"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __knownSymbol = (name5, symbol) => {
  if (symbol = Symbol[name5])
    return symbol;
  throw Error("Symbol." + name5 + " is not defined");
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod2) => function __require() {
  return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
};
var __export = (target, all4) => {
  for (var name5 in all4)
    __defProp(target, name5, { get: all4[name5], enumerable: true });
};
var __copyProps = (to, from3, except, desc) => {
  if (from3 && typeof from3 === "object" || typeof from3 === "function") {
    for (let key of __getOwnPropNames(from3))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from3[key], enumerable: !(desc = __getOwnPropDesc(from3, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", { value: mod2, enumerable: true }) : target,
  mod2
));
var __toCommonJS = (mod2) => __copyProps(__defProp({}, "__esModule", { value: true }), mod2);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var __await = function(promise, isYieldStar) {
  this[0] = promise;
  this[1] = isYieldStar;
};
var __asyncGenerator = (__this, __arguments, generator) => {
  var resume = (k, v, yes, no) => {
    try {
      var x = generator[k](v), isAwait = (v = x.value) instanceof __await, done = x.done;
      Promise.resolve(isAwait ? v[0] : v).then((y) => isAwait ? resume(k === "return" ? k : "next", v[1] ? { done: y.done, value: y.value } : y, yes, no) : yes({ value: y, done })).catch((e) => resume("throw", e, yes, no));
    } catch (e) {
      no(e);
    }
  };
  var method = (k) => it[k] = (x) => new Promise((yes, no) => resume(k, x, yes, no));
  var it = {};
  return generator = generator.apply(__this, __arguments), it[Symbol.asyncIterator] = () => it, method("next"), method("throw"), method("return"), it;
};
var __yieldStar = (value) => {
  var obj = value[__knownSymbol("asyncIterator")];
  var isAwait = false;
  var method;
  var it = {};
  if (obj == null) {
    obj = value[__knownSymbol("iterator")]();
    method = (k) => it[k] = (x) => obj[k](x);
  } else {
    obj = obj.call(value);
    method = (k) => it[k] = (v) => {
      if (isAwait) {
        isAwait = false;
        if (k === "throw")
          throw v;
        return v;
      }
      isAwait = true;
      return {
        done: false,
        value: new __await(new Promise((resolve) => {
          var x = obj[k](v);
          if (!(x instanceof Object))
            throw TypeError("Object expected");
          resolve(x);
        }), 1)
      };
    };
  }
  return it[__knownSymbol("iterator")] = () => it, method("next"), "throw" in obj ? method("throw") : it.throw = (x) => {
    throw x;
  }, "return" in obj && method("return"), it;
};
var __forAwait = (obj, it, method) => (it = obj[__knownSymbol("asyncIterator")]) ? it.call(obj) : (obj = obj[__knownSymbol("iterator")](), it = {}, method = (key, fn) => (fn = obj[key]) && (it[key] = (arg) => new Promise((yes, no, done) => (arg = fn.call(obj, arg), done = arg.done, Promise.resolve(arg.value).then((value) => yes({ value, done }), no)))), method("next"), method("return"), it);

// ../../node_modules/.pnpm/retry@0.13.1/node_modules/retry/lib/retry_operation.js
var require_retry_operation = __commonJS({
  "../../node_modules/.pnpm/retry@0.13.1/node_modules/retry/lib/retry_operation.js"(exports2, module2) {
    "use strict";
    function RetryOperation(timeouts, options) {
      if (typeof options === "boolean") {
        options = { forever: options };
      }
      this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));
      this._timeouts = timeouts;
      this._options = options || {};
      this._maxRetryTime = options && options.maxRetryTime || Infinity;
      this._fn = null;
      this._errors = [];
      this._attempts = 1;
      this._operationTimeout = null;
      this._operationTimeoutCb = null;
      this._timeout = null;
      this._operationStart = null;
      this._timer = null;
      if (this._options.forever) {
        this._cachedTimeouts = this._timeouts.slice(0);
      }
    }
    module2.exports = RetryOperation;
    RetryOperation.prototype.reset = function() {
      this._attempts = 1;
      this._timeouts = this._originalTimeouts.slice(0);
    };
    RetryOperation.prototype.stop = function() {
      if (this._timeout) {
        clearTimeout(this._timeout);
      }
      if (this._timer) {
        clearTimeout(this._timer);
      }
      this._timeouts = [];
      this._cachedTimeouts = null;
    };
    RetryOperation.prototype.retry = function(err) {
      if (this._timeout) {
        clearTimeout(this._timeout);
      }
      if (!err) {
        return false;
      }
      var currentTime = (/* @__PURE__ */ new Date()).getTime();
      if (err && currentTime - this._operationStart >= this._maxRetryTime) {
        this._errors.push(err);
        this._errors.unshift(new Error("RetryOperation timeout occurred"));
        return false;
      }
      this._errors.push(err);
      var timeout = this._timeouts.shift();
      if (timeout === void 0) {
        if (this._cachedTimeouts) {
          this._errors.splice(0, this._errors.length - 1);
          timeout = this._cachedTimeouts.slice(-1);
        } else {
          return false;
        }
      }
      var self2 = this;
      this._timer = setTimeout(function() {
        self2._attempts++;
        if (self2._operationTimeoutCb) {
          self2._timeout = setTimeout(function() {
            self2._operationTimeoutCb(self2._attempts);
          }, self2._operationTimeout);
          if (self2._options.unref) {
            self2._timeout.unref();
          }
        }
        self2._fn(self2._attempts);
      }, timeout);
      if (this._options.unref) {
        this._timer.unref();
      }
      return true;
    };
    RetryOperation.prototype.attempt = function(fn, timeoutOps) {
      this._fn = fn;
      if (timeoutOps) {
        if (timeoutOps.timeout) {
          this._operationTimeout = timeoutOps.timeout;
        }
        if (timeoutOps.cb) {
          this._operationTimeoutCb = timeoutOps.cb;
        }
      }
      var self2 = this;
      if (this._operationTimeoutCb) {
        this._timeout = setTimeout(function() {
          self2._operationTimeoutCb();
        }, self2._operationTimeout);
      }
      this._operationStart = (/* @__PURE__ */ new Date()).getTime();
      this._fn(this._attempts);
    };
    RetryOperation.prototype.try = function(fn) {
      console.log("Using RetryOperation.try() is deprecated");
      this.attempt(fn);
    };
    RetryOperation.prototype.start = function(fn) {
      console.log("Using RetryOperation.start() is deprecated");
      this.attempt(fn);
    };
    RetryOperation.prototype.start = RetryOperation.prototype.try;
    RetryOperation.prototype.errors = function() {
      return this._errors;
    };
    RetryOperation.prototype.attempts = function() {
      return this._attempts;
    };
    RetryOperation.prototype.mainError = function() {
      if (this._errors.length === 0) {
        return null;
      }
      var counts = {};
      var mainError = null;
      var mainErrorCount = 0;
      for (var i = 0; i < this._errors.length; i++) {
        var error = this._errors[i];
        var message = error.message;
        var count = (counts[message] || 0) + 1;
        counts[message] = count;
        if (count >= mainErrorCount) {
          mainError = error;
          mainErrorCount = count;
        }
      }
      return mainError;
    };
  }
});

// ../../node_modules/.pnpm/retry@0.13.1/node_modules/retry/lib/retry.js
var require_retry = __commonJS({
  "../../node_modules/.pnpm/retry@0.13.1/node_modules/retry/lib/retry.js"(exports2) {
    "use strict";
    var RetryOperation = require_retry_operation();
    exports2.operation = function(options) {
      var timeouts = exports2.timeouts(options);
      return new RetryOperation(timeouts, {
        forever: options && (options.forever || options.retries === Infinity),
        unref: options && options.unref,
        maxRetryTime: options && options.maxRetryTime
      });
    };
    exports2.timeouts = function(options) {
      if (options instanceof Array) {
        return [].concat(options);
      }
      var opts = {
        retries: 10,
        factor: 2,
        minTimeout: 1 * 1e3,
        maxTimeout: Infinity,
        randomize: false
      };
      for (var key in options) {
        opts[key] = options[key];
      }
      if (opts.minTimeout > opts.maxTimeout) {
        throw new Error("minTimeout is greater than maxTimeout");
      }
      var timeouts = [];
      for (var i = 0; i < opts.retries; i++) {
        timeouts.push(this.createTimeout(i, opts));
      }
      if (options && options.forever && !timeouts.length) {
        timeouts.push(this.createTimeout(i, opts));
      }
      timeouts.sort(function(a, b) {
        return a - b;
      });
      return timeouts;
    };
    exports2.createTimeout = function(attempt, opts) {
      var random = opts.randomize ? Math.random() + 1 : 1;
      var timeout = Math.round(random * Math.max(opts.minTimeout, 1) * Math.pow(opts.factor, attempt));
      timeout = Math.min(timeout, opts.maxTimeout);
      return timeout;
    };
    exports2.wrap = function(obj, options, methods) {
      if (options instanceof Array) {
        methods = options;
        options = null;
      }
      if (!methods) {
        methods = [];
        for (var key in obj) {
          if (typeof obj[key] === "function") {
            methods.push(key);
          }
        }
      }
      for (var i = 0; i < methods.length; i++) {
        var method = methods[i];
        var original = obj[method];
        obj[method] = function retryWrapper(original2) {
          var op = exports2.operation(options);
          var args = Array.prototype.slice.call(arguments, 1);
          var callback = args.pop();
          args.push(function(err) {
            if (op.retry(err)) {
              return;
            }
            if (err) {
              arguments[0] = op.mainError();
            }
            callback.apply(this, arguments);
          });
          op.attempt(function() {
            original2.apply(obj, args);
          });
        }.bind(obj, original);
        obj[method].options = options;
      }
    };
  }
});

// ../../node_modules/.pnpm/retry@0.13.1/node_modules/retry/index.js
var require_retry2 = __commonJS({
  "../../node_modules/.pnpm/retry@0.13.1/node_modules/retry/index.js"(exports2, module2) {
    "use strict";
    module2.exports = require_retry();
  }
});

// ../../node_modules/.pnpm/p-retry@4.6.2/node_modules/p-retry/index.js
var require_p_retry = __commonJS({
  "../../node_modules/.pnpm/p-retry@4.6.2/node_modules/p-retry/index.js"(exports2, module2) {
    "use strict";
    var retry = require_retry2();
    var networkErrorMsgs = [
      "Failed to fetch",
      // Chrome
      "NetworkError when attempting to fetch resource.",
      // Firefox
      "The Internet connection appears to be offline.",
      // Safari
      "Network request failed"
      // `cross-fetch`
    ];
    var AbortError3 = class extends Error {
      constructor(message) {
        super();
        if (message instanceof Error) {
          this.originalError = message;
          ({ message } = message);
        } else {
          this.originalError = new Error(message);
          this.originalError.stack = this.stack;
        }
        this.name = "AbortError";
        this.message = message;
      }
    };
    var decorateErrorWithCounts = (error, attemptNumber, options) => {
      const retriesLeft = options.retries - (attemptNumber - 1);
      error.attemptNumber = attemptNumber;
      error.retriesLeft = retriesLeft;
      return error;
    };
    var isNetworkError = (errorMessage) => networkErrorMsgs.includes(errorMessage);
    var pRetry2 = (input, options) => new Promise((resolve, reject) => {
      options = __spreadValues({
        onFailedAttempt: () => {
        },
        retries: 10
      }, options);
      const operation = retry.operation(options);
      operation.attempt((attemptNumber) => __async(exports2, null, function* () {
        try {
          resolve(yield input(attemptNumber));
        } catch (error) {
          if (!(error instanceof Error)) {
            reject(new TypeError(`Non-error was thrown: "${error}". You should only throw errors.`));
            return;
          }
          if (error instanceof AbortError3) {
            operation.stop();
            reject(error.originalError);
          } else if (error instanceof TypeError && !isNetworkError(error.message)) {
            operation.stop();
            reject(error);
          } else {
            decorateErrorWithCounts(error, attemptNumber, options);
            try {
              yield options.onFailedAttempt(error);
            } catch (error2) {
              reject(error2);
              return;
            }
            if (!operation.retry(error)) {
              reject(operation.mainError());
            }
          }
        }
      }));
    });
    module2.exports = pRetry2;
    module2.exports.default = pRetry2;
    module2.exports.AbortError = AbortError3;
  }
});

// ../../node_modules/.pnpm/varint@6.0.0/node_modules/varint/encode.js
var require_encode = __commonJS({
  "../../node_modules/.pnpm/varint@6.0.0/node_modules/varint/encode.js"(exports2, module2) {
    "use strict";
    module2.exports = encode12;
    var MSB2 = 128;
    var REST2 = 127;
    var MSBALL2 = ~REST2;
    var INT2 = Math.pow(2, 31);
    function encode12(num, out, offset) {
      if (Number.MAX_SAFE_INTEGER && num > Number.MAX_SAFE_INTEGER) {
        encode12.bytes = 0;
        throw new RangeError("Could not encode varint");
      }
      out = out || [];
      offset = offset || 0;
      var oldOffset = offset;
      while (num >= INT2) {
        out[offset++] = num & 255 | MSB2;
        num /= 128;
      }
      while (num & MSBALL2) {
        out[offset++] = num & 255 | MSB2;
        num >>>= 7;
      }
      out[offset] = num | 0;
      encode12.bytes = offset - oldOffset + 1;
      return out;
    }
  }
});

// ../../node_modules/.pnpm/varint@6.0.0/node_modules/varint/decode.js
var require_decode = __commonJS({
  "../../node_modules/.pnpm/varint@6.0.0/node_modules/varint/decode.js"(exports2, module2) {
    "use strict";
    module2.exports = read2;
    var MSB2 = 128;
    var REST2 = 127;
    function read2(buf2, offset) {
      var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf2.length;
      do {
        if (counter >= l || shift > 49) {
          read2.bytes = 0;
          throw new RangeError("Could not decode varint");
        }
        b = buf2[counter++];
        res += shift < 28 ? (b & REST2) << shift : (b & REST2) * Math.pow(2, shift);
        shift += 7;
      } while (b >= MSB2);
      read2.bytes = counter - offset;
      return res;
    }
  }
});

// ../../node_modules/.pnpm/varint@6.0.0/node_modules/varint/length.js
var require_length = __commonJS({
  "../../node_modules/.pnpm/varint@6.0.0/node_modules/varint/length.js"(exports2, module2) {
    "use strict";
    var N12 = Math.pow(2, 7);
    var N22 = Math.pow(2, 14);
    var N32 = Math.pow(2, 21);
    var N42 = Math.pow(2, 28);
    var N52 = Math.pow(2, 35);
    var N62 = Math.pow(2, 42);
    var N72 = Math.pow(2, 49);
    var N82 = Math.pow(2, 56);
    var N92 = Math.pow(2, 63);
    module2.exports = function(value) {
      return value < N12 ? 1 : value < N22 ? 2 : value < N32 ? 3 : value < N42 ? 4 : value < N52 ? 5 : value < N62 ? 6 : value < N72 ? 7 : value < N82 ? 8 : value < N92 ? 9 : 10;
    };
  }
});

// ../../node_modules/.pnpm/varint@6.0.0/node_modules/varint/index.js
var require_varint = __commonJS({
  "../../node_modules/.pnpm/varint@6.0.0/node_modules/varint/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      encode: require_encode(),
      decode: require_decode(),
      encodingLength: require_length()
    };
  }
});

// ../../node_modules/.pnpm/it-last@1.0.6/node_modules/it-last/index.js
var require_it_last = __commonJS({
  "../../node_modules/.pnpm/it-last@1.0.6/node_modules/it-last/index.js"(exports2, module2) {
    "use strict";
    var last2 = (source) => __async(exports2, null, function* () {
      let res;
      try {
        for (var iter = __forAwait(source), more, temp, error; more = !(temp = yield iter.next()).done; more = false) {
          const entry = temp.value;
          res = entry;
        }
      } catch (temp) {
        error = [temp];
      } finally {
        try {
          more && (temp = iter.return) && (yield temp.call(iter));
        } finally {
          if (error)
            throw error[0];
        }
      }
      return res;
    });
    module2.exports = last2;
  }
});

// ../../node_modules/.pnpm/it-pipe@1.1.0/node_modules/it-pipe/index.js
var require_it_pipe = __commonJS({
  "../../node_modules/.pnpm/it-pipe@1.1.0/node_modules/it-pipe/index.js"(exports2, module2) {
    "use strict";
    var rawPipe = (...fns) => {
      let res;
      while (fns.length) {
        res = fns.shift()(res);
      }
      return res;
    };
    var isIterable3 = (obj) => obj && (typeof obj[Symbol.asyncIterator] === "function" || typeof obj[Symbol.iterator] === "function" || typeof obj.next === "function");
    var isDuplex = (obj) => obj && typeof obj.sink === "function" && isIterable3(obj.source);
    var duplexPipelineFn = (duplex) => (source) => {
      duplex.sink(source);
      return duplex.source;
    };
    var pipe3 = (...fns) => {
      if (isDuplex(fns[0])) {
        const duplex = fns[0];
        fns[0] = () => duplex.source;
      } else if (isIterable3(fns[0])) {
        const source = fns[0];
        fns[0] = () => source;
      }
      if (fns.length > 1) {
        if (isDuplex(fns[fns.length - 1])) {
          fns[fns.length - 1] = fns[fns.length - 1].sink;
        }
      }
      if (fns.length > 2) {
        for (let i = 1; i < fns.length - 1; i++) {
          if (isDuplex(fns[i])) {
            fns[i] = duplexPipelineFn(fns[i]);
          }
        }
      }
      return rawPipe(...fns);
    };
    module2.exports = pipe3;
    module2.exports.pipe = pipe3;
    module2.exports.rawPipe = rawPipe;
    module2.exports.isIterable = isIterable3;
    module2.exports.isDuplex = isDuplex;
  }
});

// ../../node_modules/.pnpm/it-batch@1.0.9/node_modules/it-batch/index.js
var require_it_batch = __commonJS({
  "../../node_modules/.pnpm/it-batch@1.0.9/node_modules/it-batch/index.js"(exports2, module2) {
    "use strict";
    function batch3(source, size = 1) {
      return __asyncGenerator(this, null, function* () {
        let things = [];
        if (size < 1) {
          size = 1;
        }
        try {
          for (var iter = __forAwait(source), more, temp, error; more = !(temp = yield new __await(iter.next())).done; more = false) {
            const thing = temp.value;
            things.push(thing);
            while (things.length >= size) {
              yield things.slice(0, size);
              things = things.slice(size);
            }
          }
        } catch (temp) {
          error = [temp];
        } finally {
          try {
            more && (temp = iter.return) && (yield new __await(temp.call(iter)));
          } finally {
            if (error)
              throw error[0];
          }
        }
        while (things.length) {
          yield things.slice(0, size);
          things = things.slice(size);
        }
      });
    }
    module2.exports = batch3;
  }
});

// ../../node_modules/.pnpm/it-parallel-batch@1.0.11/node_modules/it-parallel-batch/index.js
var require_it_parallel_batch = __commonJS({
  "../../node_modules/.pnpm/it-parallel-batch@1.0.11/node_modules/it-parallel-batch/index.js"(exports2, module2) {
    "use strict";
    var batch3 = require_it_batch();
    function parallelBatch3(source, size = 1) {
      return __asyncGenerator(this, null, function* () {
        try {
          for (var iter = __forAwait(batch3(source, size)), more, temp, error; more = !(temp = yield new __await(iter.next())).done; more = false) {
            const tasks = temp.value;
            const things = tasks.map(
              /**
               * @param {() => Promise<T>} p
               */
              (p) => {
                return p().then((value) => ({ ok: true, value }), (err) => ({ ok: false, err }));
              }
            );
            for (let i = 0; i < things.length; i++) {
              const result = yield new __await(things[i]);
              if (result.ok) {
                yield result.value;
              } else {
                throw result.err;
              }
            }
          }
        } catch (temp) {
          error = [temp];
        } finally {
          try {
            more && (temp = iter.return) && (yield new __await(temp.call(iter)));
          } finally {
            if (error)
              throw error[0];
          }
        }
      });
    }
    module2.exports = parallelBatch3;
  }
});

// ../../node_modules/.pnpm/is-plain-obj@2.1.0/node_modules/is-plain-obj/index.js
var require_is_plain_obj = __commonJS({
  "../../node_modules/.pnpm/is-plain-obj@2.1.0/node_modules/is-plain-obj/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (value) => {
      if (Object.prototype.toString.call(value) !== "[object Object]") {
        return false;
      }
      const prototype = Object.getPrototypeOf(value);
      return prototype === null || prototype === Object.prototype;
    };
  }
});

// ../../node_modules/.pnpm/merge-options@3.0.4/node_modules/merge-options/index.js
var require_merge_options = __commonJS({
  "../../node_modules/.pnpm/merge-options@3.0.4/node_modules/merge-options/index.js"(exports2, module2) {
    "use strict";
    var isOptionObject = require_is_plain_obj();
    var { hasOwnProperty } = Object.prototype;
    var { propertyIsEnumerable } = Object;
    var defineProperty = (object, name5, value) => Object.defineProperty(object, name5, {
      value,
      writable: true,
      enumerable: true,
      configurable: true
    });
    var globalThis2 = exports2;
    var defaultMergeOptions = {
      concatArrays: false,
      ignoreUndefined: false
    };
    var getEnumerableOwnPropertyKeys = (value) => {
      const keys = [];
      for (const key in value) {
        if (hasOwnProperty.call(value, key)) {
          keys.push(key);
        }
      }
      if (Object.getOwnPropertySymbols) {
        const symbols = Object.getOwnPropertySymbols(value);
        for (const symbol of symbols) {
          if (propertyIsEnumerable.call(value, symbol)) {
            keys.push(symbol);
          }
        }
      }
      return keys;
    };
    function clone2(value) {
      if (Array.isArray(value)) {
        return cloneArray(value);
      }
      if (isOptionObject(value)) {
        return cloneOptionObject(value);
      }
      return value;
    }
    function cloneArray(array) {
      const result = array.slice(0, 0);
      getEnumerableOwnPropertyKeys(array).forEach((key) => {
        defineProperty(result, key, clone2(array[key]));
      });
      return result;
    }
    function cloneOptionObject(object) {
      const result = Object.getPrototypeOf(object) === null ? /* @__PURE__ */ Object.create(null) : {};
      getEnumerableOwnPropertyKeys(object).forEach((key) => {
        defineProperty(result, key, clone2(object[key]));
      });
      return result;
    }
    var mergeKeys = (merged, source, keys, config) => {
      keys.forEach((key) => {
        if (typeof source[key] === "undefined" && config.ignoreUndefined) {
          return;
        }
        if (key in merged && merged[key] !== Object.getPrototypeOf(merged)) {
          defineProperty(merged, key, merge(merged[key], source[key], config));
        } else {
          defineProperty(merged, key, clone2(source[key]));
        }
      });
      return merged;
    };
    var concatArrays = (merged, source, config) => {
      let result = merged.slice(0, 0);
      let resultIndex = 0;
      [merged, source].forEach((array) => {
        const indices = [];
        for (let k = 0; k < array.length; k++) {
          if (!hasOwnProperty.call(array, k)) {
            continue;
          }
          indices.push(String(k));
          if (array === merged) {
            defineProperty(result, resultIndex++, array[k]);
          } else {
            defineProperty(result, resultIndex++, clone2(array[k]));
          }
        }
        result = mergeKeys(result, array, getEnumerableOwnPropertyKeys(array).filter((key) => !indices.includes(key)), config);
      });
      return result;
    };
    function merge(merged, source, config) {
      if (config.concatArrays && Array.isArray(merged) && Array.isArray(source)) {
        return concatArrays(merged, source, config);
      }
      if (!isOptionObject(source) || !isOptionObject(merged)) {
        return clone2(source);
      }
      return mergeKeys(merged, source, getEnumerableOwnPropertyKeys(source), config);
    }
    module2.exports = function(...options) {
      const config = merge(clone2(defaultMergeOptions), this !== globalThis2 && this || {}, defaultMergeOptions);
      let merged = { _: {} };
      for (const option of options) {
        if (option === void 0) {
          continue;
        }
        if (!isOptionObject(option)) {
          throw new TypeError("`" + option + "` is not an Option Object");
        }
        merged = merge(merged, { _: option }, config);
      }
      return merged._;
    };
  }
});

// ../../node_modules/.pnpm/murmurhash3js-revisited@3.0.0/node_modules/murmurhash3js-revisited/lib/murmurHash3js.js
var require_murmurHash3js = __commonJS({
  "../../node_modules/.pnpm/murmurhash3js-revisited@3.0.0/node_modules/murmurhash3js-revisited/lib/murmurHash3js.js"(exports2, module2) {
    "use strict";
    (function(root, undefined2) {
      "use strict";
      var library = {
        "version": "3.0.0",
        "x86": {},
        "x64": {},
        "inputValidation": true
      };
      function _validBytes(bytes) {
        if (!Array.isArray(bytes) && !ArrayBuffer.isView(bytes)) {
          return false;
        }
        for (var i = 0; i < bytes.length; i++) {
          if (!Number.isInteger(bytes[i]) || bytes[i] < 0 || bytes[i] > 255) {
            return false;
          }
        }
        return true;
      }
      function _x86Multiply(m, n) {
        return (m & 65535) * n + (((m >>> 16) * n & 65535) << 16);
      }
      function _x86Rotl(m, n) {
        return m << n | m >>> 32 - n;
      }
      function _x86Fmix(h) {
        h ^= h >>> 16;
        h = _x86Multiply(h, 2246822507);
        h ^= h >>> 13;
        h = _x86Multiply(h, 3266489909);
        h ^= h >>> 16;
        return h;
      }
      function _x64Add(m, n) {
        m = [m[0] >>> 16, m[0] & 65535, m[1] >>> 16, m[1] & 65535];
        n = [n[0] >>> 16, n[0] & 65535, n[1] >>> 16, n[1] & 65535];
        var o = [0, 0, 0, 0];
        o[3] += m[3] + n[3];
        o[2] += o[3] >>> 16;
        o[3] &= 65535;
        o[2] += m[2] + n[2];
        o[1] += o[2] >>> 16;
        o[2] &= 65535;
        o[1] += m[1] + n[1];
        o[0] += o[1] >>> 16;
        o[1] &= 65535;
        o[0] += m[0] + n[0];
        o[0] &= 65535;
        return [o[0] << 16 | o[1], o[2] << 16 | o[3]];
      }
      function _x64Multiply(m, n) {
        m = [m[0] >>> 16, m[0] & 65535, m[1] >>> 16, m[1] & 65535];
        n = [n[0] >>> 16, n[0] & 65535, n[1] >>> 16, n[1] & 65535];
        var o = [0, 0, 0, 0];
        o[3] += m[3] * n[3];
        o[2] += o[3] >>> 16;
        o[3] &= 65535;
        o[2] += m[2] * n[3];
        o[1] += o[2] >>> 16;
        o[2] &= 65535;
        o[2] += m[3] * n[2];
        o[1] += o[2] >>> 16;
        o[2] &= 65535;
        o[1] += m[1] * n[3];
        o[0] += o[1] >>> 16;
        o[1] &= 65535;
        o[1] += m[2] * n[2];
        o[0] += o[1] >>> 16;
        o[1] &= 65535;
        o[1] += m[3] * n[1];
        o[0] += o[1] >>> 16;
        o[1] &= 65535;
        o[0] += m[0] * n[3] + m[1] * n[2] + m[2] * n[1] + m[3] * n[0];
        o[0] &= 65535;
        return [o[0] << 16 | o[1], o[2] << 16 | o[3]];
      }
      function _x64Rotl(m, n) {
        n %= 64;
        if (n === 32) {
          return [m[1], m[0]];
        } else if (n < 32) {
          return [m[0] << n | m[1] >>> 32 - n, m[1] << n | m[0] >>> 32 - n];
        } else {
          n -= 32;
          return [m[1] << n | m[0] >>> 32 - n, m[0] << n | m[1] >>> 32 - n];
        }
      }
      function _x64LeftShift(m, n) {
        n %= 64;
        if (n === 0) {
          return m;
        } else if (n < 32) {
          return [m[0] << n | m[1] >>> 32 - n, m[1] << n];
        } else {
          return [m[1] << n - 32, 0];
        }
      }
      function _x64Xor(m, n) {
        return [m[0] ^ n[0], m[1] ^ n[1]];
      }
      function _x64Fmix(h) {
        h = _x64Xor(h, [0, h[0] >>> 1]);
        h = _x64Multiply(h, [4283543511, 3981806797]);
        h = _x64Xor(h, [0, h[0] >>> 1]);
        h = _x64Multiply(h, [3301882366, 444984403]);
        h = _x64Xor(h, [0, h[0] >>> 1]);
        return h;
      }
      library.x86.hash32 = function(bytes, seed) {
        if (library.inputValidation && !_validBytes(bytes)) {
          return undefined2;
        }
        seed = seed || 0;
        var remainder = bytes.length % 4;
        var blocks = bytes.length - remainder;
        var h1 = seed;
        var k1 = 0;
        var c1 = 3432918353;
        var c2 = 461845907;
        for (var i = 0; i < blocks; i = i + 4) {
          k1 = bytes[i] | bytes[i + 1] << 8 | bytes[i + 2] << 16 | bytes[i + 3] << 24;
          k1 = _x86Multiply(k1, c1);
          k1 = _x86Rotl(k1, 15);
          k1 = _x86Multiply(k1, c2);
          h1 ^= k1;
          h1 = _x86Rotl(h1, 13);
          h1 = _x86Multiply(h1, 5) + 3864292196;
        }
        k1 = 0;
        switch (remainder) {
          case 3:
            k1 ^= bytes[i + 2] << 16;
          case 2:
            k1 ^= bytes[i + 1] << 8;
          case 1:
            k1 ^= bytes[i];
            k1 = _x86Multiply(k1, c1);
            k1 = _x86Rotl(k1, 15);
            k1 = _x86Multiply(k1, c2);
            h1 ^= k1;
        }
        h1 ^= bytes.length;
        h1 = _x86Fmix(h1);
        return h1 >>> 0;
      };
      library.x86.hash128 = function(bytes, seed) {
        if (library.inputValidation && !_validBytes(bytes)) {
          return undefined2;
        }
        seed = seed || 0;
        var remainder = bytes.length % 16;
        var blocks = bytes.length - remainder;
        var h1 = seed;
        var h2 = seed;
        var h3 = seed;
        var h4 = seed;
        var k1 = 0;
        var k2 = 0;
        var k3 = 0;
        var k4 = 0;
        var c1 = 597399067;
        var c2 = 2869860233;
        var c3 = 951274213;
        var c4 = 2716044179;
        for (var i = 0; i < blocks; i = i + 16) {
          k1 = bytes[i] | bytes[i + 1] << 8 | bytes[i + 2] << 16 | bytes[i + 3] << 24;
          k2 = bytes[i + 4] | bytes[i + 5] << 8 | bytes[i + 6] << 16 | bytes[i + 7] << 24;
          k3 = bytes[i + 8] | bytes[i + 9] << 8 | bytes[i + 10] << 16 | bytes[i + 11] << 24;
          k4 = bytes[i + 12] | bytes[i + 13] << 8 | bytes[i + 14] << 16 | bytes[i + 15] << 24;
          k1 = _x86Multiply(k1, c1);
          k1 = _x86Rotl(k1, 15);
          k1 = _x86Multiply(k1, c2);
          h1 ^= k1;
          h1 = _x86Rotl(h1, 19);
          h1 += h2;
          h1 = _x86Multiply(h1, 5) + 1444728091;
          k2 = _x86Multiply(k2, c2);
          k2 = _x86Rotl(k2, 16);
          k2 = _x86Multiply(k2, c3);
          h2 ^= k2;
          h2 = _x86Rotl(h2, 17);
          h2 += h3;
          h2 = _x86Multiply(h2, 5) + 197830471;
          k3 = _x86Multiply(k3, c3);
          k3 = _x86Rotl(k3, 17);
          k3 = _x86Multiply(k3, c4);
          h3 ^= k3;
          h3 = _x86Rotl(h3, 15);
          h3 += h4;
          h3 = _x86Multiply(h3, 5) + 2530024501;
          k4 = _x86Multiply(k4, c4);
          k4 = _x86Rotl(k4, 18);
          k4 = _x86Multiply(k4, c1);
          h4 ^= k4;
          h4 = _x86Rotl(h4, 13);
          h4 += h1;
          h4 = _x86Multiply(h4, 5) + 850148119;
        }
        k1 = 0;
        k2 = 0;
        k3 = 0;
        k4 = 0;
        switch (remainder) {
          case 15:
            k4 ^= bytes[i + 14] << 16;
          case 14:
            k4 ^= bytes[i + 13] << 8;
          case 13:
            k4 ^= bytes[i + 12];
            k4 = _x86Multiply(k4, c4);
            k4 = _x86Rotl(k4, 18);
            k4 = _x86Multiply(k4, c1);
            h4 ^= k4;
          case 12:
            k3 ^= bytes[i + 11] << 24;
          case 11:
            k3 ^= bytes[i + 10] << 16;
          case 10:
            k3 ^= bytes[i + 9] << 8;
          case 9:
            k3 ^= bytes[i + 8];
            k3 = _x86Multiply(k3, c3);
            k3 = _x86Rotl(k3, 17);
            k3 = _x86Multiply(k3, c4);
            h3 ^= k3;
          case 8:
            k2 ^= bytes[i + 7] << 24;
          case 7:
            k2 ^= bytes[i + 6] << 16;
          case 6:
            k2 ^= bytes[i + 5] << 8;
          case 5:
            k2 ^= bytes[i + 4];
            k2 = _x86Multiply(k2, c2);
            k2 = _x86Rotl(k2, 16);
            k2 = _x86Multiply(k2, c3);
            h2 ^= k2;
          case 4:
            k1 ^= bytes[i + 3] << 24;
          case 3:
            k1 ^= bytes[i + 2] << 16;
          case 2:
            k1 ^= bytes[i + 1] << 8;
          case 1:
            k1 ^= bytes[i];
            k1 = _x86Multiply(k1, c1);
            k1 = _x86Rotl(k1, 15);
            k1 = _x86Multiply(k1, c2);
            h1 ^= k1;
        }
        h1 ^= bytes.length;
        h2 ^= bytes.length;
        h3 ^= bytes.length;
        h4 ^= bytes.length;
        h1 += h2;
        h1 += h3;
        h1 += h4;
        h2 += h1;
        h3 += h1;
        h4 += h1;
        h1 = _x86Fmix(h1);
        h2 = _x86Fmix(h2);
        h3 = _x86Fmix(h3);
        h4 = _x86Fmix(h4);
        h1 += h2;
        h1 += h3;
        h1 += h4;
        h2 += h1;
        h3 += h1;
        h4 += h1;
        return ("00000000" + (h1 >>> 0).toString(16)).slice(-8) + ("00000000" + (h2 >>> 0).toString(16)).slice(-8) + ("00000000" + (h3 >>> 0).toString(16)).slice(-8) + ("00000000" + (h4 >>> 0).toString(16)).slice(-8);
      };
      library.x64.hash128 = function(bytes, seed) {
        if (library.inputValidation && !_validBytes(bytes)) {
          return undefined2;
        }
        seed = seed || 0;
        var remainder = bytes.length % 16;
        var blocks = bytes.length - remainder;
        var h1 = [0, seed];
        var h2 = [0, seed];
        var k1 = [0, 0];
        var k2 = [0, 0];
        var c1 = [2277735313, 289559509];
        var c2 = [1291169091, 658871167];
        for (var i = 0; i < blocks; i = i + 16) {
          k1 = [bytes[i + 4] | bytes[i + 5] << 8 | bytes[i + 6] << 16 | bytes[i + 7] << 24, bytes[i] | bytes[i + 1] << 8 | bytes[i + 2] << 16 | bytes[i + 3] << 24];
          k2 = [bytes[i + 12] | bytes[i + 13] << 8 | bytes[i + 14] << 16 | bytes[i + 15] << 24, bytes[i + 8] | bytes[i + 9] << 8 | bytes[i + 10] << 16 | bytes[i + 11] << 24];
          k1 = _x64Multiply(k1, c1);
          k1 = _x64Rotl(k1, 31);
          k1 = _x64Multiply(k1, c2);
          h1 = _x64Xor(h1, k1);
          h1 = _x64Rotl(h1, 27);
          h1 = _x64Add(h1, h2);
          h1 = _x64Add(_x64Multiply(h1, [0, 5]), [0, 1390208809]);
          k2 = _x64Multiply(k2, c2);
          k2 = _x64Rotl(k2, 33);
          k2 = _x64Multiply(k2, c1);
          h2 = _x64Xor(h2, k2);
          h2 = _x64Rotl(h2, 31);
          h2 = _x64Add(h2, h1);
          h2 = _x64Add(_x64Multiply(h2, [0, 5]), [0, 944331445]);
        }
        k1 = [0, 0];
        k2 = [0, 0];
        switch (remainder) {
          case 15:
            k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i + 14]], 48));
          case 14:
            k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i + 13]], 40));
          case 13:
            k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i + 12]], 32));
          case 12:
            k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i + 11]], 24));
          case 11:
            k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i + 10]], 16));
          case 10:
            k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i + 9]], 8));
          case 9:
            k2 = _x64Xor(k2, [0, bytes[i + 8]]);
            k2 = _x64Multiply(k2, c2);
            k2 = _x64Rotl(k2, 33);
            k2 = _x64Multiply(k2, c1);
            h2 = _x64Xor(h2, k2);
          case 8:
            k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i + 7]], 56));
          case 7:
            k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i + 6]], 48));
          case 6:
            k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i + 5]], 40));
          case 5:
            k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i + 4]], 32));
          case 4:
            k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i + 3]], 24));
          case 3:
            k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i + 2]], 16));
          case 2:
            k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i + 1]], 8));
          case 1:
            k1 = _x64Xor(k1, [0, bytes[i]]);
            k1 = _x64Multiply(k1, c1);
            k1 = _x64Rotl(k1, 31);
            k1 = _x64Multiply(k1, c2);
            h1 = _x64Xor(h1, k1);
        }
        h1 = _x64Xor(h1, [0, bytes.length]);
        h2 = _x64Xor(h2, [0, bytes.length]);
        h1 = _x64Add(h1, h2);
        h2 = _x64Add(h2, h1);
        h1 = _x64Fmix(h1);
        h2 = _x64Fmix(h2);
        h1 = _x64Add(h1, h2);
        h2 = _x64Add(h2, h1);
        return ("00000000" + (h1[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (h1[1] >>> 0).toString(16)).slice(-8) + ("00000000" + (h2[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (h2[1] >>> 0).toString(16)).slice(-8);
      };
      if (typeof exports2 !== "undefined") {
        if (typeof module2 !== "undefined" && module2.exports) {
          exports2 = module2.exports = library;
        }
        exports2.murmurHash3 = library;
      } else if (typeof define === "function" && define.amd) {
        define([], function() {
          return library;
        });
      } else {
        library._murmurHash3 = root.murmurHash3;
        library.noConflict = function() {
          root.murmurHash3 = library._murmurHash3;
          library._murmurHash3 = undefined2;
          library.noConflict = undefined2;
          return library;
        };
        root.murmurHash3 = library;
      }
    })(exports2);
  }
});

// ../../node_modules/.pnpm/murmurhash3js-revisited@3.0.0/node_modules/murmurhash3js-revisited/index.js
var require_murmurhash3js_revisited = __commonJS({
  "../../node_modules/.pnpm/murmurhash3js-revisited@3.0.0/node_modules/murmurhash3js-revisited/index.js"(exports2, module2) {
    "use strict";
    module2.exports = require_murmurHash3js();
  }
});

// ../../node_modules/.pnpm/err-code@3.0.1/node_modules/err-code/index.js
var require_err_code = __commonJS({
  "../../node_modules/.pnpm/err-code@3.0.1/node_modules/err-code/index.js"(exports2, module2) {
    "use strict";
    function assign(obj, props) {
      for (const key in props) {
        Object.defineProperty(obj, key, {
          value: props[key],
          enumerable: true,
          configurable: true
        });
      }
      return obj;
    }
    function createError(err, code5, props) {
      if (!err || typeof err === "string") {
        throw new TypeError("Please pass an Error to err-code");
      }
      if (!props) {
        props = {};
      }
      if (typeof code5 === "object") {
        props = code5;
        code5 = "";
      }
      if (code5) {
        props.code = code5;
      }
      try {
        return assign(err, props);
      } catch (_) {
        props.message = err.message;
        props.stack = err.stack;
        const ErrClass = function() {
        };
        ErrClass.prototype = Object.create(Object.getPrototypeOf(err));
        const output = assign(new ErrClass(), props);
        return output;
      }
    }
    module2.exports = createError;
  }
});

// ../../node_modules/.pnpm/@protobufjs+aspromise@1.1.2/node_modules/@protobufjs/aspromise/index.js
var require_aspromise = __commonJS({
  "../../node_modules/.pnpm/@protobufjs+aspromise@1.1.2/node_modules/@protobufjs/aspromise/index.js"(exports2, module2) {
    "use strict";
    module2.exports = asPromise;
    function asPromise(fn, ctx) {
      var params = new Array(arguments.length - 1), offset = 0, index = 2, pending = true;
      while (index < arguments.length)
        params[offset++] = arguments[index++];
      return new Promise(function executor(resolve, reject) {
        params[offset] = function callback(err) {
          if (pending) {
            pending = false;
            if (err)
              reject(err);
            else {
              var params2 = new Array(arguments.length - 1), offset2 = 0;
              while (offset2 < params2.length)
                params2[offset2++] = arguments[offset2];
              resolve.apply(null, params2);
            }
          }
        };
        try {
          fn.apply(ctx || null, params);
        } catch (err) {
          if (pending) {
            pending = false;
            reject(err);
          }
        }
      });
    }
  }
});

// ../../node_modules/.pnpm/@protobufjs+base64@1.1.2/node_modules/@protobufjs/base64/index.js
var require_base64 = __commonJS({
  "../../node_modules/.pnpm/@protobufjs+base64@1.1.2/node_modules/@protobufjs/base64/index.js"(exports2) {
    "use strict";
    var base642 = exports2;
    base642.length = function length2(string2) {
      var p = string2.length;
      if (!p)
        return 0;
      var n = 0;
      while (--p % 4 > 1 && string2.charAt(p) === "=")
        ++n;
      return Math.ceil(string2.length * 3) / 4 - n;
    };
    var b64 = new Array(64);
    var s64 = new Array(123);
    for (i = 0; i < 64; )
      s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;
    var i;
    base642.encode = function encode12(buffer2, start, end) {
      var parts = null, chunk = [];
      var i2 = 0, j = 0, t;
      while (start < end) {
        var b = buffer2[start++];
        switch (j) {
          case 0:
            chunk[i2++] = b64[b >> 2];
            t = (b & 3) << 4;
            j = 1;
            break;
          case 1:
            chunk[i2++] = b64[t | b >> 4];
            t = (b & 15) << 2;
            j = 2;
            break;
          case 2:
            chunk[i2++] = b64[t | b >> 6];
            chunk[i2++] = b64[b & 63];
            j = 0;
            break;
        }
        if (i2 > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i2 = 0;
        }
      }
      if (j) {
        chunk[i2++] = b64[t];
        chunk[i2++] = 61;
        if (j === 1)
          chunk[i2++] = 61;
      }
      if (parts) {
        if (i2)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i2)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i2));
    };
    var invalidEncoding = "invalid encoding";
    base642.decode = function decode12(string2, buffer2, offset) {
      var start = offset;
      var j = 0, t;
      for (var i2 = 0; i2 < string2.length; ) {
        var c = string2.charCodeAt(i2++);
        if (c === 61 && j > 1)
          break;
        if ((c = s64[c]) === void 0)
          throw Error(invalidEncoding);
        switch (j) {
          case 0:
            t = c;
            j = 1;
            break;
          case 1:
            buffer2[offset++] = t << 2 | (c & 48) >> 4;
            t = c;
            j = 2;
            break;
          case 2:
            buffer2[offset++] = (t & 15) << 4 | (c & 60) >> 2;
            t = c;
            j = 3;
            break;
          case 3:
            buffer2[offset++] = (t & 3) << 6 | c;
            j = 0;
            break;
        }
      }
      if (j === 1)
        throw Error(invalidEncoding);
      return offset - start;
    };
    base642.test = function test(string2) {
      return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string2);
    };
  }
});

// ../../node_modules/.pnpm/@protobufjs+eventemitter@1.1.0/node_modules/@protobufjs/eventemitter/index.js
var require_eventemitter = __commonJS({
  "../../node_modules/.pnpm/@protobufjs+eventemitter@1.1.0/node_modules/@protobufjs/eventemitter/index.js"(exports2, module2) {
    "use strict";
    module2.exports = EventEmitter;
    function EventEmitter() {
      this._listeners = {};
    }
    EventEmitter.prototype.on = function on(evt, fn, ctx) {
      (this._listeners[evt] || (this._listeners[evt] = [])).push({
        fn,
        ctx: ctx || this
      });
      return this;
    };
    EventEmitter.prototype.off = function off(evt, fn) {
      if (evt === void 0)
        this._listeners = {};
      else {
        if (fn === void 0)
          this._listeners[evt] = [];
        else {
          var listeners = this._listeners[evt];
          for (var i = 0; i < listeners.length; )
            if (listeners[i].fn === fn)
              listeners.splice(i, 1);
            else
              ++i;
        }
      }
      return this;
    };
    EventEmitter.prototype.emit = function emit(evt) {
      var listeners = this._listeners[evt];
      if (listeners) {
        var args = [], i = 1;
        for (; i < arguments.length; )
          args.push(arguments[i++]);
        for (i = 0; i < listeners.length; )
          listeners[i].fn.apply(listeners[i++].ctx, args);
      }
      return this;
    };
  }
});

// ../../node_modules/.pnpm/@protobufjs+float@1.0.2/node_modules/@protobufjs/float/index.js
var require_float = __commonJS({
  "../../node_modules/.pnpm/@protobufjs+float@1.0.2/node_modules/@protobufjs/float/index.js"(exports2, module2) {
    "use strict";
    module2.exports = factory(factory);
    function factory(exports3) {
      if (typeof Float32Array !== "undefined")
        (function() {
          var f32 = new Float32Array([-0]), f8b = new Uint8Array(f32.buffer), le = f8b[3] === 128;
          function writeFloat_f32_cpy(val, buf2, pos) {
            f32[0] = val;
            buf2[pos] = f8b[0];
            buf2[pos + 1] = f8b[1];
            buf2[pos + 2] = f8b[2];
            buf2[pos + 3] = f8b[3];
          }
          function writeFloat_f32_rev(val, buf2, pos) {
            f32[0] = val;
            buf2[pos] = f8b[3];
            buf2[pos + 1] = f8b[2];
            buf2[pos + 2] = f8b[1];
            buf2[pos + 3] = f8b[0];
          }
          exports3.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
          exports3.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;
          function readFloat_f32_cpy(buf2, pos) {
            f8b[0] = buf2[pos];
            f8b[1] = buf2[pos + 1];
            f8b[2] = buf2[pos + 2];
            f8b[3] = buf2[pos + 3];
            return f32[0];
          }
          function readFloat_f32_rev(buf2, pos) {
            f8b[3] = buf2[pos];
            f8b[2] = buf2[pos + 1];
            f8b[1] = buf2[pos + 2];
            f8b[0] = buf2[pos + 3];
            return f32[0];
          }
          exports3.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
          exports3.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;
        })();
      else
        (function() {
          function writeFloat_ieee754(writeUint, val, buf2, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
              val = -val;
            if (val === 0)
              writeUint(1 / val > 0 ? (
                /* positive */
                0
              ) : (
                /* negative 0 */
                2147483648
              ), buf2, pos);
            else if (isNaN(val))
              writeUint(2143289344, buf2, pos);
            else if (val > 34028234663852886e22)
              writeUint((sign << 31 | 2139095040) >>> 0, buf2, pos);
            else if (val < 11754943508222875e-54)
              writeUint((sign << 31 | Math.round(val / 1401298464324817e-60)) >>> 0, buf2, pos);
            else {
              var exponent = Math.floor(Math.log(val) / Math.LN2), mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
              writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf2, pos);
            }
          }
          exports3.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
          exports3.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);
          function readFloat_ieee754(readUint, buf2, pos) {
            var uint = readUint(buf2, pos), sign = (uint >> 31) * 2 + 1, exponent = uint >>> 23 & 255, mantissa = uint & 8388607;
            return exponent === 255 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 1401298464324817e-60 * mantissa : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
          }
          exports3.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
          exports3.readFloatBE = readFloat_ieee754.bind(null, readUintBE);
        })();
      if (typeof Float64Array !== "undefined")
        (function() {
          var f64 = new Float64Array([-0]), f8b = new Uint8Array(f64.buffer), le = f8b[7] === 128;
          function writeDouble_f64_cpy(val, buf2, pos) {
            f64[0] = val;
            buf2[pos] = f8b[0];
            buf2[pos + 1] = f8b[1];
            buf2[pos + 2] = f8b[2];
            buf2[pos + 3] = f8b[3];
            buf2[pos + 4] = f8b[4];
            buf2[pos + 5] = f8b[5];
            buf2[pos + 6] = f8b[6];
            buf2[pos + 7] = f8b[7];
          }
          function writeDouble_f64_rev(val, buf2, pos) {
            f64[0] = val;
            buf2[pos] = f8b[7];
            buf2[pos + 1] = f8b[6];
            buf2[pos + 2] = f8b[5];
            buf2[pos + 3] = f8b[4];
            buf2[pos + 4] = f8b[3];
            buf2[pos + 5] = f8b[2];
            buf2[pos + 6] = f8b[1];
            buf2[pos + 7] = f8b[0];
          }
          exports3.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
          exports3.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;
          function readDouble_f64_cpy(buf2, pos) {
            f8b[0] = buf2[pos];
            f8b[1] = buf2[pos + 1];
            f8b[2] = buf2[pos + 2];
            f8b[3] = buf2[pos + 3];
            f8b[4] = buf2[pos + 4];
            f8b[5] = buf2[pos + 5];
            f8b[6] = buf2[pos + 6];
            f8b[7] = buf2[pos + 7];
            return f64[0];
          }
          function readDouble_f64_rev(buf2, pos) {
            f8b[7] = buf2[pos];
            f8b[6] = buf2[pos + 1];
            f8b[5] = buf2[pos + 2];
            f8b[4] = buf2[pos + 3];
            f8b[3] = buf2[pos + 4];
            f8b[2] = buf2[pos + 5];
            f8b[1] = buf2[pos + 6];
            f8b[0] = buf2[pos + 7];
            return f64[0];
          }
          exports3.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
          exports3.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;
        })();
      else
        (function() {
          function writeDouble_ieee754(writeUint, off0, off1, val, buf2, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
              val = -val;
            if (val === 0) {
              writeUint(0, buf2, pos + off0);
              writeUint(1 / val > 0 ? (
                /* positive */
                0
              ) : (
                /* negative 0 */
                2147483648
              ), buf2, pos + off1);
            } else if (isNaN(val)) {
              writeUint(0, buf2, pos + off0);
              writeUint(2146959360, buf2, pos + off1);
            } else if (val > 17976931348623157e292) {
              writeUint(0, buf2, pos + off0);
              writeUint((sign << 31 | 2146435072) >>> 0, buf2, pos + off1);
            } else {
              var mantissa;
              if (val < 22250738585072014e-324) {
                mantissa = val / 5e-324;
                writeUint(mantissa >>> 0, buf2, pos + off0);
                writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf2, pos + off1);
              } else {
                var exponent = Math.floor(Math.log(val) / Math.LN2);
                if (exponent === 1024)
                  exponent = 1023;
                mantissa = val * Math.pow(2, -exponent);
                writeUint(mantissa * 4503599627370496 >>> 0, buf2, pos + off0);
                writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf2, pos + off1);
              }
            }
          }
          exports3.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
          exports3.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);
          function readDouble_ieee754(readUint, off0, off1, buf2, pos) {
            var lo = readUint(buf2, pos + off0), hi = readUint(buf2, pos + off1);
            var sign = (hi >> 31) * 2 + 1, exponent = hi >>> 20 & 2047, mantissa = 4294967296 * (hi & 1048575) + lo;
            return exponent === 2047 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 5e-324 * mantissa : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
          }
          exports3.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
          exports3.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);
        })();
      return exports3;
    }
    function writeUintLE(val, buf2, pos) {
      buf2[pos] = val & 255;
      buf2[pos + 1] = val >>> 8 & 255;
      buf2[pos + 2] = val >>> 16 & 255;
      buf2[pos + 3] = val >>> 24;
    }
    function writeUintBE(val, buf2, pos) {
      buf2[pos] = val >>> 24;
      buf2[pos + 1] = val >>> 16 & 255;
      buf2[pos + 2] = val >>> 8 & 255;
      buf2[pos + 3] = val & 255;
    }
    function readUintLE(buf2, pos) {
      return (buf2[pos] | buf2[pos + 1] << 8 | buf2[pos + 2] << 16 | buf2[pos + 3] << 24) >>> 0;
    }
    function readUintBE(buf2, pos) {
      return (buf2[pos] << 24 | buf2[pos + 1] << 16 | buf2[pos + 2] << 8 | buf2[pos + 3]) >>> 0;
    }
  }
});

// ../../node_modules/.pnpm/@protobufjs+inquire@1.1.0/node_modules/@protobufjs/inquire/index.js
var require_inquire = __commonJS({
  "../../node_modules/.pnpm/@protobufjs+inquire@1.1.0/node_modules/@protobufjs/inquire/index.js"(exports, module) {
    "use strict";
    module.exports = inquire;
    function inquire(moduleName) {
      try {
        var mod = eval("quire".replace(/^/, "re"))(moduleName);
        if (mod && (mod.length || Object.keys(mod).length))
          return mod;
      } catch (e) {
      }
      return null;
    }
  }
});

// ../../node_modules/.pnpm/@protobufjs+utf8@1.1.0/node_modules/@protobufjs/utf8/index.js
var require_utf8 = __commonJS({
  "../../node_modules/.pnpm/@protobufjs+utf8@1.1.0/node_modules/@protobufjs/utf8/index.js"(exports2) {
    "use strict";
    var utf8 = exports2;
    utf8.length = function utf8_length(string2) {
      var len = 0, c = 0;
      for (var i = 0; i < string2.length; ++i) {
        c = string2.charCodeAt(i);
        if (c < 128)
          len += 1;
        else if (c < 2048)
          len += 2;
        else if ((c & 64512) === 55296 && (string2.charCodeAt(i + 1) & 64512) === 56320) {
          ++i;
          len += 4;
        } else
          len += 3;
      }
      return len;
    };
    utf8.read = function utf8_read(buffer2, start, end) {
      var len = end - start;
      if (len < 1)
        return "";
      var parts = null, chunk = [], i = 0, t;
      while (start < end) {
        t = buffer2[start++];
        if (t < 128)
          chunk[i++] = t;
        else if (t > 191 && t < 224)
          chunk[i++] = (t & 31) << 6 | buffer2[start++] & 63;
        else if (t > 239 && t < 365) {
          t = ((t & 7) << 18 | (buffer2[start++] & 63) << 12 | (buffer2[start++] & 63) << 6 | buffer2[start++] & 63) - 65536;
          chunk[i++] = 55296 + (t >> 10);
          chunk[i++] = 56320 + (t & 1023);
        } else
          chunk[i++] = (t & 15) << 12 | (buffer2[start++] & 63) << 6 | buffer2[start++] & 63;
        if (i > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i = 0;
        }
      }
      if (parts) {
        if (i)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i));
    };
    utf8.write = function utf8_write(string2, buffer2, offset) {
      var start = offset, c1, c2;
      for (var i = 0; i < string2.length; ++i) {
        c1 = string2.charCodeAt(i);
        if (c1 < 128) {
          buffer2[offset++] = c1;
        } else if (c1 < 2048) {
          buffer2[offset++] = c1 >> 6 | 192;
          buffer2[offset++] = c1 & 63 | 128;
        } else if ((c1 & 64512) === 55296 && ((c2 = string2.charCodeAt(i + 1)) & 64512) === 56320) {
          c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
          ++i;
          buffer2[offset++] = c1 >> 18 | 240;
          buffer2[offset++] = c1 >> 12 & 63 | 128;
          buffer2[offset++] = c1 >> 6 & 63 | 128;
          buffer2[offset++] = c1 & 63 | 128;
        } else {
          buffer2[offset++] = c1 >> 12 | 224;
          buffer2[offset++] = c1 >> 6 & 63 | 128;
          buffer2[offset++] = c1 & 63 | 128;
        }
      }
      return offset - start;
    };
  }
});

// ../../node_modules/.pnpm/@protobufjs+pool@1.1.0/node_modules/@protobufjs/pool/index.js
var require_pool = __commonJS({
  "../../node_modules/.pnpm/@protobufjs+pool@1.1.0/node_modules/@protobufjs/pool/index.js"(exports2, module2) {
    "use strict";
    module2.exports = pool;
    function pool(alloc2, slice2, size) {
      var SIZE = size || 8192;
      var MAX = SIZE >>> 1;
      var slab = null;
      var offset = SIZE;
      return function pool_alloc(size2) {
        if (size2 < 1 || size2 > MAX)
          return alloc2(size2);
        if (offset + size2 > SIZE) {
          slab = alloc2(SIZE);
          offset = 0;
        }
        var buf2 = slice2.call(slab, offset, offset += size2);
        if (offset & 7)
          offset = (offset | 7) + 1;
        return buf2;
      };
    }
  }
});

// ../../node_modules/.pnpm/protobufjs@6.11.4/node_modules/protobufjs/src/util/longbits.js
var require_longbits = __commonJS({
  "../../node_modules/.pnpm/protobufjs@6.11.4/node_modules/protobufjs/src/util/longbits.js"(exports2, module2) {
    "use strict";
    module2.exports = LongBits;
    var util = require_minimal();
    function LongBits(lo, hi) {
      this.lo = lo >>> 0;
      this.hi = hi >>> 0;
    }
    var zero = LongBits.zero = new LongBits(0, 0);
    zero.toNumber = function() {
      return 0;
    };
    zero.zzEncode = zero.zzDecode = function() {
      return this;
    };
    zero.length = function() {
      return 1;
    };
    var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";
    LongBits.fromNumber = function fromNumber(value) {
      if (value === 0)
        return zero;
      var sign = value < 0;
      if (sign)
        value = -value;
      var lo = value >>> 0, hi = (value - lo) / 4294967296 >>> 0;
      if (sign) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
          lo = 0;
          if (++hi > 4294967295)
            hi = 0;
        }
      }
      return new LongBits(lo, hi);
    };
    LongBits.from = function from3(value) {
      if (typeof value === "number")
        return LongBits.fromNumber(value);
      if (util.isString(value)) {
        if (util.Long)
          value = util.Long.fromString(value);
        else
          return LongBits.fromNumber(parseInt(value, 10));
      }
      return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
    };
    LongBits.prototype.toNumber = function toNumber(unsigned) {
      if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;
        if (!lo)
          hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
      }
      return this.lo + this.hi * 4294967296;
    };
    LongBits.prototype.toLong = function toLong(unsigned) {
      return util.Long ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
    };
    var charCodeAt = String.prototype.charCodeAt;
    LongBits.fromHash = function fromHash(hash) {
      if (hash === zeroHash)
        return zero;
      return new LongBits(
        (charCodeAt.call(hash, 0) | charCodeAt.call(hash, 1) << 8 | charCodeAt.call(hash, 2) << 16 | charCodeAt.call(hash, 3) << 24) >>> 0,
        (charCodeAt.call(hash, 4) | charCodeAt.call(hash, 5) << 8 | charCodeAt.call(hash, 6) << 16 | charCodeAt.call(hash, 7) << 24) >>> 0
      );
    };
    LongBits.prototype.toHash = function toHash() {
      return String.fromCharCode(
        this.lo & 255,
        this.lo >>> 8 & 255,
        this.lo >>> 16 & 255,
        this.lo >>> 24,
        this.hi & 255,
        this.hi >>> 8 & 255,
        this.hi >>> 16 & 255,
        this.hi >>> 24
      );
    };
    LongBits.prototype.zzEncode = function zzEncode() {
      var mask = this.hi >> 31;
      this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
      this.lo = (this.lo << 1 ^ mask) >>> 0;
      return this;
    };
    LongBits.prototype.zzDecode = function zzDecode() {
      var mask = -(this.lo & 1);
      this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
      this.hi = (this.hi >>> 1 ^ mask) >>> 0;
      return this;
    };
    LongBits.prototype.length = function length2() {
      var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;
      return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
    };
  }
});

// ../../node_modules/.pnpm/protobufjs@6.11.4/node_modules/protobufjs/src/util/minimal.js
var require_minimal = __commonJS({
  "../../node_modules/.pnpm/protobufjs@6.11.4/node_modules/protobufjs/src/util/minimal.js"(exports2) {
    "use strict";
    var util = exports2;
    util.asPromise = require_aspromise();
    util.base64 = require_base64();
    util.EventEmitter = require_eventemitter();
    util.float = require_float();
    util.inquire = require_inquire();
    util.utf8 = require_utf8();
    util.pool = require_pool();
    util.LongBits = require_longbits();
    util.isNode = Boolean(typeof global !== "undefined" && global && global.process && global.process.versions && global.process.versions.node);
    util.global = util.isNode && global || typeof window !== "undefined" && window || typeof self !== "undefined" && self || exports2;
    util.emptyArray = Object.freeze ? Object.freeze([]) : (
      /* istanbul ignore next */
      []
    );
    util.emptyObject = Object.freeze ? Object.freeze({}) : (
      /* istanbul ignore next */
      {}
    );
    util.isInteger = Number.isInteger || /* istanbul ignore next */
    function isInteger(value) {
      return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
    };
    util.isString = function isString(value) {
      return typeof value === "string" || value instanceof String;
    };
    util.isObject = function isObject3(value) {
      return value && typeof value === "object";
    };
    util.isset = /**
     * Checks if a property on a message is considered to be present.
     * @param {Object} obj Plain object or message instance
     * @param {string} prop Property name
     * @returns {boolean} `true` if considered to be present, otherwise `false`
     */
    util.isSet = function isSet(obj, prop) {
      var value = obj[prop];
      if (value != null && obj.hasOwnProperty(prop))
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
      return false;
    };
    util.Buffer = function() {
      try {
        var Buffer3 = util.inquire("buffer").Buffer;
        return Buffer3.prototype.utf8Write ? Buffer3 : (
          /* istanbul ignore next */
          null
        );
      } catch (e) {
        return null;
      }
    }();
    util._Buffer_from = null;
    util._Buffer_allocUnsafe = null;
    util.newBuffer = function newBuffer(sizeOrArray) {
      return typeof sizeOrArray === "number" ? util.Buffer ? util._Buffer_allocUnsafe(sizeOrArray) : new util.Array(sizeOrArray) : util.Buffer ? util._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
    };
    util.Array = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    util.Long = /* istanbul ignore next */
    util.global.dcodeIO && /* istanbul ignore next */
    util.global.dcodeIO.Long || /* istanbul ignore next */
    util.global.Long || util.inquire("long");
    util.key2Re = /^true|false|0|1$/;
    util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
    util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
    util.longToHash = function longToHash(value) {
      return value ? util.LongBits.from(value).toHash() : util.LongBits.zeroHash;
    };
    util.longFromHash = function longFromHash(hash, unsigned) {
      var bits = util.LongBits.fromHash(hash);
      if (util.Long)
        return util.Long.fromBits(bits.lo, bits.hi, unsigned);
      return bits.toNumber(Boolean(unsigned));
    };
    function merge(dst, src2, ifNotSet) {
      for (var keys = Object.keys(src2), i = 0; i < keys.length; ++i)
        if (dst[keys[i]] === void 0 || !ifNotSet)
          dst[keys[i]] = src2[keys[i]];
      return dst;
    }
    util.merge = merge;
    util.lcFirst = function lcFirst(str) {
      return str.charAt(0).toLowerCase() + str.substring(1);
    };
    function newError(name5) {
      function CustomError(message, properties) {
        if (!(this instanceof CustomError))
          return new CustomError(message, properties);
        Object.defineProperty(this, "message", { get: function() {
          return message;
        } });
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, CustomError);
        else
          Object.defineProperty(this, "stack", { value: new Error().stack || "" });
        if (properties)
          merge(this, properties);
      }
      (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;
      Object.defineProperty(CustomError.prototype, "name", { get: function() {
        return name5;
      } });
      CustomError.prototype.toString = function toString3() {
        return this.name + ": " + this.message;
      };
      return CustomError;
    }
    util.newError = newError;
    util.ProtocolError = newError("ProtocolError");
    util.oneOfGetter = function getOneOf(fieldNames) {
      var fieldMap = {};
      for (var i = 0; i < fieldNames.length; ++i)
        fieldMap[fieldNames[i]] = 1;
      return function() {
        for (var keys = Object.keys(this), i2 = keys.length - 1; i2 > -1; --i2)
          if (fieldMap[keys[i2]] === 1 && this[keys[i2]] !== void 0 && this[keys[i2]] !== null)
            return keys[i2];
      };
    };
    util.oneOfSetter = function setOneOf(fieldNames) {
      return function(name5) {
        for (var i = 0; i < fieldNames.length; ++i)
          if (fieldNames[i] !== name5)
            delete this[fieldNames[i]];
      };
    };
    util.toJSONOptions = {
      longs: String,
      enums: String,
      bytes: String,
      json: true
    };
    util._configure = function() {
      var Buffer3 = util.Buffer;
      if (!Buffer3) {
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
      }
      util._Buffer_from = Buffer3.from !== Uint8Array.from && Buffer3.from || /* istanbul ignore next */
      function Buffer_from(value, encoding) {
        return new Buffer3(value, encoding);
      };
      util._Buffer_allocUnsafe = Buffer3.allocUnsafe || /* istanbul ignore next */
      function Buffer_allocUnsafe(size) {
        return new Buffer3(size);
      };
    };
  }
});

// ../../node_modules/.pnpm/protobufjs@6.11.4/node_modules/protobufjs/src/writer.js
var require_writer = __commonJS({
  "../../node_modules/.pnpm/protobufjs@6.11.4/node_modules/protobufjs/src/writer.js"(exports2, module2) {
    "use strict";
    module2.exports = Writer;
    var util = require_minimal();
    var BufferWriter;
    var LongBits = util.LongBits;
    var base642 = util.base64;
    var utf8 = util.utf8;
    function Op(fn, len, val) {
      this.fn = fn;
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    function noop3() {
    }
    function State(writer) {
      this.head = writer.head;
      this.tail = writer.tail;
      this.len = writer.len;
      this.next = writer.states;
    }
    function Writer() {
      this.len = 0;
      this.head = new Op(noop3, 0, 0);
      this.tail = this.head;
      this.states = null;
    }
    var create4 = function create5() {
      return util.Buffer ? function create_buffer_setup() {
        return (Writer.create = function create_buffer() {
          return new BufferWriter();
        })();
      } : function create_array() {
        return new Writer();
      };
    };
    Writer.create = create4();
    Writer.alloc = function alloc2(size) {
      return new util.Array(size);
    };
    if (util.Array !== Array)
      Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);
    Writer.prototype._push = function push(fn, len, val) {
      this.tail = this.tail.next = new Op(fn, len, val);
      this.len += len;
      return this;
    };
    function writeByte(val, buf2, pos) {
      buf2[pos] = val & 255;
    }
    function writeVarint32(val, buf2, pos) {
      while (val > 127) {
        buf2[pos++] = val & 127 | 128;
        val >>>= 7;
      }
      buf2[pos] = val;
    }
    function VarintOp(len, val) {
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    VarintOp.prototype = Object.create(Op.prototype);
    VarintOp.prototype.fn = writeVarint32;
    Writer.prototype.uint32 = function write_uint32(value) {
      this.len += (this.tail = this.tail.next = new VarintOp(
        (value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5,
        value
      )).len;
      return this;
    };
    Writer.prototype.int32 = function write_int32(value) {
      return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) : this.uint32(value);
    };
    Writer.prototype.sint32 = function write_sint32(value) {
      return this.uint32((value << 1 ^ value >> 31) >>> 0);
    };
    function writeVarint64(val, buf2, pos) {
      while (val.hi) {
        buf2[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
      }
      while (val.lo > 127) {
        buf2[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
      }
      buf2[pos++] = val.lo;
    }
    Writer.prototype.uint64 = function write_uint64(value) {
      var bits = LongBits.from(value);
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer.prototype.int64 = Writer.prototype.uint64;
    Writer.prototype.sint64 = function write_sint64(value) {
      var bits = LongBits.from(value).zzEncode();
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer.prototype.bool = function write_bool(value) {
      return this._push(writeByte, 1, value ? 1 : 0);
    };
    function writeFixed32(val, buf2, pos) {
      buf2[pos] = val & 255;
      buf2[pos + 1] = val >>> 8 & 255;
      buf2[pos + 2] = val >>> 16 & 255;
      buf2[pos + 3] = val >>> 24;
    }
    Writer.prototype.fixed32 = function write_fixed32(value) {
      return this._push(writeFixed32, 4, value >>> 0);
    };
    Writer.prototype.sfixed32 = Writer.prototype.fixed32;
    Writer.prototype.fixed64 = function write_fixed64(value) {
      var bits = LongBits.from(value);
      return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
    };
    Writer.prototype.sfixed64 = Writer.prototype.fixed64;
    Writer.prototype.float = function write_float(value) {
      return this._push(util.float.writeFloatLE, 4, value);
    };
    Writer.prototype.double = function write_double(value) {
      return this._push(util.float.writeDoubleLE, 8, value);
    };
    var writeBytes2 = util.Array.prototype.set ? function writeBytes_set(val, buf2, pos) {
      buf2.set(val, pos);
    } : function writeBytes_for(val, buf2, pos) {
      for (var i = 0; i < val.length; ++i)
        buf2[pos + i] = val[i];
    };
    Writer.prototype.bytes = function write_bytes(value) {
      var len = value.length >>> 0;
      if (!len)
        return this._push(writeByte, 1, 0);
      if (util.isString(value)) {
        var buf2 = Writer.alloc(len = base642.length(value));
        base642.decode(value, buf2, 0);
        value = buf2;
      }
      return this.uint32(len)._push(writeBytes2, len, value);
    };
    Writer.prototype.string = function write_string(value) {
      var len = utf8.length(value);
      return len ? this.uint32(len)._push(utf8.write, len, value) : this._push(writeByte, 1, 0);
    };
    Writer.prototype.fork = function fork() {
      this.states = new State(this);
      this.head = this.tail = new Op(noop3, 0, 0);
      this.len = 0;
      return this;
    };
    Writer.prototype.reset = function reset() {
      if (this.states) {
        this.head = this.states.head;
        this.tail = this.states.tail;
        this.len = this.states.len;
        this.states = this.states.next;
      } else {
        this.head = this.tail = new Op(noop3, 0, 0);
        this.len = 0;
      }
      return this;
    };
    Writer.prototype.ldelim = function ldelim() {
      var head = this.head, tail = this.tail, len = this.len;
      this.reset().uint32(len);
      if (len) {
        this.tail.next = head.next;
        this.tail = tail;
        this.len += len;
      }
      return this;
    };
    Writer.prototype.finish = function finish() {
      var head = this.head.next, buf2 = this.constructor.alloc(this.len), pos = 0;
      while (head) {
        head.fn(head.val, buf2, pos);
        pos += head.len;
        head = head.next;
      }
      return buf2;
    };
    Writer._configure = function(BufferWriter_) {
      BufferWriter = BufferWriter_;
      Writer.create = create4();
      BufferWriter._configure();
    };
  }
});

// ../../node_modules/.pnpm/protobufjs@6.11.4/node_modules/protobufjs/src/writer_buffer.js
var require_writer_buffer = __commonJS({
  "../../node_modules/.pnpm/protobufjs@6.11.4/node_modules/protobufjs/src/writer_buffer.js"(exports2, module2) {
    "use strict";
    module2.exports = BufferWriter;
    var Writer = require_writer();
    (BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
    var util = require_minimal();
    function BufferWriter() {
      Writer.call(this);
    }
    BufferWriter._configure = function() {
      BufferWriter.alloc = util._Buffer_allocUnsafe;
      BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === "set" ? function writeBytesBuffer_set(val, buf2, pos) {
        buf2.set(val, pos);
      } : function writeBytesBuffer_copy(val, buf2, pos) {
        if (val.copy)
          val.copy(buf2, pos, 0, val.length);
        else
          for (var i = 0; i < val.length; )
            buf2[pos++] = val[i++];
      };
    };
    BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
      if (util.isString(value))
        value = util._Buffer_from(value, "base64");
      var len = value.length >>> 0;
      this.uint32(len);
      if (len)
        this._push(BufferWriter.writeBytesBuffer, len, value);
      return this;
    };
    function writeStringBuffer(val, buf2, pos) {
      if (val.length < 40)
        util.utf8.write(val, buf2, pos);
      else if (buf2.utf8Write)
        buf2.utf8Write(val, pos);
      else
        buf2.write(val, pos);
    }
    BufferWriter.prototype.string = function write_string_buffer(value) {
      var len = util.Buffer.byteLength(value);
      this.uint32(len);
      if (len)
        this._push(writeStringBuffer, len, value);
      return this;
    };
    BufferWriter._configure();
  }
});

// ../../node_modules/.pnpm/protobufjs@6.11.4/node_modules/protobufjs/src/reader.js
var require_reader = __commonJS({
  "../../node_modules/.pnpm/protobufjs@6.11.4/node_modules/protobufjs/src/reader.js"(exports2, module2) {
    "use strict";
    module2.exports = Reader;
    var util = require_minimal();
    var BufferReader;
    var LongBits = util.LongBits;
    var utf8 = util.utf8;
    function indexOutOfRange(reader, writeLength) {
      return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
    }
    function Reader(buffer2) {
      this.buf = buffer2;
      this.pos = 0;
      this.len = buffer2.length;
    }
    var create_array = typeof Uint8Array !== "undefined" ? function create_typed_array(buffer2) {
      if (buffer2 instanceof Uint8Array || Array.isArray(buffer2))
        return new Reader(buffer2);
      throw Error("illegal buffer");
    } : function create_array2(buffer2) {
      if (Array.isArray(buffer2))
        return new Reader(buffer2);
      throw Error("illegal buffer");
    };
    var create4 = function create5() {
      return util.Buffer ? function create_buffer_setup(buffer2) {
        return (Reader.create = function create_buffer(buffer3) {
          return util.Buffer.isBuffer(buffer3) ? new BufferReader(buffer3) : create_array(buffer3);
        })(buffer2);
      } : create_array;
    };
    Reader.create = create4();
    Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */
    util.Array.prototype.slice;
    Reader.prototype.uint32 = function read_uint32_setup() {
      var value = 4294967295;
      return function read_uint32() {
        value = (this.buf[this.pos] & 127) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        if ((this.pos += 5) > this.len) {
          this.pos = this.len;
          throw indexOutOfRange(this, 10);
        }
        return value;
      };
    }();
    Reader.prototype.int32 = function read_int32() {
      return this.uint32() | 0;
    };
    Reader.prototype.sint32 = function read_sint32() {
      var value = this.uint32();
      return value >>> 1 ^ -(value & 1) | 0;
    };
    function readLongVarint() {
      var bits = new LongBits(0, 0);
      var i = 0;
      if (this.len - this.pos > 4) {
        for (; i < 4; ++i) {
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits;
        i = 0;
      } else {
        for (; i < 3; ++i) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits;
      }
      if (this.len - this.pos > 4) {
        for (; i < 5; ++i) {
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      } else {
        for (; i < 5; ++i) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      }
      throw Error("invalid varint encoding");
    }
    Reader.prototype.bool = function read_bool() {
      return this.uint32() !== 0;
    };
    function readFixed32_end(buf2, end) {
      return (buf2[end - 4] | buf2[end - 3] << 8 | buf2[end - 2] << 16 | buf2[end - 1] << 24) >>> 0;
    }
    Reader.prototype.fixed32 = function read_fixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4);
    };
    Reader.prototype.sfixed32 = function read_sfixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4) | 0;
    };
    function readFixed64() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);
      return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
    }
    Reader.prototype.float = function read_float() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util.float.readFloatLE(this.buf, this.pos);
      this.pos += 4;
      return value;
    };
    Reader.prototype.double = function read_double() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util.float.readDoubleLE(this.buf, this.pos);
      this.pos += 8;
      return value;
    };
    Reader.prototype.bytes = function read_bytes() {
      var length2 = this.uint32(), start = this.pos, end = this.pos + length2;
      if (end > this.len)
        throw indexOutOfRange(this, length2);
      this.pos += length2;
      if (Array.isArray(this.buf))
        return this.buf.slice(start, end);
      return start === end ? new this.buf.constructor(0) : this._slice.call(this.buf, start, end);
    };
    Reader.prototype.string = function read_string() {
      var bytes = this.bytes();
      return utf8.read(bytes, 0, bytes.length);
    };
    Reader.prototype.skip = function skip(length2) {
      if (typeof length2 === "number") {
        if (this.pos + length2 > this.len)
          throw indexOutOfRange(this, length2);
        this.pos += length2;
      } else {
        do {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
      }
      return this;
    };
    Reader.prototype.skipType = function(wireType) {
      switch (wireType) {
        case 0:
          this.skip();
          break;
        case 1:
          this.skip(8);
          break;
        case 2:
          this.skip(this.uint32());
          break;
        case 3:
          while ((wireType = this.uint32() & 7) !== 4) {
            this.skipType(wireType);
          }
          break;
        case 5:
          this.skip(4);
          break;
        default:
          throw Error("invalid wire type " + wireType + " at offset " + this.pos);
      }
      return this;
    };
    Reader._configure = function(BufferReader_) {
      BufferReader = BufferReader_;
      Reader.create = create4();
      BufferReader._configure();
      var fn = util.Long ? "toLong" : (
        /* istanbul ignore next */
        "toNumber"
      );
      util.merge(Reader.prototype, {
        int64: function read_int64() {
          return readLongVarint.call(this)[fn](false);
        },
        uint64: function read_uint64() {
          return readLongVarint.call(this)[fn](true);
        },
        sint64: function read_sint64() {
          return readLongVarint.call(this).zzDecode()[fn](false);
        },
        fixed64: function read_fixed64() {
          return readFixed64.call(this)[fn](true);
        },
        sfixed64: function read_sfixed64() {
          return readFixed64.call(this)[fn](false);
        }
      });
    };
  }
});

// ../../node_modules/.pnpm/protobufjs@6.11.4/node_modules/protobufjs/src/reader_buffer.js
var require_reader_buffer = __commonJS({
  "../../node_modules/.pnpm/protobufjs@6.11.4/node_modules/protobufjs/src/reader_buffer.js"(exports2, module2) {
    "use strict";
    module2.exports = BufferReader;
    var Reader = require_reader();
    (BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
    var util = require_minimal();
    function BufferReader(buffer2) {
      Reader.call(this, buffer2);
    }
    BufferReader._configure = function() {
      if (util.Buffer)
        BufferReader.prototype._slice = util.Buffer.prototype.slice;
    };
    BufferReader.prototype.string = function read_string_buffer() {
      var len = this.uint32();
      return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
    };
    BufferReader._configure();
  }
});

// ../../node_modules/.pnpm/protobufjs@6.11.4/node_modules/protobufjs/src/rpc/service.js
var require_service = __commonJS({
  "../../node_modules/.pnpm/protobufjs@6.11.4/node_modules/protobufjs/src/rpc/service.js"(exports2, module2) {
    "use strict";
    module2.exports = Service;
    var util = require_minimal();
    (Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;
    function Service(rpcImpl, requestDelimited, responseDelimited) {
      if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");
      util.EventEmitter.call(this);
      this.rpcImpl = rpcImpl;
      this.requestDelimited = Boolean(requestDelimited);
      this.responseDelimited = Boolean(responseDelimited);
    }
    Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {
      if (!request)
        throw TypeError("request must be specified");
      var self2 = this;
      if (!callback)
        return util.asPromise(rpcCall, self2, method, requestCtor, responseCtor, request);
      if (!self2.rpcImpl) {
        setTimeout(function() {
          callback(Error("already ended"));
        }, 0);
        return void 0;
      }
      try {
        return self2.rpcImpl(
          method,
          requestCtor[self2.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
          function rpcCallback(err, response) {
            if (err) {
              self2.emit("error", err, method);
              return callback(err);
            }
            if (response === null) {
              self2.end(
                /* endedByRPC */
                true
              );
              return void 0;
            }
            if (!(response instanceof responseCtor)) {
              try {
                response = responseCtor[self2.responseDelimited ? "decodeDelimited" : "decode"](response);
              } catch (err2) {
                self2.emit("error", err2, method);
                return callback(err2);
              }
            }
            self2.emit("data", response, method);
            return callback(null, response);
          }
        );
      } catch (err) {
        self2.emit("error", err, method);
        setTimeout(function() {
          callback(err);
        }, 0);
        return void 0;
      }
    };
    Service.prototype.end = function end(endedByRPC) {
      if (this.rpcImpl) {
        if (!endedByRPC)
          this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
      }
      return this;
    };
  }
});

// ../../node_modules/.pnpm/protobufjs@6.11.4/node_modules/protobufjs/src/rpc.js
var require_rpc = __commonJS({
  "../../node_modules/.pnpm/protobufjs@6.11.4/node_modules/protobufjs/src/rpc.js"(exports2) {
    "use strict";
    var rpc = exports2;
    rpc.Service = require_service();
  }
});

// ../../node_modules/.pnpm/protobufjs@6.11.4/node_modules/protobufjs/src/roots.js
var require_roots = __commonJS({
  "../../node_modules/.pnpm/protobufjs@6.11.4/node_modules/protobufjs/src/roots.js"(exports2, module2) {
    "use strict";
    module2.exports = {};
  }
});

// ../../node_modules/.pnpm/protobufjs@6.11.4/node_modules/protobufjs/src/index-minimal.js
var require_index_minimal = __commonJS({
  "../../node_modules/.pnpm/protobufjs@6.11.4/node_modules/protobufjs/src/index-minimal.js"(exports2) {
    "use strict";
    var protobuf = exports2;
    protobuf.build = "minimal";
    protobuf.Writer = require_writer();
    protobuf.BufferWriter = require_writer_buffer();
    protobuf.Reader = require_reader();
    protobuf.BufferReader = require_reader_buffer();
    protobuf.util = require_minimal();
    protobuf.rpc = require_rpc();
    protobuf.roots = require_roots();
    protobuf.configure = configure;
    function configure() {
      protobuf.util._configure();
      protobuf.Writer._configure(protobuf.BufferWriter);
      protobuf.Reader._configure(protobuf.BufferReader);
    }
    configure();
  }
});

// ../../node_modules/.pnpm/protobufjs@6.11.4/node_modules/protobufjs/minimal.js
var require_minimal2 = __commonJS({
  "../../node_modules/.pnpm/protobufjs@6.11.4/node_modules/protobufjs/minimal.js"(exports2, module2) {
    "use strict";
    module2.exports = require_index_minimal();
  }
});

// ../../node_modules/.pnpm/it-all@1.0.6/node_modules/it-all/index.js
var require_it_all = __commonJS({
  "../../node_modules/.pnpm/it-all@1.0.6/node_modules/it-all/index.js"(exports2, module2) {
    "use strict";
    var all4 = (source) => __async(exports2, null, function* () {
      const arr = [];
      try {
        for (var iter = __forAwait(source), more, temp, error; more = !(temp = yield iter.next()).done; more = false) {
          const entry = temp.value;
          arr.push(entry);
        }
      } catch (temp) {
        error = [temp];
      } finally {
        try {
          more && (temp = iter.return) && (yield temp.call(iter));
        } finally {
          if (error)
            throw error[0];
        }
      }
      return arr;
    });
    module2.exports = all4;
  }
});

// ../../node_modules/.pnpm/bl@5.1.0/node_modules/bl/BufferList.js
var require_BufferList = __commonJS({
  "../../node_modules/.pnpm/bl@5.1.0/node_modules/bl/BufferList.js"(exports2, module2) {
    "use strict";
    var { Buffer: Buffer3 } = require("buffer");
    var symbol = Symbol.for("BufferList");
    function BufferList3(buf2) {
      if (!(this instanceof BufferList3)) {
        return new BufferList3(buf2);
      }
      BufferList3._init.call(this, buf2);
    }
    BufferList3._init = function _init(buf2) {
      Object.defineProperty(this, symbol, { value: true });
      this._bufs = [];
      this.length = 0;
      if (buf2) {
        this.append(buf2);
      }
    };
    BufferList3.prototype._new = function _new(buf2) {
      return new BufferList3(buf2);
    };
    BufferList3.prototype._offset = function _offset(offset) {
      if (offset === 0) {
        return [0, 0];
      }
      let tot = 0;
      for (let i = 0; i < this._bufs.length; i++) {
        const _t = tot + this._bufs[i].length;
        if (offset < _t || i === this._bufs.length - 1) {
          return [i, offset - tot];
        }
        tot = _t;
      }
    };
    BufferList3.prototype._reverseOffset = function(blOffset) {
      const bufferId = blOffset[0];
      let offset = blOffset[1];
      for (let i = 0; i < bufferId; i++) {
        offset += this._bufs[i].length;
      }
      return offset;
    };
    BufferList3.prototype.get = function get2(index) {
      if (index > this.length || index < 0) {
        return void 0;
      }
      const offset = this._offset(index);
      return this._bufs[offset[0]][offset[1]];
    };
    BufferList3.prototype.slice = function slice2(start, end) {
      if (typeof start === "number" && start < 0) {
        start += this.length;
      }
      if (typeof end === "number" && end < 0) {
        end += this.length;
      }
      return this.copy(null, 0, start, end);
    };
    BufferList3.prototype.copy = function copy(dst, dstStart, srcStart, srcEnd) {
      if (typeof srcStart !== "number" || srcStart < 0) {
        srcStart = 0;
      }
      if (typeof srcEnd !== "number" || srcEnd > this.length) {
        srcEnd = this.length;
      }
      if (srcStart >= this.length) {
        return dst || Buffer3.alloc(0);
      }
      if (srcEnd <= 0) {
        return dst || Buffer3.alloc(0);
      }
      const copy2 = !!dst;
      const off = this._offset(srcStart);
      const len = srcEnd - srcStart;
      let bytes = len;
      let bufoff = copy2 && dstStart || 0;
      let start = off[1];
      if (srcStart === 0 && srcEnd === this.length) {
        if (!copy2) {
          return this._bufs.length === 1 ? this._bufs[0] : Buffer3.concat(this._bufs, this.length);
        }
        for (let i = 0; i < this._bufs.length; i++) {
          this._bufs[i].copy(dst, bufoff);
          bufoff += this._bufs[i].length;
        }
        return dst;
      }
      if (bytes <= this._bufs[off[0]].length - start) {
        return copy2 ? this._bufs[off[0]].copy(dst, dstStart, start, start + bytes) : this._bufs[off[0]].slice(start, start + bytes);
      }
      if (!copy2) {
        dst = Buffer3.allocUnsafe(len);
      }
      for (let i = off[0]; i < this._bufs.length; i++) {
        const l = this._bufs[i].length - start;
        if (bytes > l) {
          this._bufs[i].copy(dst, bufoff, start);
          bufoff += l;
        } else {
          this._bufs[i].copy(dst, bufoff, start, start + bytes);
          bufoff += l;
          break;
        }
        bytes -= l;
        if (start) {
          start = 0;
        }
      }
      if (dst.length > bufoff)
        return dst.slice(0, bufoff);
      return dst;
    };
    BufferList3.prototype.shallowSlice = function shallowSlice(start, end) {
      start = start || 0;
      end = typeof end !== "number" ? this.length : end;
      if (start < 0) {
        start += this.length;
      }
      if (end < 0) {
        end += this.length;
      }
      if (start === end) {
        return this._new();
      }
      const startOffset = this._offset(start);
      const endOffset = this._offset(end);
      const buffers = this._bufs.slice(startOffset[0], endOffset[0] + 1);
      if (endOffset[1] === 0) {
        buffers.pop();
      } else {
        buffers[buffers.length - 1] = buffers[buffers.length - 1].slice(0, endOffset[1]);
      }
      if (startOffset[1] !== 0) {
        buffers[0] = buffers[0].slice(startOffset[1]);
      }
      return this._new(buffers);
    };
    BufferList3.prototype.toString = function toString3(encoding, start, end) {
      return this.slice(start, end).toString(encoding);
    };
    BufferList3.prototype.consume = function consume(bytes) {
      bytes = Math.trunc(bytes);
      if (Number.isNaN(bytes) || bytes <= 0)
        return this;
      while (this._bufs.length) {
        if (bytes >= this._bufs[0].length) {
          bytes -= this._bufs[0].length;
          this.length -= this._bufs[0].length;
          this._bufs.shift();
        } else {
          this._bufs[0] = this._bufs[0].slice(bytes);
          this.length -= bytes;
          break;
        }
      }
      return this;
    };
    BufferList3.prototype.duplicate = function duplicate() {
      const copy = this._new();
      for (let i = 0; i < this._bufs.length; i++) {
        copy.append(this._bufs[i]);
      }
      return copy;
    };
    BufferList3.prototype.append = function append(buf2) {
      if (buf2 == null) {
        return this;
      }
      if (buf2.buffer) {
        this._appendBuffer(Buffer3.from(buf2.buffer, buf2.byteOffset, buf2.byteLength));
      } else if (Array.isArray(buf2)) {
        for (let i = 0; i < buf2.length; i++) {
          this.append(buf2[i]);
        }
      } else if (this._isBufferList(buf2)) {
        for (let i = 0; i < buf2._bufs.length; i++) {
          this.append(buf2._bufs[i]);
        }
      } else {
        if (typeof buf2 === "number") {
          buf2 = buf2.toString();
        }
        this._appendBuffer(Buffer3.from(buf2));
      }
      return this;
    };
    BufferList3.prototype._appendBuffer = function appendBuffer(buf2) {
      this._bufs.push(buf2);
      this.length += buf2.length;
    };
    BufferList3.prototype.indexOf = function(search, offset, encoding) {
      if (encoding === void 0 && typeof offset === "string") {
        encoding = offset;
        offset = void 0;
      }
      if (typeof search === "function" || Array.isArray(search)) {
        throw new TypeError('The "value" argument must be one of type string, Buffer, BufferList, or Uint8Array.');
      } else if (typeof search === "number") {
        search = Buffer3.from([search]);
      } else if (typeof search === "string") {
        search = Buffer3.from(search, encoding);
      } else if (this._isBufferList(search)) {
        search = search.slice();
      } else if (Array.isArray(search.buffer)) {
        search = Buffer3.from(search.buffer, search.byteOffset, search.byteLength);
      } else if (!Buffer3.isBuffer(search)) {
        search = Buffer3.from(search);
      }
      offset = Number(offset || 0);
      if (isNaN(offset)) {
        offset = 0;
      }
      if (offset < 0) {
        offset = this.length + offset;
      }
      if (offset < 0) {
        offset = 0;
      }
      if (search.length === 0) {
        return offset > this.length ? this.length : offset;
      }
      const blOffset = this._offset(offset);
      let blIndex = blOffset[0];
      let buffOffset = blOffset[1];
      for (; blIndex < this._bufs.length; blIndex++) {
        const buff = this._bufs[blIndex];
        while (buffOffset < buff.length) {
          const availableWindow = buff.length - buffOffset;
          if (availableWindow >= search.length) {
            const nativeSearchResult = buff.indexOf(search, buffOffset);
            if (nativeSearchResult !== -1) {
              return this._reverseOffset([blIndex, nativeSearchResult]);
            }
            buffOffset = buff.length - search.length + 1;
          } else {
            const revOffset = this._reverseOffset([blIndex, buffOffset]);
            if (this._match(revOffset, search)) {
              return revOffset;
            }
            buffOffset++;
          }
        }
        buffOffset = 0;
      }
      return -1;
    };
    BufferList3.prototype._match = function(offset, search) {
      if (this.length - offset < search.length) {
        return false;
      }
      for (let searchOffset = 0; searchOffset < search.length; searchOffset++) {
        if (this.get(offset + searchOffset) !== search[searchOffset]) {
          return false;
        }
      }
      return true;
    };
    (function() {
      const methods = {
        readDoubleBE: 8,
        readDoubleLE: 8,
        readFloatBE: 4,
        readFloatLE: 4,
        readInt32BE: 4,
        readInt32LE: 4,
        readUInt32BE: 4,
        readUInt32LE: 4,
        readInt16BE: 2,
        readInt16LE: 2,
        readUInt16BE: 2,
        readUInt16LE: 2,
        readInt8: 1,
        readUInt8: 1,
        readIntBE: null,
        readIntLE: null,
        readUIntBE: null,
        readUIntLE: null
      };
      for (const m in methods) {
        (function(m2) {
          if (methods[m2] === null) {
            BufferList3.prototype[m2] = function(offset, byteLength) {
              return this.slice(offset, offset + byteLength)[m2](0, byteLength);
            };
          } else {
            BufferList3.prototype[m2] = function(offset = 0) {
              return this.slice(offset, offset + methods[m2])[m2](0);
            };
          }
        })(m);
      }
    })();
    BufferList3.prototype._isBufferList = function _isBufferList(b) {
      return b instanceof BufferList3 || BufferList3.isBufferList(b);
    };
    BufferList3.isBufferList = function isBufferList(b) {
      return b != null && b[symbol];
    };
    module2.exports = BufferList3;
  }
});

// ../../node_modules/.pnpm/rabin-wasm@0.1.5/node_modules/rabin-wasm/src/rabin.js
var require_rabin = __commonJS({
  "../../node_modules/.pnpm/rabin-wasm@0.1.5/node_modules/rabin-wasm/src/rabin.js"(exports2, module2) {
    "use strict";
    var Rabin = class {
      /**
       * Creates an instance of Rabin.
       * @param { import("./../dist/rabin-wasm") } asModule
       * @param {number} [bits=12]
       * @param {number} [min=8 * 1024]
       * @param {number} [max=32 * 1024]
       * @param {number} polynomial
       * @memberof Rabin
       */
      constructor(asModule, bits = 12, min = 8 * 1024, max = 32 * 1024, windowSize = 64, polynomial) {
        this.bits = bits;
        this.min = min;
        this.max = max;
        this.asModule = asModule;
        this.rabin = new asModule.Rabin(bits, min, max, windowSize, polynomial);
        this.polynomial = polynomial;
      }
      /**
       * Fingerprints the buffer
       *
       * @param {Uint8Array} buf
       * @returns {Array<number>}
       * @memberof Rabin
       */
      fingerprint(buf2) {
        const {
          __retain,
          __release,
          __allocArray,
          __getInt32Array,
          Int32Array_ID,
          Uint8Array_ID
        } = this.asModule;
        const lengths = new Int32Array(Math.ceil(buf2.length / this.min));
        const lengthsPtr = __retain(__allocArray(Int32Array_ID, lengths));
        const pointer = __retain(__allocArray(Uint8Array_ID, buf2));
        const out = this.rabin.fingerprint(pointer, lengthsPtr);
        const processed = __getInt32Array(out);
        __release(pointer);
        __release(lengthsPtr);
        const end = processed.indexOf(0);
        return end >= 0 ? processed.subarray(0, end) : processed;
      }
    };
    module2.exports = Rabin;
  }
});

// ../../node_modules/.pnpm/@assemblyscript+loader@0.9.4/node_modules/@assemblyscript/loader/index.js
var require_loader = __commonJS({
  "../../node_modules/.pnpm/@assemblyscript+loader@0.9.4/node_modules/@assemblyscript/loader/index.js"(exports2) {
    "use strict";
    var ID_OFFSET = -8;
    var SIZE_OFFSET = -4;
    var ARRAYBUFFER_ID = 0;
    var STRING_ID = 1;
    var ARRAYBUFFERVIEW = 1 << 0;
    var ARRAY = 1 << 1;
    var SET = 1 << 2;
    var MAP = 1 << 3;
    var VAL_ALIGN_OFFSET = 5;
    var VAL_ALIGN = 1 << VAL_ALIGN_OFFSET;
    var VAL_SIGNED = 1 << 10;
    var VAL_FLOAT = 1 << 11;
    var VAL_NULLABLE = 1 << 12;
    var VAL_MANAGED = 1 << 13;
    var KEY_ALIGN_OFFSET = 14;
    var KEY_ALIGN = 1 << KEY_ALIGN_OFFSET;
    var KEY_SIGNED = 1 << 19;
    var KEY_FLOAT = 1 << 20;
    var KEY_NULLABLE = 1 << 21;
    var KEY_MANAGED = 1 << 22;
    var ARRAYBUFFERVIEW_BUFFER_OFFSET = 0;
    var ARRAYBUFFERVIEW_DATASTART_OFFSET = 4;
    var ARRAYBUFFERVIEW_DATALENGTH_OFFSET = 8;
    var ARRAYBUFFERVIEW_SIZE = 12;
    var ARRAY_LENGTH_OFFSET = 12;
    var ARRAY_SIZE = 16;
    var BIGINT = typeof BigUint64Array !== "undefined";
    var THIS = Symbol();
    var CHUNKSIZE = 1024;
    function getStringImpl(buffer2, ptr) {
      const U32 = new Uint32Array(buffer2);
      const U16 = new Uint16Array(buffer2);
      var length2 = U32[ptr + SIZE_OFFSET >>> 2] >>> 1;
      var offset = ptr >>> 1;
      if (length2 <= CHUNKSIZE)
        return String.fromCharCode.apply(String, U16.subarray(offset, offset + length2));
      const parts = [];
      do {
        const last2 = U16[offset + CHUNKSIZE - 1];
        const size = last2 >= 55296 && last2 < 56320 ? CHUNKSIZE - 1 : CHUNKSIZE;
        parts.push(String.fromCharCode.apply(String, U16.subarray(offset, offset += size)));
        length2 -= size;
      } while (length2 > CHUNKSIZE);
      return parts.join("") + String.fromCharCode.apply(String, U16.subarray(offset, offset + length2));
    }
    function preInstantiate(imports) {
      const baseModule = {};
      function getString(memory, ptr) {
        if (!memory)
          return "<yet unknown>";
        return getStringImpl(memory.buffer, ptr);
      }
      const env = imports.env = imports.env || {};
      env.abort = env.abort || function abort(mesg, file, line, colm) {
        const memory = baseModule.memory || env.memory;
        throw Error("abort: " + getString(memory, mesg) + " at " + getString(memory, file) + ":" + line + ":" + colm);
      };
      env.trace = env.trace || function trace(mesg, n) {
        const memory = baseModule.memory || env.memory;
        console.log("trace: " + getString(memory, mesg) + (n ? " " : "") + Array.prototype.slice.call(arguments, 2, 2 + n).join(", "));
      };
      imports.Math = imports.Math || Math;
      imports.Date = imports.Date || Date;
      return baseModule;
    }
    function postInstantiate(baseModule, instance) {
      const rawExports = instance.exports;
      const memory = rawExports.memory;
      const table = rawExports.table;
      const alloc2 = rawExports["__alloc"];
      const retain = rawExports["__retain"];
      const rttiBase = rawExports["__rtti_base"] || ~0;
      function getInfo(id) {
        const U32 = new Uint32Array(memory.buffer);
        const count = U32[rttiBase >>> 2];
        if ((id >>>= 0) >= count)
          throw Error("invalid id: " + id);
        return U32[(rttiBase + 4 >>> 2) + id * 2];
      }
      function getBase(id) {
        const U32 = new Uint32Array(memory.buffer);
        const count = U32[rttiBase >>> 2];
        if ((id >>>= 0) >= count)
          throw Error("invalid id: " + id);
        return U32[(rttiBase + 4 >>> 2) + id * 2 + 1];
      }
      function getValueAlign(info) {
        return 31 - Math.clz32(info >>> VAL_ALIGN_OFFSET & 31);
      }
      function getKeyAlign(info) {
        return 31 - Math.clz32(info >>> KEY_ALIGN_OFFSET & 31);
      }
      function __allocString(str) {
        const length2 = str.length;
        const ptr = alloc2(length2 << 1, STRING_ID);
        const U16 = new Uint16Array(memory.buffer);
        for (var i = 0, p = ptr >>> 1; i < length2; ++i)
          U16[p + i] = str.charCodeAt(i);
        return ptr;
      }
      baseModule.__allocString = __allocString;
      function __getString(ptr) {
        const buffer2 = memory.buffer;
        const id = new Uint32Array(buffer2)[ptr + ID_OFFSET >>> 2];
        if (id !== STRING_ID)
          throw Error("not a string: " + ptr);
        return getStringImpl(buffer2, ptr);
      }
      baseModule.__getString = __getString;
      function getView(alignLog2, signed, float) {
        const buffer2 = memory.buffer;
        if (float) {
          switch (alignLog2) {
            case 2:
              return new Float32Array(buffer2);
            case 3:
              return new Float64Array(buffer2);
          }
        } else {
          switch (alignLog2) {
            case 0:
              return new (signed ? Int8Array : Uint8Array)(buffer2);
            case 1:
              return new (signed ? Int16Array : Uint16Array)(buffer2);
            case 2:
              return new (signed ? Int32Array : Uint32Array)(buffer2);
            case 3:
              return new (signed ? BigInt64Array : BigUint64Array)(buffer2);
          }
        }
        throw Error("unsupported align: " + alignLog2);
      }
      function __allocArray(id, values) {
        const info = getInfo(id);
        if (!(info & (ARRAYBUFFERVIEW | ARRAY)))
          throw Error("not an array: " + id + " @ " + info);
        const align = getValueAlign(info);
        const length2 = values.length;
        const buf2 = alloc2(length2 << align, ARRAYBUFFER_ID);
        const arr = alloc2(info & ARRAY ? ARRAY_SIZE : ARRAYBUFFERVIEW_SIZE, id);
        const U32 = new Uint32Array(memory.buffer);
        U32[arr + ARRAYBUFFERVIEW_BUFFER_OFFSET >>> 2] = retain(buf2);
        U32[arr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2] = buf2;
        U32[arr + ARRAYBUFFERVIEW_DATALENGTH_OFFSET >>> 2] = length2 << align;
        if (info & ARRAY)
          U32[arr + ARRAY_LENGTH_OFFSET >>> 2] = length2;
        const view = getView(align, info & VAL_SIGNED, info & VAL_FLOAT);
        if (info & VAL_MANAGED) {
          for (let i = 0; i < length2; ++i)
            view[(buf2 >>> align) + i] = retain(values[i]);
        } else {
          view.set(values, buf2 >>> align);
        }
        return arr;
      }
      baseModule.__allocArray = __allocArray;
      function __getArrayView(arr) {
        const U32 = new Uint32Array(memory.buffer);
        const id = U32[arr + ID_OFFSET >>> 2];
        const info = getInfo(id);
        if (!(info & ARRAYBUFFERVIEW))
          throw Error("not an array: " + id);
        const align = getValueAlign(info);
        var buf2 = U32[arr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2];
        const length2 = info & ARRAY ? U32[arr + ARRAY_LENGTH_OFFSET >>> 2] : U32[buf2 + SIZE_OFFSET >>> 2] >>> align;
        return getView(align, info & VAL_SIGNED, info & VAL_FLOAT).subarray(buf2 >>>= align, buf2 + length2);
      }
      baseModule.__getArrayView = __getArrayView;
      function __getArray(arr) {
        const input = __getArrayView(arr);
        const len = input.length;
        const out = new Array(len);
        for (let i = 0; i < len; i++)
          out[i] = input[i];
        return out;
      }
      baseModule.__getArray = __getArray;
      function __getArrayBuffer(ptr) {
        const buffer2 = memory.buffer;
        const length2 = new Uint32Array(buffer2)[ptr + SIZE_OFFSET >>> 2];
        return buffer2.slice(ptr, ptr + length2);
      }
      baseModule.__getArrayBuffer = __getArrayBuffer;
      function getTypedArray(Type2, alignLog2, ptr) {
        return new Type2(getTypedArrayView(Type2, alignLog2, ptr));
      }
      function getTypedArrayView(Type2, alignLog2, ptr) {
        const buffer2 = memory.buffer;
        const U32 = new Uint32Array(buffer2);
        const bufPtr = U32[ptr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2];
        return new Type2(buffer2, bufPtr, U32[bufPtr + SIZE_OFFSET >>> 2] >>> alignLog2);
      }
      baseModule.__getInt8Array = getTypedArray.bind(null, Int8Array, 0);
      baseModule.__getInt8ArrayView = getTypedArrayView.bind(null, Int8Array, 0);
      baseModule.__getUint8Array = getTypedArray.bind(null, Uint8Array, 0);
      baseModule.__getUint8ArrayView = getTypedArrayView.bind(null, Uint8Array, 0);
      baseModule.__getUint8ClampedArray = getTypedArray.bind(null, Uint8ClampedArray, 0);
      baseModule.__getUint8ClampedArrayView = getTypedArrayView.bind(null, Uint8ClampedArray, 0);
      baseModule.__getInt16Array = getTypedArray.bind(null, Int16Array, 1);
      baseModule.__getInt16ArrayView = getTypedArrayView.bind(null, Int16Array, 1);
      baseModule.__getUint16Array = getTypedArray.bind(null, Uint16Array, 1);
      baseModule.__getUint16ArrayView = getTypedArrayView.bind(null, Uint16Array, 1);
      baseModule.__getInt32Array = getTypedArray.bind(null, Int32Array, 2);
      baseModule.__getInt32ArrayView = getTypedArrayView.bind(null, Int32Array, 2);
      baseModule.__getUint32Array = getTypedArray.bind(null, Uint32Array, 2);
      baseModule.__getUint32ArrayView = getTypedArrayView.bind(null, Uint32Array, 2);
      if (BIGINT) {
        baseModule.__getInt64Array = getTypedArray.bind(null, BigInt64Array, 3);
        baseModule.__getInt64ArrayView = getTypedArrayView.bind(null, BigInt64Array, 3);
        baseModule.__getUint64Array = getTypedArray.bind(null, BigUint64Array, 3);
        baseModule.__getUint64ArrayView = getTypedArrayView.bind(null, BigUint64Array, 3);
      }
      baseModule.__getFloat32Array = getTypedArray.bind(null, Float32Array, 2);
      baseModule.__getFloat32ArrayView = getTypedArrayView.bind(null, Float32Array, 2);
      baseModule.__getFloat64Array = getTypedArray.bind(null, Float64Array, 3);
      baseModule.__getFloat64ArrayView = getTypedArrayView.bind(null, Float64Array, 3);
      function __instanceof(ptr, baseId) {
        const U32 = new Uint32Array(memory.buffer);
        var id = U32[ptr + ID_OFFSET >>> 2];
        if (id <= U32[rttiBase >>> 2]) {
          do
            if (id == baseId)
              return true;
          while (id = getBase(id));
        }
        return false;
      }
      baseModule.__instanceof = __instanceof;
      baseModule.memory = baseModule.memory || memory;
      baseModule.table = baseModule.table || table;
      return demangle(rawExports, baseModule);
    }
    function isResponse(o) {
      return typeof Response !== "undefined" && o instanceof Response;
    }
    function instantiate(source, imports) {
      return __async(this, null, function* () {
        if (isResponse(source = yield source))
          return instantiateStreaming(source, imports);
        return postInstantiate(
          preInstantiate(imports || (imports = {})),
          yield WebAssembly.instantiate(
            source instanceof WebAssembly.Module ? source : yield WebAssembly.compile(source),
            imports
          )
        );
      });
    }
    exports2.instantiate = instantiate;
    function instantiateSync(source, imports) {
      return postInstantiate(
        preInstantiate(imports || (imports = {})),
        new WebAssembly.Instance(
          source instanceof WebAssembly.Module ? source : new WebAssembly.Module(source),
          imports
        )
      );
    }
    exports2.instantiateSync = instantiateSync;
    function instantiateStreaming(source, imports) {
      return __async(this, null, function* () {
        if (!WebAssembly.instantiateStreaming) {
          return instantiate(
            isResponse(source = yield source) ? source.arrayBuffer() : source,
            imports
          );
        }
        return postInstantiate(
          preInstantiate(imports || (imports = {})),
          (yield WebAssembly.instantiateStreaming(source, imports)).instance
        );
      });
    }
    exports2.instantiateStreaming = instantiateStreaming;
    function demangle(exports3, baseModule) {
      var module3 = baseModule ? Object.create(baseModule) : {};
      var setArgumentsLength = exports3["__argumentsLength"] ? function(length2) {
        exports3["__argumentsLength"].value = length2;
      } : exports3["__setArgumentsLength"] || exports3["__setargc"] || function() {
      };
      for (let internalName in exports3) {
        if (!Object.prototype.hasOwnProperty.call(exports3, internalName))
          continue;
        const elem = exports3[internalName];
        let parts = internalName.split(".");
        let curr = module3;
        while (parts.length > 1) {
          let part = parts.shift();
          if (!Object.prototype.hasOwnProperty.call(curr, part))
            curr[part] = {};
          curr = curr[part];
        }
        let name5 = parts[0];
        let hash = name5.indexOf("#");
        if (hash >= 0) {
          let className = name5.substring(0, hash);
          let classElem = curr[className];
          if (typeof classElem === "undefined" || !classElem.prototype) {
            let ctor = function(...args) {
              return ctor.wrap(ctor.prototype.constructor(0, ...args));
            };
            ctor.prototype = {
              valueOf: function valueOf() {
                return this[THIS];
              }
            };
            ctor.wrap = function(thisValue) {
              return Object.create(ctor.prototype, { [THIS]: { value: thisValue, writable: false } });
            };
            if (classElem)
              Object.getOwnPropertyNames(classElem).forEach(
                (name6) => Object.defineProperty(ctor, name6, Object.getOwnPropertyDescriptor(classElem, name6))
              );
            curr[className] = ctor;
          }
          name5 = name5.substring(hash + 1);
          curr = curr[className].prototype;
          if (/^(get|set):/.test(name5)) {
            if (!Object.prototype.hasOwnProperty.call(curr, name5 = name5.substring(4))) {
              let getter = exports3[internalName.replace("set:", "get:")];
              let setter = exports3[internalName.replace("get:", "set:")];
              Object.defineProperty(curr, name5, {
                get: function() {
                  return getter(this[THIS]);
                },
                set: function(value) {
                  setter(this[THIS], value);
                },
                enumerable: true
              });
            }
          } else {
            if (name5 === "constructor") {
              (curr[name5] = (...args) => {
                setArgumentsLength(args.length);
                return elem(...args);
              }).original = elem;
            } else {
              (curr[name5] = function(...args) {
                setArgumentsLength(args.length);
                return elem(this[THIS], ...args);
              }).original = elem;
            }
          }
        } else {
          if (/^(get|set):/.test(name5)) {
            if (!Object.prototype.hasOwnProperty.call(curr, name5 = name5.substring(4))) {
              Object.defineProperty(curr, name5, {
                get: exports3[internalName.replace("set:", "get:")],
                set: exports3[internalName.replace("get:", "set:")],
                enumerable: true
              });
            }
          } else if (typeof elem === "function" && elem !== setArgumentsLength) {
            (curr[name5] = (...args) => {
              setArgumentsLength(args.length);
              return elem(...args);
            }).original = elem;
          } else {
            curr[name5] = elem;
          }
        }
      }
      return module3;
    }
    exports2.demangle = demangle;
  }
});

// ../../node_modules/.pnpm/rabin-wasm@0.1.5/node_modules/rabin-wasm/dist/rabin-wasm.node.js
var require_rabin_wasm_node = __commonJS({
  "../../node_modules/.pnpm/rabin-wasm@0.1.5/node_modules/rabin-wasm/dist/rabin-wasm.node.js"(exports2, module2) {
    "use strict";
    var { instantiateSync } = require_loader();
    var fs5 = require("fs");
    loadWebAssembly.supported = typeof WebAssembly !== "undefined";
    function loadWebAssembly() {
      return __async(this, arguments, function* (imp = {}) {
        if (!loadWebAssembly.supported)
          return null;
        return instantiateSync(fs5.readFileSync(__dirname + "/../dist/rabin.wasm"), imp);
      });
    }
    module2.exports = loadWebAssembly;
  }
});

// ../../node_modules/.pnpm/rabin-wasm@0.1.5/node_modules/rabin-wasm/src/index.js
var require_src = __commonJS({
  "../../node_modules/.pnpm/rabin-wasm@0.1.5/node_modules/rabin-wasm/src/index.js"(exports2, module2) {
    "use strict";
    var Rabin = require_rabin();
    var getRabin = require_rabin_wasm_node();
    var create4 = (avg, min, max, windowSize, polynomial) => __async(exports2, null, function* () {
      const compiled = yield getRabin();
      return new Rabin(compiled, avg, min, max, windowSize, polynomial);
    });
    module2.exports = {
      Rabin,
      create: create4
    };
  }
});

// ../../node_modules/.pnpm/sparse-array@1.3.2/node_modules/sparse-array/index.js
var require_sparse_array = __commonJS({
  "../../node_modules/.pnpm/sparse-array@1.3.2/node_modules/sparse-array/index.js"(exports2, module2) {
    "use strict";
    var BITS_PER_BYTE = 7;
    module2.exports = class SparseArray {
      constructor() {
        this._bitArrays = [];
        this._data = [];
        this._length = 0;
        this._changedLength = false;
        this._changedData = false;
      }
      set(index, value) {
        let pos = this._internalPositionFor(index, false);
        if (value === void 0) {
          if (pos !== -1) {
            this._unsetInternalPos(pos);
            this._unsetBit(index);
            this._changedLength = true;
            this._changedData = true;
          }
        } else {
          let needsSort = false;
          if (pos === -1) {
            pos = this._data.length;
            this._setBit(index);
            this._changedData = true;
          } else {
            needsSort = true;
          }
          this._setInternalPos(pos, index, value, needsSort);
          this._changedLength = true;
        }
      }
      unset(index) {
        this.set(index, void 0);
      }
      get(index) {
        this._sortData();
        const pos = this._internalPositionFor(index, true);
        if (pos === -1) {
          return void 0;
        }
        return this._data[pos][1];
      }
      push(value) {
        this.set(this.length, value);
        return this.length;
      }
      get length() {
        this._sortData();
        if (this._changedLength) {
          const last2 = this._data[this._data.length - 1];
          this._length = last2 ? last2[0] + 1 : 0;
          this._changedLength = false;
        }
        return this._length;
      }
      forEach(iterator) {
        let i = 0;
        while (i < this.length) {
          iterator(this.get(i), i, this);
          i++;
        }
      }
      map(iterator) {
        let i = 0;
        let mapped = new Array(this.length);
        while (i < this.length) {
          mapped[i] = iterator(this.get(i), i, this);
          i++;
        }
        return mapped;
      }
      reduce(reducer, initialValue) {
        let i = 0;
        let acc = initialValue;
        while (i < this.length) {
          const value = this.get(i);
          acc = reducer(acc, value, i);
          i++;
        }
        return acc;
      }
      find(finder) {
        let i = 0, found, last2;
        while (i < this.length && !found) {
          last2 = this.get(i);
          found = finder(last2);
          i++;
        }
        return found ? last2 : void 0;
      }
      _internalPositionFor(index, noCreate) {
        const bytePos = this._bytePosFor(index, noCreate);
        if (bytePos >= this._bitArrays.length) {
          return -1;
        }
        const byte = this._bitArrays[bytePos];
        const bitPos = index - bytePos * BITS_PER_BYTE;
        const exists = (byte & 1 << bitPos) > 0;
        if (!exists) {
          return -1;
        }
        const previousPopCount = this._bitArrays.slice(0, bytePos).reduce(popCountReduce, 0);
        const mask = ~(4294967295 << bitPos + 1);
        const bytePopCount = popCount(byte & mask);
        const arrayPos = previousPopCount + bytePopCount - 1;
        return arrayPos;
      }
      _bytePosFor(index, noCreate) {
        const bytePos = Math.floor(index / BITS_PER_BYTE);
        const targetLength = bytePos + 1;
        while (!noCreate && this._bitArrays.length < targetLength) {
          this._bitArrays.push(0);
        }
        return bytePos;
      }
      _setBit(index) {
        const bytePos = this._bytePosFor(index, false);
        this._bitArrays[bytePos] |= 1 << index - bytePos * BITS_PER_BYTE;
      }
      _unsetBit(index) {
        const bytePos = this._bytePosFor(index, false);
        this._bitArrays[bytePos] &= ~(1 << index - bytePos * BITS_PER_BYTE);
      }
      _setInternalPos(pos, index, value, needsSort) {
        const data = this._data;
        const elem = [index, value];
        if (needsSort) {
          this._sortData();
          data[pos] = elem;
        } else {
          if (data.length) {
            if (data[data.length - 1][0] >= index) {
              data.push(elem);
            } else if (data[0][0] <= index) {
              data.unshift(elem);
            } else {
              const randomIndex = Math.round(data.length / 2);
              this._data = data.slice(0, randomIndex).concat(elem).concat(data.slice(randomIndex));
            }
          } else {
            this._data.push(elem);
          }
          this._changedData = true;
          this._changedLength = true;
        }
      }
      _unsetInternalPos(pos) {
        this._data.splice(pos, 1);
      }
      _sortData() {
        if (this._changedData) {
          this._data.sort(sortInternal);
        }
        this._changedData = false;
      }
      bitField() {
        const bytes = [];
        let pendingBitsForResultingByte = 8;
        let pendingBitsForNewByte = 0;
        let resultingByte = 0;
        let newByte;
        const pending = this._bitArrays.slice();
        while (pending.length || pendingBitsForNewByte) {
          if (pendingBitsForNewByte === 0) {
            newByte = pending.shift();
            pendingBitsForNewByte = 7;
          }
          const usingBits = Math.min(pendingBitsForNewByte, pendingBitsForResultingByte);
          const mask = ~(255 << usingBits);
          const masked = newByte & mask;
          resultingByte |= masked << 8 - pendingBitsForResultingByte;
          newByte = newByte >>> usingBits;
          pendingBitsForNewByte -= usingBits;
          pendingBitsForResultingByte -= usingBits;
          if (!pendingBitsForResultingByte || !pendingBitsForNewByte && !pending.length) {
            bytes.push(resultingByte);
            resultingByte = 0;
            pendingBitsForResultingByte = 8;
          }
        }
        for (var i = bytes.length - 1; i > 0; i--) {
          const value = bytes[i];
          if (value === 0) {
            bytes.pop();
          } else {
            break;
          }
        }
        return bytes;
      }
      compactArray() {
        this._sortData();
        return this._data.map(valueOnly);
      }
    };
    function popCountReduce(count, byte) {
      return count + popCount(byte);
    }
    function popCount(_v) {
      let v = _v;
      v = v - (v >> 1 & 1431655765);
      v = (v & 858993459) + (v >> 2 & 858993459);
      return (v + (v >> 4) & 252645135) * 16843009 >> 24;
    }
    function sortInternal(a, b) {
      return a[0] - b[0];
    }
    function valueOnly(elem) {
      return elem[1];
    }
  }
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/vendor/base-x.js
var require_base_x = __commonJS({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/vendor/base-x.js"(exports2, module2) {
    "use strict";
    function base3(ALPHABET, name5) {
      if (ALPHABET.length >= 255) {
        throw new TypeError("Alphabet too long");
      }
      var BASE_MAP = new Uint8Array(256);
      for (var j = 0; j < BASE_MAP.length; j++) {
        BASE_MAP[j] = 255;
      }
      for (var i = 0; i < ALPHABET.length; i++) {
        var x = ALPHABET.charAt(i);
        var xc = x.charCodeAt(0);
        if (BASE_MAP[xc] !== 255) {
          throw new TypeError(x + " is ambiguous");
        }
        BASE_MAP[xc] = i;
      }
      var BASE = ALPHABET.length;
      var LEADER = ALPHABET.charAt(0);
      var FACTOR = Math.log(BASE) / Math.log(256);
      var iFACTOR = Math.log(256) / Math.log(BASE);
      function encode12(source) {
        if (source instanceof Uint8Array)
          ;
        else if (ArrayBuffer.isView(source)) {
          source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
        } else if (Array.isArray(source)) {
          source = Uint8Array.from(source);
        }
        if (!(source instanceof Uint8Array)) {
          throw new TypeError("Expected Uint8Array");
        }
        if (source.length === 0) {
          return "";
        }
        var zeroes = 0;
        var length2 = 0;
        var pbegin = 0;
        var pend = source.length;
        while (pbegin !== pend && source[pbegin] === 0) {
          pbegin++;
          zeroes++;
        }
        var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
        var b58 = new Uint8Array(size);
        while (pbegin !== pend) {
          var carry = source[pbegin];
          var i2 = 0;
          for (var it1 = size - 1; (carry !== 0 || i2 < length2) && it1 !== -1; it1--, i2++) {
            carry += 256 * b58[it1] >>> 0;
            b58[it1] = carry % BASE >>> 0;
            carry = carry / BASE >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length2 = i2;
          pbegin++;
        }
        var it2 = size - length2;
        while (it2 !== size && b58[it2] === 0) {
          it2++;
        }
        var str = LEADER.repeat(zeroes);
        for (; it2 < size; ++it2) {
          str += ALPHABET.charAt(b58[it2]);
        }
        return str;
      }
      function decodeUnsafe(source) {
        if (typeof source !== "string") {
          throw new TypeError("Expected String");
        }
        if (source.length === 0) {
          return new Uint8Array();
        }
        var psz = 0;
        if (source[psz] === " ") {
          return;
        }
        var zeroes = 0;
        var length2 = 0;
        while (source[psz] === LEADER) {
          zeroes++;
          psz++;
        }
        var size = (source.length - psz) * FACTOR + 1 >>> 0;
        var b256 = new Uint8Array(size);
        while (source[psz]) {
          var carry = BASE_MAP[source.charCodeAt(psz)];
          if (carry === 255) {
            return;
          }
          var i2 = 0;
          for (var it3 = size - 1; (carry !== 0 || i2 < length2) && it3 !== -1; it3--, i2++) {
            carry += BASE * b256[it3] >>> 0;
            b256[it3] = carry % 256 >>> 0;
            carry = carry / 256 >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length2 = i2;
          psz++;
        }
        if (source[psz] === " ") {
          return;
        }
        var it4 = size - length2;
        while (it4 !== size && b256[it4] === 0) {
          it4++;
        }
        var vch = new Uint8Array(zeroes + (size - it4));
        var j2 = zeroes;
        while (it4 !== size) {
          vch[j2++] = b256[it4++];
        }
        return vch;
      }
      function decode12(string2) {
        var buffer2 = decodeUnsafe(string2);
        if (buffer2) {
          return buffer2;
        }
        throw new Error(`Non-${name5} character`);
      }
      return {
        encode: encode12,
        decodeUnsafe,
        decode: decode12
      };
    }
    var src2 = base3;
    var _brrp__multiformats_scope_baseX2 = src2;
    module2.exports = _brrp__multiformats_scope_baseX2;
  }
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/bytes.js
var require_bytes = __commonJS({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/bytes.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var empty2 = new Uint8Array(0);
    var toHex2 = (d) => d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, "0"), "");
    var fromHex2 = (hex) => {
      const hexes = hex.match(/../g);
      return hexes ? new Uint8Array(hexes.map((b) => parseInt(b, 16))) : empty2;
    };
    var equals3 = (aa, bb) => {
      if (aa === bb)
        return true;
      if (aa.byteLength !== bb.byteLength) {
        return false;
      }
      for (let ii = 0; ii < aa.byteLength; ii++) {
        if (aa[ii] !== bb[ii]) {
          return false;
        }
      }
      return true;
    };
    var coerce3 = (o) => {
      if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
        return o;
      if (o instanceof ArrayBuffer)
        return new Uint8Array(o);
      if (ArrayBuffer.isView(o)) {
        return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
      }
      throw new Error("Unknown type, must be binary type");
    };
    var isBinary2 = (o) => o instanceof ArrayBuffer || ArrayBuffer.isView(o);
    var fromString4 = (str) => new TextEncoder().encode(str);
    var toString3 = (b) => new TextDecoder().decode(b);
    exports2.coerce = coerce3;
    exports2.empty = empty2;
    exports2.equals = equals3;
    exports2.fromHex = fromHex2;
    exports2.fromString = fromString4;
    exports2.isBinary = isBinary2;
    exports2.toHex = toHex2;
    exports2.toString = toString3;
  }
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/bases/base.js
var require_base = __commonJS({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/bases/base.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var baseX$1 = require_base_x();
    var bytes = require_bytes();
    var Encoder3 = class {
      constructor(name5, prefix, baseEncode) {
        this.name = name5;
        this.prefix = prefix;
        this.baseEncode = baseEncode;
      }
      encode(bytes2) {
        if (bytes2 instanceof Uint8Array) {
          return `${this.prefix}${this.baseEncode(bytes2)}`;
        } else {
          throw Error("Unknown type, must be binary type");
        }
      }
    };
    var Decoder3 = class {
      constructor(name5, prefix, baseDecode) {
        this.name = name5;
        this.prefix = prefix;
        if (prefix.codePointAt(0) === void 0) {
          throw new Error("Invalid prefix character");
        }
        this.prefixCodePoint = prefix.codePointAt(0);
        this.baseDecode = baseDecode;
      }
      decode(text) {
        if (typeof text === "string") {
          if (text.codePointAt(0) !== this.prefixCodePoint) {
            throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
          }
          return this.baseDecode(text.slice(this.prefix.length));
        } else {
          throw Error("Can only multibase decode strings");
        }
      }
      or(decoder2) {
        return or2(this, decoder2);
      }
    };
    var ComposedDecoder2 = class {
      constructor(decoders) {
        this.decoders = decoders;
      }
      or(decoder2) {
        return or2(this, decoder2);
      }
      decode(input) {
        const prefix = input[0];
        const decoder2 = this.decoders[prefix];
        if (decoder2) {
          return decoder2.decode(input);
        } else {
          throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
        }
      }
    };
    var or2 = (left, right) => new ComposedDecoder2(__spreadValues(__spreadValues({}, left.decoders || { [left.prefix]: left }), right.decoders || { [right.prefix]: right }));
    var Codec2 = class {
      constructor(name5, prefix, baseEncode, baseDecode) {
        this.name = name5;
        this.prefix = prefix;
        this.baseEncode = baseEncode;
        this.baseDecode = baseDecode;
        this.encoder = new Encoder3(name5, prefix, baseEncode);
        this.decoder = new Decoder3(name5, prefix, baseDecode);
      }
      encode(input) {
        return this.encoder.encode(input);
      }
      decode(input) {
        return this.decoder.decode(input);
      }
    };
    var from3 = ({ name: name5, prefix, encode: encode13, decode: decode13 }) => new Codec2(name5, prefix, encode13, decode13);
    var baseX2 = ({ prefix, name: name5, alphabet: alphabet2 }) => {
      const { encode: encode13, decode: decode13 } = baseX$1(alphabet2, name5);
      return from3({
        prefix,
        name: name5,
        encode: encode13,
        decode: (text) => bytes.coerce(decode13(text))
      });
    };
    var decode12 = (string2, alphabet2, bitsPerChar, name5) => {
      const codes = {};
      for (let i = 0; i < alphabet2.length; ++i) {
        codes[alphabet2[i]] = i;
      }
      let end = string2.length;
      while (string2[end - 1] === "=") {
        --end;
      }
      const out = new Uint8Array(end * bitsPerChar / 8 | 0);
      let bits = 0;
      let buffer2 = 0;
      let written = 0;
      for (let i = 0; i < end; ++i) {
        const value = codes[string2[i]];
        if (value === void 0) {
          throw new SyntaxError(`Non-${name5} character`);
        }
        buffer2 = buffer2 << bitsPerChar | value;
        bits += bitsPerChar;
        if (bits >= 8) {
          bits -= 8;
          out[written++] = 255 & buffer2 >> bits;
        }
      }
      if (bits >= bitsPerChar || 255 & buffer2 << 8 - bits) {
        throw new SyntaxError("Unexpected end of data");
      }
      return out;
    };
    var encode12 = (data, alphabet2, bitsPerChar) => {
      const pad = alphabet2[alphabet2.length - 1] === "=";
      const mask = (1 << bitsPerChar) - 1;
      let out = "";
      let bits = 0;
      let buffer2 = 0;
      for (let i = 0; i < data.length; ++i) {
        buffer2 = buffer2 << 8 | data[i];
        bits += 8;
        while (bits > bitsPerChar) {
          bits -= bitsPerChar;
          out += alphabet2[mask & buffer2 >> bits];
        }
      }
      if (bits) {
        out += alphabet2[mask & buffer2 << bitsPerChar - bits];
      }
      if (pad) {
        while (out.length * bitsPerChar & 7) {
          out += "=";
        }
      }
      return out;
    };
    var rfc46482 = ({ name: name5, prefix, bitsPerChar, alphabet: alphabet2 }) => {
      return from3({
        prefix,
        name: name5,
        encode(input) {
          return encode12(input, alphabet2, bitsPerChar);
        },
        decode(input) {
          return decode12(input, alphabet2, bitsPerChar, name5);
        }
      });
    };
    exports2.Codec = Codec2;
    exports2.baseX = baseX2;
    exports2.from = from3;
    exports2.or = or2;
    exports2.rfc4648 = rfc46482;
  }
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/bases/identity.js
var require_identity = __commonJS({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/bases/identity.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var base3 = require_base();
    var bytes = require_bytes();
    var identity3 = base3.from({
      prefix: "\0",
      name: "identity",
      encode: (buf2) => bytes.toString(buf2),
      decode: (str) => bytes.fromString(str)
    });
    exports2.identity = identity3;
  }
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/bases/base2.js
var require_base2 = __commonJS({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/bases/base2.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var base3 = require_base();
    var base22 = base3.rfc4648({
      prefix: "0",
      name: "base2",
      alphabet: "01",
      bitsPerChar: 1
    });
    exports2.base2 = base22;
  }
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/bases/base8.js
var require_base8 = __commonJS({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/bases/base8.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var base3 = require_base();
    var base82 = base3.rfc4648({
      prefix: "7",
      name: "base8",
      alphabet: "01234567",
      bitsPerChar: 3
    });
    exports2.base8 = base82;
  }
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/bases/base10.js
var require_base10 = __commonJS({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/bases/base10.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var base3 = require_base();
    var base102 = base3.baseX({
      prefix: "9",
      name: "base10",
      alphabet: "0123456789"
    });
    exports2.base10 = base102;
  }
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/bases/base16.js
var require_base16 = __commonJS({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/bases/base16.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var base3 = require_base();
    var base162 = base3.rfc4648({
      prefix: "f",
      name: "base16",
      alphabet: "0123456789abcdef",
      bitsPerChar: 4
    });
    var base16upper2 = base3.rfc4648({
      prefix: "F",
      name: "base16upper",
      alphabet: "0123456789ABCDEF",
      bitsPerChar: 4
    });
    exports2.base16 = base162;
    exports2.base16upper = base16upper2;
  }
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/bases/base32.js
var require_base32 = __commonJS({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/bases/base32.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var base3 = require_base();
    var base322 = base3.rfc4648({
      prefix: "b",
      name: "base32",
      alphabet: "abcdefghijklmnopqrstuvwxyz234567",
      bitsPerChar: 5
    });
    var base32upper2 = base3.rfc4648({
      prefix: "B",
      name: "base32upper",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
      bitsPerChar: 5
    });
    var base32pad2 = base3.rfc4648({
      prefix: "c",
      name: "base32pad",
      alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
      bitsPerChar: 5
    });
    var base32padupper2 = base3.rfc4648({
      prefix: "C",
      name: "base32padupper",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
      bitsPerChar: 5
    });
    var base32hex2 = base3.rfc4648({
      prefix: "v",
      name: "base32hex",
      alphabet: "0123456789abcdefghijklmnopqrstuv",
      bitsPerChar: 5
    });
    var base32hexupper2 = base3.rfc4648({
      prefix: "V",
      name: "base32hexupper",
      alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
      bitsPerChar: 5
    });
    var base32hexpad2 = base3.rfc4648({
      prefix: "t",
      name: "base32hexpad",
      alphabet: "0123456789abcdefghijklmnopqrstuv=",
      bitsPerChar: 5
    });
    var base32hexpadupper2 = base3.rfc4648({
      prefix: "T",
      name: "base32hexpadupper",
      alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
      bitsPerChar: 5
    });
    var base32z2 = base3.rfc4648({
      prefix: "h",
      name: "base32z",
      alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
      bitsPerChar: 5
    });
    exports2.base32 = base322;
    exports2.base32hex = base32hex2;
    exports2.base32hexpad = base32hexpad2;
    exports2.base32hexpadupper = base32hexpadupper2;
    exports2.base32hexupper = base32hexupper2;
    exports2.base32pad = base32pad2;
    exports2.base32padupper = base32padupper2;
    exports2.base32upper = base32upper2;
    exports2.base32z = base32z2;
  }
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/bases/base36.js
var require_base36 = __commonJS({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/bases/base36.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var base3 = require_base();
    var base362 = base3.baseX({
      prefix: "k",
      name: "base36",
      alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
    });
    var base36upper2 = base3.baseX({
      prefix: "K",
      name: "base36upper",
      alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    });
    exports2.base36 = base362;
    exports2.base36upper = base36upper2;
  }
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/bases/base58.js
var require_base58 = __commonJS({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/bases/base58.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var base3 = require_base();
    var base58btc2 = base3.baseX({
      name: "base58btc",
      prefix: "z",
      alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
    });
    var base58flickr2 = base3.baseX({
      name: "base58flickr",
      prefix: "Z",
      alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
    });
    exports2.base58btc = base58btc2;
    exports2.base58flickr = base58flickr2;
  }
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/bases/base64.js
var require_base642 = __commonJS({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/bases/base64.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var base3 = require_base();
    var base642 = base3.rfc4648({
      prefix: "m",
      name: "base64",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
      bitsPerChar: 6
    });
    var base64pad2 = base3.rfc4648({
      prefix: "M",
      name: "base64pad",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
      bitsPerChar: 6
    });
    var base64url2 = base3.rfc4648({
      prefix: "u",
      name: "base64url",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
      bitsPerChar: 6
    });
    var base64urlpad2 = base3.rfc4648({
      prefix: "U",
      name: "base64urlpad",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
      bitsPerChar: 6
    });
    exports2.base64 = base642;
    exports2.base64pad = base64pad2;
    exports2.base64url = base64url2;
    exports2.base64urlpad = base64urlpad2;
  }
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/bases/base256emoji.js
var require_base256emoji = __commonJS({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/bases/base256emoji.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var base3 = require_base();
    var alphabet2 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
    var alphabetBytesToChars2 = alphabet2.reduce((p, c, i) => {
      p[i] = c;
      return p;
    }, []);
    var alphabetCharsToBytes2 = alphabet2.reduce((p, c, i) => {
      p[c.codePointAt(0)] = i;
      return p;
    }, []);
    function encode12(data) {
      return data.reduce((p, c) => {
        p += alphabetBytesToChars2[c];
        return p;
      }, "");
    }
    function decode12(str) {
      const byts = [];
      for (const char of str) {
        const byt = alphabetCharsToBytes2[char.codePointAt(0)];
        if (byt === void 0) {
          throw new Error(`Non-base256emoji character: ${char}`);
        }
        byts.push(byt);
      }
      return new Uint8Array(byts);
    }
    var base256emoji2 = base3.from({
      prefix: "\u{1F680}",
      name: "base256emoji",
      encode: encode12,
      decode: decode12
    });
    exports2.base256emoji = base256emoji2;
  }
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/vendor/varint.js
var require_varint2 = __commonJS({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/vendor/varint.js"(exports2, module2) {
    "use strict";
    var encode_12 = encode12;
    var MSB2 = 128;
    var REST2 = 127;
    var MSBALL2 = ~REST2;
    var INT2 = Math.pow(2, 31);
    function encode12(num, out, offset) {
      out = out || [];
      offset = offset || 0;
      var oldOffset = offset;
      while (num >= INT2) {
        out[offset++] = num & 255 | MSB2;
        num /= 128;
      }
      while (num & MSBALL2) {
        out[offset++] = num & 255 | MSB2;
        num >>>= 7;
      }
      out[offset] = num | 0;
      encode12.bytes = offset - oldOffset + 1;
      return out;
    }
    var decode12 = read2;
    var MSB$12 = 128;
    var REST$12 = 127;
    function read2(buf2, offset) {
      var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf2.length;
      do {
        if (counter >= l) {
          read2.bytes = 0;
          throw new RangeError("Could not decode varint");
        }
        b = buf2[counter++];
        res += shift < 28 ? (b & REST$12) << shift : (b & REST$12) * Math.pow(2, shift);
        shift += 7;
      } while (b >= MSB$12);
      read2.bytes = counter - offset;
      return res;
    }
    var N12 = Math.pow(2, 7);
    var N22 = Math.pow(2, 14);
    var N32 = Math.pow(2, 21);
    var N42 = Math.pow(2, 28);
    var N52 = Math.pow(2, 35);
    var N62 = Math.pow(2, 42);
    var N72 = Math.pow(2, 49);
    var N82 = Math.pow(2, 56);
    var N92 = Math.pow(2, 63);
    var length2 = function(value) {
      return value < N12 ? 1 : value < N22 ? 2 : value < N32 ? 3 : value < N42 ? 4 : value < N52 ? 5 : value < N62 ? 6 : value < N72 ? 7 : value < N82 ? 8 : value < N92 ? 9 : 10;
    };
    var varint4 = {
      encode: encode_12,
      decode: decode12,
      encodingLength: length2
    };
    var _brrp_varint2 = varint4;
    var varint$1 = _brrp_varint2;
    module2.exports = varint$1;
  }
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/varint.js
var require_varint3 = __commonJS({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/varint.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var varint$1 = require_varint2();
    var decode12 = (data, offset = 0) => {
      const code5 = varint$1.decode(data, offset);
      return [
        code5,
        varint$1.decode.bytes
      ];
    };
    var encodeTo2 = (int, target, offset = 0) => {
      varint$1.encode(int, target, offset);
      return target;
    };
    var encodingLength2 = (int) => {
      return varint$1.encodingLength(int);
    };
    exports2.decode = decode12;
    exports2.encodeTo = encodeTo2;
    exports2.encodingLength = encodingLength2;
  }
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/hashes/digest.js
var require_digest = __commonJS({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/hashes/digest.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var bytes = require_bytes();
    var varint4 = require_varint3();
    var create4 = (code5, digest2) => {
      const size = digest2.byteLength;
      const sizeOffset = varint4.encodingLength(code5);
      const digestOffset = sizeOffset + varint4.encodingLength(size);
      const bytes2 = new Uint8Array(digestOffset + size);
      varint4.encodeTo(code5, bytes2, 0);
      varint4.encodeTo(size, bytes2, sizeOffset);
      bytes2.set(digest2, digestOffset);
      return new Digest2(code5, size, digest2, bytes2);
    };
    var decode12 = (multihash) => {
      const bytes$1 = bytes.coerce(multihash);
      const [code5, sizeOffset] = varint4.decode(bytes$1);
      const [size, digestOffset] = varint4.decode(bytes$1.subarray(sizeOffset));
      const digest2 = bytes$1.subarray(sizeOffset + digestOffset);
      if (digest2.byteLength !== size) {
        throw new Error("Incorrect length");
      }
      return new Digest2(code5, size, digest2, bytes$1);
    };
    var equals3 = (a, b) => {
      if (a === b) {
        return true;
      } else {
        return a.code === b.code && a.size === b.size && bytes.equals(a.bytes, b.bytes);
      }
    };
    var Digest2 = class {
      constructor(code5, size, digest2, bytes2) {
        this.code = code5;
        this.size = size;
        this.digest = digest2;
        this.bytes = bytes2;
      }
    };
    exports2.Digest = Digest2;
    exports2.create = create4;
    exports2.decode = decode12;
    exports2.equals = equals3;
  }
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/hashes/hasher.js
var require_hasher = __commonJS({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/hashes/hasher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var digest2 = require_digest();
    var from3 = ({ name: name5, code: code5, encode: encode12 }) => new Hasher2(name5, code5, encode12);
    var Hasher2 = class {
      constructor(name5, code5, encode12) {
        this.name = name5;
        this.code = code5;
        this.encode = encode12;
      }
      digest(input) {
        if (input instanceof Uint8Array) {
          const result = this.encode(input);
          return result instanceof Uint8Array ? digest2.create(this.code, result) : result.then((digest$1) => digest2.create(this.code, digest$1));
        } else {
          throw Error("Unknown type, must be binary type");
        }
      }
    };
    exports2.Hasher = Hasher2;
    exports2.from = from3;
  }
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/hashes/sha2.js
var require_sha2 = __commonJS({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/hashes/sha2.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var crypto2 = require("crypto");
    var hasher = require_hasher();
    var bytes = require_bytes();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var crypto__default = /* @__PURE__ */ _interopDefaultLegacy(crypto2);
    var sha2562 = hasher.from({
      name: "sha2-256",
      code: 18,
      encode: (input) => bytes.coerce(crypto__default["default"].createHash("sha256").update(input).digest())
    });
    var sha5122 = hasher.from({
      name: "sha2-512",
      code: 19,
      encode: (input) => bytes.coerce(crypto__default["default"].createHash("sha512").update(input).digest())
    });
    exports2.sha256 = sha2562;
    exports2.sha512 = sha5122;
  }
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/hashes/identity.js
var require_identity2 = __commonJS({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/hashes/identity.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var bytes = require_bytes();
    var digest$1 = require_digest();
    var code5 = 0;
    var name5 = "identity";
    var encode12 = bytes.coerce;
    var digest2 = (input) => digest$1.create(code5, encode12(input));
    var identity3 = {
      code: code5,
      name: name5,
      encode: encode12,
      digest: digest2
    };
    exports2.identity = identity3;
  }
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/codecs/raw.js
var require_raw = __commonJS({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/codecs/raw.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var bytes = require_bytes();
    var name5 = "raw";
    var code5 = 85;
    var encode12 = (node) => bytes.coerce(node);
    var decode12 = (data) => bytes.coerce(data);
    exports2.code = code5;
    exports2.decode = decode12;
    exports2.encode = encode12;
    exports2.name = name5;
  }
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/codecs/json.js
var require_json = __commonJS({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/codecs/json.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var textEncoder5 = new TextEncoder();
    var textDecoder4 = new TextDecoder();
    var name5 = "json";
    var code5 = 512;
    var encode12 = (node) => textEncoder5.encode(JSON.stringify(node));
    var decode12 = (data) => JSON.parse(textDecoder4.decode(data));
    exports2.code = code5;
    exports2.decode = decode12;
    exports2.encode = encode12;
    exports2.name = name5;
  }
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/cid.js
var require_cid = __commonJS({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/cid.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var varint4 = require_varint3();
    var digest2 = require_digest();
    var base58 = require_base58();
    var base322 = require_base32();
    var bytes = require_bytes();
    var CID2 = class _CID {
      constructor(version3, code5, multihash, bytes2) {
        this.code = code5;
        this.version = version3;
        this.multihash = multihash;
        this.bytes = bytes2;
        this.byteOffset = bytes2.byteOffset;
        this.byteLength = bytes2.byteLength;
        this.asCID = this;
        this._baseCache = /* @__PURE__ */ new Map();
        Object.defineProperties(this, {
          byteOffset: hidden2,
          byteLength: hidden2,
          code: readonly3,
          version: readonly3,
          multihash: readonly3,
          bytes: readonly3,
          _baseCache: hidden2,
          asCID: hidden2
        });
      }
      toV0() {
        switch (this.version) {
          case 0: {
            return this;
          }
          default: {
            const { code: code5, multihash } = this;
            if (code5 !== DAG_PB_CODE2) {
              throw new Error("Cannot convert a non dag-pb CID to CIDv0");
            }
            if (multihash.code !== SHA_256_CODE2) {
              throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
            }
            return _CID.createV0(multihash);
          }
        }
      }
      toV1() {
        switch (this.version) {
          case 0: {
            const { code: code5, digest: digest$1 } = this.multihash;
            const multihash = digest2.create(code5, digest$1);
            return _CID.createV1(this.code, multihash);
          }
          case 1: {
            return this;
          }
          default: {
            throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
          }
        }
      }
      equals(other) {
        return other && this.code === other.code && this.version === other.version && digest2.equals(this.multihash, other.multihash);
      }
      toString(base3) {
        const { bytes: bytes2, version: version3, _baseCache } = this;
        switch (version3) {
          case 0:
            return toStringV02(bytes2, _baseCache, base3 || base58.base58btc.encoder);
          default:
            return toStringV12(bytes2, _baseCache, base3 || base322.base32.encoder);
        }
      }
      toJSON() {
        return {
          code: this.code,
          version: this.version,
          hash: this.multihash.bytes
        };
      }
      get [Symbol.toStringTag]() {
        return "CID";
      }
      [Symbol.for("nodejs.util.inspect.custom")]() {
        return "CID(" + this.toString() + ")";
      }
      static isCID(value) {
        deprecate2(/^0\.0/, IS_CID_DEPRECATION2);
        return !!(value && (value[cidSymbol2] || value.asCID === value));
      }
      get toBaseEncodedString() {
        throw new Error("Deprecated, use .toString()");
      }
      get codec() {
        throw new Error('"codec" property is deprecated, use integer "code" property instead');
      }
      get buffer() {
        throw new Error("Deprecated .buffer property, use .bytes to get Uint8Array instead");
      }
      get multibaseName() {
        throw new Error('"multibaseName" property is deprecated');
      }
      get prefix() {
        throw new Error('"prefix" property is deprecated');
      }
      static asCID(value) {
        if (value instanceof _CID) {
          return value;
        } else if (value != null && value.asCID === value) {
          const { version: version3, code: code5, multihash, bytes: bytes2 } = value;
          return new _CID(version3, code5, multihash, bytes2 || encodeCID2(version3, code5, multihash.bytes));
        } else if (value != null && value[cidSymbol2] === true) {
          const { version: version3, multihash, code: code5 } = value;
          const digest$1 = digest2.decode(multihash);
          return _CID.create(version3, code5, digest$1);
        } else {
          return null;
        }
      }
      static create(version3, code5, digest3) {
        if (typeof code5 !== "number") {
          throw new Error("String codecs are no longer supported");
        }
        switch (version3) {
          case 0: {
            if (code5 !== DAG_PB_CODE2) {
              throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE2}) block encoding`);
            } else {
              return new _CID(version3, code5, digest3, digest3.bytes);
            }
          }
          case 1: {
            const bytes2 = encodeCID2(version3, code5, digest3.bytes);
            return new _CID(version3, code5, digest3, bytes2);
          }
          default: {
            throw new Error("Invalid version");
          }
        }
      }
      static createV0(digest3) {
        return _CID.create(0, DAG_PB_CODE2, digest3);
      }
      static createV1(code5, digest3) {
        return _CID.create(1, code5, digest3);
      }
      static decode(bytes2) {
        const [cid, remainder] = _CID.decodeFirst(bytes2);
        if (remainder.length) {
          throw new Error("Incorrect length");
        }
        return cid;
      }
      static decodeFirst(bytes$1) {
        const specs = _CID.inspectBytes(bytes$1);
        const prefixSize = specs.size - specs.multihashSize;
        const multihashBytes = bytes.coerce(bytes$1.subarray(prefixSize, prefixSize + specs.multihashSize));
        if (multihashBytes.byteLength !== specs.multihashSize) {
          throw new Error("Incorrect length");
        }
        const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
        const digest$1 = new digest2.Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
        const cid = specs.version === 0 ? _CID.createV0(digest$1) : _CID.createV1(specs.codec, digest$1);
        return [
          cid,
          bytes$1.subarray(specs.size)
        ];
      }
      static inspectBytes(initialBytes) {
        let offset = 0;
        const next = () => {
          const [i, length2] = varint4.decode(initialBytes.subarray(offset));
          offset += length2;
          return i;
        };
        let version3 = next();
        let codec = DAG_PB_CODE2;
        if (version3 === 18) {
          version3 = 0;
          offset = 0;
        } else if (version3 === 1) {
          codec = next();
        }
        if (version3 !== 0 && version3 !== 1) {
          throw new RangeError(`Invalid CID version ${version3}`);
        }
        const prefixSize = offset;
        const multihashCode = next();
        const digestSize = next();
        const size = offset + digestSize;
        const multihashSize = size - prefixSize;
        return {
          version: version3,
          codec,
          multihashCode,
          digestSize,
          multihashSize,
          size
        };
      }
      static parse(source, base3) {
        const [prefix, bytes2] = parseCIDtoBytes2(source, base3);
        const cid = _CID.decode(bytes2);
        cid._baseCache.set(prefix, source);
        return cid;
      }
    };
    var parseCIDtoBytes2 = (source, base3) => {
      switch (source[0]) {
        case "Q": {
          const decoder2 = base3 || base58.base58btc;
          return [
            base58.base58btc.prefix,
            decoder2.decode(`${base58.base58btc.prefix}${source}`)
          ];
        }
        case base58.base58btc.prefix: {
          const decoder2 = base3 || base58.base58btc;
          return [
            base58.base58btc.prefix,
            decoder2.decode(source)
          ];
        }
        case base322.base32.prefix: {
          const decoder2 = base3 || base322.base32;
          return [
            base322.base32.prefix,
            decoder2.decode(source)
          ];
        }
        default: {
          if (base3 == null) {
            throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
          }
          return [
            source[0],
            base3.decode(source)
          ];
        }
      }
    };
    var toStringV02 = (bytes2, cache, base3) => {
      const { prefix } = base3;
      if (prefix !== base58.base58btc.prefix) {
        throw Error(`Cannot string encode V0 in ${base3.name} encoding`);
      }
      const cid = cache.get(prefix);
      if (cid == null) {
        const cid2 = base3.encode(bytes2).slice(1);
        cache.set(prefix, cid2);
        return cid2;
      } else {
        return cid;
      }
    };
    var toStringV12 = (bytes2, cache, base3) => {
      const { prefix } = base3;
      const cid = cache.get(prefix);
      if (cid == null) {
        const cid2 = base3.encode(bytes2);
        cache.set(prefix, cid2);
        return cid2;
      } else {
        return cid;
      }
    };
    var DAG_PB_CODE2 = 112;
    var SHA_256_CODE2 = 18;
    var encodeCID2 = (version3, code5, multihash) => {
      const codeOffset = varint4.encodingLength(version3);
      const hashOffset = codeOffset + varint4.encodingLength(code5);
      const bytes2 = new Uint8Array(hashOffset + multihash.byteLength);
      varint4.encodeTo(version3, bytes2, 0);
      varint4.encodeTo(code5, bytes2, codeOffset);
      bytes2.set(multihash, hashOffset);
      return bytes2;
    };
    var cidSymbol2 = Symbol.for("@ipld/js-cid/CID");
    var readonly3 = {
      writable: false,
      configurable: false,
      enumerable: true
    };
    var hidden2 = {
      writable: false,
      enumerable: false,
      configurable: false
    };
    var version2 = "0.0.0-dev";
    var deprecate2 = (range, message) => {
      if (range.test(version2)) {
        console.warn(message);
      } else {
        throw new Error(message);
      }
    };
    var IS_CID_DEPRECATION2 = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`;
    exports2.CID = CID2;
  }
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/index.js
var require_src2 = __commonJS({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var cid = require_cid();
    var varint4 = require_varint3();
    var bytes = require_bytes();
    var hasher = require_hasher();
    var digest2 = require_digest();
    exports2.CID = cid.CID;
    exports2.varint = varint4;
    exports2.bytes = bytes;
    exports2.hasher = hasher;
    exports2.digest = digest2;
  }
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/basics.js
var require_basics = __commonJS({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/basics.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var identity3 = require_identity();
    var base22 = require_base2();
    var base82 = require_base8();
    var base102 = require_base10();
    var base162 = require_base16();
    var base322 = require_base32();
    var base362 = require_base36();
    var base58 = require_base58();
    var base642 = require_base642();
    var base256emoji2 = require_base256emoji();
    var sha2 = require_sha2();
    var identity$1 = require_identity2();
    var raw = require_raw();
    var json = require_json();
    require_src2();
    var cid = require_cid();
    var hasher = require_hasher();
    var digest2 = require_digest();
    var varint4 = require_varint3();
    var bytes = require_bytes();
    var bases2 = __spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({}, identity3), base22), base82), base102), base162), base322), base362), base58), base642), base256emoji2);
    var hashes2 = __spreadValues(__spreadValues({}, sha2), identity$1);
    var codecs = {
      raw,
      json
    };
    exports2.CID = cid.CID;
    exports2.hasher = hasher;
    exports2.digest = digest2;
    exports2.varint = varint4;
    exports2.bytes = bytes;
    exports2.bases = bases2;
    exports2.codecs = codecs;
    exports2.hashes = hashes2;
  }
});

// ../../node_modules/.pnpm/uint8arrays@3.1.1/node_modules/uint8arrays/cjs/src/util/as-uint8array.js
var require_as_uint8array = __commonJS({
  "../../node_modules/.pnpm/uint8arrays@3.1.1/node_modules/uint8arrays/cjs/src/util/as-uint8array.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function asUint8Array2(buf2) {
      if (globalThis.Buffer != null) {
        return new Uint8Array(buf2.buffer, buf2.byteOffset, buf2.byteLength);
      }
      return buf2;
    }
    exports2.asUint8Array = asUint8Array2;
  }
});

// ../../node_modules/.pnpm/uint8arrays@3.1.1/node_modules/uint8arrays/cjs/src/alloc.js
var require_alloc = __commonJS({
  "../../node_modules/.pnpm/uint8arrays@3.1.1/node_modules/uint8arrays/cjs/src/alloc.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var asUint8array = require_as_uint8array();
    function alloc2(size = 0) {
      if (globalThis.Buffer != null && globalThis.Buffer.alloc != null) {
        return asUint8array.asUint8Array(globalThis.Buffer.alloc(size));
      }
      return new Uint8Array(size);
    }
    function allocUnsafe2(size = 0) {
      if (globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null) {
        return asUint8array.asUint8Array(globalThis.Buffer.allocUnsafe(size));
      }
      return new Uint8Array(size);
    }
    exports2.alloc = alloc2;
    exports2.allocUnsafe = allocUnsafe2;
  }
});

// ../../node_modules/.pnpm/uint8arrays@3.1.1/node_modules/uint8arrays/cjs/src/util/bases.js
var require_bases = __commonJS({
  "../../node_modules/.pnpm/uint8arrays@3.1.1/node_modules/uint8arrays/cjs/src/util/bases.js"(exports2, module2) {
    "use strict";
    var basics = require_basics();
    var alloc2 = require_alloc();
    function createCodec2(name5, prefix, encode12, decode12) {
      return {
        name: name5,
        prefix,
        encoder: {
          name: name5,
          prefix,
          encode: encode12
        },
        decoder: { decode: decode12 }
      };
    }
    var string2 = createCodec2("utf8", "u", (buf2) => {
      const decoder2 = new TextDecoder("utf8");
      return "u" + decoder2.decode(buf2);
    }, (str) => {
      const encoder2 = new TextEncoder();
      return encoder2.encode(str.substring(1));
    });
    var ascii2 = createCodec2("ascii", "a", (buf2) => {
      let string3 = "a";
      for (let i = 0; i < buf2.length; i++) {
        string3 += String.fromCharCode(buf2[i]);
      }
      return string3;
    }, (str) => {
      str = str.substring(1);
      const buf2 = alloc2.allocUnsafe(str.length);
      for (let i = 0; i < str.length; i++) {
        buf2[i] = str.charCodeAt(i);
      }
      return buf2;
    });
    var BASES2 = __spreadValues({
      utf8: string2,
      "utf-8": string2,
      hex: basics.bases.base16,
      latin1: ascii2,
      ascii: ascii2,
      binary: ascii2
    }, basics.bases);
    module2.exports = BASES2;
  }
});

// ../../node_modules/.pnpm/uint8arrays@3.1.1/node_modules/uint8arrays/cjs/src/from-string.js
var require_from_string = __commonJS({
  "../../node_modules/.pnpm/uint8arrays@3.1.1/node_modules/uint8arrays/cjs/src/from-string.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var bases2 = require_bases();
    var asUint8array = require_as_uint8array();
    function fromString4(string2, encoding = "utf8") {
      const base3 = bases2[encoding];
      if (!base3) {
        throw new Error(`Unsupported encoding "${encoding}"`);
      }
      if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
        return asUint8array.asUint8Array(globalThis.Buffer.from(string2, "utf-8"));
      }
      return base3.decoder.decode(`${base3.prefix}${string2}`);
    }
    exports2.fromString = fromString4;
  }
});

// ../../node_modules/.pnpm/hamt-sharding@2.0.1/node_modules/hamt-sharding/src/bucket.js
var require_bucket = __commonJS({
  "../../node_modules/.pnpm/hamt-sharding@2.0.1/node_modules/hamt-sharding/src/bucket.js"(exports2, module2) {
    "use strict";
    var SparseArray = require_sparse_array();
    var { fromString: uint8ArrayFromString } = require_from_string();
    var Bucket2 = class _Bucket {
      /**
       * @param {BucketOptions} options
       * @param {Bucket<T>} [parent]
       * @param {number} [posAtParent=0]
       */
      constructor(options, parent, posAtParent = 0) {
        this._options = options;
        this._popCount = 0;
        this._parent = parent;
        this._posAtParent = posAtParent;
        this._children = new SparseArray();
        this.key = null;
      }
      /**
       * @param {string} key
       * @param {T} value
       */
      put(key, value) {
        return __async(this, null, function* () {
          const place = yield this._findNewBucketAndPos(key);
          yield place.bucket._putAt(place, key, value);
        });
      }
      /**
       * @param {string} key
       */
      get(key) {
        return __async(this, null, function* () {
          const child = yield this._findChild(key);
          if (child) {
            return child.value;
          }
        });
      }
      /**
       * @param {string} key
       */
      del(key) {
        return __async(this, null, function* () {
          const place = yield this._findPlace(key);
          const child = place.bucket._at(place.pos);
          if (child && child.key === key) {
            place.bucket._delAt(place.pos);
          }
        });
      }
      /**
       * @returns {number}
       */
      leafCount() {
        const children = this._children.compactArray();
        return children.reduce((acc, child) => {
          if (child instanceof _Bucket) {
            return acc + child.leafCount();
          }
          return acc + 1;
        }, 0);
      }
      childrenCount() {
        return this._children.length;
      }
      onlyChild() {
        return this._children.get(0);
      }
      /**
       * @returns {Iterable<BucketChild<T>>}
       */
      *eachLeafSeries() {
        const children = this._children.compactArray();
        for (const child of children) {
          if (child instanceof _Bucket) {
            yield* __yieldStar(child.eachLeafSeries());
          } else {
            yield child;
          }
        }
        return [];
      }
      /**
       * @param {(value: BucketChild<T>, index: number) => T} map
       * @param {(reduced: any) => any} reduce
       */
      serialize(map3, reduce2) {
        const acc = [];
        return reduce2(this._children.reduce((acc2, child, index) => {
          if (child) {
            if (child instanceof _Bucket) {
              acc2.push(child.serialize(map3, reduce2));
            } else {
              acc2.push(map3(child, index));
            }
          }
          return acc2;
        }, acc));
      }
      /**
       * @param {(value: BucketChild<T>) => Promise<T[]>} asyncMap
       * @param {(reduced: any) => Promise<any>} asyncReduce
       */
      asyncTransform(asyncMap, asyncReduce) {
        return asyncTransformBucket(this, asyncMap, asyncReduce);
      }
      toJSON() {
        return this.serialize(mapNode, reduceNodes);
      }
      prettyPrint() {
        return JSON.stringify(this.toJSON(), null, "  ");
      }
      tableSize() {
        return Math.pow(2, this._options.bits);
      }
      /**
       * @param {string} key
       * @returns {Promise<BucketChild<T> | undefined>}
       */
      _findChild(key) {
        return __async(this, null, function* () {
          const result = yield this._findPlace(key);
          const child = result.bucket._at(result.pos);
          if (child instanceof _Bucket) {
            return void 0;
          }
          if (child && child.key === key) {
            return child;
          }
        });
      }
      /**
       * @param {string | InfiniteHash} key
       * @returns {Promise<BucketPosition<T>>}
       */
      _findPlace(key) {
        return __async(this, null, function* () {
          const hashValue = this._options.hash(typeof key === "string" ? uint8ArrayFromString(key) : key);
          const index = yield hashValue.take(this._options.bits);
          const child = this._children.get(index);
          if (child instanceof _Bucket) {
            return child._findPlace(hashValue);
          }
          return {
            bucket: this,
            pos: index,
            hash: hashValue,
            existingChild: child
          };
        });
      }
      /**
       * @param {string | InfiniteHash} key
       * @returns {Promise<BucketPosition<T>>}
       */
      _findNewBucketAndPos(key) {
        return __async(this, null, function* () {
          const place = yield this._findPlace(key);
          if (place.existingChild && place.existingChild.key !== key) {
            const bucket = new _Bucket(this._options, place.bucket, place.pos);
            place.bucket._putObjectAt(place.pos, bucket);
            const newPlace = yield bucket._findPlace(place.existingChild.hash);
            newPlace.bucket._putAt(newPlace, place.existingChild.key, place.existingChild.value);
            return bucket._findNewBucketAndPos(place.hash);
          }
          return place;
        });
      }
      /**
       * @param {BucketPosition<T>} place
       * @param {string} key
       * @param {T} value
       */
      _putAt(place, key, value) {
        this._putObjectAt(place.pos, {
          key,
          value,
          hash: place.hash
        });
      }
      /**
       * @param {number} pos
       * @param {Bucket<T> | BucketChild<T>} object
       */
      _putObjectAt(pos, object) {
        if (!this._children.get(pos)) {
          this._popCount++;
        }
        this._children.set(pos, object);
      }
      /**
       * @param {number} pos
       */
      _delAt(pos) {
        if (pos === -1) {
          throw new Error("Invalid position");
        }
        if (this._children.get(pos)) {
          this._popCount--;
        }
        this._children.unset(pos);
        this._level();
      }
      _level() {
        if (this._parent && this._popCount <= 1) {
          if (this._popCount === 1) {
            const onlyChild = this._children.find(exists);
            if (onlyChild && !(onlyChild instanceof _Bucket)) {
              const hash = onlyChild.hash;
              hash.untake(this._options.bits);
              const place = {
                pos: this._posAtParent,
                hash,
                bucket: this._parent
              };
              this._parent._putAt(place, onlyChild.key, onlyChild.value);
            }
          } else {
            this._parent._delAt(this._posAtParent);
          }
        }
      }
      /**
       * @param {number} index
       * @returns {BucketChild<T> | Bucket<T> | undefined}
       */
      _at(index) {
        return this._children.get(index);
      }
    };
    function exists(o) {
      return Boolean(o);
    }
    function mapNode(node, index) {
      return node.key;
    }
    function reduceNodes(nodes) {
      return nodes;
    }
    function asyncTransformBucket(bucket, asyncMap, asyncReduce) {
      return __async(this, null, function* () {
        const output = [];
        for (const child of bucket._children.compactArray()) {
          if (child instanceof Bucket2) {
            yield asyncTransformBucket(child, asyncMap, asyncReduce);
          } else {
            const mappedChildren = yield asyncMap(child);
            output.push({
              bitField: bucket._children.bitField(),
              children: mappedChildren
            });
          }
        }
        return asyncReduce(output);
      });
    }
    module2.exports = Bucket2;
  }
});

// ../../node_modules/.pnpm/hamt-sharding@2.0.1/node_modules/hamt-sharding/src/consumable-buffer.js
var require_consumable_buffer = __commonJS({
  "../../node_modules/.pnpm/hamt-sharding@2.0.1/node_modules/hamt-sharding/src/consumable-buffer.js"(exports2, module2) {
    "use strict";
    var START_MASKS = [
      255,
      254,
      252,
      248,
      240,
      224,
      192,
      128
    ];
    var STOP_MASKS = [
      1,
      3,
      7,
      15,
      31,
      63,
      127,
      255
    ];
    module2.exports = class ConsumableBuffer {
      /**
       * @param {Uint8Array} value
       */
      constructor(value) {
        this._value = value;
        this._currentBytePos = value.length - 1;
        this._currentBitPos = 7;
      }
      availableBits() {
        return this._currentBitPos + 1 + this._currentBytePos * 8;
      }
      totalBits() {
        return this._value.length * 8;
      }
      /**
       * @param {number} bits
       */
      take(bits) {
        let pendingBits = bits;
        let result = 0;
        while (pendingBits && this._haveBits()) {
          const byte = this._value[this._currentBytePos];
          const availableBits = this._currentBitPos + 1;
          const taking = Math.min(availableBits, pendingBits);
          const value = byteBitsToInt(byte, availableBits - taking, taking);
          result = (result << taking) + value;
          pendingBits -= taking;
          this._currentBitPos -= taking;
          if (this._currentBitPos < 0) {
            this._currentBitPos = 7;
            this._currentBytePos--;
          }
        }
        return result;
      }
      /**
       * @param {number} bits
       */
      untake(bits) {
        this._currentBitPos += bits;
        while (this._currentBitPos > 7) {
          this._currentBitPos -= 8;
          this._currentBytePos += 1;
        }
      }
      _haveBits() {
        return this._currentBytePos >= 0;
      }
    };
    function byteBitsToInt(byte, start, length2) {
      const mask = maskFor(start, length2);
      return (byte & mask) >>> start;
    }
    function maskFor(start, length2) {
      return START_MASKS[start] & STOP_MASKS[Math.min(length2 + start - 1, 7)];
    }
  }
});

// ../../node_modules/.pnpm/uint8arrays@3.1.1/node_modules/uint8arrays/cjs/src/concat.js
var require_concat = __commonJS({
  "../../node_modules/.pnpm/uint8arrays@3.1.1/node_modules/uint8arrays/cjs/src/concat.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var alloc2 = require_alloc();
    var asUint8array = require_as_uint8array();
    function concat2(arrays, length2) {
      if (!length2) {
        length2 = arrays.reduce((acc, curr) => acc + curr.length, 0);
      }
      const output = alloc2.allocUnsafe(length2);
      let offset = 0;
      for (const arr of arrays) {
        output.set(arr, offset);
        offset += arr.length;
      }
      return asUint8array.asUint8Array(output);
    }
    exports2.concat = concat2;
  }
});

// ../../node_modules/.pnpm/hamt-sharding@2.0.1/node_modules/hamt-sharding/src/consumable-hash.js
var require_consumable_hash = __commonJS({
  "../../node_modules/.pnpm/hamt-sharding@2.0.1/node_modules/hamt-sharding/src/consumable-hash.js"(exports2, module2) {
    "use strict";
    var ConsumableBuffer = require_consumable_buffer();
    var { concat: uint8ArrayConcat } = require_concat();
    function wrapHash(hashFn) {
      function hashing(value) {
        if (value instanceof InfiniteHash) {
          return value;
        } else {
          return new InfiniteHash(value, hashFn);
        }
      }
      return hashing;
    }
    var InfiniteHash = class {
      /**
       *
       * @param {Uint8Array} value
       * @param {(value: Uint8Array) => Promise<Uint8Array>} hashFn
       */
      constructor(value, hashFn) {
        if (!(value instanceof Uint8Array)) {
          throw new Error("can only hash Uint8Arrays");
        }
        this._value = value;
        this._hashFn = hashFn;
        this._depth = -1;
        this._availableBits = 0;
        this._currentBufferIndex = 0;
        this._buffers = [];
      }
      /**
       * @param {number} bits
       */
      take(bits) {
        return __async(this, null, function* () {
          let pendingBits = bits;
          while (this._availableBits < pendingBits) {
            yield this._produceMoreBits();
          }
          let result = 0;
          while (pendingBits > 0) {
            const hash = this._buffers[this._currentBufferIndex];
            const available = Math.min(hash.availableBits(), pendingBits);
            const took = hash.take(available);
            result = (result << available) + took;
            pendingBits -= available;
            this._availableBits -= available;
            if (hash.availableBits() === 0) {
              this._currentBufferIndex++;
            }
          }
          return result;
        });
      }
      /**
       * @param {number} bits
       */
      untake(bits) {
        let pendingBits = bits;
        while (pendingBits > 0) {
          const hash = this._buffers[this._currentBufferIndex];
          const availableForUntake = Math.min(hash.totalBits() - hash.availableBits(), pendingBits);
          hash.untake(availableForUntake);
          pendingBits -= availableForUntake;
          this._availableBits += availableForUntake;
          if (this._currentBufferIndex > 0 && hash.totalBits() === hash.availableBits()) {
            this._depth--;
            this._currentBufferIndex--;
          }
        }
      }
      _produceMoreBits() {
        return __async(this, null, function* () {
          this._depth++;
          const value = this._depth ? uint8ArrayConcat([this._value, Uint8Array.from([this._depth])]) : this._value;
          const hashValue = yield this._hashFn(value);
          const buffer2 = new ConsumableBuffer(hashValue);
          this._buffers.push(buffer2);
          this._availableBits += buffer2.availableBits();
        });
      }
    };
    module2.exports = wrapHash;
    module2.exports.InfiniteHash = InfiniteHash;
  }
});

// ../../node_modules/.pnpm/hamt-sharding@2.0.1/node_modules/hamt-sharding/src/index.js
var require_src3 = __commonJS({
  "../../node_modules/.pnpm/hamt-sharding@2.0.1/node_modules/hamt-sharding/src/index.js"(exports2, module2) {
    "use strict";
    var Bucket2 = require_bucket();
    var wrapHash = require_consumable_hash();
    function createHAMT2(options) {
      if (!options || !options.hashFn) {
        throw new Error("please define an options.hashFn");
      }
      const bucketOptions = {
        bits: options.bits || 8,
        hash: wrapHash(options.hashFn)
      };
      return new Bucket2(bucketOptions);
    }
    module2.exports = {
      createHAMT: createHAMT2,
      Bucket: Bucket2
    };
  }
});

// ../../node_modules/.pnpm/browser-readablestream-to-it@1.0.3/node_modules/browser-readablestream-to-it/index.js
var require_browser_readablestream_to_it = __commonJS({
  "../../node_modules/.pnpm/browser-readablestream-to-it@1.0.3/node_modules/browser-readablestream-to-it/index.js"(exports2, module2) {
    "use strict";
    function browserReadableStreamToIt(_0) {
      return __asyncGenerator(this, arguments, function* (stream, options = {}) {
        const reader = stream.getReader();
        try {
          while (true) {
            const result = yield new __await(reader.read());
            if (result.done) {
              return;
            }
            yield result.value;
          }
        } finally {
          if (options.preventCancel !== true) {
            reader.cancel();
          }
          reader.releaseLock();
        }
      });
    }
    module2.exports = browserReadableStreamToIt;
  }
});

// ../../node_modules/.pnpm/blob-to-it@1.0.4/node_modules/blob-to-it/index.js
var require_blob_to_it = __commonJS({
  "../../node_modules/.pnpm/blob-to-it@1.0.4/node_modules/blob-to-it/index.js"(exports2, module2) {
    "use strict";
    var browserReadableStreamToIt = require_browser_readablestream_to_it();
    function blobToIt2(blob) {
      if (typeof blob.stream === "function") {
        return browserReadableStreamToIt(blob.stream());
      }
      return browserReadableStreamToIt(new Response(blob).body);
    }
    module2.exports = blobToIt2;
  }
});

// ../../node_modules/.pnpm/it-peekable@1.0.3/node_modules/it-peekable/index.js
var require_it_peekable = __commonJS({
  "../../node_modules/.pnpm/it-peekable@1.0.3/node_modules/it-peekable/index.js"(exports2, module2) {
    "use strict";
    function peekableIterator(iterable) {
      const [iterator, symbol] = iterable[Symbol.asyncIterator] ? [iterable[Symbol.asyncIterator](), Symbol.asyncIterator] : [iterable[Symbol.iterator](), Symbol.iterator];
      const queue = [];
      return {
        peek: () => {
          return iterator.next();
        },
        push: (value) => {
          queue.push(value);
        },
        next: () => {
          if (queue.length) {
            return {
              done: false,
              value: queue.shift()
            };
          }
          return iterator.next();
        },
        [symbol]() {
          return this;
        }
      };
    }
    module2.exports = peekableIterator;
  }
});

// ../../node_modules/.pnpm/it-map@1.0.6/node_modules/it-map/index.js
var require_it_map = __commonJS({
  "../../node_modules/.pnpm/it-map@1.0.6/node_modules/it-map/index.js"(exports2, module2) {
    "use strict";
    var map3 = function(source, func) {
      return __asyncGenerator(this, null, function* () {
        try {
          for (var iter = __forAwait(source), more, temp, error; more = !(temp = yield new __await(iter.next())).done; more = false) {
            const val = temp.value;
            yield func(val);
          }
        } catch (temp) {
          error = [temp];
        } finally {
          try {
            more && (temp = iter.return) && (yield new __await(temp.call(iter)));
          } finally {
            if (error)
              throw error[0];
          }
        }
      });
    };
    module2.exports = map3;
  }
});

// ../../node_modules/.pnpm/it-drain@1.0.5/node_modules/it-drain/index.js
var require_it_drain = __commonJS({
  "../../node_modules/.pnpm/it-drain@1.0.5/node_modules/it-drain/index.js"(exports2, module2) {
    "use strict";
    var drain2 = (source) => __async(exports2, null, function* () {
      try {
        for (var iter = __forAwait(source), more, temp, error; more = !(temp = yield iter.next()).done; more = false) {
          const _ = temp.value;
        }
      } catch (temp) {
        error = [temp];
      } finally {
        try {
          more && (temp = iter.return) && (yield temp.call(iter));
        } finally {
          if (error)
            throw error[0];
        }
      }
    });
    module2.exports = drain2;
  }
});

// ../../node_modules/.pnpm/it-filter@1.0.3/node_modules/it-filter/index.js
var require_it_filter = __commonJS({
  "../../node_modules/.pnpm/it-filter@1.0.3/node_modules/it-filter/index.js"(exports2, module2) {
    "use strict";
    var filter2 = function(source, fn) {
      return __asyncGenerator(this, null, function* () {
        try {
          for (var iter = __forAwait(source), more, temp, error; more = !(temp = yield new __await(iter.next())).done; more = false) {
            const entry = temp.value;
            if (yield new __await(fn(entry))) {
              yield entry;
            }
          }
        } catch (temp) {
          error = [temp];
        } finally {
          try {
            more && (temp = iter.return) && (yield new __await(temp.call(iter)));
          } finally {
            if (error)
              throw error[0];
          }
        }
      });
    };
    module2.exports = filter2;
  }
});

// ../../node_modules/.pnpm/it-take@1.0.2/node_modules/it-take/index.js
var require_it_take = __commonJS({
  "../../node_modules/.pnpm/it-take@1.0.2/node_modules/it-take/index.js"(exports2, module2) {
    "use strict";
    var take2 = function(source, limit) {
      return __asyncGenerator(this, null, function* () {
        let items = 0;
        if (limit < 1) {
          return;
        }
        try {
          for (var iter = __forAwait(source), more, temp, error; more = !(temp = yield new __await(iter.next())).done; more = false) {
            const entry = temp.value;
            yield entry;
            items++;
            if (items === limit) {
              return;
            }
          }
        } catch (temp) {
          error = [temp];
        } finally {
          try {
            more && (temp = iter.return) && (yield new __await(temp.call(iter)));
          } finally {
            if (error)
              throw error[0];
          }
        }
      });
    };
    module2.exports = take2;
  }
});

// ../../node_modules/.pnpm/throttled-queue@2.1.4/node_modules/throttled-queue/dist/throttledQueue.js
var require_throttledQueue = __commonJS({
  "../../node_modules/.pnpm/throttled-queue@2.1.4/node_modules/throttled-queue/dist/throttledQueue.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function throttledQueue2(maxRequestsPerInterval, interval, evenlySpaced) {
      if (evenlySpaced === void 0) {
        evenlySpaced = false;
      }
      if (evenlySpaced) {
        interval = interval / maxRequestsPerInterval;
        maxRequestsPerInterval = 1;
      }
      var queue = [];
      var lastIntervalStart = 0;
      var numRequestsPerInterval = 0;
      var timeout;
      var dequeue = function() {
        var intervalEnd = lastIntervalStart + interval;
        var now = Date.now();
        if (now < intervalEnd) {
          timeout !== void 0 && clearTimeout(timeout);
          timeout = setTimeout(dequeue, intervalEnd - now);
          return;
        }
        lastIntervalStart = now;
        numRequestsPerInterval = 0;
        for (var _i = 0, _a2 = queue.splice(0, maxRequestsPerInterval); _i < _a2.length; _i++) {
          var callback = _a2[_i];
          numRequestsPerInterval++;
          void callback();
        }
        if (queue.length) {
          timeout = setTimeout(dequeue, interval);
        } else {
          timeout = void 0;
        }
      };
      return function(fn) {
        return new Promise(function(resolve, reject) {
          var callback = function() {
            return Promise.resolve().then(fn).then(resolve).catch(reject);
          };
          var now = Date.now();
          if (timeout === void 0 && now - lastIntervalStart > interval) {
            lastIntervalStart = now;
            numRequestsPerInterval = 0;
          }
          if (numRequestsPerInterval++ < maxRequestsPerInterval) {
            void callback();
          } else {
            queue.push(callback);
            if (timeout === void 0) {
              timeout = setTimeout(dequeue, lastIntervalStart + interval - now);
            }
          }
        });
      };
    }
    module2.exports = throttledQueue2;
    exports2.default = throttledQueue2;
  }
});

// ../../node_modules/.pnpm/data-uri-to-buffer@3.0.1/node_modules/data-uri-to-buffer/dist/src/index.js
var require_src4 = __commonJS({
  "../../node_modules/.pnpm/data-uri-to-buffer@3.0.1/node_modules/data-uri-to-buffer/dist/src/index.js"(exports2, module2) {
    "use strict";
    function dataUriToBuffer2(uri) {
      if (!/^data:/i.test(uri)) {
        throw new TypeError('`uri` does not appear to be a Data URI (must begin with "data:")');
      }
      uri = uri.replace(/\r?\n/g, "");
      const firstComma = uri.indexOf(",");
      if (firstComma === -1 || firstComma <= 4) {
        throw new TypeError("malformed data: URI");
      }
      const meta = uri.substring(5, firstComma).split(";");
      let charset = "";
      let base642 = false;
      const type = meta[0] || "text/plain";
      let typeFull = type;
      for (let i = 1; i < meta.length; i++) {
        if (meta[i] === "base64") {
          base642 = true;
        } else {
          typeFull += `;${meta[i]}`;
          if (meta[i].indexOf("charset=") === 0) {
            charset = meta[i].substring(8);
          }
        }
      }
      if (!meta[0] && !charset.length) {
        typeFull += ";charset=US-ASCII";
        charset = "US-ASCII";
      }
      const encoding = base642 ? "base64" : "ascii";
      const data = unescape(uri.substring(firstComma + 1));
      const buffer2 = Buffer.from(data, encoding);
      buffer2.type = type;
      buffer2.typeFull = typeFull;
      buffer2.charset = charset;
      return buffer2;
    }
    module2.exports = dataUriToBuffer2;
  }
});

// ../../node_modules/.pnpm/web-streams-polyfill@3.2.1/node_modules/web-streams-polyfill/dist/ponyfill.mjs
var ponyfill_exports = {};
__export(ponyfill_exports, {
  ByteLengthQueuingStrategy: () => ByteLengthQueuingStrategy,
  CountQueuingStrategy: () => CountQueuingStrategy,
  ReadableByteStreamController: () => ReadableByteStreamController,
  ReadableStream: () => ReadableStream,
  ReadableStreamBYOBReader: () => ReadableStreamBYOBReader,
  ReadableStreamBYOBRequest: () => ReadableStreamBYOBRequest,
  ReadableStreamDefaultController: () => ReadableStreamDefaultController,
  ReadableStreamDefaultReader: () => ReadableStreamDefaultReader,
  TransformStream: () => TransformStream,
  TransformStreamDefaultController: () => TransformStreamDefaultController,
  WritableStream: () => WritableStream,
  WritableStreamDefaultController: () => WritableStreamDefaultController,
  WritableStreamDefaultWriter: () => WritableStreamDefaultWriter
});
function noop2() {
  return void 0;
}
function getGlobals() {
  if (typeof self !== "undefined") {
    return self;
  } else if (typeof window !== "undefined") {
    return window;
  } else if (typeof global !== "undefined") {
    return global;
  }
  return void 0;
}
function typeIsObject(x) {
  return typeof x === "object" && x !== null || typeof x === "function";
}
function newPromise(executor) {
  return new originalPromise(executor);
}
function promiseResolvedWith(value) {
  return originalPromiseResolve(value);
}
function promiseRejectedWith(reason) {
  return originalPromiseReject(reason);
}
function PerformPromiseThen(promise, onFulfilled, onRejected) {
  return originalPromiseThen.call(promise, onFulfilled, onRejected);
}
function uponPromise(promise, onFulfilled, onRejected) {
  PerformPromiseThen(PerformPromiseThen(promise, onFulfilled, onRejected), void 0, rethrowAssertionErrorRejection);
}
function uponFulfillment(promise, onFulfilled) {
  uponPromise(promise, onFulfilled);
}
function uponRejection(promise, onRejected) {
  uponPromise(promise, void 0, onRejected);
}
function transformPromiseWith(promise, fulfillmentHandler, rejectionHandler) {
  return PerformPromiseThen(promise, fulfillmentHandler, rejectionHandler);
}
function setPromiseIsHandledToTrue(promise) {
  PerformPromiseThen(promise, void 0, rethrowAssertionErrorRejection);
}
function reflectCall(F, V, args) {
  if (typeof F !== "function") {
    throw new TypeError("Argument is not a function");
  }
  return Function.prototype.apply.call(F, V, args);
}
function promiseCall(F, V, args) {
  try {
    return promiseResolvedWith(reflectCall(F, V, args));
  } catch (value) {
    return promiseRejectedWith(value);
  }
}
function ReadableStreamReaderGenericInitialize(reader, stream) {
  reader._ownerReadableStream = stream;
  stream._reader = reader;
  if (stream._state === "readable") {
    defaultReaderClosedPromiseInitialize(reader);
  } else if (stream._state === "closed") {
    defaultReaderClosedPromiseInitializeAsResolved(reader);
  } else {
    defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);
  }
}
function ReadableStreamReaderGenericCancel(reader, reason) {
  var stream = reader._ownerReadableStream;
  return ReadableStreamCancel(stream, reason);
}
function ReadableStreamReaderGenericRelease(reader) {
  if (reader._ownerReadableStream._state === "readable") {
    defaultReaderClosedPromiseReject(reader, new TypeError("Reader was released and can no longer be used to monitor the stream's closedness"));
  } else {
    defaultReaderClosedPromiseResetToRejected(reader, new TypeError("Reader was released and can no longer be used to monitor the stream's closedness"));
  }
  reader._ownerReadableStream._reader = void 0;
  reader._ownerReadableStream = void 0;
}
function readerLockException(name5) {
  return new TypeError("Cannot " + name5 + " a stream using a released reader");
}
function defaultReaderClosedPromiseInitialize(reader) {
  reader._closedPromise = newPromise(function(resolve, reject) {
    reader._closedPromise_resolve = resolve;
    reader._closedPromise_reject = reject;
  });
}
function defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {
  defaultReaderClosedPromiseInitialize(reader);
  defaultReaderClosedPromiseReject(reader, reason);
}
function defaultReaderClosedPromiseInitializeAsResolved(reader) {
  defaultReaderClosedPromiseInitialize(reader);
  defaultReaderClosedPromiseResolve(reader);
}
function defaultReaderClosedPromiseReject(reader, reason) {
  if (reader._closedPromise_reject === void 0) {
    return;
  }
  setPromiseIsHandledToTrue(reader._closedPromise);
  reader._closedPromise_reject(reason);
  reader._closedPromise_resolve = void 0;
  reader._closedPromise_reject = void 0;
}
function defaultReaderClosedPromiseResetToRejected(reader, reason) {
  defaultReaderClosedPromiseInitializeAsRejected(reader, reason);
}
function defaultReaderClosedPromiseResolve(reader) {
  if (reader._closedPromise_resolve === void 0) {
    return;
  }
  reader._closedPromise_resolve(void 0);
  reader._closedPromise_resolve = void 0;
  reader._closedPromise_reject = void 0;
}
function isDictionary(x) {
  return typeof x === "object" || typeof x === "function";
}
function assertDictionary(obj, context) {
  if (obj !== void 0 && !isDictionary(obj)) {
    throw new TypeError(context + " is not an object.");
  }
}
function assertFunction(x, context) {
  if (typeof x !== "function") {
    throw new TypeError(context + " is not a function.");
  }
}
function isObject(x) {
  return typeof x === "object" && x !== null || typeof x === "function";
}
function assertObject(x, context) {
  if (!isObject(x)) {
    throw new TypeError(context + " is not an object.");
  }
}
function assertRequiredArgument(x, position, context) {
  if (x === void 0) {
    throw new TypeError("Parameter " + position + " is required in '" + context + "'.");
  }
}
function assertRequiredField(x, field, context) {
  if (x === void 0) {
    throw new TypeError(field + " is required in '" + context + "'.");
  }
}
function convertUnrestrictedDouble(value) {
  return Number(value);
}
function censorNegativeZero(x) {
  return x === 0 ? 0 : x;
}
function integerPart(x) {
  return censorNegativeZero(MathTrunc(x));
}
function convertUnsignedLongLongWithEnforceRange(value, context) {
  var lowerBound = 0;
  var upperBound = Number.MAX_SAFE_INTEGER;
  var x = Number(value);
  x = censorNegativeZero(x);
  if (!NumberIsFinite(x)) {
    throw new TypeError(context + " is not a finite number");
  }
  x = integerPart(x);
  if (x < lowerBound || x > upperBound) {
    throw new TypeError(context + " is outside the accepted range of " + lowerBound + " to " + upperBound + ", inclusive");
  }
  if (!NumberIsFinite(x) || x === 0) {
    return 0;
  }
  return x;
}
function assertReadableStream(x, context) {
  if (!IsReadableStream(x)) {
    throw new TypeError(context + " is not a ReadableStream.");
  }
}
function AcquireReadableStreamDefaultReader(stream) {
  return new ReadableStreamDefaultReader(stream);
}
function ReadableStreamAddReadRequest(stream, readRequest) {
  stream._reader._readRequests.push(readRequest);
}
function ReadableStreamFulfillReadRequest(stream, chunk, done) {
  var reader = stream._reader;
  var readRequest = reader._readRequests.shift();
  if (done) {
    readRequest._closeSteps();
  } else {
    readRequest._chunkSteps(chunk);
  }
}
function ReadableStreamGetNumReadRequests(stream) {
  return stream._reader._readRequests.length;
}
function ReadableStreamHasDefaultReader(stream) {
  var reader = stream._reader;
  if (reader === void 0) {
    return false;
  }
  if (!IsReadableStreamDefaultReader(reader)) {
    return false;
  }
  return true;
}
function IsReadableStreamDefaultReader(x) {
  if (!typeIsObject(x)) {
    return false;
  }
  if (!Object.prototype.hasOwnProperty.call(x, "_readRequests")) {
    return false;
  }
  return x instanceof ReadableStreamDefaultReader;
}
function ReadableStreamDefaultReaderRead(reader, readRequest) {
  var stream = reader._ownerReadableStream;
  stream._disturbed = true;
  if (stream._state === "closed") {
    readRequest._closeSteps();
  } else if (stream._state === "errored") {
    readRequest._errorSteps(stream._storedError);
  } else {
    stream._readableStreamController[PullSteps](readRequest);
  }
}
function defaultReaderBrandCheckException(name5) {
  return new TypeError("ReadableStreamDefaultReader.prototype." + name5 + " can only be used on a ReadableStreamDefaultReader");
}
function AcquireReadableStreamAsyncIterator(stream, preventCancel) {
  var reader = AcquireReadableStreamDefaultReader(stream);
  var impl = new ReadableStreamAsyncIteratorImpl(reader, preventCancel);
  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype);
  iterator._asyncIteratorImpl = impl;
  return iterator;
}
function IsReadableStreamAsyncIterator(x) {
  if (!typeIsObject(x)) {
    return false;
  }
  if (!Object.prototype.hasOwnProperty.call(x, "_asyncIteratorImpl")) {
    return false;
  }
  try {
    return x._asyncIteratorImpl instanceof ReadableStreamAsyncIteratorImpl;
  } catch (_a2) {
    return false;
  }
}
function streamAsyncIteratorBrandCheckException(name5) {
  return new TypeError("ReadableStreamAsyncIterator." + name5 + " can only be used on a ReadableSteamAsyncIterator");
}
function CreateArrayFromList(elements) {
  return elements.slice();
}
function CopyDataBlockBytes(dest, destOffset, src2, srcOffset, n) {
  new Uint8Array(dest).set(new Uint8Array(src2, srcOffset, n), destOffset);
}
function TransferArrayBuffer(O) {
  return O;
}
function IsDetachedBuffer(O) {
  return false;
}
function ArrayBufferSlice(buffer2, begin, end) {
  if (buffer2.slice) {
    return buffer2.slice(begin, end);
  }
  var length2 = end - begin;
  var slice2 = new ArrayBuffer(length2);
  CopyDataBlockBytes(slice2, 0, buffer2, begin, length2);
  return slice2;
}
function IsNonNegativeNumber(v) {
  if (typeof v !== "number") {
    return false;
  }
  if (NumberIsNaN(v)) {
    return false;
  }
  if (v < 0) {
    return false;
  }
  return true;
}
function CloneAsUint8Array(O) {
  var buffer2 = ArrayBufferSlice(O.buffer, O.byteOffset, O.byteOffset + O.byteLength);
  return new Uint8Array(buffer2);
}
function DequeueValue(container) {
  var pair = container._queue.shift();
  container._queueTotalSize -= pair.size;
  if (container._queueTotalSize < 0) {
    container._queueTotalSize = 0;
  }
  return pair.value;
}
function EnqueueValueWithSize(container, value, size) {
  if (!IsNonNegativeNumber(size) || size === Infinity) {
    throw new RangeError("Size must be a finite, non-NaN, non-negative number.");
  }
  container._queue.push({ value, size });
  container._queueTotalSize += size;
}
function PeekQueueValue(container) {
  var pair = container._queue.peek();
  return pair.value;
}
function ResetQueue(container) {
  container._queue = new SimpleQueue();
  container._queueTotalSize = 0;
}
function IsReadableByteStreamController(x) {
  if (!typeIsObject(x)) {
    return false;
  }
  if (!Object.prototype.hasOwnProperty.call(x, "_controlledReadableByteStream")) {
    return false;
  }
  return x instanceof ReadableByteStreamController;
}
function IsReadableStreamBYOBRequest(x) {
  if (!typeIsObject(x)) {
    return false;
  }
  if (!Object.prototype.hasOwnProperty.call(x, "_associatedReadableByteStreamController")) {
    return false;
  }
  return x instanceof ReadableStreamBYOBRequest;
}
function ReadableByteStreamControllerCallPullIfNeeded(controller) {
  var shouldPull = ReadableByteStreamControllerShouldCallPull(controller);
  if (!shouldPull) {
    return;
  }
  if (controller._pulling) {
    controller._pullAgain = true;
    return;
  }
  controller._pulling = true;
  var pullPromise = controller._pullAlgorithm();
  uponPromise(pullPromise, function() {
    controller._pulling = false;
    if (controller._pullAgain) {
      controller._pullAgain = false;
      ReadableByteStreamControllerCallPullIfNeeded(controller);
    }
  }, function(e) {
    ReadableByteStreamControllerError(controller, e);
  });
}
function ReadableByteStreamControllerClearPendingPullIntos(controller) {
  ReadableByteStreamControllerInvalidateBYOBRequest(controller);
  controller._pendingPullIntos = new SimpleQueue();
}
function ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {
  var done = false;
  if (stream._state === "closed") {
    done = true;
  }
  var filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
  if (pullIntoDescriptor.readerType === "default") {
    ReadableStreamFulfillReadRequest(stream, filledView, done);
  } else {
    ReadableStreamFulfillReadIntoRequest(stream, filledView, done);
  }
}
function ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {
  var bytesFilled = pullIntoDescriptor.bytesFilled;
  var elementSize = pullIntoDescriptor.elementSize;
  return new pullIntoDescriptor.viewConstructor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);
}
function ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer2, byteOffset, byteLength) {
  controller._queue.push({ buffer: buffer2, byteOffset, byteLength });
  controller._queueTotalSize += byteLength;
}
function ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {
  var elementSize = pullIntoDescriptor.elementSize;
  var currentAlignedBytes = pullIntoDescriptor.bytesFilled - pullIntoDescriptor.bytesFilled % elementSize;
  var maxBytesToCopy = Math.min(controller._queueTotalSize, pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);
  var maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;
  var maxAlignedBytes = maxBytesFilled - maxBytesFilled % elementSize;
  var totalBytesToCopyRemaining = maxBytesToCopy;
  var ready = false;
  if (maxAlignedBytes > currentAlignedBytes) {
    totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;
    ready = true;
  }
  var queue = controller._queue;
  while (totalBytesToCopyRemaining > 0) {
    var headOfQueue = queue.peek();
    var bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);
    var destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
    CopyDataBlockBytes(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);
    if (headOfQueue.byteLength === bytesToCopy) {
      queue.shift();
    } else {
      headOfQueue.byteOffset += bytesToCopy;
      headOfQueue.byteLength -= bytesToCopy;
    }
    controller._queueTotalSize -= bytesToCopy;
    ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);
    totalBytesToCopyRemaining -= bytesToCopy;
  }
  return ready;
}
function ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {
  pullIntoDescriptor.bytesFilled += size;
}
function ReadableByteStreamControllerHandleQueueDrain(controller) {
  if (controller._queueTotalSize === 0 && controller._closeRequested) {
    ReadableByteStreamControllerClearAlgorithms(controller);
    ReadableStreamClose(controller._controlledReadableByteStream);
  } else {
    ReadableByteStreamControllerCallPullIfNeeded(controller);
  }
}
function ReadableByteStreamControllerInvalidateBYOBRequest(controller) {
  if (controller._byobRequest === null) {
    return;
  }
  controller._byobRequest._associatedReadableByteStreamController = void 0;
  controller._byobRequest._view = null;
  controller._byobRequest = null;
}
function ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {
  while (controller._pendingPullIntos.length > 0) {
    if (controller._queueTotalSize === 0) {
      return;
    }
    var pullIntoDescriptor = controller._pendingPullIntos.peek();
    if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
      ReadableByteStreamControllerShiftPendingPullInto(controller);
      ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
    }
  }
}
function ReadableByteStreamControllerPullInto(controller, view, readIntoRequest) {
  var stream = controller._controlledReadableByteStream;
  var elementSize = 1;
  if (view.constructor !== DataView) {
    elementSize = view.constructor.BYTES_PER_ELEMENT;
  }
  var ctor = view.constructor;
  var buffer2 = TransferArrayBuffer(view.buffer);
  var pullIntoDescriptor = {
    buffer: buffer2,
    bufferByteLength: buffer2.byteLength,
    byteOffset: view.byteOffset,
    byteLength: view.byteLength,
    bytesFilled: 0,
    elementSize,
    viewConstructor: ctor,
    readerType: "byob"
  };
  if (controller._pendingPullIntos.length > 0) {
    controller._pendingPullIntos.push(pullIntoDescriptor);
    ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
    return;
  }
  if (stream._state === "closed") {
    var emptyView = new ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);
    readIntoRequest._closeSteps(emptyView);
    return;
  }
  if (controller._queueTotalSize > 0) {
    if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
      var filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
      ReadableByteStreamControllerHandleQueueDrain(controller);
      readIntoRequest._chunkSteps(filledView);
      return;
    }
    if (controller._closeRequested) {
      var e = new TypeError("Insufficient bytes to fill elements in the given buffer");
      ReadableByteStreamControllerError(controller, e);
      readIntoRequest._errorSteps(e);
      return;
    }
  }
  controller._pendingPullIntos.push(pullIntoDescriptor);
  ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
  ReadableByteStreamControllerCallPullIfNeeded(controller);
}
function ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {
  var stream = controller._controlledReadableByteStream;
  if (ReadableStreamHasBYOBReader(stream)) {
    while (ReadableStreamGetNumReadIntoRequests(stream) > 0) {
      var pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);
      ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);
    }
  }
}
function ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {
  ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);
  if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize) {
    return;
  }
  ReadableByteStreamControllerShiftPendingPullInto(controller);
  var remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;
  if (remainderSize > 0) {
    var end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
    var remainder = ArrayBufferSlice(pullIntoDescriptor.buffer, end - remainderSize, end);
    ReadableByteStreamControllerEnqueueChunkToQueue(controller, remainder, 0, remainder.byteLength);
  }
  pullIntoDescriptor.bytesFilled -= remainderSize;
  ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
  ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
}
function ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {
  var firstDescriptor = controller._pendingPullIntos.peek();
  ReadableByteStreamControllerInvalidateBYOBRequest(controller);
  var state = controller._controlledReadableByteStream._state;
  if (state === "closed") {
    ReadableByteStreamControllerRespondInClosedState(controller);
  } else {
    ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);
  }
  ReadableByteStreamControllerCallPullIfNeeded(controller);
}
function ReadableByteStreamControllerShiftPendingPullInto(controller) {
  var descriptor = controller._pendingPullIntos.shift();
  return descriptor;
}
function ReadableByteStreamControllerShouldCallPull(controller) {
  var stream = controller._controlledReadableByteStream;
  if (stream._state !== "readable") {
    return false;
  }
  if (controller._closeRequested) {
    return false;
  }
  if (!controller._started) {
    return false;
  }
  if (ReadableStreamHasDefaultReader(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
    return true;
  }
  if (ReadableStreamHasBYOBReader(stream) && ReadableStreamGetNumReadIntoRequests(stream) > 0) {
    return true;
  }
  var desiredSize = ReadableByteStreamControllerGetDesiredSize(controller);
  if (desiredSize > 0) {
    return true;
  }
  return false;
}
function ReadableByteStreamControllerClearAlgorithms(controller) {
  controller._pullAlgorithm = void 0;
  controller._cancelAlgorithm = void 0;
}
function ReadableByteStreamControllerClose(controller) {
  var stream = controller._controlledReadableByteStream;
  if (controller._closeRequested || stream._state !== "readable") {
    return;
  }
  if (controller._queueTotalSize > 0) {
    controller._closeRequested = true;
    return;
  }
  if (controller._pendingPullIntos.length > 0) {
    var firstPendingPullInto = controller._pendingPullIntos.peek();
    if (firstPendingPullInto.bytesFilled > 0) {
      var e = new TypeError("Insufficient bytes to fill elements in the given buffer");
      ReadableByteStreamControllerError(controller, e);
      throw e;
    }
  }
  ReadableByteStreamControllerClearAlgorithms(controller);
  ReadableStreamClose(stream);
}
function ReadableByteStreamControllerEnqueue(controller, chunk) {
  var stream = controller._controlledReadableByteStream;
  if (controller._closeRequested || stream._state !== "readable") {
    return;
  }
  var buffer2 = chunk.buffer;
  var byteOffset = chunk.byteOffset;
  var byteLength = chunk.byteLength;
  var transferredBuffer = TransferArrayBuffer(buffer2);
  if (controller._pendingPullIntos.length > 0) {
    var firstPendingPullInto = controller._pendingPullIntos.peek();
    if (IsDetachedBuffer(firstPendingPullInto.buffer))
      ;
    firstPendingPullInto.buffer = TransferArrayBuffer(firstPendingPullInto.buffer);
  }
  ReadableByteStreamControllerInvalidateBYOBRequest(controller);
  if (ReadableStreamHasDefaultReader(stream)) {
    if (ReadableStreamGetNumReadRequests(stream) === 0) {
      ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
    } else {
      if (controller._pendingPullIntos.length > 0) {
        ReadableByteStreamControllerShiftPendingPullInto(controller);
      }
      var transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);
      ReadableStreamFulfillReadRequest(stream, transferredView, false);
    }
  } else if (ReadableStreamHasBYOBReader(stream)) {
    ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
    ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
  } else {
    ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
  }
  ReadableByteStreamControllerCallPullIfNeeded(controller);
}
function ReadableByteStreamControllerError(controller, e) {
  var stream = controller._controlledReadableByteStream;
  if (stream._state !== "readable") {
    return;
  }
  ReadableByteStreamControllerClearPendingPullIntos(controller);
  ResetQueue(controller);
  ReadableByteStreamControllerClearAlgorithms(controller);
  ReadableStreamError(stream, e);
}
function ReadableByteStreamControllerGetBYOBRequest(controller) {
  if (controller._byobRequest === null && controller._pendingPullIntos.length > 0) {
    var firstDescriptor = controller._pendingPullIntos.peek();
    var view = new Uint8Array(firstDescriptor.buffer, firstDescriptor.byteOffset + firstDescriptor.bytesFilled, firstDescriptor.byteLength - firstDescriptor.bytesFilled);
    var byobRequest = Object.create(ReadableStreamBYOBRequest.prototype);
    SetUpReadableStreamBYOBRequest(byobRequest, controller, view);
    controller._byobRequest = byobRequest;
  }
  return controller._byobRequest;
}
function ReadableByteStreamControllerGetDesiredSize(controller) {
  var state = controller._controlledReadableByteStream._state;
  if (state === "errored") {
    return null;
  }
  if (state === "closed") {
    return 0;
  }
  return controller._strategyHWM - controller._queueTotalSize;
}
function ReadableByteStreamControllerRespond(controller, bytesWritten) {
  var firstDescriptor = controller._pendingPullIntos.peek();
  var state = controller._controlledReadableByteStream._state;
  if (state === "closed") {
    if (bytesWritten !== 0) {
      throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream");
    }
  } else {
    if (bytesWritten === 0) {
      throw new TypeError("bytesWritten must be greater than 0 when calling respond() on a readable stream");
    }
    if (firstDescriptor.bytesFilled + bytesWritten > firstDescriptor.byteLength) {
      throw new RangeError("bytesWritten out of range");
    }
  }
  firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);
  ReadableByteStreamControllerRespondInternal(controller, bytesWritten);
}
function ReadableByteStreamControllerRespondWithNewView(controller, view) {
  var firstDescriptor = controller._pendingPullIntos.peek();
  var state = controller._controlledReadableByteStream._state;
  if (state === "closed") {
    if (view.byteLength !== 0) {
      throw new TypeError("The view's length must be 0 when calling respondWithNewView() on a closed stream");
    }
  } else {
    if (view.byteLength === 0) {
      throw new TypeError("The view's length must be greater than 0 when calling respondWithNewView() on a readable stream");
    }
  }
  if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {
    throw new RangeError("The region specified by view does not match byobRequest");
  }
  if (firstDescriptor.bufferByteLength !== view.buffer.byteLength) {
    throw new RangeError("The buffer of view has different capacity than byobRequest");
  }
  if (firstDescriptor.bytesFilled + view.byteLength > firstDescriptor.byteLength) {
    throw new RangeError("The region specified by view is larger than byobRequest");
  }
  var viewByteLength = view.byteLength;
  firstDescriptor.buffer = TransferArrayBuffer(view.buffer);
  ReadableByteStreamControllerRespondInternal(controller, viewByteLength);
}
function SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize) {
  controller._controlledReadableByteStream = stream;
  controller._pullAgain = false;
  controller._pulling = false;
  controller._byobRequest = null;
  controller._queue = controller._queueTotalSize = void 0;
  ResetQueue(controller);
  controller._closeRequested = false;
  controller._started = false;
  controller._strategyHWM = highWaterMark;
  controller._pullAlgorithm = pullAlgorithm;
  controller._cancelAlgorithm = cancelAlgorithm;
  controller._autoAllocateChunkSize = autoAllocateChunkSize;
  controller._pendingPullIntos = new SimpleQueue();
  stream._readableStreamController = controller;
  var startResult = startAlgorithm();
  uponPromise(promiseResolvedWith(startResult), function() {
    controller._started = true;
    ReadableByteStreamControllerCallPullIfNeeded(controller);
  }, function(r) {
    ReadableByteStreamControllerError(controller, r);
  });
}
function SetUpReadableByteStreamControllerFromUnderlyingSource(stream, underlyingByteSource, highWaterMark) {
  var controller = Object.create(ReadableByteStreamController.prototype);
  var startAlgorithm = function() {
    return void 0;
  };
  var pullAlgorithm = function() {
    return promiseResolvedWith(void 0);
  };
  var cancelAlgorithm = function() {
    return promiseResolvedWith(void 0);
  };
  if (underlyingByteSource.start !== void 0) {
    startAlgorithm = function() {
      return underlyingByteSource.start(controller);
    };
  }
  if (underlyingByteSource.pull !== void 0) {
    pullAlgorithm = function() {
      return underlyingByteSource.pull(controller);
    };
  }
  if (underlyingByteSource.cancel !== void 0) {
    cancelAlgorithm = function(reason) {
      return underlyingByteSource.cancel(reason);
    };
  }
  var autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;
  if (autoAllocateChunkSize === 0) {
    throw new TypeError("autoAllocateChunkSize must be greater than 0");
  }
  SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize);
}
function SetUpReadableStreamBYOBRequest(request, controller, view) {
  request._associatedReadableByteStreamController = controller;
  request._view = view;
}
function byobRequestBrandCheckException(name5) {
  return new TypeError("ReadableStreamBYOBRequest.prototype." + name5 + " can only be used on a ReadableStreamBYOBRequest");
}
function byteStreamControllerBrandCheckException(name5) {
  return new TypeError("ReadableByteStreamController.prototype." + name5 + " can only be used on a ReadableByteStreamController");
}
function AcquireReadableStreamBYOBReader(stream) {
  return new ReadableStreamBYOBReader(stream);
}
function ReadableStreamAddReadIntoRequest(stream, readIntoRequest) {
  stream._reader._readIntoRequests.push(readIntoRequest);
}
function ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {
  var reader = stream._reader;
  var readIntoRequest = reader._readIntoRequests.shift();
  if (done) {
    readIntoRequest._closeSteps(chunk);
  } else {
    readIntoRequest._chunkSteps(chunk);
  }
}
function ReadableStreamGetNumReadIntoRequests(stream) {
  return stream._reader._readIntoRequests.length;
}
function ReadableStreamHasBYOBReader(stream) {
  var reader = stream._reader;
  if (reader === void 0) {
    return false;
  }
  if (!IsReadableStreamBYOBReader(reader)) {
    return false;
  }
  return true;
}
function IsReadableStreamBYOBReader(x) {
  if (!typeIsObject(x)) {
    return false;
  }
  if (!Object.prototype.hasOwnProperty.call(x, "_readIntoRequests")) {
    return false;
  }
  return x instanceof ReadableStreamBYOBReader;
}
function ReadableStreamBYOBReaderRead(reader, view, readIntoRequest) {
  var stream = reader._ownerReadableStream;
  stream._disturbed = true;
  if (stream._state === "errored") {
    readIntoRequest._errorSteps(stream._storedError);
  } else {
    ReadableByteStreamControllerPullInto(stream._readableStreamController, view, readIntoRequest);
  }
}
function byobReaderBrandCheckException(name5) {
  return new TypeError("ReadableStreamBYOBReader.prototype." + name5 + " can only be used on a ReadableStreamBYOBReader");
}
function ExtractHighWaterMark(strategy, defaultHWM) {
  var highWaterMark = strategy.highWaterMark;
  if (highWaterMark === void 0) {
    return defaultHWM;
  }
  if (NumberIsNaN(highWaterMark) || highWaterMark < 0) {
    throw new RangeError("Invalid highWaterMark");
  }
  return highWaterMark;
}
function ExtractSizeAlgorithm(strategy) {
  var size = strategy.size;
  if (!size) {
    return function() {
      return 1;
    };
  }
  return size;
}
function convertQueuingStrategy(init, context) {
  assertDictionary(init, context);
  var highWaterMark = init === null || init === void 0 ? void 0 : init.highWaterMark;
  var size = init === null || init === void 0 ? void 0 : init.size;
  return {
    highWaterMark: highWaterMark === void 0 ? void 0 : convertUnrestrictedDouble(highWaterMark),
    size: size === void 0 ? void 0 : convertQueuingStrategySize(size, context + " has member 'size' that")
  };
}
function convertQueuingStrategySize(fn, context) {
  assertFunction(fn, context);
  return function(chunk) {
    return convertUnrestrictedDouble(fn(chunk));
  };
}
function convertUnderlyingSink(original, context) {
  assertDictionary(original, context);
  var abort = original === null || original === void 0 ? void 0 : original.abort;
  var close = original === null || original === void 0 ? void 0 : original.close;
  var start = original === null || original === void 0 ? void 0 : original.start;
  var type = original === null || original === void 0 ? void 0 : original.type;
  var write = original === null || original === void 0 ? void 0 : original.write;
  return {
    abort: abort === void 0 ? void 0 : convertUnderlyingSinkAbortCallback(abort, original, context + " has member 'abort' that"),
    close: close === void 0 ? void 0 : convertUnderlyingSinkCloseCallback(close, original, context + " has member 'close' that"),
    start: start === void 0 ? void 0 : convertUnderlyingSinkStartCallback(start, original, context + " has member 'start' that"),
    write: write === void 0 ? void 0 : convertUnderlyingSinkWriteCallback(write, original, context + " has member 'write' that"),
    type
  };
}
function convertUnderlyingSinkAbortCallback(fn, original, context) {
  assertFunction(fn, context);
  return function(reason) {
    return promiseCall(fn, original, [reason]);
  };
}
function convertUnderlyingSinkCloseCallback(fn, original, context) {
  assertFunction(fn, context);
  return function() {
    return promiseCall(fn, original, []);
  };
}
function convertUnderlyingSinkStartCallback(fn, original, context) {
  assertFunction(fn, context);
  return function(controller) {
    return reflectCall(fn, original, [controller]);
  };
}
function convertUnderlyingSinkWriteCallback(fn, original, context) {
  assertFunction(fn, context);
  return function(chunk, controller) {
    return promiseCall(fn, original, [chunk, controller]);
  };
}
function assertWritableStream(x, context) {
  if (!IsWritableStream(x)) {
    throw new TypeError(context + " is not a WritableStream.");
  }
}
function isAbortSignal(value) {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  try {
    return typeof value.aborted === "boolean";
  } catch (_a2) {
    return false;
  }
}
function createAbortController() {
  if (supportsAbortController) {
    return new AbortController();
  }
  return void 0;
}
function AcquireWritableStreamDefaultWriter(stream) {
  return new WritableStreamDefaultWriter(stream);
}
function CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {
  if (highWaterMark === void 0) {
    highWaterMark = 1;
  }
  if (sizeAlgorithm === void 0) {
    sizeAlgorithm = function() {
      return 1;
    };
  }
  var stream = Object.create(WritableStream.prototype);
  InitializeWritableStream(stream);
  var controller = Object.create(WritableStreamDefaultController.prototype);
  SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
  return stream;
}
function InitializeWritableStream(stream) {
  stream._state = "writable";
  stream._storedError = void 0;
  stream._writer = void 0;
  stream._writableStreamController = void 0;
  stream._writeRequests = new SimpleQueue();
  stream._inFlightWriteRequest = void 0;
  stream._closeRequest = void 0;
  stream._inFlightCloseRequest = void 0;
  stream._pendingAbortRequest = void 0;
  stream._backpressure = false;
}
function IsWritableStream(x) {
  if (!typeIsObject(x)) {
    return false;
  }
  if (!Object.prototype.hasOwnProperty.call(x, "_writableStreamController")) {
    return false;
  }
  return x instanceof WritableStream;
}
function IsWritableStreamLocked(stream) {
  if (stream._writer === void 0) {
    return false;
  }
  return true;
}
function WritableStreamAbort(stream, reason) {
  var _a2;
  if (stream._state === "closed" || stream._state === "errored") {
    return promiseResolvedWith(void 0);
  }
  stream._writableStreamController._abortReason = reason;
  (_a2 = stream._writableStreamController._abortController) === null || _a2 === void 0 ? void 0 : _a2.abort();
  var state = stream._state;
  if (state === "closed" || state === "errored") {
    return promiseResolvedWith(void 0);
  }
  if (stream._pendingAbortRequest !== void 0) {
    return stream._pendingAbortRequest._promise;
  }
  var wasAlreadyErroring = false;
  if (state === "erroring") {
    wasAlreadyErroring = true;
    reason = void 0;
  }
  var promise = newPromise(function(resolve, reject) {
    stream._pendingAbortRequest = {
      _promise: void 0,
      _resolve: resolve,
      _reject: reject,
      _reason: reason,
      _wasAlreadyErroring: wasAlreadyErroring
    };
  });
  stream._pendingAbortRequest._promise = promise;
  if (!wasAlreadyErroring) {
    WritableStreamStartErroring(stream, reason);
  }
  return promise;
}
function WritableStreamClose(stream) {
  var state = stream._state;
  if (state === "closed" || state === "errored") {
    return promiseRejectedWith(new TypeError("The stream (in " + state + " state) is not in the writable state and cannot be closed"));
  }
  var promise = newPromise(function(resolve, reject) {
    var closeRequest = {
      _resolve: resolve,
      _reject: reject
    };
    stream._closeRequest = closeRequest;
  });
  var writer = stream._writer;
  if (writer !== void 0 && stream._backpressure && state === "writable") {
    defaultWriterReadyPromiseResolve(writer);
  }
  WritableStreamDefaultControllerClose(stream._writableStreamController);
  return promise;
}
function WritableStreamAddWriteRequest(stream) {
  var promise = newPromise(function(resolve, reject) {
    var writeRequest = {
      _resolve: resolve,
      _reject: reject
    };
    stream._writeRequests.push(writeRequest);
  });
  return promise;
}
function WritableStreamDealWithRejection(stream, error) {
  var state = stream._state;
  if (state === "writable") {
    WritableStreamStartErroring(stream, error);
    return;
  }
  WritableStreamFinishErroring(stream);
}
function WritableStreamStartErroring(stream, reason) {
  var controller = stream._writableStreamController;
  stream._state = "erroring";
  stream._storedError = reason;
  var writer = stream._writer;
  if (writer !== void 0) {
    WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);
  }
  if (!WritableStreamHasOperationMarkedInFlight(stream) && controller._started) {
    WritableStreamFinishErroring(stream);
  }
}
function WritableStreamFinishErroring(stream) {
  stream._state = "errored";
  stream._writableStreamController[ErrorSteps]();
  var storedError = stream._storedError;
  stream._writeRequests.forEach(function(writeRequest) {
    writeRequest._reject(storedError);
  });
  stream._writeRequests = new SimpleQueue();
  if (stream._pendingAbortRequest === void 0) {
    WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
    return;
  }
  var abortRequest = stream._pendingAbortRequest;
  stream._pendingAbortRequest = void 0;
  if (abortRequest._wasAlreadyErroring) {
    abortRequest._reject(storedError);
    WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
    return;
  }
  var promise = stream._writableStreamController[AbortSteps](abortRequest._reason);
  uponPromise(promise, function() {
    abortRequest._resolve();
    WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
  }, function(reason) {
    abortRequest._reject(reason);
    WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
  });
}
function WritableStreamFinishInFlightWrite(stream) {
  stream._inFlightWriteRequest._resolve(void 0);
  stream._inFlightWriteRequest = void 0;
}
function WritableStreamFinishInFlightWriteWithError(stream, error) {
  stream._inFlightWriteRequest._reject(error);
  stream._inFlightWriteRequest = void 0;
  WritableStreamDealWithRejection(stream, error);
}
function WritableStreamFinishInFlightClose(stream) {
  stream._inFlightCloseRequest._resolve(void 0);
  stream._inFlightCloseRequest = void 0;
  var state = stream._state;
  if (state === "erroring") {
    stream._storedError = void 0;
    if (stream._pendingAbortRequest !== void 0) {
      stream._pendingAbortRequest._resolve();
      stream._pendingAbortRequest = void 0;
    }
  }
  stream._state = "closed";
  var writer = stream._writer;
  if (writer !== void 0) {
    defaultWriterClosedPromiseResolve(writer);
  }
}
function WritableStreamFinishInFlightCloseWithError(stream, error) {
  stream._inFlightCloseRequest._reject(error);
  stream._inFlightCloseRequest = void 0;
  if (stream._pendingAbortRequest !== void 0) {
    stream._pendingAbortRequest._reject(error);
    stream._pendingAbortRequest = void 0;
  }
  WritableStreamDealWithRejection(stream, error);
}
function WritableStreamCloseQueuedOrInFlight(stream) {
  if (stream._closeRequest === void 0 && stream._inFlightCloseRequest === void 0) {
    return false;
  }
  return true;
}
function WritableStreamHasOperationMarkedInFlight(stream) {
  if (stream._inFlightWriteRequest === void 0 && stream._inFlightCloseRequest === void 0) {
    return false;
  }
  return true;
}
function WritableStreamMarkCloseRequestInFlight(stream) {
  stream._inFlightCloseRequest = stream._closeRequest;
  stream._closeRequest = void 0;
}
function WritableStreamMarkFirstWriteRequestInFlight(stream) {
  stream._inFlightWriteRequest = stream._writeRequests.shift();
}
function WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {
  if (stream._closeRequest !== void 0) {
    stream._closeRequest._reject(stream._storedError);
    stream._closeRequest = void 0;
  }
  var writer = stream._writer;
  if (writer !== void 0) {
    defaultWriterClosedPromiseReject(writer, stream._storedError);
  }
}
function WritableStreamUpdateBackpressure(stream, backpressure) {
  var writer = stream._writer;
  if (writer !== void 0 && backpressure !== stream._backpressure) {
    if (backpressure) {
      defaultWriterReadyPromiseReset(writer);
    } else {
      defaultWriterReadyPromiseResolve(writer);
    }
  }
  stream._backpressure = backpressure;
}
function IsWritableStreamDefaultWriter(x) {
  if (!typeIsObject(x)) {
    return false;
  }
  if (!Object.prototype.hasOwnProperty.call(x, "_ownerWritableStream")) {
    return false;
  }
  return x instanceof WritableStreamDefaultWriter;
}
function WritableStreamDefaultWriterAbort(writer, reason) {
  var stream = writer._ownerWritableStream;
  return WritableStreamAbort(stream, reason);
}
function WritableStreamDefaultWriterClose(writer) {
  var stream = writer._ownerWritableStream;
  return WritableStreamClose(stream);
}
function WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {
  var stream = writer._ownerWritableStream;
  var state = stream._state;
  if (WritableStreamCloseQueuedOrInFlight(stream) || state === "closed") {
    return promiseResolvedWith(void 0);
  }
  if (state === "errored") {
    return promiseRejectedWith(stream._storedError);
  }
  return WritableStreamDefaultWriterClose(writer);
}
function WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error) {
  if (writer._closedPromiseState === "pending") {
    defaultWriterClosedPromiseReject(writer, error);
  } else {
    defaultWriterClosedPromiseResetToRejected(writer, error);
  }
}
function WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error) {
  if (writer._readyPromiseState === "pending") {
    defaultWriterReadyPromiseReject(writer, error);
  } else {
    defaultWriterReadyPromiseResetToRejected(writer, error);
  }
}
function WritableStreamDefaultWriterGetDesiredSize(writer) {
  var stream = writer._ownerWritableStream;
  var state = stream._state;
  if (state === "errored" || state === "erroring") {
    return null;
  }
  if (state === "closed") {
    return 0;
  }
  return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);
}
function WritableStreamDefaultWriterRelease(writer) {
  var stream = writer._ownerWritableStream;
  var releasedError = new TypeError("Writer was released and can no longer be used to monitor the stream's closedness");
  WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);
  WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);
  stream._writer = void 0;
  writer._ownerWritableStream = void 0;
}
function WritableStreamDefaultWriterWrite(writer, chunk) {
  var stream = writer._ownerWritableStream;
  var controller = stream._writableStreamController;
  var chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);
  if (stream !== writer._ownerWritableStream) {
    return promiseRejectedWith(defaultWriterLockException("write to"));
  }
  var state = stream._state;
  if (state === "errored") {
    return promiseRejectedWith(stream._storedError);
  }
  if (WritableStreamCloseQueuedOrInFlight(stream) || state === "closed") {
    return promiseRejectedWith(new TypeError("The stream is closing or closed and cannot be written to"));
  }
  if (state === "erroring") {
    return promiseRejectedWith(stream._storedError);
  }
  var promise = WritableStreamAddWriteRequest(stream);
  WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);
  return promise;
}
function IsWritableStreamDefaultController(x) {
  if (!typeIsObject(x)) {
    return false;
  }
  if (!Object.prototype.hasOwnProperty.call(x, "_controlledWritableStream")) {
    return false;
  }
  return x instanceof WritableStreamDefaultController;
}
function SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {
  controller._controlledWritableStream = stream;
  stream._writableStreamController = controller;
  controller._queue = void 0;
  controller._queueTotalSize = void 0;
  ResetQueue(controller);
  controller._abortReason = void 0;
  controller._abortController = createAbortController();
  controller._started = false;
  controller._strategySizeAlgorithm = sizeAlgorithm;
  controller._strategyHWM = highWaterMark;
  controller._writeAlgorithm = writeAlgorithm;
  controller._closeAlgorithm = closeAlgorithm;
  controller._abortAlgorithm = abortAlgorithm;
  var backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
  WritableStreamUpdateBackpressure(stream, backpressure);
  var startResult = startAlgorithm();
  var startPromise = promiseResolvedWith(startResult);
  uponPromise(startPromise, function() {
    controller._started = true;
    WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
  }, function(r) {
    controller._started = true;
    WritableStreamDealWithRejection(stream, r);
  });
}
function SetUpWritableStreamDefaultControllerFromUnderlyingSink(stream, underlyingSink, highWaterMark, sizeAlgorithm) {
  var controller = Object.create(WritableStreamDefaultController.prototype);
  var startAlgorithm = function() {
    return void 0;
  };
  var writeAlgorithm = function() {
    return promiseResolvedWith(void 0);
  };
  var closeAlgorithm = function() {
    return promiseResolvedWith(void 0);
  };
  var abortAlgorithm = function() {
    return promiseResolvedWith(void 0);
  };
  if (underlyingSink.start !== void 0) {
    startAlgorithm = function() {
      return underlyingSink.start(controller);
    };
  }
  if (underlyingSink.write !== void 0) {
    writeAlgorithm = function(chunk) {
      return underlyingSink.write(chunk, controller);
    };
  }
  if (underlyingSink.close !== void 0) {
    closeAlgorithm = function() {
      return underlyingSink.close();
    };
  }
  if (underlyingSink.abort !== void 0) {
    abortAlgorithm = function(reason) {
      return underlyingSink.abort(reason);
    };
  }
  SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
}
function WritableStreamDefaultControllerClearAlgorithms(controller) {
  controller._writeAlgorithm = void 0;
  controller._closeAlgorithm = void 0;
  controller._abortAlgorithm = void 0;
  controller._strategySizeAlgorithm = void 0;
}
function WritableStreamDefaultControllerClose(controller) {
  EnqueueValueWithSize(controller, closeSentinel, 0);
  WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
}
function WritableStreamDefaultControllerGetChunkSize(controller, chunk) {
  try {
    return controller._strategySizeAlgorithm(chunk);
  } catch (chunkSizeE) {
    WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);
    return 1;
  }
}
function WritableStreamDefaultControllerGetDesiredSize(controller) {
  return controller._strategyHWM - controller._queueTotalSize;
}
function WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {
  try {
    EnqueueValueWithSize(controller, chunk, chunkSize);
  } catch (enqueueE) {
    WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);
    return;
  }
  var stream = controller._controlledWritableStream;
  if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._state === "writable") {
    var backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
    WritableStreamUpdateBackpressure(stream, backpressure);
  }
  WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
}
function WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {
  var stream = controller._controlledWritableStream;
  if (!controller._started) {
    return;
  }
  if (stream._inFlightWriteRequest !== void 0) {
    return;
  }
  var state = stream._state;
  if (state === "erroring") {
    WritableStreamFinishErroring(stream);
    return;
  }
  if (controller._queue.length === 0) {
    return;
  }
  var value = PeekQueueValue(controller);
  if (value === closeSentinel) {
    WritableStreamDefaultControllerProcessClose(controller);
  } else {
    WritableStreamDefaultControllerProcessWrite(controller, value);
  }
}
function WritableStreamDefaultControllerErrorIfNeeded(controller, error) {
  if (controller._controlledWritableStream._state === "writable") {
    WritableStreamDefaultControllerError(controller, error);
  }
}
function WritableStreamDefaultControllerProcessClose(controller) {
  var stream = controller._controlledWritableStream;
  WritableStreamMarkCloseRequestInFlight(stream);
  DequeueValue(controller);
  var sinkClosePromise = controller._closeAlgorithm();
  WritableStreamDefaultControllerClearAlgorithms(controller);
  uponPromise(sinkClosePromise, function() {
    WritableStreamFinishInFlightClose(stream);
  }, function(reason) {
    WritableStreamFinishInFlightCloseWithError(stream, reason);
  });
}
function WritableStreamDefaultControllerProcessWrite(controller, chunk) {
  var stream = controller._controlledWritableStream;
  WritableStreamMarkFirstWriteRequestInFlight(stream);
  var sinkWritePromise = controller._writeAlgorithm(chunk);
  uponPromise(sinkWritePromise, function() {
    WritableStreamFinishInFlightWrite(stream);
    var state = stream._state;
    DequeueValue(controller);
    if (!WritableStreamCloseQueuedOrInFlight(stream) && state === "writable") {
      var backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
      WritableStreamUpdateBackpressure(stream, backpressure);
    }
    WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
  }, function(reason) {
    if (stream._state === "writable") {
      WritableStreamDefaultControllerClearAlgorithms(controller);
    }
    WritableStreamFinishInFlightWriteWithError(stream, reason);
  });
}
function WritableStreamDefaultControllerGetBackpressure(controller) {
  var desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);
  return desiredSize <= 0;
}
function WritableStreamDefaultControllerError(controller, error) {
  var stream = controller._controlledWritableStream;
  WritableStreamDefaultControllerClearAlgorithms(controller);
  WritableStreamStartErroring(stream, error);
}
function streamBrandCheckException$2(name5) {
  return new TypeError("WritableStream.prototype." + name5 + " can only be used on a WritableStream");
}
function defaultControllerBrandCheckException$2(name5) {
  return new TypeError("WritableStreamDefaultController.prototype." + name5 + " can only be used on a WritableStreamDefaultController");
}
function defaultWriterBrandCheckException(name5) {
  return new TypeError("WritableStreamDefaultWriter.prototype." + name5 + " can only be used on a WritableStreamDefaultWriter");
}
function defaultWriterLockException(name5) {
  return new TypeError("Cannot " + name5 + " a stream using a released writer");
}
function defaultWriterClosedPromiseInitialize(writer) {
  writer._closedPromise = newPromise(function(resolve, reject) {
    writer._closedPromise_resolve = resolve;
    writer._closedPromise_reject = reject;
    writer._closedPromiseState = "pending";
  });
}
function defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {
  defaultWriterClosedPromiseInitialize(writer);
  defaultWriterClosedPromiseReject(writer, reason);
}
function defaultWriterClosedPromiseInitializeAsResolved(writer) {
  defaultWriterClosedPromiseInitialize(writer);
  defaultWriterClosedPromiseResolve(writer);
}
function defaultWriterClosedPromiseReject(writer, reason) {
  if (writer._closedPromise_reject === void 0) {
    return;
  }
  setPromiseIsHandledToTrue(writer._closedPromise);
  writer._closedPromise_reject(reason);
  writer._closedPromise_resolve = void 0;
  writer._closedPromise_reject = void 0;
  writer._closedPromiseState = "rejected";
}
function defaultWriterClosedPromiseResetToRejected(writer, reason) {
  defaultWriterClosedPromiseInitializeAsRejected(writer, reason);
}
function defaultWriterClosedPromiseResolve(writer) {
  if (writer._closedPromise_resolve === void 0) {
    return;
  }
  writer._closedPromise_resolve(void 0);
  writer._closedPromise_resolve = void 0;
  writer._closedPromise_reject = void 0;
  writer._closedPromiseState = "resolved";
}
function defaultWriterReadyPromiseInitialize(writer) {
  writer._readyPromise = newPromise(function(resolve, reject) {
    writer._readyPromise_resolve = resolve;
    writer._readyPromise_reject = reject;
  });
  writer._readyPromiseState = "pending";
}
function defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {
  defaultWriterReadyPromiseInitialize(writer);
  defaultWriterReadyPromiseReject(writer, reason);
}
function defaultWriterReadyPromiseInitializeAsResolved(writer) {
  defaultWriterReadyPromiseInitialize(writer);
  defaultWriterReadyPromiseResolve(writer);
}
function defaultWriterReadyPromiseReject(writer, reason) {
  if (writer._readyPromise_reject === void 0) {
    return;
  }
  setPromiseIsHandledToTrue(writer._readyPromise);
  writer._readyPromise_reject(reason);
  writer._readyPromise_resolve = void 0;
  writer._readyPromise_reject = void 0;
  writer._readyPromiseState = "rejected";
}
function defaultWriterReadyPromiseReset(writer) {
  defaultWriterReadyPromiseInitialize(writer);
}
function defaultWriterReadyPromiseResetToRejected(writer, reason) {
  defaultWriterReadyPromiseInitializeAsRejected(writer, reason);
}
function defaultWriterReadyPromiseResolve(writer) {
  if (writer._readyPromise_resolve === void 0) {
    return;
  }
  writer._readyPromise_resolve(void 0);
  writer._readyPromise_resolve = void 0;
  writer._readyPromise_reject = void 0;
  writer._readyPromiseState = "fulfilled";
}
function isDOMExceptionConstructor(ctor) {
  if (!(typeof ctor === "function" || typeof ctor === "object")) {
    return false;
  }
  try {
    new ctor();
    return true;
  } catch (_a2) {
    return false;
  }
}
function createDOMExceptionPolyfill() {
  var ctor = function DOMException2(message, name5) {
    this.message = message || "";
    this.name = name5 || "Error";
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
  };
  ctor.prototype = Object.create(Error.prototype);
  Object.defineProperty(ctor.prototype, "constructor", { value: ctor, writable: true, configurable: true });
  return ctor;
}
function ReadableStreamPipeTo(source, dest, preventClose, preventAbort, preventCancel, signal) {
  var reader = AcquireReadableStreamDefaultReader(source);
  var writer = AcquireWritableStreamDefaultWriter(dest);
  source._disturbed = true;
  var shuttingDown = false;
  var currentWrite = promiseResolvedWith(void 0);
  return newPromise(function(resolve, reject) {
    var abortAlgorithm;
    if (signal !== void 0) {
      abortAlgorithm = function() {
        var error = new DOMException$1("Aborted", "AbortError");
        var actions = [];
        if (!preventAbort) {
          actions.push(function() {
            if (dest._state === "writable") {
              return WritableStreamAbort(dest, error);
            }
            return promiseResolvedWith(void 0);
          });
        }
        if (!preventCancel) {
          actions.push(function() {
            if (source._state === "readable") {
              return ReadableStreamCancel(source, error);
            }
            return promiseResolvedWith(void 0);
          });
        }
        shutdownWithAction(function() {
          return Promise.all(actions.map(function(action) {
            return action();
          }));
        }, true, error);
      };
      if (signal.aborted) {
        abortAlgorithm();
        return;
      }
      signal.addEventListener("abort", abortAlgorithm);
    }
    function pipeLoop() {
      return newPromise(function(resolveLoop, rejectLoop) {
        function next(done) {
          if (done) {
            resolveLoop();
          } else {
            PerformPromiseThen(pipeStep(), next, rejectLoop);
          }
        }
        next(false);
      });
    }
    function pipeStep() {
      if (shuttingDown) {
        return promiseResolvedWith(true);
      }
      return PerformPromiseThen(writer._readyPromise, function() {
        return newPromise(function(resolveRead, rejectRead) {
          ReadableStreamDefaultReaderRead(reader, {
            _chunkSteps: function(chunk) {
              currentWrite = PerformPromiseThen(WritableStreamDefaultWriterWrite(writer, chunk), void 0, noop2);
              resolveRead(false);
            },
            _closeSteps: function() {
              return resolveRead(true);
            },
            _errorSteps: rejectRead
          });
        });
      });
    }
    isOrBecomesErrored(source, reader._closedPromise, function(storedError) {
      if (!preventAbort) {
        shutdownWithAction(function() {
          return WritableStreamAbort(dest, storedError);
        }, true, storedError);
      } else {
        shutdown(true, storedError);
      }
    });
    isOrBecomesErrored(dest, writer._closedPromise, function(storedError) {
      if (!preventCancel) {
        shutdownWithAction(function() {
          return ReadableStreamCancel(source, storedError);
        }, true, storedError);
      } else {
        shutdown(true, storedError);
      }
    });
    isOrBecomesClosed(source, reader._closedPromise, function() {
      if (!preventClose) {
        shutdownWithAction(function() {
          return WritableStreamDefaultWriterCloseWithErrorPropagation(writer);
        });
      } else {
        shutdown();
      }
    });
    if (WritableStreamCloseQueuedOrInFlight(dest) || dest._state === "closed") {
      var destClosed_1 = new TypeError("the destination writable stream closed before all data could be piped to it");
      if (!preventCancel) {
        shutdownWithAction(function() {
          return ReadableStreamCancel(source, destClosed_1);
        }, true, destClosed_1);
      } else {
        shutdown(true, destClosed_1);
      }
    }
    setPromiseIsHandledToTrue(pipeLoop());
    function waitForWritesToFinish() {
      var oldCurrentWrite = currentWrite;
      return PerformPromiseThen(currentWrite, function() {
        return oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : void 0;
      });
    }
    function isOrBecomesErrored(stream, promise, action) {
      if (stream._state === "errored") {
        action(stream._storedError);
      } else {
        uponRejection(promise, action);
      }
    }
    function isOrBecomesClosed(stream, promise, action) {
      if (stream._state === "closed") {
        action();
      } else {
        uponFulfillment(promise, action);
      }
    }
    function shutdownWithAction(action, originalIsError, originalError) {
      if (shuttingDown) {
        return;
      }
      shuttingDown = true;
      if (dest._state === "writable" && !WritableStreamCloseQueuedOrInFlight(dest)) {
        uponFulfillment(waitForWritesToFinish(), doTheRest);
      } else {
        doTheRest();
      }
      function doTheRest() {
        uponPromise(action(), function() {
          return finalize(originalIsError, originalError);
        }, function(newError) {
          return finalize(true, newError);
        });
      }
    }
    function shutdown(isError, error) {
      if (shuttingDown) {
        return;
      }
      shuttingDown = true;
      if (dest._state === "writable" && !WritableStreamCloseQueuedOrInFlight(dest)) {
        uponFulfillment(waitForWritesToFinish(), function() {
          return finalize(isError, error);
        });
      } else {
        finalize(isError, error);
      }
    }
    function finalize(isError, error) {
      WritableStreamDefaultWriterRelease(writer);
      ReadableStreamReaderGenericRelease(reader);
      if (signal !== void 0) {
        signal.removeEventListener("abort", abortAlgorithm);
      }
      if (isError) {
        reject(error);
      } else {
        resolve(void 0);
      }
    }
  });
}
function IsReadableStreamDefaultController(x) {
  if (!typeIsObject(x)) {
    return false;
  }
  if (!Object.prototype.hasOwnProperty.call(x, "_controlledReadableStream")) {
    return false;
  }
  return x instanceof ReadableStreamDefaultController;
}
function ReadableStreamDefaultControllerCallPullIfNeeded(controller) {
  var shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);
  if (!shouldPull) {
    return;
  }
  if (controller._pulling) {
    controller._pullAgain = true;
    return;
  }
  controller._pulling = true;
  var pullPromise = controller._pullAlgorithm();
  uponPromise(pullPromise, function() {
    controller._pulling = false;
    if (controller._pullAgain) {
      controller._pullAgain = false;
      ReadableStreamDefaultControllerCallPullIfNeeded(controller);
    }
  }, function(e) {
    ReadableStreamDefaultControllerError(controller, e);
  });
}
function ReadableStreamDefaultControllerShouldCallPull(controller) {
  var stream = controller._controlledReadableStream;
  if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
    return false;
  }
  if (!controller._started) {
    return false;
  }
  if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
    return true;
  }
  var desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);
  if (desiredSize > 0) {
    return true;
  }
  return false;
}
function ReadableStreamDefaultControllerClearAlgorithms(controller) {
  controller._pullAlgorithm = void 0;
  controller._cancelAlgorithm = void 0;
  controller._strategySizeAlgorithm = void 0;
}
function ReadableStreamDefaultControllerClose(controller) {
  if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
    return;
  }
  var stream = controller._controlledReadableStream;
  controller._closeRequested = true;
  if (controller._queue.length === 0) {
    ReadableStreamDefaultControllerClearAlgorithms(controller);
    ReadableStreamClose(stream);
  }
}
function ReadableStreamDefaultControllerEnqueue(controller, chunk) {
  if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
    return;
  }
  var stream = controller._controlledReadableStream;
  if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
    ReadableStreamFulfillReadRequest(stream, chunk, false);
  } else {
    var chunkSize = void 0;
    try {
      chunkSize = controller._strategySizeAlgorithm(chunk);
    } catch (chunkSizeE) {
      ReadableStreamDefaultControllerError(controller, chunkSizeE);
      throw chunkSizeE;
    }
    try {
      EnqueueValueWithSize(controller, chunk, chunkSize);
    } catch (enqueueE) {
      ReadableStreamDefaultControllerError(controller, enqueueE);
      throw enqueueE;
    }
  }
  ReadableStreamDefaultControllerCallPullIfNeeded(controller);
}
function ReadableStreamDefaultControllerError(controller, e) {
  var stream = controller._controlledReadableStream;
  if (stream._state !== "readable") {
    return;
  }
  ResetQueue(controller);
  ReadableStreamDefaultControllerClearAlgorithms(controller);
  ReadableStreamError(stream, e);
}
function ReadableStreamDefaultControllerGetDesiredSize(controller) {
  var state = controller._controlledReadableStream._state;
  if (state === "errored") {
    return null;
  }
  if (state === "closed") {
    return 0;
  }
  return controller._strategyHWM - controller._queueTotalSize;
}
function ReadableStreamDefaultControllerHasBackpressure(controller) {
  if (ReadableStreamDefaultControllerShouldCallPull(controller)) {
    return false;
  }
  return true;
}
function ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {
  var state = controller._controlledReadableStream._state;
  if (!controller._closeRequested && state === "readable") {
    return true;
  }
  return false;
}
function SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {
  controller._controlledReadableStream = stream;
  controller._queue = void 0;
  controller._queueTotalSize = void 0;
  ResetQueue(controller);
  controller._started = false;
  controller._closeRequested = false;
  controller._pullAgain = false;
  controller._pulling = false;
  controller._strategySizeAlgorithm = sizeAlgorithm;
  controller._strategyHWM = highWaterMark;
  controller._pullAlgorithm = pullAlgorithm;
  controller._cancelAlgorithm = cancelAlgorithm;
  stream._readableStreamController = controller;
  var startResult = startAlgorithm();
  uponPromise(promiseResolvedWith(startResult), function() {
    controller._started = true;
    ReadableStreamDefaultControllerCallPullIfNeeded(controller);
  }, function(r) {
    ReadableStreamDefaultControllerError(controller, r);
  });
}
function SetUpReadableStreamDefaultControllerFromUnderlyingSource(stream, underlyingSource, highWaterMark, sizeAlgorithm) {
  var controller = Object.create(ReadableStreamDefaultController.prototype);
  var startAlgorithm = function() {
    return void 0;
  };
  var pullAlgorithm = function() {
    return promiseResolvedWith(void 0);
  };
  var cancelAlgorithm = function() {
    return promiseResolvedWith(void 0);
  };
  if (underlyingSource.start !== void 0) {
    startAlgorithm = function() {
      return underlyingSource.start(controller);
    };
  }
  if (underlyingSource.pull !== void 0) {
    pullAlgorithm = function() {
      return underlyingSource.pull(controller);
    };
  }
  if (underlyingSource.cancel !== void 0) {
    cancelAlgorithm = function(reason) {
      return underlyingSource.cancel(reason);
    };
  }
  SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
}
function defaultControllerBrandCheckException$1(name5) {
  return new TypeError("ReadableStreamDefaultController.prototype." + name5 + " can only be used on a ReadableStreamDefaultController");
}
function ReadableStreamTee(stream, cloneForBranch2) {
  if (IsReadableByteStreamController(stream._readableStreamController)) {
    return ReadableByteStreamTee(stream);
  }
  return ReadableStreamDefaultTee(stream);
}
function ReadableStreamDefaultTee(stream, cloneForBranch2) {
  var reader = AcquireReadableStreamDefaultReader(stream);
  var reading = false;
  var readAgain = false;
  var canceled1 = false;
  var canceled2 = false;
  var reason1;
  var reason2;
  var branch1;
  var branch2;
  var resolveCancelPromise;
  var cancelPromise = newPromise(function(resolve) {
    resolveCancelPromise = resolve;
  });
  function pullAlgorithm() {
    if (reading) {
      readAgain = true;
      return promiseResolvedWith(void 0);
    }
    reading = true;
    var readRequest = {
      _chunkSteps: function(chunk) {
        queueMicrotask(function() {
          readAgain = false;
          var chunk1 = chunk;
          var chunk2 = chunk;
          if (!canceled1) {
            ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, chunk1);
          }
          if (!canceled2) {
            ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, chunk2);
          }
          reading = false;
          if (readAgain) {
            pullAlgorithm();
          }
        });
      },
      _closeSteps: function() {
        reading = false;
        if (!canceled1) {
          ReadableStreamDefaultControllerClose(branch1._readableStreamController);
        }
        if (!canceled2) {
          ReadableStreamDefaultControllerClose(branch2._readableStreamController);
        }
        if (!canceled1 || !canceled2) {
          resolveCancelPromise(void 0);
        }
      },
      _errorSteps: function() {
        reading = false;
      }
    };
    ReadableStreamDefaultReaderRead(reader, readRequest);
    return promiseResolvedWith(void 0);
  }
  function cancel1Algorithm(reason) {
    canceled1 = true;
    reason1 = reason;
    if (canceled2) {
      var compositeReason = CreateArrayFromList([reason1, reason2]);
      var cancelResult = ReadableStreamCancel(stream, compositeReason);
      resolveCancelPromise(cancelResult);
    }
    return cancelPromise;
  }
  function cancel2Algorithm(reason) {
    canceled2 = true;
    reason2 = reason;
    if (canceled1) {
      var compositeReason = CreateArrayFromList([reason1, reason2]);
      var cancelResult = ReadableStreamCancel(stream, compositeReason);
      resolveCancelPromise(cancelResult);
    }
    return cancelPromise;
  }
  function startAlgorithm() {
  }
  branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);
  branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);
  uponRejection(reader._closedPromise, function(r) {
    ReadableStreamDefaultControllerError(branch1._readableStreamController, r);
    ReadableStreamDefaultControllerError(branch2._readableStreamController, r);
    if (!canceled1 || !canceled2) {
      resolveCancelPromise(void 0);
    }
  });
  return [branch1, branch2];
}
function ReadableByteStreamTee(stream) {
  var reader = AcquireReadableStreamDefaultReader(stream);
  var reading = false;
  var readAgainForBranch1 = false;
  var readAgainForBranch2 = false;
  var canceled1 = false;
  var canceled2 = false;
  var reason1;
  var reason2;
  var branch1;
  var branch2;
  var resolveCancelPromise;
  var cancelPromise = newPromise(function(resolve) {
    resolveCancelPromise = resolve;
  });
  function forwardReaderError(thisReader) {
    uponRejection(thisReader._closedPromise, function(r) {
      if (thisReader !== reader) {
        return;
      }
      ReadableByteStreamControllerError(branch1._readableStreamController, r);
      ReadableByteStreamControllerError(branch2._readableStreamController, r);
      if (!canceled1 || !canceled2) {
        resolveCancelPromise(void 0);
      }
    });
  }
  function pullWithDefaultReader() {
    if (IsReadableStreamBYOBReader(reader)) {
      ReadableStreamReaderGenericRelease(reader);
      reader = AcquireReadableStreamDefaultReader(stream);
      forwardReaderError(reader);
    }
    var readRequest = {
      _chunkSteps: function(chunk) {
        queueMicrotask(function() {
          readAgainForBranch1 = false;
          readAgainForBranch2 = false;
          var chunk1 = chunk;
          var chunk2 = chunk;
          if (!canceled1 && !canceled2) {
            try {
              chunk2 = CloneAsUint8Array(chunk);
            } catch (cloneE) {
              ReadableByteStreamControllerError(branch1._readableStreamController, cloneE);
              ReadableByteStreamControllerError(branch2._readableStreamController, cloneE);
              resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
              return;
            }
          }
          if (!canceled1) {
            ReadableByteStreamControllerEnqueue(branch1._readableStreamController, chunk1);
          }
          if (!canceled2) {
            ReadableByteStreamControllerEnqueue(branch2._readableStreamController, chunk2);
          }
          reading = false;
          if (readAgainForBranch1) {
            pull1Algorithm();
          } else if (readAgainForBranch2) {
            pull2Algorithm();
          }
        });
      },
      _closeSteps: function() {
        reading = false;
        if (!canceled1) {
          ReadableByteStreamControllerClose(branch1._readableStreamController);
        }
        if (!canceled2) {
          ReadableByteStreamControllerClose(branch2._readableStreamController);
        }
        if (branch1._readableStreamController._pendingPullIntos.length > 0) {
          ReadableByteStreamControllerRespond(branch1._readableStreamController, 0);
        }
        if (branch2._readableStreamController._pendingPullIntos.length > 0) {
          ReadableByteStreamControllerRespond(branch2._readableStreamController, 0);
        }
        if (!canceled1 || !canceled2) {
          resolveCancelPromise(void 0);
        }
      },
      _errorSteps: function() {
        reading = false;
      }
    };
    ReadableStreamDefaultReaderRead(reader, readRequest);
  }
  function pullWithBYOBReader(view, forBranch2) {
    if (IsReadableStreamDefaultReader(reader)) {
      ReadableStreamReaderGenericRelease(reader);
      reader = AcquireReadableStreamBYOBReader(stream);
      forwardReaderError(reader);
    }
    var byobBranch = forBranch2 ? branch2 : branch1;
    var otherBranch = forBranch2 ? branch1 : branch2;
    var readIntoRequest = {
      _chunkSteps: function(chunk) {
        queueMicrotask(function() {
          readAgainForBranch1 = false;
          readAgainForBranch2 = false;
          var byobCanceled = forBranch2 ? canceled2 : canceled1;
          var otherCanceled = forBranch2 ? canceled1 : canceled2;
          if (!otherCanceled) {
            var clonedChunk = void 0;
            try {
              clonedChunk = CloneAsUint8Array(chunk);
            } catch (cloneE) {
              ReadableByteStreamControllerError(byobBranch._readableStreamController, cloneE);
              ReadableByteStreamControllerError(otherBranch._readableStreamController, cloneE);
              resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
              return;
            }
            if (!byobCanceled) {
              ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
            }
            ReadableByteStreamControllerEnqueue(otherBranch._readableStreamController, clonedChunk);
          } else if (!byobCanceled) {
            ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
          }
          reading = false;
          if (readAgainForBranch1) {
            pull1Algorithm();
          } else if (readAgainForBranch2) {
            pull2Algorithm();
          }
        });
      },
      _closeSteps: function(chunk) {
        reading = false;
        var byobCanceled = forBranch2 ? canceled2 : canceled1;
        var otherCanceled = forBranch2 ? canceled1 : canceled2;
        if (!byobCanceled) {
          ReadableByteStreamControllerClose(byobBranch._readableStreamController);
        }
        if (!otherCanceled) {
          ReadableByteStreamControllerClose(otherBranch._readableStreamController);
        }
        if (chunk !== void 0) {
          if (!byobCanceled) {
            ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
          }
          if (!otherCanceled && otherBranch._readableStreamController._pendingPullIntos.length > 0) {
            ReadableByteStreamControllerRespond(otherBranch._readableStreamController, 0);
          }
        }
        if (!byobCanceled || !otherCanceled) {
          resolveCancelPromise(void 0);
        }
      },
      _errorSteps: function() {
        reading = false;
      }
    };
    ReadableStreamBYOBReaderRead(reader, view, readIntoRequest);
  }
  function pull1Algorithm() {
    if (reading) {
      readAgainForBranch1 = true;
      return promiseResolvedWith(void 0);
    }
    reading = true;
    var byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch1._readableStreamController);
    if (byobRequest === null) {
      pullWithDefaultReader();
    } else {
      pullWithBYOBReader(byobRequest._view, false);
    }
    return promiseResolvedWith(void 0);
  }
  function pull2Algorithm() {
    if (reading) {
      readAgainForBranch2 = true;
      return promiseResolvedWith(void 0);
    }
    reading = true;
    var byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch2._readableStreamController);
    if (byobRequest === null) {
      pullWithDefaultReader();
    } else {
      pullWithBYOBReader(byobRequest._view, true);
    }
    return promiseResolvedWith(void 0);
  }
  function cancel1Algorithm(reason) {
    canceled1 = true;
    reason1 = reason;
    if (canceled2) {
      var compositeReason = CreateArrayFromList([reason1, reason2]);
      var cancelResult = ReadableStreamCancel(stream, compositeReason);
      resolveCancelPromise(cancelResult);
    }
    return cancelPromise;
  }
  function cancel2Algorithm(reason) {
    canceled2 = true;
    reason2 = reason;
    if (canceled1) {
      var compositeReason = CreateArrayFromList([reason1, reason2]);
      var cancelResult = ReadableStreamCancel(stream, compositeReason);
      resolveCancelPromise(cancelResult);
    }
    return cancelPromise;
  }
  function startAlgorithm() {
    return;
  }
  branch1 = CreateReadableByteStream(startAlgorithm, pull1Algorithm, cancel1Algorithm);
  branch2 = CreateReadableByteStream(startAlgorithm, pull2Algorithm, cancel2Algorithm);
  forwardReaderError(reader);
  return [branch1, branch2];
}
function convertUnderlyingDefaultOrByteSource(source, context) {
  assertDictionary(source, context);
  var original = source;
  var autoAllocateChunkSize = original === null || original === void 0 ? void 0 : original.autoAllocateChunkSize;
  var cancel = original === null || original === void 0 ? void 0 : original.cancel;
  var pull = original === null || original === void 0 ? void 0 : original.pull;
  var start = original === null || original === void 0 ? void 0 : original.start;
  var type = original === null || original === void 0 ? void 0 : original.type;
  return {
    autoAllocateChunkSize: autoAllocateChunkSize === void 0 ? void 0 : convertUnsignedLongLongWithEnforceRange(autoAllocateChunkSize, context + " has member 'autoAllocateChunkSize' that"),
    cancel: cancel === void 0 ? void 0 : convertUnderlyingSourceCancelCallback(cancel, original, context + " has member 'cancel' that"),
    pull: pull === void 0 ? void 0 : convertUnderlyingSourcePullCallback(pull, original, context + " has member 'pull' that"),
    start: start === void 0 ? void 0 : convertUnderlyingSourceStartCallback(start, original, context + " has member 'start' that"),
    type: type === void 0 ? void 0 : convertReadableStreamType(type, context + " has member 'type' that")
  };
}
function convertUnderlyingSourceCancelCallback(fn, original, context) {
  assertFunction(fn, context);
  return function(reason) {
    return promiseCall(fn, original, [reason]);
  };
}
function convertUnderlyingSourcePullCallback(fn, original, context) {
  assertFunction(fn, context);
  return function(controller) {
    return promiseCall(fn, original, [controller]);
  };
}
function convertUnderlyingSourceStartCallback(fn, original, context) {
  assertFunction(fn, context);
  return function(controller) {
    return reflectCall(fn, original, [controller]);
  };
}
function convertReadableStreamType(type, context) {
  type = "" + type;
  if (type !== "bytes") {
    throw new TypeError(context + " '" + type + "' is not a valid enumeration value for ReadableStreamType");
  }
  return type;
}
function convertReaderOptions(options, context) {
  assertDictionary(options, context);
  var mode = options === null || options === void 0 ? void 0 : options.mode;
  return {
    mode: mode === void 0 ? void 0 : convertReadableStreamReaderMode(mode, context + " has member 'mode' that")
  };
}
function convertReadableStreamReaderMode(mode, context) {
  mode = "" + mode;
  if (mode !== "byob") {
    throw new TypeError(context + " '" + mode + "' is not a valid enumeration value for ReadableStreamReaderMode");
  }
  return mode;
}
function convertIteratorOptions(options, context) {
  assertDictionary(options, context);
  var preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;
  return { preventCancel: Boolean(preventCancel) };
}
function convertPipeOptions(options, context) {
  assertDictionary(options, context);
  var preventAbort = options === null || options === void 0 ? void 0 : options.preventAbort;
  var preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;
  var preventClose = options === null || options === void 0 ? void 0 : options.preventClose;
  var signal = options === null || options === void 0 ? void 0 : options.signal;
  if (signal !== void 0) {
    assertAbortSignal(signal, context + " has member 'signal' that");
  }
  return {
    preventAbort: Boolean(preventAbort),
    preventCancel: Boolean(preventCancel),
    preventClose: Boolean(preventClose),
    signal
  };
}
function assertAbortSignal(signal, context) {
  if (!isAbortSignal(signal)) {
    throw new TypeError(context + " is not an AbortSignal.");
  }
}
function convertReadableWritablePair(pair, context) {
  assertDictionary(pair, context);
  var readable = pair === null || pair === void 0 ? void 0 : pair.readable;
  assertRequiredField(readable, "readable", "ReadableWritablePair");
  assertReadableStream(readable, context + " has member 'readable' that");
  var writable = pair === null || pair === void 0 ? void 0 : pair.writable;
  assertRequiredField(writable, "writable", "ReadableWritablePair");
  assertWritableStream(writable, context + " has member 'writable' that");
  return { readable, writable };
}
function CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {
  if (highWaterMark === void 0) {
    highWaterMark = 1;
  }
  if (sizeAlgorithm === void 0) {
    sizeAlgorithm = function() {
      return 1;
    };
  }
  var stream = Object.create(ReadableStream.prototype);
  InitializeReadableStream(stream);
  var controller = Object.create(ReadableStreamDefaultController.prototype);
  SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
  return stream;
}
function CreateReadableByteStream(startAlgorithm, pullAlgorithm, cancelAlgorithm) {
  var stream = Object.create(ReadableStream.prototype);
  InitializeReadableStream(stream);
  var controller = Object.create(ReadableByteStreamController.prototype);
  SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, 0, void 0);
  return stream;
}
function InitializeReadableStream(stream) {
  stream._state = "readable";
  stream._reader = void 0;
  stream._storedError = void 0;
  stream._disturbed = false;
}
function IsReadableStream(x) {
  if (!typeIsObject(x)) {
    return false;
  }
  if (!Object.prototype.hasOwnProperty.call(x, "_readableStreamController")) {
    return false;
  }
  return x instanceof ReadableStream;
}
function IsReadableStreamLocked(stream) {
  if (stream._reader === void 0) {
    return false;
  }
  return true;
}
function ReadableStreamCancel(stream, reason) {
  stream._disturbed = true;
  if (stream._state === "closed") {
    return promiseResolvedWith(void 0);
  }
  if (stream._state === "errored") {
    return promiseRejectedWith(stream._storedError);
  }
  ReadableStreamClose(stream);
  var reader = stream._reader;
  if (reader !== void 0 && IsReadableStreamBYOBReader(reader)) {
    reader._readIntoRequests.forEach(function(readIntoRequest) {
      readIntoRequest._closeSteps(void 0);
    });
    reader._readIntoRequests = new SimpleQueue();
  }
  var sourceCancelPromise = stream._readableStreamController[CancelSteps](reason);
  return transformPromiseWith(sourceCancelPromise, noop2);
}
function ReadableStreamClose(stream) {
  stream._state = "closed";
  var reader = stream._reader;
  if (reader === void 0) {
    return;
  }
  defaultReaderClosedPromiseResolve(reader);
  if (IsReadableStreamDefaultReader(reader)) {
    reader._readRequests.forEach(function(readRequest) {
      readRequest._closeSteps();
    });
    reader._readRequests = new SimpleQueue();
  }
}
function ReadableStreamError(stream, e) {
  stream._state = "errored";
  stream._storedError = e;
  var reader = stream._reader;
  if (reader === void 0) {
    return;
  }
  defaultReaderClosedPromiseReject(reader, e);
  if (IsReadableStreamDefaultReader(reader)) {
    reader._readRequests.forEach(function(readRequest) {
      readRequest._errorSteps(e);
    });
    reader._readRequests = new SimpleQueue();
  } else {
    reader._readIntoRequests.forEach(function(readIntoRequest) {
      readIntoRequest._errorSteps(e);
    });
    reader._readIntoRequests = new SimpleQueue();
  }
}
function streamBrandCheckException$1(name5) {
  return new TypeError("ReadableStream.prototype." + name5 + " can only be used on a ReadableStream");
}
function convertQueuingStrategyInit(init, context) {
  assertDictionary(init, context);
  var highWaterMark = init === null || init === void 0 ? void 0 : init.highWaterMark;
  assertRequiredField(highWaterMark, "highWaterMark", "QueuingStrategyInit");
  return {
    highWaterMark: convertUnrestrictedDouble(highWaterMark)
  };
}
function byteLengthBrandCheckException(name5) {
  return new TypeError("ByteLengthQueuingStrategy.prototype." + name5 + " can only be used on a ByteLengthQueuingStrategy");
}
function IsByteLengthQueuingStrategy(x) {
  if (!typeIsObject(x)) {
    return false;
  }
  if (!Object.prototype.hasOwnProperty.call(x, "_byteLengthQueuingStrategyHighWaterMark")) {
    return false;
  }
  return x instanceof ByteLengthQueuingStrategy;
}
function countBrandCheckException(name5) {
  return new TypeError("CountQueuingStrategy.prototype." + name5 + " can only be used on a CountQueuingStrategy");
}
function IsCountQueuingStrategy(x) {
  if (!typeIsObject(x)) {
    return false;
  }
  if (!Object.prototype.hasOwnProperty.call(x, "_countQueuingStrategyHighWaterMark")) {
    return false;
  }
  return x instanceof CountQueuingStrategy;
}
function convertTransformer(original, context) {
  assertDictionary(original, context);
  var flush2 = original === null || original === void 0 ? void 0 : original.flush;
  var readableType = original === null || original === void 0 ? void 0 : original.readableType;
  var start = original === null || original === void 0 ? void 0 : original.start;
  var transform2 = original === null || original === void 0 ? void 0 : original.transform;
  var writableType = original === null || original === void 0 ? void 0 : original.writableType;
  return {
    flush: flush2 === void 0 ? void 0 : convertTransformerFlushCallback(flush2, original, context + " has member 'flush' that"),
    readableType,
    start: start === void 0 ? void 0 : convertTransformerStartCallback(start, original, context + " has member 'start' that"),
    transform: transform2 === void 0 ? void 0 : convertTransformerTransformCallback(transform2, original, context + " has member 'transform' that"),
    writableType
  };
}
function convertTransformerFlushCallback(fn, original, context) {
  assertFunction(fn, context);
  return function(controller) {
    return promiseCall(fn, original, [controller]);
  };
}
function convertTransformerStartCallback(fn, original, context) {
  assertFunction(fn, context);
  return function(controller) {
    return reflectCall(fn, original, [controller]);
  };
}
function convertTransformerTransformCallback(fn, original, context) {
  assertFunction(fn, context);
  return function(chunk, controller) {
    return promiseCall(fn, original, [chunk, controller]);
  };
}
function InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark2, readableSizeAlgorithm) {
  function startAlgorithm() {
    return startPromise;
  }
  function writeAlgorithm(chunk) {
    return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);
  }
  function abortAlgorithm(reason) {
    return TransformStreamDefaultSinkAbortAlgorithm(stream, reason);
  }
  function closeAlgorithm() {
    return TransformStreamDefaultSinkCloseAlgorithm(stream);
  }
  stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, writableHighWaterMark, writableSizeAlgorithm);
  function pullAlgorithm() {
    return TransformStreamDefaultSourcePullAlgorithm(stream);
  }
  function cancelAlgorithm(reason) {
    TransformStreamErrorWritableAndUnblockWrite(stream, reason);
    return promiseResolvedWith(void 0);
  }
  stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark2, readableSizeAlgorithm);
  stream._backpressure = void 0;
  stream._backpressureChangePromise = void 0;
  stream._backpressureChangePromise_resolve = void 0;
  TransformStreamSetBackpressure(stream, true);
  stream._transformStreamController = void 0;
}
function IsTransformStream(x) {
  if (!typeIsObject(x)) {
    return false;
  }
  if (!Object.prototype.hasOwnProperty.call(x, "_transformStreamController")) {
    return false;
  }
  return x instanceof TransformStream;
}
function TransformStreamError(stream, e) {
  ReadableStreamDefaultControllerError(stream._readable._readableStreamController, e);
  TransformStreamErrorWritableAndUnblockWrite(stream, e);
}
function TransformStreamErrorWritableAndUnblockWrite(stream, e) {
  TransformStreamDefaultControllerClearAlgorithms(stream._transformStreamController);
  WritableStreamDefaultControllerErrorIfNeeded(stream._writable._writableStreamController, e);
  if (stream._backpressure) {
    TransformStreamSetBackpressure(stream, false);
  }
}
function TransformStreamSetBackpressure(stream, backpressure) {
  if (stream._backpressureChangePromise !== void 0) {
    stream._backpressureChangePromise_resolve();
  }
  stream._backpressureChangePromise = newPromise(function(resolve) {
    stream._backpressureChangePromise_resolve = resolve;
  });
  stream._backpressure = backpressure;
}
function IsTransformStreamDefaultController(x) {
  if (!typeIsObject(x)) {
    return false;
  }
  if (!Object.prototype.hasOwnProperty.call(x, "_controlledTransformStream")) {
    return false;
  }
  return x instanceof TransformStreamDefaultController;
}
function SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm) {
  controller._controlledTransformStream = stream;
  stream._transformStreamController = controller;
  controller._transformAlgorithm = transformAlgorithm;
  controller._flushAlgorithm = flushAlgorithm;
}
function SetUpTransformStreamDefaultControllerFromTransformer(stream, transformer) {
  var controller = Object.create(TransformStreamDefaultController.prototype);
  var transformAlgorithm = function(chunk) {
    try {
      TransformStreamDefaultControllerEnqueue(controller, chunk);
      return promiseResolvedWith(void 0);
    } catch (transformResultE) {
      return promiseRejectedWith(transformResultE);
    }
  };
  var flushAlgorithm = function() {
    return promiseResolvedWith(void 0);
  };
  if (transformer.transform !== void 0) {
    transformAlgorithm = function(chunk) {
      return transformer.transform(chunk, controller);
    };
  }
  if (transformer.flush !== void 0) {
    flushAlgorithm = function() {
      return transformer.flush(controller);
    };
  }
  SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm);
}
function TransformStreamDefaultControllerClearAlgorithms(controller) {
  controller._transformAlgorithm = void 0;
  controller._flushAlgorithm = void 0;
}
function TransformStreamDefaultControllerEnqueue(controller, chunk) {
  var stream = controller._controlledTransformStream;
  var readableController = stream._readable._readableStreamController;
  if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController)) {
    throw new TypeError("Readable side is not in a state that permits enqueue");
  }
  try {
    ReadableStreamDefaultControllerEnqueue(readableController, chunk);
  } catch (e) {
    TransformStreamErrorWritableAndUnblockWrite(stream, e);
    throw stream._readable._storedError;
  }
  var backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);
  if (backpressure !== stream._backpressure) {
    TransformStreamSetBackpressure(stream, true);
  }
}
function TransformStreamDefaultControllerError(controller, e) {
  TransformStreamError(controller._controlledTransformStream, e);
}
function TransformStreamDefaultControllerPerformTransform(controller, chunk) {
  var transformPromise = controller._transformAlgorithm(chunk);
  return transformPromiseWith(transformPromise, void 0, function(r) {
    TransformStreamError(controller._controlledTransformStream, r);
    throw r;
  });
}
function TransformStreamDefaultControllerTerminate(controller) {
  var stream = controller._controlledTransformStream;
  var readableController = stream._readable._readableStreamController;
  ReadableStreamDefaultControllerClose(readableController);
  var error = new TypeError("TransformStream terminated");
  TransformStreamErrorWritableAndUnblockWrite(stream, error);
}
function TransformStreamDefaultSinkWriteAlgorithm(stream, chunk) {
  var controller = stream._transformStreamController;
  if (stream._backpressure) {
    var backpressureChangePromise = stream._backpressureChangePromise;
    return transformPromiseWith(backpressureChangePromise, function() {
      var writable = stream._writable;
      var state = writable._state;
      if (state === "erroring") {
        throw writable._storedError;
      }
      return TransformStreamDefaultControllerPerformTransform(controller, chunk);
    });
  }
  return TransformStreamDefaultControllerPerformTransform(controller, chunk);
}
function TransformStreamDefaultSinkAbortAlgorithm(stream, reason) {
  TransformStreamError(stream, reason);
  return promiseResolvedWith(void 0);
}
function TransformStreamDefaultSinkCloseAlgorithm(stream) {
  var readable = stream._readable;
  var controller = stream._transformStreamController;
  var flushPromise = controller._flushAlgorithm();
  TransformStreamDefaultControllerClearAlgorithms(controller);
  return transformPromiseWith(flushPromise, function() {
    if (readable._state === "errored") {
      throw readable._storedError;
    }
    ReadableStreamDefaultControllerClose(readable._readableStreamController);
  }, function(r) {
    TransformStreamError(stream, r);
    throw readable._storedError;
  });
}
function TransformStreamDefaultSourcePullAlgorithm(stream) {
  TransformStreamSetBackpressure(stream, false);
  return stream._backpressureChangePromise;
}
function defaultControllerBrandCheckException(name5) {
  return new TypeError("TransformStreamDefaultController.prototype." + name5 + " can only be used on a TransformStreamDefaultController");
}
function streamBrandCheckException(name5) {
  return new TypeError("TransformStream.prototype." + name5 + " can only be used on a TransformStream");
}
var SymbolPolyfill, globals, rethrowAssertionErrorRejection, originalPromise, originalPromiseThen, originalPromiseResolve, originalPromiseReject, queueMicrotask, QUEUE_MAX_ARRAY_SIZE, SimpleQueue, AbortSteps, ErrorSteps, CancelSteps, PullSteps, NumberIsFinite, MathTrunc, ReadableStreamDefaultReader, _a, AsyncIteratorPrototype, ReadableStreamAsyncIteratorImpl, ReadableStreamAsyncIteratorPrototype, NumberIsNaN, ReadableStreamBYOBRequest, ReadableByteStreamController, ReadableStreamBYOBReader, supportsAbortController, WritableStream, WritableStreamDefaultWriter, closeSentinel, WritableStreamDefaultController, NativeDOMException, DOMException$1, ReadableStreamDefaultController, ReadableStream, byteLengthSizeFunction, ByteLengthQueuingStrategy, countSizeFunction, CountQueuingStrategy, TransformStream, TransformStreamDefaultController;
var init_ponyfill = __esm({
  "../../node_modules/.pnpm/web-streams-polyfill@3.2.1/node_modules/web-streams-polyfill/dist/ponyfill.mjs"() {
    "use strict";
    SymbolPolyfill = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol : function(description) {
      return "Symbol(" + description + ")";
    };
    globals = getGlobals();
    rethrowAssertionErrorRejection = noop2;
    originalPromise = Promise;
    originalPromiseThen = Promise.prototype.then;
    originalPromiseResolve = Promise.resolve.bind(originalPromise);
    originalPromiseReject = Promise.reject.bind(originalPromise);
    queueMicrotask = function() {
      var globalQueueMicrotask = globals && globals.queueMicrotask;
      if (typeof globalQueueMicrotask === "function") {
        return globalQueueMicrotask;
      }
      var resolvedPromise = promiseResolvedWith(void 0);
      return function(fn) {
        return PerformPromiseThen(resolvedPromise, fn);
      };
    }();
    QUEUE_MAX_ARRAY_SIZE = 16384;
    SimpleQueue = /** @class */
    function() {
      function SimpleQueue2() {
        this._cursor = 0;
        this._size = 0;
        this._front = {
          _elements: [],
          _next: void 0
        };
        this._back = this._front;
        this._cursor = 0;
        this._size = 0;
      }
      Object.defineProperty(SimpleQueue2.prototype, "length", {
        get: function() {
          return this._size;
        },
        enumerable: false,
        configurable: true
      });
      SimpleQueue2.prototype.push = function(element) {
        var oldBack = this._back;
        var newBack = oldBack;
        if (oldBack._elements.length === QUEUE_MAX_ARRAY_SIZE - 1) {
          newBack = {
            _elements: [],
            _next: void 0
          };
        }
        oldBack._elements.push(element);
        if (newBack !== oldBack) {
          this._back = newBack;
          oldBack._next = newBack;
        }
        ++this._size;
      };
      SimpleQueue2.prototype.shift = function() {
        var oldFront = this._front;
        var newFront = oldFront;
        var oldCursor = this._cursor;
        var newCursor = oldCursor + 1;
        var elements = oldFront._elements;
        var element = elements[oldCursor];
        if (newCursor === QUEUE_MAX_ARRAY_SIZE) {
          newFront = oldFront._next;
          newCursor = 0;
        }
        --this._size;
        this._cursor = newCursor;
        if (oldFront !== newFront) {
          this._front = newFront;
        }
        elements[oldCursor] = void 0;
        return element;
      };
      SimpleQueue2.prototype.forEach = function(callback) {
        var i = this._cursor;
        var node = this._front;
        var elements = node._elements;
        while (i !== elements.length || node._next !== void 0) {
          if (i === elements.length) {
            node = node._next;
            elements = node._elements;
            i = 0;
            if (elements.length === 0) {
              break;
            }
          }
          callback(elements[i]);
          ++i;
        }
      };
      SimpleQueue2.prototype.peek = function() {
        var front = this._front;
        var cursor = this._cursor;
        return front._elements[cursor];
      };
      return SimpleQueue2;
    }();
    AbortSteps = SymbolPolyfill("[[AbortSteps]]");
    ErrorSteps = SymbolPolyfill("[[ErrorSteps]]");
    CancelSteps = SymbolPolyfill("[[CancelSteps]]");
    PullSteps = SymbolPolyfill("[[PullSteps]]");
    NumberIsFinite = Number.isFinite || function(x) {
      return typeof x === "number" && isFinite(x);
    };
    MathTrunc = Math.trunc || function(v) {
      return v < 0 ? Math.ceil(v) : Math.floor(v);
    };
    ReadableStreamDefaultReader = /** @class */
    function() {
      function ReadableStreamDefaultReader3(stream) {
        assertRequiredArgument(stream, 1, "ReadableStreamDefaultReader");
        assertReadableStream(stream, "First parameter");
        if (IsReadableStreamLocked(stream)) {
          throw new TypeError("This stream has already been locked for exclusive reading by another reader");
        }
        ReadableStreamReaderGenericInitialize(this, stream);
        this._readRequests = new SimpleQueue();
      }
      Object.defineProperty(ReadableStreamDefaultReader3.prototype, "closed", {
        /**
         * Returns a promise that will be fulfilled when the stream becomes closed,
         * or rejected if the stream ever errors or the reader's lock is released before the stream finishes closing.
         */
        get: function() {
          if (!IsReadableStreamDefaultReader(this)) {
            return promiseRejectedWith(defaultReaderBrandCheckException("closed"));
          }
          return this._closedPromise;
        },
        enumerable: false,
        configurable: true
      });
      ReadableStreamDefaultReader3.prototype.cancel = function(reason) {
        if (reason === void 0) {
          reason = void 0;
        }
        if (!IsReadableStreamDefaultReader(this)) {
          return promiseRejectedWith(defaultReaderBrandCheckException("cancel"));
        }
        if (this._ownerReadableStream === void 0) {
          return promiseRejectedWith(readerLockException("cancel"));
        }
        return ReadableStreamReaderGenericCancel(this, reason);
      };
      ReadableStreamDefaultReader3.prototype.read = function() {
        if (!IsReadableStreamDefaultReader(this)) {
          return promiseRejectedWith(defaultReaderBrandCheckException("read"));
        }
        if (this._ownerReadableStream === void 0) {
          return promiseRejectedWith(readerLockException("read from"));
        }
        var resolvePromise;
        var rejectPromise;
        var promise = newPromise(function(resolve, reject) {
          resolvePromise = resolve;
          rejectPromise = reject;
        });
        var readRequest = {
          _chunkSteps: function(chunk) {
            return resolvePromise({ value: chunk, done: false });
          },
          _closeSteps: function() {
            return resolvePromise({ value: void 0, done: true });
          },
          _errorSteps: function(e) {
            return rejectPromise(e);
          }
        };
        ReadableStreamDefaultReaderRead(this, readRequest);
        return promise;
      };
      ReadableStreamDefaultReader3.prototype.releaseLock = function() {
        if (!IsReadableStreamDefaultReader(this)) {
          throw defaultReaderBrandCheckException("releaseLock");
        }
        if (this._ownerReadableStream === void 0) {
          return;
        }
        if (this._readRequests.length > 0) {
          throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");
        }
        ReadableStreamReaderGenericRelease(this);
      };
      return ReadableStreamDefaultReader3;
    }();
    Object.defineProperties(ReadableStreamDefaultReader.prototype, {
      cancel: { enumerable: true },
      read: { enumerable: true },
      releaseLock: { enumerable: true },
      closed: { enumerable: true }
    });
    if (typeof SymbolPolyfill.toStringTag === "symbol") {
      Object.defineProperty(ReadableStreamDefaultReader.prototype, SymbolPolyfill.toStringTag, {
        value: "ReadableStreamDefaultReader",
        configurable: true
      });
    }
    if (typeof SymbolPolyfill.asyncIterator === "symbol") {
      AsyncIteratorPrototype = (_a = {}, // 25.1.3.1 %AsyncIteratorPrototype% [ @@asyncIterator ] ( )
      // https://tc39.github.io/ecma262/#sec-asynciteratorprototype-asynciterator
      _a[SymbolPolyfill.asyncIterator] = function() {
        return this;
      }, _a);
      Object.defineProperty(AsyncIteratorPrototype, SymbolPolyfill.asyncIterator, { enumerable: false });
    }
    ReadableStreamAsyncIteratorImpl = /** @class */
    function() {
      function ReadableStreamAsyncIteratorImpl2(reader, preventCancel) {
        this._ongoingPromise = void 0;
        this._isFinished = false;
        this._reader = reader;
        this._preventCancel = preventCancel;
      }
      ReadableStreamAsyncIteratorImpl2.prototype.next = function() {
        var _this = this;
        var nextSteps = function() {
          return _this._nextSteps();
        };
        this._ongoingPromise = this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, nextSteps, nextSteps) : nextSteps();
        return this._ongoingPromise;
      };
      ReadableStreamAsyncIteratorImpl2.prototype.return = function(value) {
        var _this = this;
        var returnSteps = function() {
          return _this._returnSteps(value);
        };
        return this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, returnSteps, returnSteps) : returnSteps();
      };
      ReadableStreamAsyncIteratorImpl2.prototype._nextSteps = function() {
        var _this = this;
        if (this._isFinished) {
          return Promise.resolve({ value: void 0, done: true });
        }
        var reader = this._reader;
        if (reader._ownerReadableStream === void 0) {
          return promiseRejectedWith(readerLockException("iterate"));
        }
        var resolvePromise;
        var rejectPromise;
        var promise = newPromise(function(resolve, reject) {
          resolvePromise = resolve;
          rejectPromise = reject;
        });
        var readRequest = {
          _chunkSteps: function(chunk) {
            _this._ongoingPromise = void 0;
            queueMicrotask(function() {
              return resolvePromise({ value: chunk, done: false });
            });
          },
          _closeSteps: function() {
            _this._ongoingPromise = void 0;
            _this._isFinished = true;
            ReadableStreamReaderGenericRelease(reader);
            resolvePromise({ value: void 0, done: true });
          },
          _errorSteps: function(reason) {
            _this._ongoingPromise = void 0;
            _this._isFinished = true;
            ReadableStreamReaderGenericRelease(reader);
            rejectPromise(reason);
          }
        };
        ReadableStreamDefaultReaderRead(reader, readRequest);
        return promise;
      };
      ReadableStreamAsyncIteratorImpl2.prototype._returnSteps = function(value) {
        if (this._isFinished) {
          return Promise.resolve({ value, done: true });
        }
        this._isFinished = true;
        var reader = this._reader;
        if (reader._ownerReadableStream === void 0) {
          return promiseRejectedWith(readerLockException("finish iterating"));
        }
        if (!this._preventCancel) {
          var result = ReadableStreamReaderGenericCancel(reader, value);
          ReadableStreamReaderGenericRelease(reader);
          return transformPromiseWith(result, function() {
            return { value, done: true };
          });
        }
        ReadableStreamReaderGenericRelease(reader);
        return promiseResolvedWith({ value, done: true });
      };
      return ReadableStreamAsyncIteratorImpl2;
    }();
    ReadableStreamAsyncIteratorPrototype = {
      next: function() {
        if (!IsReadableStreamAsyncIterator(this)) {
          return promiseRejectedWith(streamAsyncIteratorBrandCheckException("next"));
        }
        return this._asyncIteratorImpl.next();
      },
      return: function(value) {
        if (!IsReadableStreamAsyncIterator(this)) {
          return promiseRejectedWith(streamAsyncIteratorBrandCheckException("return"));
        }
        return this._asyncIteratorImpl.return(value);
      }
    };
    if (AsyncIteratorPrototype !== void 0) {
      Object.setPrototypeOf(ReadableStreamAsyncIteratorPrototype, AsyncIteratorPrototype);
    }
    NumberIsNaN = Number.isNaN || function(x) {
      return x !== x;
    };
    ReadableStreamBYOBRequest = /** @class */
    function() {
      function ReadableStreamBYOBRequest3() {
        throw new TypeError("Illegal constructor");
      }
      Object.defineProperty(ReadableStreamBYOBRequest3.prototype, "view", {
        /**
         * Returns the view for writing in to, or `null` if the BYOB request has already been responded to.
         */
        get: function() {
          if (!IsReadableStreamBYOBRequest(this)) {
            throw byobRequestBrandCheckException("view");
          }
          return this._view;
        },
        enumerable: false,
        configurable: true
      });
      ReadableStreamBYOBRequest3.prototype.respond = function(bytesWritten) {
        if (!IsReadableStreamBYOBRequest(this)) {
          throw byobRequestBrandCheckException("respond");
        }
        assertRequiredArgument(bytesWritten, 1, "respond");
        bytesWritten = convertUnsignedLongLongWithEnforceRange(bytesWritten, "First parameter");
        if (this._associatedReadableByteStreamController === void 0) {
          throw new TypeError("This BYOB request has been invalidated");
        }
        if (IsDetachedBuffer(this._view.buffer))
          ;
        ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);
      };
      ReadableStreamBYOBRequest3.prototype.respondWithNewView = function(view) {
        if (!IsReadableStreamBYOBRequest(this)) {
          throw byobRequestBrandCheckException("respondWithNewView");
        }
        assertRequiredArgument(view, 1, "respondWithNewView");
        if (!ArrayBuffer.isView(view)) {
          throw new TypeError("You can only respond with array buffer views");
        }
        if (this._associatedReadableByteStreamController === void 0) {
          throw new TypeError("This BYOB request has been invalidated");
        }
        if (IsDetachedBuffer(view.buffer))
          ;
        ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);
      };
      return ReadableStreamBYOBRequest3;
    }();
    Object.defineProperties(ReadableStreamBYOBRequest.prototype, {
      respond: { enumerable: true },
      respondWithNewView: { enumerable: true },
      view: { enumerable: true }
    });
    if (typeof SymbolPolyfill.toStringTag === "symbol") {
      Object.defineProperty(ReadableStreamBYOBRequest.prototype, SymbolPolyfill.toStringTag, {
        value: "ReadableStreamBYOBRequest",
        configurable: true
      });
    }
    ReadableByteStreamController = /** @class */
    function() {
      function ReadableByteStreamController3() {
        throw new TypeError("Illegal constructor");
      }
      Object.defineProperty(ReadableByteStreamController3.prototype, "byobRequest", {
        /**
         * Returns the current BYOB pull request, or `null` if there isn't one.
         */
        get: function() {
          if (!IsReadableByteStreamController(this)) {
            throw byteStreamControllerBrandCheckException("byobRequest");
          }
          return ReadableByteStreamControllerGetBYOBRequest(this);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ReadableByteStreamController3.prototype, "desiredSize", {
        /**
         * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is
         * over-full. An underlying byte source ought to use this information to determine when and how to apply backpressure.
         */
        get: function() {
          if (!IsReadableByteStreamController(this)) {
            throw byteStreamControllerBrandCheckException("desiredSize");
          }
          return ReadableByteStreamControllerGetDesiredSize(this);
        },
        enumerable: false,
        configurable: true
      });
      ReadableByteStreamController3.prototype.close = function() {
        if (!IsReadableByteStreamController(this)) {
          throw byteStreamControllerBrandCheckException("close");
        }
        if (this._closeRequested) {
          throw new TypeError("The stream has already been closed; do not close it again!");
        }
        var state = this._controlledReadableByteStream._state;
        if (state !== "readable") {
          throw new TypeError("The stream (in " + state + " state) is not in the readable state and cannot be closed");
        }
        ReadableByteStreamControllerClose(this);
      };
      ReadableByteStreamController3.prototype.enqueue = function(chunk) {
        if (!IsReadableByteStreamController(this)) {
          throw byteStreamControllerBrandCheckException("enqueue");
        }
        assertRequiredArgument(chunk, 1, "enqueue");
        if (!ArrayBuffer.isView(chunk)) {
          throw new TypeError("chunk must be an array buffer view");
        }
        if (chunk.byteLength === 0) {
          throw new TypeError("chunk must have non-zero byteLength");
        }
        if (chunk.buffer.byteLength === 0) {
          throw new TypeError("chunk's buffer must have non-zero byteLength");
        }
        if (this._closeRequested) {
          throw new TypeError("stream is closed or draining");
        }
        var state = this._controlledReadableByteStream._state;
        if (state !== "readable") {
          throw new TypeError("The stream (in " + state + " state) is not in the readable state and cannot be enqueued to");
        }
        ReadableByteStreamControllerEnqueue(this, chunk);
      };
      ReadableByteStreamController3.prototype.error = function(e) {
        if (e === void 0) {
          e = void 0;
        }
        if (!IsReadableByteStreamController(this)) {
          throw byteStreamControllerBrandCheckException("error");
        }
        ReadableByteStreamControllerError(this, e);
      };
      ReadableByteStreamController3.prototype[CancelSteps] = function(reason) {
        ReadableByteStreamControllerClearPendingPullIntos(this);
        ResetQueue(this);
        var result = this._cancelAlgorithm(reason);
        ReadableByteStreamControllerClearAlgorithms(this);
        return result;
      };
      ReadableByteStreamController3.prototype[PullSteps] = function(readRequest) {
        var stream = this._controlledReadableByteStream;
        if (this._queueTotalSize > 0) {
          var entry = this._queue.shift();
          this._queueTotalSize -= entry.byteLength;
          ReadableByteStreamControllerHandleQueueDrain(this);
          var view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);
          readRequest._chunkSteps(view);
          return;
        }
        var autoAllocateChunkSize = this._autoAllocateChunkSize;
        if (autoAllocateChunkSize !== void 0) {
          var buffer2 = void 0;
          try {
            buffer2 = new ArrayBuffer(autoAllocateChunkSize);
          } catch (bufferE) {
            readRequest._errorSteps(bufferE);
            return;
          }
          var pullIntoDescriptor = {
            buffer: buffer2,
            bufferByteLength: autoAllocateChunkSize,
            byteOffset: 0,
            byteLength: autoAllocateChunkSize,
            bytesFilled: 0,
            elementSize: 1,
            viewConstructor: Uint8Array,
            readerType: "default"
          };
          this._pendingPullIntos.push(pullIntoDescriptor);
        }
        ReadableStreamAddReadRequest(stream, readRequest);
        ReadableByteStreamControllerCallPullIfNeeded(this);
      };
      return ReadableByteStreamController3;
    }();
    Object.defineProperties(ReadableByteStreamController.prototype, {
      close: { enumerable: true },
      enqueue: { enumerable: true },
      error: { enumerable: true },
      byobRequest: { enumerable: true },
      desiredSize: { enumerable: true }
    });
    if (typeof SymbolPolyfill.toStringTag === "symbol") {
      Object.defineProperty(ReadableByteStreamController.prototype, SymbolPolyfill.toStringTag, {
        value: "ReadableByteStreamController",
        configurable: true
      });
    }
    ReadableStreamBYOBReader = /** @class */
    function() {
      function ReadableStreamBYOBReader3(stream) {
        assertRequiredArgument(stream, 1, "ReadableStreamBYOBReader");
        assertReadableStream(stream, "First parameter");
        if (IsReadableStreamLocked(stream)) {
          throw new TypeError("This stream has already been locked for exclusive reading by another reader");
        }
        if (!IsReadableByteStreamController(stream._readableStreamController)) {
          throw new TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source");
        }
        ReadableStreamReaderGenericInitialize(this, stream);
        this._readIntoRequests = new SimpleQueue();
      }
      Object.defineProperty(ReadableStreamBYOBReader3.prototype, "closed", {
        /**
         * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or
         * the reader's lock is released before the stream finishes closing.
         */
        get: function() {
          if (!IsReadableStreamBYOBReader(this)) {
            return promiseRejectedWith(byobReaderBrandCheckException("closed"));
          }
          return this._closedPromise;
        },
        enumerable: false,
        configurable: true
      });
      ReadableStreamBYOBReader3.prototype.cancel = function(reason) {
        if (reason === void 0) {
          reason = void 0;
        }
        if (!IsReadableStreamBYOBReader(this)) {
          return promiseRejectedWith(byobReaderBrandCheckException("cancel"));
        }
        if (this._ownerReadableStream === void 0) {
          return promiseRejectedWith(readerLockException("cancel"));
        }
        return ReadableStreamReaderGenericCancel(this, reason);
      };
      ReadableStreamBYOBReader3.prototype.read = function(view) {
        if (!IsReadableStreamBYOBReader(this)) {
          return promiseRejectedWith(byobReaderBrandCheckException("read"));
        }
        if (!ArrayBuffer.isView(view)) {
          return promiseRejectedWith(new TypeError("view must be an array buffer view"));
        }
        if (view.byteLength === 0) {
          return promiseRejectedWith(new TypeError("view must have non-zero byteLength"));
        }
        if (view.buffer.byteLength === 0) {
          return promiseRejectedWith(new TypeError("view's buffer must have non-zero byteLength"));
        }
        if (IsDetachedBuffer(view.buffer))
          ;
        if (this._ownerReadableStream === void 0) {
          return promiseRejectedWith(readerLockException("read from"));
        }
        var resolvePromise;
        var rejectPromise;
        var promise = newPromise(function(resolve, reject) {
          resolvePromise = resolve;
          rejectPromise = reject;
        });
        var readIntoRequest = {
          _chunkSteps: function(chunk) {
            return resolvePromise({ value: chunk, done: false });
          },
          _closeSteps: function(chunk) {
            return resolvePromise({ value: chunk, done: true });
          },
          _errorSteps: function(e) {
            return rejectPromise(e);
          }
        };
        ReadableStreamBYOBReaderRead(this, view, readIntoRequest);
        return promise;
      };
      ReadableStreamBYOBReader3.prototype.releaseLock = function() {
        if (!IsReadableStreamBYOBReader(this)) {
          throw byobReaderBrandCheckException("releaseLock");
        }
        if (this._ownerReadableStream === void 0) {
          return;
        }
        if (this._readIntoRequests.length > 0) {
          throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");
        }
        ReadableStreamReaderGenericRelease(this);
      };
      return ReadableStreamBYOBReader3;
    }();
    Object.defineProperties(ReadableStreamBYOBReader.prototype, {
      cancel: { enumerable: true },
      read: { enumerable: true },
      releaseLock: { enumerable: true },
      closed: { enumerable: true }
    });
    if (typeof SymbolPolyfill.toStringTag === "symbol") {
      Object.defineProperty(ReadableStreamBYOBReader.prototype, SymbolPolyfill.toStringTag, {
        value: "ReadableStreamBYOBReader",
        configurable: true
      });
    }
    supportsAbortController = typeof AbortController === "function";
    WritableStream = /** @class */
    function() {
      function WritableStream3(rawUnderlyingSink, rawStrategy) {
        if (rawUnderlyingSink === void 0) {
          rawUnderlyingSink = {};
        }
        if (rawStrategy === void 0) {
          rawStrategy = {};
        }
        if (rawUnderlyingSink === void 0) {
          rawUnderlyingSink = null;
        } else {
          assertObject(rawUnderlyingSink, "First parameter");
        }
        var strategy = convertQueuingStrategy(rawStrategy, "Second parameter");
        var underlyingSink = convertUnderlyingSink(rawUnderlyingSink, "First parameter");
        InitializeWritableStream(this);
        var type = underlyingSink.type;
        if (type !== void 0) {
          throw new RangeError("Invalid type is specified");
        }
        var sizeAlgorithm = ExtractSizeAlgorithm(strategy);
        var highWaterMark = ExtractHighWaterMark(strategy, 1);
        SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);
      }
      Object.defineProperty(WritableStream3.prototype, "locked", {
        /**
         * Returns whether or not the writable stream is locked to a writer.
         */
        get: function() {
          if (!IsWritableStream(this)) {
            throw streamBrandCheckException$2("locked");
          }
          return IsWritableStreamLocked(this);
        },
        enumerable: false,
        configurable: true
      });
      WritableStream3.prototype.abort = function(reason) {
        if (reason === void 0) {
          reason = void 0;
        }
        if (!IsWritableStream(this)) {
          return promiseRejectedWith(streamBrandCheckException$2("abort"));
        }
        if (IsWritableStreamLocked(this)) {
          return promiseRejectedWith(new TypeError("Cannot abort a stream that already has a writer"));
        }
        return WritableStreamAbort(this, reason);
      };
      WritableStream3.prototype.close = function() {
        if (!IsWritableStream(this)) {
          return promiseRejectedWith(streamBrandCheckException$2("close"));
        }
        if (IsWritableStreamLocked(this)) {
          return promiseRejectedWith(new TypeError("Cannot close a stream that already has a writer"));
        }
        if (WritableStreamCloseQueuedOrInFlight(this)) {
          return promiseRejectedWith(new TypeError("Cannot close an already-closing stream"));
        }
        return WritableStreamClose(this);
      };
      WritableStream3.prototype.getWriter = function() {
        if (!IsWritableStream(this)) {
          throw streamBrandCheckException$2("getWriter");
        }
        return AcquireWritableStreamDefaultWriter(this);
      };
      return WritableStream3;
    }();
    Object.defineProperties(WritableStream.prototype, {
      abort: { enumerable: true },
      close: { enumerable: true },
      getWriter: { enumerable: true },
      locked: { enumerable: true }
    });
    if (typeof SymbolPolyfill.toStringTag === "symbol") {
      Object.defineProperty(WritableStream.prototype, SymbolPolyfill.toStringTag, {
        value: "WritableStream",
        configurable: true
      });
    }
    WritableStreamDefaultWriter = /** @class */
    function() {
      function WritableStreamDefaultWriter3(stream) {
        assertRequiredArgument(stream, 1, "WritableStreamDefaultWriter");
        assertWritableStream(stream, "First parameter");
        if (IsWritableStreamLocked(stream)) {
          throw new TypeError("This stream has already been locked for exclusive writing by another writer");
        }
        this._ownerWritableStream = stream;
        stream._writer = this;
        var state = stream._state;
        if (state === "writable") {
          if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._backpressure) {
            defaultWriterReadyPromiseInitialize(this);
          } else {
            defaultWriterReadyPromiseInitializeAsResolved(this);
          }
          defaultWriterClosedPromiseInitialize(this);
        } else if (state === "erroring") {
          defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError);
          defaultWriterClosedPromiseInitialize(this);
        } else if (state === "closed") {
          defaultWriterReadyPromiseInitializeAsResolved(this);
          defaultWriterClosedPromiseInitializeAsResolved(this);
        } else {
          var storedError = stream._storedError;
          defaultWriterReadyPromiseInitializeAsRejected(this, storedError);
          defaultWriterClosedPromiseInitializeAsRejected(this, storedError);
        }
      }
      Object.defineProperty(WritableStreamDefaultWriter3.prototype, "closed", {
        /**
         * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or
         * the writer’s lock is released before the stream finishes closing.
         */
        get: function() {
          if (!IsWritableStreamDefaultWriter(this)) {
            return promiseRejectedWith(defaultWriterBrandCheckException("closed"));
          }
          return this._closedPromise;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(WritableStreamDefaultWriter3.prototype, "desiredSize", {
        /**
         * Returns the desired size to fill the stream’s internal queue. It can be negative, if the queue is over-full.
         * A producer can use this information to determine the right amount of data to write.
         *
         * It will be `null` if the stream cannot be successfully written to (due to either being errored, or having an abort
         * queued up). It will return zero if the stream is closed. And the getter will throw an exception if invoked when
         * the writer’s lock is released.
         */
        get: function() {
          if (!IsWritableStreamDefaultWriter(this)) {
            throw defaultWriterBrandCheckException("desiredSize");
          }
          if (this._ownerWritableStream === void 0) {
            throw defaultWriterLockException("desiredSize");
          }
          return WritableStreamDefaultWriterGetDesiredSize(this);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(WritableStreamDefaultWriter3.prototype, "ready", {
        /**
         * Returns a promise that will be fulfilled when the desired size to fill the stream’s internal queue transitions
         * from non-positive to positive, signaling that it is no longer applying backpressure. Once the desired size dips
         * back to zero or below, the getter will return a new promise that stays pending until the next transition.
         *
         * If the stream becomes errored or aborted, or the writer’s lock is released, the returned promise will become
         * rejected.
         */
        get: function() {
          if (!IsWritableStreamDefaultWriter(this)) {
            return promiseRejectedWith(defaultWriterBrandCheckException("ready"));
          }
          return this._readyPromise;
        },
        enumerable: false,
        configurable: true
      });
      WritableStreamDefaultWriter3.prototype.abort = function(reason) {
        if (reason === void 0) {
          reason = void 0;
        }
        if (!IsWritableStreamDefaultWriter(this)) {
          return promiseRejectedWith(defaultWriterBrandCheckException("abort"));
        }
        if (this._ownerWritableStream === void 0) {
          return promiseRejectedWith(defaultWriterLockException("abort"));
        }
        return WritableStreamDefaultWriterAbort(this, reason);
      };
      WritableStreamDefaultWriter3.prototype.close = function() {
        if (!IsWritableStreamDefaultWriter(this)) {
          return promiseRejectedWith(defaultWriterBrandCheckException("close"));
        }
        var stream = this._ownerWritableStream;
        if (stream === void 0) {
          return promiseRejectedWith(defaultWriterLockException("close"));
        }
        if (WritableStreamCloseQueuedOrInFlight(stream)) {
          return promiseRejectedWith(new TypeError("Cannot close an already-closing stream"));
        }
        return WritableStreamDefaultWriterClose(this);
      };
      WritableStreamDefaultWriter3.prototype.releaseLock = function() {
        if (!IsWritableStreamDefaultWriter(this)) {
          throw defaultWriterBrandCheckException("releaseLock");
        }
        var stream = this._ownerWritableStream;
        if (stream === void 0) {
          return;
        }
        WritableStreamDefaultWriterRelease(this);
      };
      WritableStreamDefaultWriter3.prototype.write = function(chunk) {
        if (chunk === void 0) {
          chunk = void 0;
        }
        if (!IsWritableStreamDefaultWriter(this)) {
          return promiseRejectedWith(defaultWriterBrandCheckException("write"));
        }
        if (this._ownerWritableStream === void 0) {
          return promiseRejectedWith(defaultWriterLockException("write to"));
        }
        return WritableStreamDefaultWriterWrite(this, chunk);
      };
      return WritableStreamDefaultWriter3;
    }();
    Object.defineProperties(WritableStreamDefaultWriter.prototype, {
      abort: { enumerable: true },
      close: { enumerable: true },
      releaseLock: { enumerable: true },
      write: { enumerable: true },
      closed: { enumerable: true },
      desiredSize: { enumerable: true },
      ready: { enumerable: true }
    });
    if (typeof SymbolPolyfill.toStringTag === "symbol") {
      Object.defineProperty(WritableStreamDefaultWriter.prototype, SymbolPolyfill.toStringTag, {
        value: "WritableStreamDefaultWriter",
        configurable: true
      });
    }
    closeSentinel = {};
    WritableStreamDefaultController = /** @class */
    function() {
      function WritableStreamDefaultController3() {
        throw new TypeError("Illegal constructor");
      }
      Object.defineProperty(WritableStreamDefaultController3.prototype, "abortReason", {
        /**
         * The reason which was passed to `WritableStream.abort(reason)` when the stream was aborted.
         *
         * @deprecated
         *  This property has been removed from the specification, see https://github.com/whatwg/streams/pull/1177.
         *  Use {@link WritableStreamDefaultController.signal}'s `reason` instead.
         */
        get: function() {
          if (!IsWritableStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException$2("abortReason");
          }
          return this._abortReason;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(WritableStreamDefaultController3.prototype, "signal", {
        /**
         * An `AbortSignal` that can be used to abort the pending write or close operation when the stream is aborted.
         */
        get: function() {
          if (!IsWritableStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException$2("signal");
          }
          if (this._abortController === void 0) {
            throw new TypeError("WritableStreamDefaultController.prototype.signal is not supported");
          }
          return this._abortController.signal;
        },
        enumerable: false,
        configurable: true
      });
      WritableStreamDefaultController3.prototype.error = function(e) {
        if (e === void 0) {
          e = void 0;
        }
        if (!IsWritableStreamDefaultController(this)) {
          throw defaultControllerBrandCheckException$2("error");
        }
        var state = this._controlledWritableStream._state;
        if (state !== "writable") {
          return;
        }
        WritableStreamDefaultControllerError(this, e);
      };
      WritableStreamDefaultController3.prototype[AbortSteps] = function(reason) {
        var result = this._abortAlgorithm(reason);
        WritableStreamDefaultControllerClearAlgorithms(this);
        return result;
      };
      WritableStreamDefaultController3.prototype[ErrorSteps] = function() {
        ResetQueue(this);
      };
      return WritableStreamDefaultController3;
    }();
    Object.defineProperties(WritableStreamDefaultController.prototype, {
      abortReason: { enumerable: true },
      signal: { enumerable: true },
      error: { enumerable: true }
    });
    if (typeof SymbolPolyfill.toStringTag === "symbol") {
      Object.defineProperty(WritableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
        value: "WritableStreamDefaultController",
        configurable: true
      });
    }
    NativeDOMException = typeof DOMException !== "undefined" ? DOMException : void 0;
    DOMException$1 = isDOMExceptionConstructor(NativeDOMException) ? NativeDOMException : createDOMExceptionPolyfill();
    ReadableStreamDefaultController = /** @class */
    function() {
      function ReadableStreamDefaultController3() {
        throw new TypeError("Illegal constructor");
      }
      Object.defineProperty(ReadableStreamDefaultController3.prototype, "desiredSize", {
        /**
         * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is
         * over-full. An underlying source ought to use this information to determine when and how to apply backpressure.
         */
        get: function() {
          if (!IsReadableStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException$1("desiredSize");
          }
          return ReadableStreamDefaultControllerGetDesiredSize(this);
        },
        enumerable: false,
        configurable: true
      });
      ReadableStreamDefaultController3.prototype.close = function() {
        if (!IsReadableStreamDefaultController(this)) {
          throw defaultControllerBrandCheckException$1("close");
        }
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
          throw new TypeError("The stream is not in a state that permits close");
        }
        ReadableStreamDefaultControllerClose(this);
      };
      ReadableStreamDefaultController3.prototype.enqueue = function(chunk) {
        if (chunk === void 0) {
          chunk = void 0;
        }
        if (!IsReadableStreamDefaultController(this)) {
          throw defaultControllerBrandCheckException$1("enqueue");
        }
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
          throw new TypeError("The stream is not in a state that permits enqueue");
        }
        return ReadableStreamDefaultControllerEnqueue(this, chunk);
      };
      ReadableStreamDefaultController3.prototype.error = function(e) {
        if (e === void 0) {
          e = void 0;
        }
        if (!IsReadableStreamDefaultController(this)) {
          throw defaultControllerBrandCheckException$1("error");
        }
        ReadableStreamDefaultControllerError(this, e);
      };
      ReadableStreamDefaultController3.prototype[CancelSteps] = function(reason) {
        ResetQueue(this);
        var result = this._cancelAlgorithm(reason);
        ReadableStreamDefaultControllerClearAlgorithms(this);
        return result;
      };
      ReadableStreamDefaultController3.prototype[PullSteps] = function(readRequest) {
        var stream = this._controlledReadableStream;
        if (this._queue.length > 0) {
          var chunk = DequeueValue(this);
          if (this._closeRequested && this._queue.length === 0) {
            ReadableStreamDefaultControllerClearAlgorithms(this);
            ReadableStreamClose(stream);
          } else {
            ReadableStreamDefaultControllerCallPullIfNeeded(this);
          }
          readRequest._chunkSteps(chunk);
        } else {
          ReadableStreamAddReadRequest(stream, readRequest);
          ReadableStreamDefaultControllerCallPullIfNeeded(this);
        }
      };
      return ReadableStreamDefaultController3;
    }();
    Object.defineProperties(ReadableStreamDefaultController.prototype, {
      close: { enumerable: true },
      enqueue: { enumerable: true },
      error: { enumerable: true },
      desiredSize: { enumerable: true }
    });
    if (typeof SymbolPolyfill.toStringTag === "symbol") {
      Object.defineProperty(ReadableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
        value: "ReadableStreamDefaultController",
        configurable: true
      });
    }
    ReadableStream = /** @class */
    function() {
      function ReadableStream3(rawUnderlyingSource, rawStrategy) {
        if (rawUnderlyingSource === void 0) {
          rawUnderlyingSource = {};
        }
        if (rawStrategy === void 0) {
          rawStrategy = {};
        }
        if (rawUnderlyingSource === void 0) {
          rawUnderlyingSource = null;
        } else {
          assertObject(rawUnderlyingSource, "First parameter");
        }
        var strategy = convertQueuingStrategy(rawStrategy, "Second parameter");
        var underlyingSource = convertUnderlyingDefaultOrByteSource(rawUnderlyingSource, "First parameter");
        InitializeReadableStream(this);
        if (underlyingSource.type === "bytes") {
          if (strategy.size !== void 0) {
            throw new RangeError("The strategy for a byte stream cannot have a size function");
          }
          var highWaterMark = ExtractHighWaterMark(strategy, 0);
          SetUpReadableByteStreamControllerFromUnderlyingSource(this, underlyingSource, highWaterMark);
        } else {
          var sizeAlgorithm = ExtractSizeAlgorithm(strategy);
          var highWaterMark = ExtractHighWaterMark(strategy, 1);
          SetUpReadableStreamDefaultControllerFromUnderlyingSource(this, underlyingSource, highWaterMark, sizeAlgorithm);
        }
      }
      Object.defineProperty(ReadableStream3.prototype, "locked", {
        /**
         * Whether or not the readable stream is locked to a {@link ReadableStreamDefaultReader | reader}.
         */
        get: function() {
          if (!IsReadableStream(this)) {
            throw streamBrandCheckException$1("locked");
          }
          return IsReadableStreamLocked(this);
        },
        enumerable: false,
        configurable: true
      });
      ReadableStream3.prototype.cancel = function(reason) {
        if (reason === void 0) {
          reason = void 0;
        }
        if (!IsReadableStream(this)) {
          return promiseRejectedWith(streamBrandCheckException$1("cancel"));
        }
        if (IsReadableStreamLocked(this)) {
          return promiseRejectedWith(new TypeError("Cannot cancel a stream that already has a reader"));
        }
        return ReadableStreamCancel(this, reason);
      };
      ReadableStream3.prototype.getReader = function(rawOptions) {
        if (rawOptions === void 0) {
          rawOptions = void 0;
        }
        if (!IsReadableStream(this)) {
          throw streamBrandCheckException$1("getReader");
        }
        var options = convertReaderOptions(rawOptions, "First parameter");
        if (options.mode === void 0) {
          return AcquireReadableStreamDefaultReader(this);
        }
        return AcquireReadableStreamBYOBReader(this);
      };
      ReadableStream3.prototype.pipeThrough = function(rawTransform, rawOptions) {
        if (rawOptions === void 0) {
          rawOptions = {};
        }
        if (!IsReadableStream(this)) {
          throw streamBrandCheckException$1("pipeThrough");
        }
        assertRequiredArgument(rawTransform, 1, "pipeThrough");
        var transform2 = convertReadableWritablePair(rawTransform, "First parameter");
        var options = convertPipeOptions(rawOptions, "Second parameter");
        if (IsReadableStreamLocked(this)) {
          throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream");
        }
        if (IsWritableStreamLocked(transform2.writable)) {
          throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream");
        }
        var promise = ReadableStreamPipeTo(this, transform2.writable, options.preventClose, options.preventAbort, options.preventCancel, options.signal);
        setPromiseIsHandledToTrue(promise);
        return transform2.readable;
      };
      ReadableStream3.prototype.pipeTo = function(destination, rawOptions) {
        if (rawOptions === void 0) {
          rawOptions = {};
        }
        if (!IsReadableStream(this)) {
          return promiseRejectedWith(streamBrandCheckException$1("pipeTo"));
        }
        if (destination === void 0) {
          return promiseRejectedWith("Parameter 1 is required in 'pipeTo'.");
        }
        if (!IsWritableStream(destination)) {
          return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo's first argument must be a WritableStream"));
        }
        var options;
        try {
          options = convertPipeOptions(rawOptions, "Second parameter");
        } catch (e) {
          return promiseRejectedWith(e);
        }
        if (IsReadableStreamLocked(this)) {
          return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream"));
        }
        if (IsWritableStreamLocked(destination)) {
          return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream"));
        }
        return ReadableStreamPipeTo(this, destination, options.preventClose, options.preventAbort, options.preventCancel, options.signal);
      };
      ReadableStream3.prototype.tee = function() {
        if (!IsReadableStream(this)) {
          throw streamBrandCheckException$1("tee");
        }
        var branches = ReadableStreamTee(this);
        return CreateArrayFromList(branches);
      };
      ReadableStream3.prototype.values = function(rawOptions) {
        if (rawOptions === void 0) {
          rawOptions = void 0;
        }
        if (!IsReadableStream(this)) {
          throw streamBrandCheckException$1("values");
        }
        var options = convertIteratorOptions(rawOptions, "First parameter");
        return AcquireReadableStreamAsyncIterator(this, options.preventCancel);
      };
      return ReadableStream3;
    }();
    Object.defineProperties(ReadableStream.prototype, {
      cancel: { enumerable: true },
      getReader: { enumerable: true },
      pipeThrough: { enumerable: true },
      pipeTo: { enumerable: true },
      tee: { enumerable: true },
      values: { enumerable: true },
      locked: { enumerable: true }
    });
    if (typeof SymbolPolyfill.toStringTag === "symbol") {
      Object.defineProperty(ReadableStream.prototype, SymbolPolyfill.toStringTag, {
        value: "ReadableStream",
        configurable: true
      });
    }
    if (typeof SymbolPolyfill.asyncIterator === "symbol") {
      Object.defineProperty(ReadableStream.prototype, SymbolPolyfill.asyncIterator, {
        value: ReadableStream.prototype.values,
        writable: true,
        configurable: true
      });
    }
    byteLengthSizeFunction = function(chunk) {
      return chunk.byteLength;
    };
    try {
      Object.defineProperty(byteLengthSizeFunction, "name", {
        value: "size",
        configurable: true
      });
    } catch (_a2) {
    }
    ByteLengthQueuingStrategy = /** @class */
    function() {
      function ByteLengthQueuingStrategy3(options) {
        assertRequiredArgument(options, 1, "ByteLengthQueuingStrategy");
        options = convertQueuingStrategyInit(options, "First parameter");
        this._byteLengthQueuingStrategyHighWaterMark = options.highWaterMark;
      }
      Object.defineProperty(ByteLengthQueuingStrategy3.prototype, "highWaterMark", {
        /**
         * Returns the high water mark provided to the constructor.
         */
        get: function() {
          if (!IsByteLengthQueuingStrategy(this)) {
            throw byteLengthBrandCheckException("highWaterMark");
          }
          return this._byteLengthQueuingStrategyHighWaterMark;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ByteLengthQueuingStrategy3.prototype, "size", {
        /**
         * Measures the size of `chunk` by returning the value of its `byteLength` property.
         */
        get: function() {
          if (!IsByteLengthQueuingStrategy(this)) {
            throw byteLengthBrandCheckException("size");
          }
          return byteLengthSizeFunction;
        },
        enumerable: false,
        configurable: true
      });
      return ByteLengthQueuingStrategy3;
    }();
    Object.defineProperties(ByteLengthQueuingStrategy.prototype, {
      highWaterMark: { enumerable: true },
      size: { enumerable: true }
    });
    if (typeof SymbolPolyfill.toStringTag === "symbol") {
      Object.defineProperty(ByteLengthQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {
        value: "ByteLengthQueuingStrategy",
        configurable: true
      });
    }
    countSizeFunction = function() {
      return 1;
    };
    try {
      Object.defineProperty(countSizeFunction, "name", {
        value: "size",
        configurable: true
      });
    } catch (_a2) {
    }
    CountQueuingStrategy = /** @class */
    function() {
      function CountQueuingStrategy3(options) {
        assertRequiredArgument(options, 1, "CountQueuingStrategy");
        options = convertQueuingStrategyInit(options, "First parameter");
        this._countQueuingStrategyHighWaterMark = options.highWaterMark;
      }
      Object.defineProperty(CountQueuingStrategy3.prototype, "highWaterMark", {
        /**
         * Returns the high water mark provided to the constructor.
         */
        get: function() {
          if (!IsCountQueuingStrategy(this)) {
            throw countBrandCheckException("highWaterMark");
          }
          return this._countQueuingStrategyHighWaterMark;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(CountQueuingStrategy3.prototype, "size", {
        /**
         * Measures the size of `chunk` by always returning 1.
         * This ensures that the total queue size is a count of the number of chunks in the queue.
         */
        get: function() {
          if (!IsCountQueuingStrategy(this)) {
            throw countBrandCheckException("size");
          }
          return countSizeFunction;
        },
        enumerable: false,
        configurable: true
      });
      return CountQueuingStrategy3;
    }();
    Object.defineProperties(CountQueuingStrategy.prototype, {
      highWaterMark: { enumerable: true },
      size: { enumerable: true }
    });
    if (typeof SymbolPolyfill.toStringTag === "symbol") {
      Object.defineProperty(CountQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {
        value: "CountQueuingStrategy",
        configurable: true
      });
    }
    TransformStream = /** @class */
    function() {
      function TransformStream3(rawTransformer, rawWritableStrategy, rawReadableStrategy) {
        if (rawTransformer === void 0) {
          rawTransformer = {};
        }
        if (rawWritableStrategy === void 0) {
          rawWritableStrategy = {};
        }
        if (rawReadableStrategy === void 0) {
          rawReadableStrategy = {};
        }
        if (rawTransformer === void 0) {
          rawTransformer = null;
        }
        var writableStrategy = convertQueuingStrategy(rawWritableStrategy, "Second parameter");
        var readableStrategy = convertQueuingStrategy(rawReadableStrategy, "Third parameter");
        var transformer = convertTransformer(rawTransformer, "First parameter");
        if (transformer.readableType !== void 0) {
          throw new RangeError("Invalid readableType specified");
        }
        if (transformer.writableType !== void 0) {
          throw new RangeError("Invalid writableType specified");
        }
        var readableHighWaterMark2 = ExtractHighWaterMark(readableStrategy, 0);
        var readableSizeAlgorithm = ExtractSizeAlgorithm(readableStrategy);
        var writableHighWaterMark = ExtractHighWaterMark(writableStrategy, 1);
        var writableSizeAlgorithm = ExtractSizeAlgorithm(writableStrategy);
        var startPromise_resolve;
        var startPromise = newPromise(function(resolve) {
          startPromise_resolve = resolve;
        });
        InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark2, readableSizeAlgorithm);
        SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);
        if (transformer.start !== void 0) {
          startPromise_resolve(transformer.start(this._transformStreamController));
        } else {
          startPromise_resolve(void 0);
        }
      }
      Object.defineProperty(TransformStream3.prototype, "readable", {
        /**
         * The readable side of the transform stream.
         */
        get: function() {
          if (!IsTransformStream(this)) {
            throw streamBrandCheckException("readable");
          }
          return this._readable;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TransformStream3.prototype, "writable", {
        /**
         * The writable side of the transform stream.
         */
        get: function() {
          if (!IsTransformStream(this)) {
            throw streamBrandCheckException("writable");
          }
          return this._writable;
        },
        enumerable: false,
        configurable: true
      });
      return TransformStream3;
    }();
    Object.defineProperties(TransformStream.prototype, {
      readable: { enumerable: true },
      writable: { enumerable: true }
    });
    if (typeof SymbolPolyfill.toStringTag === "symbol") {
      Object.defineProperty(TransformStream.prototype, SymbolPolyfill.toStringTag, {
        value: "TransformStream",
        configurable: true
      });
    }
    TransformStreamDefaultController = /** @class */
    function() {
      function TransformStreamDefaultController3() {
        throw new TypeError("Illegal constructor");
      }
      Object.defineProperty(TransformStreamDefaultController3.prototype, "desiredSize", {
        /**
         * Returns the desired size to fill the readable side’s internal queue. It can be negative, if the queue is over-full.
         */
        get: function() {
          if (!IsTransformStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException("desiredSize");
          }
          var readableController = this._controlledTransformStream._readable._readableStreamController;
          return ReadableStreamDefaultControllerGetDesiredSize(readableController);
        },
        enumerable: false,
        configurable: true
      });
      TransformStreamDefaultController3.prototype.enqueue = function(chunk) {
        if (chunk === void 0) {
          chunk = void 0;
        }
        if (!IsTransformStreamDefaultController(this)) {
          throw defaultControllerBrandCheckException("enqueue");
        }
        TransformStreamDefaultControllerEnqueue(this, chunk);
      };
      TransformStreamDefaultController3.prototype.error = function(reason) {
        if (reason === void 0) {
          reason = void 0;
        }
        if (!IsTransformStreamDefaultController(this)) {
          throw defaultControllerBrandCheckException("error");
        }
        TransformStreamDefaultControllerError(this, reason);
      };
      TransformStreamDefaultController3.prototype.terminate = function() {
        if (!IsTransformStreamDefaultController(this)) {
          throw defaultControllerBrandCheckException("terminate");
        }
        TransformStreamDefaultControllerTerminate(this);
      };
      return TransformStreamDefaultController3;
    }();
    Object.defineProperties(TransformStreamDefaultController.prototype, {
      enqueue: { enumerable: true },
      error: { enumerable: true },
      terminate: { enumerable: true },
      desiredSize: { enumerable: true }
    });
    if (typeof SymbolPolyfill.toStringTag === "symbol") {
      Object.defineProperty(TransformStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
        value: "TransformStreamDefaultController",
        configurable: true
      });
    }
  }
});

// ../../node_modules/.pnpm/@web-std+stream@1.0.0/node_modules/@web-std/stream/src/stream.cjs
var require_stream = __commonJS({
  "../../node_modules/.pnpm/@web-std+stream@1.0.0/node_modules/@web-std/stream/src/stream.cjs"(exports2, module2) {
    "use strict";
    try {
      module2.exports = require("stream/web");
    } catch (error) {
      module2.exports = (init_ponyfill(), __toCommonJS(ponyfill_exports));
    }
  }
});

// ../../node_modules/.pnpm/event-target-shim@5.0.1/node_modules/event-target-shim/dist/event-target-shim.js
var require_event_target_shim = __commonJS({
  "../../node_modules/.pnpm/event-target-shim@5.0.1/node_modules/event-target-shim/dist/event-target-shim.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var privateData = /* @__PURE__ */ new WeakMap();
    var wrappers = /* @__PURE__ */ new WeakMap();
    function pd(event) {
      const retv = privateData.get(event);
      console.assert(
        retv != null,
        "'this' is expected an Event object, but got",
        event
      );
      return retv;
    }
    function setCancelFlag(data) {
      if (data.passiveListener != null) {
        if (typeof console !== "undefined" && typeof console.error === "function") {
          console.error(
            "Unable to preventDefault inside passive event listener invocation.",
            data.passiveListener
          );
        }
        return;
      }
      if (!data.event.cancelable) {
        return;
      }
      data.canceled = true;
      if (typeof data.event.preventDefault === "function") {
        data.event.preventDefault();
      }
    }
    function Event(eventTarget, event) {
      privateData.set(this, {
        eventTarget,
        event,
        eventPhase: 2,
        currentTarget: eventTarget,
        canceled: false,
        stopped: false,
        immediateStopped: false,
        passiveListener: null,
        timeStamp: event.timeStamp || Date.now()
      });
      Object.defineProperty(this, "isTrusted", { value: false, enumerable: true });
      const keys = Object.keys(event);
      for (let i = 0; i < keys.length; ++i) {
        const key = keys[i];
        if (!(key in this)) {
          Object.defineProperty(this, key, defineRedirectDescriptor(key));
        }
      }
    }
    Event.prototype = {
      /**
       * The type of this event.
       * @type {string}
       */
      get type() {
        return pd(this).event.type;
      },
      /**
       * The target of this event.
       * @type {EventTarget}
       */
      get target() {
        return pd(this).eventTarget;
      },
      /**
       * The target of this event.
       * @type {EventTarget}
       */
      get currentTarget() {
        return pd(this).currentTarget;
      },
      /**
       * @returns {EventTarget[]} The composed path of this event.
       */
      composedPath() {
        const currentTarget = pd(this).currentTarget;
        if (currentTarget == null) {
          return [];
        }
        return [currentTarget];
      },
      /**
       * Constant of NONE.
       * @type {number}
       */
      get NONE() {
        return 0;
      },
      /**
       * Constant of CAPTURING_PHASE.
       * @type {number}
       */
      get CAPTURING_PHASE() {
        return 1;
      },
      /**
       * Constant of AT_TARGET.
       * @type {number}
       */
      get AT_TARGET() {
        return 2;
      },
      /**
       * Constant of BUBBLING_PHASE.
       * @type {number}
       */
      get BUBBLING_PHASE() {
        return 3;
      },
      /**
       * The target of this event.
       * @type {number}
       */
      get eventPhase() {
        return pd(this).eventPhase;
      },
      /**
       * Stop event bubbling.
       * @returns {void}
       */
      stopPropagation() {
        const data = pd(this);
        data.stopped = true;
        if (typeof data.event.stopPropagation === "function") {
          data.event.stopPropagation();
        }
      },
      /**
       * Stop event bubbling.
       * @returns {void}
       */
      stopImmediatePropagation() {
        const data = pd(this);
        data.stopped = true;
        data.immediateStopped = true;
        if (typeof data.event.stopImmediatePropagation === "function") {
          data.event.stopImmediatePropagation();
        }
      },
      /**
       * The flag to be bubbling.
       * @type {boolean}
       */
      get bubbles() {
        return Boolean(pd(this).event.bubbles);
      },
      /**
       * The flag to be cancelable.
       * @type {boolean}
       */
      get cancelable() {
        return Boolean(pd(this).event.cancelable);
      },
      /**
       * Cancel this event.
       * @returns {void}
       */
      preventDefault() {
        setCancelFlag(pd(this));
      },
      /**
       * The flag to indicate cancellation state.
       * @type {boolean}
       */
      get defaultPrevented() {
        return pd(this).canceled;
      },
      /**
       * The flag to be composed.
       * @type {boolean}
       */
      get composed() {
        return Boolean(pd(this).event.composed);
      },
      /**
       * The unix time of this event.
       * @type {number}
       */
      get timeStamp() {
        return pd(this).timeStamp;
      },
      /**
       * The target of this event.
       * @type {EventTarget}
       * @deprecated
       */
      get srcElement() {
        return pd(this).eventTarget;
      },
      /**
       * The flag to stop event bubbling.
       * @type {boolean}
       * @deprecated
       */
      get cancelBubble() {
        return pd(this).stopped;
      },
      set cancelBubble(value) {
        if (!value) {
          return;
        }
        const data = pd(this);
        data.stopped = true;
        if (typeof data.event.cancelBubble === "boolean") {
          data.event.cancelBubble = true;
        }
      },
      /**
       * The flag to indicate cancellation state.
       * @type {boolean}
       * @deprecated
       */
      get returnValue() {
        return !pd(this).canceled;
      },
      set returnValue(value) {
        if (!value) {
          setCancelFlag(pd(this));
        }
      },
      /**
       * Initialize this event object. But do nothing under event dispatching.
       * @param {string} type The event type.
       * @param {boolean} [bubbles=false] The flag to be possible to bubble up.
       * @param {boolean} [cancelable=false] The flag to be possible to cancel.
       * @deprecated
       */
      initEvent() {
      }
    };
    Object.defineProperty(Event.prototype, "constructor", {
      value: Event,
      configurable: true,
      writable: true
    });
    if (typeof window !== "undefined" && typeof window.Event !== "undefined") {
      Object.setPrototypeOf(Event.prototype, window.Event.prototype);
      wrappers.set(window.Event.prototype, Event);
    }
    function defineRedirectDescriptor(key) {
      return {
        get() {
          return pd(this).event[key];
        },
        set(value) {
          pd(this).event[key] = value;
        },
        configurable: true,
        enumerable: true
      };
    }
    function defineCallDescriptor(key) {
      return {
        value() {
          const event = pd(this).event;
          return event[key].apply(event, arguments);
        },
        configurable: true,
        enumerable: true
      };
    }
    function defineWrapper(BaseEvent, proto) {
      const keys = Object.keys(proto);
      if (keys.length === 0) {
        return BaseEvent;
      }
      function CustomEvent(eventTarget, event) {
        BaseEvent.call(this, eventTarget, event);
      }
      CustomEvent.prototype = Object.create(BaseEvent.prototype, {
        constructor: { value: CustomEvent, configurable: true, writable: true }
      });
      for (let i = 0; i < keys.length; ++i) {
        const key = keys[i];
        if (!(key in BaseEvent.prototype)) {
          const descriptor = Object.getOwnPropertyDescriptor(proto, key);
          const isFunc = typeof descriptor.value === "function";
          Object.defineProperty(
            CustomEvent.prototype,
            key,
            isFunc ? defineCallDescriptor(key) : defineRedirectDescriptor(key)
          );
        }
      }
      return CustomEvent;
    }
    function getWrapper(proto) {
      if (proto == null || proto === Object.prototype) {
        return Event;
      }
      let wrapper = wrappers.get(proto);
      if (wrapper == null) {
        wrapper = defineWrapper(getWrapper(Object.getPrototypeOf(proto)), proto);
        wrappers.set(proto, wrapper);
      }
      return wrapper;
    }
    function wrapEvent(eventTarget, event) {
      const Wrapper = getWrapper(Object.getPrototypeOf(event));
      return new Wrapper(eventTarget, event);
    }
    function isStopped(event) {
      return pd(event).immediateStopped;
    }
    function setEventPhase(event, eventPhase) {
      pd(event).eventPhase = eventPhase;
    }
    function setCurrentTarget(event, currentTarget) {
      pd(event).currentTarget = currentTarget;
    }
    function setPassiveListener(event, passiveListener) {
      pd(event).passiveListener = passiveListener;
    }
    var listenersMap = /* @__PURE__ */ new WeakMap();
    var CAPTURE = 1;
    var BUBBLE = 2;
    var ATTRIBUTE = 3;
    function isObject3(x) {
      return x !== null && typeof x === "object";
    }
    function getListeners(eventTarget) {
      const listeners = listenersMap.get(eventTarget);
      if (listeners == null) {
        throw new TypeError(
          "'this' is expected an EventTarget object, but got another value."
        );
      }
      return listeners;
    }
    function defineEventAttributeDescriptor(eventName) {
      return {
        get() {
          const listeners = getListeners(this);
          let node = listeners.get(eventName);
          while (node != null) {
            if (node.listenerType === ATTRIBUTE) {
              return node.listener;
            }
            node = node.next;
          }
          return null;
        },
        set(listener) {
          if (typeof listener !== "function" && !isObject3(listener)) {
            listener = null;
          }
          const listeners = getListeners(this);
          let prev = null;
          let node = listeners.get(eventName);
          while (node != null) {
            if (node.listenerType === ATTRIBUTE) {
              if (prev !== null) {
                prev.next = node.next;
              } else if (node.next !== null) {
                listeners.set(eventName, node.next);
              } else {
                listeners.delete(eventName);
              }
            } else {
              prev = node;
            }
            node = node.next;
          }
          if (listener !== null) {
            const newNode = {
              listener,
              listenerType: ATTRIBUTE,
              passive: false,
              once: false,
              next: null
            };
            if (prev === null) {
              listeners.set(eventName, newNode);
            } else {
              prev.next = newNode;
            }
          }
        },
        configurable: true,
        enumerable: true
      };
    }
    function defineEventAttribute(eventTargetPrototype, eventName) {
      Object.defineProperty(
        eventTargetPrototype,
        `on${eventName}`,
        defineEventAttributeDescriptor(eventName)
      );
    }
    function defineCustomEventTarget(eventNames) {
      function CustomEventTarget() {
        EventTarget.call(this);
      }
      CustomEventTarget.prototype = Object.create(EventTarget.prototype, {
        constructor: {
          value: CustomEventTarget,
          configurable: true,
          writable: true
        }
      });
      for (let i = 0; i < eventNames.length; ++i) {
        defineEventAttribute(CustomEventTarget.prototype, eventNames[i]);
      }
      return CustomEventTarget;
    }
    function EventTarget() {
      if (this instanceof EventTarget) {
        listenersMap.set(this, /* @__PURE__ */ new Map());
        return;
      }
      if (arguments.length === 1 && Array.isArray(arguments[0])) {
        return defineCustomEventTarget(arguments[0]);
      }
      if (arguments.length > 0) {
        const types4 = new Array(arguments.length);
        for (let i = 0; i < arguments.length; ++i) {
          types4[i] = arguments[i];
        }
        return defineCustomEventTarget(types4);
      }
      throw new TypeError("Cannot call a class as a function");
    }
    EventTarget.prototype = {
      /**
       * Add a given listener to this event target.
       * @param {string} eventName The event name to add.
       * @param {Function} listener The listener to add.
       * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.
       * @returns {void}
       */
      addEventListener(eventName, listener, options) {
        if (listener == null) {
          return;
        }
        if (typeof listener !== "function" && !isObject3(listener)) {
          throw new TypeError("'listener' should be a function or an object.");
        }
        const listeners = getListeners(this);
        const optionsIsObj = isObject3(options);
        const capture = optionsIsObj ? Boolean(options.capture) : Boolean(options);
        const listenerType = capture ? CAPTURE : BUBBLE;
        const newNode = {
          listener,
          listenerType,
          passive: optionsIsObj && Boolean(options.passive),
          once: optionsIsObj && Boolean(options.once),
          next: null
        };
        let node = listeners.get(eventName);
        if (node === void 0) {
          listeners.set(eventName, newNode);
          return;
        }
        let prev = null;
        while (node != null) {
          if (node.listener === listener && node.listenerType === listenerType) {
            return;
          }
          prev = node;
          node = node.next;
        }
        prev.next = newNode;
      },
      /**
       * Remove a given listener from this event target.
       * @param {string} eventName The event name to remove.
       * @param {Function} listener The listener to remove.
       * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.
       * @returns {void}
       */
      removeEventListener(eventName, listener, options) {
        if (listener == null) {
          return;
        }
        const listeners = getListeners(this);
        const capture = isObject3(options) ? Boolean(options.capture) : Boolean(options);
        const listenerType = capture ? CAPTURE : BUBBLE;
        let prev = null;
        let node = listeners.get(eventName);
        while (node != null) {
          if (node.listener === listener && node.listenerType === listenerType) {
            if (prev !== null) {
              prev.next = node.next;
            } else if (node.next !== null) {
              listeners.set(eventName, node.next);
            } else {
              listeners.delete(eventName);
            }
            return;
          }
          prev = node;
          node = node.next;
        }
      },
      /**
       * Dispatch a given event.
       * @param {Event|{type:string}} event The event to dispatch.
       * @returns {boolean} `false` if canceled.
       */
      dispatchEvent(event) {
        if (event == null || typeof event.type !== "string") {
          throw new TypeError('"event.type" should be a string.');
        }
        const listeners = getListeners(this);
        const eventName = event.type;
        let node = listeners.get(eventName);
        if (node == null) {
          return true;
        }
        const wrappedEvent = wrapEvent(this, event);
        let prev = null;
        while (node != null) {
          if (node.once) {
            if (prev !== null) {
              prev.next = node.next;
            } else if (node.next !== null) {
              listeners.set(eventName, node.next);
            } else {
              listeners.delete(eventName);
            }
          } else {
            prev = node;
          }
          setPassiveListener(
            wrappedEvent,
            node.passive ? node.listener : null
          );
          if (typeof node.listener === "function") {
            try {
              node.listener.call(this, wrappedEvent);
            } catch (err) {
              if (typeof console !== "undefined" && typeof console.error === "function") {
                console.error(err);
              }
            }
          } else if (node.listenerType !== ATTRIBUTE && typeof node.listener.handleEvent === "function") {
            node.listener.handleEvent(wrappedEvent);
          }
          if (isStopped(wrappedEvent)) {
            break;
          }
          node = node.next;
        }
        setPassiveListener(wrappedEvent, null);
        setEventPhase(wrappedEvent, 0);
        setCurrentTarget(wrappedEvent, null);
        return !wrappedEvent.defaultPrevented;
      }
    };
    Object.defineProperty(EventTarget.prototype, "constructor", {
      value: EventTarget,
      configurable: true,
      writable: true
    });
    if (typeof window !== "undefined" && typeof window.EventTarget !== "undefined") {
      Object.setPrototypeOf(EventTarget.prototype, window.EventTarget.prototype);
    }
    exports2.defineEventAttribute = defineEventAttribute;
    exports2.EventTarget = EventTarget;
    exports2.default = EventTarget;
    module2.exports = EventTarget;
    module2.exports.EventTarget = module2.exports["default"] = EventTarget;
    module2.exports.defineEventAttribute = defineEventAttribute;
  }
});

// ../../node_modules/.pnpm/abort-controller@3.0.0/node_modules/abort-controller/dist/abort-controller.js
var require_abort_controller = __commonJS({
  "../../node_modules/.pnpm/abort-controller@3.0.0/node_modules/abort-controller/dist/abort-controller.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var eventTargetShim = require_event_target_shim();
    var AbortSignal = class extends eventTargetShim.EventTarget {
      /**
       * AbortSignal cannot be constructed directly.
       */
      constructor() {
        super();
        throw new TypeError("AbortSignal cannot be constructed directly");
      }
      /**
       * Returns `true` if this `AbortSignal`'s `AbortController` has signaled to abort, and `false` otherwise.
       */
      get aborted() {
        const aborted = abortedFlags.get(this);
        if (typeof aborted !== "boolean") {
          throw new TypeError(`Expected 'this' to be an 'AbortSignal' object, but got ${this === null ? "null" : typeof this}`);
        }
        return aborted;
      }
    };
    eventTargetShim.defineEventAttribute(AbortSignal.prototype, "abort");
    function createAbortSignal() {
      const signal = Object.create(AbortSignal.prototype);
      eventTargetShim.EventTarget.call(signal);
      abortedFlags.set(signal, false);
      return signal;
    }
    function abortSignal(signal) {
      if (abortedFlags.get(signal) !== false) {
        return;
      }
      abortedFlags.set(signal, true);
      signal.dispatchEvent({ type: "abort" });
    }
    var abortedFlags = /* @__PURE__ */ new WeakMap();
    Object.defineProperties(AbortSignal.prototype, {
      aborted: { enumerable: true }
    });
    if (typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol") {
      Object.defineProperty(AbortSignal.prototype, Symbol.toStringTag, {
        configurable: true,
        value: "AbortSignal"
      });
    }
    var AbortController2 = class {
      /**
       * Initialize this controller.
       */
      constructor() {
        signals.set(this, createAbortSignal());
      }
      /**
       * Returns the `AbortSignal` object associated with this object.
       */
      get signal() {
        return getSignal(this);
      }
      /**
       * Abort and signal to any observers that the associated activity is to be aborted.
       */
      abort() {
        abortSignal(getSignal(this));
      }
    };
    var signals = /* @__PURE__ */ new WeakMap();
    function getSignal(controller) {
      const signal = signals.get(controller);
      if (signal == null) {
        throw new TypeError(`Expected 'this' to be an 'AbortController' object, but got ${controller === null ? "null" : typeof controller}`);
      }
      return signal;
    }
    Object.defineProperties(AbortController2.prototype, {
      signal: { enumerable: true },
      abort: { enumerable: true }
    });
    if (typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol") {
      Object.defineProperty(AbortController2.prototype, Symbol.toStringTag, {
        configurable: true,
        value: "AbortController"
      });
    }
    exports2.AbortController = AbortController2;
    exports2.AbortSignal = AbortSignal;
    exports2.default = AbortController2;
    module2.exports = AbortController2;
    module2.exports.AbortController = module2.exports["default"] = AbortController2;
    module2.exports.AbortSignal = AbortSignal;
  }
});

// src/index.ts
var src_exports2 = {};
__export(src_exports2, {
  Metaplex: () => Metaplex9
});
module.exports = __toCommonJS(src_exports2);

// src/metaplex/burn.ts
var import_core = require("@solana-suite/core");
var Metaplex;
((Metaplex10) => {
  const NFT_AMOUNT2 = 1;
  const NFT_DECIMALS = 0;
  Metaplex10.burn = (mint, owner, signer, feePayer) => {
    return import_core.SplToken.burn(
      mint,
      owner,
      [signer],
      NFT_AMOUNT2,
      NFT_DECIMALS,
      feePayer
    );
  };
})(Metaplex || (Metaplex = {}));

// ../internal/shared-metaplex/dist/index.mjs
var import_shared = require("@solana-suite/shared");
var import_shared2 = require("@solana-suite/shared");
var import_shared3 = require("@solana-suite/shared");
var import_web3 = require("@solana/web3.js");
var import_mpl_token_metadata = require("@metaplex-foundation/mpl-token-metadata");
var import_shared4 = require("@solana-suite/shared");
var __defProp2 = Object.defineProperty;
var __defProps2 = Object.defineProperties;
var __getOwnPropDescs2 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols2 = Object.getOwnPropertySymbols;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __propIsEnum2 = Object.prototype.propertyIsEnumerable;
var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues2 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp2.call(b, prop))
      __defNormalProp2(a, prop, b[prop]);
  if (__getOwnPropSymbols2)
    for (var prop of __getOwnPropSymbols2(b)) {
      if (__propIsEnum2.call(b, prop))
        __defNormalProp2(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps2 = (a, b) => __defProps2(a, __getOwnPropDescs2(b));
var __async2 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var Convert;
((Convert8) => {
  let Collection;
  ((Collection2) => {
    Collection2.intoInfraSide = (input) => {
      if (!input) {
        return null;
      }
      return {
        key: input.toPublicKey(),
        verified: false
      };
    };
    Collection2.intoUserSide = (output) => {
      if (!output) {
        return void 0;
      }
      return {
        address: output.key.toString(),
        verified: output.verified
      };
    };
  })(Collection = Convert8.Collection || (Convert8.Collection = {}));
})(Convert || (Convert = {}));
var Convert2;
((Convert8) => {
  let Creators;
  ((Creators2) => {
    Creators2.intoInfraSide = (input) => {
      if (!input) {
        return null;
      }
      return input.map((data) => {
        let modify = null;
        modify = {
          address: data.address.toPublicKey(),
          share: data.share,
          verified: data.verified
        };
        return modify;
      });
    };
    Creators2.intoUserSide = (output) => {
      if (!output) {
        return void 0;
      }
      return output.map((data) => {
        const modify = {
          address: data.address.toString(),
          share: data.share,
          verified: data.verified
        };
        return modify;
      });
    };
  })(Creators = Convert8.Creators || (Convert8.Creators = {}));
})(Convert2 || (Convert2 = {}));
var Convert3;
((Convert8) => {
  let Uses;
  ((Uses2) => {
    Uses2.intoUserSide = (output) => {
      if (!output) {
        return void 0;
      }
      return output;
    };
  })(Uses = Convert8.Uses || (Convert8.Uses = {}));
})(Convert3 || (Convert3 = {}));
var Convert4;
((Convert8) => {
  let TokenMetadata;
  ((TokenMetadata2) => {
    TokenMetadata2.intoInfraSide = (input, uri, sellerFeeBasisPoints) => {
      return {
        name: input.name,
        symbol: input.symbol,
        uri,
        sellerFeeBasisPoints,
        creators: Convert2.Creators.intoInfraSide(input.creators),
        collection: null,
        uses: input.uses || null
      };
    };
    TokenMetadata2.intoUserSide = (output, tokenAmount) => {
      return {
        mint: output.onchain.mint.toString(),
        royalty: output.onchain.data.sellerFeeBasisPoints,
        name: (0, TokenMetadata2.deleteNullStrings)(output.onchain.data.name),
        symbol: (0, TokenMetadata2.deleteNullStrings)(output.onchain.data.symbol),
        tokenAmount,
        uri: (0, TokenMetadata2.deleteNullStrings)(output.onchain.data.uri),
        creators: Convert2.Creators.intoUserSide(output.onchain.data.creators),
        uses: Convert3.Uses.intoUserSide(output.onchain.uses),
        dateTime: (0, import_shared.convertTimestampToDateTime)(output.offchain.created_at),
        offchain: output.offchain
      };
    };
    TokenMetadata2.deleteNullStrings = (str) => {
      return str.replace(/\0/g, "");
    };
  })(TokenMetadata = Convert8.TokenMetadata || (Convert8.TokenMetadata = {}));
})(Convert4 || (Convert4 = {}));
var Convert5;
((Convert8) => {
  let NftMetadata;
  ((NftMetadata2) => {
    NftMetadata2.intoInfraSide = (input, uri, sellerFeeBasisPoints) => {
      return {
        name: input.name,
        symbol: input.symbol,
        uri,
        sellerFeeBasisPoints,
        creators: Convert2.Creators.intoInfraSide(input.creators),
        collection: Convert.Collection.intoInfraSide(input.collection),
        uses: input.uses || null
      };
    };
    NftMetadata2.intoUserSide = (output, tokenAmount) => {
      return {
        mint: output.onchain.mint.toString(),
        updateAuthority: output.onchain.updateAuthority.toString(),
        royalty: output.onchain.data.sellerFeeBasisPoints,
        name: Convert4.TokenMetadata.deleteNullStrings(output.onchain.data.name),
        symbol: Convert4.TokenMetadata.deleteNullStrings(
          output.onchain.data.symbol
        ),
        tokenAmount,
        uri: Convert4.TokenMetadata.deleteNullStrings(output.onchain.data.uri),
        isMutable: output.onchain.isMutable,
        primarySaleHappened: output.onchain.primarySaleHappened,
        creators: Convert2.Creators.intoUserSide(output.onchain.data.creators),
        editionNonce: output.onchain.editionNonce,
        collection: Convert.Collection.intoUserSide(
          output.onchain.collection
        ),
        uses: Convert3.Uses.intoUserSide(output.onchain.uses),
        dateTime: (0, import_shared2.convertTimestampToDateTime)(output.offchain.created_at),
        offchain: output.offchain
      };
    };
  })(NftMetadata = Convert8.NftMetadata || (Convert8.NftMetadata = {}));
})(Convert5 || (Convert5 = {}));
var Convert6;
((Convert8) => {
  let Properties;
  ((Properties2) => {
    Properties2.intoInfraSide = (input, storageFunc, storageType, feePayer) => __async2(void 0, null, function* () {
      if (!input || !input.files) {
        return {};
      }
      const files = yield Promise.all(
        input.files.map((file) => __async2(void 0, null, function* () {
          if (!file.filePath) {
            return {};
          }
          const res = yield storageFunc(file.filePath, storageType, feePayer);
          if (res.isErr) {
            throw Error(res.error.message);
          }
          return (0, import_shared3.overwriteObject)(file, [
            {
              existsKey: "filePath",
              will: { key: "uri", value: res.value }
            }
          ]);
        }))
      );
      return __spreadProps2(__spreadValues2({}, input), { files });
    });
  })(Properties = Convert8.Properties || (Convert8.Properties = {}));
})(Convert6 || (Convert6 = {}));
var Convert7 = __spreadValues2(__spreadValues2(__spreadValues2(__spreadValues2(__spreadValues2(__spreadValues2({}, Convert), Convert2), Convert5), Convert6), Convert4), Convert3);
var UserSideInput;
((UserSideInput22) => {
  let TokenStandard;
  ((TokenStandard2) => {
    TokenStandard2[TokenStandard2["NonFungible"] = 0] = "NonFungible";
    TokenStandard2[TokenStandard2["FungibleAsset"] = 1] = "FungibleAsset";
    TokenStandard2[TokenStandard2["Fungible"] = 2] = "Fungible";
    TokenStandard2[TokenStandard2["NonFungibleEdition"] = 3] = "NonFungibleEdition";
    TokenStandard2[TokenStandard2["ProgrammableNonFungible"] = 4] = "ProgrammableNonFungible";
  })(TokenStandard = UserSideInput22.TokenStandard || (UserSideInput22.TokenStandard = {}));
})(UserSideInput || (UserSideInput = {}));
var _Shared;
((_Shared2) => {
  let UseMethod;
  ((UseMethod2) => {
    UseMethod2[UseMethod2["Burn"] = 0] = "Burn";
    UseMethod2[UseMethod2["Multiple"] = 1] = "Multiple";
    UseMethod2[UseMethod2["Single"] = 2] = "Single";
  })(UseMethod = _Shared2.UseMethod || (_Shared2.UseMethod = {}));
})(_Shared || (_Shared = {}));
var Pda;
((Pda2) => {
  Pda2.getMetadata = (mint) => {
    const [publicKey] = import_web3.PublicKey.findProgramAddressSync(
      [Buffer.from("metadata"), import_mpl_token_metadata.PROGRAM_ID.toBuffer(), mint.toPublicKey().toBuffer()],
      import_mpl_token_metadata.PROGRAM_ID
    );
    return publicKey;
  };
  Pda2.getMasterEdition = (mint) => {
    const [publicKey] = import_web3.PublicKey.findProgramAddressSync(
      [
        Buffer.from("metadata"),
        import_mpl_token_metadata.PROGRAM_ID.toBuffer(),
        mint.toPublicKey().toBuffer(),
        Buffer.from("edition")
      ],
      import_mpl_token_metadata.PROGRAM_ID
    );
    return publicKey;
  };
})(Pda || (Pda = {}));
var Royalty;
((Royalty2) => {
  Royalty2.THRESHOLD = 100;
  Royalty2.convert = (percentage) => {
    return percentage * Royalty2.THRESHOLD;
  };
})(Royalty || (Royalty = {}));
var Validator;
((Validator2) => {
  let Message;
  ((Message2) => {
    Message2.SUCCESS = "success";
    Message2.SMALL_NUMBER = "too small";
    Message2.BIG_NUMBER = "too big";
    Message2.LONG_LENGTH = "too long";
    Message2.EMPTY = "invalid empty value";
    Message2.INVALID_URL = "invalid url";
    Message2.ONLY_NODE_JS = "`string` type is only Node.js";
  })(Message = Validator2.Message || (Validator2.Message = {}));
  Validator2.NAME_LENGTH = 32;
  Validator2.SYMBOL_LENGTH = 10;
  Validator2.URL_LENGTH = 200;
  Validator2.ROYALTY_MAX = 100;
  Validator2.SELLER_FEE_BASIS_POINTS_MAX = 1e4;
  Validator2.ROYALTY_MIN = -1;
  Validator2.isRoyalty = (royalty) => {
    return (0, import_shared4.Try)(() => {
      const key = "royalty";
      if (royalty !== 0 && !royalty) {
        throw createError(key, Message.EMPTY, royalty);
      }
      if (royalty < Validator2.ROYALTY_MIN) {
        throw createError(key, Message.SMALL_NUMBER, royalty, {
          threshold: Validator2.ROYALTY_MIN,
          condition: "underMin"
        });
      } else if (royalty > Validator2.ROYALTY_MAX) {
        throw createError(key, Message.BIG_NUMBER, royalty, {
          threshold: Validator2.ROYALTY_MAX,
          condition: "overMax"
        });
      }
      return Message.SUCCESS;
    });
  };
  Validator2.isSellerFeeBasisPoints = (royalty) => {
    return (0, import_shared4.Try)(() => {
      const key = "sellerFeeBasisPoints/seller_fee_basis_points";
      if (royalty !== 0 && !royalty) {
        throw createError(key, Message.EMPTY, royalty);
      }
      if (royalty < Validator2.ROYALTY_MIN) {
        throw createError(key, Message.SMALL_NUMBER, royalty, {
          threshold: Validator2.ROYALTY_MIN,
          condition: "underMin"
        });
      } else if (royalty > Validator2.ROYALTY_MAX * Royalty.THRESHOLD) {
        throw createError(key, Message.BIG_NUMBER, royalty, {
          threshold: Validator2.SELLER_FEE_BASIS_POINTS_MAX,
          condition: "overMax"
        });
      }
      return Message.SUCCESS;
    });
  };
  Validator2.isName = (name5) => {
    return (0, import_shared4.Try)(() => {
      const key = "name";
      if (!name5) {
        throw createError(key, Message.EMPTY, name5);
      }
      if (byteLength(name5) > Validator2.NAME_LENGTH) {
        throw createError(key, Message.LONG_LENGTH, name5, {
          threshold: Validator2.NAME_LENGTH,
          condition: "overMax"
        });
      }
      return Message.SUCCESS;
    });
  };
  Validator2.isSymbol = (symbol) => {
    return (0, import_shared4.Try)(() => {
      const key = "symbol";
      if (!symbol) {
        throw createError(key, Message.EMPTY, symbol);
      }
      if (byteLength(symbol) > Validator2.SYMBOL_LENGTH) {
        throw createError(key, Message.LONG_LENGTH, symbol, {
          threshold: Validator2.SYMBOL_LENGTH,
          condition: "overMax"
        });
      }
      return Message.SUCCESS;
    });
  };
  Validator2.isImageUrl = (image) => isUriOrImage(image, "image");
  Validator2.checkAll = (metadata) => {
    return (0, import_shared4.Try)(() => {
      const keys = Object.keys(metadata);
      const results = [];
      keys.map((key) => {
        let res;
        switch (key) {
          case "image":
            if (key in metadata && metadata.image) {
              res = (0, Validator2.isImageUrl)(metadata.image);
            }
            break;
          case "royalty":
            if (key in metadata) {
              res = (0, Validator2.isRoyalty)(metadata.royalty);
            }
            break;
          case "seller_fee_basis_points":
            if (key in metadata && metadata.seller_fee_basis_points) {
              res = (0, Validator2.isSellerFeeBasisPoints)(metadata.seller_fee_basis_points);
            }
            break;
          case "sellerFeeBasisPoints":
            if (key in metadata) {
              res = (0, Validator2.isSellerFeeBasisPoints)(metadata.sellerFeeBasisPoints);
            }
            break;
          case "name":
            if (metadata.name) {
              res = (0, Validator2.isName)(metadata.name);
            }
            break;
          case "symbol":
            if (metadata.symbol) {
              res = (0, Validator2.isSymbol)(metadata.symbol);
            }
            break;
        }
        if (res && res.isErr) {
          results.push(...res.error.details);
        }
      });
      if (results.length > 0) {
        const message = "Caught in the validation errors. see information e.g: err<ValidatorError>.details";
        throw new ValidatorError(message, results);
      }
      return Message.SUCCESS;
    });
  };
  const byteLength = (value) => {
    const text = new TextEncoder();
    return text.encode(value).length;
  };
  const createError = (key, message, actual, limit) => {
    let error;
    if (limit) {
      error = new ValidatorError(message, [{ key, message, actual, limit }]);
    } else {
      error = new ValidatorError(message, [{ key, message, actual }]);
    }
    return error;
  };
  const isUriOrImage = (imageOrUri, key) => {
    return (0, import_shared4.Try)(() => {
      if (!imageOrUri) {
        throw createError(key, Message.EMPTY, imageOrUri);
      }
      if (byteLength(imageOrUri) > Validator2.URL_LENGTH) {
        throw createError(key, Message.LONG_LENGTH, imageOrUri, {
          threshold: Validator2.URL_LENGTH,
          condition: "overMax"
        });
      }
      if (!/https?:\/\/[-_.!~*\\()a-zA-Z0-9;?:&=+,%#]+/g.test(imageOrUri)) {
        throw createError(key, Message.INVALID_URL, imageOrUri);
      }
      return Message.SUCCESS;
    });
  };
})(Validator || (Validator = {}));
var ValidatorError = class extends Error {
  constructor(message, details) {
    super(message);
    this.details = details;
  }
};

// src/metaplex/find.ts
var import_core2 = require("@solana-suite/core");
var Metaplex2;
((Metaplex10) => {
  Metaplex10.findByOwner = (owner, onOk, onErr, options) => __async(void 0, null, function* () {
    const sortable = !(options == null ? void 0 : options.sortable) ? import_core2.Sortable.Desc : options == null ? void 0 : options.sortable;
    const isHolder = !(options == null ? void 0 : options.isHolder) ? true : false;
    yield import_core2.SplToken.genericFindByOwner(
      owner,
      (result) => result.match(onOk, onErr),
      UserSideInput.TokenStandard.NonFungible,
      sortable,
      isHolder
    );
  });
  Metaplex10.findByMint = (mint) => __async(void 0, null, function* () {
    return yield import_core2.SplToken.genericFindByMint(
      mint,
      UserSideInput.TokenStandard.NonFungible
    );
  });
})(Metaplex2 || (Metaplex2 = {}));

// src/metaplex/freeze.ts
var import_shared5 = require("@solana-suite/shared");
var import_spl_token = require("@solana/spl-token");
var import_mpl_token_metadata2 = require("@metaplex-foundation/mpl-token-metadata");
var Metaplex3;
((Metaplex10) => {
  Metaplex10.freeze = (mint, owner, freezeAuthority, feePayer) => {
    const payer = feePayer ? feePayer : freezeAuthority;
    return (0, import_shared5.Try)(() => {
      const tokenAccount = (0, import_spl_token.getAssociatedTokenAddressSync)(
        mint.toPublicKey(),
        owner.toPublicKey()
      );
      const editionAddress = Pda.getMasterEdition(mint);
      const inst = (0, import_mpl_token_metadata2.createFreezeDelegatedAccountInstruction)({
        delegate: new import_shared5.KeypairAccount({ secret: freezeAuthority }).toPublicKey(),
        tokenAccount,
        edition: editionAddress,
        mint: mint.toPublicKey()
      });
      return new import_shared5.Instruction(
        [inst],
        [freezeAuthority.toKeypair()],
        payer.toKeypair()
      );
    });
  };
})(Metaplex3 || (Metaplex3 = {}));

// src/metaplex/fee-payer-partial-sign-mint.ts
var import_shared11 = require("@solana-suite/shared");
var import_web33 = require("@solana/web3.js");

// ../internal/storage/dist/index.mjs
var import_js = require("@metaplex-foundation/js");
var import_shared6 = require("@solana-suite/shared");
var import_js2 = require("@metaplex-foundation/js");
var import_shared7 = require("@solana-suite/shared");

// ../../node_modules/.pnpm/streaming-iterables@6.2.0/node_modules/streaming-iterables/dist/index.mjs
var TIMEOUT = Symbol("TIMEOUT");
function getIterator(iterable) {
  if (typeof iterable.next === "function") {
    return iterable;
  }
  if (typeof iterable[Symbol.iterator] === "function") {
    return iterable[Symbol.iterator]();
  }
  if (typeof iterable[Symbol.asyncIterator] === "function") {
    return iterable[Symbol.asyncIterator]();
  }
  throw new TypeError('"values" does not to conform to any of the iterator or iterable protocols');
}
function defer() {
  let reject;
  let resolve;
  const promise = new Promise((resolveFunc, rejectFunc) => {
    resolve = resolveFunc;
    reject = rejectFunc;
  });
  return {
    promise,
    reject,
    resolve
  };
}
function _transform(concurrency, func, iterable) {
  const iterator = getIterator(iterable);
  const resultQueue = [];
  const readQueue = [];
  let ended = false;
  let reading = false;
  let inflightCount = 0;
  let lastError = null;
  function fulfillReadQueue() {
    while (readQueue.length > 0 && resultQueue.length > 0) {
      const { resolve } = readQueue.shift();
      const value = resultQueue.shift();
      resolve({ done: false, value });
    }
    while (readQueue.length > 0 && inflightCount === 0 && ended) {
      const { resolve, reject } = readQueue.shift();
      if (lastError) {
        reject(lastError);
        lastError = null;
      } else {
        resolve({ done: true, value: void 0 });
      }
    }
  }
  function fillQueue() {
    return __async(this, null, function* () {
      if (ended) {
        fulfillReadQueue();
        return;
      }
      if (reading) {
        return;
      }
      if (inflightCount + resultQueue.length >= concurrency) {
        return;
      }
      reading = true;
      inflightCount++;
      try {
        const { done, value } = yield iterator.next();
        if (done) {
          ended = true;
          inflightCount--;
          fulfillReadQueue();
        } else {
          mapAndQueue(value);
        }
      } catch (error) {
        ended = true;
        inflightCount--;
        lastError = error;
        fulfillReadQueue();
      }
      reading = false;
      fillQueue();
    });
  }
  function mapAndQueue(itrValue) {
    return __async(this, null, function* () {
      try {
        const value = yield func(itrValue);
        resultQueue.push(value);
      } catch (error) {
        ended = true;
        lastError = error;
      }
      inflightCount--;
      fulfillReadQueue();
      fillQueue();
    });
  }
  function next() {
    return __async(this, null, function* () {
      if (resultQueue.length === 0) {
        const deferred = defer();
        readQueue.push(deferred);
        fillQueue();
        return deferred.promise;
      }
      const value = resultQueue.shift();
      fillQueue();
      return { done: false, value };
    });
  }
  const asyncIterableIterator = {
    next,
    [Symbol.asyncIterator]: () => asyncIterableIterator
  };
  return asyncIterableIterator;
}
function transform(concurrency, func, iterable) {
  if (func === void 0) {
    return (curriedFunc, curriedIterable) => curriedIterable ? transform(concurrency, curriedFunc, curriedIterable) : transform(concurrency, curriedFunc);
  }
  if (iterable === void 0) {
    return (curriedIterable) => transform(concurrency, func, curriedIterable);
  }
  return _transform(concurrency, func, iterable);
}

// ../../node_modules/.pnpm/nft.storage@7.1.1_node-fetch@3.3.2/node_modules/nft.storage/src/lib.js
var import_p_retry = __toESM(require_p_retry(), 1);

// ../../node_modules/.pnpm/@ipld+car@3.2.4/node_modules/@ipld/car/esm/lib/reader.js
var import_fs = __toESM(require("fs"), 1);
var import_util = require("util");

// ../../node_modules/.pnpm/@ipld+car@3.2.4/node_modules/@ipld/car/esm/lib/decoder.js
var import_varint2 = __toESM(require_varint(), 1);

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/vendor/varint.js
var encode_1 = encode;
var MSB = 128;
var REST = 127;
var MSBALL = ~REST;
var INT = Math.pow(2, 31);
function encode(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT) {
    out[offset++] = num & 255 | MSB;
    num /= 128;
  }
  while (num & MSBALL) {
    out[offset++] = num & 255 | MSB;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode.bytes = offset - oldOffset + 1;
  return out;
}
var decode = read;
var MSB$1 = 128;
var REST$1 = 127;
function read(buf2, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf2.length;
  do {
    if (counter >= l) {
      read.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf2[counter++];
    res += shift < 28 ? (b & REST$1) << shift : (b & REST$1) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$1);
  read.bytes = counter - offset;
  return res;
}
var N1 = Math.pow(2, 7);
var N2 = Math.pow(2, 14);
var N3 = Math.pow(2, 21);
var N4 = Math.pow(2, 28);
var N5 = Math.pow(2, 35);
var N6 = Math.pow(2, 42);
var N7 = Math.pow(2, 49);
var N8 = Math.pow(2, 56);
var N9 = Math.pow(2, 63);
var length = function(value) {
  return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
};
var varint = {
  encode: encode_1,
  decode,
  encodingLength: length
};
var _brrp_varint = varint;
var varint_default = _brrp_varint;

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/varint.js
var decode2 = (data, offset = 0) => {
  const code5 = varint_default.decode(data, offset);
  return [
    code5,
    varint_default.decode.bytes
  ];
};
var encodeTo = (int, target, offset = 0) => {
  varint_default.encode(int, target, offset);
  return target;
};
var encodingLength = (int) => {
  return varint_default.encodingLength(int);
};

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bytes.js
var bytes_exports = {};
__export(bytes_exports, {
  coerce: () => coerce,
  empty: () => empty,
  equals: () => equals,
  fromHex: () => fromHex,
  fromString: () => fromString,
  isBinary: () => isBinary,
  toHex: () => toHex,
  toString: () => toString
});
var empty = new Uint8Array(0);
var toHex = (d) => d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, "0"), "");
var fromHex = (hex) => {
  const hexes = hex.match(/../g);
  return hexes ? new Uint8Array(hexes.map((b) => parseInt(b, 16))) : empty;
};
var equals = (aa, bb) => {
  if (aa === bb)
    return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
};
var coerce = (o) => {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
};
var isBinary = (o) => o instanceof ArrayBuffer || ArrayBuffer.isView(o);
var fromString = (str) => new TextEncoder().encode(str);
var toString = (b) => new TextDecoder().decode(b);

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/hashes/digest.js
var create = (code5, digest2) => {
  const size = digest2.byteLength;
  const sizeOffset = encodingLength(code5);
  const digestOffset = sizeOffset + encodingLength(size);
  const bytes = new Uint8Array(digestOffset + size);
  encodeTo(code5, bytes, 0);
  encodeTo(size, bytes, sizeOffset);
  bytes.set(digest2, digestOffset);
  return new Digest(code5, size, digest2, bytes);
};
var decode3 = (multihash) => {
  const bytes = coerce(multihash);
  const [code5, sizeOffset] = decode2(bytes);
  const [size, digestOffset] = decode2(bytes.subarray(sizeOffset));
  const digest2 = bytes.subarray(sizeOffset + digestOffset);
  if (digest2.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest(code5, size, digest2, bytes);
};
var equals2 = (a, b) => {
  if (a === b) {
    return true;
  } else {
    return a.code === b.code && a.size === b.size && equals(a.bytes, b.bytes);
  }
};
var Digest = class {
  constructor(code5, size, digest2, bytes) {
    this.code = code5;
    this.size = size;
    this.digest = digest2;
    this.bytes = bytes;
  }
};

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base58.js
var base58_exports = {};
__export(base58_exports, {
  base58btc: () => base58btc,
  base58flickr: () => base58flickr
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/vendor/base-x.js
function base(ALPHABET, name5) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode12(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length2 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length2) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length2 = i2;
      pbegin++;
    }
    var it2 = size - length2;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length2 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length2) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length2 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length2;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode12(string2) {
    var buffer2 = decodeUnsafe(string2);
    if (buffer2) {
      return buffer2;
    }
    throw new Error(`Non-${name5} character`);
  }
  return {
    encode: encode12,
    decodeUnsafe,
    decode: decode12
  };
}
var src = base;
var _brrp__multiformats_scope_baseX = src;
var base_x_default = _brrp__multiformats_scope_baseX;

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base.js
var Encoder = class {
  constructor(name5, prefix, baseEncode) {
    this.name = name5;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes) {
    if (bytes instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder = class {
  constructor(name5, prefix, baseDecode) {
    this.name = name5;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder2) {
    return or(this, decoder2);
  }
};
var ComposedDecoder = class {
  constructor(decoders) {
    this.decoders = decoders;
  }
  or(decoder2) {
    return or(this, decoder2);
  }
  decode(input) {
    const prefix = input[0];
    const decoder2 = this.decoders[prefix];
    if (decoder2) {
      return decoder2.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
var or = (left, right) => new ComposedDecoder(__spreadValues(__spreadValues({}, left.decoders || { [left.prefix]: left }), right.decoders || { [right.prefix]: right }));
var Codec = class {
  constructor(name5, prefix, baseEncode, baseDecode) {
    this.name = name5;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder(name5, prefix, baseEncode);
    this.decoder = new Decoder(name5, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
};
var from = ({ name: name5, prefix, encode: encode12, decode: decode12 }) => new Codec(name5, prefix, encode12, decode12);
var baseX = ({ prefix, name: name5, alphabet: alphabet2 }) => {
  const { encode: encode12, decode: decode12 } = base_x_default(alphabet2, name5);
  return from({
    prefix,
    name: name5,
    encode: encode12,
    decode: (text) => coerce(decode12(text))
  });
};
var decode4 = (string2, alphabet2, bitsPerChar, name5) => {
  const codes = {};
  for (let i = 0; i < alphabet2.length; ++i) {
    codes[alphabet2[i]] = i;
  }
  let end = string2.length;
  while (string2[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits = 0;
  let buffer2 = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value = codes[string2[i]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name5} character`);
    }
    buffer2 = buffer2 << bitsPerChar | value;
    bits += bitsPerChar;
    if (bits >= 8) {
      bits -= 8;
      out[written++] = 255 & buffer2 >> bits;
    }
  }
  if (bits >= bitsPerChar || 255 & buffer2 << 8 - bits) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
};
var encode2 = (data, alphabet2, bitsPerChar) => {
  const pad = alphabet2[alphabet2.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits = 0;
  let buffer2 = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer2 = buffer2 << 8 | data[i];
    bits += 8;
    while (bits > bitsPerChar) {
      bits -= bitsPerChar;
      out += alphabet2[mask & buffer2 >> bits];
    }
  }
  if (bits) {
    out += alphabet2[mask & buffer2 << bitsPerChar - bits];
  }
  if (pad) {
    while (out.length * bitsPerChar & 7) {
      out += "=";
    }
  }
  return out;
};
var rfc4648 = ({ name: name5, prefix, bitsPerChar, alphabet: alphabet2 }) => {
  return from({
    prefix,
    name: name5,
    encode(input) {
      return encode2(input, alphabet2, bitsPerChar);
    },
    decode(input) {
      return decode4(input, alphabet2, bitsPerChar, name5);
    }
  });
};

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base58.js
var base58btc = baseX({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr = baseX({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base32.js
var base32_exports = {};
__export(base32_exports, {
  base32: () => base32,
  base32hex: () => base32hex,
  base32hexpad: () => base32hexpad,
  base32hexpadupper: () => base32hexpadupper,
  base32hexupper: () => base32hexupper,
  base32pad: () => base32pad,
  base32padupper: () => base32padupper,
  base32upper: () => base32upper,
  base32z: () => base32z
});
var base32 = rfc4648({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper = rfc4648({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad = rfc4648({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper = rfc4648({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex = rfc4648({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper = rfc4648({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad = rfc4648({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper = rfc4648({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z = rfc4648({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/cid.js
var CID = class _CID {
  constructor(version2, code5, multihash, bytes) {
    this.code = code5;
    this.version = version2;
    this.multihash = multihash;
    this.bytes = bytes;
    this.byteOffset = bytes.byteOffset;
    this.byteLength = bytes.byteLength;
    this.asCID = this;
    this._baseCache = /* @__PURE__ */ new Map();
    Object.defineProperties(this, {
      byteOffset: hidden,
      byteLength: hidden,
      code: readonly,
      version: readonly,
      multihash: readonly,
      bytes: readonly,
      _baseCache: hidden,
      asCID: hidden
    });
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      default: {
        const { code: code5, multihash } = this;
        if (code5 !== DAG_PB_CODE) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return _CID.createV0(multihash);
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code5, digest: digest2 } = this.multihash;
        const multihash = create(code5, digest2);
        return _CID.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
      }
    }
  }
  equals(other) {
    return other && this.code === other.code && this.version === other.version && equals2(this.multihash, other.multihash);
  }
  toString(base3) {
    const { bytes, version: version2, _baseCache } = this;
    switch (version2) {
      case 0:
        return toStringV0(bytes, _baseCache, base3 || base58btc.encoder);
      default:
        return toStringV1(bytes, _baseCache, base3 || base32.encoder);
    }
  }
  toJSON() {
    return {
      code: this.code,
      version: this.version,
      hash: this.multihash.bytes
    };
  }
  get [Symbol.toStringTag]() {
    return "CID";
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return "CID(" + this.toString() + ")";
  }
  static isCID(value) {
    deprecate(/^0\.0/, IS_CID_DEPRECATION);
    return !!(value && (value[cidSymbol] || value.asCID === value));
  }
  get toBaseEncodedString() {
    throw new Error("Deprecated, use .toString()");
  }
  get codec() {
    throw new Error('"codec" property is deprecated, use integer "code" property instead');
  }
  get buffer() {
    throw new Error("Deprecated .buffer property, use .bytes to get Uint8Array instead");
  }
  get multibaseName() {
    throw new Error('"multibaseName" property is deprecated');
  }
  get prefix() {
    throw new Error('"prefix" property is deprecated');
  }
  static asCID(value) {
    if (value instanceof _CID) {
      return value;
    } else if (value != null && value.asCID === value) {
      const { version: version2, code: code5, multihash, bytes } = value;
      return new _CID(version2, code5, multihash, bytes || encodeCID(version2, code5, multihash.bytes));
    } else if (value != null && value[cidSymbol] === true) {
      const { version: version2, multihash, code: code5 } = value;
      const digest2 = decode3(multihash);
      return _CID.create(version2, code5, digest2);
    } else {
      return null;
    }
  }
  static create(version2, code5, digest2) {
    if (typeof code5 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    switch (version2) {
      case 0: {
        if (code5 !== DAG_PB_CODE) {
          throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`);
        } else {
          return new _CID(version2, code5, digest2, digest2.bytes);
        }
      }
      case 1: {
        const bytes = encodeCID(version2, code5, digest2.bytes);
        return new _CID(version2, code5, digest2, bytes);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  static createV0(digest2) {
    return _CID.create(0, DAG_PB_CODE, digest2);
  }
  static createV1(code5, digest2) {
    return _CID.create(1, code5, digest2);
  }
  static decode(bytes) {
    const [cid, remainder] = _CID.decodeFirst(bytes);
    if (remainder.length) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  static decodeFirst(bytes) {
    const specs = _CID.inspectBytes(bytes);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce(bytes.subarray(prefixSize, prefixSize + specs.multihashSize));
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
    const digest2 = new Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
    const cid = specs.version === 0 ? _CID.createV0(digest2) : _CID.createV1(specs.codec, digest2);
    return [
      cid,
      bytes.subarray(specs.size)
    ];
  }
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i, length2] = decode2(initialBytes.subarray(offset));
      offset += length2;
      return i;
    };
    let version2 = next();
    let codec = DAG_PB_CODE;
    if (version2 === 18) {
      version2 = 0;
      offset = 0;
    } else if (version2 === 1) {
      codec = next();
    }
    if (version2 !== 0 && version2 !== 1) {
      throw new RangeError(`Invalid CID version ${version2}`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return {
      version: version2,
      codec,
      multihashCode,
      digestSize,
      multihashSize,
      size
    };
  }
  static parse(source, base3) {
    const [prefix, bytes] = parseCIDtoBytes(source, base3);
    const cid = _CID.decode(bytes);
    cid._baseCache.set(prefix, source);
    return cid;
  }
};
var parseCIDtoBytes = (source, base3) => {
  switch (source[0]) {
    case "Q": {
      const decoder2 = base3 || base58btc;
      return [
        base58btc.prefix,
        decoder2.decode(`${base58btc.prefix}${source}`)
      ];
    }
    case base58btc.prefix: {
      const decoder2 = base3 || base58btc;
      return [
        base58btc.prefix,
        decoder2.decode(source)
      ];
    }
    case base32.prefix: {
      const decoder2 = base3 || base32;
      return [
        base32.prefix,
        decoder2.decode(source)
      ];
    }
    default: {
      if (base3 == null) {
        throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
      }
      return [
        source[0],
        base3.decode(source)
      ];
    }
  }
};
var toStringV0 = (bytes, cache, base3) => {
  const { prefix } = base3;
  if (prefix !== base58btc.prefix) {
    throw Error(`Cannot string encode V0 in ${base3.name} encoding`);
  }
  const cid = cache.get(prefix);
  if (cid == null) {
    const cid2 = base3.encode(bytes).slice(1);
    cache.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
var toStringV1 = (bytes, cache, base3) => {
  const { prefix } = base3;
  const cid = cache.get(prefix);
  if (cid == null) {
    const cid2 = base3.encode(bytes);
    cache.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
var DAG_PB_CODE = 112;
var SHA_256_CODE = 18;
var encodeCID = (version2, code5, multihash) => {
  const codeOffset = encodingLength(version2);
  const hashOffset = codeOffset + encodingLength(code5);
  const bytes = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo(version2, bytes, 0);
  encodeTo(code5, bytes, codeOffset);
  bytes.set(multihash, hashOffset);
  return bytes;
};
var cidSymbol = Symbol.for("@ipld/js-cid/CID");
var readonly = {
  writable: false,
  configurable: false,
  enumerable: true
};
var hidden = {
  writable: false,
  enumerable: false,
  configurable: false
};
var version = "0.0.0-dev";
var deprecate = (range, message) => {
  if (range.test(version)) {
    console.warn(message);
  } else {
    throw new Error(message);
  }
};
var IS_CID_DEPRECATION = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`;

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/is.js
var typeofs = [
  "string",
  "number",
  "bigint",
  "symbol"
];
var objectTypeNames = [
  "Function",
  "Generator",
  "AsyncGenerator",
  "GeneratorFunction",
  "AsyncGeneratorFunction",
  "AsyncFunction",
  "Observable",
  "Array",
  "Buffer",
  "Object",
  "RegExp",
  "Date",
  "Error",
  "Map",
  "Set",
  "WeakMap",
  "WeakSet",
  "ArrayBuffer",
  "SharedArrayBuffer",
  "DataView",
  "Promise",
  "URL",
  "HTMLElement",
  "Int8Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "Int16Array",
  "Uint16Array",
  "Int32Array",
  "Uint32Array",
  "Float32Array",
  "Float64Array",
  "BigInt64Array",
  "BigUint64Array"
];
function is(value) {
  if (value === null) {
    return "null";
  }
  if (value === void 0) {
    return "undefined";
  }
  if (value === true || value === false) {
    return "boolean";
  }
  const typeOf = typeof value;
  if (typeofs.includes(typeOf)) {
    return typeOf;
  }
  if (typeOf === "function") {
    return "Function";
  }
  if (Array.isArray(value)) {
    return "Array";
  }
  if (isBuffer(value)) {
    return "Buffer";
  }
  const objectType = getObjectType(value);
  if (objectType) {
    return objectType;
  }
  return "Object";
}
function isBuffer(value) {
  return value && value.constructor && value.constructor.isBuffer && value.constructor.isBuffer.call(null, value);
}
function getObjectType(value) {
  const objectTypeName = Object.prototype.toString.call(value).slice(8, -1);
  if (objectTypeNames.includes(objectTypeName)) {
    return objectTypeName;
  }
  return void 0;
}

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/token.js
var Type = class {
  constructor(major, name5, terminal) {
    this.major = major;
    this.majorEncoded = major << 5;
    this.name = name5;
    this.terminal = terminal;
  }
  toString() {
    return `Type[${this.major}].${this.name}`;
  }
  compare(typ) {
    return this.major < typ.major ? -1 : this.major > typ.major ? 1 : 0;
  }
};
Type.uint = new Type(0, "uint", true);
Type.negint = new Type(1, "negint", true);
Type.bytes = new Type(2, "bytes", true);
Type.string = new Type(3, "string", true);
Type.array = new Type(4, "array", false);
Type.map = new Type(5, "map", false);
Type.tag = new Type(6, "tag", false);
Type.float = new Type(7, "float", true);
Type.false = new Type(7, "false", true);
Type.true = new Type(7, "true", true);
Type.null = new Type(7, "null", true);
Type.undefined = new Type(7, "undefined", true);
Type.break = new Type(7, "break", true);
var Token = class {
  constructor(type, value, encodedLength) {
    this.type = type;
    this.value = value;
    this.encodedLength = encodedLength;
    this.encodedBytes = void 0;
    this.byteValue = void 0;
  }
  toString() {
    return `Token[${this.type}].${this.value}`;
  }
};

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/byte-utils.js
var useBuffer = globalThis.process && !globalThis.process.browser && globalThis.Buffer && typeof globalThis.Buffer.isBuffer === "function";
var textDecoder = new TextDecoder();
var textEncoder = new TextEncoder();
function isBuffer2(buf2) {
  return useBuffer && globalThis.Buffer.isBuffer(buf2);
}
function asU8A(buf2) {
  if (!(buf2 instanceof Uint8Array)) {
    return Uint8Array.from(buf2);
  }
  return isBuffer2(buf2) ? new Uint8Array(buf2.buffer, buf2.byteOffset, buf2.byteLength) : buf2;
}
var toString2 = useBuffer ? (bytes, start, end) => {
  return end - start > 64 ? globalThis.Buffer.from(bytes.subarray(start, end)).toString("utf8") : utf8Slice(bytes, start, end);
} : (bytes, start, end) => {
  return end - start > 64 ? textDecoder.decode(bytes.subarray(start, end)) : utf8Slice(bytes, start, end);
};
var fromString2 = useBuffer ? (string2) => {
  return string2.length > 64 ? globalThis.Buffer.from(string2) : utf8ToBytes(string2);
} : (string2) => {
  return string2.length > 64 ? textEncoder.encode(string2) : utf8ToBytes(string2);
};
var fromArray = (arr) => {
  return Uint8Array.from(arr);
};
var slice = useBuffer ? (bytes, start, end) => {
  if (isBuffer2(bytes)) {
    return new Uint8Array(bytes.subarray(start, end));
  }
  return bytes.slice(start, end);
} : (bytes, start, end) => {
  return bytes.slice(start, end);
};
var concat = useBuffer ? (chunks, length2) => {
  chunks = chunks.map((c) => c instanceof Uint8Array ? c : globalThis.Buffer.from(c));
  return asU8A(globalThis.Buffer.concat(chunks, length2));
} : (chunks, length2) => {
  const out = new Uint8Array(length2);
  let off = 0;
  for (let b of chunks) {
    if (off + b.length > out.length) {
      b = b.subarray(0, out.length - off);
    }
    out.set(b, off);
    off += b.length;
  }
  return out;
};
var alloc = useBuffer ? (size) => {
  return globalThis.Buffer.allocUnsafe(size);
} : (size) => {
  return new Uint8Array(size);
};
function compare(b1, b2) {
  if (isBuffer2(b1) && isBuffer2(b2)) {
    return b1.compare(b2);
  }
  for (let i = 0; i < b1.length; i++) {
    if (b1[i] === b2[i]) {
      continue;
    }
    return b1[i] < b2[i] ? -1 : 1;
  }
  return 0;
}
function utf8ToBytes(string2, units = Infinity) {
  let codePoint;
  const length2 = string2.length;
  let leadSurrogate = null;
  const bytes = [];
  for (let i = 0; i < length2; ++i) {
    codePoint = string2.charCodeAt(i);
    if (codePoint > 55295 && codePoint < 57344) {
      if (!leadSurrogate) {
        if (codePoint > 56319) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          continue;
        } else if (i + 1 === length2) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          continue;
        }
        leadSurrogate = codePoint;
        continue;
      }
      if (codePoint < 56320) {
        if ((units -= 3) > -1)
          bytes.push(239, 191, 189);
        leadSurrogate = codePoint;
        continue;
      }
      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
    } else if (leadSurrogate) {
      if ((units -= 3) > -1)
        bytes.push(239, 191, 189);
    }
    leadSurrogate = null;
    if (codePoint < 128) {
      if ((units -= 1) < 0)
        break;
      bytes.push(codePoint);
    } else if (codePoint < 2048) {
      if ((units -= 2) < 0)
        break;
      bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
    } else if (codePoint < 65536) {
      if ((units -= 3) < 0)
        break;
      bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else if (codePoint < 1114112) {
      if ((units -= 4) < 0)
        break;
      bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else {
      throw new Error("Invalid code point");
    }
  }
  return bytes;
}
function utf8Slice(buf2, offset, end) {
  const res = [];
  while (offset < end) {
    const firstByte = buf2[offset];
    let codePoint = null;
    let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (offset + bytesPerSequence <= end) {
      let secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf2[offset + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf2[offset + 1];
          thirdByte = buf2[offset + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf2[offset + 1];
          thirdByte = buf2[offset + 2];
          fourthByte = buf2[offset + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      codePoint = 65533;
      bytesPerSequence = 1;
    } else if (codePoint > 65535) {
      codePoint -= 65536;
      res.push(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    res.push(codePoint);
    offset += bytesPerSequence;
  }
  return decodeCodePointsArray(res);
}
var MAX_ARGUMENTS_LENGTH = 4096;
function decodeCodePointsArray(codePoints) {
  const len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints);
  }
  let res = "";
  let i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
  }
  return res;
}

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/bl.js
var defaultChunkSize = 256;
var Bl = class {
  constructor(chunkSize = defaultChunkSize) {
    this.chunkSize = chunkSize;
    this.cursor = 0;
    this.maxCursor = -1;
    this.chunks = [];
    this._initReuseChunk = null;
  }
  reset() {
    this.cursor = 0;
    this.maxCursor = -1;
    if (this.chunks.length) {
      this.chunks = [];
    }
    if (this._initReuseChunk !== null) {
      this.chunks.push(this._initReuseChunk);
      this.maxCursor = this._initReuseChunk.length - 1;
    }
  }
  push(bytes) {
    let topChunk = this.chunks[this.chunks.length - 1];
    const newMax = this.cursor + bytes.length;
    if (newMax <= this.maxCursor + 1) {
      const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;
      topChunk.set(bytes, chunkPos);
    } else {
      if (topChunk) {
        const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;
        if (chunkPos < topChunk.length) {
          this.chunks[this.chunks.length - 1] = topChunk.subarray(0, chunkPos);
          this.maxCursor = this.cursor - 1;
        }
      }
      if (bytes.length < 64 && bytes.length < this.chunkSize) {
        topChunk = alloc(this.chunkSize);
        this.chunks.push(topChunk);
        this.maxCursor += topChunk.length;
        if (this._initReuseChunk === null) {
          this._initReuseChunk = topChunk;
        }
        topChunk.set(bytes, 0);
      } else {
        this.chunks.push(bytes);
        this.maxCursor += bytes.length;
      }
    }
    this.cursor += bytes.length;
  }
  toBytes(reset = false) {
    let byts;
    if (this.chunks.length === 1) {
      const chunk = this.chunks[0];
      if (reset && this.cursor > chunk.length / 2) {
        byts = this.cursor === chunk.length ? chunk : chunk.subarray(0, this.cursor);
        this._initReuseChunk = null;
        this.chunks = [];
      } else {
        byts = slice(chunk, 0, this.cursor);
      }
    } else {
      byts = concat(this.chunks, this.cursor);
    }
    if (reset) {
      this.reset();
    }
    return byts;
  }
};

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/common.js
var decodeErrPrefix = "CBOR decode error:";
var encodeErrPrefix = "CBOR encode error:";
var uintMinorPrefixBytes = [];
uintMinorPrefixBytes[23] = 1;
uintMinorPrefixBytes[24] = 2;
uintMinorPrefixBytes[25] = 3;
uintMinorPrefixBytes[26] = 5;
uintMinorPrefixBytes[27] = 9;
function assertEnoughData(data, pos, need) {
  if (data.length - pos < need) {
    throw new Error(`${decodeErrPrefix} not enough data for type`);
  }
}

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/0uint.js
var uintBoundaries = [
  24,
  256,
  65536,
  4294967296,
  BigInt("18446744073709551616")
];
function readUint8(data, offset, options) {
  assertEnoughData(data, offset, 1);
  const value = data[offset];
  if (options.strict === true && value < uintBoundaries[0]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value;
}
function readUint16(data, offset, options) {
  assertEnoughData(data, offset, 2);
  const value = data[offset] << 8 | data[offset + 1];
  if (options.strict === true && value < uintBoundaries[1]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value;
}
function readUint32(data, offset, options) {
  assertEnoughData(data, offset, 4);
  const value = data[offset] * 16777216 + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3];
  if (options.strict === true && value < uintBoundaries[2]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value;
}
function readUint64(data, offset, options) {
  assertEnoughData(data, offset, 8);
  const hi = data[offset] * 16777216 + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3];
  const lo = data[offset + 4] * 16777216 + (data[offset + 5] << 16) + (data[offset + 6] << 8) + data[offset + 7];
  const value = (BigInt(hi) << BigInt(32)) + BigInt(lo);
  if (options.strict === true && value < uintBoundaries[3]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  if (value <= Number.MAX_SAFE_INTEGER) {
    return Number(value);
  }
  if (options.allowBigInt === true) {
    return value;
  }
  throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`);
}
function decodeUint8(data, pos, _minor, options) {
  return new Token(Type.uint, readUint8(data, pos + 1, options), 2);
}
function decodeUint16(data, pos, _minor, options) {
  return new Token(Type.uint, readUint16(data, pos + 1, options), 3);
}
function decodeUint32(data, pos, _minor, options) {
  return new Token(Type.uint, readUint32(data, pos + 1, options), 5);
}
function decodeUint64(data, pos, _minor, options) {
  return new Token(Type.uint, readUint64(data, pos + 1, options), 9);
}
function encodeUint(buf2, token) {
  return encodeUintValue(buf2, 0, token.value);
}
function encodeUintValue(buf2, major, uint) {
  if (uint < uintBoundaries[0]) {
    const nuint = Number(uint);
    buf2.push([major | nuint]);
  } else if (uint < uintBoundaries[1]) {
    const nuint = Number(uint);
    buf2.push([
      major | 24,
      nuint
    ]);
  } else if (uint < uintBoundaries[2]) {
    const nuint = Number(uint);
    buf2.push([
      major | 25,
      nuint >>> 8,
      nuint & 255
    ]);
  } else if (uint < uintBoundaries[3]) {
    const nuint = Number(uint);
    buf2.push([
      major | 26,
      nuint >>> 24 & 255,
      nuint >>> 16 & 255,
      nuint >>> 8 & 255,
      nuint & 255
    ]);
  } else {
    const buint = BigInt(uint);
    if (buint < uintBoundaries[4]) {
      const set = [
        major | 27,
        0,
        0,
        0,
        0,
        0,
        0,
        0
      ];
      let lo = Number(buint & BigInt(4294967295));
      let hi = Number(buint >> BigInt(32) & BigInt(4294967295));
      set[8] = lo & 255;
      lo = lo >> 8;
      set[7] = lo & 255;
      lo = lo >> 8;
      set[6] = lo & 255;
      lo = lo >> 8;
      set[5] = lo & 255;
      set[4] = hi & 255;
      hi = hi >> 8;
      set[3] = hi & 255;
      hi = hi >> 8;
      set[2] = hi & 255;
      hi = hi >> 8;
      set[1] = hi & 255;
      buf2.push(set);
    } else {
      throw new Error(`${decodeErrPrefix} encountered BigInt larger than allowable range`);
    }
  }
}
encodeUint.encodedSize = function encodedSize(token) {
  return encodeUintValue.encodedSize(token.value);
};
encodeUintValue.encodedSize = function encodedSize2(uint) {
  if (uint < uintBoundaries[0]) {
    return 1;
  }
  if (uint < uintBoundaries[1]) {
    return 2;
  }
  if (uint < uintBoundaries[2]) {
    return 3;
  }
  if (uint < uintBoundaries[3]) {
    return 5;
  }
  return 9;
};
encodeUint.compareTokens = function compareTokens(tok1, tok2) {
  return tok1.value < tok2.value ? -1 : tok1.value > tok2.value ? 1 : 0;
};

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/1negint.js
function decodeNegint8(data, pos, _minor, options) {
  return new Token(Type.negint, -1 - readUint8(data, pos + 1, options), 2);
}
function decodeNegint16(data, pos, _minor, options) {
  return new Token(Type.negint, -1 - readUint16(data, pos + 1, options), 3);
}
function decodeNegint32(data, pos, _minor, options) {
  return new Token(Type.negint, -1 - readUint32(data, pos + 1, options), 5);
}
var neg1b = BigInt(-1);
var pos1b = BigInt(1);
function decodeNegint64(data, pos, _minor, options) {
  const int = readUint64(data, pos + 1, options);
  if (typeof int !== "bigint") {
    const value = -1 - int;
    if (value >= Number.MIN_SAFE_INTEGER) {
      return new Token(Type.negint, value, 9);
    }
  }
  if (options.allowBigInt !== true) {
    throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`);
  }
  return new Token(Type.negint, neg1b - BigInt(int), 9);
}
function encodeNegint(buf2, token) {
  const negint = token.value;
  const unsigned = typeof negint === "bigint" ? negint * neg1b - pos1b : negint * -1 - 1;
  encodeUintValue(buf2, token.type.majorEncoded, unsigned);
}
encodeNegint.encodedSize = function encodedSize3(token) {
  const negint = token.value;
  const unsigned = typeof negint === "bigint" ? negint * neg1b - pos1b : negint * -1 - 1;
  if (unsigned < uintBoundaries[0]) {
    return 1;
  }
  if (unsigned < uintBoundaries[1]) {
    return 2;
  }
  if (unsigned < uintBoundaries[2]) {
    return 3;
  }
  if (unsigned < uintBoundaries[3]) {
    return 5;
  }
  return 9;
};
encodeNegint.compareTokens = function compareTokens2(tok1, tok2) {
  return tok1.value < tok2.value ? 1 : tok1.value > tok2.value ? -1 : 0;
};

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/2bytes.js
function toToken(data, pos, prefix, length2) {
  assertEnoughData(data, pos, prefix + length2);
  const buf2 = slice(data, pos + prefix, pos + prefix + length2);
  return new Token(Type.bytes, buf2, prefix + length2);
}
function decodeBytesCompact(data, pos, minor, _options) {
  return toToken(data, pos, 1, minor);
}
function decodeBytes8(data, pos, _minor, options) {
  return toToken(data, pos, 2, readUint8(data, pos + 1, options));
}
function decodeBytes16(data, pos, _minor, options) {
  return toToken(data, pos, 3, readUint16(data, pos + 1, options));
}
function decodeBytes32(data, pos, _minor, options) {
  return toToken(data, pos, 5, readUint32(data, pos + 1, options));
}
function decodeBytes64(data, pos, _minor, options) {
  const l = readUint64(data, pos + 1, options);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer bytes lengths not supported`);
  }
  return toToken(data, pos, 9, l);
}
function tokenBytes(token) {
  if (token.encodedBytes === void 0) {
    token.encodedBytes = token.type === Type.string ? fromString2(token.value) : token.value;
  }
  return token.encodedBytes;
}
function encodeBytes(buf2, token) {
  const bytes = tokenBytes(token);
  encodeUintValue(buf2, token.type.majorEncoded, bytes.length);
  buf2.push(bytes);
}
encodeBytes.encodedSize = function encodedSize4(token) {
  const bytes = tokenBytes(token);
  return encodeUintValue.encodedSize(bytes.length) + bytes.length;
};
encodeBytes.compareTokens = function compareTokens3(tok1, tok2) {
  return compareBytes(tokenBytes(tok1), tokenBytes(tok2));
};
function compareBytes(b1, b2) {
  return b1.length < b2.length ? -1 : b1.length > b2.length ? 1 : compare(b1, b2);
}

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/3string.js
function toToken2(data, pos, prefix, length2, options) {
  const totLength = prefix + length2;
  assertEnoughData(data, pos, totLength);
  const tok = new Token(Type.string, toString2(data, pos + prefix, pos + totLength), totLength);
  if (options.retainStringBytes === true) {
    tok.byteValue = slice(data, pos + prefix, pos + totLength);
  }
  return tok;
}
function decodeStringCompact(data, pos, minor, options) {
  return toToken2(data, pos, 1, minor, options);
}
function decodeString8(data, pos, _minor, options) {
  return toToken2(data, pos, 2, readUint8(data, pos + 1, options), options);
}
function decodeString16(data, pos, _minor, options) {
  return toToken2(data, pos, 3, readUint16(data, pos + 1, options), options);
}
function decodeString32(data, pos, _minor, options) {
  return toToken2(data, pos, 5, readUint32(data, pos + 1, options), options);
}
function decodeString64(data, pos, _minor, options) {
  const l = readUint64(data, pos + 1, options);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer string lengths not supported`);
  }
  return toToken2(data, pos, 9, l, options);
}
var encodeString = encodeBytes;

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/4array.js
function toToken3(_data, _pos, prefix, length2) {
  return new Token(Type.array, length2, prefix);
}
function decodeArrayCompact(data, pos, minor, _options) {
  return toToken3(data, pos, 1, minor);
}
function decodeArray8(data, pos, _minor, options) {
  return toToken3(data, pos, 2, readUint8(data, pos + 1, options));
}
function decodeArray16(data, pos, _minor, options) {
  return toToken3(data, pos, 3, readUint16(data, pos + 1, options));
}
function decodeArray32(data, pos, _minor, options) {
  return toToken3(data, pos, 5, readUint32(data, pos + 1, options));
}
function decodeArray64(data, pos, _minor, options) {
  const l = readUint64(data, pos + 1, options);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer array lengths not supported`);
  }
  return toToken3(data, pos, 9, l);
}
function decodeArrayIndefinite(data, pos, _minor, options) {
  if (options.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
  }
  return toToken3(data, pos, 1, Infinity);
}
function encodeArray(buf2, token) {
  encodeUintValue(buf2, Type.array.majorEncoded, token.value);
}
encodeArray.compareTokens = encodeUint.compareTokens;
encodeArray.encodedSize = function encodedSize5(token) {
  return encodeUintValue.encodedSize(token.value);
};

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/5map.js
function toToken4(_data, _pos, prefix, length2) {
  return new Token(Type.map, length2, prefix);
}
function decodeMapCompact(data, pos, minor, _options) {
  return toToken4(data, pos, 1, minor);
}
function decodeMap8(data, pos, _minor, options) {
  return toToken4(data, pos, 2, readUint8(data, pos + 1, options));
}
function decodeMap16(data, pos, _minor, options) {
  return toToken4(data, pos, 3, readUint16(data, pos + 1, options));
}
function decodeMap32(data, pos, _minor, options) {
  return toToken4(data, pos, 5, readUint32(data, pos + 1, options));
}
function decodeMap64(data, pos, _minor, options) {
  const l = readUint64(data, pos + 1, options);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer map lengths not supported`);
  }
  return toToken4(data, pos, 9, l);
}
function decodeMapIndefinite(data, pos, _minor, options) {
  if (options.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
  }
  return toToken4(data, pos, 1, Infinity);
}
function encodeMap(buf2, token) {
  encodeUintValue(buf2, Type.map.majorEncoded, token.value);
}
encodeMap.compareTokens = encodeUint.compareTokens;
encodeMap.encodedSize = function encodedSize6(token) {
  return encodeUintValue.encodedSize(token.value);
};

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/6tag.js
function decodeTagCompact(_data, _pos, minor, _options) {
  return new Token(Type.tag, minor, 1);
}
function decodeTag8(data, pos, _minor, options) {
  return new Token(Type.tag, readUint8(data, pos + 1, options), 2);
}
function decodeTag16(data, pos, _minor, options) {
  return new Token(Type.tag, readUint16(data, pos + 1, options), 3);
}
function decodeTag32(data, pos, _minor, options) {
  return new Token(Type.tag, readUint32(data, pos + 1, options), 5);
}
function decodeTag64(data, pos, _minor, options) {
  return new Token(Type.tag, readUint64(data, pos + 1, options), 9);
}
function encodeTag(buf2, token) {
  encodeUintValue(buf2, Type.tag.majorEncoded, token.value);
}
encodeTag.compareTokens = encodeUint.compareTokens;
encodeTag.encodedSize = function encodedSize7(token) {
  return encodeUintValue.encodedSize(token.value);
};

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/7float.js
var MINOR_FALSE = 20;
var MINOR_TRUE = 21;
var MINOR_NULL = 22;
var MINOR_UNDEFINED = 23;
function decodeUndefined(_data, _pos, _minor, options) {
  if (options.allowUndefined === false) {
    throw new Error(`${decodeErrPrefix} undefined values are not supported`);
  } else if (options.coerceUndefinedToNull === true) {
    return new Token(Type.null, null, 1);
  }
  return new Token(Type.undefined, void 0, 1);
}
function decodeBreak(_data, _pos, _minor, options) {
  if (options.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
  }
  return new Token(Type.break, void 0, 1);
}
function createToken(value, bytes, options) {
  if (options) {
    if (options.allowNaN === false && Number.isNaN(value)) {
      throw new Error(`${decodeErrPrefix} NaN values are not supported`);
    }
    if (options.allowInfinity === false && (value === Infinity || value === -Infinity)) {
      throw new Error(`${decodeErrPrefix} Infinity values are not supported`);
    }
  }
  return new Token(Type.float, value, bytes);
}
function decodeFloat16(data, pos, _minor, options) {
  return createToken(readFloat16(data, pos + 1), 3, options);
}
function decodeFloat32(data, pos, _minor, options) {
  return createToken(readFloat32(data, pos + 1), 5, options);
}
function decodeFloat64(data, pos, _minor, options) {
  return createToken(readFloat64(data, pos + 1), 9, options);
}
function encodeFloat(buf2, token, options) {
  const float = token.value;
  if (float === false) {
    buf2.push([Type.float.majorEncoded | MINOR_FALSE]);
  } else if (float === true) {
    buf2.push([Type.float.majorEncoded | MINOR_TRUE]);
  } else if (float === null) {
    buf2.push([Type.float.majorEncoded | MINOR_NULL]);
  } else if (float === void 0) {
    buf2.push([Type.float.majorEncoded | MINOR_UNDEFINED]);
  } else {
    let decoded;
    let success = false;
    if (!options || options.float64 !== true) {
      encodeFloat16(float);
      decoded = readFloat16(ui8a, 1);
      if (float === decoded || Number.isNaN(float)) {
        ui8a[0] = 249;
        buf2.push(ui8a.slice(0, 3));
        success = true;
      } else {
        encodeFloat32(float);
        decoded = readFloat32(ui8a, 1);
        if (float === decoded) {
          ui8a[0] = 250;
          buf2.push(ui8a.slice(0, 5));
          success = true;
        }
      }
    }
    if (!success) {
      encodeFloat64(float);
      decoded = readFloat64(ui8a, 1);
      ui8a[0] = 251;
      buf2.push(ui8a.slice(0, 9));
    }
  }
}
encodeFloat.encodedSize = function encodedSize8(token, options) {
  const float = token.value;
  if (float === false || float === true || float === null || float === void 0) {
    return 1;
  }
  if (!options || options.float64 !== true) {
    encodeFloat16(float);
    let decoded = readFloat16(ui8a, 1);
    if (float === decoded || Number.isNaN(float)) {
      return 3;
    }
    encodeFloat32(float);
    decoded = readFloat32(ui8a, 1);
    if (float === decoded) {
      return 5;
    }
  }
  return 9;
};
var buffer = new ArrayBuffer(9);
var dataView = new DataView(buffer, 1);
var ui8a = new Uint8Array(buffer, 0);
function encodeFloat16(inp) {
  if (inp === Infinity) {
    dataView.setUint16(0, 31744, false);
  } else if (inp === -Infinity) {
    dataView.setUint16(0, 64512, false);
  } else if (Number.isNaN(inp)) {
    dataView.setUint16(0, 32256, false);
  } else {
    dataView.setFloat32(0, inp);
    const valu32 = dataView.getUint32(0);
    const exponent = (valu32 & 2139095040) >> 23;
    const mantissa = valu32 & 8388607;
    if (exponent === 255) {
      dataView.setUint16(0, 31744, false);
    } else if (exponent === 0) {
      dataView.setUint16(0, (inp & 2147483648) >> 16 | mantissa >> 13, false);
    } else {
      const logicalExponent = exponent - 127;
      if (logicalExponent < -24) {
        dataView.setUint16(0, 0);
      } else if (logicalExponent < -14) {
        dataView.setUint16(0, (valu32 & 2147483648) >> 16 | 1 << 24 + logicalExponent, false);
      } else {
        dataView.setUint16(0, (valu32 & 2147483648) >> 16 | logicalExponent + 15 << 10 | mantissa >> 13, false);
      }
    }
  }
}
function readFloat16(ui8a2, pos) {
  if (ui8a2.length - pos < 2) {
    throw new Error(`${decodeErrPrefix} not enough data for float16`);
  }
  const half = (ui8a2[pos] << 8) + ui8a2[pos + 1];
  if (half === 31744) {
    return Infinity;
  }
  if (half === 64512) {
    return -Infinity;
  }
  if (half === 32256) {
    return NaN;
  }
  const exp = half >> 10 & 31;
  const mant = half & 1023;
  let val;
  if (exp === 0) {
    val = mant * 2 ** -24;
  } else if (exp !== 31) {
    val = (mant + 1024) * 2 ** (exp - 25);
  } else {
    val = mant === 0 ? Infinity : NaN;
  }
  return half & 32768 ? -val : val;
}
function encodeFloat32(inp) {
  dataView.setFloat32(0, inp, false);
}
function readFloat32(ui8a2, pos) {
  if (ui8a2.length - pos < 4) {
    throw new Error(`${decodeErrPrefix} not enough data for float32`);
  }
  const offset = (ui8a2.byteOffset || 0) + pos;
  return new DataView(ui8a2.buffer, offset, 4).getFloat32(0, false);
}
function encodeFloat64(inp) {
  dataView.setFloat64(0, inp, false);
}
function readFloat64(ui8a2, pos) {
  if (ui8a2.length - pos < 8) {
    throw new Error(`${decodeErrPrefix} not enough data for float64`);
  }
  const offset = (ui8a2.byteOffset || 0) + pos;
  return new DataView(ui8a2.buffer, offset, 8).getFloat64(0, false);
}
encodeFloat.compareTokens = encodeUint.compareTokens;

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/jump.js
function invalidMinor(data, pos, minor) {
  throw new Error(`${decodeErrPrefix} encountered invalid minor (${minor}) for major ${data[pos] >>> 5}`);
}
function errorer(msg) {
  return () => {
    throw new Error(`${decodeErrPrefix} ${msg}`);
  };
}
var jump = [];
for (let i = 0; i <= 23; i++) {
  jump[i] = invalidMinor;
}
jump[24] = decodeUint8;
jump[25] = decodeUint16;
jump[26] = decodeUint32;
jump[27] = decodeUint64;
jump[28] = invalidMinor;
jump[29] = invalidMinor;
jump[30] = invalidMinor;
jump[31] = invalidMinor;
for (let i = 32; i <= 55; i++) {
  jump[i] = invalidMinor;
}
jump[56] = decodeNegint8;
jump[57] = decodeNegint16;
jump[58] = decodeNegint32;
jump[59] = decodeNegint64;
jump[60] = invalidMinor;
jump[61] = invalidMinor;
jump[62] = invalidMinor;
jump[63] = invalidMinor;
for (let i = 64; i <= 87; i++) {
  jump[i] = decodeBytesCompact;
}
jump[88] = decodeBytes8;
jump[89] = decodeBytes16;
jump[90] = decodeBytes32;
jump[91] = decodeBytes64;
jump[92] = invalidMinor;
jump[93] = invalidMinor;
jump[94] = invalidMinor;
jump[95] = errorer("indefinite length bytes/strings are not supported");
for (let i = 96; i <= 119; i++) {
  jump[i] = decodeStringCompact;
}
jump[120] = decodeString8;
jump[121] = decodeString16;
jump[122] = decodeString32;
jump[123] = decodeString64;
jump[124] = invalidMinor;
jump[125] = invalidMinor;
jump[126] = invalidMinor;
jump[127] = errorer("indefinite length bytes/strings are not supported");
for (let i = 128; i <= 151; i++) {
  jump[i] = decodeArrayCompact;
}
jump[152] = decodeArray8;
jump[153] = decodeArray16;
jump[154] = decodeArray32;
jump[155] = decodeArray64;
jump[156] = invalidMinor;
jump[157] = invalidMinor;
jump[158] = invalidMinor;
jump[159] = decodeArrayIndefinite;
for (let i = 160; i <= 183; i++) {
  jump[i] = decodeMapCompact;
}
jump[184] = decodeMap8;
jump[185] = decodeMap16;
jump[186] = decodeMap32;
jump[187] = decodeMap64;
jump[188] = invalidMinor;
jump[189] = invalidMinor;
jump[190] = invalidMinor;
jump[191] = decodeMapIndefinite;
for (let i = 192; i <= 215; i++) {
  jump[i] = decodeTagCompact;
}
jump[216] = decodeTag8;
jump[217] = decodeTag16;
jump[218] = decodeTag32;
jump[219] = decodeTag64;
jump[220] = invalidMinor;
jump[221] = invalidMinor;
jump[222] = invalidMinor;
jump[223] = invalidMinor;
for (let i = 224; i <= 243; i++) {
  jump[i] = errorer("simple values are not supported");
}
jump[244] = invalidMinor;
jump[245] = invalidMinor;
jump[246] = invalidMinor;
jump[247] = decodeUndefined;
jump[248] = errorer("simple values are not supported");
jump[249] = decodeFloat16;
jump[250] = decodeFloat32;
jump[251] = decodeFloat64;
jump[252] = invalidMinor;
jump[253] = invalidMinor;
jump[254] = invalidMinor;
jump[255] = decodeBreak;
var quick = [];
for (let i = 0; i < 24; i++) {
  quick[i] = new Token(Type.uint, i, 1);
}
for (let i = -1; i >= -24; i--) {
  quick[31 - i] = new Token(Type.negint, i, 1);
}
quick[64] = new Token(Type.bytes, new Uint8Array(0), 1);
quick[96] = new Token(Type.string, "", 1);
quick[128] = new Token(Type.array, 0, 1);
quick[160] = new Token(Type.map, 0, 1);
quick[244] = new Token(Type.false, false, 1);
quick[245] = new Token(Type.true, true, 1);
quick[246] = new Token(Type.null, null, 1);
function quickEncodeToken(token) {
  switch (token.type) {
    case Type.false:
      return fromArray([244]);
    case Type.true:
      return fromArray([245]);
    case Type.null:
      return fromArray([246]);
    case Type.bytes:
      if (!token.value.length) {
        return fromArray([64]);
      }
      return;
    case Type.string:
      if (token.value === "") {
        return fromArray([96]);
      }
      return;
    case Type.array:
      if (token.value === 0) {
        return fromArray([128]);
      }
      return;
    case Type.map:
      if (token.value === 0) {
        return fromArray([160]);
      }
      return;
    case Type.uint:
      if (token.value < 24) {
        return fromArray([Number(token.value)]);
      }
      return;
    case Type.negint:
      if (token.value >= -24) {
        return fromArray([31 - Number(token.value)]);
      }
  }
}

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/encode.js
var defaultEncodeOptions = {
  float64: false,
  mapSorter,
  quickEncodeToken
};
function makeCborEncoders() {
  const encoders = [];
  encoders[Type.uint.major] = encodeUint;
  encoders[Type.negint.major] = encodeNegint;
  encoders[Type.bytes.major] = encodeBytes;
  encoders[Type.string.major] = encodeString;
  encoders[Type.array.major] = encodeArray;
  encoders[Type.map.major] = encodeMap;
  encoders[Type.tag.major] = encodeTag;
  encoders[Type.float.major] = encodeFloat;
  return encoders;
}
var cborEncoders = makeCborEncoders();
var buf = new Bl();
var Ref = class _Ref {
  constructor(obj, parent) {
    this.obj = obj;
    this.parent = parent;
  }
  includes(obj) {
    let p = this;
    do {
      if (p.obj === obj) {
        return true;
      }
    } while (p = p.parent);
    return false;
  }
  static createCheck(stack, obj) {
    if (stack && stack.includes(obj)) {
      throw new Error(`${encodeErrPrefix} object contains circular references`);
    }
    return new _Ref(obj, stack);
  }
};
var simpleTokens = {
  null: new Token(Type.null, null),
  undefined: new Token(Type.undefined, void 0),
  true: new Token(Type.true, true),
  false: new Token(Type.false, false),
  emptyArray: new Token(Type.array, 0),
  emptyMap: new Token(Type.map, 0)
};
var typeEncoders = {
  number(obj, _typ, _options, _refStack) {
    if (!Number.isInteger(obj) || !Number.isSafeInteger(obj)) {
      return new Token(Type.float, obj);
    } else if (obj >= 0) {
      return new Token(Type.uint, obj);
    } else {
      return new Token(Type.negint, obj);
    }
  },
  bigint(obj, _typ, _options, _refStack) {
    if (obj >= BigInt(0)) {
      return new Token(Type.uint, obj);
    } else {
      return new Token(Type.negint, obj);
    }
  },
  Uint8Array(obj, _typ, _options, _refStack) {
    return new Token(Type.bytes, obj);
  },
  string(obj, _typ, _options, _refStack) {
    return new Token(Type.string, obj);
  },
  boolean(obj, _typ, _options, _refStack) {
    return obj ? simpleTokens.true : simpleTokens.false;
  },
  null(_obj, _typ, _options, _refStack) {
    return simpleTokens.null;
  },
  undefined(_obj, _typ, _options, _refStack) {
    return simpleTokens.undefined;
  },
  ArrayBuffer(obj, _typ, _options, _refStack) {
    return new Token(Type.bytes, new Uint8Array(obj));
  },
  DataView(obj, _typ, _options, _refStack) {
    return new Token(Type.bytes, new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength));
  },
  Array(obj, _typ, options, refStack) {
    if (!obj.length) {
      if (options.addBreakTokens === true) {
        return [
          simpleTokens.emptyArray,
          new Token(Type.break)
        ];
      }
      return simpleTokens.emptyArray;
    }
    refStack = Ref.createCheck(refStack, obj);
    const entries = [];
    let i = 0;
    for (const e of obj) {
      entries[i++] = objectToTokens(e, options, refStack);
    }
    if (options.addBreakTokens) {
      return [
        new Token(Type.array, obj.length),
        entries,
        new Token(Type.break)
      ];
    }
    return [
      new Token(Type.array, obj.length),
      entries
    ];
  },
  Object(obj, typ, options, refStack) {
    const isMap = typ !== "Object";
    const keys = isMap ? obj.keys() : Object.keys(obj);
    const length2 = isMap ? obj.size : keys.length;
    if (!length2) {
      if (options.addBreakTokens === true) {
        return [
          simpleTokens.emptyMap,
          new Token(Type.break)
        ];
      }
      return simpleTokens.emptyMap;
    }
    refStack = Ref.createCheck(refStack, obj);
    const entries = [];
    let i = 0;
    for (const key of keys) {
      entries[i++] = [
        objectToTokens(key, options, refStack),
        objectToTokens(isMap ? obj.get(key) : obj[key], options, refStack)
      ];
    }
    sortMapEntries(entries, options);
    if (options.addBreakTokens) {
      return [
        new Token(Type.map, length2),
        entries,
        new Token(Type.break)
      ];
    }
    return [
      new Token(Type.map, length2),
      entries
    ];
  }
};
typeEncoders.Map = typeEncoders.Object;
typeEncoders.Buffer = typeEncoders.Uint8Array;
for (const typ of "Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64".split(" ")) {
  typeEncoders[`${typ}Array`] = typeEncoders.DataView;
}
function objectToTokens(obj, options = {}, refStack) {
  const typ = is(obj);
  const customTypeEncoder = options && options.typeEncoders && options.typeEncoders[typ] || typeEncoders[typ];
  if (typeof customTypeEncoder === "function") {
    const tokens = customTypeEncoder(obj, typ, options, refStack);
    if (tokens != null) {
      return tokens;
    }
  }
  const typeEncoder = typeEncoders[typ];
  if (!typeEncoder) {
    throw new Error(`${encodeErrPrefix} unsupported type: ${typ}`);
  }
  return typeEncoder(obj, typ, options, refStack);
}
function sortMapEntries(entries, options) {
  if (options.mapSorter) {
    entries.sort(options.mapSorter);
  }
}
function mapSorter(e1, e2) {
  const keyToken1 = Array.isArray(e1[0]) ? e1[0][0] : e1[0];
  const keyToken2 = Array.isArray(e2[0]) ? e2[0][0] : e2[0];
  if (keyToken1.type !== keyToken2.type) {
    return keyToken1.type.compare(keyToken2.type);
  }
  const major = keyToken1.type.major;
  const tcmp = cborEncoders[major].compareTokens(keyToken1, keyToken2);
  if (tcmp === 0) {
    console.warn("WARNING: complex key types used, CBOR key sorting guarantees are gone");
  }
  return tcmp;
}
function tokensToEncoded(buf2, tokens, encoders, options) {
  if (Array.isArray(tokens)) {
    for (const token of tokens) {
      tokensToEncoded(buf2, token, encoders, options);
    }
  } else {
    encoders[tokens.type.major](buf2, tokens, options);
  }
}
function encodeCustom(data, encoders, options) {
  const tokens = objectToTokens(data, options);
  if (!Array.isArray(tokens) && options.quickEncodeToken) {
    const quickBytes = options.quickEncodeToken(tokens);
    if (quickBytes) {
      return quickBytes;
    }
    const encoder2 = encoders[tokens.type.major];
    if (encoder2.encodedSize) {
      const size = encoder2.encodedSize(tokens, options);
      const buf2 = new Bl(size);
      encoder2(buf2, tokens, options);
      if (buf2.chunks.length !== 1) {
        throw new Error(`Unexpected error: pre-calculated length for ${tokens} was wrong`);
      }
      return asU8A(buf2.chunks[0]);
    }
  }
  buf.reset();
  tokensToEncoded(buf, tokens, encoders, options);
  return buf.toBytes(true);
}
function encode3(data, options) {
  options = Object.assign({}, defaultEncodeOptions, options);
  return encodeCustom(data, cborEncoders, options);
}

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/decode.js
var defaultDecodeOptions = {
  strict: false,
  allowIndefinite: true,
  allowUndefined: true,
  allowBigInt: true
};
var Tokeniser = class {
  constructor(data, options = {}) {
    this.pos = 0;
    this.data = data;
    this.options = options;
  }
  done() {
    return this.pos >= this.data.length;
  }
  next() {
    const byt = this.data[this.pos];
    let token = quick[byt];
    if (token === void 0) {
      const decoder2 = jump[byt];
      if (!decoder2) {
        throw new Error(`${decodeErrPrefix} no decoder for major type ${byt >>> 5} (byte 0x${byt.toString(16).padStart(2, "0")})`);
      }
      const minor = byt & 31;
      token = decoder2(this.data, this.pos, minor, this.options);
    }
    this.pos += token.encodedLength;
    return token;
  }
};
var DONE = Symbol.for("DONE");
var BREAK = Symbol.for("BREAK");
function tokenToArray(token, tokeniser, options) {
  const arr = [];
  for (let i = 0; i < token.value; i++) {
    const value = tokensToObject(tokeniser, options);
    if (value === BREAK) {
      if (token.value === Infinity) {
        break;
      }
      throw new Error(`${decodeErrPrefix} got unexpected break to lengthed array`);
    }
    if (value === DONE) {
      throw new Error(`${decodeErrPrefix} found array but not enough entries (got ${i}, expected ${token.value})`);
    }
    arr[i] = value;
  }
  return arr;
}
function tokenToMap(token, tokeniser, options) {
  const useMaps = options.useMaps === true;
  const obj = useMaps ? void 0 : {};
  const m = useMaps ? /* @__PURE__ */ new Map() : void 0;
  for (let i = 0; i < token.value; i++) {
    const key = tokensToObject(tokeniser, options);
    if (key === BREAK) {
      if (token.value === Infinity) {
        break;
      }
      throw new Error(`${decodeErrPrefix} got unexpected break to lengthed map`);
    }
    if (key === DONE) {
      throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${i} [no key], expected ${token.value})`);
    }
    if (useMaps !== true && typeof key !== "string") {
      throw new Error(`${decodeErrPrefix} non-string keys not supported (got ${typeof key})`);
    }
    if (options.rejectDuplicateMapKeys === true) {
      if (useMaps && m.has(key) || !useMaps && key in obj) {
        throw new Error(`${decodeErrPrefix} found repeat map key "${key}"`);
      }
    }
    const value = tokensToObject(tokeniser, options);
    if (value === DONE) {
      throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${i} [no value], expected ${token.value})`);
    }
    if (useMaps) {
      m.set(key, value);
    } else {
      obj[key] = value;
    }
  }
  return useMaps ? m : obj;
}
function tokensToObject(tokeniser, options) {
  if (tokeniser.done()) {
    return DONE;
  }
  const token = tokeniser.next();
  if (token.type === Type.break) {
    return BREAK;
  }
  if (token.type.terminal) {
    return token.value;
  }
  if (token.type === Type.array) {
    return tokenToArray(token, tokeniser, options);
  }
  if (token.type === Type.map) {
    return tokenToMap(token, tokeniser, options);
  }
  if (token.type === Type.tag) {
    if (options.tags && typeof options.tags[token.value] === "function") {
      const tagged = tokensToObject(tokeniser, options);
      return options.tags[token.value](tagged);
    }
    throw new Error(`${decodeErrPrefix} tag not supported (${token.value})`);
  }
  throw new Error("unsupported");
}
function decode5(data, options) {
  if (!(data instanceof Uint8Array)) {
    throw new Error(`${decodeErrPrefix} data to decode must be a Uint8Array`);
  }
  options = Object.assign({}, defaultDecodeOptions, options);
  const tokeniser = options.tokenizer || new Tokeniser(data, options);
  const decoded = tokensToObject(tokeniser, options);
  if (decoded === DONE) {
    throw new Error(`${decodeErrPrefix} did not find any content to decode`);
  }
  if (decoded === BREAK) {
    throw new Error(`${decodeErrPrefix} got unexpected break`);
  }
  if (!tokeniser.done()) {
    throw new Error(`${decodeErrPrefix} too many terminals, data makes no sense`);
  }
  return decoded;
}

// ../../node_modules/.pnpm/@ipld+dag-cbor@7.0.3/node_modules/@ipld/dag-cbor/esm/index.js
var CID_CBOR_TAG = 42;
function cidEncoder(obj) {
  if (obj.asCID !== obj) {
    return null;
  }
  const cid = CID.asCID(obj);
  if (!cid) {
    return null;
  }
  const bytes = new Uint8Array(cid.bytes.byteLength + 1);
  bytes.set(cid.bytes, 1);
  return [
    new Token(Type.tag, CID_CBOR_TAG),
    new Token(Type.bytes, bytes)
  ];
}
function undefinedEncoder() {
  throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded");
}
function numberEncoder(num) {
  if (Number.isNaN(num)) {
    throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded");
  }
  if (num === Infinity || num === -Infinity) {
    throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded");
  }
  return null;
}
var encodeOptions = {
  float64: true,
  typeEncoders: {
    Object: cidEncoder,
    undefined: undefinedEncoder,
    number: numberEncoder
  }
};
function cidDecoder(bytes) {
  if (bytes[0] !== 0) {
    throw new Error("Invalid CID for CBOR tag 42; expected leading 0x00");
  }
  return CID.decode(bytes.subarray(1));
}
var decodeOptions = {
  allowIndefinite: false,
  coerceUndefinedToNull: true,
  allowNaN: false,
  allowInfinity: false,
  allowBigInt: true,
  strict: true,
  useMaps: false,
  tags: []
};
decodeOptions.tags[CID_CBOR_TAG] = cidDecoder;
var encode4 = (node) => encode3(node, encodeOptions);
var decode6 = (data) => decode5(data, decodeOptions);

// ../../node_modules/.pnpm/@ipld+car@3.2.4/node_modules/@ipld/car/esm/lib/decoder.js
var CIDV0_BYTES = {
  SHA2_256: 18,
  LENGTH: 32,
  DAG_PB: 112
};
function readVarint(reader) {
  return __async(this, null, function* () {
    const bytes = yield reader.upTo(8);
    const i = import_varint2.default.decode(bytes);
    reader.seek(import_varint2.default.decode.bytes);
    return i;
  });
}
function readHeader(reader) {
  return __async(this, null, function* () {
    const length2 = yield readVarint(reader);
    if (length2 === 0) {
      throw new Error("Invalid CAR header (zero length)");
    }
    const header = yield reader.exactly(length2);
    reader.seek(length2);
    const block = decode6(header);
    if (block == null || Array.isArray(block) || typeof block !== "object") {
      throw new Error("Invalid CAR header format");
    }
    if (block.version !== 1) {
      if (typeof block.version === "string") {
        throw new Error(`Invalid CAR version: "${block.version}"`);
      }
      throw new Error(`Invalid CAR version: ${block.version}`);
    }
    if (!Array.isArray(block.roots)) {
      throw new Error("Invalid CAR header format");
    }
    if (Object.keys(block).filter((p) => p !== "roots" && p !== "version").length) {
      throw new Error("Invalid CAR header format");
    }
    return block;
  });
}
function readMultihash(reader) {
  return __async(this, null, function* () {
    const bytes = yield reader.upTo(8);
    import_varint2.default.decode(bytes);
    const codeLength = import_varint2.default.decode.bytes;
    const length2 = import_varint2.default.decode(bytes.subarray(import_varint2.default.decode.bytes));
    const lengthLength = import_varint2.default.decode.bytes;
    const mhLength = codeLength + lengthLength + length2;
    const multihash = yield reader.exactly(mhLength);
    reader.seek(mhLength);
    return multihash;
  });
}
function readCid(reader) {
  return __async(this, null, function* () {
    const first = yield reader.exactly(2);
    if (first[0] === CIDV0_BYTES.SHA2_256 && first[1] === CIDV0_BYTES.LENGTH) {
      const bytes2 = yield reader.exactly(34);
      reader.seek(34);
      const multihash2 = decode3(bytes2);
      return CID.create(0, CIDV0_BYTES.DAG_PB, multihash2);
    }
    const version2 = yield readVarint(reader);
    if (version2 !== 1) {
      throw new Error(`Unexpected CID version (${version2})`);
    }
    const codec = yield readVarint(reader);
    const bytes = yield readMultihash(reader);
    const multihash = decode3(bytes);
    return CID.create(version2, codec, multihash);
  });
}
function readBlockHead(reader) {
  return __async(this, null, function* () {
    const start = reader.pos;
    let length2 = yield readVarint(reader);
    if (length2 === 0) {
      throw new Error("Invalid CAR section (zero length)");
    }
    length2 += reader.pos - start;
    const cid = yield readCid(reader);
    const blockLength = length2 - (reader.pos - start);
    return {
      cid,
      length: length2,
      blockLength
    };
  });
}
function readBlock(reader) {
  return __async(this, null, function* () {
    const { cid, blockLength } = yield readBlockHead(reader);
    const bytes = yield reader.exactly(blockLength);
    reader.seek(blockLength);
    return {
      bytes,
      cid
    };
  });
}
function readBlockIndex(reader) {
  return __async(this, null, function* () {
    const offset = reader.pos;
    const { cid, length: length2, blockLength } = yield readBlockHead(reader);
    const index = {
      cid,
      length: length2,
      blockLength,
      offset,
      blockOffset: reader.pos
    };
    reader.seek(index.blockLength);
    return index;
  });
}
function createDecoder(reader) {
  const headerPromise = readHeader(reader);
  return {
    header: () => headerPromise,
    blocks() {
      return __asyncGenerator(this, null, function* () {
        yield new __await(headerPromise);
        while ((yield new __await(reader.upTo(8))).length > 0) {
          yield yield new __await(readBlock(reader));
        }
      });
    },
    blocksIndex() {
      return __asyncGenerator(this, null, function* () {
        yield new __await(headerPromise);
        while ((yield new __await(reader.upTo(8))).length > 0) {
          yield yield new __await(readBlockIndex(reader));
        }
      });
    }
  };
}
function bytesReader(bytes) {
  let pos = 0;
  return {
    upTo(length2) {
      return __async(this, null, function* () {
        return bytes.subarray(pos, pos + Math.min(length2, bytes.length - pos));
      });
    },
    exactly(length2) {
      return __async(this, null, function* () {
        if (length2 > bytes.length - pos) {
          throw new Error("Unexpected end of data");
        }
        return bytes.subarray(pos, pos + length2);
      });
    },
    seek(length2) {
      pos += length2;
    },
    get pos() {
      return pos;
    }
  };
}
function chunkReader(readChunk) {
  let pos = 0;
  let have = 0;
  let offset = 0;
  let currentChunk = new Uint8Array(0);
  const read2 = (length2) => __async(this, null, function* () {
    have = currentChunk.length - offset;
    const bufa = [currentChunk.subarray(offset)];
    while (have < length2) {
      const chunk = yield readChunk();
      if (chunk == null) {
        break;
      }
      if (have < 0) {
        if (chunk.length > have) {
          bufa.push(chunk.subarray(-have));
        }
      } else {
        bufa.push(chunk);
      }
      have += chunk.length;
    }
    currentChunk = new Uint8Array(bufa.reduce((p, c) => p + c.length, 0));
    let off = 0;
    for (const b of bufa) {
      currentChunk.set(b, off);
      off += b.length;
    }
    offset = 0;
  });
  return {
    upTo(length2) {
      return __async(this, null, function* () {
        if (currentChunk.length - offset < length2) {
          yield read2(length2);
        }
        return currentChunk.subarray(offset, offset + Math.min(currentChunk.length - offset, length2));
      });
    },
    exactly(length2) {
      return __async(this, null, function* () {
        if (currentChunk.length - offset < length2) {
          yield read2(length2);
        }
        if (currentChunk.length - offset < length2) {
          throw new Error("Unexpected end of data");
        }
        return currentChunk.subarray(offset, offset + length2);
      });
    },
    seek(length2) {
      pos += length2;
      offset += length2;
    },
    get pos() {
      return pos;
    }
  };
}
function asyncIterableReader(asyncIterable) {
  const iterator = asyncIterable[Symbol.asyncIterator]();
  function readChunk() {
    return __async(this, null, function* () {
      const next = yield iterator.next();
      if (next.done) {
        return null;
      }
      return next.value;
    });
  }
  return chunkReader(readChunk);
}

// ../../node_modules/.pnpm/@ipld+car@3.2.4/node_modules/@ipld/car/esm/lib/reader-browser.js
var CarReader = class {
  constructor(version2, roots, blocks) {
    this._version = version2;
    this._roots = roots;
    this._blocks = blocks;
    this._keys = blocks.map((b) => b.cid.toString());
  }
  get version() {
    return this._version;
  }
  getRoots() {
    return __async(this, null, function* () {
      return this._roots;
    });
  }
  has(key) {
    return __async(this, null, function* () {
      return this._keys.indexOf(key.toString()) > -1;
    });
  }
  get(key) {
    return __async(this, null, function* () {
      const index = this._keys.indexOf(key.toString());
      return index > -1 ? this._blocks[index] : void 0;
    });
  }
  blocks() {
    return __asyncGenerator(this, null, function* () {
      for (const block of this._blocks) {
        yield block;
      }
    });
  }
  cids() {
    return __asyncGenerator(this, null, function* () {
      for (const block of this._blocks) {
        yield block.cid;
      }
    });
  }
  static fromBytes(bytes) {
    return __async(this, null, function* () {
      if (!(bytes instanceof Uint8Array)) {
        throw new TypeError("fromBytes() requires a Uint8Array");
      }
      return decodeReaderComplete(bytesReader(bytes));
    });
  }
  static fromIterable(asyncIterable) {
    return __async(this, null, function* () {
      if (!asyncIterable || !(typeof asyncIterable[Symbol.asyncIterator] === "function")) {
        throw new TypeError("fromIterable() requires an async iterable");
      }
      return decodeReaderComplete(asyncIterableReader(asyncIterable));
    });
  }
};
function decodeReaderComplete(reader) {
  return __async(this, null, function* () {
    const decoder2 = createDecoder(reader);
    const { version: version2, roots } = yield decoder2.header();
    const blocks = [];
    try {
      for (var iter = __forAwait(decoder2.blocks()), more, temp, error; more = !(temp = yield iter.next()).done; more = false) {
        const block = temp.value;
        blocks.push(block);
      }
    } catch (temp) {
      error = [temp];
    } finally {
      try {
        more && (temp = iter.return) && (yield temp.call(iter));
      } finally {
        if (error)
          throw error[0];
      }
    }
    return new CarReader(version2, roots, blocks);
  });
}

// ../../node_modules/.pnpm/@ipld+car@3.2.4/node_modules/@ipld/car/esm/lib/reader.js
var fsread = (0, import_util.promisify)(import_fs.default.read);
var CarReader2 = class extends CarReader {
  static readRaw(fd, blockIndex) {
    return __async(this, null, function* () {
      const { cid, blockLength, blockOffset } = blockIndex;
      const bytes = new Uint8Array(blockLength);
      let read2;
      if (typeof fd === "number") {
        read2 = (yield fsread(fd, bytes, 0, blockLength, blockOffset)).bytesRead;
      } else if (typeof fd === "object" && typeof fd.read === "function") {
        read2 = (yield fd.read(bytes, 0, blockLength, blockOffset)).bytesRead;
      } else {
        throw new TypeError("Bad fd");
      }
      if (read2 !== blockLength) {
        throw new Error(`Failed to read entire block (${read2} instead of ${blockLength})`);
      }
      return {
        cid,
        bytes
      };
    });
  }
};

// ../../node_modules/.pnpm/@ipld+car@3.2.4/node_modules/@ipld/car/esm/lib/indexer.js
var CarIndexer = class {
  constructor(version2, roots, iterator) {
    this._version = version2;
    this._roots = roots;
    this._iterator = iterator;
  }
  get version() {
    return this._version;
  }
  getRoots() {
    return __async(this, null, function* () {
      return this._roots;
    });
  }
  [Symbol.asyncIterator]() {
    return this._iterator;
  }
  static fromBytes(bytes) {
    return __async(this, null, function* () {
      if (!(bytes instanceof Uint8Array)) {
        throw new TypeError("fromBytes() requires a Uint8Array");
      }
      return decodeIndexerComplete(bytesReader(bytes));
    });
  }
  static fromIterable(asyncIterable) {
    return __async(this, null, function* () {
      if (!asyncIterable || !(typeof asyncIterable[Symbol.asyncIterator] === "function")) {
        throw new TypeError("fromIterable() requires an async iterable");
      }
      return decodeIndexerComplete(asyncIterableReader(asyncIterable));
    });
  }
};
function decodeIndexerComplete(reader) {
  return __async(this, null, function* () {
    const decoder2 = createDecoder(reader);
    const { version: version2, roots } = yield decoder2.header();
    return new CarIndexer(version2, roots, decoder2.blocksIndex());
  });
}

// ../../node_modules/.pnpm/@ipld+car@3.2.4/node_modules/@ipld/car/esm/lib/iterator.js
var CarIteratorBase = class {
  constructor(version2, roots, iterable) {
    this._version = version2;
    this._roots = roots;
    this._iterable = iterable;
    this._decoded = false;
  }
  get version() {
    return this._version;
  }
  getRoots() {
    return __async(this, null, function* () {
      return this._roots;
    });
  }
};
var CarBlockIterator = class _CarBlockIterator extends CarIteratorBase {
  [Symbol.asyncIterator]() {
    if (this._decoded) {
      throw new Error("Cannot decode more than once");
    }
    if (!this._iterable) {
      throw new Error("Block iterable not found");
    }
    this._decoded = true;
    return this._iterable[Symbol.asyncIterator]();
  }
  static fromBytes(bytes) {
    return __async(this, null, function* () {
      const { version: version2, roots, iterator } = yield fromBytes(bytes);
      return new _CarBlockIterator(version2, roots, iterator);
    });
  }
  static fromIterable(asyncIterable) {
    return __async(this, null, function* () {
      const { version: version2, roots, iterator } = yield fromIterable(asyncIterable);
      return new _CarBlockIterator(version2, roots, iterator);
    });
  }
};
var CarCIDIterator = class _CarCIDIterator extends CarIteratorBase {
  [Symbol.asyncIterator]() {
    if (this._decoded) {
      throw new Error("Cannot decode more than once");
    }
    if (!this._iterable) {
      throw new Error("Block iterable not found");
    }
    this._decoded = true;
    const iterable = this._iterable[Symbol.asyncIterator]();
    return {
      next() {
        return __async(this, null, function* () {
          const next = yield iterable.next();
          if (next.done) {
            return next;
          }
          return {
            done: false,
            value: next.value.cid
          };
        });
      }
    };
  }
  static fromBytes(bytes) {
    return __async(this, null, function* () {
      const { version: version2, roots, iterator } = yield fromBytes(bytes);
      return new _CarCIDIterator(version2, roots, iterator);
    });
  }
  static fromIterable(asyncIterable) {
    return __async(this, null, function* () {
      const { version: version2, roots, iterator } = yield fromIterable(asyncIterable);
      return new _CarCIDIterator(version2, roots, iterator);
    });
  }
};
function fromBytes(bytes) {
  return __async(this, null, function* () {
    if (!(bytes instanceof Uint8Array)) {
      throw new TypeError("fromBytes() requires a Uint8Array");
    }
    return decodeIterator(bytesReader(bytes));
  });
}
function fromIterable(asyncIterable) {
  return __async(this, null, function* () {
    if (!asyncIterable || !(typeof asyncIterable[Symbol.asyncIterator] === "function")) {
      throw new TypeError("fromIterable() requires an async iterable");
    }
    return decodeIterator(asyncIterableReader(asyncIterable));
  });
}
function decodeIterator(reader) {
  return __async(this, null, function* () {
    const decoder2 = createDecoder(reader);
    const { version: version2, roots } = yield decoder2.header();
    return {
      version: version2,
      roots,
      iterator: decoder2.blocks()
    };
  });
}

// ../../node_modules/.pnpm/@ipld+car@3.2.4/node_modules/@ipld/car/esm/lib/writer.js
var import_fs2 = __toESM(require("fs"), 1);
var import_util2 = require("util");

// ../../node_modules/.pnpm/@ipld+car@3.2.4/node_modules/@ipld/car/esm/lib/encoder.js
var import_varint3 = __toESM(require_varint(), 1);
function createHeader(roots) {
  const headerBytes = encode4({
    version: 1,
    roots
  });
  const varintBytes = import_varint3.default.encode(headerBytes.length);
  const header = new Uint8Array(varintBytes.length + headerBytes.length);
  header.set(varintBytes, 0);
  header.set(headerBytes, varintBytes.length);
  return header;
}
function createEncoder(writer) {
  return {
    setRoots(roots) {
      return __async(this, null, function* () {
        const bytes = createHeader(roots);
        yield writer.write(bytes);
      });
    },
    writeBlock(block) {
      return __async(this, null, function* () {
        const { cid, bytes } = block;
        yield writer.write(new Uint8Array(import_varint3.default.encode(cid.bytes.length + bytes.length)));
        yield writer.write(cid.bytes);
        if (bytes.length) {
          yield writer.write(bytes);
        }
      });
    },
    close() {
      return __async(this, null, function* () {
        return writer.end();
      });
    }
  };
}

// ../../node_modules/.pnpm/@ipld+car@3.2.4/node_modules/@ipld/car/esm/lib/iterator-channel.js
function noop() {
}
function create2() {
  const chunkQueue = [];
  let drainer = null;
  let drainerResolver = noop;
  let ended = false;
  let outWait = null;
  let outWaitResolver = noop;
  const makeDrainer = () => {
    if (!drainer) {
      drainer = new Promise((resolve) => {
        drainerResolver = () => {
          drainer = null;
          drainerResolver = noop;
          resolve();
        };
      });
    }
    return drainer;
  };
  const writer = {
    write(chunk) {
      chunkQueue.push(chunk);
      const drainer2 = makeDrainer();
      outWaitResolver();
      return drainer2;
    },
    end() {
      return __async(this, null, function* () {
        ended = true;
        const drainer2 = makeDrainer();
        outWaitResolver();
        return drainer2;
      });
    }
  };
  const iterator = {
    next() {
      return __async(this, null, function* () {
        const chunk = chunkQueue.shift();
        if (chunk) {
          if (chunkQueue.length === 0) {
            drainerResolver();
          }
          return {
            done: false,
            value: chunk
          };
        }
        if (ended) {
          drainerResolver();
          return {
            done: true,
            value: void 0
          };
        }
        if (!outWait) {
          outWait = new Promise((resolve) => {
            outWaitResolver = () => {
              outWait = null;
              outWaitResolver = noop;
              return resolve(iterator.next());
            };
          });
        }
        return outWait;
      });
    }
  };
  return {
    writer,
    iterator
  };
}

// ../../node_modules/.pnpm/@ipld+car@3.2.4/node_modules/@ipld/car/esm/lib/writer-browser.js
var CarWriter = class _CarWriter {
  constructor(roots, encoder2) {
    this._encoder = encoder2;
    this._mutex = encoder2.setRoots(roots);
    this._ended = false;
  }
  put(block) {
    return __async(this, null, function* () {
      if (!(block.bytes instanceof Uint8Array) || !block.cid) {
        throw new TypeError("Can only write {cid, bytes} objects");
      }
      if (this._ended) {
        throw new Error("Already closed");
      }
      const cid = CID.asCID(block.cid);
      if (!cid) {
        throw new TypeError("Can only write {cid, bytes} objects");
      }
      this._mutex = this._mutex.then(() => this._encoder.writeBlock({
        cid,
        bytes: block.bytes
      }));
      return this._mutex;
    });
  }
  close() {
    return __async(this, null, function* () {
      if (this._ended) {
        throw new Error("Already closed");
      }
      yield this._mutex;
      this._ended = true;
      return this._encoder.close();
    });
  }
  static create(roots) {
    roots = toRoots(roots);
    const { encoder: encoder2, iterator } = encodeWriter();
    const writer = new _CarWriter(roots, encoder2);
    const out = new CarWriterOut(iterator);
    return {
      writer,
      out
    };
  }
  static createAppender() {
    const { encoder: encoder2, iterator } = encodeWriter();
    encoder2.setRoots = () => Promise.resolve();
    const writer = new _CarWriter([], encoder2);
    const out = new CarWriterOut(iterator);
    return {
      writer,
      out
    };
  }
  static updateRootsInBytes(bytes, roots) {
    return __async(this, null, function* () {
      const reader = bytesReader(bytes);
      yield readHeader(reader);
      const newHeader = createHeader(roots);
      if (reader.pos !== newHeader.length) {
        throw new Error(`updateRoots() can only overwrite a header of the same length (old header is ${reader.pos} bytes, new header is ${newHeader.length} bytes)`);
      }
      bytes.set(newHeader, 0);
      return bytes;
    });
  }
};
var CarWriterOut = class {
  constructor(iterator) {
    this._iterator = iterator;
  }
  [Symbol.asyncIterator]() {
    if (this._iterating) {
      throw new Error("Multiple iterator not supported");
    }
    this._iterating = true;
    return this._iterator;
  }
};
function encodeWriter() {
  const iw = create2();
  const { writer, iterator } = iw;
  const encoder2 = createEncoder(writer);
  return {
    encoder: encoder2,
    iterator
  };
}
function toRoots(roots) {
  if (roots === void 0) {
    return [];
  }
  if (!Array.isArray(roots)) {
    const cid = CID.asCID(roots);
    if (!cid) {
      throw new TypeError("roots must be a single CID or an array of CIDs");
    }
    return [cid];
  }
  const _roots = [];
  for (const root of roots) {
    const _root = CID.asCID(root);
    if (!_root) {
      throw new TypeError("roots must be a single CID or an array of CIDs");
    }
    _roots.push(_root);
  }
  return _roots;
}

// ../../node_modules/.pnpm/@ipld+car@3.2.4/node_modules/@ipld/car/esm/lib/writer.js
var fsread2 = (0, import_util2.promisify)(import_fs2.default.read);
var fswrite = (0, import_util2.promisify)(import_fs2.default.write);
var CarWriter2 = class extends CarWriter {
  static updateRootsInFile(fd, roots) {
    return __async(this, null, function* () {
      const chunkSize = 256;
      let bytes;
      let offset = 0;
      let readChunk;
      if (typeof fd === "number") {
        readChunk = () => __async(this, null, function* () {
          return (yield fsread2(fd, bytes, 0, chunkSize, offset)).bytesRead;
        });
      } else if (typeof fd === "object" && typeof fd.read === "function") {
        readChunk = () => __async(this, null, function* () {
          return (yield fd.read(bytes, 0, chunkSize, offset)).bytesRead;
        });
      } else {
        throw new TypeError("Bad fd");
      }
      const fdReader = chunkReader(() => __async(this, null, function* () {
        bytes = new Uint8Array(chunkSize);
        const read2 = yield readChunk();
        offset += read2;
        return read2 < chunkSize ? bytes.subarray(0, read2) : bytes;
      }));
      yield readHeader(fdReader);
      const newHeader = createHeader(roots);
      if (fdReader.pos !== newHeader.length) {
        throw new Error(`updateRoots() can only overwrite a header of the same length (old header is ${fdReader.pos} bytes, new header is ${newHeader.length} bytes)`);
      }
      if (typeof fd === "number") {
        yield fswrite(fd, newHeader, 0, newHeader.length, 0);
      } else if (typeof fd === "object" && typeof fd.read === "function") {
        yield fd.write(newHeader, 0, newHeader.length, 0);
      }
    });
  }
};

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/hashes/hasher.js
var from2 = ({ name: name5, code: code5, encode: encode12 }) => new Hasher(name5, code5, encode12);
var Hasher = class {
  constructor(name5, code5, encode12) {
    this.name = name5;
    this.code = code5;
    this.encode = encode12;
  }
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create(this.code, result) : result.then((digest2) => create(this.code, digest2));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/block.js
var readonly2 = ({ enumerable = true, configurable = false } = {}) => ({
  enumerable,
  configurable,
  writable: false
});
var links = function* (source, base3) {
  if (source == null)
    return;
  if (source instanceof Uint8Array)
    return;
  for (const [key, value] of Object.entries(source)) {
    const path = [
      ...base3,
      key
    ];
    if (value != null && typeof value === "object") {
      if (Array.isArray(value)) {
        for (const [index, element] of value.entries()) {
          const elementPath = [
            ...path,
            index
          ];
          const cid = CID.asCID(element);
          if (cid) {
            yield [
              elementPath.join("/"),
              cid
            ];
          } else if (typeof element === "object") {
            yield* __yieldStar(links(element, elementPath));
          }
        }
      } else {
        const cid = CID.asCID(value);
        if (cid) {
          yield [
            path.join("/"),
            cid
          ];
        } else {
          yield* __yieldStar(links(value, path));
        }
      }
    }
  }
};
var tree = function* (source, base3) {
  if (source == null)
    return;
  for (const [key, value] of Object.entries(source)) {
    const path = [
      ...base3,
      key
    ];
    yield path.join("/");
    if (value != null && !(value instanceof Uint8Array) && typeof value === "object" && !CID.asCID(value)) {
      if (Array.isArray(value)) {
        for (const [index, element] of value.entries()) {
          const elementPath = [
            ...path,
            index
          ];
          yield elementPath.join("/");
          if (typeof element === "object" && !CID.asCID(element)) {
            yield* __yieldStar(tree(element, elementPath));
          }
        }
      } else {
        yield* __yieldStar(tree(value, path));
      }
    }
  }
};
var get = (source, path) => {
  let node = source;
  for (const [index, key] of path.entries()) {
    node = node[key];
    if (node == null) {
      throw new Error(`Object has no property at ${path.slice(0, index + 1).map((part) => `[${JSON.stringify(part)}]`).join("")}`);
    }
    const cid = CID.asCID(node);
    if (cid) {
      return {
        value: cid,
        remaining: path.slice(index + 1).join("/")
      };
    }
  }
  return { value: node };
};
var Block = class {
  constructor({ cid, bytes, value }) {
    if (!cid || !bytes || typeof value === "undefined")
      throw new Error("Missing required argument");
    this.cid = cid;
    this.bytes = bytes;
    this.value = value;
    this.asBlock = this;
    Object.defineProperties(this, {
      cid: readonly2(),
      bytes: readonly2(),
      value: readonly2(),
      asBlock: readonly2()
    });
  }
  links() {
    return links(this.value, []);
  }
  tree() {
    return tree(this.value, []);
  }
  get(path = "/") {
    return get(this.value, path.split("/").filter(Boolean));
  }
};
var encode5 = (_0) => __async(void 0, [_0], function* ({ value, codec, hasher }) {
  if (typeof value === "undefined")
    throw new Error('Missing required argument "value"');
  if (!codec || !hasher)
    throw new Error("Missing required argument: codec or hasher");
  const bytes = codec.encode(value);
  const hash = yield hasher.digest(bytes);
  const cid = CID.create(1, codec.code, hash);
  return new Block({
    value,
    bytes,
    cid
  });
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/codecs/raw.js
var raw_exports = {};
__export(raw_exports, {
  code: () => code,
  decode: () => decode7,
  encode: () => encode6,
  name: () => name
});
var name = "raw";
var code = 85;
var encode6 = (node) => coerce(node);
var decode7 = (data) => coerce(data);

// ../../node_modules/.pnpm/@ipld+dag-cbor@6.0.15/node_modules/@ipld/dag-cbor/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  code: () => code2,
  decode: () => decode8,
  encode: () => encode7,
  name: () => name2
});
var CID_CBOR_TAG2 = 42;
function cidEncoder2(obj) {
  if (obj.asCID !== obj) {
    return null;
  }
  const cid = CID.asCID(obj);
  if (!cid) {
    return null;
  }
  const bytes = new Uint8Array(cid.bytes.byteLength + 1);
  bytes.set(cid.bytes, 1);
  return [
    new Token(Type.tag, CID_CBOR_TAG2),
    new Token(Type.bytes, bytes)
  ];
}
function undefinedEncoder2() {
  throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded");
}
function numberEncoder2(num) {
  if (Number.isNaN(num)) {
    throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded");
  }
  if (num === Infinity || num === -Infinity) {
    throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded");
  }
  return null;
}
var encodeOptions2 = {
  float64: true,
  typeEncoders: {
    Object: cidEncoder2,
    undefined: undefinedEncoder2,
    number: numberEncoder2
  }
};
function cidDecoder2(bytes) {
  if (bytes[0] !== 0) {
    throw new Error("Invalid CID for CBOR tag 42; expected leading 0x00");
  }
  return CID.decode(bytes.subarray(1));
}
var decodeOptions2 = {
  allowIndefinite: false,
  allowUndefined: false,
  allowNaN: false,
  allowInfinity: false,
  allowBigInt: true,
  strict: true,
  useMaps: false,
  tags: []
};
decodeOptions2.tags[CID_CBOR_TAG2] = cidDecoder2;
var name2 = "dag-cbor";
var code2 = 113;
var encode7 = (node) => encode3(node, encodeOptions2);
var decode8 = (data) => decode5(data, decodeOptions2);

// ../../node_modules/.pnpm/@ipld+dag-pb@2.1.18/node_modules/@ipld/dag-pb/esm/src/index.js
var src_exports = {};
__export(src_exports, {
  code: () => code3,
  createLink: () => createLink,
  createNode: () => createNode,
  decode: () => decode9,
  encode: () => encode8,
  name: () => name3,
  prepare: () => prepare,
  validate: () => validate
});

// ../../node_modules/.pnpm/@ipld+dag-pb@2.1.18/node_modules/@ipld/dag-pb/esm/src/pb-decode.js
var textDecoder2 = new TextDecoder();
function decodeVarint(bytes, offset) {
  let v = 0;
  for (let shift = 0; ; shift += 7) {
    if (shift >= 64) {
      throw new Error("protobuf: varint overflow");
    }
    if (offset >= bytes.length) {
      throw new Error("protobuf: unexpected end of data");
    }
    const b = bytes[offset++];
    v += shift < 28 ? (b & 127) << shift : (b & 127) * 2 ** shift;
    if (b < 128) {
      break;
    }
  }
  return [
    v,
    offset
  ];
}
function decodeBytes(bytes, offset) {
  let byteLen;
  [byteLen, offset] = decodeVarint(bytes, offset);
  const postOffset = offset + byteLen;
  if (byteLen < 0 || postOffset < 0) {
    throw new Error("protobuf: invalid length");
  }
  if (postOffset > bytes.length) {
    throw new Error("protobuf: unexpected end of data");
  }
  return [
    bytes.subarray(offset, postOffset),
    postOffset
  ];
}
function decodeKey(bytes, index) {
  let wire;
  [wire, index] = decodeVarint(bytes, index);
  return [
    wire & 7,
    wire >> 3,
    index
  ];
}
function decodeLink(bytes) {
  const link = {};
  const l = bytes.length;
  let index = 0;
  while (index < l) {
    let wireType, fieldNum;
    [wireType, fieldNum, index] = decodeKey(bytes, index);
    if (fieldNum === 1) {
      if (link.Hash) {
        throw new Error("protobuf: (PBLink) duplicate Hash section");
      }
      if (wireType !== 2) {
        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Hash`);
      }
      if (link.Name !== void 0) {
        throw new Error("protobuf: (PBLink) invalid order, found Name before Hash");
      }
      if (link.Tsize !== void 0) {
        throw new Error("protobuf: (PBLink) invalid order, found Tsize before Hash");
      }
      ;
      [link.Hash, index] = decodeBytes(bytes, index);
    } else if (fieldNum === 2) {
      if (link.Name !== void 0) {
        throw new Error("protobuf: (PBLink) duplicate Name section");
      }
      if (wireType !== 2) {
        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Name`);
      }
      if (link.Tsize !== void 0) {
        throw new Error("protobuf: (PBLink) invalid order, found Tsize before Name");
      }
      let byts;
      [byts, index] = decodeBytes(bytes, index);
      link.Name = textDecoder2.decode(byts);
    } else if (fieldNum === 3) {
      if (link.Tsize !== void 0) {
        throw new Error("protobuf: (PBLink) duplicate Tsize section");
      }
      if (wireType !== 0) {
        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Tsize`);
      }
      ;
      [link.Tsize, index] = decodeVarint(bytes, index);
    } else {
      throw new Error(`protobuf: (PBLink) invalid fieldNumber, expected 1, 2 or 3, got ${fieldNum}`);
    }
  }
  if (index > l) {
    throw new Error("protobuf: (PBLink) unexpected end of data");
  }
  return link;
}
function decodeNode(bytes) {
  const l = bytes.length;
  let index = 0;
  let links2;
  let linksBeforeData = false;
  let data;
  while (index < l) {
    let wireType, fieldNum;
    [wireType, fieldNum, index] = decodeKey(bytes, index);
    if (wireType !== 2) {
      throw new Error(`protobuf: (PBNode) invalid wireType, expected 2, got ${wireType}`);
    }
    if (fieldNum === 1) {
      if (data) {
        throw new Error("protobuf: (PBNode) duplicate Data section");
      }
      ;
      [data, index] = decodeBytes(bytes, index);
      if (links2) {
        linksBeforeData = true;
      }
    } else if (fieldNum === 2) {
      if (linksBeforeData) {
        throw new Error("protobuf: (PBNode) duplicate Links section");
      } else if (!links2) {
        links2 = [];
      }
      let byts;
      [byts, index] = decodeBytes(bytes, index);
      links2.push(decodeLink(byts));
    } else {
      throw new Error(`protobuf: (PBNode) invalid fieldNumber, expected 1 or 2, got ${fieldNum}`);
    }
  }
  if (index > l) {
    throw new Error("protobuf: (PBNode) unexpected end of data");
  }
  const node = {};
  if (data) {
    node.Data = data;
  }
  node.Links = links2 || [];
  return node;
}

// ../../node_modules/.pnpm/@ipld+dag-pb@2.1.18/node_modules/@ipld/dag-pb/esm/src/pb-encode.js
var textEncoder2 = new TextEncoder();
var maxInt32 = 2 ** 32;
var maxUInt32 = 2 ** 31;
function encodeLink(link, bytes) {
  let i = bytes.length;
  if (typeof link.Tsize === "number") {
    if (link.Tsize < 0) {
      throw new Error("Tsize cannot be negative");
    }
    if (!Number.isSafeInteger(link.Tsize)) {
      throw new Error("Tsize too large for encoding");
    }
    i = encodeVarint(bytes, i, link.Tsize) - 1;
    bytes[i] = 24;
  }
  if (typeof link.Name === "string") {
    const nameBytes = textEncoder2.encode(link.Name);
    i -= nameBytes.length;
    bytes.set(nameBytes, i);
    i = encodeVarint(bytes, i, nameBytes.length) - 1;
    bytes[i] = 18;
  }
  if (link.Hash) {
    i -= link.Hash.length;
    bytes.set(link.Hash, i);
    i = encodeVarint(bytes, i, link.Hash.length) - 1;
    bytes[i] = 10;
  }
  return bytes.length - i;
}
function encodeNode(node) {
  const size = sizeNode(node);
  const bytes = new Uint8Array(size);
  let i = size;
  if (node.Data) {
    i -= node.Data.length;
    bytes.set(node.Data, i);
    i = encodeVarint(bytes, i, node.Data.length) - 1;
    bytes[i] = 10;
  }
  if (node.Links) {
    for (let index = node.Links.length - 1; index >= 0; index--) {
      const size2 = encodeLink(node.Links[index], bytes.subarray(0, i));
      i -= size2;
      i = encodeVarint(bytes, i, size2) - 1;
      bytes[i] = 18;
    }
  }
  return bytes;
}
function sizeLink(link) {
  let n = 0;
  if (link.Hash) {
    const l = link.Hash.length;
    n += 1 + l + sov(l);
  }
  if (typeof link.Name === "string") {
    const l = textEncoder2.encode(link.Name).length;
    n += 1 + l + sov(l);
  }
  if (typeof link.Tsize === "number") {
    n += 1 + sov(link.Tsize);
  }
  return n;
}
function sizeNode(node) {
  let n = 0;
  if (node.Data) {
    const l = node.Data.length;
    n += 1 + l + sov(l);
  }
  if (node.Links) {
    for (const link of node.Links) {
      const l = sizeLink(link);
      n += 1 + l + sov(l);
    }
  }
  return n;
}
function encodeVarint(bytes, offset, v) {
  offset -= sov(v);
  const base3 = offset;
  while (v >= maxUInt32) {
    bytes[offset++] = v & 127 | 128;
    v /= 128;
  }
  while (v >= 128) {
    bytes[offset++] = v & 127 | 128;
    v >>>= 7;
  }
  bytes[offset] = v;
  return base3;
}
function sov(x) {
  if (x % 2 === 0) {
    x++;
  }
  return Math.floor((len64(x) + 6) / 7);
}
function len64(x) {
  let n = 0;
  if (x >= maxInt32) {
    x = Math.floor(x / maxInt32);
    n = 32;
  }
  if (x >= 1 << 16) {
    x >>>= 16;
    n += 16;
  }
  if (x >= 1 << 8) {
    x >>>= 8;
    n += 8;
  }
  return n + len8tab[x];
}
var len8tab = [
  0,
  1,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8
];

// ../../node_modules/.pnpm/@ipld+dag-pb@2.1.18/node_modules/@ipld/dag-pb/esm/src/util.js
var pbNodeProperties = [
  "Data",
  "Links"
];
var pbLinkProperties = [
  "Hash",
  "Name",
  "Tsize"
];
var textEncoder3 = new TextEncoder();
function linkComparator(a, b) {
  if (a === b) {
    return 0;
  }
  const abuf = a.Name ? textEncoder3.encode(a.Name) : [];
  const bbuf = b.Name ? textEncoder3.encode(b.Name) : [];
  let x = abuf.length;
  let y = bbuf.length;
  for (let i = 0, len = Math.min(x, y); i < len; ++i) {
    if (abuf[i] !== bbuf[i]) {
      x = abuf[i];
      y = bbuf[i];
      break;
    }
  }
  return x < y ? -1 : y < x ? 1 : 0;
}
function hasOnlyProperties(node, properties) {
  return !Object.keys(node).some((p) => !properties.includes(p));
}
function asLink(link) {
  if (typeof link.asCID === "object") {
    const Hash = CID.asCID(link);
    if (!Hash) {
      throw new TypeError("Invalid DAG-PB form");
    }
    return { Hash };
  }
  if (typeof link !== "object" || Array.isArray(link)) {
    throw new TypeError("Invalid DAG-PB form");
  }
  const pbl = {};
  if (link.Hash) {
    let cid = CID.asCID(link.Hash);
    try {
      if (!cid) {
        if (typeof link.Hash === "string") {
          cid = CID.parse(link.Hash);
        } else if (link.Hash instanceof Uint8Array) {
          cid = CID.decode(link.Hash);
        }
      }
    } catch (e) {
      throw new TypeError(`Invalid DAG-PB form: ${e.message}`);
    }
    if (cid) {
      pbl.Hash = cid;
    }
  }
  if (!pbl.Hash) {
    throw new TypeError("Invalid DAG-PB form");
  }
  if (typeof link.Name === "string") {
    pbl.Name = link.Name;
  }
  if (typeof link.Tsize === "number") {
    pbl.Tsize = link.Tsize;
  }
  return pbl;
}
function prepare(node) {
  if (node instanceof Uint8Array || typeof node === "string") {
    node = { Data: node };
  }
  if (typeof node !== "object" || Array.isArray(node)) {
    throw new TypeError("Invalid DAG-PB form");
  }
  const pbn = {};
  if (node.Data !== void 0) {
    if (typeof node.Data === "string") {
      pbn.Data = textEncoder3.encode(node.Data);
    } else if (node.Data instanceof Uint8Array) {
      pbn.Data = node.Data;
    } else {
      throw new TypeError("Invalid DAG-PB form");
    }
  }
  if (node.Links !== void 0) {
    if (Array.isArray(node.Links)) {
      pbn.Links = node.Links.map(asLink);
      pbn.Links.sort(linkComparator);
    } else {
      throw new TypeError("Invalid DAG-PB form");
    }
  } else {
    pbn.Links = [];
  }
  return pbn;
}
function validate(node) {
  if (!node || typeof node !== "object" || Array.isArray(node)) {
    throw new TypeError("Invalid DAG-PB form");
  }
  if (!hasOnlyProperties(node, pbNodeProperties)) {
    throw new TypeError("Invalid DAG-PB form (extraneous properties)");
  }
  if (node.Data !== void 0 && !(node.Data instanceof Uint8Array)) {
    throw new TypeError("Invalid DAG-PB form (Data must be a Uint8Array)");
  }
  if (!Array.isArray(node.Links)) {
    throw new TypeError("Invalid DAG-PB form (Links must be an array)");
  }
  for (let i = 0; i < node.Links.length; i++) {
    const link = node.Links[i];
    if (!link || typeof link !== "object" || Array.isArray(link)) {
      throw new TypeError("Invalid DAG-PB form (bad link object)");
    }
    if (!hasOnlyProperties(link, pbLinkProperties)) {
      throw new TypeError("Invalid DAG-PB form (extraneous properties on link object)");
    }
    if (!link.Hash) {
      throw new TypeError("Invalid DAG-PB form (link must have a Hash)");
    }
    if (link.Hash.asCID !== link.Hash) {
      throw new TypeError("Invalid DAG-PB form (link Hash must be a CID)");
    }
    if (link.Name !== void 0 && typeof link.Name !== "string") {
      throw new TypeError("Invalid DAG-PB form (link Name must be a string)");
    }
    if (link.Tsize !== void 0 && (typeof link.Tsize !== "number" || link.Tsize % 1 !== 0)) {
      throw new TypeError("Invalid DAG-PB form (link Tsize must be an integer)");
    }
    if (i > 0 && linkComparator(link, node.Links[i - 1]) === -1) {
      throw new TypeError("Invalid DAG-PB form (links must be sorted by Name bytes)");
    }
  }
}
function createNode(data, links2 = []) {
  return prepare({
    Data: data,
    Links: links2
  });
}
function createLink(name5, size, cid) {
  return asLink({
    Hash: cid,
    Name: name5,
    Tsize: size
  });
}

// ../../node_modules/.pnpm/@ipld+dag-pb@2.1.18/node_modules/@ipld/dag-pb/esm/src/index.js
var name3 = "dag-pb";
var code3 = 112;
function encode8(node) {
  validate(node);
  const pbn = {};
  if (node.Links) {
    pbn.Links = node.Links.map((l) => {
      const link = {};
      if (l.Hash) {
        link.Hash = l.Hash.bytes;
      }
      if (l.Name !== void 0) {
        link.Name = l.Name;
      }
      if (l.Tsize !== void 0) {
        link.Tsize = l.Tsize;
      }
      return link;
    });
  }
  if (node.Data) {
    pbn.Data = node.Data;
  }
  return encodeNode(pbn);
}
function decode9(bytes) {
  const pbn = decodeNode(bytes);
  const node = {};
  if (pbn.Data) {
    node.Data = pbn.Data;
  }
  if (pbn.Links) {
    node.Links = pbn.Links.map((l) => {
      const link = {};
      try {
        link.Hash = CID.decode(l.Hash);
      } catch (e) {
      }
      if (!link.Hash) {
        throw new Error("Invalid Hash field found in link, expected CID");
      }
      if (l.Name !== void 0) {
        link.Name = l.Name;
      }
      if (l.Tsize !== void 0) {
        link.Tsize = l.Tsize;
      }
      return link;
    });
  }
  return node;
}

// ../../node_modules/.pnpm/carbites@1.0.6/node_modules/carbites/esm/lib/treewalk/splitter.js
var TreewalkCarSplitter = class _TreewalkCarSplitter {
  constructor(reader, targetSize, options = {}) {
    if (typeof targetSize !== "number" || targetSize <= 0) {
      throw new Error("invalid target chunk size");
    }
    this._reader = reader;
    this._targetSize = targetSize;
    this._decoders = [
      src_exports,
      raw_exports,
      esm_exports,
      ...options.decoders || []
    ];
  }
  cars() {
    return __asyncGenerator(this, null, function* () {
      const roots = yield new __await(this._reader.getRoots());
      if (roots.length !== 1)
        throw new Error(`unexpected number of roots: ${roots.length}`);
      let channel;
      try {
        for (var iter = __forAwait(this._cars(roots[0])), more, temp, error; more = !(temp = yield new __await(iter.next())).done; more = false) {
          const val = temp.value;
          channel = val.channel;
          if (val.out)
            yield val.out;
        }
      } catch (temp) {
        error = [temp];
      } finally {
        try {
          more && (temp = iter.return) && (yield new __await(temp.call(iter)));
        } finally {
          if (error)
            throw error[0];
        }
      }
      if (!channel) {
        throw new Error("missing CAR writer channel");
      }
      channel.writer.close();
      yield channel.out;
    });
  }
  _get(cid) {
    return __async(this, null, function* () {
      const rawBlock = yield this._reader.get(cid);
      if (!rawBlock)
        throw new Error(`missing block for ${cid}`);
      const { bytes } = rawBlock;
      const decoder2 = this._decoders.find((d) => d.code === cid.code);
      if (!decoder2)
        throw new Error(`missing decoder for ${cid.code}`);
      return new Block({
        cid,
        bytes,
        value: decoder2.decode(bytes)
      });
    });
  }
  _cars(_0) {
    return __asyncGenerator(this, arguments, function* (cid, parents = [], channel = void 0) {
      const block = yield new __await(this._get(cid));
      channel = channel || Object.assign(CarWriter2.create(cid), { size: 0 });
      if (channel.size > 0 && channel.size + block.bytes.byteLength >= this._targetSize) {
        channel.writer.close();
        const { out } = channel;
        channel = newCar(parents);
        yield {
          channel,
          out
        };
      }
      parents = parents.concat(block);
      channel.size += block.bytes.byteLength;
      channel.writer.put(block);
      for (const [, cid2] of block.links()) {
        try {
          for (var iter = __forAwait(this._cars(cid2, parents, channel)), more, temp, error; more = !(temp = yield new __await(iter.next())).done; more = false) {
            const val = temp.value;
            channel = val.channel;
            yield val;
          }
        } catch (temp) {
          error = [temp];
        } finally {
          try {
            more && (temp = iter.return) && (yield new __await(temp.call(iter)));
          } finally {
            if (error)
              throw error[0];
          }
        }
      }
      if (!channel) {
        throw new Error("missing CAR writer channel");
      }
      yield { channel };
    });
  }
  static fromIterable(iterable, targetSize, options) {
    return __async(this, null, function* () {
      const reader = yield CarReader2.fromIterable(iterable);
      return new _TreewalkCarSplitter(reader, targetSize, options);
    });
  }
  static fromBlob(blob, targetSize, options) {
    return __async(this, null, function* () {
      const buffer2 = yield blob.arrayBuffer();
      const reader = yield CarReader2.fromBytes(new Uint8Array(buffer2));
      return new _TreewalkCarSplitter(reader, targetSize, options);
    });
  }
};
function newCar(parents) {
  const ch = Object.assign(CarWriter2.create(parents[0].cid), { size: parents.reduce((size, b) => size + b.bytes.byteLength, 0) });
  for (const b of parents) {
    ch.writer.put(b);
  }
  return ch;
}

// ../../node_modules/.pnpm/ipfs-car@0.6.2_node-fetch@3.3.2/node_modules/ipfs-car/dist/esm/pack/index.js
var import_it_last = __toESM(require_it_last(), 1);
var import_it_pipe = __toESM(require_it_pipe(), 1);

// ../../node_modules/.pnpm/ipfs-unixfs-importer@9.0.10/node_modules/ipfs-unixfs-importer/esm/src/index.js
var import_it_parallel_batch2 = __toESM(require_it_parallel_batch(), 1);

// ../../node_modules/.pnpm/merge-options@3.0.4/node_modules/merge-options/index.mjs
var import_index2 = __toESM(require_merge_options(), 1);
var merge_options_default = import_index2.default;

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/hashes/sha2.js
var sha2_exports = {};
__export(sha2_exports, {
  sha256: () => sha256,
  sha512: () => sha512
});
var import_crypto = __toESM(require("crypto"), 1);
var sha256 = from2({
  name: "sha2-256",
  code: 18,
  encode: (input) => coerce(import_crypto.default.createHash("sha256").update(input).digest())
});
var sha512 = from2({
  name: "sha2-512",
  code: 19,
  encode: (input) => coerce(import_crypto.default.createHash("sha512").update(input).digest())
});

// ../../node_modules/.pnpm/@multiformats+murmur3@1.1.3/node_modules/@multiformats/murmur3/esm/index.js
var import_murmurhash3js_revisited = __toESM(require_murmurhash3js_revisited(), 1);
function fromNumberTo32BitBuf(number) {
  const bytes = new Array(4);
  for (let i = 0; i < 4; i++) {
    bytes[i] = number & 255;
    number = number >> 8;
  }
  return new Uint8Array(bytes);
}
var murmur332 = from2({
  name: "murmur3-32",
  code: 35,
  encode: (input) => fromNumberTo32BitBuf(import_murmurhash3js_revisited.default.x86.hash32(input))
});
var murmur3128 = from2({
  name: "murmur3-128",
  code: 34,
  encode: (input) => bytes_exports.fromHex(import_murmurhash3js_revisited.default.x64.hash128(input))
});

// ../../node_modules/.pnpm/ipfs-unixfs-importer@9.0.10/node_modules/ipfs-unixfs-importer/esm/src/options.js
function hamtHashFn(buf2) {
  return __async(this, null, function* () {
    return (yield murmur3128.encode(buf2)).slice(0, 8).reverse();
  });
}
var defaultOptions = {
  chunker: "fixed",
  strategy: "balanced",
  rawLeaves: false,
  onlyHash: false,
  reduceSingleLeafToSelf: true,
  hasher: sha256,
  leafType: "file",
  cidVersion: 0,
  progress: () => () => {
  },
  shardSplitThreshold: 1e3,
  fileImportConcurrency: 50,
  blockWriteConcurrency: 10,
  minChunkSize: 262144,
  maxChunkSize: 262144,
  avgChunkSize: 262144,
  window: 16,
  polynomial: 17437180132763652,
  maxChildrenPerNode: 174,
  layerRepeat: 4,
  wrapWithDirectory: false,
  recursive: false,
  hidden: false,
  timeout: void 0,
  hamtHashFn,
  hamtHashCode: 34,
  hamtBucketBits: 8
};
var options_default = (options = {}) => {
  const defaults = merge_options_default.bind({ ignoreUndefined: true });
  return defaults(defaultOptions, options);
};

// ../../node_modules/.pnpm/ipfs-unixfs@6.0.9/node_modules/ipfs-unixfs/esm/src/index.js
var import_err_code = __toESM(require_err_code(), 1);

// ../../node_modules/.pnpm/ipfs-unixfs@6.0.9/node_modules/ipfs-unixfs/esm/src/unixfs.js
var import_minimal = __toESM(require_minimal2(), 1);
var $Reader = import_minimal.default.Reader;
var $Writer = import_minimal.default.Writer;
var $util = import_minimal.default.util;
var $root = import_minimal.default.roots["ipfs-unixfs"] || (import_minimal.default.roots["ipfs-unixfs"] = {});
var Data = $root.Data = (() => {
  function Data2(p) {
    this.blocksizes = [];
    if (p) {
      for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
        if (p[ks[i]] != null)
          this[ks[i]] = p[ks[i]];
    }
  }
  Data2.prototype.Type = 0;
  Data2.prototype.Data = $util.newBuffer([]);
  Data2.prototype.filesize = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
  Data2.prototype.blocksizes = $util.emptyArray;
  Data2.prototype.hashType = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
  Data2.prototype.fanout = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
  Data2.prototype.mode = 0;
  Data2.prototype.mtime = null;
  Data2.encode = function encode12(m, w) {
    if (!w)
      w = $Writer.create();
    w.uint32(8).int32(m.Type);
    if (m.Data != null && Object.hasOwnProperty.call(m, "Data"))
      w.uint32(18).bytes(m.Data);
    if (m.filesize != null && Object.hasOwnProperty.call(m, "filesize"))
      w.uint32(24).uint64(m.filesize);
    if (m.blocksizes != null && m.blocksizes.length) {
      for (var i = 0; i < m.blocksizes.length; ++i)
        w.uint32(32).uint64(m.blocksizes[i]);
    }
    if (m.hashType != null && Object.hasOwnProperty.call(m, "hashType"))
      w.uint32(40).uint64(m.hashType);
    if (m.fanout != null && Object.hasOwnProperty.call(m, "fanout"))
      w.uint32(48).uint64(m.fanout);
    if (m.mode != null && Object.hasOwnProperty.call(m, "mode"))
      w.uint32(56).uint32(m.mode);
    if (m.mtime != null && Object.hasOwnProperty.call(m, "mtime"))
      $root.UnixTime.encode(m.mtime, w.uint32(66).fork()).ldelim();
    return w;
  };
  Data2.decode = function decode12(r, l) {
    if (!(r instanceof $Reader))
      r = $Reader.create(r);
    var c = l === void 0 ? r.len : r.pos + l, m = new $root.Data();
    while (r.pos < c) {
      var t = r.uint32();
      switch (t >>> 3) {
        case 1:
          m.Type = r.int32();
          break;
        case 2:
          m.Data = r.bytes();
          break;
        case 3:
          m.filesize = r.uint64();
          break;
        case 4:
          if (!(m.blocksizes && m.blocksizes.length))
            m.blocksizes = [];
          if ((t & 7) === 2) {
            var c2 = r.uint32() + r.pos;
            while (r.pos < c2)
              m.blocksizes.push(r.uint64());
          } else
            m.blocksizes.push(r.uint64());
          break;
        case 5:
          m.hashType = r.uint64();
          break;
        case 6:
          m.fanout = r.uint64();
          break;
        case 7:
          m.mode = r.uint32();
          break;
        case 8:
          m.mtime = $root.UnixTime.decode(r, r.uint32());
          break;
        default:
          r.skipType(t & 7);
          break;
      }
    }
    if (!m.hasOwnProperty("Type"))
      throw $util.ProtocolError("missing required 'Type'", { instance: m });
    return m;
  };
  Data2.fromObject = function fromObject(d) {
    if (d instanceof $root.Data)
      return d;
    var m = new $root.Data();
    switch (d.Type) {
      case "Raw":
      case 0:
        m.Type = 0;
        break;
      case "Directory":
      case 1:
        m.Type = 1;
        break;
      case "File":
      case 2:
        m.Type = 2;
        break;
      case "Metadata":
      case 3:
        m.Type = 3;
        break;
      case "Symlink":
      case 4:
        m.Type = 4;
        break;
      case "HAMTShard":
      case 5:
        m.Type = 5;
        break;
    }
    if (d.Data != null) {
      if (typeof d.Data === "string")
        $util.base64.decode(d.Data, m.Data = $util.newBuffer($util.base64.length(d.Data)), 0);
      else if (d.Data.length)
        m.Data = d.Data;
    }
    if (d.filesize != null) {
      if ($util.Long)
        (m.filesize = $util.Long.fromValue(d.filesize)).unsigned = true;
      else if (typeof d.filesize === "string")
        m.filesize = parseInt(d.filesize, 10);
      else if (typeof d.filesize === "number")
        m.filesize = d.filesize;
      else if (typeof d.filesize === "object")
        m.filesize = new $util.LongBits(d.filesize.low >>> 0, d.filesize.high >>> 0).toNumber(true);
    }
    if (d.blocksizes) {
      if (!Array.isArray(d.blocksizes))
        throw TypeError(".Data.blocksizes: array expected");
      m.blocksizes = [];
      for (var i = 0; i < d.blocksizes.length; ++i) {
        if ($util.Long)
          (m.blocksizes[i] = $util.Long.fromValue(d.blocksizes[i])).unsigned = true;
        else if (typeof d.blocksizes[i] === "string")
          m.blocksizes[i] = parseInt(d.blocksizes[i], 10);
        else if (typeof d.blocksizes[i] === "number")
          m.blocksizes[i] = d.blocksizes[i];
        else if (typeof d.blocksizes[i] === "object")
          m.blocksizes[i] = new $util.LongBits(d.blocksizes[i].low >>> 0, d.blocksizes[i].high >>> 0).toNumber(true);
      }
    }
    if (d.hashType != null) {
      if ($util.Long)
        (m.hashType = $util.Long.fromValue(d.hashType)).unsigned = true;
      else if (typeof d.hashType === "string")
        m.hashType = parseInt(d.hashType, 10);
      else if (typeof d.hashType === "number")
        m.hashType = d.hashType;
      else if (typeof d.hashType === "object")
        m.hashType = new $util.LongBits(d.hashType.low >>> 0, d.hashType.high >>> 0).toNumber(true);
    }
    if (d.fanout != null) {
      if ($util.Long)
        (m.fanout = $util.Long.fromValue(d.fanout)).unsigned = true;
      else if (typeof d.fanout === "string")
        m.fanout = parseInt(d.fanout, 10);
      else if (typeof d.fanout === "number")
        m.fanout = d.fanout;
      else if (typeof d.fanout === "object")
        m.fanout = new $util.LongBits(d.fanout.low >>> 0, d.fanout.high >>> 0).toNumber(true);
    }
    if (d.mode != null) {
      m.mode = d.mode >>> 0;
    }
    if (d.mtime != null) {
      if (typeof d.mtime !== "object")
        throw TypeError(".Data.mtime: object expected");
      m.mtime = $root.UnixTime.fromObject(d.mtime);
    }
    return m;
  };
  Data2.toObject = function toObject(m, o) {
    if (!o)
      o = {};
    var d = {};
    if (o.arrays || o.defaults) {
      d.blocksizes = [];
    }
    if (o.defaults) {
      d.Type = o.enums === String ? "Raw" : 0;
      if (o.bytes === String)
        d.Data = "";
      else {
        d.Data = [];
        if (o.bytes !== Array)
          d.Data = $util.newBuffer(d.Data);
      }
      if ($util.Long) {
        var n = new $util.Long(0, 0, true);
        d.filesize = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
      } else
        d.filesize = o.longs === String ? "0" : 0;
      if ($util.Long) {
        var n = new $util.Long(0, 0, true);
        d.hashType = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
      } else
        d.hashType = o.longs === String ? "0" : 0;
      if ($util.Long) {
        var n = new $util.Long(0, 0, true);
        d.fanout = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
      } else
        d.fanout = o.longs === String ? "0" : 0;
      d.mode = 0;
      d.mtime = null;
    }
    if (m.Type != null && m.hasOwnProperty("Type")) {
      d.Type = o.enums === String ? $root.Data.DataType[m.Type] : m.Type;
    }
    if (m.Data != null && m.hasOwnProperty("Data")) {
      d.Data = o.bytes === String ? $util.base64.encode(m.Data, 0, m.Data.length) : o.bytes === Array ? Array.prototype.slice.call(m.Data) : m.Data;
    }
    if (m.filesize != null && m.hasOwnProperty("filesize")) {
      if (typeof m.filesize === "number")
        d.filesize = o.longs === String ? String(m.filesize) : m.filesize;
      else
        d.filesize = o.longs === String ? $util.Long.prototype.toString.call(m.filesize) : o.longs === Number ? new $util.LongBits(m.filesize.low >>> 0, m.filesize.high >>> 0).toNumber(true) : m.filesize;
    }
    if (m.blocksizes && m.blocksizes.length) {
      d.blocksizes = [];
      for (var j = 0; j < m.blocksizes.length; ++j) {
        if (typeof m.blocksizes[j] === "number")
          d.blocksizes[j] = o.longs === String ? String(m.blocksizes[j]) : m.blocksizes[j];
        else
          d.blocksizes[j] = o.longs === String ? $util.Long.prototype.toString.call(m.blocksizes[j]) : o.longs === Number ? new $util.LongBits(m.blocksizes[j].low >>> 0, m.blocksizes[j].high >>> 0).toNumber(true) : m.blocksizes[j];
      }
    }
    if (m.hashType != null && m.hasOwnProperty("hashType")) {
      if (typeof m.hashType === "number")
        d.hashType = o.longs === String ? String(m.hashType) : m.hashType;
      else
        d.hashType = o.longs === String ? $util.Long.prototype.toString.call(m.hashType) : o.longs === Number ? new $util.LongBits(m.hashType.low >>> 0, m.hashType.high >>> 0).toNumber(true) : m.hashType;
    }
    if (m.fanout != null && m.hasOwnProperty("fanout")) {
      if (typeof m.fanout === "number")
        d.fanout = o.longs === String ? String(m.fanout) : m.fanout;
      else
        d.fanout = o.longs === String ? $util.Long.prototype.toString.call(m.fanout) : o.longs === Number ? new $util.LongBits(m.fanout.low >>> 0, m.fanout.high >>> 0).toNumber(true) : m.fanout;
    }
    if (m.mode != null && m.hasOwnProperty("mode")) {
      d.mode = m.mode;
    }
    if (m.mtime != null && m.hasOwnProperty("mtime")) {
      d.mtime = $root.UnixTime.toObject(m.mtime, o);
    }
    return d;
  };
  Data2.prototype.toJSON = function toJSON() {
    return this.constructor.toObject(this, import_minimal.default.util.toJSONOptions);
  };
  Data2.DataType = function() {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = "Raw"] = 0;
    values[valuesById[1] = "Directory"] = 1;
    values[valuesById[2] = "File"] = 2;
    values[valuesById[3] = "Metadata"] = 3;
    values[valuesById[4] = "Symlink"] = 4;
    values[valuesById[5] = "HAMTShard"] = 5;
    return values;
  }();
  return Data2;
})();
var UnixTime = $root.UnixTime = (() => {
  function UnixTime2(p) {
    if (p) {
      for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
        if (p[ks[i]] != null)
          this[ks[i]] = p[ks[i]];
    }
  }
  UnixTime2.prototype.Seconds = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
  UnixTime2.prototype.FractionalNanoseconds = 0;
  UnixTime2.encode = function encode12(m, w) {
    if (!w)
      w = $Writer.create();
    w.uint32(8).int64(m.Seconds);
    if (m.FractionalNanoseconds != null && Object.hasOwnProperty.call(m, "FractionalNanoseconds"))
      w.uint32(21).fixed32(m.FractionalNanoseconds);
    return w;
  };
  UnixTime2.decode = function decode12(r, l) {
    if (!(r instanceof $Reader))
      r = $Reader.create(r);
    var c = l === void 0 ? r.len : r.pos + l, m = new $root.UnixTime();
    while (r.pos < c) {
      var t = r.uint32();
      switch (t >>> 3) {
        case 1:
          m.Seconds = r.int64();
          break;
        case 2:
          m.FractionalNanoseconds = r.fixed32();
          break;
        default:
          r.skipType(t & 7);
          break;
      }
    }
    if (!m.hasOwnProperty("Seconds"))
      throw $util.ProtocolError("missing required 'Seconds'", { instance: m });
    return m;
  };
  UnixTime2.fromObject = function fromObject(d) {
    if (d instanceof $root.UnixTime)
      return d;
    var m = new $root.UnixTime();
    if (d.Seconds != null) {
      if ($util.Long)
        (m.Seconds = $util.Long.fromValue(d.Seconds)).unsigned = false;
      else if (typeof d.Seconds === "string")
        m.Seconds = parseInt(d.Seconds, 10);
      else if (typeof d.Seconds === "number")
        m.Seconds = d.Seconds;
      else if (typeof d.Seconds === "object")
        m.Seconds = new $util.LongBits(d.Seconds.low >>> 0, d.Seconds.high >>> 0).toNumber();
    }
    if (d.FractionalNanoseconds != null) {
      m.FractionalNanoseconds = d.FractionalNanoseconds >>> 0;
    }
    return m;
  };
  UnixTime2.toObject = function toObject(m, o) {
    if (!o)
      o = {};
    var d = {};
    if (o.defaults) {
      if ($util.Long) {
        var n = new $util.Long(0, 0, false);
        d.Seconds = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
      } else
        d.Seconds = o.longs === String ? "0" : 0;
      d.FractionalNanoseconds = 0;
    }
    if (m.Seconds != null && m.hasOwnProperty("Seconds")) {
      if (typeof m.Seconds === "number")
        d.Seconds = o.longs === String ? String(m.Seconds) : m.Seconds;
      else
        d.Seconds = o.longs === String ? $util.Long.prototype.toString.call(m.Seconds) : o.longs === Number ? new $util.LongBits(m.Seconds.low >>> 0, m.Seconds.high >>> 0).toNumber() : m.Seconds;
    }
    if (m.FractionalNanoseconds != null && m.hasOwnProperty("FractionalNanoseconds")) {
      d.FractionalNanoseconds = m.FractionalNanoseconds;
    }
    return d;
  };
  UnixTime2.prototype.toJSON = function toJSON() {
    return this.constructor.toObject(this, import_minimal.default.util.toJSONOptions);
  };
  return UnixTime2;
})();
var Metadata = $root.Metadata = (() => {
  function Metadata2(p) {
    if (p) {
      for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
        if (p[ks[i]] != null)
          this[ks[i]] = p[ks[i]];
    }
  }
  Metadata2.prototype.MimeType = "";
  Metadata2.encode = function encode12(m, w) {
    if (!w)
      w = $Writer.create();
    if (m.MimeType != null && Object.hasOwnProperty.call(m, "MimeType"))
      w.uint32(10).string(m.MimeType);
    return w;
  };
  Metadata2.decode = function decode12(r, l) {
    if (!(r instanceof $Reader))
      r = $Reader.create(r);
    var c = l === void 0 ? r.len : r.pos + l, m = new $root.Metadata();
    while (r.pos < c) {
      var t = r.uint32();
      switch (t >>> 3) {
        case 1:
          m.MimeType = r.string();
          break;
        default:
          r.skipType(t & 7);
          break;
      }
    }
    return m;
  };
  Metadata2.fromObject = function fromObject(d) {
    if (d instanceof $root.Metadata)
      return d;
    var m = new $root.Metadata();
    if (d.MimeType != null) {
      m.MimeType = String(d.MimeType);
    }
    return m;
  };
  Metadata2.toObject = function toObject(m, o) {
    if (!o)
      o = {};
    var d = {};
    if (o.defaults) {
      d.MimeType = "";
    }
    if (m.MimeType != null && m.hasOwnProperty("MimeType")) {
      d.MimeType = m.MimeType;
    }
    return d;
  };
  Metadata2.prototype.toJSON = function toJSON() {
    return this.constructor.toObject(this, import_minimal.default.util.toJSONOptions);
  };
  return Metadata2;
})();

// ../../node_modules/.pnpm/ipfs-unixfs@6.0.9/node_modules/ipfs-unixfs/esm/src/index.js
var PBData = Data;
var types = [
  "raw",
  "directory",
  "file",
  "metadata",
  "symlink",
  "hamt-sharded-directory"
];
var dirTypes = [
  "directory",
  "hamt-sharded-directory"
];
var DEFAULT_FILE_MODE = parseInt("0644", 8);
var DEFAULT_DIRECTORY_MODE = parseInt("0755", 8);
function parseMode(mode) {
  if (mode == null) {
    return void 0;
  }
  if (typeof mode === "number") {
    return mode & 4095;
  }
  mode = mode.toString();
  if (mode.substring(0, 1) === "0") {
    return parseInt(mode, 8) & 4095;
  }
  return parseInt(mode, 10) & 4095;
}
function parseMtime(input) {
  if (input == null) {
    return void 0;
  }
  let mtime;
  if (input.secs != null) {
    mtime = {
      secs: input.secs,
      nsecs: input.nsecs
    };
  }
  if (input.Seconds != null) {
    mtime = {
      secs: input.Seconds,
      nsecs: input.FractionalNanoseconds
    };
  }
  if (Array.isArray(input)) {
    mtime = {
      secs: input[0],
      nsecs: input[1]
    };
  }
  if (input instanceof Date) {
    const ms = input.getTime();
    const secs = Math.floor(ms / 1e3);
    mtime = {
      secs,
      nsecs: (ms - secs * 1e3) * 1e3
    };
  }
  if (!Object.prototype.hasOwnProperty.call(mtime, "secs")) {
    return void 0;
  }
  if (mtime != null && mtime.nsecs != null && (mtime.nsecs < 0 || mtime.nsecs > 999999999)) {
    throw (0, import_err_code.default)(new Error("mtime-nsecs must be within the range [0,999999999]"), "ERR_INVALID_MTIME_NSECS");
  }
  return mtime;
}
var UnixFS = class _UnixFS {
  static unmarshal(marshaled) {
    const message = PBData.decode(marshaled);
    const decoded = PBData.toObject(message, {
      defaults: false,
      arrays: true,
      longs: Number,
      objects: false
    });
    const data = new _UnixFS({
      type: types[decoded.Type],
      data: decoded.Data,
      blockSizes: decoded.blocksizes,
      mode: decoded.mode,
      mtime: decoded.mtime ? {
        secs: decoded.mtime.Seconds,
        nsecs: decoded.mtime.FractionalNanoseconds
      } : void 0
    });
    data._originalMode = decoded.mode || 0;
    return data;
  }
  constructor(options = { type: "file" }) {
    const { type, data, blockSizes, hashType, fanout, mtime, mode } = options;
    if (type && !types.includes(type)) {
      throw (0, import_err_code.default)(new Error("Type: " + type + " is not valid"), "ERR_INVALID_TYPE");
    }
    this.type = type || "file";
    this.data = data;
    this.hashType = hashType;
    this.fanout = fanout;
    this.blockSizes = blockSizes || [];
    this._originalMode = 0;
    this.mode = parseMode(mode);
    if (mtime) {
      this.mtime = parseMtime(mtime);
      if (this.mtime && !this.mtime.nsecs) {
        this.mtime.nsecs = 0;
      }
    }
  }
  set mode(mode) {
    this._mode = this.isDirectory() ? DEFAULT_DIRECTORY_MODE : DEFAULT_FILE_MODE;
    const parsedMode = parseMode(mode);
    if (parsedMode !== void 0) {
      this._mode = parsedMode;
    }
  }
  get mode() {
    return this._mode;
  }
  isDirectory() {
    return Boolean(this.type && dirTypes.includes(this.type));
  }
  addBlockSize(size) {
    this.blockSizes.push(size);
  }
  removeBlockSize(index) {
    this.blockSizes.splice(index, 1);
  }
  fileSize() {
    if (this.isDirectory()) {
      return 0;
    }
    let sum = 0;
    this.blockSizes.forEach((size) => {
      sum += size;
    });
    if (this.data) {
      sum += this.data.length;
    }
    return sum;
  }
  marshal() {
    let type;
    switch (this.type) {
      case "raw":
        type = PBData.DataType.Raw;
        break;
      case "directory":
        type = PBData.DataType.Directory;
        break;
      case "file":
        type = PBData.DataType.File;
        break;
      case "metadata":
        type = PBData.DataType.Metadata;
        break;
      case "symlink":
        type = PBData.DataType.Symlink;
        break;
      case "hamt-sharded-directory":
        type = PBData.DataType.HAMTShard;
        break;
      default:
        throw (0, import_err_code.default)(new Error("Type: " + type + " is not valid"), "ERR_INVALID_TYPE");
    }
    let data = this.data;
    if (!this.data || !this.data.length) {
      data = void 0;
    }
    let mode;
    if (this.mode != null) {
      mode = this._originalMode & 4294963200 | (parseMode(this.mode) || 0);
      if (mode === DEFAULT_FILE_MODE && !this.isDirectory()) {
        mode = void 0;
      }
      if (mode === DEFAULT_DIRECTORY_MODE && this.isDirectory()) {
        mode = void 0;
      }
    }
    let mtime;
    if (this.mtime != null) {
      const parsed = parseMtime(this.mtime);
      if (parsed) {
        mtime = {
          Seconds: parsed.secs,
          FractionalNanoseconds: parsed.nsecs
        };
        if (mtime.FractionalNanoseconds === 0) {
          delete mtime.FractionalNanoseconds;
        }
      }
    }
    const pbData = {
      Type: type,
      Data: data,
      filesize: this.isDirectory() ? void 0 : this.fileSize(),
      blocksizes: this.blockSizes,
      hashType: this.hashType,
      fanout: this.fanout,
      mode,
      mtime
    };
    return PBData.encode(pbData).finish();
  }
};

// ../../node_modules/.pnpm/ipfs-unixfs-importer@9.0.10/node_modules/ipfs-unixfs-importer/esm/src/utils/persist.js
var persist = (buffer2, blockstore, options) => __async(void 0, null, function* () {
  if (!options.codec) {
    options.codec = src_exports;
  }
  if (!options.hasher) {
    options.hasher = sha256;
  }
  if (options.cidVersion === void 0) {
    options.cidVersion = 1;
  }
  if (options.codec === src_exports && options.hasher !== sha256) {
    options.cidVersion = 1;
  }
  const multihash = yield options.hasher.digest(buffer2);
  const cid = CID.create(options.cidVersion, options.codec.code, multihash);
  if (!options.onlyHash) {
    yield blockstore.put(cid, buffer2, { signal: options.signal });
  }
  return cid;
});
var persist_default = persist;

// ../../node_modules/.pnpm/ipfs-unixfs-importer@9.0.10/node_modules/ipfs-unixfs-importer/esm/src/dag-builder/dir.js
var dirBuilder = (item, blockstore, options) => __async(void 0, null, function* () {
  const unixfs = new UnixFS({
    type: "directory",
    mtime: item.mtime,
    mode: item.mode
  });
  const buffer2 = encode8(prepare({ Data: unixfs.marshal() }));
  const cid = yield persist_default(buffer2, blockstore, options);
  const path = item.path;
  return {
    cid,
    path,
    unixfs,
    size: buffer2.length
  };
});
var dir_default = dirBuilder;

// ../../node_modules/.pnpm/ipfs-unixfs-importer@9.0.10/node_modules/ipfs-unixfs-importer/esm/src/dag-builder/file/index.js
var import_err_code2 = __toESM(require_err_code(), 1);
var import_it_parallel_batch = __toESM(require_it_parallel_batch(), 1);

// ../../node_modules/.pnpm/ipfs-unixfs-importer@9.0.10/node_modules/ipfs-unixfs-importer/esm/src/dag-builder/file/flat.js
var import_it_all = __toESM(require_it_all(), 1);
function flat(source, reduce2) {
  return __async(this, null, function* () {
    return reduce2(yield (0, import_it_all.default)(source));
  });
}
var flat_default = flat;

// ../../node_modules/.pnpm/ipfs-unixfs-importer@9.0.10/node_modules/ipfs-unixfs-importer/esm/src/dag-builder/file/balanced.js
var import_it_batch = __toESM(require_it_batch(), 1);
function balanced(source, reduce2, options) {
  return reduceToParents(source, reduce2, options);
}
function reduceToParents(source, reduce2, options) {
  return __async(this, null, function* () {
    const roots = [];
    try {
      for (var iter = __forAwait((0, import_it_batch.default)(source, options.maxChildrenPerNode)), more, temp, error; more = !(temp = yield iter.next()).done; more = false) {
        const chunked = temp.value;
        roots.push(yield reduce2(chunked));
      }
    } catch (temp) {
      error = [temp];
    } finally {
      try {
        more && (temp = iter.return) && (yield temp.call(iter));
      } finally {
        if (error)
          throw error[0];
      }
    }
    if (roots.length > 1) {
      return reduceToParents(roots, reduce2, options);
    }
    return roots[0];
  });
}
var balanced_default = balanced;

// ../../node_modules/.pnpm/ipfs-unixfs-importer@9.0.10/node_modules/ipfs-unixfs-importer/esm/src/dag-builder/file/trickle.js
var import_it_batch2 = __toESM(require_it_batch(), 1);
function trickleStream(source, reduce2, options) {
  return __async(this, null, function* () {
    const root = new Root(options.layerRepeat);
    let iteration = 0;
    let maxDepth = 1;
    let subTree = root;
    try {
      for (var iter = __forAwait((0, import_it_batch2.default)(source, options.maxChildrenPerNode)), more, temp, error; more = !(temp = yield iter.next()).done; more = false) {
        const layer = temp.value;
        if (subTree.isFull()) {
          if (subTree !== root) {
            root.addChild(yield subTree.reduce(reduce2));
          }
          if (iteration && iteration % options.layerRepeat === 0) {
            maxDepth++;
          }
          subTree = new SubTree(maxDepth, options.layerRepeat, iteration);
          iteration++;
        }
        subTree.append(layer);
      }
    } catch (temp) {
      error = [temp];
    } finally {
      try {
        more && (temp = iter.return) && (yield temp.call(iter));
      } finally {
        if (error)
          throw error[0];
      }
    }
    if (subTree && subTree !== root) {
      root.addChild(yield subTree.reduce(reduce2));
    }
    return root.reduce(reduce2);
  });
}
var trickle_default = trickleStream;
var SubTree = class {
  constructor(maxDepth, layerRepeat, iteration = 0) {
    this.maxDepth = maxDepth;
    this.layerRepeat = layerRepeat;
    this.currentDepth = 1;
    this.iteration = iteration;
    this.root = this.node = this.parent = {
      children: [],
      depth: this.currentDepth,
      maxDepth,
      maxChildren: (this.maxDepth - this.currentDepth) * this.layerRepeat
    };
  }
  isFull() {
    if (!this.root.data) {
      return false;
    }
    if (this.currentDepth < this.maxDepth && this.node.maxChildren) {
      this._addNextNodeToParent(this.node);
      return false;
    }
    const distantRelative = this._findParent(this.node, this.currentDepth);
    if (distantRelative) {
      this._addNextNodeToParent(distantRelative);
      return false;
    }
    return true;
  }
  _addNextNodeToParent(parent) {
    this.parent = parent;
    const nextNode = {
      children: [],
      depth: parent.depth + 1,
      parent,
      maxDepth: this.maxDepth,
      maxChildren: Math.floor(parent.children.length / this.layerRepeat) * this.layerRepeat
    };
    parent.children.push(nextNode);
    this.currentDepth = nextNode.depth;
    this.node = nextNode;
  }
  append(layer) {
    this.node.data = layer;
  }
  reduce(reduce2) {
    return this._reduce(this.root, reduce2);
  }
  _reduce(node, reduce2) {
    return __async(this, null, function* () {
      let children = [];
      if (node.children.length) {
        children = yield Promise.all(node.children.filter((child) => child.data).map((child) => this._reduce(child, reduce2)));
      }
      return reduce2((node.data || []).concat(children));
    });
  }
  _findParent(node, depth) {
    const parent = node.parent;
    if (!parent || parent.depth === 0) {
      return;
    }
    if (parent.children.length === parent.maxChildren || !parent.maxChildren) {
      return this._findParent(parent, depth);
    }
    return parent;
  }
};
var Root = class extends SubTree {
  constructor(layerRepeat) {
    super(0, layerRepeat);
    this.root.depth = 0;
    this.currentDepth = 1;
  }
  addChild(child) {
    this.root.children.push(child);
  }
  reduce(reduce2) {
    return reduce2((this.root.data || []).concat(this.root.children));
  }
};

// ../../node_modules/.pnpm/ipfs-unixfs-importer@9.0.10/node_modules/ipfs-unixfs-importer/esm/src/dag-builder/file/buffer-importer.js
function bufferImporter(file, block, options) {
  return __asyncGenerator(this, null, function* () {
    try {
      for (var iter = __forAwait(file.content), more, temp, error; more = !(temp = yield new __await(iter.next())).done; more = false) {
        let buffer2 = temp.value;
        yield () => __async(this, null, function* () {
          options.progress(buffer2.length, file.path);
          let unixfs;
          const opts = {
            codec: src_exports,
            cidVersion: options.cidVersion,
            hasher: options.hasher,
            onlyHash: options.onlyHash
          };
          if (options.rawLeaves) {
            opts.codec = raw_exports;
            opts.cidVersion = 1;
          } else {
            unixfs = new UnixFS({
              type: options.leafType,
              data: buffer2
            });
            buffer2 = encode8({
              Data: unixfs.marshal(),
              Links: []
            });
          }
          return {
            cid: yield persist_default(buffer2, block, opts),
            unixfs,
            size: buffer2.length
          };
        });
      }
    } catch (temp) {
      error = [temp];
    } finally {
      try {
        more && (temp = iter.return) && (yield new __await(temp.call(iter)));
      } finally {
        if (error)
          throw error[0];
      }
    }
  });
}
var buffer_importer_default = bufferImporter;

// ../../node_modules/.pnpm/ipfs-unixfs-importer@9.0.10/node_modules/ipfs-unixfs-importer/esm/src/dag-builder/file/index.js
var dagBuilders = {
  flat: flat_default,
  balanced: balanced_default,
  trickle: trickle_default
};
function buildFileBatch(file, blockstore, options) {
  return __asyncGenerator(this, null, function* () {
    let count = -1;
    let previous;
    let bufferImporter2;
    if (typeof options.bufferImporter === "function") {
      bufferImporter2 = options.bufferImporter;
    } else {
      bufferImporter2 = buffer_importer_default;
    }
    try {
      for (var iter = __forAwait((0, import_it_parallel_batch.default)(bufferImporter2(file, blockstore, options), options.blockWriteConcurrency)), more, temp, error; more = !(temp = yield new __await(iter.next())).done; more = false) {
        const entry = temp.value;
        count++;
        if (count === 0) {
          previous = entry;
          continue;
        } else if (count === 1 && previous) {
          yield previous;
          previous = null;
        }
        yield entry;
      }
    } catch (temp) {
      error = [temp];
    } finally {
      try {
        more && (temp = iter.return) && (yield new __await(temp.call(iter)));
      } finally {
        if (error)
          throw error[0];
      }
    }
    if (previous) {
      previous.single = true;
      yield previous;
    }
  });
}
var reduce = (file, blockstore, options) => {
  function reducer(leaves) {
    return __async(this, null, function* () {
      if (leaves.length === 1 && leaves[0].single && options.reduceSingleLeafToSelf) {
        const leaf = leaves[0];
        if (file.mtime !== void 0 || file.mode !== void 0) {
          let buffer3 = yield blockstore.get(leaf.cid);
          leaf.unixfs = new UnixFS({
            type: "file",
            mtime: file.mtime,
            mode: file.mode,
            data: buffer3
          });
          buffer3 = encode8(prepare({ Data: leaf.unixfs.marshal() }));
          leaf.cid = yield persist_default(buffer3, blockstore, __spreadProps(__spreadValues({}, options), {
            codec: src_exports,
            hasher: options.hasher,
            cidVersion: options.cidVersion
          }));
          leaf.size = buffer3.length;
        }
        return {
          cid: leaf.cid,
          path: file.path,
          unixfs: leaf.unixfs,
          size: leaf.size
        };
      }
      const f = new UnixFS({
        type: "file",
        mtime: file.mtime,
        mode: file.mode
      });
      const links2 = leaves.filter((leaf) => {
        if (leaf.cid.code === code && leaf.size) {
          return true;
        }
        if (leaf.unixfs && !leaf.unixfs.data && leaf.unixfs.fileSize()) {
          return true;
        }
        return Boolean(leaf.unixfs && leaf.unixfs.data && leaf.unixfs.data.length);
      }).map((leaf) => {
        if (leaf.cid.code === code) {
          f.addBlockSize(leaf.size);
          return {
            Name: "",
            Tsize: leaf.size,
            Hash: leaf.cid
          };
        }
        if (!leaf.unixfs || !leaf.unixfs.data) {
          f.addBlockSize(leaf.unixfs && leaf.unixfs.fileSize() || 0);
        } else {
          f.addBlockSize(leaf.unixfs.data.length);
        }
        return {
          Name: "",
          Tsize: leaf.size,
          Hash: leaf.cid
        };
      });
      const node = {
        Data: f.marshal(),
        Links: links2
      };
      const buffer2 = encode8(prepare(node));
      const cid = yield persist_default(buffer2, blockstore, options);
      return {
        cid,
        path: file.path,
        unixfs: f,
        size: buffer2.length + node.Links.reduce((acc, curr) => acc + curr.Tsize, 0)
      };
    });
  }
  return reducer;
};
function fileBuilder(file, block, options) {
  const dagBuilder2 = dagBuilders[options.strategy];
  if (!dagBuilder2) {
    throw (0, import_err_code2.default)(new Error(`Unknown importer build strategy name: ${options.strategy}`), "ERR_BAD_STRATEGY");
  }
  return dagBuilder2(buildFileBatch(file, block, options), reduce(file, block, options), options);
}
var file_default = fileBuilder;

// ../../node_modules/.pnpm/ipfs-unixfs-importer@9.0.10/node_modules/ipfs-unixfs-importer/esm/src/dag-builder/index.js
var import_err_code5 = __toESM(require_err_code(), 1);

// ../../node_modules/.pnpm/ipfs-unixfs-importer@9.0.10/node_modules/ipfs-unixfs-importer/esm/src/chunker/rabin.js
var import_BufferList = __toESM(require_BufferList(), 1);
var import_rabin_wasm = __toESM(require_src(), 1);
var import_err_code3 = __toESM(require_err_code(), 1);
function rabinChunker(source, options) {
  return __asyncGenerator(this, null, function* () {
    let min, max, avg;
    if (options.minChunkSize && options.maxChunkSize && options.avgChunkSize) {
      avg = options.avgChunkSize;
      min = options.minChunkSize;
      max = options.maxChunkSize;
    } else if (!options.avgChunkSize) {
      throw (0, import_err_code3.default)(new Error("please specify an average chunk size"), "ERR_INVALID_AVG_CHUNK_SIZE");
    } else {
      avg = options.avgChunkSize;
      min = avg / 3;
      max = avg + avg / 2;
    }
    if (min < 16) {
      throw (0, import_err_code3.default)(new Error("rabin min must be greater than 16"), "ERR_INVALID_MIN_CHUNK_SIZE");
    }
    if (max < min) {
      max = min;
    }
    if (avg < min) {
      avg = min;
    }
    const sizepow = Math.floor(Math.log2(avg));
    try {
      for (var iter = __forAwait(rabin(source, {
        min,
        max,
        bits: sizepow,
        window: options.window,
        polynomial: options.polynomial
      })), more, temp, error; more = !(temp = yield new __await(iter.next())).done; more = false) {
        const chunk = temp.value;
        yield chunk;
      }
    } catch (temp) {
      error = [temp];
    } finally {
      try {
        more && (temp = iter.return) && (yield new __await(temp.call(iter)));
      } finally {
        if (error)
          throw error[0];
      }
    }
  });
}
var rabin_default = rabinChunker;
function rabin(source, options) {
  return __asyncGenerator(this, null, function* () {
    const r = yield new __await((0, import_rabin_wasm.create)(options.bits, options.min, options.max, options.window));
    const buffers = new import_BufferList.default();
    try {
      for (var iter = __forAwait(source), more, temp, error; more = !(temp = yield new __await(iter.next())).done; more = false) {
        const chunk = temp.value;
        buffers.append(chunk);
        const sizes = r.fingerprint(chunk);
        for (let i = 0; i < sizes.length; i++) {
          const size = sizes[i];
          const buf2 = buffers.slice(0, size);
          buffers.consume(size);
          yield buf2;
        }
      }
    } catch (temp) {
      error = [temp];
    } finally {
      try {
        more && (temp = iter.return) && (yield new __await(temp.call(iter)));
      } finally {
        if (error)
          throw error[0];
      }
    }
    if (buffers.length) {
      yield buffers.slice(0);
    }
  });
}

// ../../node_modules/.pnpm/ipfs-unixfs-importer@9.0.10/node_modules/ipfs-unixfs-importer/esm/src/chunker/fixed-size.js
var import_BufferList2 = __toESM(require_BufferList(), 1);
function fixedSizeChunker(source, options) {
  return __asyncGenerator(this, null, function* () {
    let bl = new import_BufferList2.default();
    let currentLength = 0;
    let emitted = false;
    const maxChunkSize = options.maxChunkSize;
    try {
      for (var iter = __forAwait(source), more, temp, error; more = !(temp = yield new __await(iter.next())).done; more = false) {
        const buffer2 = temp.value;
        bl.append(buffer2);
        currentLength += buffer2.length;
        while (currentLength >= maxChunkSize) {
          yield bl.slice(0, maxChunkSize);
          emitted = true;
          if (maxChunkSize === bl.length) {
            bl = new import_BufferList2.default();
            currentLength = 0;
          } else {
            const newBl = new import_BufferList2.default();
            newBl.append(bl.shallowSlice(maxChunkSize));
            bl = newBl;
            currentLength -= maxChunkSize;
          }
        }
      }
    } catch (temp) {
      error = [temp];
    } finally {
      try {
        more && (temp = iter.return) && (yield new __await(temp.call(iter)));
      } finally {
        if (error)
          throw error[0];
      }
    }
    if (!emitted || currentLength) {
      yield bl.slice(0, currentLength);
    }
  });
}
var fixed_size_default = fixedSizeChunker;

// ../../node_modules/.pnpm/ipfs-unixfs-importer@9.0.10/node_modules/ipfs-unixfs-importer/esm/src/dag-builder/validate-chunks.js
var import_err_code4 = __toESM(require_err_code(), 1);

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/identity.js
var identity_exports = {};
__export(identity_exports, {
  identity: () => identity
});
var identity = from({
  prefix: "\0",
  name: "identity",
  encode: (buf2) => toString(buf2),
  decode: (str) => fromString(str)
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base2.js
var base2_exports = {};
__export(base2_exports, {
  base2: () => base2
});
var base2 = rfc4648({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base8.js
var base8_exports = {};
__export(base8_exports, {
  base8: () => base8
});
var base8 = rfc4648({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base10.js
var base10_exports = {};
__export(base10_exports, {
  base10: () => base10
});
var base10 = baseX({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base16.js
var base16_exports = {};
__export(base16_exports, {
  base16: () => base16,
  base16upper: () => base16upper
});
var base16 = rfc4648({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
});
var base16upper = rfc4648({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base36.js
var base36_exports = {};
__export(base36_exports, {
  base36: () => base36,
  base36upper: () => base36upper
});
var base36 = baseX({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
var base36upper = baseX({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base64.js
var base64_exports = {};
__export(base64_exports, {
  base64: () => base64,
  base64pad: () => base64pad,
  base64url: () => base64url,
  base64urlpad: () => base64urlpad
});
var base64 = rfc4648({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad = rfc4648({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url = rfc4648({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad = rfc4648({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base256emoji.js
var base256emoji_exports = {};
__export(base256emoji_exports, {
  base256emoji: () => base256emoji
});
var alphabet = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
var alphabetBytesToChars = alphabet.reduce((p, c, i) => {
  p[i] = c;
  return p;
}, []);
var alphabetCharsToBytes = alphabet.reduce((p, c, i) => {
  p[c.codePointAt(0)] = i;
  return p;
}, []);
function encode9(data) {
  return data.reduce((p, c) => {
    p += alphabetBytesToChars[c];
    return p;
  }, "");
}
function decode10(str) {
  const byts = [];
  for (const char of str) {
    const byt = alphabetCharsToBytes[char.codePointAt(0)];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
var base256emoji = from({
  prefix: "\u{1F680}",
  name: "base256emoji",
  encode: encode9,
  decode: decode10
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/hashes/identity.js
var identity_exports2 = {};
__export(identity_exports2, {
  identity: () => identity2
});
var code4 = 0;
var name4 = "identity";
var encode10 = coerce;
var digest = (input) => create(code4, encode10(input));
var identity2 = {
  code: code4,
  name: name4,
  encode: encode10,
  digest
};

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/codecs/json.js
var textEncoder4 = new TextEncoder();
var textDecoder3 = new TextDecoder();

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/basics.js
var bases = __spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({}, identity_exports), base2_exports), base8_exports), base10_exports), base16_exports), base32_exports), base36_exports), base58_exports), base64_exports), base256emoji_exports);
var hashes = __spreadValues(__spreadValues({}, sha2_exports), identity_exports2);

// ../../node_modules/.pnpm/uint8arrays@3.1.1/node_modules/uint8arrays/esm/src/util/as-uint8array.js
function asUint8Array(buf2) {
  if (globalThis.Buffer != null) {
    return new Uint8Array(buf2.buffer, buf2.byteOffset, buf2.byteLength);
  }
  return buf2;
}

// ../../node_modules/.pnpm/uint8arrays@3.1.1/node_modules/uint8arrays/esm/src/alloc.js
function allocUnsafe(size = 0) {
  if (globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null) {
    return asUint8Array(globalThis.Buffer.allocUnsafe(size));
  }
  return new Uint8Array(size);
}

// ../../node_modules/.pnpm/uint8arrays@3.1.1/node_modules/uint8arrays/esm/src/util/bases.js
function createCodec(name5, prefix, encode12, decode12) {
  return {
    name: name5,
    prefix,
    encoder: {
      name: name5,
      prefix,
      encode: encode12
    },
    decoder: { decode: decode12 }
  };
}
var string = createCodec("utf8", "u", (buf2) => {
  const decoder2 = new TextDecoder("utf8");
  return "u" + decoder2.decode(buf2);
}, (str) => {
  const encoder2 = new TextEncoder();
  return encoder2.encode(str.substring(1));
});
var ascii = createCodec("ascii", "a", (buf2) => {
  let string2 = "a";
  for (let i = 0; i < buf2.length; i++) {
    string2 += String.fromCharCode(buf2[i]);
  }
  return string2;
}, (str) => {
  str = str.substring(1);
  const buf2 = allocUnsafe(str.length);
  for (let i = 0; i < str.length; i++) {
    buf2[i] = str.charCodeAt(i);
  }
  return buf2;
});
var BASES = __spreadValues({
  utf8: string,
  "utf-8": string,
  hex: bases.base16,
  latin1: ascii,
  ascii,
  binary: ascii
}, bases);
var bases_default = BASES;

// ../../node_modules/.pnpm/uint8arrays@3.1.1/node_modules/uint8arrays/esm/src/from-string.js
function fromString3(string2, encoding = "utf8") {
  const base3 = bases_default[encoding];
  if (!base3) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return asUint8Array(globalThis.Buffer.from(string2, "utf-8"));
  }
  return base3.decoder.decode(`${base3.prefix}${string2}`);
}

// ../../node_modules/.pnpm/ipfs-unixfs-importer@9.0.10/node_modules/ipfs-unixfs-importer/esm/src/dag-builder/validate-chunks.js
function validateChunks(source) {
  return __asyncGenerator(this, null, function* () {
    try {
      for (var iter = __forAwait(source), more, temp, error; more = !(temp = yield new __await(iter.next())).done; more = false) {
        const content = temp.value;
        if (content.length === void 0) {
          throw (0, import_err_code4.default)(new Error("Content was invalid"), "ERR_INVALID_CONTENT");
        }
        if (typeof content === "string" || content instanceof String) {
          yield fromString3(content.toString());
        } else if (Array.isArray(content)) {
          yield Uint8Array.from(content);
        } else if (content instanceof Uint8Array) {
          yield content;
        } else {
          throw (0, import_err_code4.default)(new Error("Content was invalid"), "ERR_INVALID_CONTENT");
        }
      }
    } catch (temp) {
      error = [temp];
    } finally {
      try {
        more && (temp = iter.return) && (yield new __await(temp.call(iter)));
      } finally {
        if (error)
          throw error[0];
      }
    }
  });
}
var validate_chunks_default = validateChunks;

// ../../node_modules/.pnpm/ipfs-unixfs-importer@9.0.10/node_modules/ipfs-unixfs-importer/esm/src/dag-builder/index.js
function isIterable(thing) {
  return Symbol.iterator in thing;
}
function isAsyncIterable(thing) {
  return Symbol.asyncIterator in thing;
}
function contentAsAsyncIterable(content) {
  try {
    if (content instanceof Uint8Array) {
      return function() {
        return __asyncGenerator(this, null, function* () {
          yield content;
        });
      }();
    } else if (isIterable(content)) {
      return function() {
        return __asyncGenerator(this, null, function* () {
          yield* __yieldStar(content);
        });
      }();
    } else if (isAsyncIterable(content)) {
      return content;
    }
  } catch (e) {
    throw (0, import_err_code5.default)(new Error("Content was invalid"), "ERR_INVALID_CONTENT");
  }
  throw (0, import_err_code5.default)(new Error("Content was invalid"), "ERR_INVALID_CONTENT");
}
function dagBuilder(source, blockstore, options) {
  return __asyncGenerator(this, null, function* () {
    try {
      for (var iter = __forAwait(source), more, temp, error; more = !(temp = yield new __await(iter.next())).done; more = false) {
        const entry = temp.value;
        if (entry.path) {
          if (entry.path.substring(0, 2) === "./") {
            options.wrapWithDirectory = true;
          }
          entry.path = entry.path.split("/").filter((path) => path && path !== ".").join("/");
        }
        if (entry.content) {
          let chunker;
          if (typeof options.chunker === "function") {
            chunker = options.chunker;
          } else if (options.chunker === "rabin") {
            chunker = rabin_default;
          } else {
            chunker = fixed_size_default;
          }
          let chunkValidator;
          if (typeof options.chunkValidator === "function") {
            chunkValidator = options.chunkValidator;
          } else {
            chunkValidator = validate_chunks_default;
          }
          const file = {
            path: entry.path,
            mtime: entry.mtime,
            mode: entry.mode,
            content: chunker(chunkValidator(contentAsAsyncIterable(entry.content), options), options)
          };
          yield () => file_default(file, blockstore, options);
        } else if (entry.path) {
          const dir = {
            path: entry.path,
            mtime: entry.mtime,
            mode: entry.mode
          };
          yield () => dir_default(dir, blockstore, options);
        } else {
          throw new Error("Import candidate must have content or path or both");
        }
      }
    } catch (temp) {
      error = [temp];
    } finally {
      try {
        more && (temp = iter.return) && (yield new __await(temp.call(iter)));
      } finally {
        if (error)
          throw error[0];
      }
    }
  });
}
var dag_builder_default = dagBuilder;

// ../../node_modules/.pnpm/ipfs-unixfs-importer@9.0.10/node_modules/ipfs-unixfs-importer/esm/src/dir.js
var Dir = class {
  constructor(props, options) {
    this.options = options || {};
    this.root = props.root;
    this.dir = props.dir;
    this.path = props.path;
    this.dirty = props.dirty;
    this.flat = props.flat;
    this.parent = props.parent;
    this.parentKey = props.parentKey;
    this.unixfs = props.unixfs;
    this.mode = props.mode;
    this.mtime = props.mtime;
    this.cid = void 0;
    this.size = void 0;
  }
  put(name5, value) {
    return __async(this, null, function* () {
    });
  }
  get(name5) {
    return Promise.resolve(this);
  }
  eachChildSeries() {
    return __asyncGenerator(this, null, function* () {
    });
  }
  flush(blockstore) {
    return __asyncGenerator(this, null, function* () {
    });
  }
};
var dir_default2 = Dir;

// ../../node_modules/.pnpm/ipfs-unixfs-importer@9.0.10/node_modules/ipfs-unixfs-importer/esm/src/dir-flat.js
var DirFlat = class extends dir_default2 {
  constructor(props, options) {
    super(props, options);
    this._children = {};
  }
  put(name5, value) {
    return __async(this, null, function* () {
      this.cid = void 0;
      this.size = void 0;
      this._children[name5] = value;
    });
  }
  get(name5) {
    return Promise.resolve(this._children[name5]);
  }
  childCount() {
    return Object.keys(this._children).length;
  }
  directChildrenCount() {
    return this.childCount();
  }
  onlyChild() {
    return this._children[Object.keys(this._children)[0]];
  }
  eachChildSeries() {
    return __asyncGenerator(this, null, function* () {
      const keys = Object.keys(this._children);
      for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        yield {
          key,
          child: this._children[key]
        };
      }
    });
  }
  flush(block) {
    return __asyncGenerator(this, null, function* () {
      const children = Object.keys(this._children);
      const links2 = [];
      for (let i = 0; i < children.length; i++) {
        let child = this._children[children[i]];
        if (child instanceof dir_default2) {
          try {
            for (var iter = __forAwait(child.flush(block)), more, temp, error; more = !(temp = yield new __await(iter.next())).done; more = false) {
              const entry = temp.value;
              child = entry;
              yield child;
            }
          } catch (temp) {
            error = [temp];
          } finally {
            try {
              more && (temp = iter.return) && (yield new __await(temp.call(iter)));
            } finally {
              if (error)
                throw error[0];
            }
          }
        }
        if (child.size != null && child.cid) {
          links2.push({
            Name: children[i],
            Tsize: child.size,
            Hash: child.cid
          });
        }
      }
      const unixfs = new UnixFS({
        type: "directory",
        mtime: this.mtime,
        mode: this.mode
      });
      const node = {
        Data: unixfs.marshal(),
        Links: links2
      };
      const buffer2 = encode8(prepare(node));
      const cid = yield new __await(persist_default(buffer2, block, this.options));
      const size = buffer2.length + node.Links.reduce((acc, curr) => acc + (curr.Tsize == null ? 0 : curr.Tsize), 0);
      this.cid = cid;
      this.size = size;
      yield {
        cid,
        unixfs,
        path: this.path,
        size
      };
    });
  }
};
var dir_flat_default = DirFlat;

// ../../node_modules/.pnpm/ipfs-unixfs-importer@9.0.10/node_modules/ipfs-unixfs-importer/esm/src/dir-sharded.js
var import_hamt_sharding = __toESM(require_src3(), 1);
var DirSharded = class extends dir_default2 {
  constructor(props, options) {
    super(props, options);
    this._bucket = (0, import_hamt_sharding.createHAMT)({
      hashFn: options.hamtHashFn,
      bits: options.hamtBucketBits
    });
  }
  put(name5, value) {
    return __async(this, null, function* () {
      yield this._bucket.put(name5, value);
    });
  }
  get(name5) {
    return this._bucket.get(name5);
  }
  childCount() {
    return this._bucket.leafCount();
  }
  directChildrenCount() {
    return this._bucket.childrenCount();
  }
  onlyChild() {
    return this._bucket.onlyChild();
  }
  eachChildSeries() {
    return __asyncGenerator(this, null, function* () {
      try {
        for (var iter = __forAwait(this._bucket.eachLeafSeries()), more, temp, error; more = !(temp = yield new __await(iter.next())).done; more = false) {
          const { key, value } = temp.value;
          yield {
            key,
            child: value
          };
        }
      } catch (temp) {
        error = [temp];
      } finally {
        try {
          more && (temp = iter.return) && (yield new __await(temp.call(iter)));
        } finally {
          if (error)
            throw error[0];
        }
      }
    });
  }
  flush(blockstore) {
    return __asyncGenerator(this, null, function* () {
      try {
        for (var iter = __forAwait(flush(this._bucket, blockstore, this, this.options)), more, temp, error; more = !(temp = yield new __await(iter.next())).done; more = false) {
          const entry = temp.value;
          yield __spreadProps(__spreadValues({}, entry), {
            path: this.path
          });
        }
      } catch (temp) {
        error = [temp];
      } finally {
        try {
          more && (temp = iter.return) && (yield new __await(temp.call(iter)));
        } finally {
          if (error)
            throw error[0];
        }
      }
    });
  }
};
var dir_sharded_default = DirSharded;
function flush(bucket, blockstore, shardRoot, options) {
  return __asyncGenerator(this, null, function* () {
    const children = bucket._children;
    const links2 = [];
    let childrenSize = 0;
    for (let i = 0; i < children.length; i++) {
      const child = children.get(i);
      if (!child) {
        continue;
      }
      const labelPrefix = i.toString(16).toUpperCase().padStart(2, "0");
      if (child instanceof import_hamt_sharding.Bucket) {
        let shard;
        try {
          for (var iter = __forAwait(yield new __await(flush(child, blockstore, null, options))), more, temp, error; more = !(temp = yield new __await(iter.next())).done; more = false) {
            const subShard = temp.value;
            shard = subShard;
          }
        } catch (temp) {
          error = [temp];
        } finally {
          try {
            more && (temp = iter.return) && (yield new __await(temp.call(iter)));
          } finally {
            if (error)
              throw error[0];
          }
        }
        if (!shard) {
          throw new Error("Could not flush sharded directory, no subshard found");
        }
        links2.push({
          Name: labelPrefix,
          Tsize: shard.size,
          Hash: shard.cid
        });
        childrenSize += shard.size;
      } else if (typeof child.value.flush === "function") {
        const dir2 = child.value;
        let flushedDir;
        try {
          for (var iter2 = __forAwait(dir2.flush(blockstore)), more2, temp2, error2; more2 = !(temp2 = yield new __await(iter2.next())).done; more2 = false) {
            const entry = temp2.value;
            flushedDir = entry;
            yield flushedDir;
          }
        } catch (temp2) {
          error2 = [temp2];
        } finally {
          try {
            more2 && (temp2 = iter2.return) && (yield new __await(temp2.call(iter2)));
          } finally {
            if (error2)
              throw error2[0];
          }
        }
        const label = labelPrefix + child.key;
        links2.push({
          Name: label,
          Tsize: flushedDir.size,
          Hash: flushedDir.cid
        });
        childrenSize += flushedDir.size;
      } else {
        const value = child.value;
        if (!value.cid) {
          continue;
        }
        const label = labelPrefix + child.key;
        const size2 = value.size;
        links2.push({
          Name: label,
          Tsize: size2,
          Hash: value.cid
        });
        childrenSize += size2;
      }
    }
    const data = Uint8Array.from(children.bitField().reverse());
    const dir = new UnixFS({
      type: "hamt-sharded-directory",
      data,
      fanout: bucket.tableSize(),
      hashType: options.hamtHashCode,
      mtime: shardRoot && shardRoot.mtime,
      mode: shardRoot && shardRoot.mode
    });
    const node = {
      Data: dir.marshal(),
      Links: links2
    };
    const buffer2 = encode8(prepare(node));
    const cid = yield new __await(persist_default(buffer2, blockstore, options));
    const size = buffer2.length + childrenSize;
    yield {
      cid,
      unixfs: dir,
      size
    };
  });
}

// ../../node_modules/.pnpm/ipfs-unixfs-importer@9.0.10/node_modules/ipfs-unixfs-importer/esm/src/flat-to-shard.js
function flatToShard(child, dir, threshold, options) {
  return __async(this, null, function* () {
    let newDir = dir;
    if (dir instanceof dir_flat_default && dir.directChildrenCount() >= threshold) {
      newDir = yield convertToShard(dir, options);
    }
    const parent = newDir.parent;
    if (parent) {
      if (newDir !== dir) {
        if (child) {
          child.parent = newDir;
        }
        if (!newDir.parentKey) {
          throw new Error("No parent key found");
        }
        yield parent.put(newDir.parentKey, newDir);
      }
      return flatToShard(newDir, parent, threshold, options);
    }
    return newDir;
  });
}
function convertToShard(oldDir, options) {
  return __async(this, null, function* () {
    const newDir = new dir_sharded_default({
      root: oldDir.root,
      dir: true,
      parent: oldDir.parent,
      parentKey: oldDir.parentKey,
      path: oldDir.path,
      dirty: oldDir.dirty,
      flat: false,
      mtime: oldDir.mtime,
      mode: oldDir.mode
    }, options);
    try {
      for (var iter = __forAwait(oldDir.eachChildSeries()), more, temp, error; more = !(temp = yield iter.next()).done; more = false) {
        const { key, child } = temp.value;
        yield newDir.put(key, child);
      }
    } catch (temp) {
      error = [temp];
    } finally {
      try {
        more && (temp = iter.return) && (yield temp.call(iter));
      } finally {
        if (error)
          throw error[0];
      }
    }
    return newDir;
  });
}
var flat_to_shard_default = flatToShard;

// ../../node_modules/.pnpm/ipfs-unixfs-importer@9.0.10/node_modules/ipfs-unixfs-importer/esm/src/utils/to-path-components.js
var toPathComponents = (path = "") => {
  return (path.trim().match(/([^\\/]|\\\/)+/g) || []).filter(Boolean);
};
var to_path_components_default = toPathComponents;

// ../../node_modules/.pnpm/ipfs-unixfs-importer@9.0.10/node_modules/ipfs-unixfs-importer/esm/src/tree-builder.js
function addToTree(elem, tree2, options) {
  return __async(this, null, function* () {
    const pathElems = to_path_components_default(elem.path || "");
    const lastIndex = pathElems.length - 1;
    let parent = tree2;
    let currentPath = "";
    for (let i = 0; i < pathElems.length; i++) {
      const pathElem = pathElems[i];
      currentPath += `${currentPath ? "/" : ""}${pathElem}`;
      const last2 = i === lastIndex;
      parent.dirty = true;
      parent.cid = void 0;
      parent.size = void 0;
      if (last2) {
        yield parent.put(pathElem, elem);
        tree2 = yield flat_to_shard_default(null, parent, options.shardSplitThreshold, options);
      } else {
        let dir = yield parent.get(pathElem);
        if (!dir || !(dir instanceof dir_default2)) {
          dir = new dir_flat_default({
            root: false,
            dir: true,
            parent,
            parentKey: pathElem,
            path: currentPath,
            dirty: true,
            flat: true,
            mtime: dir && dir.unixfs && dir.unixfs.mtime,
            mode: dir && dir.unixfs && dir.unixfs.mode
          }, options);
        }
        yield parent.put(pathElem, dir);
        parent = dir;
      }
    }
    return tree2;
  });
}
function flushAndYield(tree2, blockstore) {
  return __asyncGenerator(this, null, function* () {
    if (!(tree2 instanceof dir_default2)) {
      if (tree2 && tree2.unixfs && tree2.unixfs.isDirectory()) {
        yield tree2;
      }
      return;
    }
    yield* __yieldStar(tree2.flush(blockstore));
  });
}
function treeBuilder(source, block, options) {
  return __asyncGenerator(this, null, function* () {
    let tree2 = new dir_flat_default({
      root: true,
      dir: true,
      path: "",
      dirty: true,
      flat: true
    }, options);
    try {
      for (var iter = __forAwait(source), more, temp, error; more = !(temp = yield new __await(iter.next())).done; more = false) {
        const entry = temp.value;
        if (!entry) {
          continue;
        }
        tree2 = yield new __await(addToTree(entry, tree2, options));
        if (!entry.unixfs || !entry.unixfs.isDirectory()) {
          yield entry;
        }
      }
    } catch (temp) {
      error = [temp];
    } finally {
      try {
        more && (temp = iter.return) && (yield new __await(temp.call(iter)));
      } finally {
        if (error)
          throw error[0];
      }
    }
    if (options.wrapWithDirectory) {
      yield* __yieldStar(flushAndYield(tree2, block));
    } else {
      try {
        for (var iter2 = __forAwait(tree2.eachChildSeries()), more2, temp2, error2; more2 = !(temp2 = yield new __await(iter2.next())).done; more2 = false) {
          const unwrapped = temp2.value;
          if (!unwrapped) {
            continue;
          }
          yield* __yieldStar(flushAndYield(unwrapped.child, block));
        }
      } catch (temp2) {
        error2 = [temp2];
      } finally {
        try {
          more2 && (temp2 = iter2.return) && (yield new __await(temp2.call(iter2)));
        } finally {
          if (error2)
            throw error2[0];
        }
      }
    }
  });
}
var tree_builder_default = treeBuilder;

// ../../node_modules/.pnpm/ipfs-unixfs-importer@9.0.10/node_modules/ipfs-unixfs-importer/esm/src/index.js
function importer(_0, _1) {
  return __asyncGenerator(this, arguments, function* (source, blockstore, options = {}) {
    const opts = options_default(options);
    let dagBuilder2;
    if (typeof options.dagBuilder === "function") {
      dagBuilder2 = options.dagBuilder;
    } else {
      dagBuilder2 = dag_builder_default;
    }
    let treeBuilder2;
    if (typeof options.treeBuilder === "function") {
      treeBuilder2 = options.treeBuilder;
    } else {
      treeBuilder2 = tree_builder_default;
    }
    let candidates;
    if (Symbol.asyncIterator in source || Symbol.iterator in source) {
      candidates = source;
    } else {
      candidates = [source];
    }
    try {
      for (var iter = __forAwait(treeBuilder2((0, import_it_parallel_batch2.default)(dagBuilder2(candidates, blockstore, opts), opts.fileImportConcurrency), blockstore, opts)), more, temp, error; more = !(temp = yield new __await(iter.next())).done; more = false) {
        const entry = temp.value;
        yield {
          cid: entry.cid,
          path: entry.path,
          unixfs: entry.unixfs,
          size: entry.size
        };
      }
    } catch (temp) {
      error = [temp];
    } finally {
      try {
        more && (temp = iter.return) && (yield new __await(temp.call(iter)));
      } finally {
        if (error)
          throw error[0];
      }
    }
  });
}

// ../../node_modules/.pnpm/ipfs-core-utils@0.12.2_node-fetch@3.3.2/node_modules/ipfs-core-utils/esm/src/files/normalise-content.js
var import_err_code6 = __toESM(require_err_code(), 1);
var import_browser_readablestream_to_it = __toESM(require_browser_readablestream_to_it(), 1);
var import_blob_to_it = __toESM(require_blob_to_it(), 1);
var import_it_peekable = __toESM(require_it_peekable(), 1);
var import_it_all2 = __toESM(require_it_all(), 1);
var import_it_map = __toESM(require_it_map(), 1);

// ../../node_modules/.pnpm/ipfs-core-utils@0.12.2_node-fetch@3.3.2/node_modules/ipfs-core-utils/esm/src/files/utils.js
function isBytes(obj) {
  return ArrayBuffer.isView(obj) || obj instanceof ArrayBuffer;
}
function isBlob(obj) {
  return obj.constructor && (obj.constructor.name === "Blob" || obj.constructor.name === "File") && typeof obj.stream === "function";
}
function isFileObject(obj) {
  return typeof obj === "object" && (obj.path || obj.content);
}
var isReadableStream = (value) => value && typeof value.getReader === "function";

// ../../node_modules/.pnpm/ipfs-core-utils@0.12.2_node-fetch@3.3.2/node_modules/ipfs-core-utils/esm/src/files/normalise-content.js
function toAsyncIterable(thing) {
  return __asyncGenerator(this, null, function* () {
    yield thing;
  });
}
function normaliseContent(input) {
  return __async(this, null, function* () {
    if (isBytes(input)) {
      return toAsyncIterable(toBytes(input));
    }
    if (typeof input === "string" || input instanceof String) {
      return toAsyncIterable(toBytes(input.toString()));
    }
    if (isBlob(input)) {
      return (0, import_blob_to_it.default)(input);
    }
    if (isReadableStream(input)) {
      input = (0, import_browser_readablestream_to_it.default)(input);
    }
    if (Symbol.iterator in input || Symbol.asyncIterator in input) {
      const peekable = (0, import_it_peekable.default)(input);
      const { value, done } = yield peekable.peek();
      if (done) {
        return toAsyncIterable(new Uint8Array(0));
      }
      peekable.push(value);
      if (Number.isInteger(value)) {
        return toAsyncIterable(Uint8Array.from(yield (0, import_it_all2.default)(peekable)));
      }
      if (isBytes(value) || typeof value === "string" || value instanceof String) {
        return (0, import_it_map.default)(peekable, toBytes);
      }
    }
    throw (0, import_err_code6.default)(new Error(`Unexpected input: ${input}`), "ERR_UNEXPECTED_INPUT");
  });
}
function toBytes(chunk) {
  if (chunk instanceof Uint8Array) {
    return chunk;
  }
  if (ArrayBuffer.isView(chunk)) {
    return new Uint8Array(chunk.buffer, chunk.byteOffset, chunk.byteLength);
  }
  if (chunk instanceof ArrayBuffer) {
    return new Uint8Array(chunk);
  }
  if (Array.isArray(chunk)) {
    return Uint8Array.from(chunk);
  }
  return fromString3(chunk.toString());
}

// ../../node_modules/.pnpm/ipfs-core-utils@0.12.2_node-fetch@3.3.2/node_modules/ipfs-core-utils/esm/src/files/normalise-candidate-single.js
var import_err_code7 = __toESM(require_err_code(), 1);
var import_browser_readablestream_to_it2 = __toESM(require_browser_readablestream_to_it(), 1);
var import_it_peekable2 = __toESM(require_it_peekable(), 1);
function normaliseCandidateSingle(input, normaliseContent2) {
  return __asyncGenerator(this, null, function* () {
    if (input === null || input === void 0) {
      throw (0, import_err_code7.default)(new Error(`Unexpected input: ${input}`), "ERR_UNEXPECTED_INPUT");
    }
    if (typeof input === "string" || input instanceof String) {
      yield toFileObject(input.toString(), normaliseContent2);
      return;
    }
    if (isBytes(input) || isBlob(input)) {
      yield toFileObject(input, normaliseContent2);
      return;
    }
    if (isReadableStream(input)) {
      input = (0, import_browser_readablestream_to_it2.default)(input);
    }
    if (Symbol.iterator in input || Symbol.asyncIterator in input) {
      const peekable = (0, import_it_peekable2.default)(input);
      const { value, done } = yield new __await(peekable.peek());
      if (done) {
        yield { content: [] };
        return;
      }
      peekable.push(value);
      if (Number.isInteger(value) || isBytes(value) || typeof value === "string" || value instanceof String) {
        yield toFileObject(peekable, normaliseContent2);
        return;
      }
      throw (0, import_err_code7.default)(new Error("Unexpected input: multiple items passed - if you are using ipfs.add, please use ipfs.addAll instead"), "ERR_UNEXPECTED_INPUT");
    }
    if (isFileObject(input)) {
      yield toFileObject(input, normaliseContent2);
      return;
    }
    throw (0, import_err_code7.default)(new Error('Unexpected input: cannot convert "' + typeof input + '" into ImportCandidate'), "ERR_UNEXPECTED_INPUT");
  });
}
function toFileObject(input, normaliseContent2) {
  return __async(this, null, function* () {
    const { path, mode, mtime, content } = input;
    const file = {
      path: path || "",
      mode: parseMode(mode),
      mtime: parseMtime(mtime)
    };
    if (content) {
      file.content = yield normaliseContent2(content);
    } else if (!path) {
      file.content = yield normaliseContent2(input);
    }
    return file;
  });
}

// ../../node_modules/.pnpm/ipfs-core-utils@0.12.2_node-fetch@3.3.2/node_modules/ipfs-core-utils/esm/src/files/normalise-input-single.js
function normaliseInput(input) {
  return normaliseCandidateSingle(input, normaliseContent);
}

// ../../node_modules/.pnpm/ipfs-core-utils@0.12.2_node-fetch@3.3.2/node_modules/ipfs-core-utils/esm/src/files/normalise-candidate-multiple.js
var import_err_code8 = __toESM(require_err_code(), 1);
var import_browser_readablestream_to_it3 = __toESM(require_browser_readablestream_to_it(), 1);
var import_it_peekable3 = __toESM(require_it_peekable(), 1);
var import_it_map2 = __toESM(require_it_map(), 1);
function normaliseCandidateMultiple(input, normaliseContent2) {
  return __asyncGenerator(this, null, function* () {
    if (typeof input === "string" || input instanceof String || isBytes(input) || isBlob(input) || input._readableState) {
      throw (0, import_err_code8.default)(new Error("Unexpected input: single item passed - if you are using ipfs.addAll, please use ipfs.add instead"), "ERR_UNEXPECTED_INPUT");
    }
    if (isReadableStream(input)) {
      input = (0, import_browser_readablestream_to_it3.default)(input);
    }
    if (Symbol.iterator in input || Symbol.asyncIterator in input) {
      const peekable = (0, import_it_peekable3.default)(input);
      const { value, done } = yield new __await(peekable.peek());
      if (done) {
        yield* __yieldStar([]);
        return;
      }
      peekable.push(value);
      if (Number.isInteger(value)) {
        throw (0, import_err_code8.default)(new Error("Unexpected input: single item passed - if you are using ipfs.addAll, please use ipfs.add instead"), "ERR_UNEXPECTED_INPUT");
      }
      if (value._readableState) {
        yield* __yieldStar((0, import_it_map2.default)(peekable, (value2) => toFileObject2({ content: value2 }, normaliseContent2)));
        return;
      }
      if (isBytes(value)) {
        yield toFileObject2({ content: peekable }, normaliseContent2);
        return;
      }
      if (isFileObject(value) || value[Symbol.iterator] || value[Symbol.asyncIterator] || isReadableStream(value) || isBlob(value)) {
        yield* __yieldStar((0, import_it_map2.default)(peekable, (value2) => toFileObject2(value2, normaliseContent2)));
        return;
      }
    }
    if (isFileObject(input)) {
      throw (0, import_err_code8.default)(new Error("Unexpected input: single item passed - if you are using ipfs.addAll, please use ipfs.add instead"), "ERR_UNEXPECTED_INPUT");
    }
    throw (0, import_err_code8.default)(new Error("Unexpected input: " + typeof input), "ERR_UNEXPECTED_INPUT");
  });
}
function toFileObject2(input, normaliseContent2) {
  return __async(this, null, function* () {
    const { path, mode, mtime, content } = input;
    const file = {
      path: path || "",
      mode: parseMode(mode),
      mtime: parseMtime(mtime)
    };
    if (content) {
      file.content = yield normaliseContent2(content);
    } else if (!path) {
      file.content = yield normaliseContent2(input);
    }
    return file;
  });
}

// ../../node_modules/.pnpm/ipfs-core-utils@0.12.2_node-fetch@3.3.2/node_modules/ipfs-core-utils/esm/src/files/normalise-input-multiple.js
function normaliseInput2(input) {
  return normaliseCandidateMultiple(input, normaliseContent);
}

// ../../node_modules/.pnpm/ipfs-car@0.6.2_node-fetch@3.3.2/node_modules/ipfs-car/dist/esm/pack/utils/normalise-input.js
function isBytes2(obj) {
  return ArrayBuffer.isView(obj) || obj instanceof ArrayBuffer;
}
function isBlob2(obj) {
  return Boolean(obj.constructor) && (obj.constructor.name === "Blob" || obj.constructor.name === "File") && typeof obj.stream === "function";
}
function isSingle(input) {
  return typeof input === "string" || input instanceof String || isBytes2(input) || isBlob2(input) || "_readableState" in input;
}
function getNormaliser(input) {
  if (isSingle(input)) {
    return normaliseInput(input);
  } else {
    return normaliseInput2(input);
  }
}

// ../../node_modules/.pnpm/blockstore-core@1.0.5/node_modules/blockstore-core/esm/src/errors.js
var errors_exports = {};
__export(errors_exports, {
  abortedError: () => abortedError,
  notFoundError: () => notFoundError
});
var import_err_code9 = __toESM(require_err_code(), 1);
function notFoundError(err) {
  err = err || new Error("Not Found");
  return (0, import_err_code9.default)(err, "ERR_NOT_FOUND");
}
function abortedError(err) {
  err = err || new Error("Aborted");
  return (0, import_err_code9.default)(err, "ERR_ABORTED");
}

// ../../node_modules/.pnpm/blockstore-core@1.0.5/node_modules/blockstore-core/esm/src/base.js
var import_it_drain = __toESM(require_it_drain(), 1);
var import_it_filter = __toESM(require_it_filter(), 1);
var import_it_take = __toESM(require_it_take(), 1);
var import_it_all3 = __toESM(require_it_all(), 1);
var sortAll = (iterable, sorter) => {
  return function() {
    return __asyncGenerator(this, null, function* () {
      const values = yield new __await((0, import_it_all3.default)(iterable));
      yield* __yieldStar(values.sort(sorter));
    });
  }();
};
var BaseBlockstore = class {
  open() {
    return Promise.reject(new Error(".open is not implemented"));
  }
  close() {
    return Promise.reject(new Error(".close is not implemented"));
  }
  put(key, val, options) {
    return Promise.reject(new Error(".put is not implemented"));
  }
  get(key, options) {
    return Promise.reject(new Error(".get is not implemented"));
  }
  has(key, options) {
    return Promise.reject(new Error(".has is not implemented"));
  }
  delete(key, options) {
    return Promise.reject(new Error(".delete is not implemented"));
  }
  putMany(_0) {
    return __asyncGenerator(this, arguments, function* (source, options = {}) {
      try {
        for (var iter = __forAwait(source), more, temp, error; more = !(temp = yield new __await(iter.next())).done; more = false) {
          const { key, value } = temp.value;
          yield new __await(this.put(key, value, options));
          yield {
            key,
            value
          };
        }
      } catch (temp) {
        error = [temp];
      } finally {
        try {
          more && (temp = iter.return) && (yield new __await(temp.call(iter)));
        } finally {
          if (error)
            throw error[0];
        }
      }
    });
  }
  getMany(_0) {
    return __asyncGenerator(this, arguments, function* (source, options = {}) {
      try {
        for (var iter = __forAwait(source), more, temp, error; more = !(temp = yield new __await(iter.next())).done; more = false) {
          const key = temp.value;
          yield this.get(key, options);
        }
      } catch (temp) {
        error = [temp];
      } finally {
        try {
          more && (temp = iter.return) && (yield new __await(temp.call(iter)));
        } finally {
          if (error)
            throw error[0];
        }
      }
    });
  }
  deleteMany(_0) {
    return __asyncGenerator(this, arguments, function* (source, options = {}) {
      try {
        for (var iter = __forAwait(source), more, temp, error; more = !(temp = yield new __await(iter.next())).done; more = false) {
          const key = temp.value;
          yield new __await(this.delete(key, options));
          yield key;
        }
      } catch (temp) {
        error = [temp];
      } finally {
        try {
          more && (temp = iter.return) && (yield new __await(temp.call(iter)));
        } finally {
          if (error)
            throw error[0];
        }
      }
    });
  }
  batch() {
    let puts = [];
    let dels = [];
    return {
      put(key, value) {
        puts.push({
          key,
          value
        });
      },
      delete(key) {
        dels.push(key);
      },
      commit: (options) => __async(this, null, function* () {
        yield (0, import_it_drain.default)(this.putMany(puts, options));
        puts = [];
        yield (0, import_it_drain.default)(this.deleteMany(dels, options));
        dels = [];
      })
    };
  }
  _all(q, options) {
    return __asyncGenerator(this, null, function* () {
      throw new Error("._all is not implemented");
    });
  }
  _allKeys(q, options) {
    return __asyncGenerator(this, null, function* () {
      throw new Error("._allKeys is not implemented");
    });
  }
  query(q, options) {
    let it = this._all(q, options);
    if (q.prefix != null) {
      it = (0, import_it_filter.default)(it, (e) => e.key.toString().startsWith(q.prefix || ""));
    }
    if (Array.isArray(q.filters)) {
      it = q.filters.reduce((it2, f) => (0, import_it_filter.default)(it2, f), it);
    }
    if (Array.isArray(q.orders)) {
      it = q.orders.reduce((it2, f) => sortAll(it2, f), it);
    }
    if (q.offset != null) {
      let i = 0;
      it = (0, import_it_filter.default)(it, () => i++ >= (q.offset || 0));
    }
    if (q.limit != null) {
      it = (0, import_it_take.default)(it, q.limit);
    }
    return it;
  }
  queryKeys(q, options) {
    let it = this._allKeys(q, options);
    if (q.prefix != null) {
      it = (0, import_it_filter.default)(it, (cid) => cid.toString().startsWith(q.prefix || ""));
    }
    if (Array.isArray(q.filters)) {
      it = q.filters.reduce((it2, f) => (0, import_it_filter.default)(it2, f), it);
    }
    if (Array.isArray(q.orders)) {
      it = q.orders.reduce((it2, f) => sortAll(it2, f), it);
    }
    if (q.offset != null) {
      let i = 0;
      it = (0, import_it_filter.default)(it, () => i++ >= q.offset);
    }
    if (q.limit != null) {
      it = (0, import_it_take.default)(it, q.limit);
    }
    return it;
  }
};

// ../../node_modules/.pnpm/blockstore-core@1.0.5/node_modules/blockstore-core/esm/src/index.js
var Errors = __spreadValues({}, errors_exports);

// ../../node_modules/.pnpm/ipfs-car@0.6.2_node-fetch@3.3.2/node_modules/ipfs-car/dist/esm/blockstore/memory.js
var MemoryBlockStore = class extends BaseBlockstore {
  constructor() {
    super();
    this.store = /* @__PURE__ */ new Map();
  }
  blocks() {
    return __asyncGenerator(this, null, function* () {
      for (const [cidStr, bytes] of this.store.entries()) {
        yield { cid: CID.parse(cidStr), bytes };
      }
    });
  }
  put(cid, bytes) {
    this.store.set(cid.toString(), bytes);
    return Promise.resolve();
  }
  get(cid) {
    const bytes = this.store.get(cid.toString());
    if (!bytes) {
      throw new Error(`block with cid ${cid.toString()} no found`);
    }
    return Promise.resolve(bytes);
  }
  has(cid) {
    return Promise.resolve(this.store.has(cid.toString()));
  }
  close() {
    this.store.clear();
    return Promise.resolve();
  }
};

// ../../node_modules/.pnpm/ipfs-car@0.6.2_node-fetch@3.3.2/node_modules/ipfs-car/dist/esm/pack/constants.js
var unixfsImporterOptionsDefault = {
  cidVersion: 1,
  chunker: "fixed",
  maxChunkSize: 262144,
  hasher: sha256,
  rawLeaves: true,
  wrapWithDirectory: true,
  maxChildrenPerNode: 174
};

// ../../node_modules/.pnpm/ipfs-car@0.6.2_node-fetch@3.3.2/node_modules/ipfs-car/dist/esm/pack/index.js
function pack(_0) {
  return __async(this, arguments, function* ({ input, blockstore: userBlockstore, hasher, maxChunkSize, maxChildrenPerNode, wrapWithDirectory, rawLeaves }) {
    if (!input || Array.isArray(input) && !input.length) {
      throw new Error("missing input file(s)");
    }
    const blockstore = userBlockstore ? userBlockstore : new MemoryBlockStore();
    const rootEntry = yield (0, import_it_last.default)((0, import_it_pipe.default)(getNormaliser(input), (source) => importer(source, blockstore, __spreadProps(__spreadValues({}, unixfsImporterOptionsDefault), {
      hasher: hasher || unixfsImporterOptionsDefault.hasher,
      maxChunkSize: maxChunkSize || unixfsImporterOptionsDefault.maxChunkSize,
      maxChildrenPerNode: maxChildrenPerNode || unixfsImporterOptionsDefault.maxChildrenPerNode,
      wrapWithDirectory: wrapWithDirectory === false ? false : unixfsImporterOptionsDefault.wrapWithDirectory,
      rawLeaves: rawLeaves == null ? unixfsImporterOptionsDefault.rawLeaves : rawLeaves
    }))));
    if (!rootEntry || !rootEntry.cid) {
      throw new Error("given input could not be parsed correctly");
    }
    const root = rootEntry.cid;
    const { writer, out: carOut } = yield CarWriter2.create([root]);
    const carOutIter = carOut[Symbol.asyncIterator]();
    let writingPromise;
    const writeAll = () => __async(this, null, function* () {
      try {
        for (var iter = __forAwait(blockstore.blocks()), more, temp, error; more = !(temp = yield iter.next()).done; more = false) {
          const block = temp.value;
          yield writer.put(block);
        }
      } catch (temp) {
        error = [temp];
      } finally {
        try {
          more && (temp = iter.return) && (yield temp.call(iter));
        } finally {
          if (error)
            throw error[0];
        }
      }
      yield writer.close();
      if (!userBlockstore) {
        yield blockstore.close();
      }
    });
    const out = {
      [Symbol.asyncIterator]() {
        if (writingPromise != null) {
          throw new Error("Multiple iterator not supported");
        }
        writingPromise = writeAll();
        return {
          next() {
            return __async(this, null, function* () {
              const result = yield carOutIter.next();
              if (result.done) {
                yield writingPromise;
              }
              return result;
            });
          }
        };
      }
    };
    return { root, out };
  });
}

// ../../node_modules/.pnpm/nft.storage@7.1.1_node-fetch@3.3.2/node_modules/nft.storage/src/lib.js
var import_throttled_queue = __toESM(require_throttledQueue(), 1);

// ../../node_modules/.pnpm/@web-std+fetch@4.2.1/node_modules/@web-std/fetch/src/fetch.js
var import_http2 = __toESM(require("http"), 1);
var import_https = __toESM(require("https"), 1);
var import_zlib = __toESM(require("zlib"), 1);
var import_fs3 = __toESM(require("fs"), 1);

// ../../node_modules/.pnpm/mrmime@1.0.1/node_modules/mrmime/index.mjs
var mimes = {
  "ez": "application/andrew-inset",
  "aw": "application/applixware",
  "atom": "application/atom+xml",
  "atomcat": "application/atomcat+xml",
  "atomdeleted": "application/atomdeleted+xml",
  "atomsvc": "application/atomsvc+xml",
  "dwd": "application/atsc-dwd+xml",
  "held": "application/atsc-held+xml",
  "rsat": "application/atsc-rsat+xml",
  "bdoc": "application/bdoc",
  "xcs": "application/calendar+xml",
  "ccxml": "application/ccxml+xml",
  "cdfx": "application/cdfx+xml",
  "cdmia": "application/cdmi-capability",
  "cdmic": "application/cdmi-container",
  "cdmid": "application/cdmi-domain",
  "cdmio": "application/cdmi-object",
  "cdmiq": "application/cdmi-queue",
  "cu": "application/cu-seeme",
  "mpd": "application/dash+xml",
  "davmount": "application/davmount+xml",
  "dbk": "application/docbook+xml",
  "dssc": "application/dssc+der",
  "xdssc": "application/dssc+xml",
  "es": "application/ecmascript",
  "ecma": "application/ecmascript",
  "emma": "application/emma+xml",
  "emotionml": "application/emotionml+xml",
  "epub": "application/epub+zip",
  "exi": "application/exi",
  "fdt": "application/fdt+xml",
  "pfr": "application/font-tdpfr",
  "geojson": "application/geo+json",
  "gml": "application/gml+xml",
  "gpx": "application/gpx+xml",
  "gxf": "application/gxf",
  "gz": "application/gzip",
  "hjson": "application/hjson",
  "stk": "application/hyperstudio",
  "ink": "application/inkml+xml",
  "inkml": "application/inkml+xml",
  "ipfix": "application/ipfix",
  "its": "application/its+xml",
  "jar": "application/java-archive",
  "war": "application/java-archive",
  "ear": "application/java-archive",
  "ser": "application/java-serialized-object",
  "class": "application/java-vm",
  "js": "application/javascript",
  "mjs": "application/javascript",
  "json": "application/json",
  "map": "application/json",
  "json5": "application/json5",
  "jsonml": "application/jsonml+json",
  "jsonld": "application/ld+json",
  "lgr": "application/lgr+xml",
  "lostxml": "application/lost+xml",
  "hqx": "application/mac-binhex40",
  "cpt": "application/mac-compactpro",
  "mads": "application/mads+xml",
  "webmanifest": "application/manifest+json",
  "mrc": "application/marc",
  "mrcx": "application/marcxml+xml",
  "ma": "application/mathematica",
  "nb": "application/mathematica",
  "mb": "application/mathematica",
  "mathml": "application/mathml+xml",
  "mbox": "application/mbox",
  "mscml": "application/mediaservercontrol+xml",
  "metalink": "application/metalink+xml",
  "meta4": "application/metalink4+xml",
  "mets": "application/mets+xml",
  "maei": "application/mmt-aei+xml",
  "musd": "application/mmt-usd+xml",
  "mods": "application/mods+xml",
  "m21": "application/mp21",
  "mp21": "application/mp21",
  "mp4s": "application/mp4",
  "m4p": "application/mp4",
  "doc": "application/msword",
  "dot": "application/msword",
  "mxf": "application/mxf",
  "nq": "application/n-quads",
  "nt": "application/n-triples",
  "cjs": "application/node",
  "bin": "application/octet-stream",
  "dms": "application/octet-stream",
  "lrf": "application/octet-stream",
  "mar": "application/octet-stream",
  "so": "application/octet-stream",
  "dist": "application/octet-stream",
  "distz": "application/octet-stream",
  "pkg": "application/octet-stream",
  "bpk": "application/octet-stream",
  "dump": "application/octet-stream",
  "elc": "application/octet-stream",
  "deploy": "application/octet-stream",
  "exe": "application/octet-stream",
  "dll": "application/octet-stream",
  "deb": "application/octet-stream",
  "dmg": "application/octet-stream",
  "iso": "application/octet-stream",
  "img": "application/octet-stream",
  "msi": "application/octet-stream",
  "msp": "application/octet-stream",
  "msm": "application/octet-stream",
  "buffer": "application/octet-stream",
  "oda": "application/oda",
  "opf": "application/oebps-package+xml",
  "ogx": "application/ogg",
  "omdoc": "application/omdoc+xml",
  "onetoc": "application/onenote",
  "onetoc2": "application/onenote",
  "onetmp": "application/onenote",
  "onepkg": "application/onenote",
  "oxps": "application/oxps",
  "relo": "application/p2p-overlay+xml",
  "xer": "application/patch-ops-error+xml",
  "pdf": "application/pdf",
  "pgp": "application/pgp-encrypted",
  "asc": "application/pgp-signature",
  "sig": "application/pgp-signature",
  "prf": "application/pics-rules",
  "p10": "application/pkcs10",
  "p7m": "application/pkcs7-mime",
  "p7c": "application/pkcs7-mime",
  "p7s": "application/pkcs7-signature",
  "p8": "application/pkcs8",
  "ac": "application/pkix-attr-cert",
  "cer": "application/pkix-cert",
  "crl": "application/pkix-crl",
  "pkipath": "application/pkix-pkipath",
  "pki": "application/pkixcmp",
  "pls": "application/pls+xml",
  "ai": "application/postscript",
  "eps": "application/postscript",
  "ps": "application/postscript",
  "provx": "application/provenance+xml",
  "cww": "application/prs.cww",
  "pskcxml": "application/pskc+xml",
  "raml": "application/raml+yaml",
  "rdf": "application/rdf+xml",
  "owl": "application/rdf+xml",
  "rif": "application/reginfo+xml",
  "rnc": "application/relax-ng-compact-syntax",
  "rl": "application/resource-lists+xml",
  "rld": "application/resource-lists-diff+xml",
  "rs": "application/rls-services+xml",
  "rapd": "application/route-apd+xml",
  "sls": "application/route-s-tsid+xml",
  "rusd": "application/route-usd+xml",
  "gbr": "application/rpki-ghostbusters",
  "mft": "application/rpki-manifest",
  "roa": "application/rpki-roa",
  "rsd": "application/rsd+xml",
  "rss": "application/rss+xml",
  "rtf": "application/rtf",
  "sbml": "application/sbml+xml",
  "scq": "application/scvp-cv-request",
  "scs": "application/scvp-cv-response",
  "spq": "application/scvp-vp-request",
  "spp": "application/scvp-vp-response",
  "sdp": "application/sdp",
  "senmlx": "application/senml+xml",
  "sensmlx": "application/sensml+xml",
  "setpay": "application/set-payment-initiation",
  "setreg": "application/set-registration-initiation",
  "shf": "application/shf+xml",
  "siv": "application/sieve",
  "sieve": "application/sieve",
  "smi": "application/smil+xml",
  "smil": "application/smil+xml",
  "rq": "application/sparql-query",
  "srx": "application/sparql-results+xml",
  "gram": "application/srgs",
  "grxml": "application/srgs+xml",
  "sru": "application/sru+xml",
  "ssdl": "application/ssdl+xml",
  "ssml": "application/ssml+xml",
  "swidtag": "application/swid+xml",
  "tei": "application/tei+xml",
  "teicorpus": "application/tei+xml",
  "tfi": "application/thraud+xml",
  "tsd": "application/timestamped-data",
  "toml": "application/toml",
  "trig": "application/trig",
  "ttml": "application/ttml+xml",
  "ubj": "application/ubjson",
  "rsheet": "application/urc-ressheet+xml",
  "td": "application/urc-targetdesc+xml",
  "vxml": "application/voicexml+xml",
  "wasm": "application/wasm",
  "wgt": "application/widget",
  "hlp": "application/winhlp",
  "wsdl": "application/wsdl+xml",
  "wspolicy": "application/wspolicy+xml",
  "xaml": "application/xaml+xml",
  "xav": "application/xcap-att+xml",
  "xca": "application/xcap-caps+xml",
  "xdf": "application/xcap-diff+xml",
  "xel": "application/xcap-el+xml",
  "xns": "application/xcap-ns+xml",
  "xenc": "application/xenc+xml",
  "xhtml": "application/xhtml+xml",
  "xht": "application/xhtml+xml",
  "xlf": "application/xliff+xml",
  "xml": "application/xml",
  "xsl": "application/xml",
  "xsd": "application/xml",
  "rng": "application/xml",
  "dtd": "application/xml-dtd",
  "xop": "application/xop+xml",
  "xpl": "application/xproc+xml",
  "xslt": "application/xml",
  "xspf": "application/xspf+xml",
  "mxml": "application/xv+xml",
  "xhvml": "application/xv+xml",
  "xvml": "application/xv+xml",
  "xvm": "application/xv+xml",
  "yang": "application/yang",
  "yin": "application/yin+xml",
  "zip": "application/zip",
  "3gpp": "video/3gpp",
  "adp": "audio/adpcm",
  "amr": "audio/amr",
  "au": "audio/basic",
  "snd": "audio/basic",
  "mid": "audio/midi",
  "midi": "audio/midi",
  "kar": "audio/midi",
  "rmi": "audio/midi",
  "mxmf": "audio/mobile-xmf",
  "mp3": "audio/mpeg",
  "m4a": "audio/mp4",
  "mp4a": "audio/mp4",
  "mpga": "audio/mpeg",
  "mp2": "audio/mpeg",
  "mp2a": "audio/mpeg",
  "m2a": "audio/mpeg",
  "m3a": "audio/mpeg",
  "oga": "audio/ogg",
  "ogg": "audio/ogg",
  "spx": "audio/ogg",
  "opus": "audio/ogg",
  "s3m": "audio/s3m",
  "sil": "audio/silk",
  "wav": "audio/wav",
  "weba": "audio/webm",
  "xm": "audio/xm",
  "ttc": "font/collection",
  "otf": "font/otf",
  "ttf": "font/ttf",
  "woff": "font/woff",
  "woff2": "font/woff2",
  "exr": "image/aces",
  "apng": "image/apng",
  "avif": "image/avif",
  "bmp": "image/bmp",
  "cgm": "image/cgm",
  "drle": "image/dicom-rle",
  "emf": "image/emf",
  "fits": "image/fits",
  "g3": "image/g3fax",
  "gif": "image/gif",
  "heic": "image/heic",
  "heics": "image/heic-sequence",
  "heif": "image/heif",
  "heifs": "image/heif-sequence",
  "hej2": "image/hej2k",
  "hsj2": "image/hsj2",
  "ief": "image/ief",
  "jls": "image/jls",
  "jp2": "image/jp2",
  "jpg2": "image/jp2",
  "jpeg": "image/jpeg",
  "jpg": "image/jpeg",
  "jpe": "image/jpeg",
  "jph": "image/jph",
  "jhc": "image/jphc",
  "jpm": "image/jpm",
  "jpx": "image/jpx",
  "jpf": "image/jpx",
  "jxr": "image/jxr",
  "jxra": "image/jxra",
  "jxrs": "image/jxrs",
  "jxs": "image/jxs",
  "jxsc": "image/jxsc",
  "jxsi": "image/jxsi",
  "jxss": "image/jxss",
  "ktx": "image/ktx",
  "ktx2": "image/ktx2",
  "png": "image/png",
  "btif": "image/prs.btif",
  "pti": "image/prs.pti",
  "sgi": "image/sgi",
  "svg": "image/svg+xml",
  "svgz": "image/svg+xml",
  "t38": "image/t38",
  "tif": "image/tiff",
  "tiff": "image/tiff",
  "tfx": "image/tiff-fx",
  "webp": "image/webp",
  "wmf": "image/wmf",
  "disposition-notification": "message/disposition-notification",
  "u8msg": "message/global",
  "u8dsn": "message/global-delivery-status",
  "u8mdn": "message/global-disposition-notification",
  "u8hdr": "message/global-headers",
  "eml": "message/rfc822",
  "mime": "message/rfc822",
  "3mf": "model/3mf",
  "gltf": "model/gltf+json",
  "glb": "model/gltf-binary",
  "igs": "model/iges",
  "iges": "model/iges",
  "msh": "model/mesh",
  "mesh": "model/mesh",
  "silo": "model/mesh",
  "mtl": "model/mtl",
  "obj": "model/obj",
  "stpz": "model/step+zip",
  "stpxz": "model/step-xml+zip",
  "stl": "model/stl",
  "wrl": "model/vrml",
  "vrml": "model/vrml",
  "x3db": "model/x3d+fastinfoset",
  "x3dbz": "model/x3d+binary",
  "x3dv": "model/x3d-vrml",
  "x3dvz": "model/x3d+vrml",
  "x3d": "model/x3d+xml",
  "x3dz": "model/x3d+xml",
  "appcache": "text/cache-manifest",
  "manifest": "text/cache-manifest",
  "ics": "text/calendar",
  "ifb": "text/calendar",
  "coffee": "text/coffeescript",
  "litcoffee": "text/coffeescript",
  "css": "text/css",
  "csv": "text/csv",
  "html": "text/html",
  "htm": "text/html",
  "shtml": "text/html",
  "jade": "text/jade",
  "jsx": "text/jsx",
  "less": "text/less",
  "markdown": "text/markdown",
  "md": "text/markdown",
  "mml": "text/mathml",
  "mdx": "text/mdx",
  "n3": "text/n3",
  "txt": "text/plain",
  "text": "text/plain",
  "conf": "text/plain",
  "def": "text/plain",
  "list": "text/plain",
  "log": "text/plain",
  "in": "text/plain",
  "ini": "text/plain",
  "dsc": "text/prs.lines.tag",
  "rtx": "text/richtext",
  "sgml": "text/sgml",
  "sgm": "text/sgml",
  "shex": "text/shex",
  "slim": "text/slim",
  "slm": "text/slim",
  "spdx": "text/spdx",
  "stylus": "text/stylus",
  "styl": "text/stylus",
  "tsv": "text/tab-separated-values",
  "t": "text/troff",
  "tr": "text/troff",
  "roff": "text/troff",
  "man": "text/troff",
  "me": "text/troff",
  "ms": "text/troff",
  "ttl": "text/turtle",
  "uri": "text/uri-list",
  "uris": "text/uri-list",
  "urls": "text/uri-list",
  "vcard": "text/vcard",
  "vtt": "text/vtt",
  "yaml": "text/yaml",
  "yml": "text/yaml",
  "3gp": "video/3gpp",
  "3g2": "video/3gpp2",
  "h261": "video/h261",
  "h263": "video/h263",
  "h264": "video/h264",
  "m4s": "video/iso.segment",
  "jpgv": "video/jpeg",
  "jpgm": "image/jpm",
  "mj2": "video/mj2",
  "mjp2": "video/mj2",
  "ts": "video/mp2t",
  "mp4": "video/mp4",
  "mp4v": "video/mp4",
  "mpg4": "video/mp4",
  "mpeg": "video/mpeg",
  "mpg": "video/mpeg",
  "mpe": "video/mpeg",
  "m1v": "video/mpeg",
  "m2v": "video/mpeg",
  "ogv": "video/ogg",
  "qt": "video/quicktime",
  "mov": "video/quicktime",
  "webm": "video/webm"
};
function lookup(extn) {
  let tmp = ("" + extn).trim().toLowerCase();
  let idx = tmp.lastIndexOf(".");
  return mimes[!~idx ? tmp : tmp.substring(++idx)];
}

// ../../node_modules/.pnpm/@web-std+fetch@4.2.1/node_modules/@web-std/fetch/src/fetch.js
var import_data_uri_to_buffer = __toESM(require_src4(), 1);
var import_buffer = require("buffer");

// ../../node_modules/.pnpm/@web-std+fetch@4.2.1/node_modules/@web-std/fetch/src/body.js
var import_stream4 = __toESM(require("stream"), 1);
var import_util5 = require("util");

// ../../node_modules/.pnpm/web-encoding@1.1.5/node_modules/web-encoding/src/lib.mjs
var Encoder2 = TextEncoder;
var Decoder2 = TextDecoder;

// ../../node_modules/.pnpm/@web-std+stream@1.0.0/node_modules/@web-std/stream/src/lib.node.js
var import_stream = __toESM(require_stream(), 1);
var {
  ReadableStream: ReadableStream2,
  ReadableStreamDefaultReader: ReadableStreamDefaultReader2,
  ReadableStreamBYOBReader: ReadableStreamBYOBReader2,
  ReadableStreamBYOBRequest: ReadableStreamBYOBRequest2,
  ReadableByteStreamController: ReadableByteStreamController2,
  ReadableStreamDefaultController: ReadableStreamDefaultController2,
  TransformStream: TransformStream2,
  TransformStreamDefaultController: TransformStreamDefaultController2,
  WritableStream: WritableStream2,
  WritableStreamDefaultWriter: WritableStreamDefaultWriter2,
  WritableStreamDefaultController: WritableStreamDefaultController2,
  ByteLengthQueuingStrategy: ByteLengthQueuingStrategy2,
  CountQueuingStrategy: CountQueuingStrategy2,
  TextEncoderStream,
  TextDecoderStream
} = import_stream.default;

// ../../node_modules/.pnpm/@web-std+blob@3.0.5/node_modules/@web-std/blob/src/blob.js
var WebBlob = class Blob {
  /**
   * @param {BlobPart[]} [init]
   * @param {BlobPropertyBag} [options]
   */
  constructor(init = [], options = {}) {
    const parts = [];
    let size = 0;
    for (const part of init) {
      if (typeof part === "string") {
        const bytes = new Encoder2().encode(part);
        parts.push(bytes);
        size += bytes.byteLength;
      } else if (part instanceof WebBlob) {
        size += part.size;
        parts.push(...part._parts);
      } else if (part instanceof ArrayBuffer) {
        parts.push(new Uint8Array(part));
        size += part.byteLength;
      } else if (part instanceof Uint8Array) {
        parts.push(part);
        size += part.byteLength;
      } else if (ArrayBuffer.isView(part)) {
        const { buffer: buffer2, byteOffset, byteLength } = part;
        parts.push(new Uint8Array(buffer2, byteOffset, byteLength));
        size += byteLength;
      } else {
        const bytes = new Encoder2().encode(String(part));
        parts.push(bytes);
        size += bytes.byteLength;
      }
    }
    this._size = size;
    this._type = readType(options.type);
    this._parts = parts;
    Object.defineProperties(this, {
      _size: { enumerable: false },
      _type: { enumerable: false },
      _parts: { enumerable: false }
    });
  }
  /**
   * A string indicating the MIME type of the data contained in the Blob.
   * If the type is unknown, this string is empty.
   * @type {string}
   */
  get type() {
    return this._type;
  }
  /**
   * The size, in bytes, of the data contained in the Blob object.
   * @type {number}
   */
  get size() {
    return this._size;
  }
  /**
   * Returns a new Blob object containing the data in the specified range of
   * bytes of the blob on which it's called.
   * @param {number} [start=0] - An index into the Blob indicating the first
   * byte to include in the new Blob. If you specify a negative value, it's
   * treated as an offset from the end of the Blob toward the beginning. For
   * example, `-10` would be the 10th from last byte in the Blob. The default
   * value is `0`. If you specify a value for start that is larger than the
   * size of the source Blob, the returned Blob has size 0 and contains no
   * data.
   * @param {number} [end] - An index into the `Blob` indicating the first byte
   *  that will *not* be included in the new `Blob` (i.e. the byte exactly at
   * this index is not included). If you specify a negative value, it's treated
   * as an offset from the end of the Blob toward the beginning. For example,
   * `-10` would be the 10th from last byte in the `Blob`. The default value is
   * size.
   * @param {string} [type] - The content type to assign to the new Blob;
   * this will be the value of its type property. The default value is an empty
   * string.
   * @returns {Blob}
   */
  slice(start = 0, end = this.size, type = "") {
    const { size, _parts } = this;
    let offset = start < 0 ? Math.max(size + start, 0) : Math.min(start, size);
    let limit = end < 0 ? Math.max(size + end, 0) : Math.min(end, size);
    const span = Math.max(limit - offset, 0);
    const blob = new Blob([], { type });
    if (span === 0) {
      return blob;
    }
    let blobSize = 0;
    const blobParts = [];
    for (const part of _parts) {
      const { byteLength } = part;
      if (offset > 0 && byteLength <= offset) {
        offset -= byteLength;
        limit -= byteLength;
      } else {
        const chunk = part.subarray(offset, Math.min(byteLength, limit));
        blobParts.push(chunk);
        blobSize += chunk.byteLength;
        offset = 0;
        if (blobSize >= span) {
          break;
        }
      }
    }
    blob._parts = blobParts;
    blob._size = blobSize;
    return blob;
  }
  /**
   * Returns a promise that resolves with an ArrayBuffer containing the entire
   * contents of the Blob as binary data.
   * @returns {Promise<ArrayBuffer>}
   */
  // eslint-disable-next-line require-await
  arrayBuffer() {
    return __async(this, null, function* () {
      const buffer2 = new ArrayBuffer(this.size);
      const bytes = new Uint8Array(buffer2);
      let offset = 0;
      for (const part of this._parts) {
        bytes.set(part, offset);
        offset += part.byteLength;
      }
      return buffer2;
    });
  }
  /**
   * Returns a promise that resolves with a USVString containing the entire
   * contents of the Blob interpreted as UTF-8 text.
   * @returns {Promise<string>}
   */
  // eslint-disable-next-line require-await
  text() {
    return __async(this, null, function* () {
      const decoder2 = new Decoder2();
      let text = "";
      for (const part of this._parts) {
        text += decoder2.decode(part);
      }
      return text;
    });
  }
  /**
   * @returns {BlobStream}
   */
  stream() {
    return new BlobStream(this._parts);
  }
  /**
   * @returns {string}
   */
  toString() {
    return "[object Blob]";
  }
  get [Symbol.toStringTag]() {
    return "Blob";
  }
};
var Blob2 = WebBlob;
var BlobStream = class extends ReadableStream2 {
  /**
   * @param {Uint8Array[]} chunks
   */
  constructor(chunks) {
    super(new BlobStreamController(chunks.values()), { type: "bytes" });
    this._chunks = chunks;
  }
  /**
   * @param {Object} [_options]
   * @property {boolean} [_options.preventCancel]
   * @returns {AsyncIterator<Uint8Array>}
   */
  [Symbol.asyncIterator](_options) {
    return __asyncGenerator(this, null, function* () {
      const reader = this.getReader();
      yield* __yieldStar(this._chunks);
      reader.releaseLock();
    });
  }
};
var BlobStreamController = class {
  /**
   * @param {Iterator<Uint8Array>} chunks
   */
  constructor(chunks) {
    this.chunks = chunks;
  }
  /**
   * @param {ReadableStreamDefaultController} controller
   */
  start(controller) {
    this.work(controller);
    this.isWorking = false;
    this.isCancelled = false;
  }
  /**
   *
   * @param {ReadableStreamDefaultController} controller
   */
  work(controller) {
    return __async(this, null, function* () {
      const { chunks } = this;
      this.isWorking = true;
      while (!this.isCancelled && (controller.desiredSize || 0) > 0) {
        let next = null;
        try {
          next = chunks.next();
        } catch (error) {
          controller.error(error);
          break;
        }
        if (next) {
          if (!next.done && !this.isCancelled) {
            controller.enqueue(next.value);
          } else {
            controller.close();
          }
        }
      }
      this.isWorking = false;
    });
  }
  /**
   * @param {ReadableStreamDefaultController} controller
   */
  pull(controller) {
    if (!this.isWorking) {
      this.work(controller);
    }
  }
  cancel() {
    this.isCancelled = true;
  }
};
var readType = (input = "") => {
  const type = String(input).toLowerCase();
  return /[^\u0020-\u007E]/.test(type) ? "" : type;
};

// ../../node_modules/.pnpm/@web-std+blob@3.0.5/node_modules/@web-std/blob/src/lib.node.js
var Blob3 = globalThis.Blob || // Disable node native blob until impractical perf issue is fixed
// @see https://github.com/nodejs/node/issues/42108
// NodeBlob ||
Blob2;

// ../../node_modules/.pnpm/@web-std+file@3.0.3/node_modules/@web-std/file/src/file.js
var File = class extends Blob3 {
  /**
   *
   * @param {BlobPart[]} init
   * @param {string} name - A USVString representing the file name or the path
   * to the file.
   * @param {FilePropertyBag} [options]
   */
  constructor(init, name5 = panic(new TypeError("File constructor requires name argument")), options = {}) {
    super(init, options);
    this._name = name5;
    this._lastModified = options.lastModified || Date.now();
  }
  /**
   * The name of the file referenced by the File object.
   * @type {string}
   */
  get name() {
    return this._name;
  }
  /**
   * The path the URL of the File is relative to.
   * @type {string}
   */
  get webkitRelativePath() {
    return "";
  }
  /**
   * Returns the last modified time of the file, in millisecond since the UNIX
   * epoch (January 1st, 1970 at Midnight).
   * @returns {number}
   */
  get lastModified() {
    return this._lastModified;
  }
  get [Symbol.toStringTag]() {
    return "File";
  }
};
var panic = (error) => {
  throw error;
};

// ../../node_modules/.pnpm/@web-std+file@3.0.3/node_modules/@web-std/file/src/lib.node.js
var File2 = typeof globalThis.File === "function" ? globalThis.File : File;

// ../../node_modules/.pnpm/@web-std+form-data@3.1.0/node_modules/@web-std/form-data/src/form-data.js
var FormData = class {
  /**
   * @param {HTMLFormElement} [form]
   */
  constructor(form) {
    this._entries = [];
    Object.defineProperty(this, "_entries", { enumerable: false });
    if (isHTMLFormElement(form)) {
      for (const element of form.elements) {
        if (isSelectElement(element)) {
          for (const option of element.options) {
            if (option.selected) {
              this.append(element.name, option.value);
            }
          }
        } else if (isInputElement(element) && (element.checked || !["radio", "checkbox"].includes(element.type)) && element.name) {
          this.append(element.name, element.value);
        }
      }
    }
  }
  get [Symbol.toStringTag]() {
    return "FormData";
  }
  /**
   * Appends a new value onto an existing key inside a FormData object, or adds
   * the key if it does not already exist.
   *
   * The difference between `set` and `append` is that if the specified key
   * already exists, `set` will overwrite all existing values with the new one,
   * whereas `append` will append the new value onto the end of the existing
   * set of values.
   *
   * @param {string} name
   * @param {string|Blob|File} value - The name of the field whose data is
   * contained in value.
   * @param {string} [filename] - The filename reported to the server, when a
   * value is a `Blob` or a `File`. The default filename for a `Blob` objects is
   * `"blob"`. The default filename for a `File` is the it's name.
   */
  append(name5, value = panic2(
    new TypeError("FormData.append: requires at least 2 arguments")
  ), filename) {
    this._entries.push([name5, toEntryValue(value, filename)]);
  }
  /**
   * Deletes a key and all its values from a FormData object.
   *
   * @param {string} name
   */
  delete(name5 = panic2(new TypeError("FormData.delete: requires string argument"))) {
    const entries = this._entries;
    let index = 0;
    while (index < entries.length) {
      const [entryName] = (
        /** @type {[string, FormDataEntryValue]}*/
        entries[index]
      );
      if (entryName === name5) {
        entries.splice(index, 1);
      } else {
        index++;
      }
    }
  }
  /**
   * Returns the first value associated with a given key from within a
   * FormData object.
   *
   * @param {string} name
   * @returns {FormDataEntryValue|null}
   */
  get(name5 = panic2(new TypeError("FormData.get: requires string argument"))) {
    for (const [entryName, value] of this._entries) {
      if (entryName === name5) {
        return value;
      }
    }
    return null;
  }
  /**
   * Returns an array of all the values associated with a given key from within
   * a FormData.
   *
   * @param {string} name
   * @returns {FormDataEntryValue[]}
   */
  getAll(name5 = panic2(new TypeError("FormData.getAll: requires string argument"))) {
    const values = [];
    for (const [entryName, value] of this._entries) {
      if (entryName === name5) {
        values.push(value);
      }
    }
    return values;
  }
  /**
   * Returns a boolean stating whether a FormData object contains a certain key.
   *
   * @param {string} name
   */
  has(name5 = panic2(new TypeError("FormData.has: requires string argument"))) {
    for (const [entryName] of this._entries) {
      if (entryName === name5) {
        return true;
      }
    }
    return false;
  }
  /**
   * Sets a new value for an existing key inside a FormData object, or adds the
   * key/value if it does not already exist.
   *
   * @param {string} name
   * @param {string|Blob|File} value
   * @param {string} [filename]
   */
  set(name5, value = panic2(new TypeError("FormData.set: requires at least 2 arguments")), filename) {
    let index = 0;
    const { _entries: entries } = this;
    const entryValue = toEntryValue(value, filename);
    let wasSet = false;
    while (index < entries.length) {
      const entry = (
        /** @type {[string, FormDataEntryValue]}*/
        entries[index]
      );
      if (entry[0] === name5) {
        if (wasSet) {
          entries.splice(index, 1);
        } else {
          wasSet = true;
          entry[1] = entryValue;
          index++;
        }
      } else {
        index++;
      }
    }
    if (!wasSet) {
      entries.push([name5, entryValue]);
    }
  }
  /**
   * Method returns an iterator allowing to go through all key/value pairs
   * contained in this object.
   */
  entries() {
    return this._entries.values();
  }
  /**
   * Returns an iterator allowing to go through all keys of the key/value pairs
   * contained in this object.
   *
   * @returns {IterableIterator<string>}
   */
  *keys() {
    for (const [name5] of this._entries) {
      yield name5;
    }
  }
  /**
   * Returns an iterator allowing to go through all values contained in this
   * object.
   *
   * @returns {IterableIterator<FormDataEntryValue>}
   */
  *values() {
    for (const [_, value] of this._entries) {
      yield value;
    }
  }
  [Symbol.iterator]() {
    return this._entries.values();
  }
  /**
   * @param {(value: FormDataEntryValue, key: string, parent: globalThis.FormData) => void} fn
   * @param {any} [thisArg]
   * @returns {void}
   */
  forEach(fn, thisArg) {
    for (const [key, value] of this._entries) {
      fn.call(thisArg, value, key, this);
    }
  }
};
var isHTMLFormElement = (value) => Object.prototype.toString.call(value) === "[object HTMLFormElement]";
var toEntryValue = (value, filename) => {
  if (isFile(value)) {
    return filename != null ? new BlobFile([value], filename, value) : value;
  } else if (isBlob3(value)) {
    return new BlobFile([value], filename != null ? filename : "blob");
  } else {
    if (filename != null && filename != "") {
      throw new TypeError(
        "filename is only supported when value is Blob or File"
      );
    }
    return `${value}`;
  }
};
var isFile = (value) => Object.prototype.toString.call(value) === "[object File]" && typeof value.name === "string";
var isBlob3 = (value) => Object.prototype.toString.call(value) === "[object Blob]";
var BlobFile = class File3 {
  /**
   * @param {[Blob]} parts
   * @param {string} name
   * @param {FilePropertyBag} [options]
   */
  constructor([blob], name5, { lastModified = Date.now() } = {}) {
    this.blob = blob;
    this.name = name5;
    this.lastModified = lastModified;
  }
  get webkitRelativePath() {
    return "";
  }
  get size() {
    return this.blob.size;
  }
  get type() {
    return this.blob.type;
  }
  /**
   *
   * @param {number} [start]
   * @param {number} [end]
   * @param {string} [contentType]
   */
  slice(start, end, contentType) {
    return this.blob.slice(start, end, contentType);
  }
  stream() {
    return this.blob.stream();
  }
  text() {
    return this.blob.text();
  }
  arrayBuffer() {
    return this.blob.arrayBuffer();
  }
  get [Symbol.toStringTag]() {
    return "File";
  }
};
var panic2 = (error) => {
  throw error;
};
function isSelectElement(element) {
  return element.tagName === "SELECT";
}
function isInputElement(element) {
  return element.tagName === "INPUT" || element.tagName === "TEXTAREA";
}

// ../../node_modules/.pnpm/@web-std+form-data@3.1.0/node_modules/@web-std/form-data/src/lib.node.js
var FormData2 = typeof globalThis.FormData === "function" ? globalThis.FormData : FormData;

// ../../node_modules/.pnpm/@web-std+fetch@4.2.1/node_modules/@web-std/fetch/src/errors/base.js
var FetchBaseError = class extends Error {
  /**
   * @param {string} message 
   * @param {string} type 
   */
  constructor(message, type) {
    super(message);
    Error.captureStackTrace(this, this.constructor);
    this.type = type;
  }
  get name() {
    return this.constructor.name;
  }
  get [Symbol.toStringTag]() {
    return this.constructor.name;
  }
};

// ../../node_modules/.pnpm/@web-std+fetch@4.2.1/node_modules/@web-std/fetch/src/errors/fetch-error.js
var FetchError = class extends FetchBaseError {
  /**
   * @param  {string} message -      Error message for human
   * @param  {string} type -        Error type for machine
   * @param  {SystemError} [systemError] - For Node.js system error
   */
  constructor(message, type, systemError) {
    super(message, type);
    if (systemError) {
      this.code = this.errno = systemError.code;
      this.erroredSysCall = systemError.syscall;
    }
  }
};

// ../../node_modules/.pnpm/@web-std+fetch@4.2.1/node_modules/@web-std/fetch/src/utils/form-data.js
var import_crypto2 = require("crypto");

// ../../node_modules/.pnpm/@web3-storage+multipart-parser@1.0.0/node_modules/@web3-storage/multipart-parser/esm/src/utils.js
function stringToArray(s) {
  const utf8 = unescape(encodeURIComponent(s));
  return Uint8Array.from(utf8, (_, i) => utf8.charCodeAt(i));
}
function arrayToString(a) {
  const utf8 = String.fromCharCode.apply(null, a);
  return decodeURIComponent(escape(utf8));
}
function mergeArrays(...arrays) {
  const out = new Uint8Array(arrays.reduce((total, arr) => total + arr.length, 0));
  let offset = 0;
  for (const arr of arrays) {
    out.set(arr, offset);
    offset += arr.length;
  }
  return out;
}
function arraysEqual(a, b) {
  if (a.length !== b.length) {
    return false;
  }
  for (let i = 0; i < a.length; i++) {
    if (a[i] !== b[i]) {
      return false;
    }
  }
  return true;
}

// ../../node_modules/.pnpm/@web3-storage+multipart-parser@1.0.0/node_modules/@web3-storage/multipart-parser/esm/src/search.js
function coerce2(a) {
  if (a instanceof Uint8Array) {
    return (index) => a[index];
  }
  return a;
}
function jsmemcmp(buf1, pos1, buf2, pos2, len) {
  const fn1 = coerce2(buf1);
  const fn2 = coerce2(buf2);
  for (let i = 0; i < len; ++i) {
    if (fn1(pos1 + i) !== fn2(pos2 + i)) {
      return false;
    }
  }
  return true;
}
function createOccurenceTable(s) {
  const table = new Array(256).fill(s.length);
  if (s.length > 1) {
    for (let i = 0; i < s.length - 1; i++) {
      table[s[i]] = s.length - 1 - i;
    }
  }
  return table;
}
var MATCH = Symbol("Match");
var StreamSearch = class {
  constructor(needle) {
    this._lookbehind = new Uint8Array();
    if (typeof needle === "string") {
      this._needle = needle = stringToArray(needle);
    } else {
      this._needle = needle;
    }
    this._lastChar = needle[needle.length - 1];
    this._occ = createOccurenceTable(needle);
  }
  feed(chunk) {
    let pos = 0;
    let tokens;
    const allTokens = [];
    while (pos !== chunk.length) {
      ;
      [pos, ...tokens] = this._feed(chunk, pos);
      allTokens.push(...tokens);
    }
    return allTokens;
  }
  end() {
    const tail = this._lookbehind;
    this._lookbehind = new Uint8Array();
    return tail;
  }
  _feed(data, bufPos) {
    const tokens = [];
    let pos = -this._lookbehind.length;
    if (pos < 0) {
      while (pos < 0 && pos <= data.length - this._needle.length) {
        const ch = this._charAt(data, pos + this._needle.length - 1);
        if (ch === this._lastChar && this._memcmp(data, pos, this._needle.length - 1)) {
          if (pos > -this._lookbehind.length) {
            tokens.push(this._lookbehind.slice(0, this._lookbehind.length + pos));
          }
          tokens.push(MATCH);
          this._lookbehind = new Uint8Array();
          return [
            pos + this._needle.length,
            ...tokens
          ];
        } else {
          pos += this._occ[ch];
        }
      }
      if (pos < 0) {
        while (pos < 0 && !this._memcmp(data, pos, data.length - pos)) {
          pos++;
        }
      }
      if (pos >= 0) {
        tokens.push(this._lookbehind);
        this._lookbehind = new Uint8Array();
      } else {
        const bytesToCutOff = this._lookbehind.length + pos;
        if (bytesToCutOff > 0) {
          tokens.push(this._lookbehind.slice(0, bytesToCutOff));
          this._lookbehind = this._lookbehind.slice(bytesToCutOff);
        }
        this._lookbehind = Uint8Array.from(new Array(this._lookbehind.length + data.length), (_, i) => this._charAt(data, i - this._lookbehind.length));
        return [
          data.length,
          ...tokens
        ];
      }
    }
    pos += bufPos;
    while (pos <= data.length - this._needle.length) {
      const ch = data[pos + this._needle.length - 1];
      if (ch === this._lastChar && data[pos] === this._needle[0] && jsmemcmp(this._needle, 0, data, pos, this._needle.length - 1)) {
        if (pos > bufPos) {
          tokens.push(data.slice(bufPos, pos));
        }
        tokens.push(MATCH);
        return [
          pos + this._needle.length,
          ...tokens
        ];
      } else {
        pos += this._occ[ch];
      }
    }
    if (pos < data.length) {
      while (pos < data.length && (data[pos] !== this._needle[0] || !jsmemcmp(data, pos, this._needle, 0, data.length - pos))) {
        ++pos;
      }
      if (pos < data.length) {
        this._lookbehind = data.slice(pos);
      }
    }
    if (pos > 0) {
      tokens.push(data.slice(bufPos, pos < data.length ? pos : data.length));
    }
    return [
      data.length,
      ...tokens
    ];
  }
  _charAt(data, pos) {
    if (pos < 0) {
      return this._lookbehind[this._lookbehind.length + pos];
    }
    return data[pos];
  }
  _memcmp(data, pos, len) {
    return jsmemcmp(this._charAt.bind(this, data), pos, this._needle, 0, len);
  }
};
var ReadableStreamSearch = class {
  constructor(needle, _readableStream) {
    this._readableStream = _readableStream;
    this._search = new StreamSearch(needle);
  }
  [Symbol.asyncIterator]() {
    return __asyncGenerator(this, null, function* () {
      const reader = this._readableStream.getReader();
      try {
        while (true) {
          const result = yield new __await(reader.read());
          if (result.done) {
            break;
          }
          yield* __yieldStar(this._search.feed(result.value));
        }
        const tail = this._search.end();
        if (tail.length) {
          yield tail;
        }
      } finally {
        reader.releaseLock();
      }
    });
  }
};
var EOQ = Symbol("End of Queue");
var QueueableStreamSearch = class {
  constructor(needle) {
    this._chunksQueue = [];
    this._closed = false;
    this._search = new StreamSearch(needle);
  }
  push(...chunks) {
    if (this._closed) {
      throw new Error("cannot call push after close");
    }
    this._chunksQueue.push(...chunks);
    if (this._notify) {
      this._notify();
    }
  }
  close() {
    if (this._closed) {
      throw new Error("close was already called");
    }
    this._closed = true;
    this._chunksQueue.push(EOQ);
    if (this._notify) {
      this._notify();
    }
  }
  [Symbol.asyncIterator]() {
    return __asyncGenerator(this, null, function* () {
      while (true) {
        let chunk;
        while (!(chunk = this._chunksQueue.shift())) {
          yield new __await(new Promise((resolve) => this._notify = resolve));
          this._notify = void 0;
        }
        if (chunk === EOQ) {
          break;
        }
        yield* __yieldStar(this._search.feed(chunk));
      }
      const tail = this._search.end();
      if (tail.length) {
        yield tail;
      }
    });
  }
};

// ../../node_modules/.pnpm/@web3-storage+multipart-parser@1.0.0/node_modules/@web3-storage/multipart-parser/esm/src/index.js
var mergeArrays2 = Function.prototype.apply.bind(mergeArrays, void 0);
var dash = stringToArray("--");
var CRLF = stringToArray("\r\n");
function parseContentDisposition(header) {
  const parts = header.split(";").map((part) => part.trim());
  if (parts.shift() !== "form-data") {
    throw new Error('malformed content-disposition header: missing "form-data" in `' + JSON.stringify(parts) + "`");
  }
  const out = {};
  for (const part of parts) {
    const kv = part.split("=", 2);
    if (kv.length !== 2) {
      throw new Error("malformed content-disposition header: key-value pair not found - " + part + " in `" + header + "`");
    }
    const [name5, value] = kv;
    if (value[0] === '"' && value[value.length - 1] === '"') {
      out[name5] = value.slice(1, -1).replace(/\\"/g, '"');
    } else if (value[0] !== '"' && value[value.length - 1] !== '"') {
      out[name5] = value;
    } else if (value[0] === '"' && value[value.length - 1] !== '"' || value[0] !== '"' && value[value.length - 1] === '"') {
      throw new Error("malformed content-disposition header: mismatched quotations in `" + header + "`");
    }
  }
  if (!out.name) {
    throw new Error("malformed content-disposition header: missing field name in `" + header + "`");
  }
  return out;
}
function parsePartHeaders(lines) {
  const entries = [];
  let disposition = false;
  let line;
  while (typeof (line = lines.shift()) !== "undefined") {
    const colon = line.indexOf(":");
    if (colon === -1) {
      throw new Error("malformed multipart-form header: missing colon");
    }
    const header = line.slice(0, colon).trim().toLowerCase();
    const value = line.slice(colon + 1).trim();
    switch (header) {
      case "content-disposition":
        disposition = true;
        entries.push(...Object.entries(parseContentDisposition(value)));
        break;
      case "content-type":
        entries.push([
          "contentType",
          value
        ]);
    }
  }
  if (!disposition) {
    throw new Error("malformed multipart-form header: missing content-disposition");
  }
  return Object.fromEntries(entries);
}
function readHeaderLines(it, needle) {
  return __async(this, null, function* () {
    let firstChunk = true;
    let lastTokenWasMatch = false;
    const headerLines = [[]];
    const crlfSearch = new StreamSearch(CRLF);
    for (; ; ) {
      const result = yield it.next();
      if (result.done) {
        throw new Error("malformed multipart-form data: unexpected end of stream");
      }
      if (firstChunk && result.value !== MATCH && arraysEqual(result.value.slice(0, 2), dash)) {
        return [
          void 0,
          new Uint8Array()
        ];
      }
      let chunk;
      if (result.value !== MATCH) {
        chunk = result.value;
      } else if (!lastTokenWasMatch) {
        chunk = needle;
      } else {
        throw new Error("malformed multipart-form data: unexpected boundary");
      }
      if (!chunk.length) {
        continue;
      }
      if (firstChunk) {
        firstChunk = false;
      }
      const tokens = crlfSearch.feed(chunk);
      for (const [i, token] of tokens.entries()) {
        const isMatch = token === MATCH;
        if (!isMatch && !token.length) {
          continue;
        }
        if (lastTokenWasMatch && isMatch) {
          tokens.push(crlfSearch.end());
          return [
            headerLines.filter((chunks) => chunks.length).map(mergeArrays2).map(arrayToString),
            mergeArrays(...tokens.slice(i + 1).map((token2) => token2 === MATCH ? CRLF : token2))
          ];
        }
        if (lastTokenWasMatch = isMatch) {
          headerLines.push([]);
        } else {
          headerLines[headerLines.length - 1].push(token);
        }
      }
    }
  });
}
function streamMultipart(body, boundary) {
  return __asyncGenerator(this, null, function* () {
    const needle = mergeArrays(dash, stringToArray(boundary));
    const it = new ReadableStreamSearch(needle, body)[Symbol.asyncIterator]();
    for (; ; ) {
      const result = yield new __await(it.next());
      if (result.done) {
        return;
      }
      if (result.value === MATCH) {
        break;
      }
    }
    const crlfSearch = new StreamSearch(CRLF);
    for (; ; ) {
      let feedChunk2 = function(chunk) {
        const chunks = [];
        for (const token of crlfSearch.feed(chunk)) {
          if (trailingCRLF) {
            chunks.push(CRLF);
          }
          if (!(trailingCRLF = token === MATCH)) {
            chunks.push(token);
          }
        }
        return mergeArrays(...chunks);
      };
      var feedChunk = feedChunk2;
      let _a2;
      const [headerLines, tail] = yield new __await(readHeaderLines(it, needle));
      if (!headerLines) {
        return;
      }
      function nextToken() {
        return __async(this, null, function* () {
          const result = yield it.next();
          if (result.done) {
            throw new Error("malformed multipart-form data: unexpected end of stream");
          }
          return result;
        });
      }
      let trailingCRLF = false;
      let done = false;
      function nextChunk() {
        return __async(this, null, function* () {
          const result = yield nextToken();
          let chunk;
          if (result.value !== MATCH) {
            chunk = result.value;
          } else if (!trailingCRLF) {
            chunk = CRLF;
          } else {
            done = true;
            return { value: crlfSearch.end() };
          }
          return { value: feedChunk2(chunk) };
        });
      }
      const bufferedChunks = [{ value: feedChunk2(tail) }];
      yield __spreadProps(__spreadValues({}, parsePartHeaders(headerLines)), {
        data: {
          [Symbol.asyncIterator]() {
            return this;
          },
          next() {
            return __async(this, null, function* () {
              for (; ; ) {
                const result = bufferedChunks.shift();
                if (!result) {
                  break;
                }
                if (result.value.length > 0) {
                  return result;
                }
              }
              for (; ; ) {
                if (done) {
                  return {
                    done,
                    value: void 0
                  };
                }
                const result = yield nextChunk();
                if (result.value.length > 0) {
                  return result;
                }
              }
            });
          }
        }
      });
      while (!done) {
        bufferedChunks.push(yield new __await(nextChunk()));
      }
    }
  });
}
function iterateMultipart(body, boundary) {
  return __asyncGenerator(this, null, function* () {
    try {
      for (var iter2 = __forAwait(streamMultipart(body, boundary)), more2, temp2, error2; more2 = !(temp2 = yield new __await(iter2.next())).done; more2 = false) {
        const part = temp2.value;
        const chunks = [];
        try {
          for (var iter = __forAwait(part.data), more, temp, error; more = !(temp = yield new __await(iter.next())).done; more = false) {
            const chunk = temp.value;
            chunks.push(chunk);
          }
        } catch (temp) {
          error = [temp];
        } finally {
          try {
            more && (temp = iter.return) && (yield new __await(temp.call(iter)));
          } finally {
            if (error)
              throw error[0];
          }
        }
        yield __spreadProps(__spreadValues({}, part), {
          data: mergeArrays(...chunks)
        });
      }
    } catch (temp2) {
      error2 = [temp2];
    } finally {
      try {
        more2 && (temp2 = iter2.return) && (yield new __await(temp2.call(iter2)));
      } finally {
        if (error2)
          throw error2[0];
      }
    }
  });
}

// ../../node_modules/.pnpm/@web-std+fetch@4.2.1/node_modules/@web-std/fetch/src/utils/is.js
var import_stream3 = __toESM(require("stream"), 1);
var NAME = Symbol.toStringTag;
var isURLSearchParameters = (object) => {
  return typeof object === "object" && typeof object.append === "function" && typeof object.delete === "function" && typeof object.get === "function" && typeof object.getAll === "function" && typeof object.has === "function" && typeof object.set === "function" && typeof object.sort === "function" && object[NAME] === "URLSearchParams";
};
var isBlob4 = (object) => {
  return typeof object === "object" && typeof object.arrayBuffer === "function" && typeof object.type === "string" && typeof object.stream === "function" && typeof object.constructor === "function" && /^(Blob|File)$/.test(object[NAME]);
};
function isFormData(object) {
  return typeof object === "object" && typeof object.append === "function" && typeof object.set === "function" && typeof object.get === "function" && typeof object.getAll === "function" && typeof object.delete === "function" && typeof object.keys === "function" && typeof object.values === "function" && typeof object.entries === "function" && typeof object.constructor === "function" && object[NAME] === "FormData";
}
var isMultipartFormDataStream = (value) => {
  return value instanceof import_stream3.default === true && typeof value.getBoundary === "function" && typeof value.hasKnownLength === "function" && typeof value.getLengthSync === "function";
};
var isAbortSignal2 = (object) => {
  return typeof object === "object" && (object[NAME] === "AbortSignal" || object[NAME] === "EventTarget");
};
var isReadableStream2 = (value) => {
  return typeof value === "object" && typeof value.getReader === "function" && typeof value.cancel === "function" && typeof value.tee === "function";
};
var isIterable2 = (value) => value && Symbol.iterator in value;

// ../../node_modules/.pnpm/@web-std+fetch@4.2.1/node_modules/@web-std/fetch/src/utils/form-data.js
var carriage = "\r\n";
var dashes = "-".repeat(2);
var carriageLength = Buffer.byteLength(carriage);
var getFooter = (boundary) => `${dashes}${boundary}${dashes}${carriage.repeat(2)}`;
function getHeader(boundary, name5, field) {
  let header = "";
  header += `${dashes}${boundary}${carriage}`;
  header += `Content-Disposition: form-data; name="${name5}"`;
  if (isBlob4(field)) {
    const { name: name6 = "blob", type } = (
      /** @type {Blob & {name?:string}} */
      field
    );
    header += `; filename="${name6}"${carriage}`;
    header += `Content-Type: ${type || "application/octet-stream"}`;
  }
  return `${header}${carriage.repeat(2)}`;
}
var getBoundary = () => (0, import_crypto2.randomBytes)(8).toString("hex");
function formDataIterator(form, boundary) {
  return __asyncGenerator(this, null, function* () {
    const encoder2 = new TextEncoder();
    for (const [name5, value] of form) {
      yield encoder2.encode(getHeader(boundary, name5, value));
      if (isBlob4(value)) {
        yield* __yieldStar(value.stream());
      } else {
        yield encoder2.encode(value);
      }
      yield encoder2.encode(carriage);
    }
    yield encoder2.encode(getFooter(boundary));
  });
}
function getFormDataLength(form, boundary) {
  let length2 = 0;
  for (const [name5, value] of form) {
    length2 += Buffer.byteLength(getHeader(boundary, name5, value));
    if (isBlob4(value)) {
      length2 += value.size;
    } else {
      length2 += Buffer.byteLength(String(value));
    }
    length2 += carriageLength;
  }
  length2 += Buffer.byteLength(getFooter(boundary));
  return length2;
}
var toFormData = (source) => __async(void 0, null, function* () {
  let { body, headers } = source;
  const contentType = (headers == null ? void 0 : headers.get("Content-Type")) || "";
  if (contentType.startsWith("application/x-www-form-urlencoded") && body != null) {
    const form = new FormData2();
    let bodyText = yield source.text();
    new URLSearchParams(bodyText).forEach((v, k) => form.append(k, v));
    return form;
  }
  const [type, boundary] = contentType.split(/\s*;\s*boundary=/);
  if (type === "multipart/form-data" && boundary != null && body != null) {
    const form = new FormData2();
    const parts = iterateMultipart(body, boundary);
    try {
      for (var iter = __forAwait(parts), more, temp, error; more = !(temp = yield iter.next()).done; more = false) {
        const { name: name5, data, filename, contentType: contentType2 } = temp.value;
        if (typeof filename === "string") {
          form.append(name5, new File2([data], filename, { type: contentType2 }));
        } else if (typeof filename !== "undefined") {
          form.append(name5, new File2([], "", { type: contentType2 }));
        } else {
          form.append(name5, new TextDecoder().decode(data), filename);
        }
      }
    } catch (temp) {
      error = [temp];
    } finally {
      try {
        more && (temp = iter.return) && (yield temp.call(iter));
      } finally {
        if (error)
          throw error[0];
      }
    }
    return form;
  } else {
    throw new TypeError("Could not parse content as FormData.");
  }
});

// ../../node_modules/.pnpm/@web-std+fetch@4.2.1/node_modules/@web-std/fetch/src/utils/utf8.js
var import_util4 = require("util");
var encoder = new import_util4.TextEncoder();
var decoder = new import_util4.TextDecoder();
var encode11 = (text) => encoder.encode(text);
var decode11 = (bytes) => decoder.decode(bytes);

// ../../node_modules/.pnpm/@web-std+fetch@4.2.1/node_modules/@web-std/fetch/src/body.js
var { readableHighWaterMark } = new import_stream4.default.Readable();
var INTERNALS = Symbol("Body internals");
var Body = class {
  /**
   * @param {BodyInit|Stream|null} body
   * @param {{size?:number}} options
   */
  constructor(body, {
    size = 0
  } = {}) {
    const state = {
      /** @type {null|ReadableStream<Uint8Array>} */
      body: null,
      /** @type {string|null} */
      type: null,
      /** @type {number|null} */
      size: null,
      /** @type {null|string} */
      boundary: null,
      disturbed: false,
      /** @type {null|Error} */
      error: null
    };
    this[INTERNALS] = state;
    if (body === null) {
      state.body = null;
      state.size = 0;
    } else if (isURLSearchParameters(body)) {
      const bytes = encode11(body.toString());
      state.body = fromBytes2(bytes);
      state.size = bytes.byteLength;
      state.type = "application/x-www-form-urlencoded;charset=UTF-8";
    } else if (isBlob4(body)) {
      state.size = body.size;
      state.type = body.type || null;
      state.body = body.stream();
    } else if (body instanceof Uint8Array) {
      state.body = fromBytes2(body);
      state.size = body.byteLength;
    } else if (import_util5.types.isAnyArrayBuffer(body)) {
      const bytes = new Uint8Array(body);
      state.body = fromBytes2(bytes);
      state.size = bytes.byteLength;
    } else if (ArrayBuffer.isView(body)) {
      const bytes = new Uint8Array(body.buffer, body.byteOffset, body.byteLength);
      state.body = fromBytes2(bytes);
      state.size = bytes.byteLength;
    } else if (isReadableStream2(body)) {
      state.body = body;
    } else if (isFormData(body)) {
      const boundary = `NodeFetchFormDataBoundary${getBoundary()}`;
      state.type = `multipart/form-data; boundary=${boundary}`;
      state.size = getFormDataLength(body, boundary);
      state.body = fromAsyncIterable(formDataIterator(body, boundary));
    } else if (isMultipartFormDataStream(body)) {
      state.type = `multipart/form-data; boundary=${body.getBoundary()}`;
      state.size = body.hasKnownLength() ? body.getLengthSync() : null;
      state.body = fromStream(body);
    } else if (body instanceof import_stream4.default) {
      state.body = fromStream(body);
    } else {
      const bytes = encode11(String(body));
      state.type = "text/plain;charset=UTF-8";
      state.size = bytes.byteLength;
      state.body = fromBytes2(bytes);
    }
    this.size = size;
  }
  /** @type {Headers} */
  /* c8 ignore next 3 */
  get headers() {
    throw new TypeError(`'get headers' called on an object that does not implements interface.`);
  }
  get body() {
    return this[INTERNALS].body;
  }
  get bodyUsed() {
    return this[INTERNALS].disturbed;
  }
  /**
   * Decode response as ArrayBuffer
   *
   * @return {Promise<ArrayBuffer>}
   */
  arrayBuffer() {
    return __async(this, null, function* () {
      const { buffer: buffer2, byteOffset, byteLength } = yield consumeBody(this);
      return buffer2.slice(byteOffset, byteOffset + byteLength);
    });
  }
  /**
   * Return raw response as Blob
   *
   * @return Promise
   */
  blob() {
    return __async(this, null, function* () {
      const ct = this.headers && this.headers.get("content-type") || this[INTERNALS].body && this[INTERNALS].type || "";
      const buf2 = yield consumeBody(this);
      return new Blob3([buf2], {
        type: ct
      });
    });
  }
  /**
   * Decode response as json
   *
   * @return  Promise
   */
  json() {
    return __async(this, null, function* () {
      return JSON.parse(yield this.text());
    });
  }
  /**
   * Decode response as text
   *
   * @return  Promise
   */
  text() {
    return __async(this, null, function* () {
      const buffer2 = yield consumeBody(this);
      return decode11(buffer2);
    });
  }
  /**
   * @returns {Promise<FormData>}
   */
  formData() {
    return __async(this, null, function* () {
      return toFormData(this);
    });
  }
};
Object.defineProperties(Body.prototype, {
  body: { enumerable: true },
  bodyUsed: { enumerable: true },
  arrayBuffer: { enumerable: true },
  blob: { enumerable: true },
  json: { enumerable: true },
  text: { enumerable: true },
  formData: { enumerable: true }
});
function consumeBody(data) {
  return __async(this, null, function* () {
    const state = data[INTERNALS];
    if (state.disturbed) {
      throw new TypeError(`body used already for: ${data.url}`);
    }
    state.disturbed = true;
    if (state.error) {
      throw state.error;
    }
    const { body } = state;
    if (body === null) {
      return new Uint8Array(0);
    }
    const [buffer2, chunks, limit] = data.size > 0 ? [new Uint8Array(data.size), [], data.size] : [null, [], Infinity];
    let offset = 0;
    const source = streamIterator(body);
    try {
      try {
        for (var iter = __forAwait(source), more, temp, error; more = !(temp = yield iter.next()).done; more = false) {
          const chunk = temp.value;
          const bytes = chunk instanceof Uint8Array ? chunk : Buffer.from(chunk);
          if (offset + bytes.byteLength > limit) {
            const error2 = new FetchError(`content size at ${data.url} over limit: ${limit}`, "max-size");
            source.throw(error2);
            throw error2;
          } else if (buffer2) {
            buffer2.set(bytes, offset);
          } else {
            chunks.push(bytes);
          }
          offset += bytes.byteLength;
        }
      } catch (temp) {
        error = [temp];
      } finally {
        try {
          more && (temp = iter.return) && (yield temp.call(iter));
        } finally {
          if (error)
            throw error[0];
        }
      }
      if (buffer2) {
        if (offset < buffer2.byteLength) {
          throw new FetchError(`Premature close of server response while trying to fetch ${data.url}`, "premature-close");
        } else {
          return buffer2;
        }
      } else {
        return writeBytes(new Uint8Array(offset), chunks);
      }
    } catch (error2) {
      if (error2 instanceof FetchBaseError) {
        throw error2;
      } else if (error2 && error2.name === "AbortError") {
        throw error2;
      } else {
        const e = (
          /** @type {import('./errors/fetch-error').SystemError} */
          error2
        );
        throw new FetchError(`Invalid response body while trying to fetch ${data.url}: ${e.message}`, "system", e);
      }
    }
  });
}
var clone = (instance) => {
  const { body } = instance;
  if (instance.bodyUsed) {
    throw new Error("cannot clone body after it is used");
  }
  if (!body) {
    return null;
  }
  const [left, right] = body.tee();
  instance[INTERNALS].body = left;
  return right;
};
var extractContentType = (source) => source[INTERNALS].type;
var getTotalBytes = (source) => source[INTERNALS].size;
var writeToStream = (dest, { body }) => {
  if (body === null) {
    dest.end();
  } else {
    import_stream4.default.Readable.from(streamIterator(body)).pipe(dest);
  }
};
var StreamIterableIterator = class {
  /**
   * @param {ReadableStream<T>} stream
   */
  constructor(stream) {
    this.stream = stream;
    this.reader = null;
  }
  /**
   * @returns {AsyncGenerator<T, void, void>}
   */
  [Symbol.asyncIterator]() {
    return this;
  }
  getReader() {
    if (this.reader) {
      return this.reader;
    }
    const reader = this.stream.getReader();
    this.reader = reader;
    return reader;
  }
  /**
   * @returns {Promise<IteratorResult<T, void>>}
   */
  next() {
    return (
      /** @type {Promise<IteratorResult<T, void>>} */
      this.getReader().read()
    );
  }
  /**
   * @returns {Promise<IteratorResult<T, void>>}
   */
  return() {
    return __async(this, null, function* () {
      if (this.reader) {
        yield this.reader.cancel();
      }
      return { done: true, value: void 0 };
    });
  }
  /**
   * 
   * @param {any} error 
   * @returns {Promise<IteratorResult<T, void>>}
   */
  throw(error) {
    return __async(this, null, function* () {
      yield this.getReader().cancel(error);
      return { done: true, value: void 0 };
    });
  }
};
var streamIterator = (stream) => new StreamIterableIterator(stream);
var writeBytes = (buffer2, chunks) => {
  let offset = 0;
  for (const chunk of chunks) {
    buffer2.set(chunk, offset);
    offset += chunk.byteLength;
  }
  return buffer2;
};
var fromBytes2 = (bytes) => new ReadableStream2({
  start(controller) {
    controller.enqueue(bytes);
    controller.close();
  }
});
var fromAsyncIterable = (content) => (
  // @ts-ignore
  new ReadableStream2(new AsyncIterablePump(content))
);
var AsyncIterablePump = class {
  /**
   * @param {AsyncIterable<Uint8Array>} source
   */
  constructor(source) {
    this.source = source[Symbol.asyncIterator]();
  }
  /**
   * @param {ReadableStreamController<Uint8Array>} controller
   */
  pull(controller) {
    return __async(this, null, function* () {
      try {
        while (controller.desiredSize || 0 > 0) {
          const next = yield this.source.next();
          if (next.done) {
            controller.close();
            break;
          } else {
            controller.enqueue(next.value);
          }
        }
      } catch (error) {
        controller.error(error);
      }
    });
  }
  /**
   * @param {any} [reason]
   */
  cancel(reason) {
    if (reason) {
      if (typeof this.source.throw === "function") {
        this.source.throw(reason);
      } else if (typeof this.source.return === "function") {
        this.source.return();
      }
    } else if (typeof this.source.return === "function") {
      this.source.return();
    }
  }
};
var fromStream = (source) => {
  const pump2 = new StreamPump(source);
  const stream = new ReadableStream2(pump2, pump2);
  return stream;
};
var StreamPump = class {
  /**
   * @param {Stream & {
   * 	readableHighWaterMark?: number
   * 	readable?:boolean,
   * 	resume?: () => void,
   * 	pause?: () => void
   * 	destroy?: (error?:Error) => void
   * }} stream
   */
  constructor(stream) {
    this.highWaterMark = stream.readableHighWaterMark || readableHighWaterMark;
    this.accumalatedSize = 0;
    this.stream = stream;
    this.enqueue = this.enqueue.bind(this);
    this.error = this.error.bind(this);
    this.close = this.close.bind(this);
  }
  /**
   * @param {Uint8Array} [chunk]
   */
  size(chunk) {
    return (chunk == null ? void 0 : chunk.byteLength) || 0;
  }
  /**
   * @param {ReadableStreamController<Uint8Array>} controller
   */
  start(controller) {
    this.controller = controller;
    this.stream.on("data", this.enqueue);
    this.stream.once("error", this.error);
    this.stream.once("end", this.close);
    this.stream.once("close", this.close);
  }
  pull() {
    this.resume();
  }
  /**
   * @param {any} [reason]
   */
  cancel(reason) {
    if (this.stream.destroy) {
      this.stream.destroy(reason);
    }
    this.stream.off("data", this.enqueue);
    this.stream.off("error", this.error);
    this.stream.off("end", this.close);
    this.stream.off("close", this.close);
  }
  /**
   * @param {Uint8Array|string} chunk
   */
  enqueue(chunk) {
    if (this.controller) {
      try {
        const bytes = chunk instanceof Uint8Array ? chunk : Buffer.from(chunk);
        const available = (this.controller.desiredSize || 0) - bytes.byteLength;
        this.controller.enqueue(bytes);
        if (available <= 0) {
          this.pause();
        }
      } catch (e) {
        this.controller.error(new Error("Could not create Buffer, chunk must be of type string or an instance of Buffer, ArrayBuffer, or Array or an Array-like Object"));
        this.cancel();
      }
    }
  }
  pause() {
    if (this.stream.pause) {
      this.stream.pause();
    }
  }
  resume() {
    if (this.stream.readable && this.stream.resume) {
      this.stream.resume();
    }
  }
  close() {
    if (this.controller) {
      this.controller.close();
      delete this.controller;
    }
  }
  /**
   * @param {Error} error 
   */
  error(error) {
    if (this.controller) {
      this.controller.error(error);
      delete this.controller;
    }
  }
};

// ../../node_modules/.pnpm/@web-std+fetch@4.2.1/node_modules/@web-std/fetch/src/headers.js
var import_util6 = require("util");
var import_http = __toESM(require("http"), 1);
var validators = (
  /** @type {{validateHeaderName?:(name:string) => any, validateHeaderValue?:(name:string, value:string) => any}} */
  import_http.default
);
var validateHeaderName = typeof validators.validateHeaderName === "function" ? validators.validateHeaderName : (
  /**
   * @param {string} name 
   */
  (name5) => {
    if (!/^[\^`\-\w!#$%&'*+.|~]+$/.test(name5)) {
      const err = new TypeError(`Header name must be a valid HTTP token [${name5}]`);
      Object.defineProperty(err, "code", { value: "ERR_INVALID_HTTP_TOKEN" });
      throw err;
    }
  }
);
var validateHeaderValue = typeof validators.validateHeaderValue === "function" ? validators.validateHeaderValue : (
  /**
   * @param {string} name 
   * @param {string} value 
   */
  (name5, value) => {
    if (/[^\t\u0020-\u007E\u0080-\u00FF]/.test(value)) {
      const err = new TypeError(`Invalid character in header content ["${name5}"]`);
      Object.defineProperty(err, "code", { value: "ERR_INVALID_CHAR" });
      throw err;
    }
  }
);
var Headers = class _Headers extends URLSearchParams {
  /**
   * Headers class
   *
   * @constructor
   * @param {HeadersInit} [init] - Response headers
   */
  constructor(init) {
    let result = [];
    if (init instanceof _Headers) {
      const raw = init.raw();
      for (const [name5, values] of Object.entries(raw)) {
        result.push(...values.map((value) => [name5, value]));
      }
    } else if (init == null) {
    } else if (isIterable2(init)) {
      result = [...init].map((pair) => {
        if (typeof pair !== "object" || import_util6.types.isBoxedPrimitive(pair)) {
          throw new TypeError("Each header pair must be an iterable object");
        }
        return [...pair];
      }).map((pair) => {
        if (pair.length !== 2) {
          throw new TypeError("Each header pair must be a name/value tuple");
        }
        return [...pair];
      });
    } else if (typeof init === "object" && init !== null) {
      result.push(...Object.entries(init));
    } else {
      throw new TypeError("Failed to construct 'Headers': The provided value is not of type '(sequence<sequence<ByteString>> or record<ByteString, ByteString>)");
    }
    result = result.length > 0 ? result.map(([name5, value]) => {
      validateHeaderName(name5);
      validateHeaderValue(name5, String(value));
      return [String(name5).toLowerCase(), String(value)];
    }) : [];
    super(result);
    return new Proxy(this, {
      get(target, p, receiver) {
        switch (p) {
          case "append":
          case "set":
            return (name5, value) => {
              validateHeaderName(name5);
              validateHeaderValue(name5, String(value));
              return URLSearchParams.prototype[p].call(
                receiver,
                String(name5).toLowerCase(),
                String(value)
              );
            };
          case "delete":
          case "has":
          case "getAll":
            return (name5) => {
              validateHeaderName(name5);
              return URLSearchParams.prototype[p].call(
                receiver,
                String(name5).toLowerCase()
              );
            };
          case "keys":
            return () => {
              target.sort();
              return new Set(URLSearchParams.prototype.keys.call(target)).keys();
            };
          default:
            return Reflect.get(target, p, receiver);
        }
      }
      /* c8 ignore next */
    });
  }
  get [Symbol.toStringTag]() {
    return this.constructor.name;
  }
  toString() {
    return Object.prototype.toString.call(this);
  }
  /**
   * 
   * @param {string} name 
   */
  get(name5) {
    const values = this.getAll(name5);
    if (values.length === 0) {
      return null;
    }
    let value = values.join(", ");
    if (/^content-encoding$/i.test(name5)) {
      value = value.toLowerCase();
    }
    return value;
  }
  /**
   * @param {(value: string, key: string, parent: this) => void} callback 
   * @param {any} thisArg 
   * @returns {void}
   */
  forEach(callback, thisArg = void 0) {
    for (const name5 of this.keys()) {
      if (name5.toLowerCase() === "set-cookie") {
        let cookies = this.getAll(name5);
        while (cookies.length > 0) {
          Reflect.apply(callback, thisArg, [cookies.shift(), name5, this]);
        }
      } else {
        Reflect.apply(callback, thisArg, [this.get(name5), name5, this]);
      }
    }
  }
  /**
   * @returns {IterableIterator<string>}
   */
  *values() {
    for (const name5 of this.keys()) {
      if (name5.toLowerCase() === "set-cookie") {
        let cookies = this.getAll(name5);
        while (cookies.length > 0) {
          yield (
            /** @type {string} */
            cookies.shift()
          );
        }
      } else {
        yield (
          /** @type {string} */
          this.get(name5)
        );
      }
    }
  }
  /**
   * @returns {IterableIterator<[string, string]>}
   */
  *entries() {
    for (const name5 of this.keys()) {
      if (name5.toLowerCase() === "set-cookie") {
        let cookies = this.getAll(name5);
        while (cookies.length > 0) {
          yield [
            name5,
            /** @type {string} */
            cookies.shift()
          ];
        }
      } else {
        yield [
          name5,
          /** @type {string} */
          this.get(name5)
        ];
      }
    }
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  /**
   * Node-fetch non-spec method
   * returning all headers and their values as array
   * @returns {Record<string, string[]>}
   */
  raw() {
    return [...this.keys()].reduce(
      (result, key) => {
        result[key] = this.getAll(key);
        return result;
      },
      /** @type {Record<string, string[]>} */
      {}
    );
  }
  /**
   * For better console.log(headers) and also to convert Headers into Node.js Request compatible format
   */
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return [...this.keys()].reduce(
      (result, key) => {
        const values = this.getAll(key);
        if (key === "host") {
          result[key] = values[0];
        } else {
          result[key] = values.length > 1 ? values : values[0];
        }
        return result;
      },
      /** @type {Record<string, string|string[]>} */
      {}
    );
  }
};
Object.defineProperties(
  Headers.prototype,
  ["get", "entries", "forEach", "values"].reduce(
    (result, property) => {
      result[property] = { enumerable: true };
      return result;
    },
    /** @type {Record<string, {enumerable:true}>} */
    {}
  )
);
function fromRawHeaders(headers = []) {
  return new Headers(
    headers.reduce(
      (result, value, index, array) => {
        if (index % 2 === 0) {
          result.push(array.slice(index, index + 2));
        }
        return result;
      },
      /** @type {string[][]} */
      []
    ).filter(([name5, value]) => {
      try {
        validateHeaderName(name5);
        validateHeaderValue(name5, String(value));
        return true;
      } catch (e) {
        return false;
      }
    })
  );
}

// ../../node_modules/.pnpm/@web-std+fetch@4.2.1/node_modules/@web-std/fetch/src/utils/is-redirect.js
var redirectStatus = /* @__PURE__ */ new Set([301, 302, 303, 307, 308]);
var isRedirect = (code5) => {
  return redirectStatus.has(code5);
};

// ../../node_modules/.pnpm/@web-std+fetch@4.2.1/node_modules/@web-std/fetch/src/response.js
var INTERNALS2 = Symbol("Response internals");
var Response2 = class _Response extends Body {
  /**
   * @param {BodyInit|import('stream').Stream|null} [body] - Readable stream
   * @param {ResponseInit & Ext} [options] - Response options
   */
  constructor(body = null, options = {}) {
    super(body, options);
    const status = options.status || 200;
    const headers = new Headers(options.headers);
    if (body !== null && !headers.has("Content-Type")) {
      const contentType = extractContentType(this);
      if (contentType) {
        headers.append("Content-Type", contentType);
      }
    }
    this[INTERNALS2] = {
      url: options.url,
      status,
      statusText: options.statusText || "",
      headers,
      counter: options.counter || 0,
      highWaterMark: options.highWaterMark
    };
  }
  /**
   * @type {ResponseType}
   */
  get type() {
    return "default";
  }
  get url() {
    return this[INTERNALS2].url || "";
  }
  get status() {
    return this[INTERNALS2].status;
  }
  /**
   * Convenience property representing if the request ended normally
   */
  get ok() {
    return this[INTERNALS2].status >= 200 && this[INTERNALS2].status < 300;
  }
  get redirected() {
    return this[INTERNALS2].counter > 0;
  }
  get statusText() {
    return this[INTERNALS2].statusText;
  }
  /**
   * @type {Headers}
   */
  get headers() {
    return this[INTERNALS2].headers;
  }
  get highWaterMark() {
    return this[INTERNALS2].highWaterMark;
  }
  /**
   * Clone this response
   *
   * @returns {Response}
   */
  clone() {
    return new _Response(clone(this), {
      url: this.url,
      status: this.status,
      statusText: this.statusText,
      headers: this.headers,
      size: this.size
    });
  }
  /**
   * @param {string} url    The URL that the new response is to originate from.
   * @param {number} status An optional status code for the response (e.g., 302.)
   * @returns {Response}    A Response object.
   */
  static redirect(url, status = 302) {
    if (!isRedirect(status)) {
      throw new RangeError('Failed to execute "redirect" on "response": Invalid status code');
    }
    return new _Response(null, {
      headers: {
        location: new URL(url).toString()
      },
      status
    });
  }
  get [Symbol.toStringTag]() {
    return "Response";
  }
};
Object.defineProperties(Response2.prototype, {
  url: { enumerable: true },
  status: { enumerable: true },
  ok: { enumerable: true },
  redirected: { enumerable: true },
  statusText: { enumerable: true },
  headers: { enumerable: true },
  clone: { enumerable: true }
});

// ../../node_modules/.pnpm/@web-std+fetch@4.2.1/node_modules/@web-std/fetch/src/request.js
var import_url = require("url");
var import_abort_controller = __toESM(require_abort_controller(), 1);

// ../../node_modules/.pnpm/@web-std+fetch@4.2.1/node_modules/@web-std/fetch/src/utils/get-search.js
var getSearch = (parsedURL) => {
  if (parsedURL.search) {
    return parsedURL.search;
  }
  const lastOffset = parsedURL.href.length - 1;
  const hash = parsedURL.hash || (parsedURL.href[lastOffset] === "#" ? "#" : "");
  return parsedURL.href[lastOffset - hash.length] === "?" ? "?" : "";
};

// ../../node_modules/.pnpm/@web-std+fetch@4.2.1/node_modules/@web-std/fetch/src/request.js
var INTERNALS3 = Symbol("Request internals");
var forbiddenMethods = /* @__PURE__ */ new Set(["CONNECT", "TRACE", "TRACK"]);
var normalizedMethods = /* @__PURE__ */ new Set(["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"]);
var isRequest = (object) => {
  return typeof object === "object" && typeof object[INTERNALS3] === "object";
};
var Request = class _Request extends Body {
  /**
   * @param {string|Request|URL} info  Url or Request instance
   * @param {RequestInit & RequestExtraOptions} init   Custom options
   */
  constructor(info, init = {}) {
    let parsedURL;
    let settings;
    if (isRequest(info)) {
      parsedURL = new URL(info.url);
      settings = info;
    } else {
      parsedURL = new URL(info);
      settings = {};
    }
    let method = init.method || settings.method || "GET";
    if (forbiddenMethods.has(method.toUpperCase())) {
      throw new TypeError(`Failed to construct 'Request': '${method}' HTTP method is unsupported.`);
    } else if (normalizedMethods.has(method.toUpperCase())) {
      method = method.toUpperCase();
    }
    const inputBody = init.body != null ? init.body : isRequest(info) && info.body !== null ? clone(info) : null;
    if (inputBody != null && (method === "GET" || method === "HEAD")) {
      throw new TypeError("Request with GET/HEAD method cannot have body");
    }
    super(inputBody, {
      size: init.size || settings.size || 0
    });
    const input = settings;
    const headers = (
      /** @type {globalThis.Headers} */
      new Headers(init.headers || input.headers || {})
    );
    if (inputBody !== null && !headers.has("Content-Type")) {
      const contentType = extractContentType(this);
      if (contentType) {
        headers.append("Content-Type", contentType);
      }
    }
    let signal = "signal" in init ? init.signal : isRequest(input) ? input.signal : null;
    if (signal != null && !isAbortSignal2(signal)) {
      throw new TypeError("Expected signal to be an instanceof AbortSignal or EventTarget");
    }
    if (!signal) {
      let AbortControllerConstructor = typeof AbortController != "undefined" ? AbortController : import_abort_controller.AbortController;
      let newSignal = new AbortControllerConstructor().signal;
      signal = newSignal;
    }
    this[INTERNALS3] = {
      method,
      redirect: init.redirect || input.redirect || "follow",
      headers,
      credentials: init.credentials || "same-origin",
      parsedURL,
      signal: signal || null
    };
    this.keepalive;
    this.follow = init.follow === void 0 ? input.follow === void 0 ? 20 : input.follow : init.follow;
    this.compress = init.compress === void 0 ? input.compress === void 0 ? true : input.compress : init.compress;
    this.counter = init.counter || input.counter || 0;
    this.agent = init.agent || input.agent;
    this.highWaterMark = init.highWaterMark || input.highWaterMark || 16384;
    this.insecureHTTPParser = init.insecureHTTPParser || input.insecureHTTPParser || false;
  }
  /**
   * @type {RequestCache}
   */
  get cache() {
    return "default";
  }
  /**
   * @type {RequestCredentials}
   */
  get credentials() {
    return this[INTERNALS3].credentials;
  }
  /**
   * @type {RequestDestination}
   */
  get destination() {
    return "";
  }
  get integrity() {
    return "";
  }
  /** @type {RequestMode} */
  get mode() {
    return "cors";
  }
  /** @type {string} */
  get referrer() {
    return "";
  }
  /** @type {ReferrerPolicy} */
  get referrerPolicy() {
    return "";
  }
  get method() {
    return this[INTERNALS3].method;
  }
  /**
   * @type {string}
   */
  get url() {
    return (0, import_url.format)(this[INTERNALS3].parsedURL);
  }
  /**
   * @type {globalThis.Headers}
   */
  get headers() {
    return this[INTERNALS3].headers;
  }
  get redirect() {
    return this[INTERNALS3].redirect;
  }
  /**
   * @returns {AbortSignal}
   */
  get signal() {
    return this[INTERNALS3].signal;
  }
  /**
   * Clone this request
   *
   * @return  {globalThis.Request}
   */
  clone() {
    return new _Request(this);
  }
  get [Symbol.toStringTag]() {
    return "Request";
  }
};
Object.defineProperties(Request.prototype, {
  method: { enumerable: true },
  url: { enumerable: true },
  headers: { enumerable: true },
  redirect: { enumerable: true },
  clone: { enumerable: true },
  signal: { enumerable: true }
});
var getNodeRequestOptions = (request) => {
  const { parsedURL } = request[INTERNALS3];
  const headers = new Headers(request[INTERNALS3].headers);
  if (!headers.has("Accept")) {
    headers.set("Accept", "*/*");
  }
  let contentLengthValue = null;
  if (request.body === null && /^(post|put)$/i.test(request.method)) {
    contentLengthValue = "0";
  }
  if (request.body !== null) {
    const totalBytes = getTotalBytes(request);
    if (typeof totalBytes === "number" && !Number.isNaN(totalBytes)) {
      contentLengthValue = String(totalBytes);
    }
  }
  if (contentLengthValue) {
    headers.set("Content-Length", contentLengthValue);
  }
  if (!headers.has("User-Agent")) {
    headers.set("User-Agent", "node-fetch");
  }
  if (request.compress && !headers.has("Accept-Encoding")) {
    headers.set("Accept-Encoding", "gzip,deflate,br");
  }
  let { agent } = request;
  if (typeof agent === "function") {
    agent = agent(parsedURL);
  }
  if (!headers.has("Connection") && !agent) {
    headers.set("Connection", "close");
  }
  const search = getSearch(parsedURL);
  const requestOptions = {
    path: parsedURL.pathname + search,
    pathname: parsedURL.pathname,
    hostname: parsedURL.hostname,
    protocol: parsedURL.protocol,
    port: parsedURL.port,
    hash: parsedURL.hash,
    search: parsedURL.search,
    // @ts-ignore - it does not has a query
    query: parsedURL.query,
    href: parsedURL.href,
    method: request.method,
    // @ts-ignore - not sure what this supposed to do
    headers: headers[Symbol.for("nodejs.util.inspect.custom")](),
    insecureHTTPParser: request.insecureHTTPParser,
    agent
  };
  return requestOptions;
};

// ../../node_modules/.pnpm/@web-std+fetch@4.2.1/node_modules/@web-std/fetch/src/errors/abort-error.js
var AbortError = class extends FetchBaseError {
  /**
   * @param {string} message 
   * @param {string} [type]
   */
  constructor(message, type = "aborted") {
    super(message, type);
  }
};

// ../../node_modules/.pnpm/@web-std+fetch@4.2.1/node_modules/@web-std/fetch/src/fetch.js
var import_stream5 = require("stream");
var Stream3 = __toESM(require("stream"), 1);
var supportedSchemas = /* @__PURE__ */ new Set(["data:", "http:", "https:", "file:"]);
function fetch(_0) {
  return __async(this, arguments, function* (url, options_ = {}) {
    return new Promise((resolve, reject) => {
      const request = new Request(url, options_);
      const options = getNodeRequestOptions(request);
      if (!supportedSchemas.has(options.protocol)) {
        throw new TypeError(`node-fetch cannot load ${url}. URL scheme "${options.protocol.replace(/:$/, "")}" is not supported.`);
      }
      if (options.protocol === "data:") {
        const data = (0, import_data_uri_to_buffer.default)(request.url.toString());
        const response2 = new Response2(data, { headers: { "Content-Type": data.typeFull } });
        resolve(response2);
        return;
      }
      if (options.protocol === "file:") {
        const stream = import_fs3.default.createReadStream(new URL(request.url));
        const type = lookup(request.url) || "application/octet-stream";
        const response2 = new Response2(stream, { headers: { "Content-Type": type } });
        resolve(response2);
        return;
      }
      const send = (options.protocol === "https:" ? import_https.default : import_http2.default).request;
      const { signal } = request;
      let response = null;
      let response_ = null;
      const abort = () => {
        const error = new AbortError("The operation was aborted.");
        reject(error);
        if (request.body) {
          request.body.cancel(error);
        }
        if (!response_) {
          return;
        }
        response_.emit("error", error);
      };
      if (signal && signal.aborted) {
        abort();
        return;
      }
      const abortAndFinalize = () => {
        abort();
        finalize();
      };
      const request_ = send(options);
      if (signal) {
        signal.addEventListener("abort", abortAndFinalize);
      }
      const finalize = () => {
        request_.abort();
        if (signal) {
          signal.removeEventListener("abort", abortAndFinalize);
        }
      };
      request_.on("error", (err) => {
        reject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, "system", err));
        finalize();
      });
      fixResponseChunkedTransferBadEnding(request_, (err) => {
        if (signal && signal.aborted) {
          return;
        }
        response_ == null ? void 0 : response_.emit("error", err);
      });
      if (parseInt(process.version.substring(1)) < 14) {
        request_.on("socket", (s) => {
          s.prependListener("close", (hadError) => {
            const hasDataListener = s.listenerCount("data") > 0;
            if (response && hasDataListener && !hadError && !(signal && signal.aborted)) {
              const err = Object.assign(new Error("Premature close"), {
                code: "ERR_STREAM_PREMATURE_CLOSE"
              });
              response_ == null ? void 0 : response_.emit("error", err);
            }
          });
        });
      }
      request_.on("response", (incoming) => {
        response_ = incoming;
        request_.setTimeout(0);
        const headers = fromRawHeaders(response_.rawHeaders);
        if (isRedirect(Number(response_.statusCode))) {
          const location = headers.get("Location");
          const locationURL = location === null ? null : new URL(location, request.url);
          switch (request.redirect) {
            case "error":
              reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, "no-redirect"));
              finalize();
              return;
            case "manual":
              if (locationURL !== null) {
                headers.set("Location", locationURL.toString());
              }
              break;
            case "follow": {
              if (locationURL === null) {
                break;
              }
              if (request.counter >= request.follow) {
                reject(new FetchError(`maximum redirect reached at: ${request.url}`, "max-redirect"));
                finalize();
                return;
              }
              const requestOptions = {
                headers: new Headers(request.headers),
                follow: request.follow,
                counter: request.counter + 1,
                agent: request.agent,
                compress: request.compress,
                method: request.method,
                // Note: We can not use `request.body` because send would have
                // consumed it already.
                body: options_.body,
                signal,
                size: request.size
              };
              const isStreamBody = requestOptions.body instanceof ReadableStream2 || requestOptions.body instanceof Stream3.Readable;
              if (response_.statusCode !== 303 && isStreamBody) {
                reject(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect"));
                finalize();
                return;
              }
              if (response_.statusCode === 303 || (response_.statusCode === 301 || response_.statusCode === 302) && request.method === "POST") {
                requestOptions.method = "GET";
                requestOptions.body = void 0;
                requestOptions.headers.delete("content-length");
              }
              fetch(new Request(locationURL.href, requestOptions)).then(resolve, reject);
              finalize();
              return;
            }
            default:
              return reject(new TypeError(`Redirect option '${request.redirect}' is not a valid value of RequestRedirect`));
          }
        }
        if (signal) {
          response_.once("end", () => {
            signal.removeEventListener("abort", abortAndFinalize);
          });
        }
        let body = (0, import_stream5.pipeline)(response_, new import_stream5.PassThrough(), reject);
        if (process.version < "v12.10") {
          response_.on("aborted", abortAndFinalize);
        }
        const responseOptions = {
          url: request.url,
          status: response_.statusCode,
          statusText: response_.statusMessage,
          headers,
          size: request.size,
          counter: request.counter,
          highWaterMark: request.highWaterMark
        };
        const codings = headers.get("Content-Encoding");
        if (!request.compress || request.method === "HEAD" || codings === null || response_.statusCode === 204 || response_.statusCode === 304) {
          response = new Response2(body, responseOptions);
          resolve(response);
          return;
        }
        const zlibOptions = {
          flush: import_zlib.default.Z_SYNC_FLUSH,
          finishFlush: import_zlib.default.Z_SYNC_FLUSH
        };
        if (codings === "gzip" || codings === "x-gzip") {
          body = (0, import_stream5.pipeline)(body, import_zlib.default.createGunzip(zlibOptions), reject);
          response = new Response2(fromAsyncIterable(body), responseOptions);
          resolve(response);
          return;
        }
        if (codings === "deflate" || codings === "x-deflate") {
          const raw = (0, import_stream5.pipeline)(response_, new import_stream5.PassThrough(), reject);
          raw.once("data", (chunk) => {
            if ((chunk[0] & 15) === 8) {
              body = (0, import_stream5.pipeline)(body, import_zlib.default.createInflate(), reject);
            } else {
              body = (0, import_stream5.pipeline)(body, import_zlib.default.createInflateRaw(), reject);
            }
            response = new Response2(fromAsyncIterable(body), responseOptions);
            resolve(response);
          });
          return;
        }
        if (codings === "br") {
          body = (0, import_stream5.pipeline)(body, import_zlib.default.createBrotliDecompress(), reject);
          response = new Response2(fromAsyncIterable(body), responseOptions);
          resolve(response);
          return;
        }
        response = new Response2(fromAsyncIterable(body), responseOptions);
        resolve(response);
      });
      writeToStream(request_, request);
    });
  });
}
function fixResponseChunkedTransferBadEnding(request, errorCallback) {
  const LAST_CHUNK = import_buffer.Buffer.from("0\r\n\r\n");
  let isChunkedTransfer = false;
  let properLastChunkReceived = false;
  let previousChunk;
  request.on("response", (response) => {
    const { headers } = response;
    isChunkedTransfer = headers["transfer-encoding"] === "chunked" && !headers["content-length"];
  });
  request.on("socket", (socket) => {
    const onSocketClose = () => {
      if (isChunkedTransfer && !properLastChunkReceived) {
        const error = Object.assign(new Error("Premature close"), {
          code: "ERR_STREAM_PREMATURE_CLOSE"
        });
        errorCallback(error);
      }
    };
    const onData = (buf2) => {
      properLastChunkReceived = import_buffer.Buffer.compare(buf2.slice(-5), LAST_CHUNK) === 0;
      if (!properLastChunkReceived && previousChunk) {
        properLastChunkReceived = import_buffer.Buffer.compare(previousChunk.slice(-3), LAST_CHUNK.slice(0, 3)) === 0 && import_buffer.Buffer.compare(buf2.slice(-2), LAST_CHUNK.slice(3)) === 0;
      }
      previousChunk = buf2;
    };
    socket.prependListener("close", onSocketClose);
    socket.on("data", onData);
    const removeSocketListeners = () => {
      socket.removeListener("close", onSocketClose);
      socket.removeListener("data", onData);
    };
    request.on("close", removeSocketListeners);
    request.on("abort", removeSocketListeners);
  });
}

// ../../node_modules/.pnpm/@web-std+fetch@4.2.1/node_modules/@web-std/fetch/src/lib.node.js
var fetch2 = (
  /** @type {typeof globalThis.fetch} */
  typeof globalThis.fetch === "function" ? globalThis.fetch.bind(globalThis) : fetch
);
var Headers2 = globalThis.Headers || Headers;
var Request2 = globalThis.Request || Request;
var Response3 = globalThis.Response || Response2;
var lib_node_default = fetch2;

// ../../node_modules/.pnpm/ipfs-car@0.6.2_node-fetch@3.3.2/node_modules/ipfs-car/dist/esm/blockstore/fs.js
var import_fs4 = __toESM(require("fs"), 1);
var import_os = __toESM(require("os"), 1);
var FsBlockStore = class extends BaseBlockstore {
  constructor() {
    super();
    this.path = `${import_os.default.tmpdir()}/${parseInt(String(Math.random() * 1e9), 10).toString() + Date.now()}`;
    this._opened = false;
  }
  _open() {
    return __async(this, null, function* () {
      if (this._opening) {
        yield this._opening;
      } else {
        this._opening = import_fs4.default.promises.mkdir(this.path);
        yield this._opening;
        this._opened = true;
      }
    });
  }
  put(cid, bytes) {
    return __async(this, null, function* () {
      if (!this._opened) {
        yield this._open();
      }
      const cidStr = cid.toString();
      const location = `${this.path}/${cidStr}`;
      yield import_fs4.default.promises.writeFile(location, bytes);
    });
  }
  get(cid) {
    return __async(this, null, function* () {
      if (!this._opened) {
        yield this._open();
      }
      const cidStr = cid.toString();
      const location = `${this.path}/${cidStr}`;
      const bytes = yield import_fs4.default.promises.readFile(location);
      return bytes;
    });
  }
  has(cid) {
    return __async(this, null, function* () {
      if (!this._opened) {
        yield this._open();
      }
      const cidStr = cid.toString();
      const location = `${this.path}/${cidStr}`;
      try {
        yield import_fs4.default.promises.access(location);
        return true;
      } catch (err) {
        return false;
      }
    });
  }
  blocks() {
    return __asyncGenerator(this, null, function* () {
      if (!this._opened) {
        yield new __await(this._open());
      }
      const cids = yield new __await(import_fs4.default.promises.readdir(this.path));
      for (const cidStr of cids) {
        const location = `${this.path}/${cidStr}`;
        const bytes = yield new __await(import_fs4.default.promises.readFile(location));
        yield { cid: CID.parse(cidStr), bytes };
      }
    });
  }
  close() {
    return __async(this, null, function* () {
      if (this._opened) {
        yield import_fs4.default.promises.rm(this.path, { recursive: true });
      }
      this._opened = false;
    });
  }
};

// ../../node_modules/.pnpm/nft.storage@7.1.1_node-fetch@3.3.2/node_modules/nft.storage/src/gateway.js
var GATEWAY = new URL("https://nftstorage.link/");
var toGatewayURL = (url, options = {}) => {
  const gateway = options.gateway || GATEWAY;
  url = new URL(String(url));
  return url.protocol === "ipfs:" ? new URL(`/ipfs/${url.href.slice("ipfs://".length)}`, gateway) : url;
};

// ../../node_modules/.pnpm/nft.storage@7.1.1_node-fetch@3.3.2/node_modules/nft.storage/src/bs-car-reader.js
var BlockstoreCarReader = class {
  /**
   * @param {number} version
   * @param {CID[]} roots
   * @param {import('ipfs-car/blockstore').Blockstore} blockstore
   */
  constructor(version2, roots, blockstore) {
    this._version = version2;
    this._roots = roots;
    this._blockstore = blockstore;
  }
  get version() {
    return this._version;
  }
  get blockstore() {
    return this._blockstore;
  }
  getRoots() {
    return __async(this, null, function* () {
      return this._roots;
    });
  }
  /**
   * @param {CID} cid
   */
  has(cid) {
    return this._blockstore.has(cid);
  }
  /**
   * @param {CID} cid
   */
  get(cid) {
    return __async(this, null, function* () {
      const bytes = yield this._blockstore.get(cid);
      return { cid, bytes };
    });
  }
  blocks() {
    return this._blockstore.blocks();
  }
  cids() {
    return __asyncGenerator(this, null, function* () {
      try {
        for (var iter = __forAwait(this.blocks()), more, temp, error; more = !(temp = yield new __await(iter.next())).done; more = false) {
          const b = temp.value;
          yield b.cid;
        }
      } catch (temp) {
        error = [temp];
      } finally {
        try {
          more && (temp = iter.return) && (yield new __await(temp.call(iter)));
        } finally {
          if (error)
            throw error[0];
        }
      }
    });
  }
};

// ../../node_modules/.pnpm/nft.storage@7.1.1_node-fetch@3.3.2/node_modules/nft.storage/src/token.js
var Token2 = class _Token {
  /**
   * @param {import('./lib/interface.js').CIDString} ipnft
   * @param {import('./lib/interface.js').EncodedURL} url
   * @param {import('./lib/interface.js').Encoded<T, [[Blob, URL]]>} data
   */
  constructor(ipnft, url, data) {
    this.ipnft = ipnft;
    this.url = url;
    this.data = data;
    Object.defineProperties(this, {
      ipnft: { enumerable: true, writable: false },
      url: { enumerable: true, writable: false },
      data: { enumerable: false, writable: false }
    });
  }
  /**
   * @returns {import('./lib/interface.js').Encoded<T, [[Blob, URL]]>}
   */
  embed() {
    return _Token.embed(this);
  }
  /**
   * @template {TokenInput} T
   * @param {{data: import('./lib/interface.js').Encoded<T, [[Blob, URL]]>}} token
   * @returns {import('./lib/interface.js').Encoded<T, [[Blob, URL]]>}
   */
  static embed({ data }) {
    return embed(data, { gateway: GATEWAY });
  }
  /**
   * Takes token input, encodes it as a DAG, wraps it in a CAR and creates a new
   * Token instance from it. Where values are discovered `Blob` (or `File`)
   * objects in the given input, they are replaced with IPFS URLs (an `ipfs://`
   * prefixed CID with an optional path).
   *
   * @example
   * ```js
   * const cat = new File(['...'], 'cat.png')
   * const kitty = new File(['...'], 'kitty.png')
   * const { token, car } = await Token.encode({
   *   name: 'hello'
   *   image: cat
   *   properties: {
   *     extra: {
   *       image: kitty
   *     }
   *   }
   * })
   * ```
   *
   * @template {TokenInput} T
   * @param {T} input
   * @returns {Promise<{ cid: CID, token: TokenType<T>, car: import('./lib/interface.js').CarReader }>}
   */
  static encode(input) {
    return __async(this, null, function* () {
      var _a2, _b;
      const blockstore = new FsBlockStore();
      const [blobs, meta] = mapTokenInputBlobs(input);
      const data = JSON.parse(JSON.stringify(meta));
      const dag = JSON.parse(JSON.stringify(meta));
      for (const [dotPath, blob] of blobs.entries()) {
        const name5 = blob.name || "blob";
        let content;
        if (parseInt((_b = (_a2 = globalThis.process) == null ? void 0 : _a2.versions) == null ? void 0 : _b.node) > 18) {
          content = new Uint8Array(yield blob.arrayBuffer());
        } else {
          content = blob.stream();
        }
        const { root: cid } = yield pack({
          input: [{ path: name5, content }],
          blockstore,
          wrapWithDirectory: true
        });
        const href = new URL(`ipfs://${cid}/${name5}`);
        const path = dotPath.split(".");
        setIn(data, path, href);
        setIn(dag, path, cid);
      }
      const { root: metadataJsonCid } = yield pack({
        input: [{ path: "metadata.json", content: JSON.stringify(data) }],
        blockstore,
        wrapWithDirectory: false
      });
      const block = yield encode5({
        value: __spreadProps(__spreadValues({}, dag), {
          "metadata.json": metadataJsonCid,
          type: "nft"
        }),
        codec: esm_exports,
        hasher: sha256
      });
      yield blockstore.put(block.cid, block.bytes);
      return {
        cid: block.cid,
        token: new _Token(
          block.cid.toString(),
          `ipfs://${block.cid}/metadata.json`,
          data
        ),
        car: new BlockstoreCarReader(1, [block.cid], blockstore)
      };
    });
  }
};
var embed = (input, options) => mapWith(input, isURL, embedURL, options);
var isURL = (value) => value instanceof URL;
var embedURL = (context, url) => [context, toGatewayURL(url, context)];
var isObject2 = (value) => typeof value === "object" && value != null;
var encodeBlob = (data, blob, path) => {
  data.set(path.join("."), blob);
  return [data, void 0];
};
var isBlob5 = (value) => value instanceof Blob3;
var mapTokenInputBlobs = (input) => {
  return mapValueWith(input, isBlob5, encodeBlob, /* @__PURE__ */ new Map(), []);
};
var mapWith = (input, p, f, state) => {
  const [, output] = mapValueWith(input, p, f, state, []);
  return output;
};
var mapValueWith = (input, p, f, state, path) => p(input, state, path) ? f(state, input, path) : Array.isArray(input) ? mapArrayWith(input, p, f, state, path) : isObject2(input) ? mapObjectWith(input, p, f, state, path) : [
  state,
  /** @type {any} */
  input
];
var mapObjectWith = (input, p, f, init, path) => {
  let state = init;
  const output = (
    /** @type {import('./lib/interface.js').Encoded<T, [[I, O]]>} */
    {}
  );
  for (const [key, value] of Object.entries(input)) {
    const [next, out] = mapValueWith(value, p, f, state, [...path, key]);
    output[key] = out;
    state = next;
  }
  return [state, output];
};
var mapArrayWith = (input, p, f, init, path) => {
  const output = (
    /** @type {unknown[]} */
    []
  );
  let state = init;
  for (const [index, element] of input.entries()) {
    const [next, out] = mapValueWith(element, p, f, state, [...path, index]);
    output[index] = out;
    state = next;
  }
  return [
    state,
    /** @type {import('./lib/interface.js').Encoded<T, [[I, O]]>} */
    output
  ];
};
var setIn = (object, path, value) => {
  const n = path.length - 1;
  let target = object;
  for (let [index, key] of path.entries()) {
    if (index === n) {
      target[key] = value;
    } else {
      target = target[key];
    }
  }
};

// ../../node_modules/.pnpm/nft.storage@7.1.1_node-fetch@3.3.2/node_modules/nft.storage/src/lib.js
var import_it_pipe2 = __toESM(require_it_pipe(), 1);
var MAX_STORE_RETRIES = 5;
var MAX_CONCURRENT_UPLOADS = 3;
var MAX_CHUNK_SIZE = 1024 * 1024 * 50;
var RATE_LIMIT_REQUESTS = 30;
var RATE_LIMIT_PERIOD = 10 * 1e3;
function createRateLimiter() {
  const throttle = (0, import_throttled_queue.default)(RATE_LIMIT_REQUESTS, RATE_LIMIT_PERIOD);
  return () => throttle(() => {
  });
}
var globalRateLimiter = createRateLimiter();
var NFTStorage = class _NFTStorage {
  /**
   * Constructs a client bound to the given `options.token` and
   * `options.endpoint`.
   *
   * @example
   * ```js
   * import { NFTStorage, File, Blob } from "nft.storage"
   * const client = new NFTStorage({ token: API_TOKEN })
   *
   * const cid = await client.storeBlob(new Blob(['hello world']))
   * ```
   * Optionally you could pass an alternative API endpoint (e.g. for testing)
   * @example
   * ```js
   * import { NFTStorage } from "nft.storage"
   * const client = new NFTStorage({
   *   token: API_TOKEN
   *   endpoint: new URL('http://localhost:8080/')
   * })
   * ```
   *
   * @param {{token: string, endpoint?: URL, rateLimiter?: RateLimiter, did?: string}} options
   */
  constructor({
    token,
    did,
    endpoint = new URL("https://api.nft.storage"),
    rateLimiter
  }) {
    this.token = token;
    this.endpoint = endpoint;
    this.rateLimiter = rateLimiter || createRateLimiter();
    this.did = did;
  }
  /**
   * @hidden
   * @param {object} options
   * @param {string} options.token
   * @param {string} [options.did]
   */
  static auth({ token, did }) {
    if (!token)
      throw new Error("missing token");
    return __spreadValues({
      Authorization: `Bearer ${token}`,
      "X-Client": "nft.storage/js"
    }, did ? { "x-agent-did": did } : {});
  }
  /**
   * Stores a single file and returns its CID.
   *
   * @param {Service} service
   * @param {Blob} blob
   * @param {RequestOptions} [options]
   * @returns {Promise<CIDString>}
   */
  static storeBlob(service, blob, options) {
    return __async(this, null, function* () {
      const blockstore = new FsBlockStore();
      let cidString;
      try {
        const { cid, car } = yield _NFTStorage.encodeBlob(blob, { blockstore });
        yield _NFTStorage.storeCar(service, car, options);
        cidString = cid.toString();
      } finally {
        yield blockstore.close();
      }
      return cidString;
    });
  }
  /**
   * Stores a CAR file and returns its root CID.
   *
   * @param {Service} service
   * @param {Blob|CarReader} car
   * @param {import('./lib/interface.js').CarStorerOptions} [options]
   * @returns {Promise<CIDString>}
   */
  static storeCar(_0, _1) {
    return __async(this, arguments, function* (_a2, car, { onStoredChunk, maxRetries, maxChunkSize, decoders, signal } = {}) {
      var _b = _a2, { endpoint, rateLimiter = globalRateLimiter } = _b, token = __objRest(_b, ["endpoint", "rateLimiter"]);
      const url = new URL("upload/", endpoint);
      const headers = __spreadProps(__spreadValues({}, _NFTStorage.auth(token)), {
        "Content-Type": "application/car"
      });
      const targetSize = maxChunkSize || MAX_CHUNK_SIZE;
      const splitter = car instanceof Blob3 ? yield TreewalkCarSplitter.fromBlob(car, targetSize, { decoders }) : new TreewalkCarSplitter(car, targetSize, { decoders });
      const upload = transform(
        MAX_CONCURRENT_UPLOADS,
        function(car2) {
          return __async(this, null, function* () {
            var _a3, _b2;
            const carParts = [];
            try {
              for (var iter2 = __forAwait(car2), more2, temp2, error2; more2 = !(temp2 = yield iter2.next()).done; more2 = false) {
                const part = temp2.value;
                carParts.push(part);
              }
            } catch (temp2) {
              error2 = [temp2];
            } finally {
              try {
                more2 && (temp2 = iter2.return) && (yield temp2.call(iter2));
              } finally {
                if (error2)
                  throw error2[0];
              }
            }
            const carFile = new Blob3(carParts, { type: "application/car" });
            let body = carFile;
            if (parseInt((_b2 = (_a3 = globalThis.process) == null ? void 0 : _a3.versions) == null ? void 0 : _b2.node) > 18) {
              body = yield body.arrayBuffer();
            }
            const cid = yield (0, import_p_retry.default)(
              () => __async(this, null, function* () {
                yield rateLimiter();
                let response;
                try {
                  response = yield lib_node_default(url.toString(), {
                    method: "POST",
                    headers,
                    body,
                    signal
                  });
                } catch (err) {
                  throw signal && signal.aborted ? new import_p_retry.AbortError(err) : err;
                }
                if (response.status === 429) {
                  throw new Error("rate limited");
                }
                const result = yield response.json();
                if (!result.ok) {
                  if (response.status === 401) {
                    throw new import_p_retry.AbortError(result.error.message);
                  }
                  throw new Error(result.error.message);
                }
                return result.value.cid;
              }),
              {
                retries: maxRetries == null ? MAX_STORE_RETRIES : maxRetries
              }
            );
            onStoredChunk && onStoredChunk(carFile.size);
            return cid;
          });
        }
      );
      let root;
      try {
        for (var iter = __forAwait(upload(splitter.cars())), more, temp, error; more = !(temp = yield iter.next()).done; more = false) {
          const cid = temp.value;
          root = cid;
        }
      } catch (temp) {
        error = [temp];
      } finally {
        try {
          more && (temp = iter.return) && (yield temp.call(iter));
        } finally {
          if (error)
            throw error[0];
        }
      }
      return (
        /** @type {CIDString} */
        root
      );
    });
  }
  /**
   * Stores a directory of files and returns a CID. Provided files **MUST**
   * be within the same directory, otherwise error is raised e.g. `foo/bar.png`,
   * `foo/bla/baz.json` is ok but `foo/bar.png`, `bla/baz.json` is not.
   *
   * @param {Service} service
   * @param {FilesSource} filesSource
   * @param {RequestOptions} [options]
   * @returns {Promise<CIDString>}
   */
  static storeDirectory(service, filesSource, options) {
    return __async(this, null, function* () {
      const blockstore = new FsBlockStore();
      let cidString;
      try {
        const { cid, car } = yield _NFTStorage.encodeDirectory(filesSource, {
          blockstore
        });
        yield _NFTStorage.storeCar(service, car, options);
        cidString = cid.toString();
      } finally {
        yield blockstore.close();
      }
      return cidString;
    });
  }
  /**
   * Stores the given token and all resources it references (in the form of a
   * File or a Blob) along with a metadata JSON as specificed in ERC-1155. The
   * `token.image` must be either a `File` or a `Blob` instance, which will be
   * stored and the corresponding content address URL will be saved in the
   * metadata JSON file under `image` field.
   *
   * If `token.properties` contains properties with `File` or `Blob` values,
   * those also get stored and their URLs will be saved in the metadata JSON
   * file in their place.
   *
   * Note: URLs for `File` objects will retain file names e.g. in case of
   * `new File([bytes], 'cat.png', { type: 'image/png' })` will be transformed
   * into a URL that looks like `ipfs://bafy...hash/image/cat.png`. For `Blob`
   * objects, the URL will not have a file name name or mime type, instead it
   * will be transformed into a URL that looks like
   * `ipfs://bafy...hash/image/blob`.
   *
   * @template {import('./lib/interface.js').TokenInput} T
   * @param {Service} service
   * @param {T} metadata
   * @param {RequestOptions} [options]
   * @returns {Promise<TokenType<T>>}
   */
  static store(service, metadata, options) {
    return __async(this, null, function* () {
      const { token, car } = yield _NFTStorage.encodeNFT(metadata);
      yield _NFTStorage.storeCar(service, car, options);
      return token;
    });
  }
  /**
   * Returns current status of the stored NFT by its CID. Note the NFT must
   * have previously been stored by this account.
   *
   * @param {Service} service
   * @param {string} cid
   * @param {RequestOptions} [options]
   * @returns {Promise<import('./lib/interface.js').StatusResult>}
   */
  static status(_c, cid, options) {
    return __async(this, null, function* () {
      var _d = _c, { endpoint, rateLimiter = globalRateLimiter } = _d, token = __objRest(_d, ["endpoint", "rateLimiter"]);
      const url = new URL(`${cid}/`, endpoint);
      yield rateLimiter();
      const response = yield lib_node_default(url.toString(), {
        method: "GET",
        headers: _NFTStorage.auth(token),
        signal: options && options.signal
      });
      if (response.status === 429) {
        throw new Error("rate limited");
      }
      const result = yield response.json();
      if (result.ok) {
        return {
          cid: result.value.cid,
          deals: decodeDeals(result.value.deals),
          size: result.value.size,
          pin: decodePin(result.value.pin),
          created: new Date(result.value.created)
        };
      } else {
        throw new Error(result.error.message);
      }
    });
  }
  /**
   * Check if a CID of an NFT is being stored by NFT.Storage.
   *
   * @param {import('./lib/interface.js').PublicService} service
   * @param {string} cid
   * @param {RequestOptions} [options]
   * @returns {Promise<import('./lib/interface.js').CheckResult>}
   */
  static check(_0, _1, _2) {
    return __async(this, arguments, function* ({ endpoint, rateLimiter = globalRateLimiter }, cid, options) {
      const url = new URL(`check/${cid}/`, endpoint);
      yield rateLimiter();
      const response = yield lib_node_default(url.toString(), {
        signal: options && options.signal
      });
      if (response.status === 429) {
        throw new Error("rate limited");
      }
      const result = yield response.json();
      if (result.ok) {
        return {
          cid: result.value.cid,
          deals: decodeDeals(result.value.deals),
          pin: result.value.pin
        };
      } else {
        throw new Error(result.error.message);
      }
    });
  }
  /**
   * Removes stored content by its CID from this account. Please note that
   * even if content is removed from the service other nodes that have
   * replicated it might still continue providing it.
   *
   * @param {Service} service
   * @param {string} cid
   * @param {RequestOptions} [options]
   * @returns {Promise<void>}
   */
  static delete(_e, cid, options) {
    return __async(this, null, function* () {
      var _f = _e, { endpoint, rateLimiter = globalRateLimiter } = _f, token = __objRest(_f, ["endpoint", "rateLimiter"]);
      const url = new URL(`${cid}/`, endpoint);
      yield rateLimiter();
      const response = yield lib_node_default(url.toString(), {
        method: "DELETE",
        headers: _NFTStorage.auth(token),
        signal: options && options.signal
      });
      if (response.status === 429) {
        throw new Error("rate limited");
      }
      const result = yield response.json();
      if (!result.ok) {
        throw new Error(result.error.message);
      }
    });
  }
  /**
   * Encodes the given token and all resources it references (in the form of a
   * File or a Blob) along with a metadata JSON as specificed in ERC-1155 to a
   * CAR file. The `token.image` must be either a `File` or a `Blob` instance,
   * which will be stored and the corresponding content address URL will be
   * saved in the metadata JSON file under `image` field.
   *
   * If `token.properties` contains properties with `File` or `Blob` values,
   * those also get stored and their URLs will be saved in the metadata JSON
   * file in their place.
   *
   * Note: URLs for `File` objects will retain file names e.g. in case of
   * `new File([bytes], 'cat.png', { type: 'image/png' })` will be transformed
   * into a URL that looks like `ipfs://bafy...hash/image/cat.png`. For `Blob`
   * objects, the URL will not have a file name name or mime type, instead it
   * will be transformed into a URL that looks like
   * `ipfs://bafy...hash/image/blob`.
   *
   * @example
   * ```js
   * const { token, car } = await NFTStorage.encodeNFT({
   *   name: 'nft.storage store test',
   *   description: 'Test ERC-1155 compatible metadata.',
   *   image: new File(['<DATA>'], 'pinpie.jpg', { type: 'image/jpg' }),
   *   properties: {
   *     custom: 'Custom data can appear here, files are auto uploaded.',
   *     file: new File(['<DATA>'], 'README.md', { type: 'text/plain' }),
   *   }
   * })
   *
   * console.log('IPFS URL for the metadata:', token.url)
   * console.log('metadata.json contents:\n', token.data)
   * console.log('metadata.json with IPFS gateway URLs:\n', token.embed())
   *
   * // Now store the CAR file on NFT.Storage
   * await client.storeCar(car)
   * ```
   *
   * @template {import('./lib/interface.js').TokenInput} T
   * @param {T} input
   * @returns {Promise<{ cid: CID, token: TokenType<T>, car: CarReader }>}
   */
  static encodeNFT(input) {
    return __async(this, null, function* () {
      validateERC1155(input);
      return Token2.encode(input);
    });
  }
  /**
   * Encodes a single file to a CAR file and also returns its root CID.
   *
   * @example
   * ```js
   * const content = new Blob(['hello world'])
   * const { cid, car } = await NFTStorage.encodeBlob(content)
   *
   * // Root CID of the file
   * console.log(cid.toString())
   *
   * // Now store the CAR file on NFT.Storage
   * await client.storeCar(car)
   * ```
   *
   * @param {Blob} blob
   * @param {object} [options]
   * @param {BlockstoreI} [options.blockstore]
   * @returns {Promise<{ cid: CID, car: CarReader }>}
   */
  static encodeBlob(_0) {
    return __async(this, arguments, function* (blob, { blockstore } = {}) {
      if (blob.size === 0) {
        throw new Error("Content size is 0, make sure to provide some content");
      }
      return packCar([toImportCandidate("blob", blob)], {
        blockstore,
        wrapWithDirectory: false
      });
    });
  }
  /**
   * Encodes a directory of files to a CAR file and also returns the root CID.
   * Provided files **MUST** be within the same directory, otherwise error is
   * raised e.g. `foo/bar.png`, `foo/bla/baz.json` is ok but `foo/bar.png`,
   * `bla/baz.json` is not.
   *
   * @example
   * ```js
   * const { cid, car } = await NFTStorage.encodeDirectory([
   *   new File(['hello world'], 'hello.txt'),
   *   new File([JSON.stringify({'from': 'incognito'}, null, 2)], 'metadata.json')
   * ])
   *
   * // Root CID of the directory
   * console.log(cid.toString())
   *
   * // Now store the CAR file on NFT.Storage
   * await client.storeCar(car)
   * ```
   *
   * @param {FilesSource} files
   * @param {object} [options]
   * @param {BlockstoreI} [options.blockstore]
   * @returns {Promise<{ cid: CID, car: CarReader }>}
   */
  static encodeDirectory(_0) {
    return __async(this, arguments, function* (files, { blockstore } = {}) {
      let size = 0;
      const input = (0, import_it_pipe2.default)(files, function(files2) {
        return __asyncGenerator(this, null, function* () {
          try {
            for (var iter = __forAwait(files2), more, temp, error; more = !(temp = yield new __await(iter.next())).done; more = false) {
              const file = temp.value;
              yield toImportCandidate(file.name, file);
              size += file.size;
            }
          } catch (temp) {
            error = [temp];
          } finally {
            try {
              more && (temp = iter.return) && (yield new __await(temp.call(iter)));
            } finally {
              if (error)
                throw error[0];
            }
          }
        });
      });
      const packed = yield packCar(input, {
        blockstore,
        wrapWithDirectory: true
      });
      if (size === 0) {
        throw new Error(
          "Total size of files should exceed 0, make sure to provide some content"
        );
      }
      return packed;
    });
  }
  // Just a sugar so you don't have to pass around endpoint and token around.
  /**
   * Stores a single file and returns the corresponding Content Identifier (CID).
   * Takes a [Blob](https://developer.mozilla.org/en-US/docs/Web/API/Blob/Blob)
   * or a [File](https://developer.mozilla.org/en-US/docs/Web/API/File). Note
   * that no file name or file metadata is retained.
   *
   * @example
   * ```js
   * const content = new Blob(['hello world'])
   * const cid = await client.storeBlob(content)
   * cid //> 'zdj7Wn9FQAURCP6MbwcWuzi7u65kAsXCdjNTkhbJcoaXBusq9'
   * ```
   *
   * @param {Blob} blob
   * @param {RequestOptions} [options]
   */
  storeBlob(blob, options) {
    return _NFTStorage.storeBlob(this, blob, options);
  }
  /**
   * Stores files encoded as a single [Content Addressed Archive
   * (CAR)](https://github.com/ipld/specs/blob/master/block-layer/content-addressable-archives.md).
   *
   * Takes a [Blob](https://developer.mozilla.org/en-US/docs/Web/API/Blob/Blob)
   * or a [File](https://developer.mozilla.org/en-US/docs/Web/API/File).
   *
   * Returns the corresponding Content Identifier (CID).
   *
   * See the [`ipfs-car` docs](https://www.npmjs.com/package/ipfs-car) for more
   * details on packing a CAR file.
   *
   * @example
   * ```js
   * import { pack } from 'ipfs-car/pack'
   * import { CarReader } from '@ipld/car'
   * const { out, root } = await pack({
   *  input: fs.createReadStream('pinpie.pdf')
   * })
   * const expectedCid = root.toString()
   * const carReader = await CarReader.fromIterable(out)
   * const cid = await storage.storeCar(carReader)
   * console.assert(cid === expectedCid)
   * ```
   *
   * @example
   * ```
   * import { packToBlob } from 'ipfs-car/pack/blob'
   * const data = 'Hello world'
   * const { root, car } = await packToBlob({ input: [new TextEncoder().encode(data)] })
   * const expectedCid = root.toString()
   * const cid = await client.storeCar(car)
   * console.assert(cid === expectedCid)
   * ```
   * @param {Blob|CarReader} car
   * @param {import('./lib/interface.js').CarStorerOptions} [options]
   */
  storeCar(car, options) {
    return _NFTStorage.storeCar(this, car, options);
  }
  /**
   * Stores a directory of files and returns a CID for the directory.
   *
   * @example
   * ```js
   * const cid = await client.storeDirectory([
   *   new File(['hello world'], 'hello.txt'),
   *   new File([JSON.stringify({'from': 'incognito'}, null, 2)], 'metadata.json')
   * ])
   * cid //>
   * ```
   *
   * Argument can be a [FileList](https://developer.mozilla.org/en-US/docs/Web/API/FileList)
   * instance as well, in which case directory structure will be retained.
   *
   * @param {FilesSource} files
   * @param {RequestOptions} [options]
   */
  storeDirectory(files, options) {
    return _NFTStorage.storeDirectory(this, files, options);
  }
  /**
   * Returns current status of the stored NFT by its CID. Note the NFT must
   * have previously been stored by this account.
   *
   * @example
   * ```js
   * const status = await client.status('zdj7Wn9FQAURCP6MbwcWuzi7u65kAsXCdjNTkhbJcoaXBusq9')
   * ```
   *
   * @param {string} cid
   * @param {RequestOptions} [options]
   */
  status(cid, options) {
    return _NFTStorage.status(this, cid, options);
  }
  /**
   * Removes stored content by its CID from the service.
   *
   * > Please note that even if content is removed from the service other nodes
   * that have replicated it might still continue providing it.
   *
   * @example
   * ```js
   * await client.delete('zdj7Wn9FQAURCP6MbwcWuzi7u65kAsXCdjNTkhbJcoaXBusq9')
   * ```
   *
   * @param {string} cid
   * @param {RequestOptions} [options]
   */
  delete(cid, options) {
    return _NFTStorage.delete(this, cid, options);
  }
  /**
   * Check if a CID of an NFT is being stored by nft.storage. Throws if the NFT
   * was not found.
   *
   * @example
   * ```js
   * const status = await client.check('zdj7Wn9FQAURCP6MbwcWuzi7u65kAsXCdjNTkhbJcoaXBusq9')
   * ```
   *
   * @param {string} cid
   * @param {RequestOptions} [options]
   */
  check(cid, options) {
    return _NFTStorage.check(this, cid, options);
  }
  /**
   * Stores the given token and all resources it references (in the form of a
   * File or a Blob) along with a metadata JSON as specificed in
   * [ERC-1155](https://eips.ethereum.org/EIPS/eip-1155#metadata). The
   * `token.image` must be either a `File` or a `Blob` instance, which will be
   * stored and the corresponding content address URL will be saved in the
   * metadata JSON file under `image` field.
   *
   * If `token.properties` contains properties with `File` or `Blob` values,
   * those also get stored and their URLs will be saved in the metadata JSON
   * file in their place.
   *
   * Note: URLs for `File` objects will retain file names e.g. in case of
   * `new File([bytes], 'cat.png', { type: 'image/png' })` will be transformed
   * into a URL that looks like `ipfs://bafy...hash/image/cat.png`. For `Blob`
   * objects, the URL will not have a file name name or mime type, instead it
   * will be transformed into a URL that looks like
   * `ipfs://bafy...hash/image/blob`.
   *
   * @example
   * ```js
   * const metadata = await client.store({
   *   name: 'nft.storage store test',
   *   description: 'Test ERC-1155 compatible metadata.',
   *   image: new File(['<DATA>'], 'pinpie.jpg', { type: 'image/jpg' }),
   *   properties: {
   *     custom: 'Custom data can appear here, files are auto uploaded.',
   *     file: new File(['<DATA>'], 'README.md', { type: 'text/plain' }),
   *   }
   * })
   *
   * console.log('IPFS URL for the metadata:', metadata.url)
   * console.log('metadata.json contents:\n', metadata.data)
   * console.log('metadata.json with IPFS gateway URLs:\n', metadata.embed())
   * ```
   *
   * @template {import('./lib/interface.js').TokenInput} T
   * @param {T} token
   * @param {RequestOptions} [options]
   */
  store(token, options) {
    return _NFTStorage.store(this, token, options);
  }
};
var validateERC1155 = ({ name: name5, description, image, decimals }) => {
  if (typeof name5 !== "string") {
    throw new TypeError(
      "string property `name` identifying the asset is required"
    );
  }
  if (typeof description !== "string") {
    throw new TypeError(
      "string property `description` describing asset is required"
    );
  }
  if (!(image instanceof Blob3)) {
    throw new TypeError("property `image` must be a Blob or File object");
  } else if (!image.type.startsWith("image/")) {
    console.warn(`According to ERC721 Metadata JSON Schema 'image' must have 'image/*' mime type.

For better interoperability we would highly recommend storing content with different mime type under 'properties' namespace e.g. \`properties: { video: file }\` and using 'image' field for storing a preview image for it instead.

For more context please see ERC-721 specification https://eips.ethereum.org/EIPS/eip-721`);
  }
  if (typeof decimals !== "undefined" && typeof decimals !== "number") {
    throw new TypeError("property `decimals` must be an integer value");
  }
};
var packCar = (_0, ..._1) => __async(void 0, [_0, ..._1], function* (input, { blockstore, wrapWithDirectory } = {}) {
  blockstore = blockstore || new FsBlockStore();
  const { root: cid } = yield pack({ input, blockstore, wrapWithDirectory });
  const car = new BlockstoreCarReader(1, [cid], blockstore);
  return { cid, car };
});
var decodeDeals = (deals) => deals.map((deal) => {
  const { dealActivation, dealExpiration, lastChanged } = __spreadValues({
    dealExpiration: null,
    dealActivation: null
  }, deal);
  return __spreadValues(__spreadValues(__spreadProps(__spreadValues({}, deal), {
    lastChanged: new Date(lastChanged)
  }), dealActivation && { dealActivation: new Date(dealActivation) }), dealExpiration && { dealExpiration: new Date(dealExpiration) });
});
var decodePin = (pin) => __spreadProps(__spreadValues({}, pin), { created: new Date(pin.created) });
function toImportCandidate(path, blob) {
  let stream;
  return {
    path,
    get content() {
      stream = stream || blob.stream();
      return stream;
    }
  };
}

// ../internal/storage/dist/index.mjs
var import_shared8 = require("@solana-suite/shared");
var import_js3 = require("@metaplex-foundation/js");
var __async3 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var Bundlr;
((Bundlr2) => {
  const BUNDLR_CONNECT_TIMEOUT = 6e4;
  Bundlr2.make = (feePayer) => {
    const object = import_js2.Metaplex.make(import_shared7.Node.getConnection()).use(
      (0, import_js2.bundlrStorage)({
        address: import_shared7.Constants.BUNDLR_NETWORK_URL,
        providerUrl: import_shared7.Constants.switchCluster({
          cluster: import_shared7.Constants.currentCluster
        }),
        timeout: BUNDLR_CONNECT_TIMEOUT
      })
    );
    if (isKeypair(feePayer)) {
      object.use((0, import_js2.keypairIdentity)(feePayer));
    } else if (isPhantom(feePayer)) {
      object.use((0, import_js2.walletAdapterIdentity)(feePayer));
    }
    return object;
  };
  Bundlr2.useStorage = (feePayer) => {
    return (0, Bundlr2.make)(feePayer).storage().driver();
  };
  const isKeypair = (payer) => {
    if (!payer) {
      return false;
    }
    return "secretKey" in payer;
  };
  const isPhantom = (payer) => {
    if (!payer) {
      return false;
    }
    return "connect" in payer;
  };
})(Bundlr || (Bundlr = {}));
var Arweave;
((Arweave2) => {
  Arweave2.getUploadPrice = (filePath, feePayer) => __async3(void 0, null, function* () {
    return (0, import_shared6.Try)(() => __async3(void 0, null, function* () {
      let buffer2;
      if ((0, import_shared6.isNode)()) {
        const filepath = filePath;
        buffer2 = (yield import("fs")).readFileSync(filepath);
      } else if ((0, import_shared6.isBrowser)()) {
        const filepath = filePath;
        buffer2 = (0, import_js.toMetaplexFile)(filepath, "").buffer;
      } else {
        throw Error("Supported environment: only Node.js and Browser js");
      }
      const res = yield Bundlr.useStorage(feePayer.toKeypair()).getUploadPrice(
        buffer2.length
      );
      const basisPoints = res.basisPoints.toString();
      (0, import_shared6.debugLog)(
        "# buffer length, price",
        buffer2.length,
        parseInt(basisPoints).toSol()
      );
      return {
        price: parseInt(basisPoints).toSol(),
        currency: res.currency
      };
    }));
  });
  Arweave2.uploadContent = (filePath, feePayer, fileOptions) => __async3(void 0, null, function* () {
    return (0, import_shared6.Try)(() => __async3(void 0, null, function* () {
      (0, import_shared6.debugLog)("# upload content: ", filePath);
      let file;
      if ((0, import_shared6.isNode)()) {
        const filepath = filePath;
        const buffer2 = (yield import("fs")).readFileSync(filepath);
        if (fileOptions) {
          file = (0, import_js.toMetaplexFile)(buffer2, filepath, fileOptions);
        } else {
          file = (0, import_js.toMetaplexFile)(buffer2, filepath);
        }
      } else if ((0, import_shared6.isBrowser)()) {
        const filepath = filePath;
        if (fileOptions) {
          file = (0, import_js.toMetaplexFile)(filepath, "", fileOptions);
        } else {
          file = (0, import_js.toMetaplexFile)(filepath, "");
        }
      } else {
        throw Error("Supported environment: only Node.js and Browser js");
      }
      return Bundlr.useStorage(feePayer.toKeypair()).upload(file);
    }));
  });
  Arweave2.uploadMetadata = (metadata, feePayer) => __async3(void 0, null, function* () {
    return (0, import_shared6.Try)(() => __async3(void 0, null, function* () {
      (0, import_shared6.debugLog)("# upload meta data: ", metadata);
      const uploaded = yield Bundlr.make(feePayer.toKeypair()).nfts().uploadMetadata(metadata);
      return uploaded.uri;
    }));
  });
})(Arweave || (Arweave = {}));
var NftStorage;
((NftStorage2) => {
  let isDisplayWarning = false;
  const getNftStorageApiKey = () => {
    if (!import_shared8.Constants.nftStorageApiKey) {
      if (!isDisplayWarning) {
        console.warn(
          `
        [Warning]
        --------------------------------------
        If will use @solana-suite/nft package
        your need to update nftStorage.apiKey define parameter in solana-suite.json.
        can get apiKey from https://nft.storage/
        --------------------------------------
        `
        );
        isDisplayWarning = true;
      }
      return import_shared8.Constants.NFT_STORAGE_API_KEY;
    } else {
      return import_shared8.Constants.nftStorageApiKey;
    }
  };
  const createGatewayUrl = (cid) => `${import_shared8.Constants.NFT_STORAGE_GATEWAY_URL}/${cid}`;
  const connect = () => new NFTStorage({ token: getNftStorageApiKey() });
  NftStorage2.uploadContent = (filePath) => __async3(void 0, null, function* () {
    return (0, import_shared8.Try)(() => __async3(void 0, null, function* () {
      (0, import_shared8.debugLog)("# upload content: ", filePath);
      let file;
      if ((0, import_shared8.isNode)()) {
        const filepath = filePath;
        file = (yield import("fs")).readFileSync(filepath);
      } else if ((0, import_shared8.isBrowser)()) {
        const filepath = filePath;
        file = (0, import_js3.toMetaplexFile)(filepath, "").buffer;
      } else {
        throw Error("Supported environment: only Node.js and Browser js");
      }
      const blobImage = new Blob3([file]);
      const res = yield connect().storeBlob(blobImage);
      return createGatewayUrl(res);
    }));
  });
  NftStorage2.uploadMetadata = (metadata) => __async3(void 0, null, function* () {
    return (0, import_shared8.Try)(() => __async3(void 0, null, function* () {
      (0, import_shared8.debugLog)("# upload metadata: ", metadata);
      const blobJson = new Blob3([JSON.stringify(metadata)]);
      const res = yield connect().storeBlob(blobJson);
      return createGatewayUrl(res);
    }));
  });
})(NftStorage || (NftStorage = {}));
var Storage;
((Storage2) => {
  Storage2.toConvertOffchaindata = (input, sellerFeeBasisPoints) => {
    const data = {
      name: input.name,
      symbol: input.symbol,
      description: input.description,
      seller_fee_basis_points: sellerFeeBasisPoints,
      external_url: input.external_url,
      attributes: input.attributes,
      properties: input.properties,
      image: "",
      options: input.options
    };
    return data;
  };
  Storage2.uploadContent = (filePath, storageType, feePayer) => __async3(void 0, null, function* () {
    if (storageType === "arweave") {
      if (!feePayer) {
        throw Error("Arweave needs to have feepayer");
      }
      return yield Arweave.uploadContent(filePath, feePayer);
    } else if (storageType === "nftStorage") {
      return yield NftStorage.uploadContent(filePath);
    } else {
      throw Error("Not found storageType");
    }
  });
  Storage2.uploadMetaAndContent = (input, filePath, storageType, feePayer) => __async3(void 0, null, function* () {
    let storage;
    if (storageType === "arweave") {
      if (!feePayer) {
        throw Error("Arweave needs to have feepayer");
      }
      storage = yield (yield Arweave.uploadContent(filePath, feePayer)).unwrap(
        (ok) => __async3(void 0, null, function* () {
          input.image = ok;
          return yield Arweave.uploadMetadata(input, feePayer);
        }),
        (err) => {
          throw err;
        }
      );
    } else if (storageType === "nftStorage") {
      storage = yield (yield NftStorage.uploadContent(filePath)).unwrap(
        (ok) => __async3(void 0, null, function* () {
          input.image = ok;
          return yield NftStorage.uploadMetadata(input);
        }),
        (err) => {
          throw err;
        }
      );
    } else {
      throw Error("No match storageType");
    }
    if (!storage) {
      throw Error("Empty storage object");
    }
    return storage;
  });
})(Storage || (Storage = {}));

// src/metaplex/mint.ts
var import_web32 = require("@solana/web3.js");
var import_bn = __toESM(require("bn.js"));
var import_spl_token2 = require("@solana/spl-token");
var import_shared9 = require("@solana-suite/shared");
var import_mpl_token_metadata3 = require("@metaplex-foundation/mpl-token-metadata");
var import_shared10 = require("@solana-suite/shared");
var NFT_AMOUNT = 1;
var Metaplex4;
((Metaplex10) => {
  Metaplex10.createDeleagateInstruction = (mint2, owner, delegateAuthority) => {
    const tokenAccount = (0, import_spl_token2.getAssociatedTokenAddressSync)(mint2, owner);
    return (0, import_spl_token2.createApproveInstruction)(
      tokenAccount,
      delegateAuthority,
      owner,
      NFT_AMOUNT
    );
  };
  Metaplex10.createMintInstructions = (mint2, owner, nftMetadata, feePayer, isMutable) => __async(void 0, null, function* () {
    const ata = (0, import_spl_token2.getAssociatedTokenAddressSync)(mint2, owner);
    const tokenMetadataPubkey = Pda.getMetadata(mint2.toString());
    const masterEditionPubkey = Pda.getMasterEdition(mint2.toString());
    const connection = import_shared10.Node.getConnection();
    const inst1 = import_web32.SystemProgram.createAccount({
      fromPubkey: feePayer,
      newAccountPubkey: mint2,
      lamports: yield (0, import_spl_token2.getMinimumBalanceForRentExemptMint)(connection),
      space: import_spl_token2.MINT_SIZE,
      programId: import_spl_token2.TOKEN_PROGRAM_ID
    });
    const inst2 = (0, import_spl_token2.createInitializeMintInstruction)(mint2, 0, owner, owner);
    const inst3 = (0, import_spl_token2.createAssociatedTokenAccountInstruction)(
      feePayer,
      ata,
      owner,
      mint2
    );
    const inst4 = (0, import_spl_token2.createMintToCheckedInstruction)(mint2, ata, owner, 1, 0);
    const inst5 = (0, import_mpl_token_metadata3.createCreateMetadataAccountV3Instruction)(
      {
        metadata: tokenMetadataPubkey,
        mint: mint2,
        mintAuthority: owner,
        payer: feePayer,
        updateAuthority: owner
      },
      {
        createMetadataAccountArgsV3: {
          data: nftMetadata,
          isMutable,
          collectionDetails: { __kind: "V1", size: new import_bn.default(1) }
        }
      }
    );
    const inst6 = (0, import_mpl_token_metadata3.createCreateMasterEditionV3Instruction)(
      {
        edition: masterEditionPubkey,
        mint: mint2,
        updateAuthority: owner,
        mintAuthority: owner,
        payer: feePayer,
        metadata: tokenMetadataPubkey
      },
      {
        createMasterEditionArgs: {
          maxSupply: 0
        }
      }
    );
    return [inst1, inst2, inst3, inst4, inst5, inst6];
  });
  Metaplex10.mint = (owner, signer, input, feePayer, freezeAuthority) => __async(void 0, null, function* () {
    return (0, import_shared9.Try)(() => __async(void 0, null, function* () {
      const valid = Validator.checkAll(input);
      if (valid.isErr) {
        throw valid.error;
      }
      const payer = feePayer ? feePayer : signer;
      let properties;
      if (input.properties && input.storageType) {
        properties = yield Convert7.Properties.intoInfraSide(
          input.properties,
          Storage.uploadContent,
          input.storageType,
          payer
        );
      } else if (input.properties && !input.storageType) {
        throw Error("Must set storageType if will use properties");
      }
      input = __spreadProps(__spreadValues({}, input), {
        properties
      });
      const sellerFeeBasisPoints = Royalty.convert(input.royalty);
      const nftStorageMetadata = Storage.toConvertOffchaindata(
        input,
        sellerFeeBasisPoints
      );
      const createdAt = Math.floor((/* @__PURE__ */ new Date()).getTime() / 1e3);
      nftStorageMetadata.created_at = createdAt;
      let uri;
      if (input.filePath && input.storageType) {
        const uploaded = yield Storage.uploadMetaAndContent(
          nftStorageMetadata,
          input.filePath,
          input.storageType,
          payer
        );
        (0, import_shared9.debugLog)("# upload content url: ", uploaded);
        if (uploaded.isErr) {
          throw uploaded;
        }
        uri = uploaded.value;
      } else if (input.uri) {
        uri = input.uri;
      } else {
        throw Error(`Must set 'storageType + filePath' or 'uri'`);
      }
      let datav2 = Convert7.NftMetadata.intoInfraSide(
        input,
        uri,
        sellerFeeBasisPoints
      );
      let collection;
      if (input.collection && input.collection) {
        collection = Convert7.Collection.intoInfraSide(input.collection);
        datav2 = __spreadProps(__spreadValues({}, datav2), { collection });
      }
      const isMutable = input.isMutable === void 0 ? true : input.isMutable;
      (0, import_shared9.debugLog)("# input: ", input);
      (0, import_shared9.debugLog)("# sellerFeeBasisPoints: ", sellerFeeBasisPoints);
      (0, import_shared9.debugLog)("# datav2: ", datav2);
      const mint2 = import_shared9.KeypairAccount.create();
      const insts = yield (0, Metaplex10.createMintInstructions)(
        mint2.toPublicKey(),
        owner.toPublicKey(),
        datav2,
        payer.toKeypair().publicKey,
        isMutable
      );
      if (freezeAuthority) {
        insts.push(
          (0, Metaplex10.createDeleagateInstruction)(
            mint2.toPublicKey(),
            owner.toPublicKey(),
            freezeAuthority.toPublicKey()
          )
        );
      }
      return new import_shared9.MintInstruction(
        insts,
        [signer.toKeypair(), mint2.toKeypair()],
        payer.toKeypair(),
        mint2.pubkey
      );
    }));
  });
})(Metaplex4 || (Metaplex4 = {}));

// src/metaplex/fee-payer-partial-sign-mint.ts
var Metaplex5;
((Metaplex10) => {
  Metaplex10.feePayerPartialSignMint = (owner, signer, input, feePayer, freezeAuthority) => __async(void 0, null, function* () {
    return (0, import_shared11.Try)(() => __async(void 0, null, function* () {
      const valid = Validator.checkAll(input);
      if (valid.isErr) {
        throw valid.error;
      }
      const sellerFeeBasisPoints = Royalty.convert(input.royalty);
      let uri = "";
      if (input.filePath && input.storageType === "nftStorage") {
        const properties = yield Convert7.Properties.intoInfraSide(
          input.properties,
          Storage.uploadContent,
          input.storageType
        );
        const nftStorageMetadata = Storage.toConvertOffchaindata(
          __spreadProps(__spreadValues({}, input), { properties }),
          sellerFeeBasisPoints
        );
        const uploaded = yield Storage.uploadMetaAndContent(
          nftStorageMetadata,
          input.filePath,
          input.storageType
        );
        if (uploaded.isErr) {
          throw uploaded;
        }
        uri = uploaded.value;
        (0, import_shared11.debugLog)("# upload content url: ", uploaded);
      } else if (input.uri) {
        uri = input.uri;
      } else {
        throw Error(`Must set 'storageType=nftStorage + filePath' or 'uri'`);
      }
      let datav2 = Convert7.NftMetadata.intoInfraSide(
        input,
        uri,
        sellerFeeBasisPoints
      );
      let collection;
      if (input.collection && input.collection) {
        collection = Convert7.Collection.intoInfraSide(input.collection);
        datav2 = __spreadProps(__spreadValues({}, datav2), { collection });
      }
      const isMutable = input.isMutable === void 0 ? true : input.isMutable;
      (0, import_shared11.debugLog)("# input: ", input);
      (0, import_shared11.debugLog)("# sellerFeeBasisPoints: ", sellerFeeBasisPoints);
      (0, import_shared11.debugLog)("# datav2: ", datav2);
      const mint = import_shared11.KeypairAccount.create();
      const insts = yield Metaplex4.createMintInstructions(
        mint.toPublicKey(),
        owner.toPublicKey(),
        datav2,
        feePayer.toPublicKey(),
        isMutable
      );
      if (freezeAuthority) {
        insts.push(
          Metaplex4.createDeleagateInstruction(
            mint.toPublicKey(),
            owner.toPublicKey(),
            freezeAuthority.toPublicKey()
          )
        );
      }
      const blockhashObj = yield import_shared11.Node.getConnection().getLatestBlockhash();
      const tx = new import_web33.Transaction({
        lastValidBlockHeight: blockhashObj.lastValidBlockHeight,
        blockhash: blockhashObj.blockhash,
        feePayer: feePayer.toPublicKey()
      });
      insts.forEach((inst) => tx.add(inst));
      tx.recentBlockhash = blockhashObj.blockhash;
      [signer, mint].forEach((signer2) => tx.partialSign(signer2.toKeypair()));
      const serializedTx = tx.serialize({
        requireAllSignatures: false
      });
      const hex = serializedTx.toString("hex");
      return new import_shared11.PartialSignInstruction(hex, mint.pubkey);
    }));
  });
})(Metaplex5 || (Metaplex5 = {}));

// src/metaplex/fee-payer-partial-sign-transfer.ts
var import_core3 = require("@solana-suite/core");
var Metaplex6;
((Metaplex10) => {
  const NFT_AMOUNT2 = 1;
  const NFT_DECIMALS = 0;
  Metaplex10.feePayerPartialSignTransferNft = (mint, owner, dest, signers, feePayer) => __async(void 0, null, function* () {
    return import_core3.SplToken.feePayerPartialSignTransfer(
      mint,
      owner,
      dest,
      signers,
      NFT_AMOUNT2,
      NFT_DECIMALS,
      feePayer
    );
  });
})(Metaplex6 || (Metaplex6 = {}));

// src/metaplex/thaw.ts
var import_shared12 = require("@solana-suite/shared");
var import_spl_token3 = require("@solana/spl-token");
var import_mpl_token_metadata4 = require("@metaplex-foundation/mpl-token-metadata");
var Metaplex7;
((Metaplex10) => {
  Metaplex10.thaw = (mint, owner, freezeAuthority, feePayer) => {
    const payer = feePayer ? feePayer : freezeAuthority;
    return (0, import_shared12.Try)(() => {
      const tokenAccount = (0, import_spl_token3.getAssociatedTokenAddressSync)(
        mint.toPublicKey(),
        owner.toPublicKey()
      );
      const editionAddress = Pda.getMasterEdition(mint);
      const inst = (0, import_mpl_token_metadata4.createThawDelegatedAccountInstruction)({
        delegate: new import_shared12.KeypairAccount({ secret: freezeAuthority }).toPublicKey(),
        tokenAccount,
        edition: editionAddress,
        mint: mint.toPublicKey()
      });
      return new import_shared12.Instruction(
        [inst],
        [freezeAuthority.toKeypair()],
        payer.toKeypair()
      );
    });
  };
})(Metaplex7 || (Metaplex7 = {}));

// src/metaplex/transfer.ts
var import_core4 = require("@solana-suite/core");
var Metaplex8;
((Metaplex10) => {
  const NFT_AMOUNT2 = 1;
  const NFT_DECIMALS = 0;
  Metaplex10.transfer = (mint, owner, dest, signers, feePayer) => __async(void 0, null, function* () {
    return import_core4.SplToken.transfer(
      mint,
      owner,
      dest,
      signers,
      NFT_AMOUNT2,
      NFT_DECIMALS,
      feePayer
    );
  });
})(Metaplex8 || (Metaplex8 = {}));

// src/metaplex/index.ts
var Metaplex9 = Object.assign(
  {},
  Metaplex,
  Metaplex2,
  Metaplex3,
  Metaplex5,
  Metaplex6,
  Metaplex4,
  Metaplex7,
  Metaplex8
);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Metaplex
});
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3JldHJ5QDAuMTMuMS9ub2RlX21vZHVsZXMvcmV0cnkvbGliL3JldHJ5X29wZXJhdGlvbi5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vcmV0cnlAMC4xMy4xL25vZGVfbW9kdWxlcy9yZXRyeS9saWIvcmV0cnkuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3JldHJ5QDAuMTMuMS9ub2RlX21vZHVsZXMvcmV0cnkvaW5kZXguanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3AtcmV0cnlANC42LjIvbm9kZV9tb2R1bGVzL3AtcmV0cnkvaW5kZXguanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3ZhcmludEA2LjAuMC9ub2RlX21vZHVsZXMvdmFyaW50L2VuY29kZS5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vdmFyaW50QDYuMC4wL25vZGVfbW9kdWxlcy92YXJpbnQvZGVjb2RlLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS92YXJpbnRANi4wLjAvbm9kZV9tb2R1bGVzL3ZhcmludC9sZW5ndGguanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3ZhcmludEA2LjAuMC9ub2RlX21vZHVsZXMvdmFyaW50L2luZGV4LmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9pdC1sYXN0QDEuMC42L25vZGVfbW9kdWxlcy9pdC1sYXN0L2luZGV4LmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9pdC1waXBlQDEuMS4wL25vZGVfbW9kdWxlcy9pdC1waXBlL2luZGV4LmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9pdC1iYXRjaEAxLjAuOS9ub2RlX21vZHVsZXMvaXQtYmF0Y2gvaW5kZXguanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2l0LXBhcmFsbGVsLWJhdGNoQDEuMC4xMS9ub2RlX21vZHVsZXMvaXQtcGFyYWxsZWwtYmF0Y2gvaW5kZXguanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2lzLXBsYWluLW9iakAyLjEuMC9ub2RlX21vZHVsZXMvaXMtcGxhaW4tb2JqL2luZGV4LmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9tZXJnZS1vcHRpb25zQDMuMC40L25vZGVfbW9kdWxlcy9tZXJnZS1vcHRpb25zL2luZGV4LmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9tdXJtdXJoYXNoM2pzLXJldmlzaXRlZEAzLjAuMC9ub2RlX21vZHVsZXMvbXVybXVyaGFzaDNqcy1yZXZpc2l0ZWQvbGliL211cm11ckhhc2gzanMuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL211cm11cmhhc2gzanMtcmV2aXNpdGVkQDMuMC4wL25vZGVfbW9kdWxlcy9tdXJtdXJoYXNoM2pzLXJldmlzaXRlZC9pbmRleC5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZXJyLWNvZGVAMy4wLjEvbm9kZV9tb2R1bGVzL2Vyci1jb2RlL2luZGV4LmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AcHJvdG9idWZqcythc3Byb21pc2VAMS4xLjIvbm9kZV9tb2R1bGVzL0Bwcm90b2J1ZmpzL2FzcHJvbWlzZS9pbmRleC5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHByb3RvYnVmanMrYmFzZTY0QDEuMS4yL25vZGVfbW9kdWxlcy9AcHJvdG9idWZqcy9iYXNlNjQvaW5kZXguanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0Bwcm90b2J1ZmpzK2V2ZW50ZW1pdHRlckAxLjEuMC9ub2RlX21vZHVsZXMvQHByb3RvYnVmanMvZXZlbnRlbWl0dGVyL2luZGV4LmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AcHJvdG9idWZqcytmbG9hdEAxLjAuMi9ub2RlX21vZHVsZXMvQHByb3RvYnVmanMvZmxvYXQvaW5kZXguanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0Bwcm90b2J1ZmpzK2lucXVpcmVAMS4xLjAvbm9kZV9tb2R1bGVzL0Bwcm90b2J1ZmpzL2lucXVpcmUvaW5kZXguanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0Bwcm90b2J1ZmpzK3V0ZjhAMS4xLjAvbm9kZV9tb2R1bGVzL0Bwcm90b2J1ZmpzL3V0ZjgvaW5kZXguanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0Bwcm90b2J1ZmpzK3Bvb2xAMS4xLjAvbm9kZV9tb2R1bGVzL0Bwcm90b2J1ZmpzL3Bvb2wvaW5kZXguanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3Byb3RvYnVmanNANi4xMS40L25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy91dGlsL2xvbmdiaXRzLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9wcm90b2J1ZmpzQDYuMTEuNC9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvdXRpbC9taW5pbWFsLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9wcm90b2J1ZmpzQDYuMTEuNC9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvd3JpdGVyLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9wcm90b2J1ZmpzQDYuMTEuNC9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvd3JpdGVyX2J1ZmZlci5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vcHJvdG9idWZqc0A2LjExLjQvbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3JlYWRlci5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vcHJvdG9idWZqc0A2LjExLjQvbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3JlYWRlcl9idWZmZXIuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3Byb3RvYnVmanNANi4xMS40L25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9ycGMvc2VydmljZS5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vcHJvdG9idWZqc0A2LjExLjQvbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3JwYy5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vcHJvdG9idWZqc0A2LjExLjQvbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3Jvb3RzLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9wcm90b2J1ZmpzQDYuMTEuNC9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvaW5kZXgtbWluaW1hbC5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vcHJvdG9idWZqc0A2LjExLjQvbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvbWluaW1hbC5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vaXQtYWxsQDEuMC42L25vZGVfbW9kdWxlcy9pdC1hbGwvaW5kZXguanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2JsQDUuMS4wL25vZGVfbW9kdWxlcy9ibC9CdWZmZXJMaXN0LmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9yYWJpbi13YXNtQDAuMS41L25vZGVfbW9kdWxlcy9yYWJpbi13YXNtL3NyYy9yYWJpbi5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQGFzc2VtYmx5c2NyaXB0K2xvYWRlckAwLjkuNC9ub2RlX21vZHVsZXMvQGFzc2VtYmx5c2NyaXB0L2xvYWRlci9pbmRleC5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vcmFiaW4td2FzbUAwLjEuNS9ub2RlX21vZHVsZXMvcmFiaW4td2FzbS9kaXN0L3JhYmluLXdhc20ubm9kZS5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vcmFiaW4td2FzbUAwLjEuNS9ub2RlX21vZHVsZXMvcmFiaW4td2FzbS9zcmMvaW5kZXguanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3NwYXJzZS1hcnJheUAxLjMuMi9ub2RlX21vZHVsZXMvc3BhcnNlLWFycmF5L2luZGV4LmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9tdWx0aWZvcm1hdHNAOS45LjAvbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9janMvdmVuZG9yL2Jhc2UteC5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbXVsdGlmb3JtYXRzQDkuOS4wL25vZGVfbW9kdWxlcy9tdWx0aWZvcm1hdHMvY2pzL3NyYy9ieXRlcy5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbXVsdGlmb3JtYXRzQDkuOS4wL25vZGVfbW9kdWxlcy9tdWx0aWZvcm1hdHMvY2pzL3NyYy9iYXNlcy9iYXNlLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9tdWx0aWZvcm1hdHNAOS45LjAvbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9janMvc3JjL2Jhc2VzL2lkZW50aXR5LmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9tdWx0aWZvcm1hdHNAOS45LjAvbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9janMvc3JjL2Jhc2VzL2Jhc2UyLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9tdWx0aWZvcm1hdHNAOS45LjAvbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9janMvc3JjL2Jhc2VzL2Jhc2U4LmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9tdWx0aWZvcm1hdHNAOS45LjAvbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9janMvc3JjL2Jhc2VzL2Jhc2UxMC5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbXVsdGlmb3JtYXRzQDkuOS4wL25vZGVfbW9kdWxlcy9tdWx0aWZvcm1hdHMvY2pzL3NyYy9iYXNlcy9iYXNlMTYuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL211bHRpZm9ybWF0c0A5LjkuMC9ub2RlX21vZHVsZXMvbXVsdGlmb3JtYXRzL2Nqcy9zcmMvYmFzZXMvYmFzZTMyLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9tdWx0aWZvcm1hdHNAOS45LjAvbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9janMvc3JjL2Jhc2VzL2Jhc2UzNi5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbXVsdGlmb3JtYXRzQDkuOS4wL25vZGVfbW9kdWxlcy9tdWx0aWZvcm1hdHMvY2pzL3NyYy9iYXNlcy9iYXNlNTguanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL211bHRpZm9ybWF0c0A5LjkuMC9ub2RlX21vZHVsZXMvbXVsdGlmb3JtYXRzL2Nqcy9zcmMvYmFzZXMvYmFzZTY0LmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9tdWx0aWZvcm1hdHNAOS45LjAvbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9janMvc3JjL2Jhc2VzL2Jhc2UyNTZlbW9qaS5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbXVsdGlmb3JtYXRzQDkuOS4wL25vZGVfbW9kdWxlcy9tdWx0aWZvcm1hdHMvY2pzL3ZlbmRvci92YXJpbnQuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL211bHRpZm9ybWF0c0A5LjkuMC9ub2RlX21vZHVsZXMvbXVsdGlmb3JtYXRzL2Nqcy9zcmMvdmFyaW50LmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9tdWx0aWZvcm1hdHNAOS45LjAvbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9janMvc3JjL2hhc2hlcy9kaWdlc3QuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL211bHRpZm9ybWF0c0A5LjkuMC9ub2RlX21vZHVsZXMvbXVsdGlmb3JtYXRzL2Nqcy9zcmMvaGFzaGVzL2hhc2hlci5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbXVsdGlmb3JtYXRzQDkuOS4wL25vZGVfbW9kdWxlcy9tdWx0aWZvcm1hdHMvY2pzL3NyYy9oYXNoZXMvc2hhMi5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbXVsdGlmb3JtYXRzQDkuOS4wL25vZGVfbW9kdWxlcy9tdWx0aWZvcm1hdHMvY2pzL3NyYy9oYXNoZXMvaWRlbnRpdHkuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL211bHRpZm9ybWF0c0A5LjkuMC9ub2RlX21vZHVsZXMvbXVsdGlmb3JtYXRzL2Nqcy9zcmMvY29kZWNzL3Jhdy5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbXVsdGlmb3JtYXRzQDkuOS4wL25vZGVfbW9kdWxlcy9tdWx0aWZvcm1hdHMvY2pzL3NyYy9jb2RlY3MvanNvbi5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbXVsdGlmb3JtYXRzQDkuOS4wL25vZGVfbW9kdWxlcy9tdWx0aWZvcm1hdHMvY2pzL3NyYy9jaWQuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL211bHRpZm9ybWF0c0A5LjkuMC9ub2RlX21vZHVsZXMvbXVsdGlmb3JtYXRzL2Nqcy9zcmMvaW5kZXguanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL211bHRpZm9ybWF0c0A5LjkuMC9ub2RlX21vZHVsZXMvbXVsdGlmb3JtYXRzL2Nqcy9zcmMvYmFzaWNzLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS91aW50OGFycmF5c0AzLjEuMS9ub2RlX21vZHVsZXMvdWludDhhcnJheXMvY2pzL3NyYy91dGlsL2FzLXVpbnQ4YXJyYXkuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3VpbnQ4YXJyYXlzQDMuMS4xL25vZGVfbW9kdWxlcy91aW50OGFycmF5cy9janMvc3JjL2FsbG9jLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS91aW50OGFycmF5c0AzLjEuMS9ub2RlX21vZHVsZXMvdWludDhhcnJheXMvY2pzL3NyYy91dGlsL2Jhc2VzLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS91aW50OGFycmF5c0AzLjEuMS9ub2RlX21vZHVsZXMvdWludDhhcnJheXMvY2pzL3NyYy9mcm9tLXN0cmluZy5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vaGFtdC1zaGFyZGluZ0AyLjAuMS9ub2RlX21vZHVsZXMvaGFtdC1zaGFyZGluZy9zcmMvYnVja2V0LmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9oYW10LXNoYXJkaW5nQDIuMC4xL25vZGVfbW9kdWxlcy9oYW10LXNoYXJkaW5nL3NyYy9jb25zdW1hYmxlLWJ1ZmZlci5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vdWludDhhcnJheXNAMy4xLjEvbm9kZV9tb2R1bGVzL3VpbnQ4YXJyYXlzL2Nqcy9zcmMvY29uY2F0LmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9oYW10LXNoYXJkaW5nQDIuMC4xL25vZGVfbW9kdWxlcy9oYW10LXNoYXJkaW5nL3NyYy9jb25zdW1hYmxlLWhhc2guanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2hhbXQtc2hhcmRpbmdAMi4wLjEvbm9kZV9tb2R1bGVzL2hhbXQtc2hhcmRpbmcvc3JjL2luZGV4LmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9icm93c2VyLXJlYWRhYmxlc3RyZWFtLXRvLWl0QDEuMC4zL25vZGVfbW9kdWxlcy9icm93c2VyLXJlYWRhYmxlc3RyZWFtLXRvLWl0L2luZGV4LmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9ibG9iLXRvLWl0QDEuMC40L25vZGVfbW9kdWxlcy9ibG9iLXRvLWl0L2luZGV4LmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9pdC1wZWVrYWJsZUAxLjAuMy9ub2RlX21vZHVsZXMvaXQtcGVla2FibGUvaW5kZXguanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2l0LW1hcEAxLjAuNi9ub2RlX21vZHVsZXMvaXQtbWFwL2luZGV4LmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9pdC1kcmFpbkAxLjAuNS9ub2RlX21vZHVsZXMvaXQtZHJhaW4vaW5kZXguanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2l0LWZpbHRlckAxLjAuMy9ub2RlX21vZHVsZXMvaXQtZmlsdGVyL2luZGV4LmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9pdC10YWtlQDEuMC4yL25vZGVfbW9kdWxlcy9pdC10YWtlL2luZGV4LmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS90aHJvdHRsZWQtcXVldWVAMi4xLjQvbm9kZV9tb2R1bGVzL3Rocm90dGxlZC1xdWV1ZS9zcmMvdGhyb3R0bGVkUXVldWUudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2RhdGEtdXJpLXRvLWJ1ZmZlckAzLjAuMS9ub2RlX21vZHVsZXMvZGF0YS11cmktdG8tYnVmZmVyL3NyYy9pbmRleC50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vd2ViLXN0cmVhbXMtcG9seWZpbGxAMy4yLjEvbm9kZV9tb2R1bGVzL3dlYi1zdHJlYW1zLXBvbHlmaWxsL3NyYy9zdHViL3N5bWJvbC50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vd2ViLXN0cmVhbXMtcG9seWZpbGxAMy4yLjEvbm9kZV9tb2R1bGVzL3dlYi1zdHJlYW1zLXBvbHlmaWxsL3NyYy91dGlscy50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vd2ViLXN0cmVhbXMtcG9seWZpbGxAMy4yLjEvbm9kZV9tb2R1bGVzL3dlYi1zdHJlYW1zLXBvbHlmaWxsL3NyYy9saWIvaGVscGVycy9taXNjZWxsYW5lb3VzLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS93ZWItc3RyZWFtcy1wb2x5ZmlsbEAzLjIuMS9ub2RlX21vZHVsZXMvd2ViLXN0cmVhbXMtcG9seWZpbGwvc3JjL2xpYi9oZWxwZXJzL3dlYmlkbC50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vd2ViLXN0cmVhbXMtcG9seWZpbGxAMy4yLjEvbm9kZV9tb2R1bGVzL3dlYi1zdHJlYW1zLXBvbHlmaWxsL3NyYy9saWIvc2ltcGxlLXF1ZXVlLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS93ZWItc3RyZWFtcy1wb2x5ZmlsbEAzLjIuMS9ub2RlX21vZHVsZXMvd2ViLXN0cmVhbXMtcG9seWZpbGwvc3JjL2xpYi9yZWFkYWJsZS1zdHJlYW0vZ2VuZXJpYy1yZWFkZXIudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3dlYi1zdHJlYW1zLXBvbHlmaWxsQDMuMi4xL25vZGVfbW9kdWxlcy93ZWItc3RyZWFtcy1wb2x5ZmlsbC9zcmMvbGliL2Fic3RyYWN0LW9wcy9pbnRlcm5hbC1tZXRob2RzLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS93ZWItc3RyZWFtcy1wb2x5ZmlsbEAzLjIuMS9ub2RlX21vZHVsZXMvd2ViLXN0cmVhbXMtcG9seWZpbGwvc3JjL3N0dWIvbnVtYmVyLWlzZmluaXRlLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS93ZWItc3RyZWFtcy1wb2x5ZmlsbEAzLjIuMS9ub2RlX21vZHVsZXMvd2ViLXN0cmVhbXMtcG9seWZpbGwvc3JjL3N0dWIvbWF0aC10cnVuYy50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vd2ViLXN0cmVhbXMtcG9seWZpbGxAMy4yLjEvbm9kZV9tb2R1bGVzL3dlYi1zdHJlYW1zLXBvbHlmaWxsL3NyYy9saWIvdmFsaWRhdG9ycy9iYXNpYy50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vd2ViLXN0cmVhbXMtcG9seWZpbGxAMy4yLjEvbm9kZV9tb2R1bGVzL3dlYi1zdHJlYW1zLXBvbHlmaWxsL3NyYy9saWIvdmFsaWRhdG9ycy9yZWFkYWJsZS1zdHJlYW0udHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3dlYi1zdHJlYW1zLXBvbHlmaWxsQDMuMi4xL25vZGVfbW9kdWxlcy93ZWItc3RyZWFtcy1wb2x5ZmlsbC9zcmMvbGliL3JlYWRhYmxlLXN0cmVhbS9kZWZhdWx0LXJlYWRlci50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vd2ViLXN0cmVhbXMtcG9seWZpbGxAMy4yLjEvbm9kZV9tb2R1bGVzL3dlYi1zdHJlYW1zLXBvbHlmaWxsL3NyYy90YXJnZXQvZXM1L3N0dWIvYXN5bmMtaXRlcmF0b3ItcHJvdG90eXBlLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS93ZWItc3RyZWFtcy1wb2x5ZmlsbEAzLjIuMS9ub2RlX21vZHVsZXMvd2ViLXN0cmVhbXMtcG9seWZpbGwvc3JjL2xpYi9yZWFkYWJsZS1zdHJlYW0vYXN5bmMtaXRlcmF0b3IudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3dlYi1zdHJlYW1zLXBvbHlmaWxsQDMuMi4xL25vZGVfbW9kdWxlcy93ZWItc3RyZWFtcy1wb2x5ZmlsbC9zcmMvc3R1Yi9udW1iZXItaXNuYW4udHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3dlYi1zdHJlYW1zLXBvbHlmaWxsQDMuMi4xL25vZGVfbW9kdWxlcy93ZWItc3RyZWFtcy1wb2x5ZmlsbC9zcmMvbGliL2Fic3RyYWN0LW9wcy9lY21hc2NyaXB0LnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS93ZWItc3RyZWFtcy1wb2x5ZmlsbEAzLjIuMS9ub2RlX21vZHVsZXMvd2ViLXN0cmVhbXMtcG9seWZpbGwvc3JjL2xpYi9hYnN0cmFjdC1vcHMvbWlzY2VsbGFuZW91cy50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vd2ViLXN0cmVhbXMtcG9seWZpbGxAMy4yLjEvbm9kZV9tb2R1bGVzL3dlYi1zdHJlYW1zLXBvbHlmaWxsL3NyYy9saWIvYWJzdHJhY3Qtb3BzL3F1ZXVlLXdpdGgtc2l6ZXMudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3dlYi1zdHJlYW1zLXBvbHlmaWxsQDMuMi4xL25vZGVfbW9kdWxlcy93ZWItc3RyZWFtcy1wb2x5ZmlsbC9zcmMvbGliL3JlYWRhYmxlLXN0cmVhbS9ieXRlLXN0cmVhbS1jb250cm9sbGVyLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS93ZWItc3RyZWFtcy1wb2x5ZmlsbEAzLjIuMS9ub2RlX21vZHVsZXMvd2ViLXN0cmVhbXMtcG9seWZpbGwvc3JjL2xpYi9yZWFkYWJsZS1zdHJlYW0vYnlvYi1yZWFkZXIudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3dlYi1zdHJlYW1zLXBvbHlmaWxsQDMuMi4xL25vZGVfbW9kdWxlcy93ZWItc3RyZWFtcy1wb2x5ZmlsbC9zcmMvbGliL2Fic3RyYWN0LW9wcy9xdWV1aW5nLXN0cmF0ZWd5LnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS93ZWItc3RyZWFtcy1wb2x5ZmlsbEAzLjIuMS9ub2RlX21vZHVsZXMvd2ViLXN0cmVhbXMtcG9seWZpbGwvc3JjL2xpYi92YWxpZGF0b3JzL3F1ZXVpbmctc3RyYXRlZ3kudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3dlYi1zdHJlYW1zLXBvbHlmaWxsQDMuMi4xL25vZGVfbW9kdWxlcy93ZWItc3RyZWFtcy1wb2x5ZmlsbC9zcmMvbGliL3ZhbGlkYXRvcnMvdW5kZXJseWluZy1zaW5rLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS93ZWItc3RyZWFtcy1wb2x5ZmlsbEAzLjIuMS9ub2RlX21vZHVsZXMvd2ViLXN0cmVhbXMtcG9seWZpbGwvc3JjL2xpYi92YWxpZGF0b3JzL3dyaXRhYmxlLXN0cmVhbS50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vd2ViLXN0cmVhbXMtcG9seWZpbGxAMy4yLjEvbm9kZV9tb2R1bGVzL3dlYi1zdHJlYW1zLXBvbHlmaWxsL3NyYy9saWIvYWJvcnQtc2lnbmFsLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS93ZWItc3RyZWFtcy1wb2x5ZmlsbEAzLjIuMS9ub2RlX21vZHVsZXMvd2ViLXN0cmVhbXMtcG9seWZpbGwvc3JjL2xpYi93cml0YWJsZS1zdHJlYW0udHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3dlYi1zdHJlYW1zLXBvbHlmaWxsQDMuMi4xL25vZGVfbW9kdWxlcy93ZWItc3RyZWFtcy1wb2x5ZmlsbC9zcmMvc3R1Yi9uYXRpdmUudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3dlYi1zdHJlYW1zLXBvbHlmaWxsQDMuMi4xL25vZGVfbW9kdWxlcy93ZWItc3RyZWFtcy1wb2x5ZmlsbC9zcmMvc3R1Yi9kb20tZXhjZXB0aW9uLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS93ZWItc3RyZWFtcy1wb2x5ZmlsbEAzLjIuMS9ub2RlX21vZHVsZXMvd2ViLXN0cmVhbXMtcG9seWZpbGwvc3JjL2xpYi9yZWFkYWJsZS1zdHJlYW0vcGlwZS50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vd2ViLXN0cmVhbXMtcG9seWZpbGxAMy4yLjEvbm9kZV9tb2R1bGVzL3dlYi1zdHJlYW1zLXBvbHlmaWxsL3NyYy9saWIvcmVhZGFibGUtc3RyZWFtL2RlZmF1bHQtY29udHJvbGxlci50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vd2ViLXN0cmVhbXMtcG9seWZpbGxAMy4yLjEvbm9kZV9tb2R1bGVzL3dlYi1zdHJlYW1zLXBvbHlmaWxsL3NyYy9saWIvcmVhZGFibGUtc3RyZWFtL3RlZS50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vd2ViLXN0cmVhbXMtcG9seWZpbGxAMy4yLjEvbm9kZV9tb2R1bGVzL3dlYi1zdHJlYW1zLXBvbHlmaWxsL3NyYy9saWIvdmFsaWRhdG9ycy91bmRlcmx5aW5nLXNvdXJjZS50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vd2ViLXN0cmVhbXMtcG9seWZpbGxAMy4yLjEvbm9kZV9tb2R1bGVzL3dlYi1zdHJlYW1zLXBvbHlmaWxsL3NyYy9saWIvdmFsaWRhdG9ycy9yZWFkZXItb3B0aW9ucy50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vd2ViLXN0cmVhbXMtcG9seWZpbGxAMy4yLjEvbm9kZV9tb2R1bGVzL3dlYi1zdHJlYW1zLXBvbHlmaWxsL3NyYy9saWIvdmFsaWRhdG9ycy9pdGVyYXRvci1vcHRpb25zLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS93ZWItc3RyZWFtcy1wb2x5ZmlsbEAzLjIuMS9ub2RlX21vZHVsZXMvd2ViLXN0cmVhbXMtcG9seWZpbGwvc3JjL2xpYi92YWxpZGF0b3JzL3BpcGUtb3B0aW9ucy50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vd2ViLXN0cmVhbXMtcG9seWZpbGxAMy4yLjEvbm9kZV9tb2R1bGVzL3dlYi1zdHJlYW1zLXBvbHlmaWxsL3NyYy9saWIvdmFsaWRhdG9ycy9yZWFkYWJsZS13cml0YWJsZS1wYWlyLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS93ZWItc3RyZWFtcy1wb2x5ZmlsbEAzLjIuMS9ub2RlX21vZHVsZXMvd2ViLXN0cmVhbXMtcG9seWZpbGwvc3JjL2xpYi9yZWFkYWJsZS1zdHJlYW0udHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3dlYi1zdHJlYW1zLXBvbHlmaWxsQDMuMi4xL25vZGVfbW9kdWxlcy93ZWItc3RyZWFtcy1wb2x5ZmlsbC9zcmMvbGliL3ZhbGlkYXRvcnMvcXVldWluZy1zdHJhdGVneS1pbml0LnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS93ZWItc3RyZWFtcy1wb2x5ZmlsbEAzLjIuMS9ub2RlX21vZHVsZXMvd2ViLXN0cmVhbXMtcG9seWZpbGwvc3JjL2xpYi9ieXRlLWxlbmd0aC1xdWV1aW5nLXN0cmF0ZWd5LnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS93ZWItc3RyZWFtcy1wb2x5ZmlsbEAzLjIuMS9ub2RlX21vZHVsZXMvd2ViLXN0cmVhbXMtcG9seWZpbGwvc3JjL2xpYi9jb3VudC1xdWV1aW5nLXN0cmF0ZWd5LnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS93ZWItc3RyZWFtcy1wb2x5ZmlsbEAzLjIuMS9ub2RlX21vZHVsZXMvd2ViLXN0cmVhbXMtcG9seWZpbGwvc3JjL2xpYi92YWxpZGF0b3JzL3RyYW5zZm9ybWVyLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS93ZWItc3RyZWFtcy1wb2x5ZmlsbEAzLjIuMS9ub2RlX21vZHVsZXMvd2ViLXN0cmVhbXMtcG9seWZpbGwvc3JjL2xpYi90cmFuc2Zvcm0tc3RyZWFtLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ad2ViLXN0ZCtzdHJlYW1AMS4wLjAvbm9kZV9tb2R1bGVzL0B3ZWItc3RkL3N0cmVhbS9zcmMvc3RyZWFtLmNqcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZXZlbnQtdGFyZ2V0LXNoaW1ANS4wLjEvbm9kZV9tb2R1bGVzL2V2ZW50LXRhcmdldC1zaGltL3NyYy9ldmVudC5tanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2V2ZW50LXRhcmdldC1zaGltQDUuMC4xL25vZGVfbW9kdWxlcy9ldmVudC10YXJnZXQtc2hpbS9zcmMvZXZlbnQtdGFyZ2V0Lm1qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vYWJvcnQtY29udHJvbGxlckAzLjAuMC9ub2RlX21vZHVsZXMvYWJvcnQtY29udHJvbGxlci9zcmMvYWJvcnQtc2lnbmFsLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9hYm9ydC1jb250cm9sbGVyQDMuMC4wL25vZGVfbW9kdWxlcy9hYm9ydC1jb250cm9sbGVyL3NyYy9hYm9ydC1jb250cm9sbGVyLnRzIiwgIi4uL3NyYy9pbmRleC50cyIsICIuLi9zcmMvbWV0YXBsZXgvYnVybi50cyIsICIuLi8uLi9pbnRlcm5hbC9zaGFyZWQtbWV0YXBsZXgvc3JjL2NvbnZlcnQvY29sbGVjdGlvbi50cyIsICIuLi8uLi9pbnRlcm5hbC9zaGFyZWQtbWV0YXBsZXgvc3JjL2NvbnZlcnQvY3JlYXRvcnMudHMiLCAiLi4vLi4vaW50ZXJuYWwvc2hhcmVkLW1ldGFwbGV4L3NyYy9jb252ZXJ0L3VzZXMudHMiLCAiLi4vLi4vaW50ZXJuYWwvc2hhcmVkLW1ldGFwbGV4L3NyYy9jb252ZXJ0L3Rva2VuLW1ldGFkYXRhLnRzIiwgIi4uLy4uL2ludGVybmFsL3NoYXJlZC1tZXRhcGxleC9zcmMvY29udmVydC9uZnQtbWV0YWRhdGEudHMiLCAiLi4vLi4vaW50ZXJuYWwvc2hhcmVkLW1ldGFwbGV4L3NyYy9jb252ZXJ0L3Byb3BlcnRpZXMudHMiLCAiLi4vLi4vaW50ZXJuYWwvc2hhcmVkLW1ldGFwbGV4L3NyYy9jb252ZXJ0L2luZGV4LnRzIiwgIi4uLy4uL2ludGVybmFsL3NoYXJlZC1tZXRhcGxleC9zcmMvdHlwZXMvdXNlci1zaWRlL2lucHV0LnRzIiwgIi4uLy4uL2ludGVybmFsL3NoYXJlZC1tZXRhcGxleC9zcmMvdHlwZXMvc2hhcmVkLnRzIiwgIi4uLy4uL2ludGVybmFsL3NoYXJlZC1tZXRhcGxleC9zcmMvcGRhLnRzIiwgIi4uLy4uL2ludGVybmFsL3NoYXJlZC1tZXRhcGxleC9zcmMvdmFsaWRhdG9yLnRzIiwgIi4uLy4uL2ludGVybmFsL3NoYXJlZC1tZXRhcGxleC9zcmMvcm95YWx0eS50cyIsICIuLi9zcmMvbWV0YXBsZXgvZmluZC50cyIsICIuLi9zcmMvbWV0YXBsZXgvZnJlZXplLnRzIiwgIi4uL3NyYy9tZXRhcGxleC9mZWUtcGF5ZXItcGFydGlhbC1zaWduLW1pbnQudHMiLCAiLi4vLi4vaW50ZXJuYWwvc3RvcmFnZS9zcmMvYXJ3ZWF2ZS50cyIsICIuLi8uLi9pbnRlcm5hbC9zdG9yYWdlL3NyYy9idW5kbHIudHMiLCAiLi4vLi4vaW50ZXJuYWwvc3RvcmFnZS9zcmMvbmZ0LXN0b3JhZ2UudHMiLCAiLi4vLi4vaW50ZXJuYWwvc3RvcmFnZS9zcmMvc3RvcmFnZS50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vc3RyZWFtaW5nLWl0ZXJhYmxlc0A2LjIuMC9ub2RlX21vZHVsZXMvc3RyZWFtaW5nLWl0ZXJhYmxlcy9kaXN0L2luZGV4Lm1qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbmZ0LnN0b3JhZ2VANy4xLjFfbm9kZS1mZXRjaEAzLjMuMi9ub2RlX21vZHVsZXMvbmZ0LnN0b3JhZ2Uvc3JjL2xpYi5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQGlwbGQrY2FyQDMuMi40L25vZGVfbW9kdWxlcy9AaXBsZC9jYXIvZXNtL2xpYi9yZWFkZXIuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BpcGxkK2NhckAzLjIuNC9ub2RlX21vZHVsZXMvQGlwbGQvY2FyL2VzbS9saWIvZGVjb2Rlci5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbXVsdGlmb3JtYXRzQDkuOS4wL25vZGVfbW9kdWxlcy9tdWx0aWZvcm1hdHMvZXNtL3ZlbmRvci92YXJpbnQuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL211bHRpZm9ybWF0c0A5LjkuMC9ub2RlX21vZHVsZXMvbXVsdGlmb3JtYXRzL2VzbS9zcmMvdmFyaW50LmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9tdWx0aWZvcm1hdHNAOS45LjAvbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9lc20vc3JjL2J5dGVzLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9tdWx0aWZvcm1hdHNAOS45LjAvbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9lc20vc3JjL2hhc2hlcy9kaWdlc3QuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL211bHRpZm9ybWF0c0A5LjkuMC9ub2RlX21vZHVsZXMvbXVsdGlmb3JtYXRzL2VzbS9zcmMvYmFzZXMvYmFzZTU4LmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9tdWx0aWZvcm1hdHNAOS45LjAvbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9lc20vdmVuZG9yL2Jhc2UteC5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbXVsdGlmb3JtYXRzQDkuOS4wL25vZGVfbW9kdWxlcy9tdWx0aWZvcm1hdHMvZXNtL3NyYy9iYXNlcy9iYXNlLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9tdWx0aWZvcm1hdHNAOS45LjAvbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9lc20vc3JjL2Jhc2VzL2Jhc2UzMi5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbXVsdGlmb3JtYXRzQDkuOS4wL25vZGVfbW9kdWxlcy9tdWx0aWZvcm1hdHMvZXNtL3NyYy9jaWQuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2Nib3JnQDEuMTAuMi9ub2RlX21vZHVsZXMvY2JvcmcvZXNtL2xpYi9pcy5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vY2JvcmdAMS4xMC4yL25vZGVfbW9kdWxlcy9jYm9yZy9lc20vbGliL3Rva2VuLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9jYm9yZ0AxLjEwLjIvbm9kZV9tb2R1bGVzL2Nib3JnL2VzbS9saWIvYnl0ZS11dGlscy5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vY2JvcmdAMS4xMC4yL25vZGVfbW9kdWxlcy9jYm9yZy9lc20vbGliL2JsLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9jYm9yZ0AxLjEwLjIvbm9kZV9tb2R1bGVzL2Nib3JnL2VzbS9saWIvY29tbW9uLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9jYm9yZ0AxLjEwLjIvbm9kZV9tb2R1bGVzL2Nib3JnL2VzbS9saWIvMHVpbnQuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2Nib3JnQDEuMTAuMi9ub2RlX21vZHVsZXMvY2JvcmcvZXNtL2xpYi8xbmVnaW50LmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9jYm9yZ0AxLjEwLjIvbm9kZV9tb2R1bGVzL2Nib3JnL2VzbS9saWIvMmJ5dGVzLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9jYm9yZ0AxLjEwLjIvbm9kZV9tb2R1bGVzL2Nib3JnL2VzbS9saWIvM3N0cmluZy5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vY2JvcmdAMS4xMC4yL25vZGVfbW9kdWxlcy9jYm9yZy9lc20vbGliLzRhcnJheS5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vY2JvcmdAMS4xMC4yL25vZGVfbW9kdWxlcy9jYm9yZy9lc20vbGliLzVtYXAuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2Nib3JnQDEuMTAuMi9ub2RlX21vZHVsZXMvY2JvcmcvZXNtL2xpYi82dGFnLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9jYm9yZ0AxLjEwLjIvbm9kZV9tb2R1bGVzL2Nib3JnL2VzbS9saWIvN2Zsb2F0LmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9jYm9yZ0AxLjEwLjIvbm9kZV9tb2R1bGVzL2Nib3JnL2VzbS9saWIvanVtcC5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vY2JvcmdAMS4xMC4yL25vZGVfbW9kdWxlcy9jYm9yZy9lc20vbGliL2VuY29kZS5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vY2JvcmdAMS4xMC4yL25vZGVfbW9kdWxlcy9jYm9yZy9lc20vbGliL2RlY29kZS5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQGlwbGQrZGFnLWNib3JANy4wLjMvbm9kZV9tb2R1bGVzL0BpcGxkL2RhZy1jYm9yL2VzbS9pbmRleC5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQGlwbGQrY2FyQDMuMi40L25vZGVfbW9kdWxlcy9AaXBsZC9jYXIvZXNtL2xpYi9yZWFkZXItYnJvd3Nlci5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQGlwbGQrY2FyQDMuMi40L25vZGVfbW9kdWxlcy9AaXBsZC9jYXIvZXNtL2xpYi9pbmRleGVyLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AaXBsZCtjYXJAMy4yLjQvbm9kZV9tb2R1bGVzL0BpcGxkL2Nhci9lc20vbGliL2l0ZXJhdG9yLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AaXBsZCtjYXJAMy4yLjQvbm9kZV9tb2R1bGVzL0BpcGxkL2Nhci9lc20vbGliL3dyaXRlci5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQGlwbGQrY2FyQDMuMi40L25vZGVfbW9kdWxlcy9AaXBsZC9jYXIvZXNtL2xpYi9lbmNvZGVyLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AaXBsZCtjYXJAMy4yLjQvbm9kZV9tb2R1bGVzL0BpcGxkL2Nhci9lc20vbGliL2l0ZXJhdG9yLWNoYW5uZWwuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BpcGxkK2NhckAzLjIuNC9ub2RlX21vZHVsZXMvQGlwbGQvY2FyL2VzbS9saWIvd3JpdGVyLWJyb3dzZXIuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL211bHRpZm9ybWF0c0A5LjkuMC9ub2RlX21vZHVsZXMvbXVsdGlmb3JtYXRzL2VzbS9zcmMvaGFzaGVzL2hhc2hlci5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbXVsdGlmb3JtYXRzQDkuOS4wL25vZGVfbW9kdWxlcy9tdWx0aWZvcm1hdHMvZXNtL3NyYy9ibG9jay5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbXVsdGlmb3JtYXRzQDkuOS4wL25vZGVfbW9kdWxlcy9tdWx0aWZvcm1hdHMvZXNtL3NyYy9jb2RlY3MvcmF3LmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AaXBsZCtkYWctY2JvckA2LjAuMTUvbm9kZV9tb2R1bGVzL0BpcGxkL2RhZy1jYm9yL2VzbS9pbmRleC5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQGlwbGQrZGFnLXBiQDIuMS4xOC9ub2RlX21vZHVsZXMvQGlwbGQvZGFnLXBiL2VzbS9zcmMvaW5kZXguanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BpcGxkK2RhZy1wYkAyLjEuMTgvbm9kZV9tb2R1bGVzL0BpcGxkL2RhZy1wYi9lc20vc3JjL3BiLWRlY29kZS5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQGlwbGQrZGFnLXBiQDIuMS4xOC9ub2RlX21vZHVsZXMvQGlwbGQvZGFnLXBiL2VzbS9zcmMvcGItZW5jb2RlLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AaXBsZCtkYWctcGJAMi4xLjE4L25vZGVfbW9kdWxlcy9AaXBsZC9kYWctcGIvZXNtL3NyYy91dGlsLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9jYXJiaXRlc0AxLjAuNi9ub2RlX21vZHVsZXMvY2FyYml0ZXMvZXNtL2xpYi90cmVld2Fsay9zcGxpdHRlci5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vaXBmcy1jYXJAMC42LjJfbm9kZS1mZXRjaEAzLjMuMi9ub2RlX21vZHVsZXMvaXBmcy1jYXIvZGlzdC9lc20vcGFjay9pbmRleC5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vaXBmcy11bml4ZnMtaW1wb3J0ZXJAOS4wLjEwL25vZGVfbW9kdWxlcy9pcGZzLXVuaXhmcy1pbXBvcnRlci9lc20vc3JjL2luZGV4LmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9tZXJnZS1vcHRpb25zQDMuMC40L25vZGVfbW9kdWxlcy9tZXJnZS1vcHRpb25zL2luZGV4Lm1qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbXVsdGlmb3JtYXRzQDkuOS4wL25vZGVfbW9kdWxlcy9tdWx0aWZvcm1hdHMvZXNtL3NyYy9oYXNoZXMvc2hhMi5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG11bHRpZm9ybWF0cyttdXJtdXIzQDEuMS4zL25vZGVfbW9kdWxlcy9AbXVsdGlmb3JtYXRzL211cm11cjMvZXNtL2luZGV4LmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9pcGZzLXVuaXhmcy1pbXBvcnRlckA5LjAuMTAvbm9kZV9tb2R1bGVzL2lwZnMtdW5peGZzLWltcG9ydGVyL2VzbS9zcmMvb3B0aW9ucy5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vaXBmcy11bml4ZnNANi4wLjkvbm9kZV9tb2R1bGVzL2lwZnMtdW5peGZzL2VzbS9zcmMvaW5kZXguanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2lwZnMtdW5peGZzQDYuMC45L25vZGVfbW9kdWxlcy9pcGZzLXVuaXhmcy9lc20vc3JjL3VuaXhmcy5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vaXBmcy11bml4ZnMtaW1wb3J0ZXJAOS4wLjEwL25vZGVfbW9kdWxlcy9pcGZzLXVuaXhmcy1pbXBvcnRlci9lc20vc3JjL3V0aWxzL3BlcnNpc3QuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2lwZnMtdW5peGZzLWltcG9ydGVyQDkuMC4xMC9ub2RlX21vZHVsZXMvaXBmcy11bml4ZnMtaW1wb3J0ZXIvZXNtL3NyYy9kYWctYnVpbGRlci9kaXIuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2lwZnMtdW5peGZzLWltcG9ydGVyQDkuMC4xMC9ub2RlX21vZHVsZXMvaXBmcy11bml4ZnMtaW1wb3J0ZXIvZXNtL3NyYy9kYWctYnVpbGRlci9maWxlL2luZGV4LmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9pcGZzLXVuaXhmcy1pbXBvcnRlckA5LjAuMTAvbm9kZV9tb2R1bGVzL2lwZnMtdW5peGZzLWltcG9ydGVyL2VzbS9zcmMvZGFnLWJ1aWxkZXIvZmlsZS9mbGF0LmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9pcGZzLXVuaXhmcy1pbXBvcnRlckA5LjAuMTAvbm9kZV9tb2R1bGVzL2lwZnMtdW5peGZzLWltcG9ydGVyL2VzbS9zcmMvZGFnLWJ1aWxkZXIvZmlsZS9iYWxhbmNlZC5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vaXBmcy11bml4ZnMtaW1wb3J0ZXJAOS4wLjEwL25vZGVfbW9kdWxlcy9pcGZzLXVuaXhmcy1pbXBvcnRlci9lc20vc3JjL2RhZy1idWlsZGVyL2ZpbGUvdHJpY2tsZS5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vaXBmcy11bml4ZnMtaW1wb3J0ZXJAOS4wLjEwL25vZGVfbW9kdWxlcy9pcGZzLXVuaXhmcy1pbXBvcnRlci9lc20vc3JjL2RhZy1idWlsZGVyL2ZpbGUvYnVmZmVyLWltcG9ydGVyLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9pcGZzLXVuaXhmcy1pbXBvcnRlckA5LjAuMTAvbm9kZV9tb2R1bGVzL2lwZnMtdW5peGZzLWltcG9ydGVyL2VzbS9zcmMvZGFnLWJ1aWxkZXIvaW5kZXguanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2lwZnMtdW5peGZzLWltcG9ydGVyQDkuMC4xMC9ub2RlX21vZHVsZXMvaXBmcy11bml4ZnMtaW1wb3J0ZXIvZXNtL3NyYy9jaHVua2VyL3JhYmluLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9pcGZzLXVuaXhmcy1pbXBvcnRlckA5LjAuMTAvbm9kZV9tb2R1bGVzL2lwZnMtdW5peGZzLWltcG9ydGVyL2VzbS9zcmMvY2h1bmtlci9maXhlZC1zaXplLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9pcGZzLXVuaXhmcy1pbXBvcnRlckA5LjAuMTAvbm9kZV9tb2R1bGVzL2lwZnMtdW5peGZzLWltcG9ydGVyL2VzbS9zcmMvZGFnLWJ1aWxkZXIvdmFsaWRhdGUtY2h1bmtzLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9tdWx0aWZvcm1hdHNAOS45LjAvbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9lc20vc3JjL2Jhc2VzL2lkZW50aXR5LmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9tdWx0aWZvcm1hdHNAOS45LjAvbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9lc20vc3JjL2Jhc2VzL2Jhc2UyLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9tdWx0aWZvcm1hdHNAOS45LjAvbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9lc20vc3JjL2Jhc2VzL2Jhc2U4LmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9tdWx0aWZvcm1hdHNAOS45LjAvbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9lc20vc3JjL2Jhc2VzL2Jhc2UxMC5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbXVsdGlmb3JtYXRzQDkuOS4wL25vZGVfbW9kdWxlcy9tdWx0aWZvcm1hdHMvZXNtL3NyYy9iYXNlcy9iYXNlMTYuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL211bHRpZm9ybWF0c0A5LjkuMC9ub2RlX21vZHVsZXMvbXVsdGlmb3JtYXRzL2VzbS9zcmMvYmFzZXMvYmFzZTM2LmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9tdWx0aWZvcm1hdHNAOS45LjAvbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9lc20vc3JjL2Jhc2VzL2Jhc2U2NC5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbXVsdGlmb3JtYXRzQDkuOS4wL25vZGVfbW9kdWxlcy9tdWx0aWZvcm1hdHMvZXNtL3NyYy9iYXNlcy9iYXNlMjU2ZW1vamkuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL211bHRpZm9ybWF0c0A5LjkuMC9ub2RlX21vZHVsZXMvbXVsdGlmb3JtYXRzL2VzbS9zcmMvaGFzaGVzL2lkZW50aXR5LmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9tdWx0aWZvcm1hdHNAOS45LjAvbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9lc20vc3JjL2NvZGVjcy9qc29uLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9tdWx0aWZvcm1hdHNAOS45LjAvbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9lc20vc3JjL2Jhc2ljcy5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vdWludDhhcnJheXNAMy4xLjEvbm9kZV9tb2R1bGVzL3VpbnQ4YXJyYXlzL2VzbS9zcmMvdXRpbC9hcy11aW50OGFycmF5LmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS91aW50OGFycmF5c0AzLjEuMS9ub2RlX21vZHVsZXMvdWludDhhcnJheXMvZXNtL3NyYy9hbGxvYy5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vdWludDhhcnJheXNAMy4xLjEvbm9kZV9tb2R1bGVzL3VpbnQ4YXJyYXlzL2VzbS9zcmMvdXRpbC9iYXNlcy5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vdWludDhhcnJheXNAMy4xLjEvbm9kZV9tb2R1bGVzL3VpbnQ4YXJyYXlzL2VzbS9zcmMvZnJvbS1zdHJpbmcuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2lwZnMtdW5peGZzLWltcG9ydGVyQDkuMC4xMC9ub2RlX21vZHVsZXMvaXBmcy11bml4ZnMtaW1wb3J0ZXIvZXNtL3NyYy9kaXIuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2lwZnMtdW5peGZzLWltcG9ydGVyQDkuMC4xMC9ub2RlX21vZHVsZXMvaXBmcy11bml4ZnMtaW1wb3J0ZXIvZXNtL3NyYy9kaXItZmxhdC5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vaXBmcy11bml4ZnMtaW1wb3J0ZXJAOS4wLjEwL25vZGVfbW9kdWxlcy9pcGZzLXVuaXhmcy1pbXBvcnRlci9lc20vc3JjL2Rpci1zaGFyZGVkLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9pcGZzLXVuaXhmcy1pbXBvcnRlckA5LjAuMTAvbm9kZV9tb2R1bGVzL2lwZnMtdW5peGZzLWltcG9ydGVyL2VzbS9zcmMvZmxhdC10by1zaGFyZC5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vaXBmcy11bml4ZnMtaW1wb3J0ZXJAOS4wLjEwL25vZGVfbW9kdWxlcy9pcGZzLXVuaXhmcy1pbXBvcnRlci9lc20vc3JjL3V0aWxzL3RvLXBhdGgtY29tcG9uZW50cy5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vaXBmcy11bml4ZnMtaW1wb3J0ZXJAOS4wLjEwL25vZGVfbW9kdWxlcy9pcGZzLXVuaXhmcy1pbXBvcnRlci9lc20vc3JjL3RyZWUtYnVpbGRlci5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vaXBmcy1jb3JlLXV0aWxzQDAuMTIuMl9ub2RlLWZldGNoQDMuMy4yL25vZGVfbW9kdWxlcy9pcGZzLWNvcmUtdXRpbHMvZXNtL3NyYy9maWxlcy9ub3JtYWxpc2UtY29udGVudC5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vaXBmcy1jb3JlLXV0aWxzQDAuMTIuMl9ub2RlLWZldGNoQDMuMy4yL25vZGVfbW9kdWxlcy9pcGZzLWNvcmUtdXRpbHMvZXNtL3NyYy9maWxlcy91dGlscy5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vaXBmcy1jb3JlLXV0aWxzQDAuMTIuMl9ub2RlLWZldGNoQDMuMy4yL25vZGVfbW9kdWxlcy9pcGZzLWNvcmUtdXRpbHMvZXNtL3NyYy9maWxlcy9ub3JtYWxpc2UtY2FuZGlkYXRlLXNpbmdsZS5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vaXBmcy1jb3JlLXV0aWxzQDAuMTIuMl9ub2RlLWZldGNoQDMuMy4yL25vZGVfbW9kdWxlcy9pcGZzLWNvcmUtdXRpbHMvZXNtL3NyYy9maWxlcy9ub3JtYWxpc2UtaW5wdXQtc2luZ2xlLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9pcGZzLWNvcmUtdXRpbHNAMC4xMi4yX25vZGUtZmV0Y2hAMy4zLjIvbm9kZV9tb2R1bGVzL2lwZnMtY29yZS11dGlscy9lc20vc3JjL2ZpbGVzL25vcm1hbGlzZS1jYW5kaWRhdGUtbXVsdGlwbGUuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2lwZnMtY29yZS11dGlsc0AwLjEyLjJfbm9kZS1mZXRjaEAzLjMuMi9ub2RlX21vZHVsZXMvaXBmcy1jb3JlLXV0aWxzL2VzbS9zcmMvZmlsZXMvbm9ybWFsaXNlLWlucHV0LW11bHRpcGxlLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9pcGZzLWNhckAwLjYuMl9ub2RlLWZldGNoQDMuMy4yL25vZGVfbW9kdWxlcy9pcGZzLWNhci9kaXN0L2VzbS9wYWNrL3V0aWxzL25vcm1hbGlzZS1pbnB1dC5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vYmxvY2tzdG9yZS1jb3JlQDEuMC41L25vZGVfbW9kdWxlcy9ibG9ja3N0b3JlLWNvcmUvZXNtL3NyYy9lcnJvcnMuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2Jsb2Nrc3RvcmUtY29yZUAxLjAuNS9ub2RlX21vZHVsZXMvYmxvY2tzdG9yZS1jb3JlL2VzbS9zcmMvYmFzZS5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vYmxvY2tzdG9yZS1jb3JlQDEuMC41L25vZGVfbW9kdWxlcy9ibG9ja3N0b3JlLWNvcmUvZXNtL3NyYy9pbmRleC5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vaXBmcy1jYXJAMC42LjJfbm9kZS1mZXRjaEAzLjMuMi9ub2RlX21vZHVsZXMvaXBmcy1jYXIvZGlzdC9lc20vYmxvY2tzdG9yZS9tZW1vcnkuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2lwZnMtY2FyQDAuNi4yX25vZGUtZmV0Y2hAMy4zLjIvbm9kZV9tb2R1bGVzL2lwZnMtY2FyL2Rpc3QvZXNtL3BhY2svY29uc3RhbnRzLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ad2ViLXN0ZCtmZXRjaEA0LjIuMS9ub2RlX21vZHVsZXMvQHdlYi1zdGQvZmV0Y2gvc3JjL2ZldGNoLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9tcm1pbWVAMS4wLjEvbm9kZV9tb2R1bGVzL21ybWltZS9pbmRleC5tanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0B3ZWItc3RkK2ZldGNoQDQuMi4xL25vZGVfbW9kdWxlcy9Ad2ViLXN0ZC9mZXRjaC9zcmMvYm9keS5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vd2ViLWVuY29kaW5nQDEuMS41L25vZGVfbW9kdWxlcy93ZWItZW5jb2Rpbmcvc3JjL2xpYi5tanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0B3ZWItc3RkK3N0cmVhbUAxLjAuMC9ub2RlX21vZHVsZXMvQHdlYi1zdGQvc3RyZWFtL3NyYy9saWIubm9kZS5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHdlYi1zdGQrYmxvYkAzLjAuNS9ub2RlX21vZHVsZXMvQHdlYi1zdGQvYmxvYi9zcmMvYmxvYi5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHdlYi1zdGQrYmxvYkAzLjAuNS9ub2RlX21vZHVsZXMvQHdlYi1zdGQvYmxvYi9zcmMvbGliLm5vZGUuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0B3ZWItc3RkK2ZpbGVAMy4wLjMvbm9kZV9tb2R1bGVzL0B3ZWItc3RkL2ZpbGUvc3JjL2ZpbGUuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0B3ZWItc3RkK2ZpbGVAMy4wLjMvbm9kZV9tb2R1bGVzL0B3ZWItc3RkL2ZpbGUvc3JjL2xpYi5ub2RlLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ad2ViLXN0ZCtmb3JtLWRhdGFAMy4xLjAvbm9kZV9tb2R1bGVzL0B3ZWItc3RkL2Zvcm0tZGF0YS9zcmMvZm9ybS1kYXRhLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ad2ViLXN0ZCtmb3JtLWRhdGFAMy4xLjAvbm9kZV9tb2R1bGVzL0B3ZWItc3RkL2Zvcm0tZGF0YS9zcmMvbGliLm5vZGUuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0B3ZWItc3RkK2ZldGNoQDQuMi4xL25vZGVfbW9kdWxlcy9Ad2ViLXN0ZC9mZXRjaC9zcmMvZXJyb3JzL2Jhc2UuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0B3ZWItc3RkK2ZldGNoQDQuMi4xL25vZGVfbW9kdWxlcy9Ad2ViLXN0ZC9mZXRjaC9zcmMvZXJyb3JzL2ZldGNoLWVycm9yLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ad2ViLXN0ZCtmZXRjaEA0LjIuMS9ub2RlX21vZHVsZXMvQHdlYi1zdGQvZmV0Y2gvc3JjL3V0aWxzL2Zvcm0tZGF0YS5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHdlYjMtc3RvcmFnZSttdWx0aXBhcnQtcGFyc2VyQDEuMC4wL25vZGVfbW9kdWxlcy9Ad2ViMy1zdG9yYWdlL211bHRpcGFydC1wYXJzZXIvZXNtL3NyYy91dGlscy5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHdlYjMtc3RvcmFnZSttdWx0aXBhcnQtcGFyc2VyQDEuMC4wL25vZGVfbW9kdWxlcy9Ad2ViMy1zdG9yYWdlL211bHRpcGFydC1wYXJzZXIvZXNtL3NyYy9zZWFyY2guanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0B3ZWIzLXN0b3JhZ2UrbXVsdGlwYXJ0LXBhcnNlckAxLjAuMC9ub2RlX21vZHVsZXMvQHdlYjMtc3RvcmFnZS9tdWx0aXBhcnQtcGFyc2VyL2VzbS9zcmMvaW5kZXguanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0B3ZWItc3RkK2ZldGNoQDQuMi4xL25vZGVfbW9kdWxlcy9Ad2ViLXN0ZC9mZXRjaC9zcmMvdXRpbHMvaXMuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0B3ZWItc3RkK2ZldGNoQDQuMi4xL25vZGVfbW9kdWxlcy9Ad2ViLXN0ZC9mZXRjaC9zcmMvdXRpbHMvdXRmOC5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHdlYi1zdGQrZmV0Y2hANC4yLjEvbm9kZV9tb2R1bGVzL0B3ZWItc3RkL2ZldGNoL3NyYy9oZWFkZXJzLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ad2ViLXN0ZCtmZXRjaEA0LjIuMS9ub2RlX21vZHVsZXMvQHdlYi1zdGQvZmV0Y2gvc3JjL3V0aWxzL2lzLXJlZGlyZWN0LmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ad2ViLXN0ZCtmZXRjaEA0LjIuMS9ub2RlX21vZHVsZXMvQHdlYi1zdGQvZmV0Y2gvc3JjL3Jlc3BvbnNlLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ad2ViLXN0ZCtmZXRjaEA0LjIuMS9ub2RlX21vZHVsZXMvQHdlYi1zdGQvZmV0Y2gvc3JjL3JlcXVlc3QuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0B3ZWItc3RkK2ZldGNoQDQuMi4xL25vZGVfbW9kdWxlcy9Ad2ViLXN0ZC9mZXRjaC9zcmMvdXRpbHMvZ2V0LXNlYXJjaC5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHdlYi1zdGQrZmV0Y2hANC4yLjEvbm9kZV9tb2R1bGVzL0B3ZWItc3RkL2ZldGNoL3NyYy9lcnJvcnMvYWJvcnQtZXJyb3IuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0B3ZWItc3RkK2ZldGNoQDQuMi4xL25vZGVfbW9kdWxlcy9Ad2ViLXN0ZC9mZXRjaC9zcmMvbGliLm5vZGUuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2lwZnMtY2FyQDAuNi4yX25vZGUtZmV0Y2hAMy4zLjIvbm9kZV9tb2R1bGVzL2lwZnMtY2FyL2Rpc3QvZXNtL2Jsb2Nrc3RvcmUvZnMuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL25mdC5zdG9yYWdlQDcuMS4xX25vZGUtZmV0Y2hAMy4zLjIvbm9kZV9tb2R1bGVzL25mdC5zdG9yYWdlL3NyYy9nYXRld2F5LmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9uZnQuc3RvcmFnZUA3LjEuMV9ub2RlLWZldGNoQDMuMy4yL25vZGVfbW9kdWxlcy9uZnQuc3RvcmFnZS9zcmMvYnMtY2FyLXJlYWRlci5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbmZ0LnN0b3JhZ2VANy4xLjFfbm9kZS1mZXRjaEAzLjMuMi9ub2RlX21vZHVsZXMvbmZ0LnN0b3JhZ2Uvc3JjL3Rva2VuLmpzIiwgIi4uL3NyYy9tZXRhcGxleC9taW50LnRzIiwgIi4uL3NyYy9tZXRhcGxleC9mZWUtcGF5ZXItcGFydGlhbC1zaWduLXRyYW5zZmVyLnRzIiwgIi4uL3NyYy9tZXRhcGxleC90aGF3LnRzIiwgIi4uL3NyYy9tZXRhcGxleC90cmFuc2Zlci50cyIsICIuLi9zcmMvbWV0YXBsZXgvaW5kZXgudHMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbImZ1bmN0aW9uIFJldHJ5T3BlcmF0aW9uKHRpbWVvdXRzLCBvcHRpb25zKSB7XG4gIC8vIENvbXBhdGliaWxpdHkgZm9yIHRoZSBvbGQgKHRpbWVvdXRzLCByZXRyeUZvcmV2ZXIpIHNpZ25hdHVyZVxuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdib29sZWFuJykge1xuICAgIG9wdGlvbnMgPSB7IGZvcmV2ZXI6IG9wdGlvbnMgfTtcbiAgfVxuXG4gIHRoaXMuX29yaWdpbmFsVGltZW91dHMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHRpbWVvdXRzKSk7XG4gIHRoaXMuX3RpbWVvdXRzID0gdGltZW91dHM7XG4gIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB0aGlzLl9tYXhSZXRyeVRpbWUgPSBvcHRpb25zICYmIG9wdGlvbnMubWF4UmV0cnlUaW1lIHx8IEluZmluaXR5O1xuICB0aGlzLl9mbiA9IG51bGw7XG4gIHRoaXMuX2Vycm9ycyA9IFtdO1xuICB0aGlzLl9hdHRlbXB0cyA9IDE7XG4gIHRoaXMuX29wZXJhdGlvblRpbWVvdXQgPSBudWxsO1xuICB0aGlzLl9vcGVyYXRpb25UaW1lb3V0Q2IgPSBudWxsO1xuICB0aGlzLl90aW1lb3V0ID0gbnVsbDtcbiAgdGhpcy5fb3BlcmF0aW9uU3RhcnQgPSBudWxsO1xuICB0aGlzLl90aW1lciA9IG51bGw7XG5cbiAgaWYgKHRoaXMuX29wdGlvbnMuZm9yZXZlcikge1xuICAgIHRoaXMuX2NhY2hlZFRpbWVvdXRzID0gdGhpcy5fdGltZW91dHMuc2xpY2UoMCk7XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gUmV0cnlPcGVyYXRpb247XG5cblJldHJ5T3BlcmF0aW9uLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9hdHRlbXB0cyA9IDE7XG4gIHRoaXMuX3RpbWVvdXRzID0gdGhpcy5fb3JpZ2luYWxUaW1lb3V0cy5zbGljZSgwKTtcbn1cblxuUmV0cnlPcGVyYXRpb24ucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuX3RpbWVvdXQpIHtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZW91dCk7XG4gIH1cbiAgaWYgKHRoaXMuX3RpbWVyKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVyKTtcbiAgfVxuXG4gIHRoaXMuX3RpbWVvdXRzICAgICAgID0gW107XG4gIHRoaXMuX2NhY2hlZFRpbWVvdXRzID0gbnVsbDtcbn07XG5cblJldHJ5T3BlcmF0aW9uLnByb3RvdHlwZS5yZXRyeSA9IGZ1bmN0aW9uKGVycikge1xuICBpZiAodGhpcy5fdGltZW91dCkge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lb3V0KTtcbiAgfVxuXG4gIGlmICghZXJyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBjdXJyZW50VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICBpZiAoZXJyICYmIGN1cnJlbnRUaW1lIC0gdGhpcy5fb3BlcmF0aW9uU3RhcnQgPj0gdGhpcy5fbWF4UmV0cnlUaW1lKSB7XG4gICAgdGhpcy5fZXJyb3JzLnB1c2goZXJyKTtcbiAgICB0aGlzLl9lcnJvcnMudW5zaGlmdChuZXcgRXJyb3IoJ1JldHJ5T3BlcmF0aW9uIHRpbWVvdXQgb2NjdXJyZWQnKSk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdGhpcy5fZXJyb3JzLnB1c2goZXJyKTtcblxuICB2YXIgdGltZW91dCA9IHRoaXMuX3RpbWVvdXRzLnNoaWZ0KCk7XG4gIGlmICh0aW1lb3V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodGhpcy5fY2FjaGVkVGltZW91dHMpIHtcbiAgICAgIC8vIHJldHJ5IGZvcmV2ZXIsIG9ubHkga2VlcCBsYXN0IGVycm9yXG4gICAgICB0aGlzLl9lcnJvcnMuc3BsaWNlKDAsIHRoaXMuX2Vycm9ycy5sZW5ndGggLSAxKTtcbiAgICAgIHRpbWVvdXQgPSB0aGlzLl9jYWNoZWRUaW1lb3V0cy5zbGljZSgtMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMuX3RpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICBzZWxmLl9hdHRlbXB0cysrO1xuXG4gICAgaWYgKHNlbGYuX29wZXJhdGlvblRpbWVvdXRDYikge1xuICAgICAgc2VsZi5fdGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHNlbGYuX29wZXJhdGlvblRpbWVvdXRDYihzZWxmLl9hdHRlbXB0cyk7XG4gICAgICB9LCBzZWxmLl9vcGVyYXRpb25UaW1lb3V0KTtcblxuICAgICAgaWYgKHNlbGYuX29wdGlvbnMudW5yZWYpIHtcbiAgICAgICAgICBzZWxmLl90aW1lb3V0LnVucmVmKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZi5fZm4oc2VsZi5fYXR0ZW1wdHMpO1xuICB9LCB0aW1lb3V0KTtcblxuICBpZiAodGhpcy5fb3B0aW9ucy51bnJlZikge1xuICAgICAgdGhpcy5fdGltZXIudW5yZWYoKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuUmV0cnlPcGVyYXRpb24ucHJvdG90eXBlLmF0dGVtcHQgPSBmdW5jdGlvbihmbiwgdGltZW91dE9wcykge1xuICB0aGlzLl9mbiA9IGZuO1xuXG4gIGlmICh0aW1lb3V0T3BzKSB7XG4gICAgaWYgKHRpbWVvdXRPcHMudGltZW91dCkge1xuICAgICAgdGhpcy5fb3BlcmF0aW9uVGltZW91dCA9IHRpbWVvdXRPcHMudGltZW91dDtcbiAgICB9XG4gICAgaWYgKHRpbWVvdXRPcHMuY2IpIHtcbiAgICAgIHRoaXMuX29wZXJhdGlvblRpbWVvdXRDYiA9IHRpbWVvdXRPcHMuY2I7XG4gICAgfVxuICB9XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBpZiAodGhpcy5fb3BlcmF0aW9uVGltZW91dENiKSB7XG4gICAgdGhpcy5fdGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmLl9vcGVyYXRpb25UaW1lb3V0Q2IoKTtcbiAgICB9LCBzZWxmLl9vcGVyYXRpb25UaW1lb3V0KTtcbiAgfVxuXG4gIHRoaXMuX29wZXJhdGlvblN0YXJ0ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5cbiAgdGhpcy5fZm4odGhpcy5fYXR0ZW1wdHMpO1xufTtcblxuUmV0cnlPcGVyYXRpb24ucHJvdG90eXBlLnRyeSA9IGZ1bmN0aW9uKGZuKSB7XG4gIGNvbnNvbGUubG9nKCdVc2luZyBSZXRyeU9wZXJhdGlvbi50cnkoKSBpcyBkZXByZWNhdGVkJyk7XG4gIHRoaXMuYXR0ZW1wdChmbik7XG59O1xuXG5SZXRyeU9wZXJhdGlvbi5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbihmbikge1xuICBjb25zb2xlLmxvZygnVXNpbmcgUmV0cnlPcGVyYXRpb24uc3RhcnQoKSBpcyBkZXByZWNhdGVkJyk7XG4gIHRoaXMuYXR0ZW1wdChmbik7XG59O1xuXG5SZXRyeU9wZXJhdGlvbi5wcm90b3R5cGUuc3RhcnQgPSBSZXRyeU9wZXJhdGlvbi5wcm90b3R5cGUudHJ5O1xuXG5SZXRyeU9wZXJhdGlvbi5wcm90b3R5cGUuZXJyb3JzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9lcnJvcnM7XG59O1xuXG5SZXRyeU9wZXJhdGlvbi5wcm90b3R5cGUuYXR0ZW1wdHMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2F0dGVtcHRzO1xufTtcblxuUmV0cnlPcGVyYXRpb24ucHJvdG90eXBlLm1haW5FcnJvciA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5fZXJyb3JzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGNvdW50cyA9IHt9O1xuICB2YXIgbWFpbkVycm9yID0gbnVsbDtcbiAgdmFyIG1haW5FcnJvckNvdW50ID0gMDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2Vycm9ycy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlcnJvciA9IHRoaXMuX2Vycm9yc1tpXTtcbiAgICB2YXIgbWVzc2FnZSA9IGVycm9yLm1lc3NhZ2U7XG4gICAgdmFyIGNvdW50ID0gKGNvdW50c1ttZXNzYWdlXSB8fCAwKSArIDE7XG5cbiAgICBjb3VudHNbbWVzc2FnZV0gPSBjb3VudDtcblxuICAgIGlmIChjb3VudCA+PSBtYWluRXJyb3JDb3VudCkge1xuICAgICAgbWFpbkVycm9yID0gZXJyb3I7XG4gICAgICBtYWluRXJyb3JDb3VudCA9IGNvdW50O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtYWluRXJyb3I7XG59O1xuIiwgInZhciBSZXRyeU9wZXJhdGlvbiA9IHJlcXVpcmUoJy4vcmV0cnlfb3BlcmF0aW9uJyk7XG5cbmV4cG9ydHMub3BlcmF0aW9uID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICB2YXIgdGltZW91dHMgPSBleHBvcnRzLnRpbWVvdXRzKG9wdGlvbnMpO1xuICByZXR1cm4gbmV3IFJldHJ5T3BlcmF0aW9uKHRpbWVvdXRzLCB7XG4gICAgICBmb3JldmVyOiBvcHRpb25zICYmIChvcHRpb25zLmZvcmV2ZXIgfHwgb3B0aW9ucy5yZXRyaWVzID09PSBJbmZpbml0eSksXG4gICAgICB1bnJlZjogb3B0aW9ucyAmJiBvcHRpb25zLnVucmVmLFxuICAgICAgbWF4UmV0cnlUaW1lOiBvcHRpb25zICYmIG9wdGlvbnMubWF4UmV0cnlUaW1lXG4gIH0pO1xufTtcblxuZXhwb3J0cy50aW1lb3V0cyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgIHJldHVybiBbXS5jb25jYXQob3B0aW9ucyk7XG4gIH1cblxuICB2YXIgb3B0cyA9IHtcbiAgICByZXRyaWVzOiAxMCxcbiAgICBmYWN0b3I6IDIsXG4gICAgbWluVGltZW91dDogMSAqIDEwMDAsXG4gICAgbWF4VGltZW91dDogSW5maW5pdHksXG4gICAgcmFuZG9taXplOiBmYWxzZVxuICB9O1xuICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucykge1xuICAgIG9wdHNba2V5XSA9IG9wdGlvbnNba2V5XTtcbiAgfVxuXG4gIGlmIChvcHRzLm1pblRpbWVvdXQgPiBvcHRzLm1heFRpbWVvdXQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ21pblRpbWVvdXQgaXMgZ3JlYXRlciB0aGFuIG1heFRpbWVvdXQnKTtcbiAgfVxuXG4gIHZhciB0aW1lb3V0cyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG9wdHMucmV0cmllczsgaSsrKSB7XG4gICAgdGltZW91dHMucHVzaCh0aGlzLmNyZWF0ZVRpbWVvdXQoaSwgb3B0cykpO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5mb3JldmVyICYmICF0aW1lb3V0cy5sZW5ndGgpIHtcbiAgICB0aW1lb3V0cy5wdXNoKHRoaXMuY3JlYXRlVGltZW91dChpLCBvcHRzKSk7XG4gIH1cblxuICAvLyBzb3J0IHRoZSBhcnJheSBudW1lcmljYWxseSBhc2NlbmRpbmdcbiAgdGltZW91dHMuc29ydChmdW5jdGlvbihhLGIpIHtcbiAgICByZXR1cm4gYSAtIGI7XG4gIH0pO1xuXG4gIHJldHVybiB0aW1lb3V0cztcbn07XG5cbmV4cG9ydHMuY3JlYXRlVGltZW91dCA9IGZ1bmN0aW9uKGF0dGVtcHQsIG9wdHMpIHtcbiAgdmFyIHJhbmRvbSA9IChvcHRzLnJhbmRvbWl6ZSlcbiAgICA/IChNYXRoLnJhbmRvbSgpICsgMSlcbiAgICA6IDE7XG5cbiAgdmFyIHRpbWVvdXQgPSBNYXRoLnJvdW5kKHJhbmRvbSAqIE1hdGgubWF4KG9wdHMubWluVGltZW91dCwgMSkgKiBNYXRoLnBvdyhvcHRzLmZhY3RvciwgYXR0ZW1wdCkpO1xuICB0aW1lb3V0ID0gTWF0aC5taW4odGltZW91dCwgb3B0cy5tYXhUaW1lb3V0KTtcblxuICByZXR1cm4gdGltZW91dDtcbn07XG5cbmV4cG9ydHMud3JhcCA9IGZ1bmN0aW9uKG9iaiwgb3B0aW9ucywgbWV0aG9kcykge1xuICBpZiAob3B0aW9ucyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgbWV0aG9kcyA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IG51bGw7XG4gIH1cblxuICBpZiAoIW1ldGhvZHMpIHtcbiAgICBtZXRob2RzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgaWYgKHR5cGVvZiBvYmpba2V5XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBtZXRob2RzLnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG1ldGhvZHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbWV0aG9kICAgPSBtZXRob2RzW2ldO1xuICAgIHZhciBvcmlnaW5hbCA9IG9ialttZXRob2RdO1xuXG4gICAgb2JqW21ldGhvZF0gPSBmdW5jdGlvbiByZXRyeVdyYXBwZXIob3JpZ2luYWwpIHtcbiAgICAgIHZhciBvcCAgICAgICA9IGV4cG9ydHMub3BlcmF0aW9uKG9wdGlvbnMpO1xuICAgICAgdmFyIGFyZ3MgICAgID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3MucG9wKCk7XG5cbiAgICAgIGFyZ3MucHVzaChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgaWYgKG9wLnJldHJ5KGVycikpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIGFyZ3VtZW50c1swXSA9IG9wLm1haW5FcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIGNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9KTtcblxuICAgICAgb3AuYXR0ZW1wdChmdW5jdGlvbigpIHtcbiAgICAgICAgb3JpZ2luYWwuYXBwbHkob2JqLCBhcmdzKTtcbiAgICAgIH0pO1xuICAgIH0uYmluZChvYmosIG9yaWdpbmFsKTtcbiAgICBvYmpbbWV0aG9kXS5vcHRpb25zID0gb3B0aW9ucztcbiAgfVxufTtcbiIsICJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL3JldHJ5Jyk7IiwgIid1c2Ugc3RyaWN0JztcbmNvbnN0IHJldHJ5ID0gcmVxdWlyZSgncmV0cnknKTtcblxuY29uc3QgbmV0d29ya0Vycm9yTXNncyA9IFtcblx0J0ZhaWxlZCB0byBmZXRjaCcsIC8vIENocm9tZVxuXHQnTmV0d29ya0Vycm9yIHdoZW4gYXR0ZW1wdGluZyB0byBmZXRjaCByZXNvdXJjZS4nLCAvLyBGaXJlZm94XG5cdCdUaGUgSW50ZXJuZXQgY29ubmVjdGlvbiBhcHBlYXJzIHRvIGJlIG9mZmxpbmUuJywgLy8gU2FmYXJpXG5cdCdOZXR3b3JrIHJlcXVlc3QgZmFpbGVkJyAvLyBgY3Jvc3MtZmV0Y2hgXG5dO1xuXG5jbGFzcyBBYm9ydEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuXHRjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG5cdFx0c3VwZXIoKTtcblxuXHRcdGlmIChtZXNzYWdlIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0XHRcdHRoaXMub3JpZ2luYWxFcnJvciA9IG1lc3NhZ2U7XG5cdFx0XHQoe21lc3NhZ2V9ID0gbWVzc2FnZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMub3JpZ2luYWxFcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcblx0XHRcdHRoaXMub3JpZ2luYWxFcnJvci5zdGFjayA9IHRoaXMuc3RhY2s7XG5cdFx0fVxuXG5cdFx0dGhpcy5uYW1lID0gJ0Fib3J0RXJyb3InO1xuXHRcdHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG5cdH1cbn1cblxuY29uc3QgZGVjb3JhdGVFcnJvcldpdGhDb3VudHMgPSAoZXJyb3IsIGF0dGVtcHROdW1iZXIsIG9wdGlvbnMpID0+IHtcblx0Ly8gTWludXMgMSBmcm9tIGF0dGVtcHROdW1iZXIgYmVjYXVzZSB0aGUgZmlyc3QgYXR0ZW1wdCBkb2VzIG5vdCBjb3VudCBhcyBhIHJldHJ5XG5cdGNvbnN0IHJldHJpZXNMZWZ0ID0gb3B0aW9ucy5yZXRyaWVzIC0gKGF0dGVtcHROdW1iZXIgLSAxKTtcblxuXHRlcnJvci5hdHRlbXB0TnVtYmVyID0gYXR0ZW1wdE51bWJlcjtcblx0ZXJyb3IucmV0cmllc0xlZnQgPSByZXRyaWVzTGVmdDtcblx0cmV0dXJuIGVycm9yO1xufTtcblxuY29uc3QgaXNOZXR3b3JrRXJyb3IgPSBlcnJvck1lc3NhZ2UgPT4gbmV0d29ya0Vycm9yTXNncy5pbmNsdWRlcyhlcnJvck1lc3NhZ2UpO1xuXG5jb25zdCBwUmV0cnkgPSAoaW5wdXQsIG9wdGlvbnMpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblx0b3B0aW9ucyA9IHtcblx0XHRvbkZhaWxlZEF0dGVtcHQ6ICgpID0+IHt9LFxuXHRcdHJldHJpZXM6IDEwLFxuXHRcdC4uLm9wdGlvbnNcblx0fTtcblxuXHRjb25zdCBvcGVyYXRpb24gPSByZXRyeS5vcGVyYXRpb24ob3B0aW9ucyk7XG5cblx0b3BlcmF0aW9uLmF0dGVtcHQoYXN5bmMgYXR0ZW1wdE51bWJlciA9PiB7XG5cdFx0dHJ5IHtcblx0XHRcdHJlc29sdmUoYXdhaXQgaW5wdXQoYXR0ZW1wdE51bWJlcikpO1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRpZiAoIShlcnJvciBpbnN0YW5jZW9mIEVycm9yKSkge1xuXHRcdFx0XHRyZWplY3QobmV3IFR5cGVFcnJvcihgTm9uLWVycm9yIHdhcyB0aHJvd246IFwiJHtlcnJvcn1cIi4gWW91IHNob3VsZCBvbmx5IHRocm93IGVycm9ycy5gKSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGVycm9yIGluc3RhbmNlb2YgQWJvcnRFcnJvcikge1xuXHRcdFx0XHRvcGVyYXRpb24uc3RvcCgpO1xuXHRcdFx0XHRyZWplY3QoZXJyb3Iub3JpZ2luYWxFcnJvcik7XG5cdFx0XHR9IGVsc2UgaWYgKGVycm9yIGluc3RhbmNlb2YgVHlwZUVycm9yICYmICFpc05ldHdvcmtFcnJvcihlcnJvci5tZXNzYWdlKSkge1xuXHRcdFx0XHRvcGVyYXRpb24uc3RvcCgpO1xuXHRcdFx0XHRyZWplY3QoZXJyb3IpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVjb3JhdGVFcnJvcldpdGhDb3VudHMoZXJyb3IsIGF0dGVtcHROdW1iZXIsIG9wdGlvbnMpO1xuXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0YXdhaXQgb3B0aW9ucy5vbkZhaWxlZEF0dGVtcHQoZXJyb3IpO1xuXHRcdFx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0XHRcdHJlamVjdChlcnJvcik7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCFvcGVyYXRpb24ucmV0cnkoZXJyb3IpKSB7XG5cdFx0XHRcdFx0cmVqZWN0KG9wZXJhdGlvbi5tYWluRXJyb3IoKSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0pO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gcFJldHJ5O1xuLy8gVE9ETzogcmVtb3ZlIHRoaXMgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvblxubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IHBSZXRyeTtcblxubW9kdWxlLmV4cG9ydHMuQWJvcnRFcnJvciA9IEFib3J0RXJyb3I7XG4iLCAibW9kdWxlLmV4cG9ydHMgPSBlbmNvZGVcblxudmFyIE1TQiA9IDB4ODBcbiAgLCBSRVNUID0gMHg3RlxuICAsIE1TQkFMTCA9IH5SRVNUXG4gICwgSU5UID0gTWF0aC5wb3coMiwgMzEpXG5cbmZ1bmN0aW9uIGVuY29kZShudW0sIG91dCwgb2Zmc2V0KSB7XG4gIGlmIChOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiAmJiBudW0gPiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikge1xuICAgIGVuY29kZS5ieXRlcyA9IDBcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQ291bGQgbm90IGVuY29kZSB2YXJpbnQnKVxuICB9XG4gIG91dCA9IG91dCB8fCBbXVxuICBvZmZzZXQgPSBvZmZzZXQgfHwgMFxuICB2YXIgb2xkT2Zmc2V0ID0gb2Zmc2V0XG5cbiAgd2hpbGUobnVtID49IElOVCkge1xuICAgIG91dFtvZmZzZXQrK10gPSAobnVtICYgMHhGRikgfCBNU0JcbiAgICBudW0gLz0gMTI4XG4gIH1cbiAgd2hpbGUobnVtICYgTVNCQUxMKSB7XG4gICAgb3V0W29mZnNldCsrXSA9IChudW0gJiAweEZGKSB8IE1TQlxuICAgIG51bSA+Pj49IDdcbiAgfVxuICBvdXRbb2Zmc2V0XSA9IG51bSB8IDBcbiAgXG4gIGVuY29kZS5ieXRlcyA9IG9mZnNldCAtIG9sZE9mZnNldCArIDFcbiAgXG4gIHJldHVybiBvdXRcbn1cbiIsICJtb2R1bGUuZXhwb3J0cyA9IHJlYWRcblxudmFyIE1TQiA9IDB4ODBcbiAgLCBSRVNUID0gMHg3RlxuXG5mdW5jdGlvbiByZWFkKGJ1Ziwgb2Zmc2V0KSB7XG4gIHZhciByZXMgICAgPSAwXG4gICAgLCBvZmZzZXQgPSBvZmZzZXQgfHwgMFxuICAgICwgc2hpZnQgID0gMFxuICAgICwgY291bnRlciA9IG9mZnNldFxuICAgICwgYlxuICAgICwgbCA9IGJ1Zi5sZW5ndGhcblxuICBkbyB7XG4gICAgaWYgKGNvdW50ZXIgPj0gbCB8fCBzaGlmdCA+IDQ5KSB7XG4gICAgICByZWFkLmJ5dGVzID0gMFxuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0NvdWxkIG5vdCBkZWNvZGUgdmFyaW50JylcbiAgICB9XG4gICAgYiA9IGJ1Zltjb3VudGVyKytdXG4gICAgcmVzICs9IHNoaWZ0IDwgMjhcbiAgICAgID8gKGIgJiBSRVNUKSA8PCBzaGlmdFxuICAgICAgOiAoYiAmIFJFU1QpICogTWF0aC5wb3coMiwgc2hpZnQpXG4gICAgc2hpZnQgKz0gN1xuICB9IHdoaWxlIChiID49IE1TQilcblxuICByZWFkLmJ5dGVzID0gY291bnRlciAtIG9mZnNldFxuXG4gIHJldHVybiByZXNcbn1cbiIsICJcbnZhciBOMSA9IE1hdGgucG93KDIsICA3KVxudmFyIE4yID0gTWF0aC5wb3coMiwgMTQpXG52YXIgTjMgPSBNYXRoLnBvdygyLCAyMSlcbnZhciBONCA9IE1hdGgucG93KDIsIDI4KVxudmFyIE41ID0gTWF0aC5wb3coMiwgMzUpXG52YXIgTjYgPSBNYXRoLnBvdygyLCA0MilcbnZhciBONyA9IE1hdGgucG93KDIsIDQ5KVxudmFyIE44ID0gTWF0aC5wb3coMiwgNTYpXG52YXIgTjkgPSBNYXRoLnBvdygyLCA2MylcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgcmV0dXJuIChcbiAgICB2YWx1ZSA8IE4xID8gMVxuICA6IHZhbHVlIDwgTjIgPyAyXG4gIDogdmFsdWUgPCBOMyA/IDNcbiAgOiB2YWx1ZSA8IE40ID8gNFxuICA6IHZhbHVlIDwgTjUgPyA1XG4gIDogdmFsdWUgPCBONiA/IDZcbiAgOiB2YWx1ZSA8IE43ID8gN1xuICA6IHZhbHVlIDwgTjggPyA4XG4gIDogdmFsdWUgPCBOOSA/IDlcbiAgOiAgICAgICAgICAgICAgMTBcbiAgKVxufVxuIiwgIm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGVuY29kZTogcmVxdWlyZSgnLi9lbmNvZGUuanMnKVxuICAsIGRlY29kZTogcmVxdWlyZSgnLi9kZWNvZGUuanMnKVxuICAsIGVuY29kaW5nTGVuZ3RoOiByZXF1aXJlKCcuL2xlbmd0aC5qcycpXG59XG4iLCAiJ3VzZSBzdHJpY3QnXG5cbi8qKlxuICogUmV0dXJucyB0aGUgbGFzdCBpdGVtIG9mIGFuIChhc3luYykgaXRlcmFibGUsIHVubGVzcyBlbXB0eSwgaW4gd2hpY2ggY2FzZVxuICogcmV0dXJuIGB1bmRlZmluZWRgLlxuICpcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge0FzeW5jSXRlcmFibGU8VD58SXRlcmFibGU8VD59IHNvdXJjZVxuICovXG5jb25zdCBsYXN0ID0gYXN5bmMgKHNvdXJjZSkgPT4ge1xuICBsZXQgcmVzXG5cbiAgZm9yIGF3YWl0IChjb25zdCBlbnRyeSBvZiBzb3VyY2UpIHtcbiAgICByZXMgPSBlbnRyeVxuICB9XG5cbiAgcmV0dXJuIHJlc1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxhc3RcbiIsICJjb25zdCByYXdQaXBlID0gKC4uLmZucykgPT4ge1xuICBsZXQgcmVzXG4gIHdoaWxlIChmbnMubGVuZ3RoKSB7XG4gICAgcmVzID0gZm5zLnNoaWZ0KCkocmVzKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuY29uc3QgaXNJdGVyYWJsZSA9IG9iaiA9PiBvYmogJiYgKFxuICB0eXBlb2Ygb2JqW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJyB8fFxuICB0eXBlb2Ygb2JqW1N5bWJvbC5pdGVyYXRvcl0gPT09ICdmdW5jdGlvbicgfHxcbiAgdHlwZW9mIG9iai5uZXh0ID09PSAnZnVuY3Rpb24nIC8vIFByb2JhYmx5LCByaWdodD9cbilcblxuY29uc3QgaXNEdXBsZXggPSBvYmogPT4gb2JqICYmIHR5cGVvZiBvYmouc2luayA9PT0gJ2Z1bmN0aW9uJyAmJiBpc0l0ZXJhYmxlKG9iai5zb3VyY2UpXG5cbmNvbnN0IGR1cGxleFBpcGVsaW5lRm4gPSBkdXBsZXggPT4gc291cmNlID0+IHtcbiAgZHVwbGV4LnNpbmsoc291cmNlKSAvLyBUT0RPOiBlcnJvciBvbiBzaW5rIHNpZGUgaXMgdW5oYW5kbGVkIHJlamVjdGlvbiAtIHRoaXMgaXMgdGhlIHNhbWUgYXMgcHVsbCBzdHJlYW1zXG4gIHJldHVybiBkdXBsZXguc291cmNlXG59XG5cbmNvbnN0IHBpcGUgPSAoLi4uZm5zKSA9PiB7XG4gIC8vIER1cGxleCBhdCBzdGFydDogd3JhcCBpbiBmdW5jdGlvbiBhbmQgcmV0dXJuIGR1cGxleCBzb3VyY2VcbiAgaWYgKGlzRHVwbGV4KGZuc1swXSkpIHtcbiAgICBjb25zdCBkdXBsZXggPSBmbnNbMF1cbiAgICBmbnNbMF0gPSAoKSA9PiBkdXBsZXguc291cmNlXG4gIC8vIEl0ZXJhYmxlIGF0IHN0YXJ0OiB3cmFwIGluIGZ1bmN0aW9uXG4gIH0gZWxzZSBpZiAoaXNJdGVyYWJsZShmbnNbMF0pKSB7XG4gICAgY29uc3Qgc291cmNlID0gZm5zWzBdXG4gICAgZm5zWzBdID0gKCkgPT4gc291cmNlXG4gIH1cblxuICBpZiAoZm5zLmxlbmd0aCA+IDEpIHtcbiAgICAvLyBEdXBsZXggYXQgZW5kOiB1c2UgZHVwbGV4IHNpbmtcbiAgICBpZiAoaXNEdXBsZXgoZm5zW2Zucy5sZW5ndGggLSAxXSkpIHtcbiAgICAgIGZuc1tmbnMubGVuZ3RoIC0gMV0gPSBmbnNbZm5zLmxlbmd0aCAtIDFdLnNpbmtcbiAgICB9XG4gIH1cblxuICBpZiAoZm5zLmxlbmd0aCA+IDIpIHtcbiAgICAvLyBEdXBsZXggaW4gdGhlIG1pZGRsZSwgY29uc3VtZSBzb3VyY2Ugd2l0aCBkdXBsZXggc2luayBhbmQgcmV0dXJuIGR1cGxleCBzb3VyY2VcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGZucy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgIGlmIChpc0R1cGxleChmbnNbaV0pKSB7XG4gICAgICAgIGZuc1tpXSA9IGR1cGxleFBpcGVsaW5lRm4oZm5zW2ldKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByYXdQaXBlKC4uLmZucylcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwaXBlXG5tb2R1bGUuZXhwb3J0cy5waXBlID0gcGlwZVxubW9kdWxlLmV4cG9ydHMucmF3UGlwZSA9IHJhd1BpcGVcbm1vZHVsZS5leHBvcnRzLmlzSXRlcmFibGUgPSBpc0l0ZXJhYmxlXG5tb2R1bGUuZXhwb3J0cy5pc0R1cGxleCA9IGlzRHVwbGV4XG4iLCAiJ3VzZSBzdHJpY3QnXG5cbi8qKlxuICogVGFrZXMgYW4gKGFzeW5jKSBpdGVyYWJsZSB0aGF0IGVtaXRzIHRoaW5ncyBhbmQgcmV0dXJucyBhbiBhc3luYyBpdGVyYWJsZSB0aGF0XG4gKiBlbWl0cyB0aG9zZSB0aGluZ3MgaW4gZml4ZWQtc2l6ZWQgYmF0Y2hlcy5cbiAqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtBc3luY0l0ZXJhYmxlPFQ+fEl0ZXJhYmxlPFQ+fSBzb3VyY2VcbiAqIEBwYXJhbSB7bnVtYmVyfSBbc2l6ZT0xXVxuICogQHJldHVybnMge0FzeW5jSXRlcmFibGU8VFtdPn1cbiAqL1xuYXN5bmMgZnVuY3Rpb24gKiBiYXRjaCAoc291cmNlLCBzaXplID0gMSkge1xuICAvKiogQHR5cGUge1RbXX0gKi9cbiAgbGV0IHRoaW5ncyA9IFtdXG5cbiAgaWYgKHNpemUgPCAxKSB7XG4gICAgc2l6ZSA9IDFcbiAgfVxuXG4gIGZvciBhd2FpdCAoY29uc3QgdGhpbmcgb2Ygc291cmNlKSB7XG4gICAgdGhpbmdzLnB1c2godGhpbmcpXG5cbiAgICB3aGlsZSAodGhpbmdzLmxlbmd0aCA+PSBzaXplKSB7XG4gICAgICB5aWVsZCB0aGluZ3Muc2xpY2UoMCwgc2l6ZSlcblxuICAgICAgdGhpbmdzID0gdGhpbmdzLnNsaWNlKHNpemUpXG4gICAgfVxuICB9XG5cbiAgd2hpbGUgKHRoaW5ncy5sZW5ndGgpIHtcbiAgICB5aWVsZCB0aGluZ3Muc2xpY2UoMCwgc2l6ZSlcblxuICAgIHRoaW5ncyA9IHRoaW5ncy5zbGljZShzaXplKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmF0Y2hcbiIsICIndXNlIHN0cmljdCdcblxuY29uc3QgYmF0Y2ggPSByZXF1aXJlKCdpdC1iYXRjaCcpXG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEB0eXBlZGVmIHt7b2s6dHJ1ZSwgdmFsdWU6VH19IFN1Y2Nlc3NcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHt7b2s6ZmFsc2UsIGVycjpFcnJvcn19IEZhaWx1cmVcbiAqL1xuXG4vKipcbiAqIFRha2VzIGFuIChhc3luYykgaXRlcmF0b3IgdGhhdCBlbWl0cyBwcm9taXNlLXJldHVybmluZyBmdW5jdGlvbnMsXG4gKiBpbnZva2VzIHRoZW0gaW4gcGFyYWxsZWwgYW5kIGVtaXRzIHRoZSByZXN1bHRzIGFzIHRoZXkgYmVjb21lIGF2YWlsYWJsZSBidXRcbiAqIGluIHRoZSBzYW1lIG9yZGVyIGFzIHRoZSBpbnB1dFxuICpcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge0FzeW5jSXRlcmFibGU8KCkgPT4gUHJvbWlzZTxUPj58SXRlcmFibGU8KCkgPT4gUHJvbWlzZTxUPj59IHNvdXJjZVxuICogQHBhcmFtIHtudW1iZXJ9IFtzaXplPTFdXG4gKiBAcmV0dXJucyB7QXN5bmNJdGVyYWJsZTxUPn1cbiAqL1xuYXN5bmMgZnVuY3Rpb24gKiBwYXJhbGxlbEJhdGNoIChzb3VyY2UsIHNpemUgPSAxKSB7XG4gIGZvciBhd2FpdCAoY29uc3QgdGFza3Mgb2YgYmF0Y2goc291cmNlLCBzaXplKSkge1xuICAgIC8qKiBAdHlwZSB7UHJvbWlzZTxTdWNjZXNzPFQ+fEZhaWx1cmU+W119ICovXG4gICAgY29uc3QgdGhpbmdzID0gdGFza3MubWFwKFxuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0geygpID0+IFByb21pc2U8VD59IHBcbiAgICAgICAqL1xuICAgICAgcCA9PiB7XG4gICAgICAgIHJldHVybiBwKCkudGhlbih2YWx1ZSA9PiAoeyBvazogdHJ1ZSwgdmFsdWUgfSksIGVyciA9PiAoeyBvazogZmFsc2UsIGVyciB9KSlcbiAgICAgIH0pXG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaW5ncy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpbmdzW2ldXG5cbiAgICAgIGlmIChyZXN1bHQub2spIHtcbiAgICAgICAgeWllbGQgcmVzdWx0LnZhbHVlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyByZXN1bHQuZXJyXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGFyYWxsZWxCYXRjaFxuIiwgIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB2YWx1ZSA9PiB7XG5cdGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpICE9PSAnW29iamVjdCBPYmplY3RdJykge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdGNvbnN0IHByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSk7XG5cdHJldHVybiBwcm90b3R5cGUgPT09IG51bGwgfHwgcHJvdG90eXBlID09PSBPYmplY3QucHJvdG90eXBlO1xufTtcbiIsICIndXNlIHN0cmljdCc7XG5jb25zdCBpc09wdGlvbk9iamVjdCA9IHJlcXVpcmUoJ2lzLXBsYWluLW9iaicpO1xuXG5jb25zdCB7aGFzT3duUHJvcGVydHl9ID0gT2JqZWN0LnByb3RvdHlwZTtcbmNvbnN0IHtwcm9wZXJ0eUlzRW51bWVyYWJsZX0gPSBPYmplY3Q7XG5jb25zdCBkZWZpbmVQcm9wZXJ0eSA9IChvYmplY3QsIG5hbWUsIHZhbHVlKSA9PiBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCBuYW1lLCB7XG5cdHZhbHVlLFxuXHR3cml0YWJsZTogdHJ1ZSxcblx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0Y29uZmlndXJhYmxlOiB0cnVlXG59KTtcblxuY29uc3QgZ2xvYmFsVGhpcyA9IHRoaXM7XG5jb25zdCBkZWZhdWx0TWVyZ2VPcHRpb25zID0ge1xuXHRjb25jYXRBcnJheXM6IGZhbHNlLFxuXHRpZ25vcmVVbmRlZmluZWQ6IGZhbHNlXG59O1xuXG5jb25zdCBnZXRFbnVtZXJhYmxlT3duUHJvcGVydHlLZXlzID0gdmFsdWUgPT4ge1xuXHRjb25zdCBrZXlzID0gW107XG5cblx0Zm9yIChjb25zdCBrZXkgaW4gdmFsdWUpIHtcblx0XHRpZiAoaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwga2V5KSkge1xuXHRcdFx0a2V5cy5wdXNoKGtleSk7XG5cdFx0fVxuXHR9XG5cblx0LyogaXN0YW5idWwgaWdub3JlIGVsc2UgICovXG5cdGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG5cdFx0Y29uc3Qgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModmFsdWUpO1xuXG5cdFx0Zm9yIChjb25zdCBzeW1ib2wgb2Ygc3ltYm9scykge1xuXHRcdFx0aWYgKHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsIHN5bWJvbCkpIHtcblx0XHRcdFx0a2V5cy5wdXNoKHN5bWJvbCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGtleXM7XG59O1xuXG5mdW5jdGlvbiBjbG9uZSh2YWx1ZSkge1xuXHRpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcblx0XHRyZXR1cm4gY2xvbmVBcnJheSh2YWx1ZSk7XG5cdH1cblxuXHRpZiAoaXNPcHRpb25PYmplY3QodmFsdWUpKSB7XG5cdFx0cmV0dXJuIGNsb25lT3B0aW9uT2JqZWN0KHZhbHVlKTtcblx0fVxuXG5cdHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gY2xvbmVBcnJheShhcnJheSkge1xuXHRjb25zdCByZXN1bHQgPSBhcnJheS5zbGljZSgwLCAwKTtcblxuXHRnZXRFbnVtZXJhYmxlT3duUHJvcGVydHlLZXlzKGFycmF5KS5mb3JFYWNoKGtleSA9PiB7XG5cdFx0ZGVmaW5lUHJvcGVydHkocmVzdWx0LCBrZXksIGNsb25lKGFycmF5W2tleV0pKTtcblx0fSk7XG5cblx0cmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gY2xvbmVPcHRpb25PYmplY3Qob2JqZWN0KSB7XG5cdGNvbnN0IHJlc3VsdCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShudWxsKSA6IHt9O1xuXG5cdGdldEVudW1lcmFibGVPd25Qcm9wZXJ0eUtleXMob2JqZWN0KS5mb3JFYWNoKGtleSA9PiB7XG5cdFx0ZGVmaW5lUHJvcGVydHkocmVzdWx0LCBrZXksIGNsb25lKG9iamVjdFtrZXldKSk7XG5cdH0pO1xuXG5cdHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHsqfSBtZXJnZWQgYWxyZWFkeSBjbG9uZWRcbiAqIEBwYXJhbSB7Kn0gc291cmNlIHNvbWV0aGluZyB0byBtZXJnZVxuICogQHBhcmFtIHtzdHJpbmdbXX0ga2V5cyBrZXlzIHRvIG1lcmdlXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIENvbmZpZyBPYmplY3RcbiAqIEByZXR1cm5zIHsqfSBjbG9uZWQgT2JqZWN0XG4gKi9cbmNvbnN0IG1lcmdlS2V5cyA9IChtZXJnZWQsIHNvdXJjZSwga2V5cywgY29uZmlnKSA9PiB7XG5cdGtleXMuZm9yRWFjaChrZXkgPT4ge1xuXHRcdGlmICh0eXBlb2Ygc291cmNlW2tleV0gPT09ICd1bmRlZmluZWQnICYmIGNvbmZpZy5pZ25vcmVVbmRlZmluZWQpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBEbyBub3QgcmVjdXJzZSBpbnRvIHByb3RvdHlwZSBjaGFpbiBvZiBtZXJnZWRcblx0XHRpZiAoa2V5IGluIG1lcmdlZCAmJiBtZXJnZWRba2V5XSAhPT0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG1lcmdlZCkpIHtcblx0XHRcdGRlZmluZVByb3BlcnR5KG1lcmdlZCwga2V5LCBtZXJnZShtZXJnZWRba2V5XSwgc291cmNlW2tleV0sIGNvbmZpZykpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkZWZpbmVQcm9wZXJ0eShtZXJnZWQsIGtleSwgY2xvbmUoc291cmNlW2tleV0pKTtcblx0XHR9XG5cdH0pO1xuXG5cdHJldHVybiBtZXJnZWQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7Kn0gbWVyZ2VkIGFscmVhZHkgY2xvbmVkXG4gKiBAcGFyYW0geyp9IHNvdXJjZSBzb21ldGhpbmcgdG8gbWVyZ2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgQ29uZmlnIE9iamVjdFxuICogQHJldHVybnMgeyp9IGNsb25lZCBPYmplY3RcbiAqXG4gKiBzZWUgW0FycmF5LnByb3RvdHlwZS5jb25jYXQgKCAuLi5hcmd1bWVudHMgKV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLWFycmF5LnByb3RvdHlwZS5jb25jYXQpXG4gKi9cbmNvbnN0IGNvbmNhdEFycmF5cyA9IChtZXJnZWQsIHNvdXJjZSwgY29uZmlnKSA9PiB7XG5cdGxldCByZXN1bHQgPSBtZXJnZWQuc2xpY2UoMCwgMCk7XG5cdGxldCByZXN1bHRJbmRleCA9IDA7XG5cblx0W21lcmdlZCwgc291cmNlXS5mb3JFYWNoKGFycmF5ID0+IHtcblx0XHRjb25zdCBpbmRpY2VzID0gW107XG5cblx0XHQvLyBgcmVzdWx0LmNvbmNhdChhcnJheSlgIHdpdGggY2xvbmluZ1xuXHRcdGZvciAobGV0IGsgPSAwOyBrIDwgYXJyYXkubGVuZ3RoOyBrKyspIHtcblx0XHRcdGlmICghaGFzT3duUHJvcGVydHkuY2FsbChhcnJheSwgaykpIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdGluZGljZXMucHVzaChTdHJpbmcoaykpO1xuXG5cdFx0XHRpZiAoYXJyYXkgPT09IG1lcmdlZCkge1xuXHRcdFx0XHQvLyBBbHJlYWR5IGNsb25lZFxuXHRcdFx0XHRkZWZpbmVQcm9wZXJ0eShyZXN1bHQsIHJlc3VsdEluZGV4KyssIGFycmF5W2tdKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRlZmluZVByb3BlcnR5KHJlc3VsdCwgcmVzdWx0SW5kZXgrKywgY2xvbmUoYXJyYXlba10pKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBNZXJnZSBub24taW5kZXgga2V5c1xuXHRcdHJlc3VsdCA9IG1lcmdlS2V5cyhyZXN1bHQsIGFycmF5LCBnZXRFbnVtZXJhYmxlT3duUHJvcGVydHlLZXlzKGFycmF5KS5maWx0ZXIoa2V5ID0+ICFpbmRpY2VzLmluY2x1ZGVzKGtleSkpLCBjb25maWcpO1xuXHR9KTtcblxuXHRyZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBAcGFyYW0geyp9IG1lcmdlZCBhbHJlYWR5IGNsb25lZFxuICogQHBhcmFtIHsqfSBzb3VyY2Ugc29tZXRoaW5nIHRvIG1lcmdlXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIENvbmZpZyBPYmplY3RcbiAqIEByZXR1cm5zIHsqfSBjbG9uZWQgT2JqZWN0XG4gKi9cbmZ1bmN0aW9uIG1lcmdlKG1lcmdlZCwgc291cmNlLCBjb25maWcpIHtcblx0aWYgKGNvbmZpZy5jb25jYXRBcnJheXMgJiYgQXJyYXkuaXNBcnJheShtZXJnZWQpICYmIEFycmF5LmlzQXJyYXkoc291cmNlKSkge1xuXHRcdHJldHVybiBjb25jYXRBcnJheXMobWVyZ2VkLCBzb3VyY2UsIGNvbmZpZyk7XG5cdH1cblxuXHRpZiAoIWlzT3B0aW9uT2JqZWN0KHNvdXJjZSkgfHwgIWlzT3B0aW9uT2JqZWN0KG1lcmdlZCkpIHtcblx0XHRyZXR1cm4gY2xvbmUoc291cmNlKTtcblx0fVxuXG5cdHJldHVybiBtZXJnZUtleXMobWVyZ2VkLCBzb3VyY2UsIGdldEVudW1lcmFibGVPd25Qcm9wZXJ0eUtleXMoc291cmNlKSwgY29uZmlnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoLi4ub3B0aW9ucykge1xuXHRjb25zdCBjb25maWcgPSBtZXJnZShjbG9uZShkZWZhdWx0TWVyZ2VPcHRpb25zKSwgKHRoaXMgIT09IGdsb2JhbFRoaXMgJiYgdGhpcykgfHwge30sIGRlZmF1bHRNZXJnZU9wdGlvbnMpO1xuXHRsZXQgbWVyZ2VkID0ge186IHt9fTtcblxuXHRmb3IgKGNvbnN0IG9wdGlvbiBvZiBvcHRpb25zKSB7XG5cdFx0aWYgKG9wdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHRpZiAoIWlzT3B0aW9uT2JqZWN0KG9wdGlvbikpIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ2AnICsgb3B0aW9uICsgJ2AgaXMgbm90IGFuIE9wdGlvbiBPYmplY3QnKTtcblx0XHR9XG5cblx0XHRtZXJnZWQgPSBtZXJnZShtZXJnZWQsIHtfOiBvcHRpb259LCBjb25maWcpO1xuXHR9XG5cblx0cmV0dXJuIG1lcmdlZC5fO1xufTtcbiIsICIvKiBqc2hpbnQgLVcwODY6IHRydWUgKi9cbi8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuLy8gfCBtdXJtdXJIYXNoM2pzLmpzIHYzLjAuMSAvLyBodHRwczovL2dpdGh1Yi5jb20vcGlkL211cm11ckhhc2gzanNcbi8vIHwgQSBqYXZhc2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIE11cm11ckhhc2gzJ3MgeDg2IGhhc2hpbmcgYWxnb3JpdGhtcy4gfFxuLy8gfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XG4vLyB8IENvcHlyaWdodCAoYykgMjAxMi0yMDE1IEthcmFuIEx5b25zICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuLy8gfCBodHRwczovL2dpdGh1Yi5jb20va2FyYW5seW9ucy9tdXJtdXJIYXNoMy5qcy9ibG9iL2MxNzc4Zjc1NzkyYWJlZjdiZGQ3NGJjODVkMmQ0ZTFhM2QyNWNmZTkvbXVybXVySGFzaDMuanMgfFxuLy8gfCBGcmVlbHkgZGlzdHJpYnV0YWJsZSB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4vLyArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcblxuOyhmdW5jdGlvbiAocm9vdCwgdW5kZWZpbmVkKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgLy8gQ3JlYXRlIGEgbG9jYWwgb2JqZWN0IHRoYXQnbGwgYmUgZXhwb3J0ZWQgb3IgcmVmZXJlbmNlZCBnbG9iYWxseS5cbiAgICB2YXIgbGlicmFyeSA9IHtcbiAgICAgICAgJ3ZlcnNpb24nOiAnMy4wLjAnLFxuICAgICAgICAneDg2Jzoge30sXG4gICAgICAgICd4NjQnOiB7fSxcbiAgICAgICAgJ2lucHV0VmFsaWRhdGlvbic6IHRydWVcbiAgICB9O1xuXG4gICAgLy8gUFJJVkFURSBGVU5DVElPTlNcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgZnVuY3Rpb24gX3ZhbGlkQnl0ZXMoYnl0ZXMpIHtcbiAgICAgICAgLy8gY2hlY2sgdGhlIGlucHV0IGlzIGFuIGFycmF5IG9yIGEgdHlwZWQgYXJyYXlcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGJ5dGVzKSAmJiAhQXJyYXlCdWZmZXIuaXNWaWV3KGJ5dGVzKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2hlY2sgYWxsIGJ5dGVzIGFyZSBhY3R1YWxseSBieXRlc1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIoYnl0ZXNbaV0pIHx8IGJ5dGVzW2ldIDwgMCB8fCBieXRlc1tpXSA+IDI1NSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfeDg2TXVsdGlwbHkobSwgbikge1xuICAgICAgICAvL1xuICAgICAgICAvLyBHaXZlbiB0d28gMzJiaXQgaW50cywgcmV0dXJucyB0aGUgdHdvIG11bHRpcGxpZWQgdG9nZXRoZXIgYXMgYVxuICAgICAgICAvLyAzMmJpdCBpbnQuXG4gICAgICAgIC8vXG5cbiAgICAgICAgcmV0dXJuICgobSAmIDB4ZmZmZikgKiBuKSArICgoKChtID4+PiAxNikgKiBuKSAmIDB4ZmZmZikgPDwgMTYpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF94ODZSb3RsKG0sIG4pIHtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gR2l2ZW4gYSAzMmJpdCBpbnQgYW5kIGFuIGludCByZXByZXNlbnRpbmcgYSBudW1iZXIgb2YgYml0IHBvc2l0aW9ucyxcbiAgICAgICAgLy8gcmV0dXJucyB0aGUgMzJiaXQgaW50IHJvdGF0ZWQgbGVmdCBieSB0aGF0IG51bWJlciBvZiBwb3NpdGlvbnMuXG4gICAgICAgIC8vXG5cbiAgICAgICAgcmV0dXJuIChtIDw8IG4pIHwgKG0gPj4+ICgzMiAtIG4pKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfeDg2Rm1peChoKSB7XG4gICAgICAgIC8vXG4gICAgICAgIC8vIEdpdmVuIGEgYmxvY2ssIHJldHVybnMgbXVybXVySGFzaDMncyBmaW5hbCB4ODYgbWl4IG9mIHRoYXQgYmxvY2suXG4gICAgICAgIC8vXG5cbiAgICAgICAgaCBePSBoID4+PiAxNjtcbiAgICAgICAgaCA9IF94ODZNdWx0aXBseShoLCAweDg1ZWJjYTZiKTtcbiAgICAgICAgaCBePSBoID4+PiAxMztcbiAgICAgICAgaCA9IF94ODZNdWx0aXBseShoLCAweGMyYjJhZTM1KTtcbiAgICAgICAgaCBePSBoID4+PiAxNjtcblxuICAgICAgICByZXR1cm4gaDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfeDY0QWRkKG0sIG4pIHtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gR2l2ZW4gdHdvIDY0Yml0IGludHMgKGFzIGFuIGFycmF5IG9mIHR3byAzMmJpdCBpbnRzKSByZXR1cm5zIHRoZSB0d29cbiAgICAgICAgLy8gYWRkZWQgdG9nZXRoZXIgYXMgYSA2NGJpdCBpbnQgKGFzIGFuIGFycmF5IG9mIHR3byAzMmJpdCBpbnRzKS5cbiAgICAgICAgLy9cblxuICAgICAgICBtID0gW21bMF0gPj4+IDE2LCBtWzBdICYgMHhmZmZmLCBtWzFdID4+PiAxNiwgbVsxXSAmIDB4ZmZmZl07XG4gICAgICAgIG4gPSBbblswXSA+Pj4gMTYsIG5bMF0gJiAweGZmZmYsIG5bMV0gPj4+IDE2LCBuWzFdICYgMHhmZmZmXTtcbiAgICAgICAgdmFyIG8gPSBbMCwgMCwgMCwgMF07XG5cbiAgICAgICAgb1szXSArPSBtWzNdICsgblszXTtcbiAgICAgICAgb1syXSArPSBvWzNdID4+PiAxNjtcbiAgICAgICAgb1szXSAmPSAweGZmZmY7XG5cbiAgICAgICAgb1syXSArPSBtWzJdICsgblsyXTtcbiAgICAgICAgb1sxXSArPSBvWzJdID4+PiAxNjtcbiAgICAgICAgb1syXSAmPSAweGZmZmY7XG5cbiAgICAgICAgb1sxXSArPSBtWzFdICsgblsxXTtcbiAgICAgICAgb1swXSArPSBvWzFdID4+PiAxNjtcbiAgICAgICAgb1sxXSAmPSAweGZmZmY7XG5cbiAgICAgICAgb1swXSArPSBtWzBdICsgblswXTtcbiAgICAgICAgb1swXSAmPSAweGZmZmY7XG5cbiAgICAgICAgcmV0dXJuIFsob1swXSA8PCAxNikgfCBvWzFdLCAob1syXSA8PCAxNikgfCBvWzNdXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfeDY0TXVsdGlwbHkobSwgbikge1xuICAgICAgICAvL1xuICAgICAgICAvLyBHaXZlbiB0d28gNjRiaXQgaW50cyAoYXMgYW4gYXJyYXkgb2YgdHdvIDMyYml0IGludHMpIHJldHVybnMgdGhlIHR3b1xuICAgICAgICAvLyBtdWx0aXBsaWVkIHRvZ2V0aGVyIGFzIGEgNjRiaXQgaW50IChhcyBhbiBhcnJheSBvZiB0d28gMzJiaXQgaW50cykuXG4gICAgICAgIC8vXG5cbiAgICAgICAgbSA9IFttWzBdID4+PiAxNiwgbVswXSAmIDB4ZmZmZiwgbVsxXSA+Pj4gMTYsIG1bMV0gJiAweGZmZmZdO1xuICAgICAgICBuID0gW25bMF0gPj4+IDE2LCBuWzBdICYgMHhmZmZmLCBuWzFdID4+PiAxNiwgblsxXSAmIDB4ZmZmZl07XG4gICAgICAgIHZhciBvID0gWzAsIDAsIDAsIDBdO1xuXG4gICAgICAgIG9bM10gKz0gbVszXSAqIG5bM107XG4gICAgICAgIG9bMl0gKz0gb1szXSA+Pj4gMTY7XG4gICAgICAgIG9bM10gJj0gMHhmZmZmO1xuXG4gICAgICAgIG9bMl0gKz0gbVsyXSAqIG5bM107XG4gICAgICAgIG9bMV0gKz0gb1syXSA+Pj4gMTY7XG4gICAgICAgIG9bMl0gJj0gMHhmZmZmO1xuXG4gICAgICAgIG9bMl0gKz0gbVszXSAqIG5bMl07XG4gICAgICAgIG9bMV0gKz0gb1syXSA+Pj4gMTY7XG4gICAgICAgIG9bMl0gJj0gMHhmZmZmO1xuXG4gICAgICAgIG9bMV0gKz0gbVsxXSAqIG5bM107XG4gICAgICAgIG9bMF0gKz0gb1sxXSA+Pj4gMTY7XG4gICAgICAgIG9bMV0gJj0gMHhmZmZmO1xuXG4gICAgICAgIG9bMV0gKz0gbVsyXSAqIG5bMl07XG4gICAgICAgIG9bMF0gKz0gb1sxXSA+Pj4gMTY7XG4gICAgICAgIG9bMV0gJj0gMHhmZmZmO1xuXG4gICAgICAgIG9bMV0gKz0gbVszXSAqIG5bMV07XG4gICAgICAgIG9bMF0gKz0gb1sxXSA+Pj4gMTY7XG4gICAgICAgIG9bMV0gJj0gMHhmZmZmO1xuXG4gICAgICAgIG9bMF0gKz0gKG1bMF0gKiBuWzNdKSArIChtWzFdICogblsyXSkgKyAobVsyXSAqIG5bMV0pICsgKG1bM10gKiBuWzBdKTtcbiAgICAgICAgb1swXSAmPSAweGZmZmY7XG5cbiAgICAgICAgcmV0dXJuIFsob1swXSA8PCAxNikgfCBvWzFdLCAob1syXSA8PCAxNikgfCBvWzNdXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfeDY0Um90bChtLCBuKSB7XG4gICAgICAgIC8vXG4gICAgICAgIC8vIEdpdmVuIGEgNjRiaXQgaW50IChhcyBhbiBhcnJheSBvZiB0d28gMzJiaXQgaW50cykgYW5kIGFuIGludFxuICAgICAgICAvLyByZXByZXNlbnRpbmcgYSBudW1iZXIgb2YgYml0IHBvc2l0aW9ucywgcmV0dXJucyB0aGUgNjRiaXQgaW50IChhcyBhblxuICAgICAgICAvLyBhcnJheSBvZiB0d28gMzJiaXQgaW50cykgcm90YXRlZCBsZWZ0IGJ5IHRoYXQgbnVtYmVyIG9mIHBvc2l0aW9ucy5cbiAgICAgICAgLy9cblxuICAgICAgICBuICU9IDY0O1xuXG4gICAgICAgIGlmIChuID09PSAzMikge1xuICAgICAgICAgICAgcmV0dXJuIFttWzFdLCBtWzBdXTtcbiAgICAgICAgfSBlbHNlIGlmIChuIDwgMzIpIHtcbiAgICAgICAgICAgIHJldHVybiBbKG1bMF0gPDwgbikgfCAobVsxXSA+Pj4gKDMyIC0gbikpLCAobVsxXSA8PCBuKSB8IChtWzBdID4+PiAoMzIgLSBuKSldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbiAtPSAzMjtcbiAgICAgICAgICAgIHJldHVybiBbKG1bMV0gPDwgbikgfCAobVswXSA+Pj4gKDMyIC0gbikpLCAobVswXSA8PCBuKSB8IChtWzFdID4+PiAoMzIgLSBuKSldO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX3g2NExlZnRTaGlmdChtLCBuKSB7XG4gICAgICAgIC8vXG4gICAgICAgIC8vIEdpdmVuIGEgNjRiaXQgaW50IChhcyBhbiBhcnJheSBvZiB0d28gMzJiaXQgaW50cykgYW5kIGFuIGludFxuICAgICAgICAvLyByZXByZXNlbnRpbmcgYSBudW1iZXIgb2YgYml0IHBvc2l0aW9ucywgcmV0dXJucyB0aGUgNjRiaXQgaW50IChhcyBhblxuICAgICAgICAvLyBhcnJheSBvZiB0d28gMzJiaXQgaW50cykgc2hpZnRlZCBsZWZ0IGJ5IHRoYXQgbnVtYmVyIG9mIHBvc2l0aW9ucy5cbiAgICAgICAgLy9cblxuICAgICAgICBuICU9IDY0O1xuXG4gICAgICAgIGlmIChuID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbTtcbiAgICAgICAgfSBlbHNlIGlmIChuIDwgMzIpIHtcbiAgICAgICAgICAgIHJldHVybiBbKG1bMF0gPDwgbikgfCAobVsxXSA+Pj4gKDMyIC0gbikpLCBtWzFdIDw8IG5dO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFttWzFdIDw8IChuIC0gMzIpLCAwXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF94NjRYb3IobSwgbikge1xuICAgICAgICAvL1xuICAgICAgICAvLyBHaXZlbiB0d28gNjRiaXQgaW50cyAoYXMgYW4gYXJyYXkgb2YgdHdvIDMyYml0IGludHMpIHJldHVybnMgdGhlIHR3b1xuICAgICAgICAvLyB4b3JlZCB0b2dldGhlciBhcyBhIDY0Yml0IGludCAoYXMgYW4gYXJyYXkgb2YgdHdvIDMyYml0IGludHMpLlxuICAgICAgICAvL1xuXG4gICAgICAgIHJldHVybiBbbVswXSBeIG5bMF0sIG1bMV0gXiBuWzFdXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfeDY0Rm1peChoKSB7XG4gICAgICAgIC8vXG4gICAgICAgIC8vIEdpdmVuIGEgYmxvY2ssIHJldHVybnMgbXVybXVySGFzaDMncyBmaW5hbCB4NjQgbWl4IG9mIHRoYXQgYmxvY2suXG4gICAgICAgIC8vIChgWzAsIGhbMF0gPj4+IDFdYCBpcyBhIDMzIGJpdCB1bnNpZ25lZCByaWdodCBzaGlmdC4gVGhpcyBpcyB0aGVcbiAgICAgICAgLy8gb25seSBwbGFjZSB3aGVyZSB3ZSBuZWVkIHRvIHJpZ2h0IHNoaWZ0IDY0Yml0IGludHMuKVxuICAgICAgICAvL1xuXG4gICAgICAgIGggPSBfeDY0WG9yKGgsIFswLCBoWzBdID4+PiAxXSk7XG4gICAgICAgIGggPSBfeDY0TXVsdGlwbHkoaCwgWzB4ZmY1MWFmZDcsIDB4ZWQ1NThjY2RdKTtcbiAgICAgICAgaCA9IF94NjRYb3IoaCwgWzAsIGhbMF0gPj4+IDFdKTtcbiAgICAgICAgaCA9IF94NjRNdWx0aXBseShoLCBbMHhjNGNlYjlmZSwgMHgxYTg1ZWM1M10pO1xuICAgICAgICBoID0gX3g2NFhvcihoLCBbMCwgaFswXSA+Pj4gMV0pO1xuXG4gICAgICAgIHJldHVybiBoO1xuICAgIH1cblxuICAgIC8vIFBVQkxJQyBGVU5DVElPTlNcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBsaWJyYXJ5Lng4Ni5oYXNoMzIgPSBmdW5jdGlvbiAoYnl0ZXMsIHNlZWQpIHtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gR2l2ZW4gYSBzdHJpbmcgYW5kIGFuIG9wdGlvbmFsIHNlZWQgYXMgYW4gaW50LCByZXR1cm5zIGEgMzIgYml0IGhhc2hcbiAgICAgICAgLy8gdXNpbmcgdGhlIHg4NiBmbGF2b3Igb2YgTXVybXVySGFzaDMsIGFzIGFuIHVuc2lnbmVkIGludC5cbiAgICAgICAgLy9cbiAgICAgICAgaWYgKGxpYnJhcnkuaW5wdXRWYWxpZGF0aW9uICYmICFfdmFsaWRCeXRlcyhieXRlcykpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgc2VlZCA9IHNlZWQgfHwgMDtcblxuICAgICAgICB2YXIgcmVtYWluZGVyID0gYnl0ZXMubGVuZ3RoICUgNDtcbiAgICAgICAgdmFyIGJsb2NrcyA9IGJ5dGVzLmxlbmd0aCAtIHJlbWFpbmRlcjtcblxuICAgICAgICB2YXIgaDEgPSBzZWVkO1xuXG4gICAgICAgIHZhciBrMSA9IDA7XG5cbiAgICAgICAgdmFyIGMxID0gMHhjYzllMmQ1MTtcbiAgICAgICAgdmFyIGMyID0gMHgxYjg3MzU5MztcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJsb2NrczsgaSA9IGkgKyA0KSB7XG4gICAgICAgICAgICBrMSA9IChieXRlc1tpXSkgfCAoYnl0ZXNbaSArIDFdIDw8IDgpIHwgKGJ5dGVzW2kgKyAyXSA8PCAxNikgfCAoYnl0ZXNbaSArIDNdIDw8IDI0KTtcblxuICAgICAgICAgICAgazEgPSBfeDg2TXVsdGlwbHkoazEsIGMxKTtcbiAgICAgICAgICAgIGsxID0gX3g4NlJvdGwoazEsIDE1KTtcbiAgICAgICAgICAgIGsxID0gX3g4Nk11bHRpcGx5KGsxLCBjMik7XG5cbiAgICAgICAgICAgIGgxIF49IGsxO1xuICAgICAgICAgICAgaDEgPSBfeDg2Um90bChoMSwgMTMpO1xuICAgICAgICAgICAgaDEgPSBfeDg2TXVsdGlwbHkoaDEsIDUpICsgMHhlNjU0NmI2NDtcbiAgICAgICAgfVxuXG4gICAgICAgIGsxID0gMDtcblxuICAgICAgICBzd2l0Y2ggKHJlbWFpbmRlcikge1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIGsxIF49IGJ5dGVzW2kgKyAyXSA8PCAxNjtcblxuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIGsxIF49IGJ5dGVzW2kgKyAxXSA8PCA4O1xuXG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgazEgXj0gYnl0ZXNbaV07XG4gICAgICAgICAgICAgICAgazEgPSBfeDg2TXVsdGlwbHkoazEsIGMxKTtcbiAgICAgICAgICAgICAgICBrMSA9IF94ODZSb3RsKGsxLCAxNSk7XG4gICAgICAgICAgICAgICAgazEgPSBfeDg2TXVsdGlwbHkoazEsIGMyKTtcbiAgICAgICAgICAgICAgICBoMSBePSBrMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGgxIF49IGJ5dGVzLmxlbmd0aDtcbiAgICAgICAgaDEgPSBfeDg2Rm1peChoMSk7XG5cbiAgICAgICAgcmV0dXJuIGgxID4+PiAwO1xuICAgIH07XG5cbiAgICBsaWJyYXJ5Lng4Ni5oYXNoMTI4ID0gZnVuY3Rpb24gKGJ5dGVzLCBzZWVkKSB7XG4gICAgICAgIC8vXG4gICAgICAgIC8vIEdpdmVuIGEgc3RyaW5nIGFuZCBhbiBvcHRpb25hbCBzZWVkIGFzIGFuIGludCwgcmV0dXJucyBhIDEyOCBiaXRcbiAgICAgICAgLy8gaGFzaCB1c2luZyB0aGUgeDg2IGZsYXZvciBvZiBNdXJtdXJIYXNoMywgYXMgYW4gdW5zaWduZWQgaGV4LlxuICAgICAgICAvL1xuICAgICAgICBpZiAobGlicmFyeS5pbnB1dFZhbGlkYXRpb24gJiYgIV92YWxpZEJ5dGVzKGJ5dGVzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlZWQgPSBzZWVkIHx8IDA7XG4gICAgICAgIHZhciByZW1haW5kZXIgPSBieXRlcy5sZW5ndGggJSAxNjtcbiAgICAgICAgdmFyIGJsb2NrcyA9IGJ5dGVzLmxlbmd0aCAtIHJlbWFpbmRlcjtcblxuICAgICAgICB2YXIgaDEgPSBzZWVkO1xuICAgICAgICB2YXIgaDIgPSBzZWVkO1xuICAgICAgICB2YXIgaDMgPSBzZWVkO1xuICAgICAgICB2YXIgaDQgPSBzZWVkO1xuXG4gICAgICAgIHZhciBrMSA9IDA7XG4gICAgICAgIHZhciBrMiA9IDA7XG4gICAgICAgIHZhciBrMyA9IDA7XG4gICAgICAgIHZhciBrNCA9IDA7XG5cbiAgICAgICAgdmFyIGMxID0gMHgyMzliOTYxYjtcbiAgICAgICAgdmFyIGMyID0gMHhhYjBlOTc4OTtcbiAgICAgICAgdmFyIGMzID0gMHgzOGIzNGFlNTtcbiAgICAgICAgdmFyIGM0ID0gMHhhMWUzOGI5MztcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJsb2NrczsgaSA9IGkgKyAxNikge1xuICAgICAgICAgICAgazEgPSAoYnl0ZXNbaV0pIHwgKGJ5dGVzW2kgKyAxXSA8PCA4KSB8IChieXRlc1tpICsgMl0gPDwgMTYpIHwgKGJ5dGVzW2kgKyAzXSA8PCAyNCk7XG4gICAgICAgICAgICBrMiA9IChieXRlc1tpICsgNF0pIHwgKGJ5dGVzW2kgKyA1XSA8PCA4KSB8IChieXRlc1tpICsgNl0gPDwgMTYpIHwgKGJ5dGVzW2kgKyA3XSA8PCAyNCk7XG4gICAgICAgICAgICBrMyA9IChieXRlc1tpICsgOF0pIHwgKGJ5dGVzW2kgKyA5XSA8PCA4KSB8IChieXRlc1tpICsgMTBdIDw8IDE2KSB8IChieXRlc1tpICsgMTFdIDw8IDI0KTtcbiAgICAgICAgICAgIGs0ID0gKGJ5dGVzW2kgKyAxMl0pIHwgKGJ5dGVzW2kgKyAxM10gPDwgOCkgfCAoYnl0ZXNbaSArIDE0XSA8PCAxNikgfCAoYnl0ZXNbaSArIDE1XSA8PCAyNCk7XG5cbiAgICAgICAgICAgIGsxID0gX3g4Nk11bHRpcGx5KGsxLCBjMSk7XG4gICAgICAgICAgICBrMSA9IF94ODZSb3RsKGsxLCAxNSk7XG4gICAgICAgICAgICBrMSA9IF94ODZNdWx0aXBseShrMSwgYzIpO1xuICAgICAgICAgICAgaDEgXj0gazE7XG5cbiAgICAgICAgICAgIGgxID0gX3g4NlJvdGwoaDEsIDE5KTtcbiAgICAgICAgICAgIGgxICs9IGgyO1xuICAgICAgICAgICAgaDEgPSBfeDg2TXVsdGlwbHkoaDEsIDUpICsgMHg1NjFjY2QxYjtcblxuICAgICAgICAgICAgazIgPSBfeDg2TXVsdGlwbHkoazIsIGMyKTtcbiAgICAgICAgICAgIGsyID0gX3g4NlJvdGwoazIsIDE2KTtcbiAgICAgICAgICAgIGsyID0gX3g4Nk11bHRpcGx5KGsyLCBjMyk7XG4gICAgICAgICAgICBoMiBePSBrMjtcblxuICAgICAgICAgICAgaDIgPSBfeDg2Um90bChoMiwgMTcpO1xuICAgICAgICAgICAgaDIgKz0gaDM7XG4gICAgICAgICAgICBoMiA9IF94ODZNdWx0aXBseShoMiwgNSkgKyAweDBiY2FhNzQ3O1xuXG4gICAgICAgICAgICBrMyA9IF94ODZNdWx0aXBseShrMywgYzMpO1xuICAgICAgICAgICAgazMgPSBfeDg2Um90bChrMywgMTcpO1xuICAgICAgICAgICAgazMgPSBfeDg2TXVsdGlwbHkoazMsIGM0KTtcbiAgICAgICAgICAgIGgzIF49IGszO1xuXG4gICAgICAgICAgICBoMyA9IF94ODZSb3RsKGgzLCAxNSk7XG4gICAgICAgICAgICBoMyArPSBoNDtcbiAgICAgICAgICAgIGgzID0gX3g4Nk11bHRpcGx5KGgzLCA1KSArIDB4OTZjZDFjMzU7XG5cbiAgICAgICAgICAgIGs0ID0gX3g4Nk11bHRpcGx5KGs0LCBjNCk7XG4gICAgICAgICAgICBrNCA9IF94ODZSb3RsKGs0LCAxOCk7XG4gICAgICAgICAgICBrNCA9IF94ODZNdWx0aXBseShrNCwgYzEpO1xuICAgICAgICAgICAgaDQgXj0gazQ7XG5cbiAgICAgICAgICAgIGg0ID0gX3g4NlJvdGwoaDQsIDEzKTtcbiAgICAgICAgICAgIGg0ICs9IGgxO1xuICAgICAgICAgICAgaDQgPSBfeDg2TXVsdGlwbHkoaDQsIDUpICsgMHgzMmFjM2IxNztcbiAgICAgICAgfVxuXG4gICAgICAgIGsxID0gMDtcbiAgICAgICAgazIgPSAwO1xuICAgICAgICBrMyA9IDA7XG4gICAgICAgIGs0ID0gMDtcblxuICAgICAgICBzd2l0Y2ggKHJlbWFpbmRlcikge1xuICAgICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgICAgICBrNCBePSBieXRlc1tpICsgMTRdIDw8IDE2O1xuXG4gICAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgICAgIGs0IF49IGJ5dGVzW2kgKyAxM10gPDwgODtcblxuICAgICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgICAgICBrNCBePSBieXRlc1tpICsgMTJdO1xuICAgICAgICAgICAgICAgIGs0ID0gX3g4Nk11bHRpcGx5KGs0LCBjNCk7XG4gICAgICAgICAgICAgICAgazQgPSBfeDg2Um90bChrNCwgMTgpO1xuICAgICAgICAgICAgICAgIGs0ID0gX3g4Nk11bHRpcGx5KGs0LCBjMSk7XG4gICAgICAgICAgICAgICAgaDQgXj0gazQ7XG5cbiAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgICAgazMgXj0gYnl0ZXNbaSArIDExXSA8PCAyNDtcblxuICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgICBrMyBePSBieXRlc1tpICsgMTBdIDw8IDE2O1xuXG4gICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICAgIGszIF49IGJ5dGVzW2kgKyA5XSA8PCA4O1xuXG4gICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgazMgXj0gYnl0ZXNbaSArIDhdO1xuICAgICAgICAgICAgICAgIGszID0gX3g4Nk11bHRpcGx5KGszLCBjMyk7XG4gICAgICAgICAgICAgICAgazMgPSBfeDg2Um90bChrMywgMTcpO1xuICAgICAgICAgICAgICAgIGszID0gX3g4Nk11bHRpcGx5KGszLCBjNCk7XG4gICAgICAgICAgICAgICAgaDMgXj0gazM7XG5cbiAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICBrMiBePSBieXRlc1tpICsgN10gPDwgMjQ7XG5cbiAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICBrMiBePSBieXRlc1tpICsgNl0gPDwgMTY7XG5cbiAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICBrMiBePSBieXRlc1tpICsgNV0gPDwgODtcblxuICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgIGsyIF49IGJ5dGVzW2kgKyA0XTtcbiAgICAgICAgICAgICAgICBrMiA9IF94ODZNdWx0aXBseShrMiwgYzIpO1xuICAgICAgICAgICAgICAgIGsyID0gX3g4NlJvdGwoazIsIDE2KTtcbiAgICAgICAgICAgICAgICBrMiA9IF94ODZNdWx0aXBseShrMiwgYzMpO1xuICAgICAgICAgICAgICAgIGgyIF49IGsyO1xuXG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgazEgXj0gYnl0ZXNbaSArIDNdIDw8IDI0O1xuXG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgazEgXj0gYnl0ZXNbaSArIDJdIDw8IDE2O1xuXG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgazEgXj0gYnl0ZXNbaSArIDFdIDw8IDg7XG5cbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBrMSBePSBieXRlc1tpXTtcbiAgICAgICAgICAgICAgICBrMSA9IF94ODZNdWx0aXBseShrMSwgYzEpO1xuICAgICAgICAgICAgICAgIGsxID0gX3g4NlJvdGwoazEsIDE1KTtcbiAgICAgICAgICAgICAgICBrMSA9IF94ODZNdWx0aXBseShrMSwgYzIpO1xuICAgICAgICAgICAgICAgIGgxIF49IGsxO1xuICAgICAgICB9XG5cbiAgICAgICAgaDEgXj0gYnl0ZXMubGVuZ3RoO1xuICAgICAgICBoMiBePSBieXRlcy5sZW5ndGg7XG4gICAgICAgIGgzIF49IGJ5dGVzLmxlbmd0aDtcbiAgICAgICAgaDQgXj0gYnl0ZXMubGVuZ3RoO1xuXG4gICAgICAgIGgxICs9IGgyO1xuICAgICAgICBoMSArPSBoMztcbiAgICAgICAgaDEgKz0gaDQ7XG4gICAgICAgIGgyICs9IGgxO1xuICAgICAgICBoMyArPSBoMTtcbiAgICAgICAgaDQgKz0gaDE7XG5cbiAgICAgICAgaDEgPSBfeDg2Rm1peChoMSk7XG4gICAgICAgIGgyID0gX3g4NkZtaXgoaDIpO1xuICAgICAgICBoMyA9IF94ODZGbWl4KGgzKTtcbiAgICAgICAgaDQgPSBfeDg2Rm1peChoNCk7XG5cbiAgICAgICAgaDEgKz0gaDI7XG4gICAgICAgIGgxICs9IGgzO1xuICAgICAgICBoMSArPSBoNDtcbiAgICAgICAgaDIgKz0gaDE7XG4gICAgICAgIGgzICs9IGgxO1xuICAgICAgICBoNCArPSBoMTtcblxuICAgICAgICByZXR1cm4gKFwiMDAwMDAwMDBcIiArIChoMSA+Pj4gMCkudG9TdHJpbmcoMTYpKS5zbGljZSgtOCkgKyAoXCIwMDAwMDAwMFwiICsgKGgyID4+PiAwKS50b1N0cmluZygxNikpLnNsaWNlKC04KSArIChcIjAwMDAwMDAwXCIgKyAoaDMgPj4+IDApLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTgpICsgKFwiMDAwMDAwMDBcIiArIChoNCA+Pj4gMCkudG9TdHJpbmcoMTYpKS5zbGljZSgtOCk7XG4gICAgfTtcblxuICAgIGxpYnJhcnkueDY0Lmhhc2gxMjggPSBmdW5jdGlvbiAoYnl0ZXMsIHNlZWQpIHtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gR2l2ZW4gYSBzdHJpbmcgYW5kIGFuIG9wdGlvbmFsIHNlZWQgYXMgYW4gaW50LCByZXR1cm5zIGEgMTI4IGJpdFxuICAgICAgICAvLyBoYXNoIHVzaW5nIHRoZSB4NjQgZmxhdm9yIG9mIE11cm11ckhhc2gzLCBhcyBhbiB1bnNpZ25lZCBoZXguXG4gICAgICAgIC8vXG4gICAgICAgIGlmIChsaWJyYXJ5LmlucHV0VmFsaWRhdGlvbiAmJiAhX3ZhbGlkQnl0ZXMoYnl0ZXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHNlZWQgPSBzZWVkIHx8IDA7XG5cbiAgICAgICAgdmFyIHJlbWFpbmRlciA9IGJ5dGVzLmxlbmd0aCAlIDE2O1xuICAgICAgICB2YXIgYmxvY2tzID0gYnl0ZXMubGVuZ3RoIC0gcmVtYWluZGVyO1xuXG4gICAgICAgIHZhciBoMSA9IFswLCBzZWVkXTtcbiAgICAgICAgdmFyIGgyID0gWzAsIHNlZWRdO1xuXG4gICAgICAgIHZhciBrMSA9IFswLCAwXTtcbiAgICAgICAgdmFyIGsyID0gWzAsIDBdO1xuXG4gICAgICAgIHZhciBjMSA9IFsweDg3YzM3YjkxLCAweDExNDI1M2Q1XTtcbiAgICAgICAgdmFyIGMyID0gWzB4NGNmNWFkNDMsIDB4Mjc0NTkzN2ZdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmxvY2tzOyBpID0gaSArIDE2KSB7XG4gICAgICAgICAgICBrMSA9IFsoYnl0ZXNbaSArIDRdKSB8IChieXRlc1tpICsgNV0gPDwgOCkgfCAoYnl0ZXNbaSArIDZdIDw8IDE2KSB8IChieXRlc1tpICsgN10gPDwgMjQpLCAoYnl0ZXNbaV0pIHxcbiAgICAgICAgICAgICAgICAoYnl0ZXNbaSArIDFdIDw8IDgpIHwgKGJ5dGVzW2kgKyAyXSA8PCAxNikgfCAoYnl0ZXNbaSArIDNdIDw8IDI0KV07XG4gICAgICAgICAgICBrMiA9IFsoYnl0ZXNbaSArIDEyXSkgfCAoYnl0ZXNbaSArIDEzXSA8PCA4KSB8IChieXRlc1tpICsgMTRdIDw8IDE2KSB8IChieXRlc1tpICsgMTVdIDw8IDI0KSwgKGJ5dGVzW2kgKyA4XSkgfFxuICAgICAgICAgICAgICAgIChieXRlc1tpICsgOV0gPDwgOCkgfCAoYnl0ZXNbaSArIDEwXSA8PCAxNikgfCAoYnl0ZXNbaSArIDExXSA8PCAyNCldO1xuXG4gICAgICAgICAgICBrMSA9IF94NjRNdWx0aXBseShrMSwgYzEpO1xuICAgICAgICAgICAgazEgPSBfeDY0Um90bChrMSwgMzEpO1xuICAgICAgICAgICAgazEgPSBfeDY0TXVsdGlwbHkoazEsIGMyKTtcbiAgICAgICAgICAgIGgxID0gX3g2NFhvcihoMSwgazEpO1xuXG4gICAgICAgICAgICBoMSA9IF94NjRSb3RsKGgxLCAyNyk7XG4gICAgICAgICAgICBoMSA9IF94NjRBZGQoaDEsIGgyKTtcbiAgICAgICAgICAgIGgxID0gX3g2NEFkZChfeDY0TXVsdGlwbHkoaDEsIFswLCA1XSksIFswLCAweDUyZGNlNzI5XSk7XG5cbiAgICAgICAgICAgIGsyID0gX3g2NE11bHRpcGx5KGsyLCBjMik7XG4gICAgICAgICAgICBrMiA9IF94NjRSb3RsKGsyLCAzMyk7XG4gICAgICAgICAgICBrMiA9IF94NjRNdWx0aXBseShrMiwgYzEpO1xuICAgICAgICAgICAgaDIgPSBfeDY0WG9yKGgyLCBrMik7XG5cbiAgICAgICAgICAgIGgyID0gX3g2NFJvdGwoaDIsIDMxKTtcbiAgICAgICAgICAgIGgyID0gX3g2NEFkZChoMiwgaDEpO1xuICAgICAgICAgICAgaDIgPSBfeDY0QWRkKF94NjRNdWx0aXBseShoMiwgWzAsIDVdKSwgWzAsIDB4Mzg0OTVhYjVdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGsxID0gWzAsIDBdO1xuICAgICAgICBrMiA9IFswLCAwXTtcblxuICAgICAgICBzd2l0Y2ggKHJlbWFpbmRlcikge1xuICAgICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgICAgICBrMiA9IF94NjRYb3IoazIsIF94NjRMZWZ0U2hpZnQoWzAsIGJ5dGVzW2kgKyAxNF1dLCA0OCkpO1xuXG4gICAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgICAgIGsyID0gX3g2NFhvcihrMiwgX3g2NExlZnRTaGlmdChbMCwgYnl0ZXNbaSArIDEzXV0sIDQwKSk7XG5cbiAgICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICAgICAgazIgPSBfeDY0WG9yKGsyLCBfeDY0TGVmdFNoaWZ0KFswLCBieXRlc1tpICsgMTJdXSwgMzIpKTtcblxuICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgICAgICBrMiA9IF94NjRYb3IoazIsIF94NjRMZWZ0U2hpZnQoWzAsIGJ5dGVzW2kgKyAxMV1dLCAyNCkpO1xuXG4gICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICAgIGsyID0gX3g2NFhvcihrMiwgX3g2NExlZnRTaGlmdChbMCwgYnl0ZXNbaSArIDEwXV0sIDE2KSk7XG5cbiAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgICAgazIgPSBfeDY0WG9yKGsyLCBfeDY0TGVmdFNoaWZ0KFswLCBieXRlc1tpICsgOV1dLCA4KSk7XG5cbiAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICBrMiA9IF94NjRYb3IoazIsIFswLCBieXRlc1tpICsgOF1dKTtcbiAgICAgICAgICAgICAgICBrMiA9IF94NjRNdWx0aXBseShrMiwgYzIpO1xuICAgICAgICAgICAgICAgIGsyID0gX3g2NFJvdGwoazIsIDMzKTtcbiAgICAgICAgICAgICAgICBrMiA9IF94NjRNdWx0aXBseShrMiwgYzEpO1xuICAgICAgICAgICAgICAgIGgyID0gX3g2NFhvcihoMiwgazIpO1xuXG4gICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgazEgPSBfeDY0WG9yKGsxLCBfeDY0TGVmdFNoaWZ0KFswLCBieXRlc1tpICsgN11dLCA1NikpO1xuXG4gICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgazEgPSBfeDY0WG9yKGsxLCBfeDY0TGVmdFNoaWZ0KFswLCBieXRlc1tpICsgNl1dLCA0OCkpO1xuXG4gICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgazEgPSBfeDY0WG9yKGsxLCBfeDY0TGVmdFNoaWZ0KFswLCBieXRlc1tpICsgNV1dLCA0MCkpO1xuXG4gICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgazEgPSBfeDY0WG9yKGsxLCBfeDY0TGVmdFNoaWZ0KFswLCBieXRlc1tpICsgNF1dLCAzMikpO1xuXG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgazEgPSBfeDY0WG9yKGsxLCBfeDY0TGVmdFNoaWZ0KFswLCBieXRlc1tpICsgM11dLCAyNCkpO1xuXG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgazEgPSBfeDY0WG9yKGsxLCBfeDY0TGVmdFNoaWZ0KFswLCBieXRlc1tpICsgMl1dLCAxNikpO1xuXG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgazEgPSBfeDY0WG9yKGsxLCBfeDY0TGVmdFNoaWZ0KFswLCBieXRlc1tpICsgMV1dLCA4KSk7XG5cbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBrMSA9IF94NjRYb3IoazEsIFswLCBieXRlc1tpXV0pO1xuICAgICAgICAgICAgICAgIGsxID0gX3g2NE11bHRpcGx5KGsxLCBjMSk7XG4gICAgICAgICAgICAgICAgazEgPSBfeDY0Um90bChrMSwgMzEpO1xuICAgICAgICAgICAgICAgIGsxID0gX3g2NE11bHRpcGx5KGsxLCBjMik7XG4gICAgICAgICAgICAgICAgaDEgPSBfeDY0WG9yKGgxLCBrMSk7XG4gICAgICAgIH1cblxuICAgICAgICBoMSA9IF94NjRYb3IoaDEsIFswLCBieXRlcy5sZW5ndGhdKTtcbiAgICAgICAgaDIgPSBfeDY0WG9yKGgyLCBbMCwgYnl0ZXMubGVuZ3RoXSk7XG5cbiAgICAgICAgaDEgPSBfeDY0QWRkKGgxLCBoMik7XG4gICAgICAgIGgyID0gX3g2NEFkZChoMiwgaDEpO1xuXG4gICAgICAgIGgxID0gX3g2NEZtaXgoaDEpO1xuICAgICAgICBoMiA9IF94NjRGbWl4KGgyKTtcblxuICAgICAgICBoMSA9IF94NjRBZGQoaDEsIGgyKTtcbiAgICAgICAgaDIgPSBfeDY0QWRkKGgyLCBoMSk7XG5cbiAgICAgICAgcmV0dXJuIChcIjAwMDAwMDAwXCIgKyAoaDFbMF0gPj4+IDApLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTgpICsgKFwiMDAwMDAwMDBcIiArIChoMVsxXSA+Pj4gMCkudG9TdHJpbmcoMTYpKS5zbGljZSgtOCkgKyAoXCIwMDAwMDAwMFwiICsgKGgyWzBdID4+PiAwKS50b1N0cmluZygxNikpLnNsaWNlKC04KSArIChcIjAwMDAwMDAwXCIgKyAoaDJbMV0gPj4+IDApLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTgpO1xuICAgIH07XG5cbiAgICAvLyBJTklUSUFMSVpBVElPTlxuICAgIC8vIC0tLS0tLS0tLS0tLS0tXG5cbiAgICAvLyBFeHBvcnQgbXVybXVySGFzaDMgZm9yIENvbW1vbkpTLCBlaXRoZXIgYXMgYW4gQU1EIG1vZHVsZSBvciBqdXN0IGFzIHBhcnRcbiAgICAvLyBvZiB0aGUgZ2xvYmFsIG9iamVjdC5cbiAgICBpZiAodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSB7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICAgICAgICBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBsaWJyYXJ5O1xuICAgICAgICB9XG5cbiAgICAgICAgZXhwb3J0cy5tdXJtdXJIYXNoMyA9IGxpYnJhcnk7XG5cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuXG4gICAgICAgIGRlZmluZShbXSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGxpYnJhcnk7XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG5cbiAgICAgICAgLy8gVXNlIG11cm11ckhhc2gzLm5vQ29uZmxpY3QgdG8gcmVzdG9yZSBgbXVybXVySGFzaDNgIGJhY2sgdG8gaXRzXG4gICAgICAgIC8vIG9yaWdpbmFsIHZhbHVlLiBSZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBsaWJyYXJ5IG9iamVjdCwgdG8gYWxsb3dcbiAgICAgICAgLy8gaXQgdG8gYmUgdXNlZCB1bmRlciBhIGRpZmZlcmVudCBuYW1lLlxuICAgICAgICBsaWJyYXJ5Ll9tdXJtdXJIYXNoMyA9IHJvb3QubXVybXVySGFzaDM7XG5cbiAgICAgICAgbGlicmFyeS5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcm9vdC5tdXJtdXJIYXNoMyA9IGxpYnJhcnkuX211cm11ckhhc2gzO1xuICAgICAgICAgICAgbGlicmFyeS5fbXVybXVySGFzaDMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBsaWJyYXJ5Lm5vQ29uZmxpY3QgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgIHJldHVybiBsaWJyYXJ5O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJvb3QubXVybXVySGFzaDMgPSBsaWJyYXJ5O1xuICAgIH1cbn0pKHRoaXMpO1xuIiwgIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvbXVybXVySGFzaDNqcycpO1xuIiwgIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAdHlwZWRlZiB7eyBba2V5OiBzdHJpbmddOiBhbnkgfX0gRXh0ZW5zaW9uc1xuICogQHR5cGVkZWYge0Vycm9yfSBFcnJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBtZXNzYWdlXG4gKi9cblxuLyoqXG4gKlxuICogQHBhcmFtIHtFcnJvcn0gb2JqXG4gKiBAcGFyYW0ge0V4dGVuc2lvbnN9IHByb3BzXG4gKiBAcmV0dXJucyB7RXJyb3IgJiBFeHRlbnNpb25zfVxuICovXG5mdW5jdGlvbiBhc3NpZ24ob2JqLCBwcm9wcykge1xuICAgIGZvciAoY29uc3Qga2V5IGluIHByb3BzKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgICAgICAgdmFsdWU6IHByb3BzW2tleV0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gb2JqO1xufVxuXG4vKipcbiAqXG4gKiBAcGFyYW0ge2FueX0gZXJyIC0gQW4gRXJyb3JcbiAqIEBwYXJhbSB7c3RyaW5nfEV4dGVuc2lvbnN9IGNvZGUgLSBBIHN0cmluZyBjb2RlIG9yIHByb3BzIHRvIHNldCBvbiB0aGUgZXJyb3JcbiAqIEBwYXJhbSB7RXh0ZW5zaW9uc30gW3Byb3BzXSAtIFByb3BzIHRvIHNldCBvbiB0aGUgZXJyb3JcbiAqIEByZXR1cm5zIHtFcnJvciAmIEV4dGVuc2lvbnN9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUVycm9yKGVyciwgY29kZSwgcHJvcHMpIHtcbiAgICBpZiAoIWVyciB8fCB0eXBlb2YgZXJyID09PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQbGVhc2UgcGFzcyBhbiBFcnJvciB0byBlcnItY29kZScpO1xuICAgIH1cblxuICAgIGlmICghcHJvcHMpIHtcbiAgICAgICAgcHJvcHMgPSB7fTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGNvZGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHByb3BzID0gY29kZTtcbiAgICAgICAgY29kZSA9ICcnO1xuICAgIH1cblxuICAgIGlmIChjb2RlKSB7XG4gICAgICAgIHByb3BzLmNvZGUgPSBjb2RlO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBhc3NpZ24oZXJyLCBwcm9wcyk7XG4gICAgfSBjYXRjaCAoXykge1xuICAgICAgICBwcm9wcy5tZXNzYWdlID0gZXJyLm1lc3NhZ2U7XG4gICAgICAgIHByb3BzLnN0YWNrID0gZXJyLnN0YWNrO1xuXG4gICAgICAgIGNvbnN0IEVyckNsYXNzID0gZnVuY3Rpb24gKCkge307XG5cbiAgICAgICAgRXJyQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2YoZXJyKSk7XG5cbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBjb25zdCBvdXRwdXQgPSBhc3NpZ24obmV3IEVyckNsYXNzKCksIHByb3BzKTtcblxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVFcnJvcjtcbiIsICJcInVzZSBzdHJpY3RcIjtcclxubW9kdWxlLmV4cG9ydHMgPSBhc1Byb21pc2U7XHJcblxyXG4vKipcclxuICogQ2FsbGJhY2sgYXMgdXNlZCBieSB7QGxpbmsgdXRpbC5hc1Byb21pc2V9LlxyXG4gKiBAdHlwZWRlZiBhc1Byb21pc2VDYWxsYmFja1xyXG4gKiBAdHlwZSB7ZnVuY3Rpb259XHJcbiAqIEBwYXJhbSB7RXJyb3J8bnVsbH0gZXJyb3IgRXJyb3IsIGlmIGFueVxyXG4gKiBAcGFyYW0gey4uLip9IHBhcmFtcyBBZGRpdGlvbmFsIGFyZ3VtZW50c1xyXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgcHJvbWlzZSBmcm9tIGEgbm9kZS1zdHlsZSBjYWxsYmFjayBmdW5jdGlvbi5cclxuICogQG1lbWJlcm9mIHV0aWxcclxuICogQHBhcmFtIHthc1Byb21pc2VDYWxsYmFja30gZm4gRnVuY3Rpb24gdG8gY2FsbFxyXG4gKiBAcGFyYW0geyp9IGN0eCBGdW5jdGlvbiBjb250ZXh0XHJcbiAqIEBwYXJhbSB7Li4uKn0gcGFyYW1zIEZ1bmN0aW9uIGFyZ3VtZW50c1xyXG4gKiBAcmV0dXJucyB7UHJvbWlzZTwqPn0gUHJvbWlzaWZpZWQgZnVuY3Rpb25cclxuICovXHJcbmZ1bmN0aW9uIGFzUHJvbWlzZShmbiwgY3R4LyosIHZhcmFyZ3MgKi8pIHtcclxuICAgIHZhciBwYXJhbXMgID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKSxcclxuICAgICAgICBvZmZzZXQgID0gMCxcclxuICAgICAgICBpbmRleCAgID0gMixcclxuICAgICAgICBwZW5kaW5nID0gdHJ1ZTtcclxuICAgIHdoaWxlIChpbmRleCA8IGFyZ3VtZW50cy5sZW5ndGgpXHJcbiAgICAgICAgcGFyYW1zW29mZnNldCsrXSA9IGFyZ3VtZW50c1tpbmRleCsrXTtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiBleGVjdXRvcihyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBwYXJhbXNbb2Zmc2V0XSA9IGZ1bmN0aW9uIGNhbGxiYWNrKGVyci8qLCB2YXJhcmdzICovKSB7XHJcbiAgICAgICAgICAgIGlmIChwZW5kaW5nKSB7XHJcbiAgICAgICAgICAgICAgICBwZW5kaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXJyKVxyXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmFtcyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKG9mZnNldCA8IHBhcmFtcy5sZW5ndGgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtc1tvZmZzZXQrK10gPSBhcmd1bWVudHNbb2Zmc2V0XTtcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlLmFwcGx5KG51bGwsIHBhcmFtcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGZuLmFwcGx5KGN0eCB8fCBudWxsLCBwYXJhbXMpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICBpZiAocGVuZGluZykge1xyXG4gICAgICAgICAgICAgICAgcGVuZGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufVxyXG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4vKipcclxuICogQSBtaW5pbWFsIGJhc2U2NCBpbXBsZW1lbnRhdGlvbiBmb3IgbnVtYmVyIGFycmF5cy5cclxuICogQG1lbWJlcm9mIHV0aWxcclxuICogQG5hbWVzcGFjZVxyXG4gKi9cclxudmFyIGJhc2U2NCA9IGV4cG9ydHM7XHJcblxyXG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgYnl0ZSBsZW5ndGggb2YgYSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgQmFzZTY0IGVuY29kZWQgc3RyaW5nXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IEJ5dGUgbGVuZ3RoXHJcbiAqL1xyXG5iYXNlNjQubGVuZ3RoID0gZnVuY3Rpb24gbGVuZ3RoKHN0cmluZykge1xyXG4gICAgdmFyIHAgPSBzdHJpbmcubGVuZ3RoO1xyXG4gICAgaWYgKCFwKVxyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgdmFyIG4gPSAwO1xyXG4gICAgd2hpbGUgKC0tcCAlIDQgPiAxICYmIHN0cmluZy5jaGFyQXQocCkgPT09IFwiPVwiKVxyXG4gICAgICAgICsrbjtcclxuICAgIHJldHVybiBNYXRoLmNlaWwoc3RyaW5nLmxlbmd0aCAqIDMpIC8gNCAtIG47XHJcbn07XHJcblxyXG4vLyBCYXNlNjQgZW5jb2RpbmcgdGFibGVcclxudmFyIGI2NCA9IG5ldyBBcnJheSg2NCk7XHJcblxyXG4vLyBCYXNlNjQgZGVjb2RpbmcgdGFibGVcclxudmFyIHM2NCA9IG5ldyBBcnJheSgxMjMpO1xyXG5cclxuLy8gNjUuLjkwLCA5Ny4uMTIyLCA0OC4uNTcsIDQzLCA0N1xyXG5mb3IgKHZhciBpID0gMDsgaSA8IDY0OylcclxuICAgIHM2NFtiNjRbaV0gPSBpIDwgMjYgPyBpICsgNjUgOiBpIDwgNTIgPyBpICsgNzEgOiBpIDwgNjIgPyBpIC0gNCA6IGkgLSA1OSB8IDQzXSA9IGkrKztcclxuXHJcbi8qKlxyXG4gKiBFbmNvZGVzIGEgYnVmZmVyIHRvIGEgYmFzZTY0IGVuY29kZWQgc3RyaW5nLlxyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZmZlciBTb3VyY2UgYnVmZmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBTb3VyY2Ugc3RhcnRcclxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBTb3VyY2UgZW5kXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9IEJhc2U2NCBlbmNvZGVkIHN0cmluZ1xyXG4gKi9cclxuYmFzZTY0LmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShidWZmZXIsIHN0YXJ0LCBlbmQpIHtcclxuICAgIHZhciBwYXJ0cyA9IG51bGwsXHJcbiAgICAgICAgY2h1bmsgPSBbXTtcclxuICAgIHZhciBpID0gMCwgLy8gb3V0cHV0IGluZGV4XHJcbiAgICAgICAgaiA9IDAsIC8vIGdvdG8gaW5kZXhcclxuICAgICAgICB0OyAgICAgLy8gdGVtcG9yYXJ5XHJcbiAgICB3aGlsZSAoc3RhcnQgPCBlbmQpIHtcclxuICAgICAgICB2YXIgYiA9IGJ1ZmZlcltzdGFydCsrXTtcclxuICAgICAgICBzd2l0Y2ggKGopIHtcclxuICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgY2h1bmtbaSsrXSA9IGI2NFtiID4+IDJdO1xyXG4gICAgICAgICAgICAgICAgdCA9IChiICYgMykgPDwgNDtcclxuICAgICAgICAgICAgICAgIGogPSAxO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgIGNodW5rW2krK10gPSBiNjRbdCB8IGIgPj4gNF07XHJcbiAgICAgICAgICAgICAgICB0ID0gKGIgJiAxNSkgPDwgMjtcclxuICAgICAgICAgICAgICAgIGogPSAyO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgIGNodW5rW2krK10gPSBiNjRbdCB8IGIgPj4gNl07XHJcbiAgICAgICAgICAgICAgICBjaHVua1tpKytdID0gYjY0W2IgJiA2M107XHJcbiAgICAgICAgICAgICAgICBqID0gMDtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaSA+IDgxOTEpIHtcclxuICAgICAgICAgICAgKHBhcnRzIHx8IChwYXJ0cyA9IFtdKSkucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY2h1bmspKTtcclxuICAgICAgICAgICAgaSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGopIHtcclxuICAgICAgICBjaHVua1tpKytdID0gYjY0W3RdO1xyXG4gICAgICAgIGNodW5rW2krK10gPSA2MTtcclxuICAgICAgICBpZiAoaiA9PT0gMSlcclxuICAgICAgICAgICAgY2h1bmtbaSsrXSA9IDYxO1xyXG4gICAgfVxyXG4gICAgaWYgKHBhcnRzKSB7XHJcbiAgICAgICAgaWYgKGkpXHJcbiAgICAgICAgICAgIHBhcnRzLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNodW5rLnNsaWNlKDAsIGkpKSk7XHJcbiAgICAgICAgcmV0dXJuIHBhcnRzLmpvaW4oXCJcIik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNodW5rLnNsaWNlKDAsIGkpKTtcclxufTtcclxuXHJcbnZhciBpbnZhbGlkRW5jb2RpbmcgPSBcImludmFsaWQgZW5jb2RpbmdcIjtcclxuXHJcbi8qKlxyXG4gKiBEZWNvZGVzIGEgYmFzZTY0IGVuY29kZWQgc3RyaW5nIHRvIGEgYnVmZmVyLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFNvdXJjZSBzdHJpbmdcclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWZmZXIgRGVzdGluYXRpb24gYnVmZmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgRGVzdGluYXRpb24gb2Zmc2V0XHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IE51bWJlciBvZiBieXRlcyB3cml0dGVuXHJcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBlbmNvZGluZyBpcyBpbnZhbGlkXHJcbiAqL1xyXG5iYXNlNjQuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHN0cmluZywgYnVmZmVyLCBvZmZzZXQpIHtcclxuICAgIHZhciBzdGFydCA9IG9mZnNldDtcclxuICAgIHZhciBqID0gMCwgLy8gZ290byBpbmRleFxyXG4gICAgICAgIHQ7ICAgICAvLyB0ZW1wb3JhcnlcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyaW5nLmxlbmd0aDspIHtcclxuICAgICAgICB2YXIgYyA9IHN0cmluZy5jaGFyQ29kZUF0KGkrKyk7XHJcbiAgICAgICAgaWYgKGMgPT09IDYxICYmIGogPiAxKVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBpZiAoKGMgPSBzNjRbY10pID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKGludmFsaWRFbmNvZGluZyk7XHJcbiAgICAgICAgc3dpdGNoIChqKSB7XHJcbiAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgIHQgPSBjO1xyXG4gICAgICAgICAgICAgICAgaiA9IDE7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IHQgPDwgMiB8IChjICYgNDgpID4+IDQ7XHJcbiAgICAgICAgICAgICAgICB0ID0gYztcclxuICAgICAgICAgICAgICAgIGogPSAyO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSAodCAmIDE1KSA8PCA0IHwgKGMgJiA2MCkgPj4gMjtcclxuICAgICAgICAgICAgICAgIHQgPSBjO1xyXG4gICAgICAgICAgICAgICAgaiA9IDM7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9ICh0ICYgMykgPDwgNiB8IGM7XHJcbiAgICAgICAgICAgICAgICBqID0gMDtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChqID09PSAxKVxyXG4gICAgICAgIHRocm93IEVycm9yKGludmFsaWRFbmNvZGluZyk7XHJcbiAgICByZXR1cm4gb2Zmc2V0IC0gc3RhcnQ7XHJcbn07XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhlIHNwZWNpZmllZCBzdHJpbmcgYXBwZWFycyB0byBiZSBiYXNlNjQgZW5jb2RlZC5cclxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBTdHJpbmcgdG8gdGVzdFxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHByb2JhYmx5IGJhc2U2NCBlbmNvZGVkLCBvdGhlcndpc2UgZmFsc2VcclxuICovXHJcbmJhc2U2NC50ZXN0ID0gZnVuY3Rpb24gdGVzdChzdHJpbmcpIHtcclxuICAgIHJldHVybiAvXig/OltBLVphLXowLTkrL117NH0pKig/OltBLVphLXowLTkrL117Mn09PXxbQS1aYS16MC05Ky9dezN9PSk/JC8udGVzdChzdHJpbmcpO1xyXG59O1xyXG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XHJcbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xyXG5cclxuLyoqXHJcbiAqIENvbnN0cnVjdHMgYSBuZXcgZXZlbnQgZW1pdHRlciBpbnN0YW5jZS5cclxuICogQGNsYXNzZGVzYyBBIG1pbmltYWwgZXZlbnQgZW1pdHRlci5cclxuICogQG1lbWJlcm9mIHV0aWxcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWdpc3RlcmVkIGxpc3RlbmVycy5cclxuICAgICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywqPn1cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuX2xpc3RlbmVycyA9IHt9O1xyXG59XHJcblxyXG4vKipcclxuICogUmVnaXN0ZXJzIGFuIGV2ZW50IGxpc3RlbmVyLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZ0IEV2ZW50IG5hbWVcclxuICogQHBhcmFtIHtmdW5jdGlvbn0gZm4gTGlzdGVuZXJcclxuICogQHBhcmFtIHsqfSBbY3R4XSBMaXN0ZW5lciBjb250ZXh0XHJcbiAqIEByZXR1cm5zIHt1dGlsLkV2ZW50RW1pdHRlcn0gYHRoaXNgXHJcbiAqL1xyXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gb24oZXZ0LCBmbiwgY3R4KSB7XHJcbiAgICAodGhpcy5fbGlzdGVuZXJzW2V2dF0gfHwgKHRoaXMuX2xpc3RlbmVyc1tldnRdID0gW10pKS5wdXNoKHtcclxuICAgICAgICBmbiAgOiBmbixcclxuICAgICAgICBjdHggOiBjdHggfHwgdGhpc1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZW1vdmVzIGFuIGV2ZW50IGxpc3RlbmVyIG9yIGFueSBtYXRjaGluZyBsaXN0ZW5lcnMgaWYgYXJndW1lbnRzIGFyZSBvbWl0dGVkLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gW2V2dF0gRXZlbnQgbmFtZS4gUmVtb3ZlcyBhbGwgbGlzdGVuZXJzIGlmIG9taXR0ZWQuXHJcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtmbl0gTGlzdGVuZXIgdG8gcmVtb3ZlLiBSZW1vdmVzIGFsbCBsaXN0ZW5lcnMgb2YgYGV2dGAgaWYgb21pdHRlZC5cclxuICogQHJldHVybnMge3V0aWwuRXZlbnRFbWl0dGVyfSBgdGhpc2BcclxuICovXHJcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24gb2ZmKGV2dCwgZm4pIHtcclxuICAgIGlmIChldnQgPT09IHVuZGVmaW5lZClcclxuICAgICAgICB0aGlzLl9saXN0ZW5lcnMgPSB7fTtcclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGlmIChmbiA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICB0aGlzLl9saXN0ZW5lcnNbZXZ0XSA9IFtdO1xyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzW2V2dF07XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDspXHJcbiAgICAgICAgICAgICAgICBpZiAobGlzdGVuZXJzW2ldLmZuID09PSBmbilcclxuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICsraTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBFbWl0cyBhbiBldmVudCBieSBjYWxsaW5nIGl0cyBsaXN0ZW5lcnMgd2l0aCB0aGUgc3BlY2lmaWVkIGFyZ3VtZW50cy5cclxuICogQHBhcmFtIHtzdHJpbmd9IGV2dCBFdmVudCBuYW1lXHJcbiAqIEBwYXJhbSB7Li4uKn0gYXJncyBBcmd1bWVudHNcclxuICogQHJldHVybnMge3V0aWwuRXZlbnRFbWl0dGVyfSBgdGhpc2BcclxuICovXHJcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQoZXZ0KSB7XHJcbiAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzW2V2dF07XHJcbiAgICBpZiAobGlzdGVuZXJzKSB7XHJcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSxcclxuICAgICAgICAgICAgaSA9IDE7XHJcbiAgICAgICAgZm9yICg7IGkgPCBhcmd1bWVudHMubGVuZ3RoOylcclxuICAgICAgICAgICAgYXJncy5wdXNoKGFyZ3VtZW50c1tpKytdKTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDspXHJcbiAgICAgICAgICAgIGxpc3RlbmVyc1tpXS5mbi5hcHBseShsaXN0ZW5lcnNbaSsrXS5jdHgsIGFyZ3MpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcbiIsICJcInVzZSBzdHJpY3RcIjtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShmYWN0b3J5KTtcclxuXHJcbi8qKlxyXG4gKiBSZWFkcyAvIHdyaXRlcyBmbG9hdHMgLyBkb3VibGVzIGZyb20gLyB0byBidWZmZXJzLlxyXG4gKiBAbmFtZSB1dGlsLmZsb2F0XHJcbiAqIEBuYW1lc3BhY2VcclxuICovXHJcblxyXG4vKipcclxuICogV3JpdGVzIGEgMzIgYml0IGZsb2F0IHRvIGEgYnVmZmVyIHVzaW5nIGxpdHRsZSBlbmRpYW4gYnl0ZSBvcmRlci5cclxuICogQG5hbWUgdXRpbC5mbG9hdC53cml0ZUZsb2F0TEVcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgVmFsdWUgdG8gd3JpdGVcclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWYgVGFyZ2V0IGJ1ZmZlclxyXG4gKiBAcGFyYW0ge251bWJlcn0gcG9zIFRhcmdldCBidWZmZXIgb2Zmc2V0XHJcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFdyaXRlcyBhIDMyIGJpdCBmbG9hdCB0byBhIGJ1ZmZlciB1c2luZyBiaWcgZW5kaWFuIGJ5dGUgb3JkZXIuXHJcbiAqIEBuYW1lIHV0aWwuZmxvYXQud3JpdGVGbG9hdEJFXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsIFZhbHVlIHRvIHdyaXRlXHJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmIFRhcmdldCBidWZmZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IHBvcyBUYXJnZXQgYnVmZmVyIG9mZnNldFxyXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBSZWFkcyBhIDMyIGJpdCBmbG9hdCBmcm9tIGEgYnVmZmVyIHVzaW5nIGxpdHRsZSBlbmRpYW4gYnl0ZSBvcmRlci5cclxuICogQG5hbWUgdXRpbC5mbG9hdC5yZWFkRmxvYXRMRVxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWYgU291cmNlIGJ1ZmZlclxyXG4gKiBAcGFyYW0ge251bWJlcn0gcG9zIFNvdXJjZSBidWZmZXIgb2Zmc2V0XHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcclxuICovXHJcblxyXG4vKipcclxuICogUmVhZHMgYSAzMiBiaXQgZmxvYXQgZnJvbSBhIGJ1ZmZlciB1c2luZyBiaWcgZW5kaWFuIGJ5dGUgb3JkZXIuXHJcbiAqIEBuYW1lIHV0aWwuZmxvYXQucmVhZEZsb2F0QkVcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmIFNvdXJjZSBidWZmZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IHBvcyBTb3VyY2UgYnVmZmVyIG9mZnNldFxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFdyaXRlcyBhIDY0IGJpdCBkb3VibGUgdG8gYSBidWZmZXIgdXNpbmcgbGl0dGxlIGVuZGlhbiBieXRlIG9yZGVyLlxyXG4gKiBAbmFtZSB1dGlsLmZsb2F0LndyaXRlRG91YmxlTEVcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgVmFsdWUgdG8gd3JpdGVcclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWYgVGFyZ2V0IGJ1ZmZlclxyXG4gKiBAcGFyYW0ge251bWJlcn0gcG9zIFRhcmdldCBidWZmZXIgb2Zmc2V0XHJcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFdyaXRlcyBhIDY0IGJpdCBkb3VibGUgdG8gYSBidWZmZXIgdXNpbmcgYmlnIGVuZGlhbiBieXRlIG9yZGVyLlxyXG4gKiBAbmFtZSB1dGlsLmZsb2F0LndyaXRlRG91YmxlQkVcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgVmFsdWUgdG8gd3JpdGVcclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWYgVGFyZ2V0IGJ1ZmZlclxyXG4gKiBAcGFyYW0ge251bWJlcn0gcG9zIFRhcmdldCBidWZmZXIgb2Zmc2V0XHJcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFJlYWRzIGEgNjQgYml0IGRvdWJsZSBmcm9tIGEgYnVmZmVyIHVzaW5nIGxpdHRsZSBlbmRpYW4gYnl0ZSBvcmRlci5cclxuICogQG5hbWUgdXRpbC5mbG9hdC5yZWFkRG91YmxlTEVcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmIFNvdXJjZSBidWZmZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IHBvcyBTb3VyY2UgYnVmZmVyIG9mZnNldFxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFJlYWRzIGEgNjQgYml0IGRvdWJsZSBmcm9tIGEgYnVmZmVyIHVzaW5nIGJpZyBlbmRpYW4gYnl0ZSBvcmRlci5cclxuICogQG5hbWUgdXRpbC5mbG9hdC5yZWFkRG91YmxlQkVcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmIFNvdXJjZSBidWZmZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IHBvcyBTb3VyY2UgYnVmZmVyIG9mZnNldFxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXHJcbiAqL1xyXG5cclxuLy8gRmFjdG9yeSBmdW5jdGlvbiBmb3IgdGhlIHB1cnBvc2Ugb2Ygbm9kZS1iYXNlZCB0ZXN0aW5nIGluIG1vZGlmaWVkIGdsb2JhbCBlbnZpcm9ubWVudHNcclxuZnVuY3Rpb24gZmFjdG9yeShleHBvcnRzKSB7XHJcblxyXG4gICAgLy8gZmxvYXQ6IHR5cGVkIGFycmF5XHJcbiAgICBpZiAodHlwZW9mIEZsb2F0MzJBcnJheSAhPT0gXCJ1bmRlZmluZWRcIikgKGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgICB2YXIgZjMyID0gbmV3IEZsb2F0MzJBcnJheShbIC0wIF0pLFxyXG4gICAgICAgICAgICBmOGIgPSBuZXcgVWludDhBcnJheShmMzIuYnVmZmVyKSxcclxuICAgICAgICAgICAgbGUgID0gZjhiWzNdID09PSAxMjg7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHdyaXRlRmxvYXRfZjMyX2NweSh2YWwsIGJ1ZiwgcG9zKSB7XHJcbiAgICAgICAgICAgIGYzMlswXSA9IHZhbDtcclxuICAgICAgICAgICAgYnVmW3BvcyAgICBdID0gZjhiWzBdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgMV0gPSBmOGJbMV07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyAyXSA9IGY4YlsyXTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDNdID0gZjhiWzNdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gd3JpdGVGbG9hdF9mMzJfcmV2KHZhbCwgYnVmLCBwb3MpIHtcclxuICAgICAgICAgICAgZjMyWzBdID0gdmFsO1xyXG4gICAgICAgICAgICBidWZbcG9zICAgIF0gPSBmOGJbM107XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyAxXSA9IGY4YlsyXTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDJdID0gZjhiWzFdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgM10gPSBmOGJbMF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIGV4cG9ydHMud3JpdGVGbG9hdExFID0gbGUgPyB3cml0ZUZsb2F0X2YzMl9jcHkgOiB3cml0ZUZsb2F0X2YzMl9yZXY7XHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICBleHBvcnRzLndyaXRlRmxvYXRCRSA9IGxlID8gd3JpdGVGbG9hdF9mMzJfcmV2IDogd3JpdGVGbG9hdF9mMzJfY3B5O1xyXG5cclxuICAgICAgICBmdW5jdGlvbiByZWFkRmxvYXRfZjMyX2NweShidWYsIHBvcykge1xyXG4gICAgICAgICAgICBmOGJbMF0gPSBidWZbcG9zICAgIF07XHJcbiAgICAgICAgICAgIGY4YlsxXSA9IGJ1Zltwb3MgKyAxXTtcclxuICAgICAgICAgICAgZjhiWzJdID0gYnVmW3BvcyArIDJdO1xyXG4gICAgICAgICAgICBmOGJbM10gPSBidWZbcG9zICsgM107XHJcbiAgICAgICAgICAgIHJldHVybiBmMzJbMF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiByZWFkRmxvYXRfZjMyX3JldihidWYsIHBvcykge1xyXG4gICAgICAgICAgICBmOGJbM10gPSBidWZbcG9zICAgIF07XHJcbiAgICAgICAgICAgIGY4YlsyXSA9IGJ1Zltwb3MgKyAxXTtcclxuICAgICAgICAgICAgZjhiWzFdID0gYnVmW3BvcyArIDJdO1xyXG4gICAgICAgICAgICBmOGJbMF0gPSBidWZbcG9zICsgM107XHJcbiAgICAgICAgICAgIHJldHVybiBmMzJbMF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIGV4cG9ydHMucmVhZEZsb2F0TEUgPSBsZSA/IHJlYWRGbG9hdF9mMzJfY3B5IDogcmVhZEZsb2F0X2YzMl9yZXY7XHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICBleHBvcnRzLnJlYWRGbG9hdEJFID0gbGUgPyByZWFkRmxvYXRfZjMyX3JldiA6IHJlYWRGbG9hdF9mMzJfY3B5O1xyXG5cclxuICAgIC8vIGZsb2F0OiBpZWVlNzU0XHJcbiAgICB9KSgpOyBlbHNlIChmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gd3JpdGVGbG9hdF9pZWVlNzU0KHdyaXRlVWludCwgdmFsLCBidWYsIHBvcykge1xyXG4gICAgICAgICAgICB2YXIgc2lnbiA9IHZhbCA8IDAgPyAxIDogMDtcclxuICAgICAgICAgICAgaWYgKHNpZ24pXHJcbiAgICAgICAgICAgICAgICB2YWwgPSAtdmFsO1xyXG4gICAgICAgICAgICBpZiAodmFsID09PSAwKVxyXG4gICAgICAgICAgICAgICAgd3JpdGVVaW50KDEgLyB2YWwgPiAwID8gLyogcG9zaXRpdmUgKi8gMCA6IC8qIG5lZ2F0aXZlIDAgKi8gMjE0NzQ4MzY0OCwgYnVmLCBwb3MpO1xyXG4gICAgICAgICAgICBlbHNlIGlmIChpc05hTih2YWwpKVxyXG4gICAgICAgICAgICAgICAgd3JpdGVVaW50KDIxNDMyODkzNDQsIGJ1ZiwgcG9zKTtcclxuICAgICAgICAgICAgZWxzZSBpZiAodmFsID4gMy40MDI4MjM0NjYzODUyODg2ZSszOCkgLy8gKy1JbmZpbml0eVxyXG4gICAgICAgICAgICAgICAgd3JpdGVVaW50KChzaWduIDw8IDMxIHwgMjEzOTA5NTA0MCkgPj4+IDAsIGJ1ZiwgcG9zKTtcclxuICAgICAgICAgICAgZWxzZSBpZiAodmFsIDwgMS4xNzU0OTQzNTA4MjIyODc1ZS0zOCkgLy8gZGVub3JtYWxcclxuICAgICAgICAgICAgICAgIHdyaXRlVWludCgoc2lnbiA8PCAzMSB8IE1hdGgucm91bmQodmFsIC8gMS40MDEyOTg0NjQzMjQ4MTdlLTQ1KSkgPj4+IDAsIGJ1ZiwgcG9zKTtcclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZXhwb25lbnQgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbCkgLyBNYXRoLkxOMiksXHJcbiAgICAgICAgICAgICAgICAgICAgbWFudGlzc2EgPSBNYXRoLnJvdW5kKHZhbCAqIE1hdGgucG93KDIsIC1leHBvbmVudCkgKiA4Mzg4NjA4KSAmIDgzODg2MDc7XHJcbiAgICAgICAgICAgICAgICB3cml0ZVVpbnQoKHNpZ24gPDwgMzEgfCBleHBvbmVudCArIDEyNyA8PCAyMyB8IG1hbnRpc3NhKSA+Pj4gMCwgYnVmLCBwb3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBleHBvcnRzLndyaXRlRmxvYXRMRSA9IHdyaXRlRmxvYXRfaWVlZTc1NC5iaW5kKG51bGwsIHdyaXRlVWludExFKTtcclxuICAgICAgICBleHBvcnRzLndyaXRlRmxvYXRCRSA9IHdyaXRlRmxvYXRfaWVlZTc1NC5iaW5kKG51bGwsIHdyaXRlVWludEJFKTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gcmVhZEZsb2F0X2llZWU3NTQocmVhZFVpbnQsIGJ1ZiwgcG9zKSB7XHJcbiAgICAgICAgICAgIHZhciB1aW50ID0gcmVhZFVpbnQoYnVmLCBwb3MpLFxyXG4gICAgICAgICAgICAgICAgc2lnbiA9ICh1aW50ID4+IDMxKSAqIDIgKyAxLFxyXG4gICAgICAgICAgICAgICAgZXhwb25lbnQgPSB1aW50ID4+PiAyMyAmIDI1NSxcclxuICAgICAgICAgICAgICAgIG1hbnRpc3NhID0gdWludCAmIDgzODg2MDc7XHJcbiAgICAgICAgICAgIHJldHVybiBleHBvbmVudCA9PT0gMjU1XHJcbiAgICAgICAgICAgICAgICA/IG1hbnRpc3NhXHJcbiAgICAgICAgICAgICAgICA/IE5hTlxyXG4gICAgICAgICAgICAgICAgOiBzaWduICogSW5maW5pdHlcclxuICAgICAgICAgICAgICAgIDogZXhwb25lbnQgPT09IDAgLy8gZGVub3JtYWxcclxuICAgICAgICAgICAgICAgID8gc2lnbiAqIDEuNDAxMjk4NDY0MzI0ODE3ZS00NSAqIG1hbnRpc3NhXHJcbiAgICAgICAgICAgICAgICA6IHNpZ24gKiBNYXRoLnBvdygyLCBleHBvbmVudCAtIDE1MCkgKiAobWFudGlzc2EgKyA4Mzg4NjA4KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGV4cG9ydHMucmVhZEZsb2F0TEUgPSByZWFkRmxvYXRfaWVlZTc1NC5iaW5kKG51bGwsIHJlYWRVaW50TEUpO1xyXG4gICAgICAgIGV4cG9ydHMucmVhZEZsb2F0QkUgPSByZWFkRmxvYXRfaWVlZTc1NC5iaW5kKG51bGwsIHJlYWRVaW50QkUpO1xyXG5cclxuICAgIH0pKCk7XHJcblxyXG4gICAgLy8gZG91YmxlOiB0eXBlZCBhcnJheVxyXG4gICAgaWYgKHR5cGVvZiBGbG9hdDY0QXJyYXkgIT09IFwidW5kZWZpbmVkXCIpIChmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgICAgdmFyIGY2NCA9IG5ldyBGbG9hdDY0QXJyYXkoWy0wXSksXHJcbiAgICAgICAgICAgIGY4YiA9IG5ldyBVaW50OEFycmF5KGY2NC5idWZmZXIpLFxyXG4gICAgICAgICAgICBsZSAgPSBmOGJbN10gPT09IDEyODtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gd3JpdGVEb3VibGVfZjY0X2NweSh2YWwsIGJ1ZiwgcG9zKSB7XHJcbiAgICAgICAgICAgIGY2NFswXSA9IHZhbDtcclxuICAgICAgICAgICAgYnVmW3BvcyAgICBdID0gZjhiWzBdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgMV0gPSBmOGJbMV07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyAyXSA9IGY4YlsyXTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDNdID0gZjhiWzNdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgNF0gPSBmOGJbNF07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyA1XSA9IGY4Yls1XTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDZdID0gZjhiWzZdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgN10gPSBmOGJbN107XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiB3cml0ZURvdWJsZV9mNjRfcmV2KHZhbCwgYnVmLCBwb3MpIHtcclxuICAgICAgICAgICAgZjY0WzBdID0gdmFsO1xyXG4gICAgICAgICAgICBidWZbcG9zICAgIF0gPSBmOGJbN107XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyAxXSA9IGY4Yls2XTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDJdID0gZjhiWzVdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgM10gPSBmOGJbNF07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyA0XSA9IGY4YlszXTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDVdID0gZjhiWzJdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgNl0gPSBmOGJbMV07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyA3XSA9IGY4YlswXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgZXhwb3J0cy53cml0ZURvdWJsZUxFID0gbGUgPyB3cml0ZURvdWJsZV9mNjRfY3B5IDogd3JpdGVEb3VibGVfZjY0X3JldjtcclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIGV4cG9ydHMud3JpdGVEb3VibGVCRSA9IGxlID8gd3JpdGVEb3VibGVfZjY0X3JldiA6IHdyaXRlRG91YmxlX2Y2NF9jcHk7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHJlYWREb3VibGVfZjY0X2NweShidWYsIHBvcykge1xyXG4gICAgICAgICAgICBmOGJbMF0gPSBidWZbcG9zICAgIF07XHJcbiAgICAgICAgICAgIGY4YlsxXSA9IGJ1Zltwb3MgKyAxXTtcclxuICAgICAgICAgICAgZjhiWzJdID0gYnVmW3BvcyArIDJdO1xyXG4gICAgICAgICAgICBmOGJbM10gPSBidWZbcG9zICsgM107XHJcbiAgICAgICAgICAgIGY4Yls0XSA9IGJ1Zltwb3MgKyA0XTtcclxuICAgICAgICAgICAgZjhiWzVdID0gYnVmW3BvcyArIDVdO1xyXG4gICAgICAgICAgICBmOGJbNl0gPSBidWZbcG9zICsgNl07XHJcbiAgICAgICAgICAgIGY4Yls3XSA9IGJ1Zltwb3MgKyA3XTtcclxuICAgICAgICAgICAgcmV0dXJuIGY2NFswXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHJlYWREb3VibGVfZjY0X3JldihidWYsIHBvcykge1xyXG4gICAgICAgICAgICBmOGJbN10gPSBidWZbcG9zICAgIF07XHJcbiAgICAgICAgICAgIGY4Yls2XSA9IGJ1Zltwb3MgKyAxXTtcclxuICAgICAgICAgICAgZjhiWzVdID0gYnVmW3BvcyArIDJdO1xyXG4gICAgICAgICAgICBmOGJbNF0gPSBidWZbcG9zICsgM107XHJcbiAgICAgICAgICAgIGY4YlszXSA9IGJ1Zltwb3MgKyA0XTtcclxuICAgICAgICAgICAgZjhiWzJdID0gYnVmW3BvcyArIDVdO1xyXG4gICAgICAgICAgICBmOGJbMV0gPSBidWZbcG9zICsgNl07XHJcbiAgICAgICAgICAgIGY4YlswXSA9IGJ1Zltwb3MgKyA3XTtcclxuICAgICAgICAgICAgcmV0dXJuIGY2NFswXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgZXhwb3J0cy5yZWFkRG91YmxlTEUgPSBsZSA/IHJlYWREb3VibGVfZjY0X2NweSA6IHJlYWREb3VibGVfZjY0X3JldjtcclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIGV4cG9ydHMucmVhZERvdWJsZUJFID0gbGUgPyByZWFkRG91YmxlX2Y2NF9yZXYgOiByZWFkRG91YmxlX2Y2NF9jcHk7XHJcblxyXG4gICAgLy8gZG91YmxlOiBpZWVlNzU0XHJcbiAgICB9KSgpOyBlbHNlIChmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gd3JpdGVEb3VibGVfaWVlZTc1NCh3cml0ZVVpbnQsIG9mZjAsIG9mZjEsIHZhbCwgYnVmLCBwb3MpIHtcclxuICAgICAgICAgICAgdmFyIHNpZ24gPSB2YWwgPCAwID8gMSA6IDA7XHJcbiAgICAgICAgICAgIGlmIChzaWduKVxyXG4gICAgICAgICAgICAgICAgdmFsID0gLXZhbDtcclxuICAgICAgICAgICAgaWYgKHZhbCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgd3JpdGVVaW50KDAsIGJ1ZiwgcG9zICsgb2ZmMCk7XHJcbiAgICAgICAgICAgICAgICB3cml0ZVVpbnQoMSAvIHZhbCA+IDAgPyAvKiBwb3NpdGl2ZSAqLyAwIDogLyogbmVnYXRpdmUgMCAqLyAyMTQ3NDgzNjQ4LCBidWYsIHBvcyArIG9mZjEpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzTmFOKHZhbCkpIHtcclxuICAgICAgICAgICAgICAgIHdyaXRlVWludCgwLCBidWYsIHBvcyArIG9mZjApO1xyXG4gICAgICAgICAgICAgICAgd3JpdGVVaW50KDIxNDY5NTkzNjAsIGJ1ZiwgcG9zICsgb2ZmMSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsID4gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDgpIHsgLy8gKy1JbmZpbml0eVxyXG4gICAgICAgICAgICAgICAgd3JpdGVVaW50KDAsIGJ1ZiwgcG9zICsgb2ZmMCk7XHJcbiAgICAgICAgICAgICAgICB3cml0ZVVpbnQoKHNpZ24gPDwgMzEgfCAyMTQ2NDM1MDcyKSA+Pj4gMCwgYnVmLCBwb3MgKyBvZmYxKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciBtYW50aXNzYTtcclxuICAgICAgICAgICAgICAgIGlmICh2YWwgPCAyLjIyNTA3Mzg1ODUwNzIwMTRlLTMwOCkgeyAvLyBkZW5vcm1hbFxyXG4gICAgICAgICAgICAgICAgICAgIG1hbnRpc3NhID0gdmFsIC8gNWUtMzI0O1xyXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlVWludChtYW50aXNzYSA+Pj4gMCwgYnVmLCBwb3MgKyBvZmYwKTtcclxuICAgICAgICAgICAgICAgICAgICB3cml0ZVVpbnQoKHNpZ24gPDwgMzEgfCBtYW50aXNzYSAvIDQyOTQ5NjcyOTYpID4+PiAwLCBidWYsIHBvcyArIG9mZjEpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZXhwb25lbnQgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbCkgLyBNYXRoLkxOMik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4cG9uZW50ID09PSAxMDI0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBvbmVudCA9IDEwMjM7XHJcbiAgICAgICAgICAgICAgICAgICAgbWFudGlzc2EgPSB2YWwgKiBNYXRoLnBvdygyLCAtZXhwb25lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlVWludChtYW50aXNzYSAqIDQ1MDM1OTk2MjczNzA0OTYgPj4+IDAsIGJ1ZiwgcG9zICsgb2ZmMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVVaW50KChzaWduIDw8IDMxIHwgZXhwb25lbnQgKyAxMDIzIDw8IDIwIHwgbWFudGlzc2EgKiAxMDQ4NTc2ICYgMTA0ODU3NSkgPj4+IDAsIGJ1ZiwgcG9zICsgb2ZmMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGV4cG9ydHMud3JpdGVEb3VibGVMRSA9IHdyaXRlRG91YmxlX2llZWU3NTQuYmluZChudWxsLCB3cml0ZVVpbnRMRSwgMCwgNCk7XHJcbiAgICAgICAgZXhwb3J0cy53cml0ZURvdWJsZUJFID0gd3JpdGVEb3VibGVfaWVlZTc1NC5iaW5kKG51bGwsIHdyaXRlVWludEJFLCA0LCAwKTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gcmVhZERvdWJsZV9pZWVlNzU0KHJlYWRVaW50LCBvZmYwLCBvZmYxLCBidWYsIHBvcykge1xyXG4gICAgICAgICAgICB2YXIgbG8gPSByZWFkVWludChidWYsIHBvcyArIG9mZjApLFxyXG4gICAgICAgICAgICAgICAgaGkgPSByZWFkVWludChidWYsIHBvcyArIG9mZjEpO1xyXG4gICAgICAgICAgICB2YXIgc2lnbiA9IChoaSA+PiAzMSkgKiAyICsgMSxcclxuICAgICAgICAgICAgICAgIGV4cG9uZW50ID0gaGkgPj4+IDIwICYgMjA0NyxcclxuICAgICAgICAgICAgICAgIG1hbnRpc3NhID0gNDI5NDk2NzI5NiAqIChoaSAmIDEwNDg1NzUpICsgbG87XHJcbiAgICAgICAgICAgIHJldHVybiBleHBvbmVudCA9PT0gMjA0N1xyXG4gICAgICAgICAgICAgICAgPyBtYW50aXNzYVxyXG4gICAgICAgICAgICAgICAgPyBOYU5cclxuICAgICAgICAgICAgICAgIDogc2lnbiAqIEluZmluaXR5XHJcbiAgICAgICAgICAgICAgICA6IGV4cG9uZW50ID09PSAwIC8vIGRlbm9ybWFsXHJcbiAgICAgICAgICAgICAgICA/IHNpZ24gKiA1ZS0zMjQgKiBtYW50aXNzYVxyXG4gICAgICAgICAgICAgICAgOiBzaWduICogTWF0aC5wb3coMiwgZXhwb25lbnQgLSAxMDc1KSAqIChtYW50aXNzYSArIDQ1MDM1OTk2MjczNzA0OTYpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZXhwb3J0cy5yZWFkRG91YmxlTEUgPSByZWFkRG91YmxlX2llZWU3NTQuYmluZChudWxsLCByZWFkVWludExFLCAwLCA0KTtcclxuICAgICAgICBleHBvcnRzLnJlYWREb3VibGVCRSA9IHJlYWREb3VibGVfaWVlZTc1NC5iaW5kKG51bGwsIHJlYWRVaW50QkUsIDQsIDApO1xyXG5cclxuICAgIH0pKCk7XHJcblxyXG4gICAgcmV0dXJuIGV4cG9ydHM7XHJcbn1cclxuXHJcbi8vIHVpbnQgaGVscGVyc1xyXG5cclxuZnVuY3Rpb24gd3JpdGVVaW50TEUodmFsLCBidWYsIHBvcykge1xyXG4gICAgYnVmW3BvcyAgICBdID0gIHZhbCAgICAgICAgJiAyNTU7XHJcbiAgICBidWZbcG9zICsgMV0gPSAgdmFsID4+PiA4ICAmIDI1NTtcclxuICAgIGJ1Zltwb3MgKyAyXSA9ICB2YWwgPj4+IDE2ICYgMjU1O1xyXG4gICAgYnVmW3BvcyArIDNdID0gIHZhbCA+Pj4gMjQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHdyaXRlVWludEJFKHZhbCwgYnVmLCBwb3MpIHtcclxuICAgIGJ1Zltwb3MgICAgXSA9ICB2YWwgPj4+IDI0O1xyXG4gICAgYnVmW3BvcyArIDFdID0gIHZhbCA+Pj4gMTYgJiAyNTU7XHJcbiAgICBidWZbcG9zICsgMl0gPSAgdmFsID4+PiA4ICAmIDI1NTtcclxuICAgIGJ1Zltwb3MgKyAzXSA9ICB2YWwgICAgICAgICYgMjU1O1xyXG59XHJcblxyXG5mdW5jdGlvbiByZWFkVWludExFKGJ1ZiwgcG9zKSB7XHJcbiAgICByZXR1cm4gKGJ1Zltwb3MgICAgXVxyXG4gICAgICAgICAgfCBidWZbcG9zICsgMV0gPDwgOFxyXG4gICAgICAgICAgfCBidWZbcG9zICsgMl0gPDwgMTZcclxuICAgICAgICAgIHwgYnVmW3BvcyArIDNdIDw8IDI0KSA+Pj4gMDtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVhZFVpbnRCRShidWYsIHBvcykge1xyXG4gICAgcmV0dXJuIChidWZbcG9zICAgIF0gPDwgMjRcclxuICAgICAgICAgIHwgYnVmW3BvcyArIDFdIDw8IDE2XHJcbiAgICAgICAgICB8IGJ1Zltwb3MgKyAyXSA8PCA4XHJcbiAgICAgICAgICB8IGJ1Zltwb3MgKyAzXSkgPj4+IDA7XHJcbn1cclxuIiwgIlwidXNlIHN0cmljdFwiO1xyXG5tb2R1bGUuZXhwb3J0cyA9IGlucXVpcmU7XHJcblxyXG4vKipcclxuICogUmVxdWlyZXMgYSBtb2R1bGUgb25seSBpZiBhdmFpbGFibGUuXHJcbiAqIEBtZW1iZXJvZiB1dGlsXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBtb2R1bGVOYW1lIE1vZHVsZSB0byByZXF1aXJlXHJcbiAqIEByZXR1cm5zIHs/T2JqZWN0fSBSZXF1aXJlZCBtb2R1bGUgaWYgYXZhaWxhYmxlIGFuZCBub3QgZW1wdHksIG90aGVyd2lzZSBgbnVsbGBcclxuICovXHJcbmZ1bmN0aW9uIGlucXVpcmUobW9kdWxlTmFtZSkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB2YXIgbW9kID0gZXZhbChcInF1aXJlXCIucmVwbGFjZSgvXi8sXCJyZVwiKSkobW9kdWxlTmFtZSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZXZhbFxyXG4gICAgICAgIGlmIChtb2QgJiYgKG1vZC5sZW5ndGggfHwgT2JqZWN0LmtleXMobW9kKS5sZW5ndGgpKVxyXG4gICAgICAgICAgICByZXR1cm4gbW9kO1xyXG4gICAgfSBjYXRjaCAoZSkge30gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1lbXB0eVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn1cclxuIiwgIlwidXNlIHN0cmljdFwiO1xyXG5cclxuLyoqXHJcbiAqIEEgbWluaW1hbCBVVEY4IGltcGxlbWVudGF0aW9uIGZvciBudW1iZXIgYXJyYXlzLlxyXG4gKiBAbWVtYmVyb2YgdXRpbFxyXG4gKiBAbmFtZXNwYWNlXHJcbiAqL1xyXG52YXIgdXRmOCA9IGV4cG9ydHM7XHJcblxyXG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgVVRGOCBieXRlIGxlbmd0aCBvZiBhIHN0cmluZy5cclxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBTdHJpbmdcclxuICogQHJldHVybnMge251bWJlcn0gQnl0ZSBsZW5ndGhcclxuICovXHJcbnV0ZjgubGVuZ3RoID0gZnVuY3Rpb24gdXRmOF9sZW5ndGgoc3RyaW5nKSB7XHJcbiAgICB2YXIgbGVuID0gMCxcclxuICAgICAgICBjID0gMDtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyaW5nLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgYyA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xyXG4gICAgICAgIGlmIChjIDwgMTI4KVxyXG4gICAgICAgICAgICBsZW4gKz0gMTtcclxuICAgICAgICBlbHNlIGlmIChjIDwgMjA0OClcclxuICAgICAgICAgICAgbGVuICs9IDI7XHJcbiAgICAgICAgZWxzZSBpZiAoKGMgJiAweEZDMDApID09PSAweEQ4MDAgJiYgKHN0cmluZy5jaGFyQ29kZUF0KGkgKyAxKSAmIDB4RkMwMCkgPT09IDB4REMwMCkge1xyXG4gICAgICAgICAgICArK2k7XHJcbiAgICAgICAgICAgIGxlbiArPSA0O1xyXG4gICAgICAgIH0gZWxzZVxyXG4gICAgICAgICAgICBsZW4gKz0gMztcclxuICAgIH1cclxuICAgIHJldHVybiBsZW47XHJcbn07XHJcblxyXG4vKipcclxuICogUmVhZHMgVVRGOCBieXRlcyBhcyBhIHN0cmluZy5cclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWZmZXIgU291cmNlIGJ1ZmZlclxyXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgU291cmNlIHN0YXJ0XHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgU291cmNlIGVuZFxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBTdHJpbmcgcmVhZFxyXG4gKi9cclxudXRmOC5yZWFkID0gZnVuY3Rpb24gdXRmOF9yZWFkKGJ1ZmZlciwgc3RhcnQsIGVuZCkge1xyXG4gICAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0O1xyXG4gICAgaWYgKGxlbiA8IDEpXHJcbiAgICAgICAgcmV0dXJuIFwiXCI7XHJcbiAgICB2YXIgcGFydHMgPSBudWxsLFxyXG4gICAgICAgIGNodW5rID0gW10sXHJcbiAgICAgICAgaSA9IDAsIC8vIGNoYXIgb2Zmc2V0XHJcbiAgICAgICAgdDsgICAgIC8vIHRlbXBvcmFyeVxyXG4gICAgd2hpbGUgKHN0YXJ0IDwgZW5kKSB7XHJcbiAgICAgICAgdCA9IGJ1ZmZlcltzdGFydCsrXTtcclxuICAgICAgICBpZiAodCA8IDEyOClcclxuICAgICAgICAgICAgY2h1bmtbaSsrXSA9IHQ7XHJcbiAgICAgICAgZWxzZSBpZiAodCA+IDE5MSAmJiB0IDwgMjI0KVxyXG4gICAgICAgICAgICBjaHVua1tpKytdID0gKHQgJiAzMSkgPDwgNiB8IGJ1ZmZlcltzdGFydCsrXSAmIDYzO1xyXG4gICAgICAgIGVsc2UgaWYgKHQgPiAyMzkgJiYgdCA8IDM2NSkge1xyXG4gICAgICAgICAgICB0ID0gKCh0ICYgNykgPDwgMTggfCAoYnVmZmVyW3N0YXJ0KytdICYgNjMpIDw8IDEyIHwgKGJ1ZmZlcltzdGFydCsrXSAmIDYzKSA8PCA2IHwgYnVmZmVyW3N0YXJ0KytdICYgNjMpIC0gMHgxMDAwMDtcclxuICAgICAgICAgICAgY2h1bmtbaSsrXSA9IDB4RDgwMCArICh0ID4+IDEwKTtcclxuICAgICAgICAgICAgY2h1bmtbaSsrXSA9IDB4REMwMCArICh0ICYgMTAyMyk7XHJcbiAgICAgICAgfSBlbHNlXHJcbiAgICAgICAgICAgIGNodW5rW2krK10gPSAodCAmIDE1KSA8PCAxMiB8IChidWZmZXJbc3RhcnQrK10gJiA2MykgPDwgNiB8IGJ1ZmZlcltzdGFydCsrXSAmIDYzO1xyXG4gICAgICAgIGlmIChpID4gODE5MSkge1xyXG4gICAgICAgICAgICAocGFydHMgfHwgKHBhcnRzID0gW10pKS5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjaHVuaykpO1xyXG4gICAgICAgICAgICBpID0gMDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAocGFydHMpIHtcclxuICAgICAgICBpZiAoaSlcclxuICAgICAgICAgICAgcGFydHMucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY2h1bmsuc2xpY2UoMCwgaSkpKTtcclxuICAgICAgICByZXR1cm4gcGFydHMuam9pbihcIlwiKTtcclxuICAgIH1cclxuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY2h1bmsuc2xpY2UoMCwgaSkpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFdyaXRlcyBhIHN0cmluZyBhcyBVVEY4IGJ5dGVzLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFNvdXJjZSBzdHJpbmdcclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWZmZXIgRGVzdGluYXRpb24gYnVmZmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgRGVzdGluYXRpb24gb2Zmc2V0XHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IEJ5dGVzIHdyaXR0ZW5cclxuICovXHJcbnV0Zjgud3JpdGUgPSBmdW5jdGlvbiB1dGY4X3dyaXRlKHN0cmluZywgYnVmZmVyLCBvZmZzZXQpIHtcclxuICAgIHZhciBzdGFydCA9IG9mZnNldCxcclxuICAgICAgICBjMSwgLy8gY2hhcmFjdGVyIDFcclxuICAgICAgICBjMjsgLy8gY2hhcmFjdGVyIDJcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyaW5nLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgYzEgPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcclxuICAgICAgICBpZiAoYzEgPCAxMjgpIHtcclxuICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IGMxO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoYzEgPCAyMDQ4KSB7XHJcbiAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSBjMSA+PiA2ICAgICAgIHwgMTkyO1xyXG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gYzEgICAgICAgJiA2MyB8IDEyODtcclxuICAgICAgICB9IGVsc2UgaWYgKChjMSAmIDB4RkMwMCkgPT09IDB4RDgwMCAmJiAoKGMyID0gc3RyaW5nLmNoYXJDb2RlQXQoaSArIDEpKSAmIDB4RkMwMCkgPT09IDB4REMwMCkge1xyXG4gICAgICAgICAgICBjMSA9IDB4MTAwMDAgKyAoKGMxICYgMHgwM0ZGKSA8PCAxMCkgKyAoYzIgJiAweDAzRkYpO1xyXG4gICAgICAgICAgICArK2k7XHJcbiAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSBjMSA+PiAxOCAgICAgIHwgMjQwO1xyXG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gYzEgPj4gMTIgJiA2MyB8IDEyODtcclxuICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IGMxID4+IDYgICYgNjMgfCAxMjg7XHJcbiAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSBjMSAgICAgICAmIDYzIHwgMTI4O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSBjMSA+PiAxMiAgICAgIHwgMjI0O1xyXG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gYzEgPj4gNiAgJiA2MyB8IDEyODtcclxuICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IGMxICAgICAgICYgNjMgfCAxMjg7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG9mZnNldCAtIHN0YXJ0O1xyXG59O1xyXG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XHJcbm1vZHVsZS5leHBvcnRzID0gcG9vbDtcclxuXHJcbi8qKlxyXG4gKiBBbiBhbGxvY2F0b3IgYXMgdXNlZCBieSB7QGxpbmsgdXRpbC5wb29sfS5cclxuICogQHR5cGVkZWYgUG9vbEFsbG9jYXRvclxyXG4gKiBAdHlwZSB7ZnVuY3Rpb259XHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBzaXplIEJ1ZmZlciBzaXplXHJcbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fSBCdWZmZXJcclxuICovXHJcblxyXG4vKipcclxuICogQSBzbGljZXIgYXMgdXNlZCBieSB7QGxpbmsgdXRpbC5wb29sfS5cclxuICogQHR5cGVkZWYgUG9vbFNsaWNlclxyXG4gKiBAdHlwZSB7ZnVuY3Rpb259XHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBTdGFydCBvZmZzZXRcclxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQgb2Zmc2V0XHJcbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fSBCdWZmZXIgc2xpY2VcclxuICogQHRoaXMge1VpbnQ4QXJyYXl9XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEEgZ2VuZXJhbCBwdXJwb3NlIGJ1ZmZlciBwb29sLlxyXG4gKiBAbWVtYmVyb2YgdXRpbFxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtQb29sQWxsb2NhdG9yfSBhbGxvYyBBbGxvY2F0b3JcclxuICogQHBhcmFtIHtQb29sU2xpY2VyfSBzbGljZSBTbGljZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IFtzaXplPTgxOTJdIFNsYWIgc2l6ZVxyXG4gKiBAcmV0dXJucyB7UG9vbEFsbG9jYXRvcn0gUG9vbGVkIGFsbG9jYXRvclxyXG4gKi9cclxuZnVuY3Rpb24gcG9vbChhbGxvYywgc2xpY2UsIHNpemUpIHtcclxuICAgIHZhciBTSVpFICAgPSBzaXplIHx8IDgxOTI7XHJcbiAgICB2YXIgTUFYICAgID0gU0laRSA+Pj4gMTtcclxuICAgIHZhciBzbGFiICAgPSBudWxsO1xyXG4gICAgdmFyIG9mZnNldCA9IFNJWkU7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gcG9vbF9hbGxvYyhzaXplKSB7XHJcbiAgICAgICAgaWYgKHNpemUgPCAxIHx8IHNpemUgPiBNQVgpXHJcbiAgICAgICAgICAgIHJldHVybiBhbGxvYyhzaXplKTtcclxuICAgICAgICBpZiAob2Zmc2V0ICsgc2l6ZSA+IFNJWkUpIHtcclxuICAgICAgICAgICAgc2xhYiA9IGFsbG9jKFNJWkUpO1xyXG4gICAgICAgICAgICBvZmZzZXQgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYnVmID0gc2xpY2UuY2FsbChzbGFiLCBvZmZzZXQsIG9mZnNldCArPSBzaXplKTtcclxuICAgICAgICBpZiAob2Zmc2V0ICYgNykgLy8gYWxpZ24gdG8gMzIgYml0XHJcbiAgICAgICAgICAgIG9mZnNldCA9IChvZmZzZXQgfCA3KSArIDE7XHJcbiAgICAgICAgcmV0dXJuIGJ1ZjtcclxuICAgIH07XHJcbn1cclxuIiwgIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBMb25nQml0cztcblxudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbC9taW5pbWFsXCIpO1xuXG4vKipcbiAqIENvbnN0cnVjdHMgbmV3IGxvbmcgYml0cy5cbiAqIEBjbGFzc2Rlc2MgSGVscGVyIGNsYXNzIGZvciB3b3JraW5nIHdpdGggdGhlIGxvdyBhbmQgaGlnaCBiaXRzIG9mIGEgNjQgYml0IHZhbHVlLlxuICogQG1lbWJlcm9mIHV0aWxcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtudW1iZXJ9IGxvIExvdyAzMiBiaXRzLCB1bnNpZ25lZFxuICogQHBhcmFtIHtudW1iZXJ9IGhpIEhpZ2ggMzIgYml0cywgdW5zaWduZWRcbiAqL1xuZnVuY3Rpb24gTG9uZ0JpdHMobG8sIGhpKSB7XG5cbiAgICAvLyBub3RlIHRoYXQgdGhlIGNhc3RzIGJlbG93IGFyZSB0aGVvcmV0aWNhbGx5IHVubmVjZXNzYXJ5IGFzIG9mIHRvZGF5LCBidXQgb2xkZXIgc3RhdGljYWxseVxuICAgIC8vIGdlbmVyYXRlZCBjb252ZXJ0ZXIgY29kZSBtaWdodCBzdGlsbCBjYWxsIHRoZSBjdG9yIHdpdGggc2lnbmVkIDMyYml0cy4ga2VwdCBmb3IgY29tcGF0LlxuXG4gICAgLyoqXG4gICAgICogTG93IGJpdHMuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmxvID0gbG8gPj4+IDA7XG5cbiAgICAvKipcbiAgICAgKiBIaWdoIGJpdHMuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmhpID0gaGkgPj4+IDA7XG59XG5cbi8qKlxuICogWmVybyBiaXRzLlxuICogQG1lbWJlcm9mIHV0aWwuTG9uZ0JpdHNcbiAqIEB0eXBlIHt1dGlsLkxvbmdCaXRzfVxuICovXG52YXIgemVybyA9IExvbmdCaXRzLnplcm8gPSBuZXcgTG9uZ0JpdHMoMCwgMCk7XG5cbnplcm8udG9OdW1iZXIgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG56ZXJvLnp6RW5jb2RlID0gemVyby56ekRlY29kZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfTtcbnplcm8ubGVuZ3RoID0gZnVuY3Rpb24oKSB7IHJldHVybiAxOyB9O1xuXG4vKipcbiAqIFplcm8gaGFzaC5cbiAqIEBtZW1iZXJvZiB1dGlsLkxvbmdCaXRzXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG52YXIgemVyb0hhc2ggPSBMb25nQml0cy56ZXJvSGFzaCA9IFwiXFwwXFwwXFwwXFwwXFwwXFwwXFwwXFwwXCI7XG5cbi8qKlxuICogQ29uc3RydWN0cyBuZXcgbG9uZyBiaXRzIGZyb20gdGhlIHNwZWNpZmllZCBudW1iZXIuXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWVcbiAqIEByZXR1cm5zIHt1dGlsLkxvbmdCaXRzfSBJbnN0YW5jZVxuICovXG5Mb25nQml0cy5mcm9tTnVtYmVyID0gZnVuY3Rpb24gZnJvbU51bWJlcih2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gMClcbiAgICAgICAgcmV0dXJuIHplcm87XG4gICAgdmFyIHNpZ24gPSB2YWx1ZSA8IDA7XG4gICAgaWYgKHNpZ24pXG4gICAgICAgIHZhbHVlID0gLXZhbHVlO1xuICAgIHZhciBsbyA9IHZhbHVlID4+PiAwLFxuICAgICAgICBoaSA9ICh2YWx1ZSAtIGxvKSAvIDQyOTQ5NjcyOTYgPj4+IDA7XG4gICAgaWYgKHNpZ24pIHtcbiAgICAgICAgaGkgPSB+aGkgPj4+IDA7XG4gICAgICAgIGxvID0gfmxvID4+PiAwO1xuICAgICAgICBpZiAoKytsbyA+IDQyOTQ5NjcyOTUpIHtcbiAgICAgICAgICAgIGxvID0gMDtcbiAgICAgICAgICAgIGlmICgrK2hpID4gNDI5NDk2NzI5NSlcbiAgICAgICAgICAgICAgICBoaSA9IDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBMb25nQml0cyhsbywgaGkpO1xufTtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIG5ldyBsb25nIGJpdHMgZnJvbSBhIG51bWJlciwgbG9uZyBvciBzdHJpbmcuXG4gKiBAcGFyYW0ge0xvbmd8bnVtYmVyfHN0cmluZ30gdmFsdWUgVmFsdWVcbiAqIEByZXR1cm5zIHt1dGlsLkxvbmdCaXRzfSBJbnN0YW5jZVxuICovXG5Mb25nQml0cy5mcm9tID0gZnVuY3Rpb24gZnJvbSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpXG4gICAgICAgIHJldHVybiBMb25nQml0cy5mcm9tTnVtYmVyKHZhbHVlKTtcbiAgICBpZiAodXRpbC5pc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgaWYgKHV0aWwuTG9uZylcbiAgICAgICAgICAgIHZhbHVlID0gdXRpbC5Mb25nLmZyb21TdHJpbmcodmFsdWUpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gTG9uZ0JpdHMuZnJvbU51bWJlcihwYXJzZUludCh2YWx1ZSwgMTApKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlLmxvdyB8fCB2YWx1ZS5oaWdoID8gbmV3IExvbmdCaXRzKHZhbHVlLmxvdyA+Pj4gMCwgdmFsdWUuaGlnaCA+Pj4gMCkgOiB6ZXJvO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGlzIGxvbmcgYml0cyB0byBhIHBvc3NpYmx5IHVuc2FmZSBKYXZhU2NyaXB0IG51bWJlci5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Vuc2lnbmVkPWZhbHNlXSBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdFxuICogQHJldHVybnMge251bWJlcn0gUG9zc2libHkgdW5zYWZlIG51bWJlclxuICovXG5Mb25nQml0cy5wcm90b3R5cGUudG9OdW1iZXIgPSBmdW5jdGlvbiB0b051bWJlcih1bnNpZ25lZCkge1xuICAgIGlmICghdW5zaWduZWQgJiYgdGhpcy5oaSA+Pj4gMzEpIHtcbiAgICAgICAgdmFyIGxvID0gfnRoaXMubG8gKyAxID4+PiAwLFxuICAgICAgICAgICAgaGkgPSB+dGhpcy5oaSAgICAgPj4+IDA7XG4gICAgICAgIGlmICghbG8pXG4gICAgICAgICAgICBoaSA9IGhpICsgMSA+Pj4gMDtcbiAgICAgICAgcmV0dXJuIC0obG8gKyBoaSAqIDQyOTQ5NjcyOTYpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5sbyArIHRoaXMuaGkgKiA0Mjk0OTY3Mjk2O1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGlzIGxvbmcgYml0cyB0byBhIGxvbmcuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFt1bnNpZ25lZD1mYWxzZV0gV2hldGhlciB1bnNpZ25lZCBvciBub3RcbiAqIEByZXR1cm5zIHtMb25nfSBMb25nXG4gKi9cbkxvbmdCaXRzLnByb3RvdHlwZS50b0xvbmcgPSBmdW5jdGlvbiB0b0xvbmcodW5zaWduZWQpIHtcbiAgICByZXR1cm4gdXRpbC5Mb25nXG4gICAgICAgID8gbmV3IHV0aWwuTG9uZyh0aGlzLmxvIHwgMCwgdGhpcy5oaSB8IDAsIEJvb2xlYW4odW5zaWduZWQpKVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICA6IHsgbG93OiB0aGlzLmxvIHwgMCwgaGlnaDogdGhpcy5oaSB8IDAsIHVuc2lnbmVkOiBCb29sZWFuKHVuc2lnbmVkKSB9O1xufTtcblxudmFyIGNoYXJDb2RlQXQgPSBTdHJpbmcucHJvdG90eXBlLmNoYXJDb2RlQXQ7XG5cbi8qKlxuICogQ29uc3RydWN0cyBuZXcgbG9uZyBiaXRzIGZyb20gdGhlIHNwZWNpZmllZCA4IGNoYXJhY3RlcnMgbG9uZyBoYXNoLlxuICogQHBhcmFtIHtzdHJpbmd9IGhhc2ggSGFzaFxuICogQHJldHVybnMge3V0aWwuTG9uZ0JpdHN9IEJpdHNcbiAqL1xuTG9uZ0JpdHMuZnJvbUhhc2ggPSBmdW5jdGlvbiBmcm9tSGFzaChoYXNoKSB7XG4gICAgaWYgKGhhc2ggPT09IHplcm9IYXNoKVxuICAgICAgICByZXR1cm4gemVybztcbiAgICByZXR1cm4gbmV3IExvbmdCaXRzKFxuICAgICAgICAoIGNoYXJDb2RlQXQuY2FsbChoYXNoLCAwKVxuICAgICAgICB8IGNoYXJDb2RlQXQuY2FsbChoYXNoLCAxKSA8PCA4XG4gICAgICAgIHwgY2hhckNvZGVBdC5jYWxsKGhhc2gsIDIpIDw8IDE2XG4gICAgICAgIHwgY2hhckNvZGVBdC5jYWxsKGhhc2gsIDMpIDw8IDI0KSA+Pj4gMFxuICAgICxcbiAgICAgICAgKCBjaGFyQ29kZUF0LmNhbGwoaGFzaCwgNClcbiAgICAgICAgfCBjaGFyQ29kZUF0LmNhbGwoaGFzaCwgNSkgPDwgOFxuICAgICAgICB8IGNoYXJDb2RlQXQuY2FsbChoYXNoLCA2KSA8PCAxNlxuICAgICAgICB8IGNoYXJDb2RlQXQuY2FsbChoYXNoLCA3KSA8PCAyNCkgPj4+IDBcbiAgICApO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGlzIGxvbmcgYml0cyB0byBhIDggY2hhcmFjdGVycyBsb25nIGhhc2guXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBIYXNoXG4gKi9cbkxvbmdCaXRzLnByb3RvdHlwZS50b0hhc2ggPSBmdW5jdGlvbiB0b0hhc2goKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoXG4gICAgICAgIHRoaXMubG8gICAgICAgICYgMjU1LFxuICAgICAgICB0aGlzLmxvID4+PiA4ICAmIDI1NSxcbiAgICAgICAgdGhpcy5sbyA+Pj4gMTYgJiAyNTUsXG4gICAgICAgIHRoaXMubG8gPj4+IDI0ICAgICAgLFxuICAgICAgICB0aGlzLmhpICAgICAgICAmIDI1NSxcbiAgICAgICAgdGhpcy5oaSA+Pj4gOCAgJiAyNTUsXG4gICAgICAgIHRoaXMuaGkgPj4+IDE2ICYgMjU1LFxuICAgICAgICB0aGlzLmhpID4+PiAyNFxuICAgICk7XG59O1xuXG4vKipcbiAqIFppZy16YWcgZW5jb2RlcyB0aGlzIGxvbmcgYml0cy5cbiAqIEByZXR1cm5zIHt1dGlsLkxvbmdCaXRzfSBgdGhpc2BcbiAqL1xuTG9uZ0JpdHMucHJvdG90eXBlLnp6RW5jb2RlID0gZnVuY3Rpb24genpFbmNvZGUoKSB7XG4gICAgdmFyIG1hc2sgPSAgIHRoaXMuaGkgPj4gMzE7XG4gICAgdGhpcy5oaSAgPSAoKHRoaXMuaGkgPDwgMSB8IHRoaXMubG8gPj4+IDMxKSBeIG1hc2spID4+PiAwO1xuICAgIHRoaXMubG8gID0gKCB0aGlzLmxvIDw8IDEgICAgICAgICAgICAgICAgICAgXiBtYXNrKSA+Pj4gMDtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogWmlnLXphZyBkZWNvZGVzIHRoaXMgbG9uZyBiaXRzLlxuICogQHJldHVybnMge3V0aWwuTG9uZ0JpdHN9IGB0aGlzYFxuICovXG5Mb25nQml0cy5wcm90b3R5cGUuenpEZWNvZGUgPSBmdW5jdGlvbiB6ekRlY29kZSgpIHtcbiAgICB2YXIgbWFzayA9IC0odGhpcy5sbyAmIDEpO1xuICAgIHRoaXMubG8gID0gKCh0aGlzLmxvID4+PiAxIHwgdGhpcy5oaSA8PCAzMSkgXiBtYXNrKSA+Pj4gMDtcbiAgICB0aGlzLmhpICA9ICggdGhpcy5oaSA+Pj4gMSAgICAgICAgICAgICAgICAgIF4gbWFzaykgPj4+IDA7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGxlbmd0aCBvZiB0aGlzIGxvbmdiaXRzIHdoZW4gZW5jb2RlZCBhcyBhIHZhcmludC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IExlbmd0aFxuICovXG5Mb25nQml0cy5wcm90b3R5cGUubGVuZ3RoID0gZnVuY3Rpb24gbGVuZ3RoKCkge1xuICAgIHZhciBwYXJ0MCA9ICB0aGlzLmxvLFxuICAgICAgICBwYXJ0MSA9ICh0aGlzLmxvID4+PiAyOCB8IHRoaXMuaGkgPDwgNCkgPj4+IDAsXG4gICAgICAgIHBhcnQyID0gIHRoaXMuaGkgPj4+IDI0O1xuICAgIHJldHVybiBwYXJ0MiA9PT0gMFxuICAgICAgICAgPyBwYXJ0MSA9PT0gMFxuICAgICAgICAgICA/IHBhcnQwIDwgMTYzODRcbiAgICAgICAgICAgICA/IHBhcnQwIDwgMTI4ID8gMSA6IDJcbiAgICAgICAgICAgICA6IHBhcnQwIDwgMjA5NzE1MiA/IDMgOiA0XG4gICAgICAgICAgIDogcGFydDEgPCAxNjM4NFxuICAgICAgICAgICAgID8gcGFydDEgPCAxMjggPyA1IDogNlxuICAgICAgICAgICAgIDogcGFydDEgPCAyMDk3MTUyID8gNyA6IDhcbiAgICAgICAgIDogcGFydDIgPCAxMjggPyA5IDogMTA7XG59O1xuIiwgIlwidXNlIHN0cmljdFwiO1xudmFyIHV0aWwgPSBleHBvcnRzO1xuXG4vLyB1c2VkIHRvIHJldHVybiBhIFByb21pc2Ugd2hlcmUgY2FsbGJhY2sgaXMgb21pdHRlZFxudXRpbC5hc1Byb21pc2UgPSByZXF1aXJlKFwiQHByb3RvYnVmanMvYXNwcm9taXNlXCIpO1xuXG4vLyBjb252ZXJ0cyB0byAvIGZyb20gYmFzZTY0IGVuY29kZWQgc3RyaW5nc1xudXRpbC5iYXNlNjQgPSByZXF1aXJlKFwiQHByb3RvYnVmanMvYmFzZTY0XCIpO1xuXG4vLyBiYXNlIGNsYXNzIG9mIHJwYy5TZXJ2aWNlXG51dGlsLkV2ZW50RW1pdHRlciA9IHJlcXVpcmUoXCJAcHJvdG9idWZqcy9ldmVudGVtaXR0ZXJcIik7XG5cbi8vIGZsb2F0IGhhbmRsaW5nIGFjY3Jvc3MgYnJvd3NlcnNcbnV0aWwuZmxvYXQgPSByZXF1aXJlKFwiQHByb3RvYnVmanMvZmxvYXRcIik7XG5cbi8vIHJlcXVpcmVzIG1vZHVsZXMgb3B0aW9uYWxseSBhbmQgaGlkZXMgdGhlIGNhbGwgZnJvbSBidW5kbGVyc1xudXRpbC5pbnF1aXJlID0gcmVxdWlyZShcIkBwcm90b2J1ZmpzL2lucXVpcmVcIik7XG5cbi8vIGNvbnZlcnRzIHRvIC8gZnJvbSB1dGY4IGVuY29kZWQgc3RyaW5nc1xudXRpbC51dGY4ID0gcmVxdWlyZShcIkBwcm90b2J1ZmpzL3V0ZjhcIik7XG5cbi8vIHByb3ZpZGVzIGEgbm9kZS1saWtlIGJ1ZmZlciBwb29sIGluIHRoZSBicm93c2VyXG51dGlsLnBvb2wgPSByZXF1aXJlKFwiQHByb3RvYnVmanMvcG9vbFwiKTtcblxuLy8gdXRpbGl0eSB0byB3b3JrIHdpdGggdGhlIGxvdyBhbmQgaGlnaCBiaXRzIG9mIGEgNjQgYml0IHZhbHVlXG51dGlsLkxvbmdCaXRzID0gcmVxdWlyZShcIi4vbG9uZ2JpdHNcIik7XG5cbi8qKlxuICogV2hldGhlciBydW5uaW5nIHdpdGhpbiBub2RlIG9yIG5vdC5cbiAqIEBtZW1iZXJvZiB1dGlsXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqL1xudXRpbC5pc05vZGUgPSBCb29sZWFuKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCJcbiAgICAgICAgICAgICAgICAgICAmJiBnbG9iYWxcbiAgICAgICAgICAgICAgICAgICAmJiBnbG9iYWwucHJvY2Vzc1xuICAgICAgICAgICAgICAgICAgICYmIGdsb2JhbC5wcm9jZXNzLnZlcnNpb25zXG4gICAgICAgICAgICAgICAgICAgJiYgZ2xvYmFsLnByb2Nlc3MudmVyc2lvbnMubm9kZSk7XG5cbi8qKlxuICogR2xvYmFsIG9iamVjdCByZWZlcmVuY2UuXG4gKiBAbWVtYmVyb2YgdXRpbFxuICogQHR5cGUge09iamVjdH1cbiAqL1xudXRpbC5nbG9iYWwgPSB1dGlsLmlzTm9kZSAmJiBnbG9iYWxcbiAgICAgICAgICAgfHwgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3dcbiAgICAgICAgICAgfHwgdHlwZW9mIHNlbGYgICAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmXG4gICAgICAgICAgIHx8IHRoaXM7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8taW52YWxpZC10aGlzXG5cbi8qKlxuICogQW4gaW1tdWFibGUgZW1wdHkgYXJyYXkuXG4gKiBAbWVtYmVyb2YgdXRpbFxuICogQHR5cGUge0FycmF5LjwqPn1cbiAqIEBjb25zdFxuICovXG51dGlsLmVtcHR5QXJyYXkgPSBPYmplY3QuZnJlZXplID8gT2JqZWN0LmZyZWV6ZShbXSkgOiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyBbXTsgLy8gdXNlZCBvbiBwcm90b3R5cGVzXG5cbi8qKlxuICogQW4gaW1tdXRhYmxlIGVtcHR5IG9iamVjdC5cbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAY29uc3RcbiAqL1xudXRpbC5lbXB0eU9iamVjdCA9IE9iamVjdC5mcmVlemUgPyBPYmplY3QuZnJlZXplKHt9KSA6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIHt9OyAvLyB1c2VkIG9uIHByb3RvdHlwZXNcblxuLyoqXG4gKiBUZXN0cyBpZiB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIGFuIGludGVnZXIuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgdmFsdWUgaXMgYW4gaW50ZWdlclxuICovXG51dGlsLmlzSW50ZWdlciA9IE51bWJlci5pc0ludGVnZXIgfHwgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gZnVuY3Rpb24gaXNJbnRlZ2VyKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiAmJiBpc0Zpbml0ZSh2YWx1ZSkgJiYgTWF0aC5mbG9vcih2YWx1ZSkgPT09IHZhbHVlO1xufTtcblxuLyoqXG4gKiBUZXN0cyBpZiB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIGEgc3RyaW5nLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSB2YWx1ZSBpcyBhIHN0cmluZ1xuICovXG51dGlsLmlzU3RyaW5nID0gZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiIHx8IHZhbHVlIGluc3RhbmNlb2YgU3RyaW5nO1xufTtcblxuLyoqXG4gKiBUZXN0cyBpZiB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIGEgbm9uLW51bGwgb2JqZWN0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSB2YWx1ZSBpcyBhIG5vbi1udWxsIG9iamVjdFxuICovXG51dGlsLmlzT2JqZWN0ID0gZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiO1xufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBwcm9wZXJ0eSBvbiBhIG1lc3NhZ2UgaXMgY29uc2lkZXJlZCB0byBiZSBwcmVzZW50LlxuICogVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgdXRpbC5pc1NldH0uXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogUGxhaW4gb2JqZWN0IG9yIG1lc3NhZ2UgaW5zdGFuY2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wIFByb3BlcnR5IG5hbWVcbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgY29uc2lkZXJlZCB0byBiZSBwcmVzZW50LCBvdGhlcndpc2UgYGZhbHNlYFxuICovXG51dGlsLmlzc2V0ID1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBwcm9wZXJ0eSBvbiBhIG1lc3NhZ2UgaXMgY29uc2lkZXJlZCB0byBiZSBwcmVzZW50LlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBQbGFpbiBvYmplY3Qgb3IgbWVzc2FnZSBpbnN0YW5jZVxuICogQHBhcmFtIHtzdHJpbmd9IHByb3AgUHJvcGVydHkgbmFtZVxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiBjb25zaWRlcmVkIHRvIGJlIHByZXNlbnQsIG90aGVyd2lzZSBgZmFsc2VgXG4gKi9cbnV0aWwuaXNTZXQgPSBmdW5jdGlvbiBpc1NldChvYmosIHByb3ApIHtcbiAgICB2YXIgdmFsdWUgPSBvYmpbcHJvcF07XG4gICAgaWYgKHZhbHVlICE9IG51bGwgJiYgb2JqLmhhc093blByb3BlcnR5KHByb3ApKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcSwgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgKEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUubGVuZ3RoIDogT2JqZWN0LmtleXModmFsdWUpLmxlbmd0aCkgPiAwO1xuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogQW55IGNvbXBhdGlibGUgQnVmZmVyIGluc3RhbmNlLlxuICogVGhpcyBpcyBhIG1pbmltYWwgc3RhbmQtYWxvbmUgZGVmaW5pdGlvbiBvZiBhIEJ1ZmZlciBpbnN0YW5jZS4gVGhlIGFjdHVhbCB0eXBlIGlzIHRoYXQgZXhwb3J0ZWQgYnkgbm9kZSdzIHR5cGluZ3MuXG4gKiBAaW50ZXJmYWNlIEJ1ZmZlclxuICogQGV4dGVuZHMgVWludDhBcnJheVxuICovXG5cbi8qKlxuICogTm9kZSdzIEJ1ZmZlciBjbGFzcyBpZiBhdmFpbGFibGUuXG4gKiBAdHlwZSB7Q29uc3RydWN0b3I8QnVmZmVyPn1cbiAqL1xudXRpbC5CdWZmZXIgPSAoZnVuY3Rpb24oKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgdmFyIEJ1ZmZlciA9IHV0aWwuaW5xdWlyZShcImJ1ZmZlclwiKS5CdWZmZXI7XG4gICAgICAgIC8vIHJlZnVzZSB0byB1c2Ugbm9uLW5vZGUgYnVmZmVycyBpZiBub3QgZXhwbGljaXRseSBhc3NpZ25lZCAocGVyZiByZWFzb25zKTpcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5wcm90b3R5cGUudXRmOFdyaXRlID8gQnVmZmVyIDogLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gbnVsbDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn0pKCk7XG5cbi8vIEludGVybmFsIGFsaWFzIG9mIG9yIHBvbHlmdWxsIGZvciBCdWZmZXIuZnJvbS5cbnV0aWwuX0J1ZmZlcl9mcm9tID0gbnVsbDtcblxuLy8gSW50ZXJuYWwgYWxpYXMgb2Ygb3IgcG9seWZpbGwgZm9yIEJ1ZmZlci5hbGxvY1Vuc2FmZS5cbnV0aWwuX0J1ZmZlcl9hbGxvY1Vuc2FmZSA9IG51bGw7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBidWZmZXIgb2Ygd2hhdGV2ZXIgdHlwZSBzdXBwb3J0ZWQgYnkgdGhlIGVudmlyb25tZW50LlxuICogQHBhcmFtIHtudW1iZXJ8bnVtYmVyW119IFtzaXplT3JBcnJheT0wXSBCdWZmZXIgc2l6ZSBvciBudW1iZXIgYXJyYXlcbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fEJ1ZmZlcn0gQnVmZmVyXG4gKi9cbnV0aWwubmV3QnVmZmVyID0gZnVuY3Rpb24gbmV3QnVmZmVyKHNpemVPckFycmF5KSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICByZXR1cm4gdHlwZW9mIHNpemVPckFycmF5ID09PSBcIm51bWJlclwiXG4gICAgICAgID8gdXRpbC5CdWZmZXJcbiAgICAgICAgICAgID8gdXRpbC5fQnVmZmVyX2FsbG9jVW5zYWZlKHNpemVPckFycmF5KVxuICAgICAgICAgICAgOiBuZXcgdXRpbC5BcnJheShzaXplT3JBcnJheSlcbiAgICAgICAgOiB1dGlsLkJ1ZmZlclxuICAgICAgICAgICAgPyB1dGlsLl9CdWZmZXJfZnJvbShzaXplT3JBcnJheSlcbiAgICAgICAgICAgIDogdHlwZW9mIFVpbnQ4QXJyYXkgPT09IFwidW5kZWZpbmVkXCJcbiAgICAgICAgICAgICAgICA/IHNpemVPckFycmF5XG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheShzaXplT3JBcnJheSk7XG59O1xuXG4vKipcbiAqIEFycmF5IGltcGxlbWVudGF0aW9uIHVzZWQgaW4gdGhlIGJyb3dzZXIuIGBVaW50OEFycmF5YCBpZiBzdXBwb3J0ZWQsIG90aGVyd2lzZSBgQXJyYXlgLlxuICogQHR5cGUge0NvbnN0cnVjdG9yPFVpbnQ4QXJyYXk+fVxuICovXG51dGlsLkFycmF5ID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09IFwidW5kZWZpbmVkXCIgPyBVaW50OEFycmF5IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIDogQXJyYXk7XG5cbi8qKlxuICogQW55IGNvbXBhdGlibGUgTG9uZyBpbnN0YW5jZS5cbiAqIFRoaXMgaXMgYSBtaW5pbWFsIHN0YW5kLWFsb25lIGRlZmluaXRpb24gb2YgYSBMb25nIGluc3RhbmNlLiBUaGUgYWN0dWFsIHR5cGUgaXMgdGhhdCBleHBvcnRlZCBieSBsb25nLmpzLlxuICogQGludGVyZmFjZSBMb25nXG4gKiBAcHJvcGVydHkge251bWJlcn0gbG93IExvdyBiaXRzXG4gKiBAcHJvcGVydHkge251bWJlcn0gaGlnaCBIaWdoIGJpdHNcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3RcbiAqL1xuXG4vKipcbiAqIExvbmcuanMncyBMb25nIGNsYXNzIGlmIGF2YWlsYWJsZS5cbiAqIEB0eXBlIHtDb25zdHJ1Y3RvcjxMb25nPn1cbiAqL1xudXRpbC5Mb25nID0gLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gdXRpbC5nbG9iYWwuZGNvZGVJTyAmJiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyB1dGlsLmdsb2JhbC5kY29kZUlPLkxvbmdcbiAgICAgICAgIHx8IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIHV0aWwuZ2xvYmFsLkxvbmdcbiAgICAgICAgIHx8IHV0aWwuaW5xdWlyZShcImxvbmdcIik7XG5cbi8qKlxuICogUmVndWxhciBleHByZXNzaW9uIHVzZWQgdG8gdmVyaWZ5IDIgYml0IChgYm9vbGApIG1hcCBrZXlzLlxuICogQHR5cGUge1JlZ0V4cH1cbiAqIEBjb25zdFxuICovXG51dGlsLmtleTJSZSA9IC9edHJ1ZXxmYWxzZXwwfDEkLztcblxuLyoqXG4gKiBSZWd1bGFyIGV4cHJlc3Npb24gdXNlZCB0byB2ZXJpZnkgMzIgYml0IChgaW50MzJgIGV0Yy4pIG1hcCBrZXlzLlxuICogQHR5cGUge1JlZ0V4cH1cbiAqIEBjb25zdFxuICovXG51dGlsLmtleTMyUmUgPSAvXi0/KD86MHxbMS05XVswLTldKikkLztcblxuLyoqXG4gKiBSZWd1bGFyIGV4cHJlc3Npb24gdXNlZCB0byB2ZXJpZnkgNjQgYml0IChgaW50NjRgIGV0Yy4pIG1hcCBrZXlzLlxuICogQHR5cGUge1JlZ0V4cH1cbiAqIEBjb25zdFxuICovXG51dGlsLmtleTY0UmUgPSAvXig/OltcXFxceDAwLVxcXFx4ZmZdezh9fC0/KD86MHxbMS05XVswLTldKikpJC87XG5cbi8qKlxuICogQ29udmVydHMgYSBudW1iZXIgb3IgbG9uZyB0byBhbiA4IGNoYXJhY3RlcnMgbG9uZyBoYXNoIHN0cmluZy5cbiAqIEBwYXJhbSB7TG9uZ3xudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIGNvbnZlcnRcbiAqIEByZXR1cm5zIHtzdHJpbmd9IEhhc2hcbiAqL1xudXRpbC5sb25nVG9IYXNoID0gZnVuY3Rpb24gbG9uZ1RvSGFzaCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZVxuICAgICAgICA/IHV0aWwuTG9uZ0JpdHMuZnJvbSh2YWx1ZSkudG9IYXNoKClcbiAgICAgICAgOiB1dGlsLkxvbmdCaXRzLnplcm9IYXNoO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhbiA4IGNoYXJhY3RlcnMgbG9uZyBoYXNoIHN0cmluZyB0byBhIGxvbmcgb3IgbnVtYmVyLlxuICogQHBhcmFtIHtzdHJpbmd9IGhhc2ggSGFzaFxuICogQHBhcmFtIHtib29sZWFufSBbdW5zaWduZWQ9ZmFsc2VdIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90XG4gKiBAcmV0dXJucyB7TG9uZ3xudW1iZXJ9IE9yaWdpbmFsIHZhbHVlXG4gKi9cbnV0aWwubG9uZ0Zyb21IYXNoID0gZnVuY3Rpb24gbG9uZ0Zyb21IYXNoKGhhc2gsIHVuc2lnbmVkKSB7XG4gICAgdmFyIGJpdHMgPSB1dGlsLkxvbmdCaXRzLmZyb21IYXNoKGhhc2gpO1xuICAgIGlmICh1dGlsLkxvbmcpXG4gICAgICAgIHJldHVybiB1dGlsLkxvbmcuZnJvbUJpdHMoYml0cy5sbywgYml0cy5oaSwgdW5zaWduZWQpO1xuICAgIHJldHVybiBiaXRzLnRvTnVtYmVyKEJvb2xlYW4odW5zaWduZWQpKTtcbn07XG5cbi8qKlxuICogTWVyZ2VzIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBzb3VyY2Ugb2JqZWN0IGludG8gdGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBtZW1iZXJvZiB1dGlsXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBkc3QgRGVzdGluYXRpb24gb2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBzcmMgU291cmNlIG9iamVjdFxuICogQHBhcmFtIHtib29sZWFufSBbaWZOb3RTZXQ9ZmFsc2VdIE1lcmdlcyBvbmx5IGlmIHRoZSBrZXkgaXMgbm90IGFscmVhZHkgc2V0XG4gKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IERlc3RpbmF0aW9uIG9iamVjdFxuICovXG5mdW5jdGlvbiBtZXJnZShkc3QsIHNyYywgaWZOb3RTZXQpIHsgLy8gdXNlZCBieSBjb252ZXJ0ZXJzXG4gICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHNyYyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgaWYgKGRzdFtrZXlzW2ldXSA9PT0gdW5kZWZpbmVkIHx8ICFpZk5vdFNldClcbiAgICAgICAgICAgIGRzdFtrZXlzW2ldXSA9IHNyY1trZXlzW2ldXTtcbiAgICByZXR1cm4gZHN0O1xufVxuXG51dGlsLm1lcmdlID0gbWVyZ2U7XG5cbi8qKlxuICogQ29udmVydHMgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiBhIHN0cmluZyB0byBsb3dlciBjYXNlLlxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciBTdHJpbmcgdG8gY29udmVydFxuICogQHJldHVybnMge3N0cmluZ30gQ29udmVydGVkIHN0cmluZ1xuICovXG51dGlsLmxjRmlyc3QgPSBmdW5jdGlvbiBsY0ZpcnN0KHN0cikge1xuICAgIHJldHVybiBzdHIuY2hhckF0KDApLnRvTG93ZXJDYXNlKCkgKyBzdHIuc3Vic3RyaW5nKDEpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY3VzdG9tIGVycm9yIGNvbnN0cnVjdG9yLlxuICogQG1lbWJlcm9mIHV0aWxcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIEVycm9yIG5hbWVcbiAqIEByZXR1cm5zIHtDb25zdHJ1Y3RvcjxFcnJvcj59IEN1c3RvbSBlcnJvciBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBuZXdFcnJvcihuYW1lKSB7XG5cbiAgICBmdW5jdGlvbiBDdXN0b21FcnJvcihtZXNzYWdlLCBwcm9wZXJ0aWVzKSB7XG5cbiAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEN1c3RvbUVycm9yKSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ3VzdG9tRXJyb3IobWVzc2FnZSwgcHJvcGVydGllcyk7XG5cbiAgICAgICAgLy8gRXJyb3IuY2FsbCh0aGlzLCBtZXNzYWdlKTtcbiAgICAgICAgLy8gXiBqdXN0IHJldHVybnMgYSBuZXcgZXJyb3IgaW5zdGFuY2UgYmVjYXVzZSB0aGUgY3RvciBjYW4gYmUgY2FsbGVkIGFzIGEgZnVuY3Rpb25cblxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtZXNzYWdlXCIsIHsgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1lc3NhZ2U7IH0gfSk7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSAvLyBub2RlXG4gICAgICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBDdXN0b21FcnJvcik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0YWNrXCIsIHsgdmFsdWU6IG5ldyBFcnJvcigpLnN0YWNrIHx8IFwiXCIgfSk7XG5cbiAgICAgICAgaWYgKHByb3BlcnRpZXMpXG4gICAgICAgICAgICBtZXJnZSh0aGlzLCBwcm9wZXJ0aWVzKTtcbiAgICB9XG5cbiAgICAoQ3VzdG9tRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IEN1c3RvbUVycm9yO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEN1c3RvbUVycm9yLnByb3RvdHlwZSwgXCJuYW1lXCIsIHsgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG5hbWU7IH0gfSk7XG5cbiAgICBDdXN0b21FcnJvci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmFtZSArIFwiOiBcIiArIHRoaXMubWVzc2FnZTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEN1c3RvbUVycm9yO1xufVxuXG51dGlsLm5ld0Vycm9yID0gbmV3RXJyb3I7XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyBwcm90b2NvbCBlcnJvci5cbiAqIEBjbGFzc2Rlc2MgRXJyb3Igc3ViY2xhc3MgaW5kaWNhdGluZyBhIHByb3RvY29sIHNwZWNpZmMgZXJyb3IuXG4gKiBAbWVtYmVyb2YgdXRpbFxuICogQGV4dGVuZHMgRXJyb3JcbiAqIEB0ZW1wbGF0ZSBUIGV4dGVuZHMgTWVzc2FnZTxUPlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSBFcnJvciBtZXNzYWdlXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBbcHJvcGVydGllc10gQWRkaXRpb25hbCBwcm9wZXJ0aWVzXG4gKiBAZXhhbXBsZVxuICogdHJ5IHtcbiAqICAgICBNeU1lc3NhZ2UuZGVjb2RlKHNvbWVCdWZmZXIpOyAvLyB0aHJvd3MgaWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gKiB9IGNhdGNoIChlKSB7XG4gKiAgICAgaWYgKGUgaW5zdGFuY2VvZiBQcm90b2NvbEVycm9yICYmIGUuaW5zdGFuY2UpXG4gKiAgICAgICAgIGNvbnNvbGUubG9nKFwiZGVjb2RlZCBzbyBmYXI6IFwiICsgSlNPTi5zdHJpbmdpZnkoZS5pbnN0YW5jZSkpO1xuICogfVxuICovXG51dGlsLlByb3RvY29sRXJyb3IgPSBuZXdFcnJvcihcIlByb3RvY29sRXJyb3JcIik7XG5cbi8qKlxuICogU28gZmFyIGRlY29kZWQgbWVzc2FnZSBpbnN0YW5jZS5cbiAqIEBuYW1lIHV0aWwuUHJvdG9jb2xFcnJvciNpbnN0YW5jZVxuICogQHR5cGUge01lc3NhZ2U8VD59XG4gKi9cblxuLyoqXG4gKiBBIE9uZU9mIGdldHRlciBhcyByZXR1cm5lZCBieSB7QGxpbmsgdXRpbC5vbmVPZkdldHRlcn0uXG4gKiBAdHlwZWRlZiBPbmVPZkdldHRlclxuICogQHR5cGUge2Z1bmN0aW9ufVxuICogQHJldHVybnMge3N0cmluZ3x1bmRlZmluZWR9IFNldCBmaWVsZCBuYW1lLCBpZiBhbnlcbiAqL1xuXG4vKipcbiAqIEJ1aWxkcyBhIGdldHRlciBmb3IgYSBvbmVvZidzIHByZXNlbnQgZmllbGQgbmFtZS5cbiAqIEBwYXJhbSB7c3RyaW5nW119IGZpZWxkTmFtZXMgRmllbGQgbmFtZXNcbiAqIEByZXR1cm5zIHtPbmVPZkdldHRlcn0gVW5ib3VuZCBnZXR0ZXJcbiAqL1xudXRpbC5vbmVPZkdldHRlciA9IGZ1bmN0aW9uIGdldE9uZU9mKGZpZWxkTmFtZXMpIHtcbiAgICB2YXIgZmllbGRNYXAgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpZWxkTmFtZXMubGVuZ3RoOyArK2kpXG4gICAgICAgIGZpZWxkTWFwW2ZpZWxkTmFtZXNbaV1dID0gMTtcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8dW5kZWZpbmVkfSBTZXQgZmllbGQgbmFtZSwgaWYgYW55XG4gICAgICogQHRoaXMgT2JqZWN0XG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIHJldHVybiBmdW5jdGlvbigpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjb25zaXN0ZW50LXJldHVyblxuICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXModGhpcyksIGkgPSBrZXlzLmxlbmd0aCAtIDE7IGkgPiAtMTsgLS1pKVxuICAgICAgICAgICAgaWYgKGZpZWxkTWFwW2tleXNbaV1dID09PSAxICYmIHRoaXNba2V5c1tpXV0gIT09IHVuZGVmaW5lZCAmJiB0aGlzW2tleXNbaV1dICE9PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBrZXlzW2ldO1xuICAgIH07XG59O1xuXG4vKipcbiAqIEEgT25lT2Ygc2V0dGVyIGFzIHJldHVybmVkIGJ5IHtAbGluayB1dGlsLm9uZU9mU2V0dGVyfS5cbiAqIEB0eXBlZGVmIE9uZU9mU2V0dGVyXG4gKiBAdHlwZSB7ZnVuY3Rpb259XG4gKiBAcGFyYW0ge3N0cmluZ3x1bmRlZmluZWR9IHZhbHVlIEZpZWxkIG5hbWVcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKi9cblxuLyoqXG4gKiBCdWlsZHMgYSBzZXR0ZXIgZm9yIGEgb25lb2YncyBwcmVzZW50IGZpZWxkIG5hbWUuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBmaWVsZE5hbWVzIEZpZWxkIG5hbWVzXG4gKiBAcmV0dXJucyB7T25lT2ZTZXR0ZXJ9IFVuYm91bmQgc2V0dGVyXG4gKi9cbnV0aWwub25lT2ZTZXR0ZXIgPSBmdW5jdGlvbiBzZXRPbmVPZihmaWVsZE5hbWVzKSB7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBGaWVsZCBuYW1lXG4gICAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICAgKiBAdGhpcyBPYmplY3RcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgcmV0dXJuIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWVsZE5hbWVzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgaWYgKGZpZWxkTmFtZXNbaV0gIT09IG5hbWUpXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXNbZmllbGROYW1lc1tpXV07XG4gICAgfTtcbn07XG5cbi8qKlxuICogRGVmYXVsdCBjb252ZXJzaW9uIG9wdGlvbnMgdXNlZCBmb3Ige0BsaW5rIE1lc3NhZ2UjdG9KU09OfSBpbXBsZW1lbnRhdGlvbnMuXG4gKlxuICogVGhlc2Ugb3B0aW9ucyBhcmUgY2xvc2UgdG8gcHJvdG8zJ3MgSlNPTiBtYXBwaW5nIHdpdGggdGhlIGV4Y2VwdGlvbiB0aGF0IGludGVybmFsIHR5cGVzIGxpa2UgQW55IGFyZSBoYW5kbGVkIGp1c3QgbGlrZSBtZXNzYWdlcy4gTW9yZSBwcmVjaXNlbHk6XG4gKlxuICogLSBMb25ncyBiZWNvbWUgc3RyaW5nc1xuICogLSBFbnVtcyBiZWNvbWUgc3RyaW5nIGtleXNcbiAqIC0gQnl0ZXMgYmVjb21lIGJhc2U2NCBlbmNvZGVkIHN0cmluZ3NcbiAqIC0gKFN1Yi0pTWVzc2FnZXMgYmVjb21lIHBsYWluIG9iamVjdHNcbiAqIC0gTWFwcyBiZWNvbWUgcGxhaW4gb2JqZWN0cyB3aXRoIGFsbCBzdHJpbmcga2V5c1xuICogLSBSZXBlYXRlZCBmaWVsZHMgYmVjb21lIGFycmF5c1xuICogLSBOYU4gYW5kIEluZmluaXR5IGZvciBmbG9hdCBhbmQgZG91YmxlIGZpZWxkcyBiZWNvbWUgc3RyaW5nc1xuICpcbiAqIEB0eXBlIHtJQ29udmVyc2lvbk9wdGlvbnN9XG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL3Byb3RvY29sLWJ1ZmZlcnMvZG9jcy9wcm90bzM/aGw9ZW4janNvblxuICovXG51dGlsLnRvSlNPTk9wdGlvbnMgPSB7XG4gICAgbG9uZ3M6IFN0cmluZyxcbiAgICBlbnVtczogU3RyaW5nLFxuICAgIGJ5dGVzOiBTdHJpbmcsXG4gICAganNvbjogdHJ1ZVxufTtcblxuLy8gU2V0cyB1cCBidWZmZXIgdXRpbGl0eSBhY2NvcmRpbmcgdG8gdGhlIGVudmlyb25tZW50IChjYWxsZWQgaW4gaW5kZXgtbWluaW1hbClcbnV0aWwuX2NvbmZpZ3VyZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBCdWZmZXIgPSB1dGlsLkJ1ZmZlcjtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIUJ1ZmZlcikge1xuICAgICAgICB1dGlsLl9CdWZmZXJfZnJvbSA9IHV0aWwuX0J1ZmZlcl9hbGxvY1Vuc2FmZSA9IG51bGw7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gYmVjYXVzZSBub2RlIDQueCBidWZmZXJzIGFyZSBpbmNvbXBhdGlibGUgJiBpbW11dGFibGVcbiAgICAvLyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9kY29kZUlPL3Byb3RvYnVmLmpzL3B1bGwvNjY1XG4gICAgdXRpbC5fQnVmZmVyX2Zyb20gPSBCdWZmZXIuZnJvbSAhPT0gVWludDhBcnJheS5mcm9tICYmIEJ1ZmZlci5mcm9tIHx8XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIGZ1bmN0aW9uIEJ1ZmZlcl9mcm9tKHZhbHVlLCBlbmNvZGluZykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXIodmFsdWUsIGVuY29kaW5nKTtcbiAgICAgICAgfTtcbiAgICB1dGlsLl9CdWZmZXJfYWxsb2NVbnNhZmUgPSBCdWZmZXIuYWxsb2NVbnNhZmUgfHxcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgZnVuY3Rpb24gQnVmZmVyX2FsbG9jVW5zYWZlKHNpemUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQnVmZmVyKHNpemUpO1xuICAgICAgICB9O1xufTtcbiIsICJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gV3JpdGVyO1xuXG52YXIgdXRpbCAgICAgID0gcmVxdWlyZShcIi4vdXRpbC9taW5pbWFsXCIpO1xuXG52YXIgQnVmZmVyV3JpdGVyOyAvLyBjeWNsaWNcblxudmFyIExvbmdCaXRzICA9IHV0aWwuTG9uZ0JpdHMsXG4gICAgYmFzZTY0ICAgID0gdXRpbC5iYXNlNjQsXG4gICAgdXRmOCAgICAgID0gdXRpbC51dGY4O1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgd3JpdGVyIG9wZXJhdGlvbiBpbnN0YW5jZS5cbiAqIEBjbGFzc2Rlc2MgU2NoZWR1bGVkIHdyaXRlciBvcGVyYXRpb24uXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKiwgVWludDhBcnJheSwgbnVtYmVyKX0gZm4gRnVuY3Rpb24gdG8gY2FsbFxuICogQHBhcmFtIHtudW1iZXJ9IGxlbiBWYWx1ZSBieXRlIGxlbmd0aFxuICogQHBhcmFtIHsqfSB2YWwgVmFsdWUgdG8gd3JpdGVcbiAqIEBpZ25vcmVcbiAqL1xuZnVuY3Rpb24gT3AoZm4sIGxlbiwgdmFsKSB7XG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB0byBjYWxsLlxuICAgICAqIEB0eXBlIHtmdW5jdGlvbihVaW50OEFycmF5LCBudW1iZXIsICopfVxuICAgICAqL1xuICAgIHRoaXMuZm4gPSBmbjtcblxuICAgIC8qKlxuICAgICAqIFZhbHVlIGJ5dGUgbGVuZ3RoLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5sZW4gPSBsZW47XG5cbiAgICAvKipcbiAgICAgKiBOZXh0IG9wZXJhdGlvbi5cbiAgICAgKiBAdHlwZSB7V3JpdGVyLk9wfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLm5leHQgPSB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBWYWx1ZSB0byB3cml0ZS5cbiAgICAgKiBAdHlwZSB7Kn1cbiAgICAgKi9cbiAgICB0aGlzLnZhbCA9IHZhbDsgLy8gdHlwZSB2YXJpZXNcbn1cblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIG5vb3AoKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWVtcHR5LWZ1bmN0aW9uXG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyB3cml0ZXIgc3RhdGUgaW5zdGFuY2UuXG4gKiBAY2xhc3NkZXNjIENvcGllZCB3cml0ZXIgc3RhdGUuXG4gKiBAbWVtYmVyb2YgV3JpdGVyXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7V3JpdGVyfSB3cml0ZXIgV3JpdGVyIHRvIGNvcHkgc3RhdGUgZnJvbVxuICogQGlnbm9yZVxuICovXG5mdW5jdGlvbiBTdGF0ZSh3cml0ZXIpIHtcblxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgaGVhZC5cbiAgICAgKiBAdHlwZSB7V3JpdGVyLk9wfVxuICAgICAqL1xuICAgIHRoaXMuaGVhZCA9IHdyaXRlci5oZWFkO1xuXG4gICAgLyoqXG4gICAgICogQ3VycmVudCB0YWlsLlxuICAgICAqIEB0eXBlIHtXcml0ZXIuT3B9XG4gICAgICovXG4gICAgdGhpcy50YWlsID0gd3JpdGVyLnRhaWw7XG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IGJ1ZmZlciBsZW5ndGguXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmxlbiA9IHdyaXRlci5sZW47XG5cbiAgICAvKipcbiAgICAgKiBOZXh0IHN0YXRlLlxuICAgICAqIEB0eXBlIHtTdGF0ZXxudWxsfVxuICAgICAqL1xuICAgIHRoaXMubmV4dCA9IHdyaXRlci5zdGF0ZXM7XG59XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyB3cml0ZXIgaW5zdGFuY2UuXG4gKiBAY2xhc3NkZXNjIFdpcmUgZm9ybWF0IHdyaXRlciB1c2luZyBgVWludDhBcnJheWAgaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgYEFycmF5YC5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBXcml0ZXIoKSB7XG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IGxlbmd0aC5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubGVuID0gMDtcblxuICAgIC8qKlxuICAgICAqIE9wZXJhdGlvbnMgaGVhZC5cbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRoaXMuaGVhZCA9IG5ldyBPcChub29wLCAwLCAwKTtcblxuICAgIC8qKlxuICAgICAqIE9wZXJhdGlvbnMgdGFpbFxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgdGhpcy50YWlsID0gdGhpcy5oZWFkO1xuXG4gICAgLyoqXG4gICAgICogTGlua2VkIGZvcmtlZCBzdGF0ZXMuXG4gICAgICogQHR5cGUge09iamVjdHxudWxsfVxuICAgICAqL1xuICAgIHRoaXMuc3RhdGVzID0gbnVsbDtcblxuICAgIC8vIFdoZW4gYSB2YWx1ZSBpcyB3cml0dGVuLCB0aGUgd3JpdGVyIGNhbGN1bGF0ZXMgaXRzIGJ5dGUgbGVuZ3RoIGFuZCBwdXRzIGl0IGludG8gYSBsaW5rZWRcbiAgICAvLyBsaXN0IG9mIG9wZXJhdGlvbnMgdG8gcGVyZm9ybSB3aGVuIGZpbmlzaCgpIGlzIGNhbGxlZC4gVGhpcyBib3RoIGFsbG93cyB1cyB0byBhbGxvY2F0ZVxuICAgIC8vIGJ1ZmZlcnMgb2YgdGhlIGV4YWN0IHJlcXVpcmVkIHNpemUgYW5kIHJlZHVjZXMgdGhlIGFtb3VudCBvZiB3b3JrIHdlIGhhdmUgdG8gZG8gY29tcGFyZWRcbiAgICAvLyB0byBmaXJzdCBjYWxjdWxhdGluZyBvdmVyIG9iamVjdHMgYW5kIHRoZW4gZW5jb2Rpbmcgb3ZlciBvYmplY3RzLiBJbiBvdXIgY2FzZSwgdGhlIGVuY29kaW5nXG4gICAgLy8gcGFydCBpcyBqdXN0IGEgbGlua2VkIGxpc3Qgd2FsayBjYWxsaW5nIG9wZXJhdGlvbnMgd2l0aCBhbHJlYWR5IHByZXBhcmVkIHZhbHVlcy5cbn1cblxudmFyIGNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgICByZXR1cm4gdXRpbC5CdWZmZXJcbiAgICAgICAgPyBmdW5jdGlvbiBjcmVhdGVfYnVmZmVyX3NldHVwKCkge1xuICAgICAgICAgICAgcmV0dXJuIChXcml0ZXIuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlX2J1ZmZlcigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlcldyaXRlcigpO1xuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICA6IGZ1bmN0aW9uIGNyZWF0ZV9hcnJheSgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgV3JpdGVyKCk7XG4gICAgICAgIH07XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgd3JpdGVyLlxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7QnVmZmVyV3JpdGVyfFdyaXRlcn0gQSB7QGxpbmsgQnVmZmVyV3JpdGVyfSB3aGVuIEJ1ZmZlcnMgYXJlIHN1cHBvcnRlZCwgb3RoZXJ3aXNlIGEge0BsaW5rIFdyaXRlcn1cbiAqL1xuV3JpdGVyLmNyZWF0ZSA9IGNyZWF0ZSgpO1xuXG4vKipcbiAqIEFsbG9jYXRlcyBhIGJ1ZmZlciBvZiB0aGUgc3BlY2lmaWVkIHNpemUuXG4gKiBAcGFyYW0ge251bWJlcn0gc2l6ZSBCdWZmZXIgc2l6ZVxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9IEJ1ZmZlclxuICovXG5Xcml0ZXIuYWxsb2MgPSBmdW5jdGlvbiBhbGxvYyhzaXplKSB7XG4gICAgcmV0dXJuIG5ldyB1dGlsLkFycmF5KHNpemUpO1xufTtcblxuLy8gVXNlIFVpbnQ4QXJyYXkgYnVmZmVyIHBvb2wgaW4gdGhlIGJyb3dzZXIsIGp1c3QgbGlrZSBub2RlIGRvZXMgd2l0aCBidWZmZXJzXG4vKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuaWYgKHV0aWwuQXJyYXkgIT09IEFycmF5KVxuICAgIFdyaXRlci5hbGxvYyA9IHV0aWwucG9vbChXcml0ZXIuYWxsb2MsIHV0aWwuQXJyYXkucHJvdG90eXBlLnN1YmFycmF5KTtcblxuLyoqXG4gKiBQdXNoZXMgYSBuZXcgb3BlcmF0aW9uIHRvIHRoZSBxdWV1ZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oVWludDhBcnJheSwgbnVtYmVyLCAqKX0gZm4gRnVuY3Rpb24gdG8gY2FsbFxuICogQHBhcmFtIHtudW1iZXJ9IGxlbiBWYWx1ZSBieXRlIGxlbmd0aFxuICogQHBhcmFtIHtudW1iZXJ9IHZhbCBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKiBAcHJpdmF0ZVxuICovXG5Xcml0ZXIucHJvdG90eXBlLl9wdXNoID0gZnVuY3Rpb24gcHVzaChmbiwgbGVuLCB2YWwpIHtcbiAgICB0aGlzLnRhaWwgPSB0aGlzLnRhaWwubmV4dCA9IG5ldyBPcChmbiwgbGVuLCB2YWwpO1xuICAgIHRoaXMubGVuICs9IGxlbjtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIHdyaXRlQnl0ZSh2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgYnVmW3Bvc10gPSB2YWwgJiAyNTU7XG59XG5cbmZ1bmN0aW9uIHdyaXRlVmFyaW50MzIodmFsLCBidWYsIHBvcykge1xuICAgIHdoaWxlICh2YWwgPiAxMjcpIHtcbiAgICAgICAgYnVmW3BvcysrXSA9IHZhbCAmIDEyNyB8IDEyODtcbiAgICAgICAgdmFsID4+Pj0gNztcbiAgICB9XG4gICAgYnVmW3Bvc10gPSB2YWw7XG59XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyB2YXJpbnQgd3JpdGVyIG9wZXJhdGlvbiBpbnN0YW5jZS5cbiAqIEBjbGFzc2Rlc2MgU2NoZWR1bGVkIHZhcmludCB3cml0ZXIgb3BlcmF0aW9uLlxuICogQGV4dGVuZHMgT3BcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtudW1iZXJ9IGxlbiBWYWx1ZSBieXRlIGxlbmd0aFxuICogQHBhcmFtIHtudW1iZXJ9IHZhbCBWYWx1ZSB0byB3cml0ZVxuICogQGlnbm9yZVxuICovXG5mdW5jdGlvbiBWYXJpbnRPcChsZW4sIHZhbCkge1xuICAgIHRoaXMubGVuID0gbGVuO1xuICAgIHRoaXMubmV4dCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnZhbCA9IHZhbDtcbn1cblxuVmFyaW50T3AucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShPcC5wcm90b3R5cGUpO1xuVmFyaW50T3AucHJvdG90eXBlLmZuID0gd3JpdGVWYXJpbnQzMjtcblxuLyoqXG4gKiBXcml0ZXMgYW4gdW5zaWduZWQgMzIgYml0IHZhbHVlIGFzIGEgdmFyaW50LlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS51aW50MzIgPSBmdW5jdGlvbiB3cml0ZV91aW50MzIodmFsdWUpIHtcbiAgICAvLyBoZXJlLCB0aGUgY2FsbCB0byB0aGlzLnB1c2ggaGFzIGJlZW4gaW5saW5lZCBhbmQgYSB2YXJpbnQgc3BlY2lmaWMgT3Agc3ViY2xhc3MgaXMgdXNlZC5cbiAgICAvLyB1aW50MzIgaXMgYnkgZmFyIHRoZSBtb3N0IGZyZXF1ZW50bHkgdXNlZCBvcGVyYXRpb24gYW5kIGJlbmVmaXRzIHNpZ25pZmljYW50bHkgZnJvbSB0aGlzLlxuICAgIHRoaXMubGVuICs9ICh0aGlzLnRhaWwgPSB0aGlzLnRhaWwubmV4dCA9IG5ldyBWYXJpbnRPcChcbiAgICAgICAgKHZhbHVlID0gdmFsdWUgPj4+IDApXG4gICAgICAgICAgICAgICAgPCAxMjggICAgICAgPyAxXG4gICAgICAgIDogdmFsdWUgPCAxNjM4NCAgICAgPyAyXG4gICAgICAgIDogdmFsdWUgPCAyMDk3MTUyICAgPyAzXG4gICAgICAgIDogdmFsdWUgPCAyNjg0MzU0NTYgPyA0XG4gICAgICAgIDogICAgICAgICAgICAgICAgICAgICA1LFxuICAgIHZhbHVlKSkubGVuO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBXcml0ZXMgYSBzaWduZWQgMzIgYml0IHZhbHVlIGFzIGEgdmFyaW50LlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLmludDMyID0gZnVuY3Rpb24gd3JpdGVfaW50MzIodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPCAwXG4gICAgICAgID8gdGhpcy5fcHVzaCh3cml0ZVZhcmludDY0LCAxMCwgTG9uZ0JpdHMuZnJvbU51bWJlcih2YWx1ZSkpIC8vIDEwIGJ5dGVzIHBlciBzcGVjXG4gICAgICAgIDogdGhpcy51aW50MzIodmFsdWUpO1xufTtcblxuLyoqXG4gKiBXcml0ZXMgYSAzMiBiaXQgdmFsdWUgYXMgYSB2YXJpbnQsIHppZy16YWcgZW5jb2RlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUuc2ludDMyID0gZnVuY3Rpb24gd3JpdGVfc2ludDMyKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMudWludDMyKCh2YWx1ZSA8PCAxIF4gdmFsdWUgPj4gMzEpID4+PiAwKTtcbn07XG5cbmZ1bmN0aW9uIHdyaXRlVmFyaW50NjQodmFsLCBidWYsIHBvcykge1xuICAgIHdoaWxlICh2YWwuaGkpIHtcbiAgICAgICAgYnVmW3BvcysrXSA9IHZhbC5sbyAmIDEyNyB8IDEyODtcbiAgICAgICAgdmFsLmxvID0gKHZhbC5sbyA+Pj4gNyB8IHZhbC5oaSA8PCAyNSkgPj4+IDA7XG4gICAgICAgIHZhbC5oaSA+Pj49IDc7XG4gICAgfVxuICAgIHdoaWxlICh2YWwubG8gPiAxMjcpIHtcbiAgICAgICAgYnVmW3BvcysrXSA9IHZhbC5sbyAmIDEyNyB8IDEyODtcbiAgICAgICAgdmFsLmxvID0gdmFsLmxvID4+PiA3O1xuICAgIH1cbiAgICBidWZbcG9zKytdID0gdmFsLmxvO1xufVxuXG4vKipcbiAqIFdyaXRlcyBhbiB1bnNpZ25lZCA2NCBiaXQgdmFsdWUgYXMgYSB2YXJpbnQuXG4gKiBAcGFyYW0ge0xvbmd8bnVtYmVyfHN0cmluZ30gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBgdmFsdWVgIGlzIGEgc3RyaW5nIGFuZCBubyBsb25nIGxpYnJhcnkgaXMgcHJlc2VudC5cbiAqL1xuV3JpdGVyLnByb3RvdHlwZS51aW50NjQgPSBmdW5jdGlvbiB3cml0ZV91aW50NjQodmFsdWUpIHtcbiAgICB2YXIgYml0cyA9IExvbmdCaXRzLmZyb20odmFsdWUpO1xuICAgIHJldHVybiB0aGlzLl9wdXNoKHdyaXRlVmFyaW50NjQsIGJpdHMubGVuZ3RoKCksIGJpdHMpO1xufTtcblxuLyoqXG4gKiBXcml0ZXMgYSBzaWduZWQgNjQgYml0IHZhbHVlIGFzIGEgdmFyaW50LlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0xvbmd8bnVtYmVyfHN0cmluZ30gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBgdmFsdWVgIGlzIGEgc3RyaW5nIGFuZCBubyBsb25nIGxpYnJhcnkgaXMgcHJlc2VudC5cbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5pbnQ2NCA9IFdyaXRlci5wcm90b3R5cGUudWludDY0O1xuXG4vKipcbiAqIFdyaXRlcyBhIHNpZ25lZCA2NCBiaXQgdmFsdWUgYXMgYSB2YXJpbnQsIHppZy16YWcgZW5jb2RlZC5cbiAqIEBwYXJhbSB7TG9uZ3xudW1iZXJ8c3RyaW5nfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGB2YWx1ZWAgaXMgYSBzdHJpbmcgYW5kIG5vIGxvbmcgbGlicmFyeSBpcyBwcmVzZW50LlxuICovXG5Xcml0ZXIucHJvdG90eXBlLnNpbnQ2NCA9IGZ1bmN0aW9uIHdyaXRlX3NpbnQ2NCh2YWx1ZSkge1xuICAgIHZhciBiaXRzID0gTG9uZ0JpdHMuZnJvbSh2YWx1ZSkuenpFbmNvZGUoKTtcbiAgICByZXR1cm4gdGhpcy5fcHVzaCh3cml0ZVZhcmludDY0LCBiaXRzLmxlbmd0aCgpLCBiaXRzKTtcbn07XG5cbi8qKlxuICogV3JpdGVzIGEgYm9vbGlzaCB2YWx1ZSBhcyBhIHZhcmludC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLmJvb2wgPSBmdW5jdGlvbiB3cml0ZV9ib29sKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuX3B1c2god3JpdGVCeXRlLCAxLCB2YWx1ZSA/IDEgOiAwKTtcbn07XG5cbmZ1bmN0aW9uIHdyaXRlRml4ZWQzMih2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgYnVmW3BvcyAgICBdID0gIHZhbCAgICAgICAgICYgMjU1O1xuICAgIGJ1Zltwb3MgKyAxXSA9ICB2YWwgPj4+IDggICAmIDI1NTtcbiAgICBidWZbcG9zICsgMl0gPSAgdmFsID4+PiAxNiAgJiAyNTU7XG4gICAgYnVmW3BvcyArIDNdID0gIHZhbCA+Pj4gMjQ7XG59XG5cbi8qKlxuICogV3JpdGVzIGFuIHVuc2lnbmVkIDMyIGJpdCB2YWx1ZSBhcyBmaXhlZCAzMiBiaXRzLlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5maXhlZDMyID0gZnVuY3Rpb24gd3JpdGVfZml4ZWQzMih2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLl9wdXNoKHdyaXRlRml4ZWQzMiwgNCwgdmFsdWUgPj4+IDApO1xufTtcblxuLyoqXG4gKiBXcml0ZXMgYSBzaWduZWQgMzIgYml0IHZhbHVlIGFzIGZpeGVkIDMyIGJpdHMuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUuc2ZpeGVkMzIgPSBXcml0ZXIucHJvdG90eXBlLmZpeGVkMzI7XG5cbi8qKlxuICogV3JpdGVzIGFuIHVuc2lnbmVkIDY0IGJpdCB2YWx1ZSBhcyBmaXhlZCA2NCBiaXRzLlxuICogQHBhcmFtIHtMb25nfG51bWJlcnxzdHJpbmd9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYHZhbHVlYCBpcyBhIHN0cmluZyBhbmQgbm8gbG9uZyBsaWJyYXJ5IGlzIHByZXNlbnQuXG4gKi9cbldyaXRlci5wcm90b3R5cGUuZml4ZWQ2NCA9IGZ1bmN0aW9uIHdyaXRlX2ZpeGVkNjQodmFsdWUpIHtcbiAgICB2YXIgYml0cyA9IExvbmdCaXRzLmZyb20odmFsdWUpO1xuICAgIHJldHVybiB0aGlzLl9wdXNoKHdyaXRlRml4ZWQzMiwgNCwgYml0cy5sbykuX3B1c2god3JpdGVGaXhlZDMyLCA0LCBiaXRzLmhpKTtcbn07XG5cbi8qKlxuICogV3JpdGVzIGEgc2lnbmVkIDY0IGJpdCB2YWx1ZSBhcyBmaXhlZCA2NCBiaXRzLlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0xvbmd8bnVtYmVyfHN0cmluZ30gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBgdmFsdWVgIGlzIGEgc3RyaW5nIGFuZCBubyBsb25nIGxpYnJhcnkgaXMgcHJlc2VudC5cbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5zZml4ZWQ2NCA9IFdyaXRlci5wcm90b3R5cGUuZml4ZWQ2NDtcblxuLyoqXG4gKiBXcml0ZXMgYSBmbG9hdCAoMzIgYml0KS5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5mbG9hdCA9IGZ1bmN0aW9uIHdyaXRlX2Zsb2F0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuX3B1c2godXRpbC5mbG9hdC53cml0ZUZsb2F0TEUsIDQsIHZhbHVlKTtcbn07XG5cbi8qKlxuICogV3JpdGVzIGEgZG91YmxlICg2NCBiaXQgZmxvYXQpLlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLmRvdWJsZSA9IGZ1bmN0aW9uIHdyaXRlX2RvdWJsZSh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLl9wdXNoKHV0aWwuZmxvYXQud3JpdGVEb3VibGVMRSwgOCwgdmFsdWUpO1xufTtcblxudmFyIHdyaXRlQnl0ZXMgPSB1dGlsLkFycmF5LnByb3RvdHlwZS5zZXRcbiAgICA/IGZ1bmN0aW9uIHdyaXRlQnl0ZXNfc2V0KHZhbCwgYnVmLCBwb3MpIHtcbiAgICAgICAgYnVmLnNldCh2YWwsIHBvcyk7IC8vIGFsc28gd29ya3MgZm9yIHBsYWluIGFycmF5IHZhbHVlc1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIDogZnVuY3Rpb24gd3JpdGVCeXRlc19mb3IodmFsLCBidWYsIHBvcykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbC5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgIGJ1Zltwb3MgKyBpXSA9IHZhbFtpXTtcbiAgICB9O1xuXG4vKipcbiAqIFdyaXRlcyBhIHNlcXVlbmNlIG9mIGJ5dGVzLlxuICogQHBhcmFtIHtVaW50OEFycmF5fHN0cmluZ30gdmFsdWUgQnVmZmVyIG9yIGJhc2U2NCBlbmNvZGVkIHN0cmluZyB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUuYnl0ZXMgPSBmdW5jdGlvbiB3cml0ZV9ieXRlcyh2YWx1ZSkge1xuICAgIHZhciBsZW4gPSB2YWx1ZS5sZW5ndGggPj4+IDA7XG4gICAgaWYgKCFsZW4pXG4gICAgICAgIHJldHVybiB0aGlzLl9wdXNoKHdyaXRlQnl0ZSwgMSwgMCk7XG4gICAgaWYgKHV0aWwuaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgIHZhciBidWYgPSBXcml0ZXIuYWxsb2MobGVuID0gYmFzZTY0Lmxlbmd0aCh2YWx1ZSkpO1xuICAgICAgICBiYXNlNjQuZGVjb2RlKHZhbHVlLCBidWYsIDApO1xuICAgICAgICB2YWx1ZSA9IGJ1ZjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudWludDMyKGxlbikuX3B1c2god3JpdGVCeXRlcywgbGVuLCB2YWx1ZSk7XG59O1xuXG4vKipcbiAqIFdyaXRlcyBhIHN0cmluZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUuc3RyaW5nID0gZnVuY3Rpb24gd3JpdGVfc3RyaW5nKHZhbHVlKSB7XG4gICAgdmFyIGxlbiA9IHV0ZjgubGVuZ3RoKHZhbHVlKTtcbiAgICByZXR1cm4gbGVuXG4gICAgICAgID8gdGhpcy51aW50MzIobGVuKS5fcHVzaCh1dGY4LndyaXRlLCBsZW4sIHZhbHVlKVxuICAgICAgICA6IHRoaXMuX3B1c2god3JpdGVCeXRlLCAxLCAwKTtcbn07XG5cbi8qKlxuICogRm9ya3MgdGhpcyB3cml0ZXIncyBzdGF0ZSBieSBwdXNoaW5nIGl0IHRvIGEgc3RhY2suXG4gKiBDYWxsaW5nIHtAbGluayBXcml0ZXIjcmVzZXR8cmVzZXR9IG9yIHtAbGluayBXcml0ZXIjbGRlbGltfGxkZWxpbX0gcmVzZXRzIHRoZSB3cml0ZXIgdG8gdGhlIHByZXZpb3VzIHN0YXRlLlxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUuZm9yayA9IGZ1bmN0aW9uIGZvcmsoKSB7XG4gICAgdGhpcy5zdGF0ZXMgPSBuZXcgU3RhdGUodGhpcyk7XG4gICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbmV3IE9wKG5vb3AsIDAsIDApO1xuICAgIHRoaXMubGVuID0gMDtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVzZXRzIHRoaXMgaW5zdGFuY2UgdG8gdGhlIGxhc3Qgc3RhdGUuXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIGlmICh0aGlzLnN0YXRlcykge1xuICAgICAgICB0aGlzLmhlYWQgICA9IHRoaXMuc3RhdGVzLmhlYWQ7XG4gICAgICAgIHRoaXMudGFpbCAgID0gdGhpcy5zdGF0ZXMudGFpbDtcbiAgICAgICAgdGhpcy5sZW4gICAgPSB0aGlzLnN0YXRlcy5sZW47XG4gICAgICAgIHRoaXMuc3RhdGVzID0gdGhpcy5zdGF0ZXMubmV4dDtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBuZXcgT3Aobm9vcCwgMCwgMCk7XG4gICAgICAgIHRoaXMubGVuICA9IDA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZXNldHMgdG8gdGhlIGxhc3Qgc3RhdGUgYW5kIGFwcGVuZHMgdGhlIGZvcmsgc3RhdGUncyBjdXJyZW50IHdyaXRlIGxlbmd0aCBhcyBhIHZhcmludCBmb2xsb3dlZCBieSBpdHMgb3BlcmF0aW9ucy5cbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLmxkZWxpbSA9IGZ1bmN0aW9uIGxkZWxpbSgpIHtcbiAgICB2YXIgaGVhZCA9IHRoaXMuaGVhZCxcbiAgICAgICAgdGFpbCA9IHRoaXMudGFpbCxcbiAgICAgICAgbGVuICA9IHRoaXMubGVuO1xuICAgIHRoaXMucmVzZXQoKS51aW50MzIobGVuKTtcbiAgICBpZiAobGVuKSB7XG4gICAgICAgIHRoaXMudGFpbC5uZXh0ID0gaGVhZC5uZXh0OyAvLyBza2lwIG5vb3BcbiAgICAgICAgdGhpcy50YWlsID0gdGFpbDtcbiAgICAgICAgdGhpcy5sZW4gKz0gbGVuO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRmluaXNoZXMgdGhlIHdyaXRlIG9wZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fSBGaW5pc2hlZCBidWZmZXJcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5maW5pc2ggPSBmdW5jdGlvbiBmaW5pc2goKSB7XG4gICAgdmFyIGhlYWQgPSB0aGlzLmhlYWQubmV4dCwgLy8gc2tpcCBub29wXG4gICAgICAgIGJ1ZiAgPSB0aGlzLmNvbnN0cnVjdG9yLmFsbG9jKHRoaXMubGVuKSxcbiAgICAgICAgcG9zICA9IDA7XG4gICAgd2hpbGUgKGhlYWQpIHtcbiAgICAgICAgaGVhZC5mbihoZWFkLnZhbCwgYnVmLCBwb3MpO1xuICAgICAgICBwb3MgKz0gaGVhZC5sZW47XG4gICAgICAgIGhlYWQgPSBoZWFkLm5leHQ7XG4gICAgfVxuICAgIC8vIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7XG4gICAgcmV0dXJuIGJ1Zjtcbn07XG5cbldyaXRlci5fY29uZmlndXJlID0gZnVuY3Rpb24oQnVmZmVyV3JpdGVyXykge1xuICAgIEJ1ZmZlcldyaXRlciA9IEJ1ZmZlcldyaXRlcl87XG4gICAgV3JpdGVyLmNyZWF0ZSA9IGNyZWF0ZSgpO1xuICAgIEJ1ZmZlcldyaXRlci5fY29uZmlndXJlKCk7XG59O1xuIiwgIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBCdWZmZXJXcml0ZXI7XG5cbi8vIGV4dGVuZHMgV3JpdGVyXG52YXIgV3JpdGVyID0gcmVxdWlyZShcIi4vd3JpdGVyXCIpO1xuKEJ1ZmZlcldyaXRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFdyaXRlci5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IEJ1ZmZlcldyaXRlcjtcblxudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsL21pbmltYWxcIik7XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyBidWZmZXIgd3JpdGVyIGluc3RhbmNlLlxuICogQGNsYXNzZGVzYyBXaXJlIGZvcm1hdCB3cml0ZXIgdXNpbmcgbm9kZSBidWZmZXJzLlxuICogQGV4dGVuZHMgV3JpdGVyXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gQnVmZmVyV3JpdGVyKCkge1xuICAgIFdyaXRlci5jYWxsKHRoaXMpO1xufVxuXG5CdWZmZXJXcml0ZXIuX2NvbmZpZ3VyZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBBbGxvY2F0ZXMgYSBidWZmZXIgb2YgdGhlIHNwZWNpZmllZCBzaXplLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzaXplIEJ1ZmZlciBzaXplXG4gICAgICogQHJldHVybnMge0J1ZmZlcn0gQnVmZmVyXG4gICAgICovXG4gICAgQnVmZmVyV3JpdGVyLmFsbG9jID0gdXRpbC5fQnVmZmVyX2FsbG9jVW5zYWZlO1xuXG4gICAgQnVmZmVyV3JpdGVyLndyaXRlQnl0ZXNCdWZmZXIgPSB1dGlsLkJ1ZmZlciAmJiB1dGlsLkJ1ZmZlci5wcm90b3R5cGUgaW5zdGFuY2VvZiBVaW50OEFycmF5ICYmIHV0aWwuQnVmZmVyLnByb3RvdHlwZS5zZXQubmFtZSA9PT0gXCJzZXRcIlxuICAgICAgICA/IGZ1bmN0aW9uIHdyaXRlQnl0ZXNCdWZmZXJfc2V0KHZhbCwgYnVmLCBwb3MpIHtcbiAgICAgICAgICBidWYuc2V0KHZhbCwgcG9zKTsgLy8gZmFzdGVyIHRoYW4gY29weSAocmVxdWlyZXMgbm9kZSA+PSA0IHdoZXJlIEJ1ZmZlcnMgZXh0ZW5kIFVpbnQ4QXJyYXkgYW5kIHNldCBpcyBwcm9wZXJseSBpbmhlcml0ZWQpXG4gICAgICAgICAgLy8gYWxzbyB3b3JrcyBmb3IgcGxhaW4gYXJyYXkgdmFsdWVzXG4gICAgICAgIH1cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgOiBmdW5jdGlvbiB3cml0ZUJ5dGVzQnVmZmVyX2NvcHkodmFsLCBidWYsIHBvcykge1xuICAgICAgICAgIGlmICh2YWwuY29weSkgLy8gQnVmZmVyIHZhbHVlc1xuICAgICAgICAgICAgdmFsLmNvcHkoYnVmLCBwb3MsIDAsIHZhbC5sZW5ndGgpO1xuICAgICAgICAgIGVsc2UgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWwubGVuZ3RoOykgLy8gcGxhaW4gYXJyYXkgdmFsdWVzXG4gICAgICAgICAgICBidWZbcG9zKytdID0gdmFsW2krK107XG4gICAgICAgIH07XG59O1xuXG5cbi8qKlxuICogQG92ZXJyaWRlXG4gKi9cbkJ1ZmZlcldyaXRlci5wcm90b3R5cGUuYnl0ZXMgPSBmdW5jdGlvbiB3cml0ZV9ieXRlc19idWZmZXIodmFsdWUpIHtcbiAgICBpZiAodXRpbC5pc1N0cmluZyh2YWx1ZSkpXG4gICAgICAgIHZhbHVlID0gdXRpbC5fQnVmZmVyX2Zyb20odmFsdWUsIFwiYmFzZTY0XCIpO1xuICAgIHZhciBsZW4gPSB2YWx1ZS5sZW5ndGggPj4+IDA7XG4gICAgdGhpcy51aW50MzIobGVuKTtcbiAgICBpZiAobGVuKVxuICAgICAgICB0aGlzLl9wdXNoKEJ1ZmZlcldyaXRlci53cml0ZUJ5dGVzQnVmZmVyLCBsZW4sIHZhbHVlKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIHdyaXRlU3RyaW5nQnVmZmVyKHZhbCwgYnVmLCBwb3MpIHtcbiAgICBpZiAodmFsLmxlbmd0aCA8IDQwKSAvLyBwbGFpbiBqcyBpcyBmYXN0ZXIgZm9yIHNob3J0IHN0cmluZ3MgKHByb2JhYmx5IGR1ZSB0byByZWR1bmRhbnQgYXNzZXJ0aW9ucylcbiAgICAgICAgdXRpbC51dGY4LndyaXRlKHZhbCwgYnVmLCBwb3MpO1xuICAgIGVsc2UgaWYgKGJ1Zi51dGY4V3JpdGUpXG4gICAgICAgIGJ1Zi51dGY4V3JpdGUodmFsLCBwb3MpO1xuICAgIGVsc2VcbiAgICAgICAgYnVmLndyaXRlKHZhbCwgcG9zKTtcbn1cblxuLyoqXG4gKiBAb3ZlcnJpZGVcbiAqL1xuQnVmZmVyV3JpdGVyLnByb3RvdHlwZS5zdHJpbmcgPSBmdW5jdGlvbiB3cml0ZV9zdHJpbmdfYnVmZmVyKHZhbHVlKSB7XG4gICAgdmFyIGxlbiA9IHV0aWwuQnVmZmVyLmJ5dGVMZW5ndGgodmFsdWUpO1xuICAgIHRoaXMudWludDMyKGxlbik7XG4gICAgaWYgKGxlbilcbiAgICAgICAgdGhpcy5fcHVzaCh3cml0ZVN0cmluZ0J1ZmZlciwgbGVuLCB2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbi8qKlxuICogRmluaXNoZXMgdGhlIHdyaXRlIG9wZXJhdGlvbi5cbiAqIEBuYW1lIEJ1ZmZlcldyaXRlciNmaW5pc2hcbiAqIEBmdW5jdGlvblxuICogQHJldHVybnMge0J1ZmZlcn0gRmluaXNoZWQgYnVmZmVyXG4gKi9cblxuQnVmZmVyV3JpdGVyLl9jb25maWd1cmUoKTtcbiIsICJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gUmVhZGVyO1xuXG52YXIgdXRpbCAgICAgID0gcmVxdWlyZShcIi4vdXRpbC9taW5pbWFsXCIpO1xuXG52YXIgQnVmZmVyUmVhZGVyOyAvLyBjeWNsaWNcblxudmFyIExvbmdCaXRzICA9IHV0aWwuTG9uZ0JpdHMsXG4gICAgdXRmOCAgICAgID0gdXRpbC51dGY4O1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gaW5kZXhPdXRPZlJhbmdlKHJlYWRlciwgd3JpdGVMZW5ndGgpIHtcbiAgICByZXR1cm4gUmFuZ2VFcnJvcihcImluZGV4IG91dCBvZiByYW5nZTogXCIgKyByZWFkZXIucG9zICsgXCIgKyBcIiArICh3cml0ZUxlbmd0aCB8fCAxKSArIFwiID4gXCIgKyByZWFkZXIubGVuKTtcbn1cblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IHJlYWRlciBpbnN0YW5jZSB1c2luZyB0aGUgc3BlY2lmaWVkIGJ1ZmZlci5cbiAqIEBjbGFzc2Rlc2MgV2lyZSBmb3JtYXQgcmVhZGVyIHVzaW5nIGBVaW50OEFycmF5YCBpZiBhdmFpbGFibGUsIG90aGVyd2lzZSBgQXJyYXlgLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZmZlciBCdWZmZXIgdG8gcmVhZCBmcm9tXG4gKi9cbmZ1bmN0aW9uIFJlYWRlcihidWZmZXIpIHtcblxuICAgIC8qKlxuICAgICAqIFJlYWQgYnVmZmVyLlxuICAgICAqIEB0eXBlIHtVaW50OEFycmF5fVxuICAgICAqL1xuICAgIHRoaXMuYnVmID0gYnVmZmVyO1xuXG4gICAgLyoqXG4gICAgICogUmVhZCBidWZmZXIgcG9zaXRpb24uXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnBvcyA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBSZWFkIGJ1ZmZlciBsZW5ndGguXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmxlbiA9IGJ1ZmZlci5sZW5ndGg7XG59XG5cbnZhciBjcmVhdGVfYXJyYXkgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gXCJ1bmRlZmluZWRcIlxuICAgID8gZnVuY3Rpb24gY3JlYXRlX3R5cGVkX2FycmF5KGJ1ZmZlcikge1xuICAgICAgICBpZiAoYnVmZmVyIGluc3RhbmNlb2YgVWludDhBcnJheSB8fCBBcnJheS5pc0FycmF5KGJ1ZmZlcikpXG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlYWRlcihidWZmZXIpO1xuICAgICAgICB0aHJvdyBFcnJvcihcImlsbGVnYWwgYnVmZmVyXCIpO1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIDogZnVuY3Rpb24gY3JlYXRlX2FycmF5KGJ1ZmZlcikge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShidWZmZXIpKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWFkZXIoYnVmZmVyKTtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJpbGxlZ2FsIGJ1ZmZlclwiKTtcbiAgICB9O1xuXG52YXIgY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKCkge1xuICAgIHJldHVybiB1dGlsLkJ1ZmZlclxuICAgICAgICA/IGZ1bmN0aW9uIGNyZWF0ZV9idWZmZXJfc2V0dXAoYnVmZmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gKFJlYWRlci5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGVfYnVmZmVyKGJ1ZmZlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB1dGlsLkJ1ZmZlci5pc0J1ZmZlcihidWZmZXIpXG4gICAgICAgICAgICAgICAgICAgID8gbmV3IEJ1ZmZlclJlYWRlcihidWZmZXIpXG4gICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICAgICAgICAgIDogY3JlYXRlX2FycmF5KGJ1ZmZlcik7XG4gICAgICAgICAgICB9KShidWZmZXIpO1xuICAgICAgICB9XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIDogY3JlYXRlX2FycmF5O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHJlYWRlciB1c2luZyB0aGUgc3BlY2lmaWVkIGJ1ZmZlci5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtVaW50OEFycmF5fEJ1ZmZlcn0gYnVmZmVyIEJ1ZmZlciB0byByZWFkIGZyb21cbiAqIEByZXR1cm5zIHtSZWFkZXJ8QnVmZmVyUmVhZGVyfSBBIHtAbGluayBCdWZmZXJSZWFkZXJ9IGlmIGBidWZmZXJgIGlzIGEgQnVmZmVyLCBvdGhlcndpc2UgYSB7QGxpbmsgUmVhZGVyfVxuICogQHRocm93cyB7RXJyb3J9IElmIGBidWZmZXJgIGlzIG5vdCBhIHZhbGlkIGJ1ZmZlclxuICovXG5SZWFkZXIuY3JlYXRlID0gY3JlYXRlKCk7XG5cblJlYWRlci5wcm90b3R5cGUuX3NsaWNlID0gdXRpbC5BcnJheS5wcm90b3R5cGUuc3ViYXJyYXkgfHwgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gdXRpbC5BcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cbi8qKlxuICogUmVhZHMgYSB2YXJpbnQgYXMgYW4gdW5zaWduZWQgMzIgYml0IHZhbHVlLlxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXG4gKi9cblJlYWRlci5wcm90b3R5cGUudWludDMyID0gKGZ1bmN0aW9uIHJlYWRfdWludDMyX3NldHVwKCkge1xuICAgIHZhciB2YWx1ZSA9IDQyOTQ5NjcyOTU7IC8vIG9wdGltaXplciB0eXBlLWhpbnQsIHRlbmRzIHRvIGRlb3B0IG90aGVyd2lzZSAoPyEpXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHJlYWRfdWludDMyKCkge1xuICAgICAgICB2YWx1ZSA9ICggICAgICAgICB0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcgICAgICAgKSA+Pj4gMDsgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KSByZXR1cm4gdmFsdWU7XG4gICAgICAgIHZhbHVlID0gKHZhbHVlIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPDwgIDcpID4+PiAwOyBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpIHJldHVybiB2YWx1ZTtcbiAgICAgICAgdmFsdWUgPSAodmFsdWUgfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA8PCAxNCkgPj4+IDA7IGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOCkgcmV0dXJuIHZhbHVlO1xuICAgICAgICB2YWx1ZSA9ICh2YWx1ZSB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpIDw8IDIxKSA+Pj4gMDsgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KSByZXR1cm4gdmFsdWU7XG4gICAgICAgIHZhbHVlID0gKHZhbHVlIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmICAxNSkgPDwgMjgpID4+PiAwOyBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpIHJldHVybiB2YWx1ZTtcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCh0aGlzLnBvcyArPSA1KSA+IHRoaXMubGVuKSB7XG4gICAgICAgICAgICB0aGlzLnBvcyA9IHRoaXMubGVuO1xuICAgICAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMsIDEwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbn0pKCk7XG5cbi8qKlxuICogUmVhZHMgYSB2YXJpbnQgYXMgYSBzaWduZWQgMzIgYml0IHZhbHVlLlxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxuICovXG5SZWFkZXIucHJvdG90eXBlLmludDMyID0gZnVuY3Rpb24gcmVhZF9pbnQzMigpIHtcbiAgICByZXR1cm4gdGhpcy51aW50MzIoKSB8IDA7XG59O1xuXG4vKipcbiAqIFJlYWRzIGEgemlnLXphZyBlbmNvZGVkIHZhcmludCBhcyBhIHNpZ25lZCAzMiBiaXQgdmFsdWUuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXG4gKi9cblJlYWRlci5wcm90b3R5cGUuc2ludDMyID0gZnVuY3Rpb24gcmVhZF9zaW50MzIoKSB7XG4gICAgdmFyIHZhbHVlID0gdGhpcy51aW50MzIoKTtcbiAgICByZXR1cm4gdmFsdWUgPj4+IDEgXiAtKHZhbHVlICYgMSkgfCAwO1xufTtcblxuLyogZXNsaW50LWRpc2FibGUgbm8taW52YWxpZC10aGlzICovXG5cbmZ1bmN0aW9uIHJlYWRMb25nVmFyaW50KCkge1xuICAgIC8vIHRlbmRzIHRvIGRlb3B0IHdpdGggbG9jYWwgdmFycyBmb3Igb2N0ZXQgZXRjLlxuICAgIHZhciBiaXRzID0gbmV3IExvbmdCaXRzKDAsIDApO1xuICAgIHZhciBpID0gMDtcbiAgICBpZiAodGhpcy5sZW4gLSB0aGlzLnBvcyA+IDQpIHsgLy8gZmFzdCByb3V0ZSAobG8pXG4gICAgICAgIGZvciAoOyBpIDwgNDsgKytpKSB7XG4gICAgICAgICAgICAvLyAxc3QuLjR0aFxuICAgICAgICAgICAgYml0cy5sbyA9IChiaXRzLmxvIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPDwgaSAqIDcpID4+PiAwO1xuICAgICAgICAgICAgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KVxuICAgICAgICAgICAgICAgIHJldHVybiBiaXRzO1xuICAgICAgICB9XG4gICAgICAgIC8vIDV0aFxuICAgICAgICBiaXRzLmxvID0gKGJpdHMubG8gfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA8PCAyOCkgPj4+IDA7XG4gICAgICAgIGJpdHMuaGkgPSAoYml0cy5oaSB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpID4+ICA0KSA+Pj4gMDtcbiAgICAgICAgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KVxuICAgICAgICAgICAgcmV0dXJuIGJpdHM7XG4gICAgICAgIGkgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoOyBpIDwgMzsgKytpKSB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgIGlmICh0aGlzLnBvcyA+PSB0aGlzLmxlbilcbiAgICAgICAgICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcyk7XG4gICAgICAgICAgICAvLyAxc3QuLjN0aFxuICAgICAgICAgICAgYml0cy5sbyA9IChiaXRzLmxvIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPDwgaSAqIDcpID4+PiAwO1xuICAgICAgICAgICAgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KVxuICAgICAgICAgICAgICAgIHJldHVybiBiaXRzO1xuICAgICAgICB9XG4gICAgICAgIC8vIDR0aFxuICAgICAgICBiaXRzLmxvID0gKGJpdHMubG8gfCAodGhpcy5idWZbdGhpcy5wb3MrK10gJiAxMjcpIDw8IGkgKiA3KSA+Pj4gMDtcbiAgICAgICAgcmV0dXJuIGJpdHM7XG4gICAgfVxuICAgIGlmICh0aGlzLmxlbiAtIHRoaXMucG9zID4gNCkgeyAvLyBmYXN0IHJvdXRlIChoaSlcbiAgICAgICAgZm9yICg7IGkgPCA1OyArK2kpIHtcbiAgICAgICAgICAgIC8vIDZ0aC4uMTB0aFxuICAgICAgICAgICAgYml0cy5oaSA9IChiaXRzLmhpIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPDwgaSAqIDcgKyAzKSA+Pj4gMDtcbiAgICAgICAgICAgIGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOClcbiAgICAgICAgICAgICAgICByZXR1cm4gYml0cztcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoOyBpIDwgNTsgKytpKSB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgIGlmICh0aGlzLnBvcyA+PSB0aGlzLmxlbilcbiAgICAgICAgICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcyk7XG4gICAgICAgICAgICAvLyA2dGguLjEwdGhcbiAgICAgICAgICAgIGJpdHMuaGkgPSAoYml0cy5oaSB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpIDw8IGkgKiA3ICsgMykgPj4+IDA7XG4gICAgICAgICAgICBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJpdHM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICB0aHJvdyBFcnJvcihcImludmFsaWQgdmFyaW50IGVuY29kaW5nXCIpO1xufVxuXG4vKiBlc2xpbnQtZW5hYmxlIG5vLWludmFsaWQtdGhpcyAqL1xuXG4vKipcbiAqIFJlYWRzIGEgdmFyaW50IGFzIGEgc2lnbmVkIDY0IGJpdCB2YWx1ZS5cbiAqIEBuYW1lIFJlYWRlciNpbnQ2NFxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7TG9uZ30gVmFsdWUgcmVhZFxuICovXG5cbi8qKlxuICogUmVhZHMgYSB2YXJpbnQgYXMgYW4gdW5zaWduZWQgNjQgYml0IHZhbHVlLlxuICogQG5hbWUgUmVhZGVyI3VpbnQ2NFxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7TG9uZ30gVmFsdWUgcmVhZFxuICovXG5cbi8qKlxuICogUmVhZHMgYSB6aWctemFnIGVuY29kZWQgdmFyaW50IGFzIGEgc2lnbmVkIDY0IGJpdCB2YWx1ZS5cbiAqIEBuYW1lIFJlYWRlciNzaW50NjRcbiAqIEBmdW5jdGlvblxuICogQHJldHVybnMge0xvbmd9IFZhbHVlIHJlYWRcbiAqL1xuXG4vKipcbiAqIFJlYWRzIGEgdmFyaW50IGFzIGEgYm9vbGVhbi5cbiAqIEByZXR1cm5zIHtib29sZWFufSBWYWx1ZSByZWFkXG4gKi9cblJlYWRlci5wcm90b3R5cGUuYm9vbCA9IGZ1bmN0aW9uIHJlYWRfYm9vbCgpIHtcbiAgICByZXR1cm4gdGhpcy51aW50MzIoKSAhPT0gMDtcbn07XG5cbmZ1bmN0aW9uIHJlYWRGaXhlZDMyX2VuZChidWYsIGVuZCkgeyAvLyBub3RlIHRoYXQgdGhpcyB1c2VzIGBlbmRgLCBub3QgYHBvc2BcbiAgICByZXR1cm4gKGJ1ZltlbmQgLSA0XVxuICAgICAgICAgIHwgYnVmW2VuZCAtIDNdIDw8IDhcbiAgICAgICAgICB8IGJ1ZltlbmQgLSAyXSA8PCAxNlxuICAgICAgICAgIHwgYnVmW2VuZCAtIDFdIDw8IDI0KSA+Pj4gMDtcbn1cblxuLyoqXG4gKiBSZWFkcyBmaXhlZCAzMiBiaXRzIGFzIGFuIHVuc2lnbmVkIDMyIGJpdCBpbnRlZ2VyLlxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxuICovXG5SZWFkZXIucHJvdG90eXBlLmZpeGVkMzIgPSBmdW5jdGlvbiByZWFkX2ZpeGVkMzIoKSB7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAodGhpcy5wb3MgKyA0ID4gdGhpcy5sZW4pXG4gICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLCA0KTtcblxuICAgIHJldHVybiByZWFkRml4ZWQzMl9lbmQodGhpcy5idWYsIHRoaXMucG9zICs9IDQpO1xufTtcblxuLyoqXG4gKiBSZWFkcyBmaXhlZCAzMiBiaXRzIGFzIGEgc2lnbmVkIDMyIGJpdCBpbnRlZ2VyLlxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxuICovXG5SZWFkZXIucHJvdG90eXBlLnNmaXhlZDMyID0gZnVuY3Rpb24gcmVhZF9zZml4ZWQzMigpIHtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh0aGlzLnBvcyArIDQgPiB0aGlzLmxlbilcbiAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMsIDQpO1xuXG4gICAgcmV0dXJuIHJlYWRGaXhlZDMyX2VuZCh0aGlzLmJ1ZiwgdGhpcy5wb3MgKz0gNCkgfCAwO1xufTtcblxuLyogZXNsaW50LWRpc2FibGUgbm8taW52YWxpZC10aGlzICovXG5cbmZ1bmN0aW9uIHJlYWRGaXhlZDY0KC8qIHRoaXM6IFJlYWRlciAqLykge1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHRoaXMucG9zICsgOCA+IHRoaXMubGVuKVxuICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcywgOCk7XG5cbiAgICByZXR1cm4gbmV3IExvbmdCaXRzKHJlYWRGaXhlZDMyX2VuZCh0aGlzLmJ1ZiwgdGhpcy5wb3MgKz0gNCksIHJlYWRGaXhlZDMyX2VuZCh0aGlzLmJ1ZiwgdGhpcy5wb3MgKz0gNCkpO1xufVxuXG4vKiBlc2xpbnQtZW5hYmxlIG5vLWludmFsaWQtdGhpcyAqL1xuXG4vKipcbiAqIFJlYWRzIGZpeGVkIDY0IGJpdHMuXG4gKiBAbmFtZSBSZWFkZXIjZml4ZWQ2NFxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7TG9uZ30gVmFsdWUgcmVhZFxuICovXG5cbi8qKlxuICogUmVhZHMgemlnLXphZyBlbmNvZGVkIGZpeGVkIDY0IGJpdHMuXG4gKiBAbmFtZSBSZWFkZXIjc2ZpeGVkNjRcbiAqIEBmdW5jdGlvblxuICogQHJldHVybnMge0xvbmd9IFZhbHVlIHJlYWRcbiAqL1xuXG4vKipcbiAqIFJlYWRzIGEgZmxvYXQgKDMyIGJpdCkgYXMgYSBudW1iZXIuXG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcbiAqL1xuUmVhZGVyLnByb3RvdHlwZS5mbG9hdCA9IGZ1bmN0aW9uIHJlYWRfZmxvYXQoKSB7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAodGhpcy5wb3MgKyA0ID4gdGhpcy5sZW4pXG4gICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLCA0KTtcblxuICAgIHZhciB2YWx1ZSA9IHV0aWwuZmxvYXQucmVhZEZsb2F0TEUodGhpcy5idWYsIHRoaXMucG9zKTtcbiAgICB0aGlzLnBvcyArPSA0O1xuICAgIHJldHVybiB2YWx1ZTtcbn07XG5cbi8qKlxuICogUmVhZHMgYSBkb3VibGUgKDY0IGJpdCBmbG9hdCkgYXMgYSBudW1iZXIuXG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcbiAqL1xuUmVhZGVyLnByb3RvdHlwZS5kb3VibGUgPSBmdW5jdGlvbiByZWFkX2RvdWJsZSgpIHtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh0aGlzLnBvcyArIDggPiB0aGlzLmxlbilcbiAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMsIDQpO1xuXG4gICAgdmFyIHZhbHVlID0gdXRpbC5mbG9hdC5yZWFkRG91YmxlTEUodGhpcy5idWYsIHRoaXMucG9zKTtcbiAgICB0aGlzLnBvcyArPSA4O1xuICAgIHJldHVybiB2YWx1ZTtcbn07XG5cbi8qKlxuICogUmVhZHMgYSBzZXF1ZW5jZSBvZiBieXRlcyBwcmVjZWVkZWQgYnkgaXRzIGxlbmd0aCBhcyBhIHZhcmludC5cbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fSBWYWx1ZSByZWFkXG4gKi9cblJlYWRlci5wcm90b3R5cGUuYnl0ZXMgPSBmdW5jdGlvbiByZWFkX2J5dGVzKCkge1xuICAgIHZhciBsZW5ndGggPSB0aGlzLnVpbnQzMigpLFxuICAgICAgICBzdGFydCAgPSB0aGlzLnBvcyxcbiAgICAgICAgZW5kICAgID0gdGhpcy5wb3MgKyBsZW5ndGg7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoZW5kID4gdGhpcy5sZW4pXG4gICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLCBsZW5ndGgpO1xuXG4gICAgdGhpcy5wb3MgKz0gbGVuZ3RoO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMuYnVmKSkgLy8gcGxhaW4gYXJyYXlcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgIHJldHVybiBzdGFydCA9PT0gZW5kIC8vIGZpeCBmb3IgSUUgMTAvV2luOCBhbmQgb3RoZXJzJyBzdWJhcnJheSByZXR1cm5pbmcgYXJyYXkgb2Ygc2l6ZSAxXG4gICAgICAgID8gbmV3IHRoaXMuYnVmLmNvbnN0cnVjdG9yKDApXG4gICAgICAgIDogdGhpcy5fc2xpY2UuY2FsbCh0aGlzLmJ1Ziwgc3RhcnQsIGVuZCk7XG59O1xuXG4vKipcbiAqIFJlYWRzIGEgc3RyaW5nIHByZWNlZWRlZCBieSBpdHMgYnl0ZSBsZW5ndGggYXMgYSB2YXJpbnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBWYWx1ZSByZWFkXG4gKi9cblJlYWRlci5wcm90b3R5cGUuc3RyaW5nID0gZnVuY3Rpb24gcmVhZF9zdHJpbmcoKSB7XG4gICAgdmFyIGJ5dGVzID0gdGhpcy5ieXRlcygpO1xuICAgIHJldHVybiB1dGY4LnJlYWQoYnl0ZXMsIDAsIGJ5dGVzLmxlbmd0aCk7XG59O1xuXG4vKipcbiAqIFNraXBzIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIGJ5dGVzIGlmIHNwZWNpZmllZCwgb3RoZXJ3aXNlIHNraXBzIGEgdmFyaW50LlxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIExlbmd0aCBpZiBrbm93biwgb3RoZXJ3aXNlIGEgdmFyaW50IGlzIGFzc3VtZWRcbiAqIEByZXR1cm5zIHtSZWFkZXJ9IGB0aGlzYFxuICovXG5SZWFkZXIucHJvdG90eXBlLnNraXAgPSBmdW5jdGlvbiBza2lwKGxlbmd0aCkge1xuICAgIGlmICh0eXBlb2YgbGVuZ3RoID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAodGhpcy5wb3MgKyBsZW5ndGggPiB0aGlzLmxlbilcbiAgICAgICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLCBsZW5ndGgpO1xuICAgICAgICB0aGlzLnBvcyArPSBsZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgPj0gdGhpcy5sZW4pXG4gICAgICAgICAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMpO1xuICAgICAgICB9IHdoaWxlICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSAmIDEyOCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTa2lwcyB0aGUgbmV4dCBlbGVtZW50IG9mIHRoZSBzcGVjaWZpZWQgd2lyZSB0eXBlLlxuICogQHBhcmFtIHtudW1iZXJ9IHdpcmVUeXBlIFdpcmUgdHlwZSByZWNlaXZlZFxuICogQHJldHVybnMge1JlYWRlcn0gYHRoaXNgXG4gKi9cblJlYWRlci5wcm90b3R5cGUuc2tpcFR5cGUgPSBmdW5jdGlvbih3aXJlVHlwZSkge1xuICAgIHN3aXRjaCAod2lyZVR5cGUpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgdGhpcy5za2lwKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgdGhpcy5za2lwKDgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHRoaXMuc2tpcCh0aGlzLnVpbnQzMigpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICB3aGlsZSAoKHdpcmVUeXBlID0gdGhpcy51aW50MzIoKSAmIDcpICE9PSA0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5za2lwVHlwZSh3aXJlVHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgdGhpcy5za2lwKDQpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiaW52YWxpZCB3aXJlIHR5cGUgXCIgKyB3aXJlVHlwZSArIFwiIGF0IG9mZnNldCBcIiArIHRoaXMucG9zKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5SZWFkZXIuX2NvbmZpZ3VyZSA9IGZ1bmN0aW9uKEJ1ZmZlclJlYWRlcl8pIHtcbiAgICBCdWZmZXJSZWFkZXIgPSBCdWZmZXJSZWFkZXJfO1xuICAgIFJlYWRlci5jcmVhdGUgPSBjcmVhdGUoKTtcbiAgICBCdWZmZXJSZWFkZXIuX2NvbmZpZ3VyZSgpO1xuXG4gICAgdmFyIGZuID0gdXRpbC5Mb25nID8gXCJ0b0xvbmdcIiA6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIFwidG9OdW1iZXJcIjtcbiAgICB1dGlsLm1lcmdlKFJlYWRlci5wcm90b3R5cGUsIHtcblxuICAgICAgICBpbnQ2NDogZnVuY3Rpb24gcmVhZF9pbnQ2NCgpIHtcbiAgICAgICAgICAgIHJldHVybiByZWFkTG9uZ1ZhcmludC5jYWxsKHRoaXMpW2ZuXShmYWxzZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdWludDY0OiBmdW5jdGlvbiByZWFkX3VpbnQ2NCgpIHtcbiAgICAgICAgICAgIHJldHVybiByZWFkTG9uZ1ZhcmludC5jYWxsKHRoaXMpW2ZuXSh0cnVlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBzaW50NjQ6IGZ1bmN0aW9uIHJlYWRfc2ludDY0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlYWRMb25nVmFyaW50LmNhbGwodGhpcykuenpEZWNvZGUoKVtmbl0oZmFsc2UpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpeGVkNjQ6IGZ1bmN0aW9uIHJlYWRfZml4ZWQ2NCgpIHtcbiAgICAgICAgICAgIHJldHVybiByZWFkRml4ZWQ2NC5jYWxsKHRoaXMpW2ZuXSh0cnVlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBzZml4ZWQ2NDogZnVuY3Rpb24gcmVhZF9zZml4ZWQ2NCgpIHtcbiAgICAgICAgICAgIHJldHVybiByZWFkRml4ZWQ2NC5jYWxsKHRoaXMpW2ZuXShmYWxzZSk7XG4gICAgICAgIH1cblxuICAgIH0pO1xufTtcbiIsICJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gQnVmZmVyUmVhZGVyO1xuXG4vLyBleHRlbmRzIFJlYWRlclxudmFyIFJlYWRlciA9IHJlcXVpcmUoXCIuL3JlYWRlclwiKTtcbihCdWZmZXJSZWFkZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShSZWFkZXIucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBCdWZmZXJSZWFkZXI7XG5cbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbC9taW5pbWFsXCIpO1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgYnVmZmVyIHJlYWRlciBpbnN0YW5jZS5cbiAqIEBjbGFzc2Rlc2MgV2lyZSBmb3JtYXQgcmVhZGVyIHVzaW5nIG5vZGUgYnVmZmVycy5cbiAqIEBleHRlbmRzIFJlYWRlclxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyIEJ1ZmZlciB0byByZWFkIGZyb21cbiAqL1xuZnVuY3Rpb24gQnVmZmVyUmVhZGVyKGJ1ZmZlcikge1xuICAgIFJlYWRlci5jYWxsKHRoaXMsIGJ1ZmZlcik7XG5cbiAgICAvKipcbiAgICAgKiBSZWFkIGJ1ZmZlci5cbiAgICAgKiBAbmFtZSBCdWZmZXJSZWFkZXIjYnVmXG4gICAgICogQHR5cGUge0J1ZmZlcn1cbiAgICAgKi9cbn1cblxuQnVmZmVyUmVhZGVyLl9jb25maWd1cmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAodXRpbC5CdWZmZXIpXG4gICAgICAgIEJ1ZmZlclJlYWRlci5wcm90b3R5cGUuX3NsaWNlID0gdXRpbC5CdWZmZXIucHJvdG90eXBlLnNsaWNlO1xufTtcblxuXG4vKipcbiAqIEBvdmVycmlkZVxuICovXG5CdWZmZXJSZWFkZXIucHJvdG90eXBlLnN0cmluZyA9IGZ1bmN0aW9uIHJlYWRfc3RyaW5nX2J1ZmZlcigpIHtcbiAgICB2YXIgbGVuID0gdGhpcy51aW50MzIoKTsgLy8gbW9kaWZpZXMgcG9zXG4gICAgcmV0dXJuIHRoaXMuYnVmLnV0ZjhTbGljZVxuICAgICAgICA/IHRoaXMuYnVmLnV0ZjhTbGljZSh0aGlzLnBvcywgdGhpcy5wb3MgPSBNYXRoLm1pbih0aGlzLnBvcyArIGxlbiwgdGhpcy5sZW4pKVxuICAgICAgICA6IHRoaXMuYnVmLnRvU3RyaW5nKFwidXRmLThcIiwgdGhpcy5wb3MsIHRoaXMucG9zID0gTWF0aC5taW4odGhpcy5wb3MgKyBsZW4sIHRoaXMubGVuKSk7XG59O1xuXG4vKipcbiAqIFJlYWRzIGEgc2VxdWVuY2Ugb2YgYnl0ZXMgcHJlY2VlZGVkIGJ5IGl0cyBsZW5ndGggYXMgYSB2YXJpbnQuXG4gKiBAbmFtZSBCdWZmZXJSZWFkZXIjYnl0ZXNcbiAqIEBmdW5jdGlvblxuICogQHJldHVybnMge0J1ZmZlcn0gVmFsdWUgcmVhZFxuICovXG5cbkJ1ZmZlclJlYWRlci5fY29uZmlndXJlKCk7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IFNlcnZpY2U7XG5cbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWwvbWluaW1hbFwiKTtcblxuLy8gRXh0ZW5kcyBFdmVudEVtaXR0ZXJcbihTZXJ2aWNlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodXRpbC5FdmVudEVtaXR0ZXIucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBTZXJ2aWNlO1xuXG4vKipcbiAqIEEgc2VydmljZSBtZXRob2QgY2FsbGJhY2sgYXMgdXNlZCBieSB7QGxpbmsgcnBjLlNlcnZpY2VNZXRob2R8U2VydmljZU1ldGhvZH0uXG4gKlxuICogRGlmZmVycyBmcm9tIHtAbGluayBSUENJbXBsQ2FsbGJhY2t9IGluIHRoYXQgaXQgaXMgYW4gYWN0dWFsIGNhbGxiYWNrIG9mIGEgc2VydmljZSBtZXRob2Qgd2hpY2ggbWF5IG5vdCByZXR1cm4gYHJlc3BvbnNlID0gbnVsbGAuXG4gKiBAdHlwZWRlZiBycGMuU2VydmljZU1ldGhvZENhbGxiYWNrXG4gKiBAdGVtcGxhdGUgVFJlcyBleHRlbmRzIE1lc3NhZ2U8VFJlcz5cbiAqIEB0eXBlIHtmdW5jdGlvbn1cbiAqIEBwYXJhbSB7RXJyb3J8bnVsbH0gZXJyb3IgRXJyb3IsIGlmIGFueVxuICogQHBhcmFtIHtUUmVzfSBbcmVzcG9uc2VdIFJlc3BvbnNlIG1lc3NhZ2VcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKi9cblxuLyoqXG4gKiBBIHNlcnZpY2UgbWV0aG9kIHBhcnQgb2YgYSB7QGxpbmsgcnBjLlNlcnZpY2V9IGFzIGNyZWF0ZWQgYnkge0BsaW5rIFNlcnZpY2UuY3JlYXRlfS5cbiAqIEB0eXBlZGVmIHJwYy5TZXJ2aWNlTWV0aG9kXG4gKiBAdGVtcGxhdGUgVFJlcSBleHRlbmRzIE1lc3NhZ2U8VFJlcT5cbiAqIEB0ZW1wbGF0ZSBUUmVzIGV4dGVuZHMgTWVzc2FnZTxUUmVzPlxuICogQHR5cGUge2Z1bmN0aW9ufVxuICogQHBhcmFtIHtUUmVxfFByb3BlcnRpZXM8VFJlcT59IHJlcXVlc3QgUmVxdWVzdCBtZXNzYWdlIG9yIHBsYWluIG9iamVjdFxuICogQHBhcmFtIHtycGMuU2VydmljZU1ldGhvZENhbGxiYWNrPFRSZXM+fSBbY2FsbGJhY2tdIE5vZGUtc3R5bGUgY2FsbGJhY2sgY2FsbGVkIHdpdGggdGhlIGVycm9yLCBpZiBhbnksIGFuZCB0aGUgcmVzcG9uc2UgbWVzc2FnZVxuICogQHJldHVybnMge1Byb21pc2U8TWVzc2FnZTxUUmVzPj59IFByb21pc2UgaWYgYGNhbGxiYWNrYCBoYXMgYmVlbiBvbWl0dGVkLCBvdGhlcndpc2UgYHVuZGVmaW5lZGBcbiAqL1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgUlBDIHNlcnZpY2UgaW5zdGFuY2UuXG4gKiBAY2xhc3NkZXNjIEFuIFJQQyBzZXJ2aWNlIGFzIHJldHVybmVkIGJ5IHtAbGluayBTZXJ2aWNlI2NyZWF0ZX0uXG4gKiBAZXhwb3J0cyBycGMuU2VydmljZVxuICogQGV4dGVuZHMgdXRpbC5FdmVudEVtaXR0ZXJcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtSUENJbXBsfSBycGNJbXBsIFJQQyBpbXBsZW1lbnRhdGlvblxuICogQHBhcmFtIHtib29sZWFufSBbcmVxdWVzdERlbGltaXRlZD1mYWxzZV0gV2hldGhlciByZXF1ZXN0cyBhcmUgbGVuZ3RoLWRlbGltaXRlZFxuICogQHBhcmFtIHtib29sZWFufSBbcmVzcG9uc2VEZWxpbWl0ZWQ9ZmFsc2VdIFdoZXRoZXIgcmVzcG9uc2VzIGFyZSBsZW5ndGgtZGVsaW1pdGVkXG4gKi9cbmZ1bmN0aW9uIFNlcnZpY2UocnBjSW1wbCwgcmVxdWVzdERlbGltaXRlZCwgcmVzcG9uc2VEZWxpbWl0ZWQpIHtcblxuICAgIGlmICh0eXBlb2YgcnBjSW1wbCAhPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJycGNJbXBsIG11c3QgYmUgYSBmdW5jdGlvblwiKTtcblxuICAgIHV0aWwuRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBSUEMgaW1wbGVtZW50YXRpb24uIEJlY29tZXMgYG51bGxgIG9uY2UgdGhlIHNlcnZpY2UgaXMgZW5kZWQuXG4gICAgICogQHR5cGUge1JQQ0ltcGx8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnJwY0ltcGwgPSBycGNJbXBsO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciByZXF1ZXN0cyBhcmUgbGVuZ3RoLWRlbGltaXRlZC5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnJlcXVlc3REZWxpbWl0ZWQgPSBCb29sZWFuKHJlcXVlc3REZWxpbWl0ZWQpO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciByZXNwb25zZXMgYXJlIGxlbmd0aC1kZWxpbWl0ZWQuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5yZXNwb25zZURlbGltaXRlZCA9IEJvb2xlYW4ocmVzcG9uc2VEZWxpbWl0ZWQpO1xufVxuXG4vKipcbiAqIENhbGxzIGEgc2VydmljZSBtZXRob2QgdGhyb3VnaCB7QGxpbmsgcnBjLlNlcnZpY2UjcnBjSW1wbHxycGNJbXBsfS5cbiAqIEBwYXJhbSB7TWV0aG9kfHJwYy5TZXJ2aWNlTWV0aG9kPFRSZXEsVFJlcz59IG1ldGhvZCBSZWZsZWN0ZWQgb3Igc3RhdGljIG1ldGhvZFxuICogQHBhcmFtIHtDb25zdHJ1Y3RvcjxUUmVxPn0gcmVxdWVzdEN0b3IgUmVxdWVzdCBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtDb25zdHJ1Y3RvcjxUUmVzPn0gcmVzcG9uc2VDdG9yIFJlc3BvbnNlIGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1RSZXF8UHJvcGVydGllczxUUmVxPn0gcmVxdWVzdCBSZXF1ZXN0IG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0XG4gKiBAcGFyYW0ge3JwYy5TZXJ2aWNlTWV0aG9kQ2FsbGJhY2s8VFJlcz59IGNhbGxiYWNrIFNlcnZpY2UgY2FsbGJhY2tcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKiBAdGVtcGxhdGUgVFJlcSBleHRlbmRzIE1lc3NhZ2U8VFJlcT5cbiAqIEB0ZW1wbGF0ZSBUUmVzIGV4dGVuZHMgTWVzc2FnZTxUUmVzPlxuICovXG5TZXJ2aWNlLnByb3RvdHlwZS5ycGNDYWxsID0gZnVuY3Rpb24gcnBjQ2FsbChtZXRob2QsIHJlcXVlc3RDdG9yLCByZXNwb25zZUN0b3IsIHJlcXVlc3QsIGNhbGxiYWNrKSB7XG5cbiAgICBpZiAoIXJlcXVlc3QpXG4gICAgICAgIHRocm93IFR5cGVFcnJvcihcInJlcXVlc3QgbXVzdCBiZSBzcGVjaWZpZWRcIik7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgaWYgKCFjYWxsYmFjaylcbiAgICAgICAgcmV0dXJuIHV0aWwuYXNQcm9taXNlKHJwY0NhbGwsIHNlbGYsIG1ldGhvZCwgcmVxdWVzdEN0b3IsIHJlc3BvbnNlQ3RvciwgcmVxdWVzdCk7XG5cbiAgICBpZiAoIXNlbGYucnBjSW1wbCkge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBjYWxsYmFjayhFcnJvcihcImFscmVhZHkgZW5kZWRcIikpOyB9LCAwKTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gc2VsZi5ycGNJbXBsKFxuICAgICAgICAgICAgbWV0aG9kLFxuICAgICAgICAgICAgcmVxdWVzdEN0b3Jbc2VsZi5yZXF1ZXN0RGVsaW1pdGVkID8gXCJlbmNvZGVEZWxpbWl0ZWRcIiA6IFwiZW5jb2RlXCJdKHJlcXVlc3QpLmZpbmlzaCgpLFxuICAgICAgICAgICAgZnVuY3Rpb24gcnBjQ2FsbGJhY2soZXJyLCByZXNwb25zZSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmVtaXQoXCJlcnJvclwiLCBlcnIsIG1ldGhvZCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmVuZCgvKiBlbmRlZEJ5UlBDICovIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghKHJlc3BvbnNlIGluc3RhbmNlb2YgcmVzcG9uc2VDdG9yKSkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSByZXNwb25zZUN0b3Jbc2VsZi5yZXNwb25zZURlbGltaXRlZCA/IFwiZGVjb2RlRGVsaW1pdGVkXCIgOiBcImRlY29kZVwiXShyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5lbWl0KFwiZXJyb3JcIiwgZXJyLCBtZXRob2QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzZWxmLmVtaXQoXCJkYXRhXCIsIHJlc3BvbnNlLCBtZXRob2QpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCByZXNwb25zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHNlbGYuZW1pdChcImVycm9yXCIsIGVyciwgbWV0aG9kKTtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsgY2FsbGJhY2soZXJyKTsgfSwgMCk7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufTtcblxuLyoqXG4gKiBFbmRzIHRoaXMgc2VydmljZSBhbmQgZW1pdHMgdGhlIGBlbmRgIGV2ZW50LlxuICogQHBhcmFtIHtib29sZWFufSBbZW5kZWRCeVJQQz1mYWxzZV0gV2hldGhlciB0aGUgc2VydmljZSBoYXMgYmVlbiBlbmRlZCBieSB0aGUgUlBDIGltcGxlbWVudGF0aW9uLlxuICogQHJldHVybnMge3JwYy5TZXJ2aWNlfSBgdGhpc2BcbiAqL1xuU2VydmljZS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gZW5kKGVuZGVkQnlSUEMpIHtcbiAgICBpZiAodGhpcy5ycGNJbXBsKSB7XG4gICAgICAgIGlmICghZW5kZWRCeVJQQykgLy8gc2lnbmFsIGVuZCB0byBycGNJbXBsXG4gICAgICAgICAgICB0aGlzLnJwY0ltcGwobnVsbCwgbnVsbCwgbnVsbCk7XG4gICAgICAgIHRoaXMucnBjSW1wbCA9IG51bGw7XG4gICAgICAgIHRoaXMuZW1pdChcImVuZFwiKS5vZmYoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIFN0cmVhbWluZyBSUEMgaGVscGVycy5cbiAqIEBuYW1lc3BhY2VcbiAqL1xudmFyIHJwYyA9IGV4cG9ydHM7XG5cbi8qKlxuICogUlBDIGltcGxlbWVudGF0aW9uIHBhc3NlZCB0byB7QGxpbmsgU2VydmljZSNjcmVhdGV9IHBlcmZvcm1pbmcgYSBzZXJ2aWNlIHJlcXVlc3Qgb24gbmV0d29yayBsZXZlbCwgaS5lLiBieSB1dGlsaXppbmcgaHR0cCByZXF1ZXN0cyBvciB3ZWJzb2NrZXRzLlxuICogQHR5cGVkZWYgUlBDSW1wbFxuICogQHR5cGUge2Z1bmN0aW9ufVxuICogQHBhcmFtIHtNZXRob2R8cnBjLlNlcnZpY2VNZXRob2Q8TWVzc2FnZTx7fT4sTWVzc2FnZTx7fT4+fSBtZXRob2QgUmVmbGVjdGVkIG9yIHN0YXRpYyBtZXRob2QgYmVpbmcgY2FsbGVkXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHJlcXVlc3REYXRhIFJlcXVlc3QgZGF0YVxuICogQHBhcmFtIHtSUENJbXBsQ2FsbGJhY2t9IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICogQGV4YW1wbGVcbiAqIGZ1bmN0aW9uIHJwY0ltcGwobWV0aG9kLCByZXF1ZXN0RGF0YSwgY2FsbGJhY2spIHtcbiAqICAgICBpZiAocHJvdG9idWYudXRpbC5sY0ZpcnN0KG1ldGhvZC5uYW1lKSAhPT0gXCJteU1ldGhvZFwiKSAvLyBjb21wYXRpYmxlIHdpdGggc3RhdGljIGNvZGVcbiAqICAgICAgICAgdGhyb3cgRXJyb3IoXCJubyBzdWNoIG1ldGhvZFwiKTtcbiAqICAgICBhc3luY2hyb25vdXNseU9idGFpbkFSZXNwb25zZShyZXF1ZXN0RGF0YSwgZnVuY3Rpb24oZXJyLCByZXNwb25zZURhdGEpIHtcbiAqICAgICAgICAgY2FsbGJhY2soZXJyLCByZXNwb25zZURhdGEpO1xuICogICAgIH0pO1xuICogfVxuICovXG5cbi8qKlxuICogTm9kZS1zdHlsZSBjYWxsYmFjayBhcyB1c2VkIGJ5IHtAbGluayBSUENJbXBsfS5cbiAqIEB0eXBlZGVmIFJQQ0ltcGxDYWxsYmFja1xuICogQHR5cGUge2Z1bmN0aW9ufVxuICogQHBhcmFtIHtFcnJvcnxudWxsfSBlcnJvciBFcnJvciwgaWYgYW55LCBvdGhlcndpc2UgYG51bGxgXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl8bnVsbH0gW3Jlc3BvbnNlXSBSZXNwb25zZSBkYXRhIG9yIGBudWxsYCB0byBzaWduYWwgZW5kIG9mIHN0cmVhbSwgaWYgdGhlcmUgaGFzbid0IGJlZW4gYW4gZXJyb3JcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKi9cblxucnBjLlNlcnZpY2UgPSByZXF1aXJlKFwiLi9ycGMvc2VydmljZVwiKTtcbiIsICJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0ge307XG5cbi8qKlxuICogTmFtZWQgcm9vdHMuXG4gKiBUaGlzIGlzIHdoZXJlIHBianMgc3RvcmVzIGdlbmVyYXRlZCBzdHJ1Y3R1cmVzICh0aGUgb3B0aW9uIGAtciwgLS1yb290YCBzcGVjaWZpZXMgYSBuYW1lKS5cbiAqIENhbiBhbHNvIGJlIHVzZWQgbWFudWFsbHkgdG8gbWFrZSByb290cyBhdmFpbGFibGUgYWNjcm9zcyBtb2R1bGVzLlxuICogQG5hbWUgcm9vdHNcbiAqIEB0eXBlIHtPYmplY3QuPHN0cmluZyxSb290Pn1cbiAqIEBleGFtcGxlXG4gKiAvLyBwYmpzIC1yIG15cm9vdCAtbyBjb21waWxlZC5qcyAuLi5cbiAqXG4gKiAvLyBpbiBhbm90aGVyIG1vZHVsZTpcbiAqIHJlcXVpcmUoXCIuL2NvbXBpbGVkLmpzXCIpO1xuICpcbiAqIC8vIGluIGFueSBzdWJzZXF1ZW50IG1vZHVsZTpcbiAqIHZhciByb290ID0gcHJvdG9idWYucm9vdHNbXCJteXJvb3RcIl07XG4gKi9cbiIsICJcInVzZSBzdHJpY3RcIjtcbnZhciBwcm90b2J1ZiA9IGV4cG9ydHM7XG5cbi8qKlxuICogQnVpbGQgdHlwZSwgb25lIG9mIGBcImZ1bGxcImAsIGBcImxpZ2h0XCJgIG9yIGBcIm1pbmltYWxcImAuXG4gKiBAbmFtZSBidWlsZFxuICogQHR5cGUge3N0cmluZ31cbiAqIEBjb25zdFxuICovXG5wcm90b2J1Zi5idWlsZCA9IFwibWluaW1hbFwiO1xuXG4vLyBTZXJpYWxpemF0aW9uXG5wcm90b2J1Zi5Xcml0ZXIgICAgICAgPSByZXF1aXJlKFwiLi93cml0ZXJcIik7XG5wcm90b2J1Zi5CdWZmZXJXcml0ZXIgPSByZXF1aXJlKFwiLi93cml0ZXJfYnVmZmVyXCIpO1xucHJvdG9idWYuUmVhZGVyICAgICAgID0gcmVxdWlyZShcIi4vcmVhZGVyXCIpO1xucHJvdG9idWYuQnVmZmVyUmVhZGVyID0gcmVxdWlyZShcIi4vcmVhZGVyX2J1ZmZlclwiKTtcblxuLy8gVXRpbGl0eVxucHJvdG9idWYudXRpbCAgICAgICAgID0gcmVxdWlyZShcIi4vdXRpbC9taW5pbWFsXCIpO1xucHJvdG9idWYucnBjICAgICAgICAgID0gcmVxdWlyZShcIi4vcnBjXCIpO1xucHJvdG9idWYucm9vdHMgICAgICAgID0gcmVxdWlyZShcIi4vcm9vdHNcIik7XG5wcm90b2J1Zi5jb25maWd1cmUgICAgPSBjb25maWd1cmU7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4vKipcbiAqIFJlY29uZmlndXJlcyB0aGUgbGlicmFyeSBhY2NvcmRpbmcgdG8gdGhlIGVudmlyb25tZW50LlxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuZnVuY3Rpb24gY29uZmlndXJlKCkge1xuICAgIHByb3RvYnVmLnV0aWwuX2NvbmZpZ3VyZSgpO1xuICAgIHByb3RvYnVmLldyaXRlci5fY29uZmlndXJlKHByb3RvYnVmLkJ1ZmZlcldyaXRlcik7XG4gICAgcHJvdG9idWYuUmVhZGVyLl9jb25maWd1cmUocHJvdG9idWYuQnVmZmVyUmVhZGVyKTtcbn1cblxuLy8gU2V0IHVwIGJ1ZmZlciB1dGlsaXR5IGFjY29yZGluZyB0byB0aGUgZW52aXJvbm1lbnRcbmNvbmZpZ3VyZSgpO1xuIiwgIi8vIG1pbmltYWwgbGlicmFyeSBlbnRyeSBwb2ludC5cblxuXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL3NyYy9pbmRleC1taW5pbWFsXCIpO1xuIiwgIid1c2Ugc3RyaWN0J1xuXG4vKipcbiAqIENvbGxlY3RzIGFsbCB2YWx1ZXMgZnJvbSBhbiAoYXN5bmMpIGl0ZXJhYmxlIGludG8gYW4gYXJyYXkgYW5kIHJldHVybnMgaXQuXG4gKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7QXN5bmNJdGVyYWJsZTxUPnxJdGVyYWJsZTxUPn0gc291cmNlXG4gKi9cbmNvbnN0IGFsbCA9IGFzeW5jIChzb3VyY2UpID0+IHtcbiAgY29uc3QgYXJyID0gW11cblxuICBmb3IgYXdhaXQgKGNvbnN0IGVudHJ5IG9mIHNvdXJjZSkge1xuICAgIGFyci5wdXNoKGVudHJ5KVxuICB9XG5cbiAgcmV0dXJuIGFyclxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFsbFxuIiwgIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IEJ1ZmZlciB9ID0gcmVxdWlyZSgnYnVmZmVyJylcbmNvbnN0IHN5bWJvbCA9IFN5bWJvbC5mb3IoJ0J1ZmZlckxpc3QnKVxuXG5mdW5jdGlvbiBCdWZmZXJMaXN0IChidWYpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlckxpc3QpKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXJMaXN0KGJ1ZilcbiAgfVxuXG4gIEJ1ZmZlckxpc3QuX2luaXQuY2FsbCh0aGlzLCBidWYpXG59XG5cbkJ1ZmZlckxpc3QuX2luaXQgPSBmdW5jdGlvbiBfaW5pdCAoYnVmKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBzeW1ib2wsIHsgdmFsdWU6IHRydWUgfSlcblxuICB0aGlzLl9idWZzID0gW11cbiAgdGhpcy5sZW5ndGggPSAwXG5cbiAgaWYgKGJ1Zikge1xuICAgIHRoaXMuYXBwZW5kKGJ1ZilcbiAgfVxufVxuXG5CdWZmZXJMaXN0LnByb3RvdHlwZS5fbmV3ID0gZnVuY3Rpb24gX25ldyAoYnVmKSB7XG4gIHJldHVybiBuZXcgQnVmZmVyTGlzdChidWYpXG59XG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLl9vZmZzZXQgPSBmdW5jdGlvbiBfb2Zmc2V0IChvZmZzZXQpIHtcbiAgaWYgKG9mZnNldCA9PT0gMCkge1xuICAgIHJldHVybiBbMCwgMF1cbiAgfVxuXG4gIGxldCB0b3QgPSAwXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9idWZzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgX3QgPSB0b3QgKyB0aGlzLl9idWZzW2ldLmxlbmd0aFxuICAgIGlmIChvZmZzZXQgPCBfdCB8fCBpID09PSB0aGlzLl9idWZzLmxlbmd0aCAtIDEpIHtcbiAgICAgIHJldHVybiBbaSwgb2Zmc2V0IC0gdG90XVxuICAgIH1cbiAgICB0b3QgPSBfdFxuICB9XG59XG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLl9yZXZlcnNlT2Zmc2V0ID0gZnVuY3Rpb24gKGJsT2Zmc2V0KSB7XG4gIGNvbnN0IGJ1ZmZlcklkID0gYmxPZmZzZXRbMF1cbiAgbGV0IG9mZnNldCA9IGJsT2Zmc2V0WzFdXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWZmZXJJZDsgaSsrKSB7XG4gICAgb2Zmc2V0ICs9IHRoaXMuX2J1ZnNbaV0ubGVuZ3RoXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0XG59XG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoaW5kZXgpIHtcbiAgaWYgKGluZGV4ID4gdGhpcy5sZW5ndGggfHwgaW5kZXggPCAwKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG5cbiAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5fb2Zmc2V0KGluZGV4KVxuXG4gIHJldHVybiB0aGlzLl9idWZzW29mZnNldFswXV1bb2Zmc2V0WzFdXVxufVxuXG5CdWZmZXJMaXN0LnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdudW1iZXInICYmIHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAodHlwZW9mIGVuZCA9PT0gJ251bWJlcicgJiYgZW5kIDwgMCkge1xuICAgIGVuZCArPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgcmV0dXJuIHRoaXMuY29weShudWxsLCAwLCBzdGFydCwgZW5kKVxufVxuXG5CdWZmZXJMaXN0LnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAoZHN0LCBkc3RTdGFydCwgc3JjU3RhcnQsIHNyY0VuZCkge1xuICBpZiAodHlwZW9mIHNyY1N0YXJ0ICE9PSAnbnVtYmVyJyB8fCBzcmNTdGFydCA8IDApIHtcbiAgICBzcmNTdGFydCA9IDBcbiAgfVxuXG4gIGlmICh0eXBlb2Ygc3JjRW5kICE9PSAnbnVtYmVyJyB8fCBzcmNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHNyY0VuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoc3JjU3RhcnQgPj0gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gZHN0IHx8IEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgaWYgKHNyY0VuZCA8PSAwKSB7XG4gICAgcmV0dXJuIGRzdCB8fCBCdWZmZXIuYWxsb2MoMClcbiAgfVxuXG4gIGNvbnN0IGNvcHkgPSAhIWRzdFxuICBjb25zdCBvZmYgPSB0aGlzLl9vZmZzZXQoc3JjU3RhcnQpXG4gIGNvbnN0IGxlbiA9IHNyY0VuZCAtIHNyY1N0YXJ0XG4gIGxldCBieXRlcyA9IGxlblxuICBsZXQgYnVmb2ZmID0gKGNvcHkgJiYgZHN0U3RhcnQpIHx8IDBcbiAgbGV0IHN0YXJ0ID0gb2ZmWzFdXG5cbiAgLy8gY29weS9zbGljZSBldmVyeXRoaW5nXG4gIGlmIChzcmNTdGFydCA9PT0gMCAmJiBzcmNFbmQgPT09IHRoaXMubGVuZ3RoKSB7XG4gICAgaWYgKCFjb3B5KSB7XG4gICAgICAvLyBzbGljZSwgYnV0IGZ1bGwgY29uY2F0IGlmIG11bHRpcGxlIGJ1ZmZlcnNcbiAgICAgIHJldHVybiB0aGlzLl9idWZzLmxlbmd0aCA9PT0gMVxuICAgICAgICA/IHRoaXMuX2J1ZnNbMF1cbiAgICAgICAgOiBCdWZmZXIuY29uY2F0KHRoaXMuX2J1ZnMsIHRoaXMubGVuZ3RoKVxuICAgIH1cblxuICAgIC8vIGNvcHksIG5lZWQgdG8gY29weSBpbmRpdmlkdWFsIGJ1ZmZlcnNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2J1ZnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuX2J1ZnNbaV0uY29weShkc3QsIGJ1Zm9mZilcbiAgICAgIGJ1Zm9mZiArPSB0aGlzLl9idWZzW2ldLmxlbmd0aFxuICAgIH1cblxuICAgIHJldHVybiBkc3RcbiAgfVxuXG4gIC8vIGVhc3ksIGNoZWFwIGNhc2Ugd2hlcmUgaXQncyBhIHN1YnNldCBvZiBvbmUgb2YgdGhlIGJ1ZmZlcnNcbiAgaWYgKGJ5dGVzIDw9IHRoaXMuX2J1ZnNbb2ZmWzBdXS5sZW5ndGggLSBzdGFydCkge1xuICAgIHJldHVybiBjb3B5XG4gICAgICA/IHRoaXMuX2J1ZnNbb2ZmWzBdXS5jb3B5KGRzdCwgZHN0U3RhcnQsIHN0YXJ0LCBzdGFydCArIGJ5dGVzKVxuICAgICAgOiB0aGlzLl9idWZzW29mZlswXV0uc2xpY2Uoc3RhcnQsIHN0YXJ0ICsgYnl0ZXMpXG4gIH1cblxuICBpZiAoIWNvcHkpIHtcbiAgICAvLyBhIHNsaWNlLCB3ZSBuZWVkIHNvbWV0aGluZyB0byBjb3B5IGluIHRvXG4gICAgZHN0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbilcbiAgfVxuXG4gIGZvciAobGV0IGkgPSBvZmZbMF07IGkgPCB0aGlzLl9idWZzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgbCA9IHRoaXMuX2J1ZnNbaV0ubGVuZ3RoIC0gc3RhcnRcblxuICAgIGlmIChieXRlcyA+IGwpIHtcbiAgICAgIHRoaXMuX2J1ZnNbaV0uY29weShkc3QsIGJ1Zm9mZiwgc3RhcnQpXG4gICAgICBidWZvZmYgKz0gbFxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9idWZzW2ldLmNvcHkoZHN0LCBidWZvZmYsIHN0YXJ0LCBzdGFydCArIGJ5dGVzKVxuICAgICAgYnVmb2ZmICs9IGxcbiAgICAgIGJyZWFrXG4gICAgfVxuXG4gICAgYnl0ZXMgLT0gbFxuXG4gICAgaWYgKHN0YXJ0KSB7XG4gICAgICBzdGFydCA9IDBcbiAgICB9XG4gIH1cblxuICAvLyBzYWZlZ3VhcmQgc28gdGhhdCB3ZSBkb24ndCByZXR1cm4gdW5pbml0aWFsaXplZCBtZW1vcnlcbiAgaWYgKGRzdC5sZW5ndGggPiBidWZvZmYpIHJldHVybiBkc3Quc2xpY2UoMCwgYnVmb2ZmKVxuXG4gIHJldHVybiBkc3Rcbn1cblxuQnVmZmVyTGlzdC5wcm90b3R5cGUuc2hhbGxvd1NsaWNlID0gZnVuY3Rpb24gc2hhbGxvd1NsaWNlIChzdGFydCwgZW5kKSB7XG4gIHN0YXJ0ID0gc3RhcnQgfHwgMFxuICBlbmQgPSB0eXBlb2YgZW5kICE9PSAnbnVtYmVyJyA/IHRoaXMubGVuZ3RoIDogZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSBlbmQpIHtcbiAgICByZXR1cm4gdGhpcy5fbmV3KClcbiAgfVxuXG4gIGNvbnN0IHN0YXJ0T2Zmc2V0ID0gdGhpcy5fb2Zmc2V0KHN0YXJ0KVxuICBjb25zdCBlbmRPZmZzZXQgPSB0aGlzLl9vZmZzZXQoZW5kKVxuICBjb25zdCBidWZmZXJzID0gdGhpcy5fYnVmcy5zbGljZShzdGFydE9mZnNldFswXSwgZW5kT2Zmc2V0WzBdICsgMSlcblxuICBpZiAoZW5kT2Zmc2V0WzFdID09PSAwKSB7XG4gICAgYnVmZmVycy5wb3AoKVxuICB9IGVsc2Uge1xuICAgIGJ1ZmZlcnNbYnVmZmVycy5sZW5ndGggLSAxXSA9IGJ1ZmZlcnNbYnVmZmVycy5sZW5ndGggLSAxXS5zbGljZSgwLCBlbmRPZmZzZXRbMV0pXG4gIH1cblxuICBpZiAoc3RhcnRPZmZzZXRbMV0gIT09IDApIHtcbiAgICBidWZmZXJzWzBdID0gYnVmZmVyc1swXS5zbGljZShzdGFydE9mZnNldFsxXSlcbiAgfVxuXG4gIHJldHVybiB0aGlzLl9uZXcoYnVmZmVycylcbn1cblxuQnVmZmVyTGlzdC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIHRoaXMuc2xpY2Uoc3RhcnQsIGVuZCkudG9TdHJpbmcoZW5jb2RpbmcpXG59XG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLmNvbnN1bWUgPSBmdW5jdGlvbiBjb25zdW1lIChieXRlcykge1xuICAvLyBmaXJzdCwgbm9ybWFsaXplIHRoZSBhcmd1bWVudCwgaW4gYWNjb3JkYW5jZSB3aXRoIGhvdyBCdWZmZXIgZG9lcyBpdFxuICBieXRlcyA9IE1hdGgudHJ1bmMoYnl0ZXMpXG4gIC8vIGRvIG5vdGhpbmcgaWYgbm90IGEgcG9zaXRpdmUgbnVtYmVyXG4gIGlmIChOdW1iZXIuaXNOYU4oYnl0ZXMpIHx8IGJ5dGVzIDw9IDApIHJldHVybiB0aGlzXG5cbiAgd2hpbGUgKHRoaXMuX2J1ZnMubGVuZ3RoKSB7XG4gICAgaWYgKGJ5dGVzID49IHRoaXMuX2J1ZnNbMF0ubGVuZ3RoKSB7XG4gICAgICBieXRlcyAtPSB0aGlzLl9idWZzWzBdLmxlbmd0aFxuICAgICAgdGhpcy5sZW5ndGggLT0gdGhpcy5fYnVmc1swXS5sZW5ndGhcbiAgICAgIHRoaXMuX2J1ZnMuc2hpZnQoKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9idWZzWzBdID0gdGhpcy5fYnVmc1swXS5zbGljZShieXRlcylcbiAgICAgIHRoaXMubGVuZ3RoIC09IGJ5dGVzXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLmR1cGxpY2F0ZSA9IGZ1bmN0aW9uIGR1cGxpY2F0ZSAoKSB7XG4gIGNvbnN0IGNvcHkgPSB0aGlzLl9uZXcoKVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fYnVmcy5sZW5ndGg7IGkrKykge1xuICAgIGNvcHkuYXBwZW5kKHRoaXMuX2J1ZnNbaV0pXG4gIH1cblxuICByZXR1cm4gY29weVxufVxuXG5CdWZmZXJMaXN0LnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbiBhcHBlbmQgKGJ1Zikge1xuICBpZiAoYnVmID09IG51bGwpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgaWYgKGJ1Zi5idWZmZXIpIHtcbiAgICAvLyBhcHBlbmQgYSB2aWV3IG9mIHRoZSB1bmRlcmx5aW5nIEFycmF5QnVmZmVyXG4gICAgdGhpcy5fYXBwZW5kQnVmZmVyKEJ1ZmZlci5mcm9tKGJ1Zi5idWZmZXIsIGJ1Zi5ieXRlT2Zmc2V0LCBidWYuYnl0ZUxlbmd0aCkpXG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShidWYpKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWYubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuYXBwZW5kKGJ1ZltpXSlcbiAgICB9XG4gIH0gZWxzZSBpZiAodGhpcy5faXNCdWZmZXJMaXN0KGJ1ZikpIHtcbiAgICAvLyB1bndyYXAgYXJndW1lbnQgaW50byBpbmRpdmlkdWFsIEJ1ZmZlckxpc3RzXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWYuX2J1ZnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuYXBwZW5kKGJ1Zi5fYnVmc1tpXSlcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gY29lcmNlIG51bWJlciBhcmd1bWVudHMgdG8gc3RyaW5ncywgc2luY2UgQnVmZmVyKG51bWJlcikgZG9lc1xuICAgIC8vIHVuaW5pdGlhbGl6ZWQgbWVtb3J5IGFsbG9jYXRpb25cbiAgICBpZiAodHlwZW9mIGJ1ZiA9PT0gJ251bWJlcicpIHtcbiAgICAgIGJ1ZiA9IGJ1Zi50b1N0cmluZygpXG4gICAgfVxuXG4gICAgdGhpcy5fYXBwZW5kQnVmZmVyKEJ1ZmZlci5mcm9tKGJ1ZikpXG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXJMaXN0LnByb3RvdHlwZS5fYXBwZW5kQnVmZmVyID0gZnVuY3Rpb24gYXBwZW5kQnVmZmVyIChidWYpIHtcbiAgdGhpcy5fYnVmcy5wdXNoKGJ1ZilcbiAgdGhpcy5sZW5ndGggKz0gYnVmLmxlbmd0aFxufVxuXG5CdWZmZXJMaXN0LnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gKHNlYXJjaCwgb2Zmc2V0LCBlbmNvZGluZykge1xuICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgb2Zmc2V0ID0gdW5kZWZpbmVkXG4gIH1cblxuICBpZiAodHlwZW9mIHNlYXJjaCA9PT0gJ2Z1bmN0aW9uJyB8fCBBcnJheS5pc0FycmF5KHNlYXJjaCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEJ1ZmZlckxpc3QsIG9yIFVpbnQ4QXJyYXkuJylcbiAgfSBlbHNlIGlmICh0eXBlb2Ygc2VhcmNoID09PSAnbnVtYmVyJykge1xuICAgIHNlYXJjaCA9IEJ1ZmZlci5mcm9tKFtzZWFyY2hdKVxuICB9IGVsc2UgaWYgKHR5cGVvZiBzZWFyY2ggPT09ICdzdHJpbmcnKSB7XG4gICAgc2VhcmNoID0gQnVmZmVyLmZyb20oc2VhcmNoLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmICh0aGlzLl9pc0J1ZmZlckxpc3Qoc2VhcmNoKSkge1xuICAgIHNlYXJjaCA9IHNlYXJjaC5zbGljZSgpXG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShzZWFyY2guYnVmZmVyKSkge1xuICAgIHNlYXJjaCA9IEJ1ZmZlci5mcm9tKHNlYXJjaC5idWZmZXIsIHNlYXJjaC5ieXRlT2Zmc2V0LCBzZWFyY2guYnl0ZUxlbmd0aClcbiAgfSBlbHNlIGlmICghQnVmZmVyLmlzQnVmZmVyKHNlYXJjaCkpIHtcbiAgICBzZWFyY2ggPSBCdWZmZXIuZnJvbShzZWFyY2gpXG4gIH1cblxuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0IHx8IDApXG5cbiAgaWYgKGlzTmFOKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSAwXG4gIH1cblxuICBpZiAob2Zmc2V0IDwgMCkge1xuICAgIG9mZnNldCA9IHRoaXMubGVuZ3RoICsgb2Zmc2V0XG4gIH1cblxuICBpZiAob2Zmc2V0IDwgMCkge1xuICAgIG9mZnNldCA9IDBcbiAgfVxuXG4gIGlmIChzZWFyY2gubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG9mZnNldCA+IHRoaXMubGVuZ3RoID8gdGhpcy5sZW5ndGggOiBvZmZzZXRcbiAgfVxuXG4gIGNvbnN0IGJsT2Zmc2V0ID0gdGhpcy5fb2Zmc2V0KG9mZnNldClcbiAgbGV0IGJsSW5kZXggPSBibE9mZnNldFswXSAvLyBpbmRleCBvZiB3aGljaCBpbnRlcm5hbCBidWZmZXIgd2UncmUgd29ya2luZyBvblxuICBsZXQgYnVmZk9mZnNldCA9IGJsT2Zmc2V0WzFdIC8vIG9mZnNldCBvZiB0aGUgaW50ZXJuYWwgYnVmZmVyIHdlJ3JlIHdvcmtpbmcgb25cblxuICAvLyBzY2FuIG92ZXIgZWFjaCBidWZmZXJcbiAgZm9yICg7IGJsSW5kZXggPCB0aGlzLl9idWZzLmxlbmd0aDsgYmxJbmRleCsrKSB7XG4gICAgY29uc3QgYnVmZiA9IHRoaXMuX2J1ZnNbYmxJbmRleF1cblxuICAgIHdoaWxlIChidWZmT2Zmc2V0IDwgYnVmZi5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGF2YWlsYWJsZVdpbmRvdyA9IGJ1ZmYubGVuZ3RoIC0gYnVmZk9mZnNldFxuXG4gICAgICBpZiAoYXZhaWxhYmxlV2luZG93ID49IHNlYXJjaC5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgbmF0aXZlU2VhcmNoUmVzdWx0ID0gYnVmZi5pbmRleE9mKHNlYXJjaCwgYnVmZk9mZnNldClcblxuICAgICAgICBpZiAobmF0aXZlU2VhcmNoUmVzdWx0ICE9PSAtMSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9yZXZlcnNlT2Zmc2V0KFtibEluZGV4LCBuYXRpdmVTZWFyY2hSZXN1bHRdKVxuICAgICAgICB9XG5cbiAgICAgICAgYnVmZk9mZnNldCA9IGJ1ZmYubGVuZ3RoIC0gc2VhcmNoLmxlbmd0aCArIDEgLy8gZW5kIG9mIG5hdGl2ZSBzZWFyY2ggd2luZG93XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCByZXZPZmZzZXQgPSB0aGlzLl9yZXZlcnNlT2Zmc2V0KFtibEluZGV4LCBidWZmT2Zmc2V0XSlcblxuICAgICAgICBpZiAodGhpcy5fbWF0Y2gocmV2T2Zmc2V0LCBzZWFyY2gpKSB7XG4gICAgICAgICAgcmV0dXJuIHJldk9mZnNldFxuICAgICAgICB9XG5cbiAgICAgICAgYnVmZk9mZnNldCsrXG4gICAgICB9XG4gICAgfVxuXG4gICAgYnVmZk9mZnNldCA9IDBcbiAgfVxuXG4gIHJldHVybiAtMVxufVxuXG5CdWZmZXJMaXN0LnByb3RvdHlwZS5fbWF0Y2ggPSBmdW5jdGlvbiAob2Zmc2V0LCBzZWFyY2gpIHtcbiAgaWYgKHRoaXMubGVuZ3RoIC0gb2Zmc2V0IDwgc2VhcmNoLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgZm9yIChsZXQgc2VhcmNoT2Zmc2V0ID0gMDsgc2VhcmNoT2Zmc2V0IDwgc2VhcmNoLmxlbmd0aDsgc2VhcmNoT2Zmc2V0KyspIHtcbiAgICBpZiAodGhpcy5nZXQob2Zmc2V0ICsgc2VhcmNoT2Zmc2V0KSAhPT0gc2VhcmNoW3NlYXJjaE9mZnNldF0pIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG47KGZ1bmN0aW9uICgpIHtcbiAgY29uc3QgbWV0aG9kcyA9IHtcbiAgICByZWFkRG91YmxlQkU6IDgsXG4gICAgcmVhZERvdWJsZUxFOiA4LFxuICAgIHJlYWRGbG9hdEJFOiA0LFxuICAgIHJlYWRGbG9hdExFOiA0LFxuICAgIHJlYWRJbnQzMkJFOiA0LFxuICAgIHJlYWRJbnQzMkxFOiA0LFxuICAgIHJlYWRVSW50MzJCRTogNCxcbiAgICByZWFkVUludDMyTEU6IDQsXG4gICAgcmVhZEludDE2QkU6IDIsXG4gICAgcmVhZEludDE2TEU6IDIsXG4gICAgcmVhZFVJbnQxNkJFOiAyLFxuICAgIHJlYWRVSW50MTZMRTogMixcbiAgICByZWFkSW50ODogMSxcbiAgICByZWFkVUludDg6IDEsXG4gICAgcmVhZEludEJFOiBudWxsLFxuICAgIHJlYWRJbnRMRTogbnVsbCxcbiAgICByZWFkVUludEJFOiBudWxsLFxuICAgIHJlYWRVSW50TEU6IG51bGxcbiAgfVxuXG4gIGZvciAoY29uc3QgbSBpbiBtZXRob2RzKSB7XG4gICAgKGZ1bmN0aW9uIChtKSB7XG4gICAgICBpZiAobWV0aG9kc1ttXSA9PT0gbnVsbCkge1xuICAgICAgICBCdWZmZXJMaXN0LnByb3RvdHlwZVttXSA9IGZ1bmN0aW9uIChvZmZzZXQsIGJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zbGljZShvZmZzZXQsIG9mZnNldCArIGJ5dGVMZW5ndGgpW21dKDAsIGJ5dGVMZW5ndGgpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIEJ1ZmZlckxpc3QucHJvdG90eXBlW21dID0gZnVuY3Rpb24gKG9mZnNldCA9IDApIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zbGljZShvZmZzZXQsIG9mZnNldCArIG1ldGhvZHNbbV0pW21dKDApXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KG0pKVxuICB9XG59KCkpXG5cbi8vIFVzZWQgaW50ZXJuYWxseSBieSB0aGUgY2xhc3MgYW5kIGFsc28gYXMgYW4gaW5kaWNhdG9yIG9mIHRoaXMgb2JqZWN0IGJlaW5nXG4vLyBhIGBCdWZmZXJMaXN0YC4gSXQncyBub3QgcG9zc2libGUgdG8gdXNlIGBpbnN0YW5jZW9mIEJ1ZmZlckxpc3RgIGluIGEgYnJvd3NlclxuLy8gZW52aXJvbm1lbnQgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBtdWx0aXBsZSBkaWZmZXJlbnQgY29waWVzIG9mIHRoZVxuLy8gQnVmZmVyTGlzdCBjbGFzcyBhbmQgc29tZSBgQnVmZmVyTGlzdGBzIG1pZ2h0IGJlIGBCdWZmZXJMaXN0YHMuXG5CdWZmZXJMaXN0LnByb3RvdHlwZS5faXNCdWZmZXJMaXN0ID0gZnVuY3Rpb24gX2lzQnVmZmVyTGlzdCAoYikge1xuICByZXR1cm4gYiBpbnN0YW5jZW9mIEJ1ZmZlckxpc3QgfHwgQnVmZmVyTGlzdC5pc0J1ZmZlckxpc3QoYilcbn1cblxuQnVmZmVyTGlzdC5pc0J1ZmZlckxpc3QgPSBmdW5jdGlvbiBpc0J1ZmZlckxpc3QgKGIpIHtcbiAgcmV0dXJuIGIgIT0gbnVsbCAmJiBiW3N5bWJvbF1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBCdWZmZXJMaXN0XG4iLCAiLyoqXG4gKiBSYWJpbiBmaW5nZXJwcmludGluZ1xuICpcbiAqIEBjbGFzcyBSYWJpblxuICovXG5jbGFzcyBSYWJpbiB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBSYWJpbi5cbiAgICAgKiBAcGFyYW0geyBpbXBvcnQoXCIuLy4uL2Rpc3QvcmFiaW4td2FzbVwiKSB9IGFzTW9kdWxlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtiaXRzPTEyXVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbWluPTggKiAxMDI0XVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbWF4PTMyICogMTAyNF1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcG9seW5vbWlhbFxuICAgICAqIEBtZW1iZXJvZiBSYWJpblxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGFzTW9kdWxlLCBiaXRzID0gMTIsIG1pbiA9IDggKiAxMDI0LCBtYXggPSAzMiAqIDEwMjQsIHdpbmRvd1NpemUgPSA2NCwgcG9seW5vbWlhbCkge1xuICAgICAgICB0aGlzLmJpdHMgPSBiaXRzXG4gICAgICAgIHRoaXMubWluID0gbWluXG4gICAgICAgIHRoaXMubWF4ID0gbWF4XG4gICAgICAgIHRoaXMuYXNNb2R1bGUgPSBhc01vZHVsZVxuICAgICAgICB0aGlzLnJhYmluID0gbmV3IGFzTW9kdWxlLlJhYmluKGJpdHMsIG1pbiwgbWF4LCB3aW5kb3dTaXplLCBwb2x5bm9taWFsKVxuICAgICAgICB0aGlzLnBvbHlub21pYWwgPSBwb2x5bm9taWFsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmluZ2VycHJpbnRzIHRoZSBidWZmZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmXG4gICAgICogQHJldHVybnMge0FycmF5PG51bWJlcj59XG4gICAgICogQG1lbWJlcm9mIFJhYmluXG4gICAgICovXG4gICAgZmluZ2VycHJpbnQoYnVmKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIF9fcmV0YWluLFxuICAgICAgICAgICAgX19yZWxlYXNlLFxuICAgICAgICAgICAgX19hbGxvY0FycmF5LFxuICAgICAgICAgICAgX19nZXRJbnQzMkFycmF5LFxuICAgICAgICAgICAgSW50MzJBcnJheV9JRCxcbiAgICAgICAgICAgIFVpbnQ4QXJyYXlfSURcbiAgICAgICAgfSA9IHRoaXMuYXNNb2R1bGVcblxuICAgICAgICBjb25zdCBsZW5ndGhzID0gbmV3IEludDMyQXJyYXkoTWF0aC5jZWlsKGJ1Zi5sZW5ndGgvdGhpcy5taW4pKVxuICAgICAgICBjb25zdCBsZW5ndGhzUHRyID0gX19yZXRhaW4oX19hbGxvY0FycmF5KEludDMyQXJyYXlfSUQsIGxlbmd0aHMpKVxuICAgICAgICBjb25zdCBwb2ludGVyID0gX19yZXRhaW4oX19hbGxvY0FycmF5KFVpbnQ4QXJyYXlfSUQsIGJ1ZikpXG5cbiAgICAgICAgY29uc3Qgb3V0ID0gdGhpcy5yYWJpbi5maW5nZXJwcmludChwb2ludGVyLCBsZW5ndGhzUHRyKVxuICAgICAgICBjb25zdCBwcm9jZXNzZWQgPSBfX2dldEludDMyQXJyYXkob3V0KVxuXG4gICAgICAgIF9fcmVsZWFzZShwb2ludGVyKVxuICAgICAgICBfX3JlbGVhc2UobGVuZ3Roc1B0cilcblxuICAgICAgICBjb25zdCBlbmQgPSBwcm9jZXNzZWQuaW5kZXhPZigwKTtcbiAgICAgICAgcmV0dXJuIGVuZCA+PSAwID8gcHJvY2Vzc2VkLnN1YmFycmF5KDAsIGVuZCkgOiBwcm9jZXNzZWQ7XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJhYmluIiwgIlwidXNlIHN0cmljdFwiO1xuXG4vLyBSdW50aW1lIGhlYWRlciBvZmZzZXRzXG5jb25zdCBJRF9PRkZTRVQgPSAtODtcbmNvbnN0IFNJWkVfT0ZGU0VUID0gLTQ7XG5cbi8vIFJ1bnRpbWUgaWRzXG5jb25zdCBBUlJBWUJVRkZFUl9JRCA9IDA7XG5jb25zdCBTVFJJTkdfSUQgPSAxO1xuY29uc3QgQVJSQVlCVUZGRVJWSUVXX0lEID0gMjtcblxuLy8gUnVudGltZSB0eXBlIGluZm9ybWF0aW9uXG5jb25zdCBBUlJBWUJVRkZFUlZJRVcgPSAxIDw8IDA7XG5jb25zdCBBUlJBWSA9IDEgPDwgMTtcbmNvbnN0IFNFVCA9IDEgPDwgMjtcbmNvbnN0IE1BUCA9IDEgPDwgMztcbmNvbnN0IFZBTF9BTElHTl9PRkZTRVQgPSA1O1xuY29uc3QgVkFMX0FMSUdOID0gMSA8PCBWQUxfQUxJR05fT0ZGU0VUO1xuY29uc3QgVkFMX1NJR05FRCA9IDEgPDwgMTA7XG5jb25zdCBWQUxfRkxPQVQgPSAxIDw8IDExO1xuY29uc3QgVkFMX05VTExBQkxFID0gMSA8PCAxMjtcbmNvbnN0IFZBTF9NQU5BR0VEID0gMSA8PCAxMztcbmNvbnN0IEtFWV9BTElHTl9PRkZTRVQgPSAxNDtcbmNvbnN0IEtFWV9BTElHTiA9IDEgPDwgS0VZX0FMSUdOX09GRlNFVDtcbmNvbnN0IEtFWV9TSUdORUQgPSAxIDw8IDE5O1xuY29uc3QgS0VZX0ZMT0FUID0gMSA8PCAyMDtcbmNvbnN0IEtFWV9OVUxMQUJMRSA9IDEgPDwgMjE7XG5jb25zdCBLRVlfTUFOQUdFRCA9IDEgPDwgMjI7XG5cbi8vIEFycmF5KEJ1ZmZlclZpZXcpIGxheW91dFxuY29uc3QgQVJSQVlCVUZGRVJWSUVXX0JVRkZFUl9PRkZTRVQgPSAwO1xuY29uc3QgQVJSQVlCVUZGRVJWSUVXX0RBVEFTVEFSVF9PRkZTRVQgPSA0O1xuY29uc3QgQVJSQVlCVUZGRVJWSUVXX0RBVEFMRU5HVEhfT0ZGU0VUID0gODtcbmNvbnN0IEFSUkFZQlVGRkVSVklFV19TSVpFID0gMTI7XG5jb25zdCBBUlJBWV9MRU5HVEhfT0ZGU0VUID0gMTI7XG5jb25zdCBBUlJBWV9TSVpFID0gMTY7XG5cbmNvbnN0IEJJR0lOVCA9IHR5cGVvZiBCaWdVaW50NjRBcnJheSAhPT0gXCJ1bmRlZmluZWRcIjtcbmNvbnN0IFRISVMgPSBTeW1ib2woKTtcbmNvbnN0IENIVU5LU0laRSA9IDEwMjQ7XG5cbi8qKiBHZXRzIGEgc3RyaW5nIGZyb20gYW4gVTMyIGFuZCBhbiBVMTYgdmlldyBvbiBhIG1lbW9yeS4gKi9cbmZ1bmN0aW9uIGdldFN0cmluZ0ltcGwoYnVmZmVyLCBwdHIpIHtcbiAgY29uc3QgVTMyID0gbmV3IFVpbnQzMkFycmF5KGJ1ZmZlcik7XG4gIGNvbnN0IFUxNiA9IG5ldyBVaW50MTZBcnJheShidWZmZXIpO1xuICB2YXIgbGVuZ3RoID0gVTMyWyhwdHIgKyBTSVpFX09GRlNFVCkgPj4+IDJdID4+PiAxO1xuICB2YXIgb2Zmc2V0ID0gcHRyID4+PiAxO1xuICBpZiAobGVuZ3RoIDw9IENIVU5LU0laRSkgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBVMTYuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyBsZW5ndGgpKTtcbiAgY29uc3QgcGFydHMgPSBbXTtcbiAgZG8ge1xuICAgIGNvbnN0IGxhc3QgPSBVMTZbb2Zmc2V0ICsgQ0hVTktTSVpFIC0gMV07XG4gICAgY29uc3Qgc2l6ZSA9IGxhc3QgPj0gMHhEODAwICYmIGxhc3QgPCAweERDMDAgPyBDSFVOS1NJWkUgLSAxIDogQ0hVTktTSVpFO1xuICAgIHBhcnRzLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIFUxNi5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArPSBzaXplKSkpO1xuICAgIGxlbmd0aCAtPSBzaXplO1xuICB9IHdoaWxlIChsZW5ndGggPiBDSFVOS1NJWkUpO1xuICByZXR1cm4gcGFydHMuam9pbihcIlwiKSArIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBVMTYuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyBsZW5ndGgpKTtcbn1cblxuLyoqIFByZXBhcmVzIHRoZSBiYXNlIG1vZHVsZSBwcmlvciB0byBpbnN0YW50aWF0aW9uLiAqL1xuZnVuY3Rpb24gcHJlSW5zdGFudGlhdGUoaW1wb3J0cykge1xuICBjb25zdCBiYXNlTW9kdWxlID0ge307XG5cbiAgZnVuY3Rpb24gZ2V0U3RyaW5nKG1lbW9yeSwgcHRyKSB7XG4gICAgaWYgKCFtZW1vcnkpIHJldHVybiBcIjx5ZXQgdW5rbm93bj5cIjtcbiAgICByZXR1cm4gZ2V0U3RyaW5nSW1wbChtZW1vcnkuYnVmZmVyLCBwdHIpO1xuICB9XG5cbiAgLy8gYWRkIGNvbW1vbiBpbXBvcnRzIHVzZWQgYnkgc3RkbGliIGZvciBjb252ZW5pZW5jZVxuICBjb25zdCBlbnYgPSAoaW1wb3J0cy5lbnYgPSBpbXBvcnRzLmVudiB8fCB7fSk7XG4gIGVudi5hYm9ydCA9IGVudi5hYm9ydCB8fCBmdW5jdGlvbiBhYm9ydChtZXNnLCBmaWxlLCBsaW5lLCBjb2xtKSB7XG4gICAgY29uc3QgbWVtb3J5ID0gYmFzZU1vZHVsZS5tZW1vcnkgfHwgZW52Lm1lbW9yeTsgLy8gcHJlZmVyIGV4cG9ydGVkLCBvdGhlcndpc2UgdHJ5IGltcG9ydGVkXG4gICAgdGhyb3cgRXJyb3IoXCJhYm9ydDogXCIgKyBnZXRTdHJpbmcobWVtb3J5LCBtZXNnKSArIFwiIGF0IFwiICsgZ2V0U3RyaW5nKG1lbW9yeSwgZmlsZSkgKyBcIjpcIiArIGxpbmUgKyBcIjpcIiArIGNvbG0pO1xuICB9XG4gIGVudi50cmFjZSA9IGVudi50cmFjZSB8fCBmdW5jdGlvbiB0cmFjZShtZXNnLCBuKSB7XG4gICAgY29uc3QgbWVtb3J5ID0gYmFzZU1vZHVsZS5tZW1vcnkgfHwgZW52Lm1lbW9yeTtcbiAgICBjb25zb2xlLmxvZyhcInRyYWNlOiBcIiArIGdldFN0cmluZyhtZW1vcnksIG1lc2cpICsgKG4gPyBcIiBcIiA6IFwiXCIpICsgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyLCAyICsgbikuam9pbihcIiwgXCIpKTtcbiAgfVxuICBpbXBvcnRzLk1hdGggPSBpbXBvcnRzLk1hdGggfHwgTWF0aDtcbiAgaW1wb3J0cy5EYXRlID0gaW1wb3J0cy5EYXRlIHx8IERhdGU7XG5cbiAgcmV0dXJuIGJhc2VNb2R1bGU7XG59XG5cbi8qKiBQcmVwYXJlcyB0aGUgZmluYWwgbW9kdWxlIG9uY2UgaW5zdGFudGlhdGlvbiBpcyBjb21wbGV0ZS4gKi9cbmZ1bmN0aW9uIHBvc3RJbnN0YW50aWF0ZShiYXNlTW9kdWxlLCBpbnN0YW5jZSkge1xuICBjb25zdCByYXdFeHBvcnRzID0gaW5zdGFuY2UuZXhwb3J0cztcbiAgY29uc3QgbWVtb3J5ID0gcmF3RXhwb3J0cy5tZW1vcnk7XG4gIGNvbnN0IHRhYmxlID0gcmF3RXhwb3J0cy50YWJsZTtcbiAgY29uc3QgYWxsb2MgPSByYXdFeHBvcnRzW1wiX19hbGxvY1wiXTtcbiAgY29uc3QgcmV0YWluID0gcmF3RXhwb3J0c1tcIl9fcmV0YWluXCJdO1xuICBjb25zdCBydHRpQmFzZSA9IHJhd0V4cG9ydHNbXCJfX3J0dGlfYmFzZVwiXSB8fCB+MDsgLy8gb29iIGlmIG5vdCBwcmVzZW50XG5cbiAgLyoqIEdldHMgdGhlIHJ1bnRpbWUgdHlwZSBpbmZvIGZvciB0aGUgZ2l2ZW4gaWQuICovXG4gIGZ1bmN0aW9uIGdldEluZm8oaWQpIHtcbiAgICBjb25zdCBVMzIgPSBuZXcgVWludDMyQXJyYXkobWVtb3J5LmJ1ZmZlcik7XG4gICAgY29uc3QgY291bnQgPSBVMzJbcnR0aUJhc2UgPj4+IDJdO1xuICAgIGlmICgoaWQgPj4+PSAwKSA+PSBjb3VudCkgdGhyb3cgRXJyb3IoXCJpbnZhbGlkIGlkOiBcIiArIGlkKTtcbiAgICByZXR1cm4gVTMyWyhydHRpQmFzZSArIDQgPj4+IDIpICsgaWQgKiAyXTtcbiAgfVxuXG4gIC8qKiBHZXRzIHRoZSBydW50aW1lIGJhc2UgaWQgZm9yIHRoZSBnaXZlbiBpZC4gKi9cbiAgZnVuY3Rpb24gZ2V0QmFzZShpZCkge1xuICAgIGNvbnN0IFUzMiA9IG5ldyBVaW50MzJBcnJheShtZW1vcnkuYnVmZmVyKTtcbiAgICBjb25zdCBjb3VudCA9IFUzMltydHRpQmFzZSA+Pj4gMl07XG4gICAgaWYgKChpZCA+Pj49IDApID49IGNvdW50KSB0aHJvdyBFcnJvcihcImludmFsaWQgaWQ6IFwiICsgaWQpO1xuICAgIHJldHVybiBVMzJbKHJ0dGlCYXNlICsgNCA+Pj4gMikgKyBpZCAqIDIgKyAxXTtcbiAgfVxuXG4gIC8qKiBHZXRzIHRoZSBydW50aW1lIGFsaWdubWVudCBvZiBhIGNvbGxlY3Rpb24ncyB2YWx1ZXMuICovXG4gIGZ1bmN0aW9uIGdldFZhbHVlQWxpZ24oaW5mbykge1xuICAgIHJldHVybiAzMSAtIE1hdGguY2x6MzIoKGluZm8gPj4+IFZBTF9BTElHTl9PRkZTRVQpICYgMzEpOyAvLyAtMSBpZiBub25lXG4gIH1cblxuICAvKiogR2V0cyB0aGUgcnVudGltZSBhbGlnbm1lbnQgb2YgYSBjb2xsZWN0aW9uJ3Mga2V5cy4gKi9cbiAgZnVuY3Rpb24gZ2V0S2V5QWxpZ24oaW5mbykge1xuICAgIHJldHVybiAzMSAtIE1hdGguY2x6MzIoKGluZm8gPj4+IEtFWV9BTElHTl9PRkZTRVQpICYgMzEpOyAvLyAtMSBpZiBub25lXG4gIH1cblxuICAvKiogQWxsb2NhdGVzIGEgbmV3IHN0cmluZyBpbiB0aGUgbW9kdWxlJ3MgbWVtb3J5IGFuZCByZXR1cm5zIGl0cyByZXRhaW5lZCBwb2ludGVyLiAqL1xuICBmdW5jdGlvbiBfX2FsbG9jU3RyaW5nKHN0cikge1xuICAgIGNvbnN0IGxlbmd0aCA9IHN0ci5sZW5ndGg7XG4gICAgY29uc3QgcHRyID0gYWxsb2MobGVuZ3RoIDw8IDEsIFNUUklOR19JRCk7XG4gICAgY29uc3QgVTE2ID0gbmV3IFVpbnQxNkFycmF5KG1lbW9yeS5idWZmZXIpO1xuICAgIGZvciAodmFyIGkgPSAwLCBwID0gcHRyID4+PiAxOyBpIDwgbGVuZ3RoOyArK2kpIFUxNltwICsgaV0gPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICByZXR1cm4gcHRyO1xuICB9XG5cbiAgYmFzZU1vZHVsZS5fX2FsbG9jU3RyaW5nID0gX19hbGxvY1N0cmluZztcblxuICAvKiogUmVhZHMgYSBzdHJpbmcgZnJvbSB0aGUgbW9kdWxlJ3MgbWVtb3J5IGJ5IGl0cyBwb2ludGVyLiAqL1xuICBmdW5jdGlvbiBfX2dldFN0cmluZyhwdHIpIHtcbiAgICBjb25zdCBidWZmZXIgPSBtZW1vcnkuYnVmZmVyO1xuICAgIGNvbnN0IGlkID0gbmV3IFVpbnQzMkFycmF5KGJ1ZmZlcilbcHRyICsgSURfT0ZGU0VUID4+PiAyXTtcbiAgICBpZiAoaWQgIT09IFNUUklOR19JRCkgdGhyb3cgRXJyb3IoXCJub3QgYSBzdHJpbmc6IFwiICsgcHRyKTtcbiAgICByZXR1cm4gZ2V0U3RyaW5nSW1wbChidWZmZXIsIHB0cik7XG4gIH1cblxuICBiYXNlTW9kdWxlLl9fZ2V0U3RyaW5nID0gX19nZXRTdHJpbmc7XG5cbiAgLyoqIEdldHMgdGhlIHZpZXcgbWF0Y2hpbmcgdGhlIHNwZWNpZmllZCBhbGlnbm1lbnQsIHNpZ25lZG5lc3MgYW5kIGZsb2F0bmVzcy4gKi9cbiAgZnVuY3Rpb24gZ2V0VmlldyhhbGlnbkxvZzIsIHNpZ25lZCwgZmxvYXQpIHtcbiAgICBjb25zdCBidWZmZXIgPSBtZW1vcnkuYnVmZmVyO1xuICAgIGlmIChmbG9hdCkge1xuICAgICAgc3dpdGNoIChhbGlnbkxvZzIpIHtcbiAgICAgICAgY2FzZSAyOiByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShidWZmZXIpO1xuICAgICAgICBjYXNlIDM6IHJldHVybiBuZXcgRmxvYXQ2NEFycmF5KGJ1ZmZlcik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXRjaCAoYWxpZ25Mb2cyKSB7XG4gICAgICAgIGNhc2UgMDogcmV0dXJuIG5ldyAoc2lnbmVkID8gSW50OEFycmF5IDogVWludDhBcnJheSkoYnVmZmVyKTtcbiAgICAgICAgY2FzZSAxOiByZXR1cm4gbmV3IChzaWduZWQgPyBJbnQxNkFycmF5IDogVWludDE2QXJyYXkpKGJ1ZmZlcik7XG4gICAgICAgIGNhc2UgMjogcmV0dXJuIG5ldyAoc2lnbmVkID8gSW50MzJBcnJheSA6IFVpbnQzMkFycmF5KShidWZmZXIpO1xuICAgICAgICBjYXNlIDM6IHJldHVybiBuZXcgKHNpZ25lZCA/IEJpZ0ludDY0QXJyYXkgOiBCaWdVaW50NjRBcnJheSkoYnVmZmVyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgRXJyb3IoXCJ1bnN1cHBvcnRlZCBhbGlnbjogXCIgKyBhbGlnbkxvZzIpO1xuICB9XG5cbiAgLyoqIEFsbG9jYXRlcyBhIG5ldyBhcnJheSBpbiB0aGUgbW9kdWxlJ3MgbWVtb3J5IGFuZCByZXR1cm5zIGl0cyByZXRhaW5lZCBwb2ludGVyLiAqL1xuICBmdW5jdGlvbiBfX2FsbG9jQXJyYXkoaWQsIHZhbHVlcykge1xuICAgIGNvbnN0IGluZm8gPSBnZXRJbmZvKGlkKTtcbiAgICBpZiAoIShpbmZvICYgKEFSUkFZQlVGRkVSVklFVyB8IEFSUkFZKSkpIHRocm93IEVycm9yKFwibm90IGFuIGFycmF5OiBcIiArIGlkICsgXCIgQCBcIiArIGluZm8pO1xuICAgIGNvbnN0IGFsaWduID0gZ2V0VmFsdWVBbGlnbihpbmZvKTtcbiAgICBjb25zdCBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoO1xuICAgIGNvbnN0IGJ1ZiA9IGFsbG9jKGxlbmd0aCA8PCBhbGlnbiwgQVJSQVlCVUZGRVJfSUQpO1xuICAgIGNvbnN0IGFyciA9IGFsbG9jKGluZm8gJiBBUlJBWSA/IEFSUkFZX1NJWkUgOiBBUlJBWUJVRkZFUlZJRVdfU0laRSwgaWQpO1xuICAgIGNvbnN0IFUzMiA9IG5ldyBVaW50MzJBcnJheShtZW1vcnkuYnVmZmVyKTtcbiAgICBVMzJbYXJyICsgQVJSQVlCVUZGRVJWSUVXX0JVRkZFUl9PRkZTRVQgPj4+IDJdID0gcmV0YWluKGJ1Zik7XG4gICAgVTMyW2FyciArIEFSUkFZQlVGRkVSVklFV19EQVRBU1RBUlRfT0ZGU0VUID4+PiAyXSA9IGJ1ZjtcbiAgICBVMzJbYXJyICsgQVJSQVlCVUZGRVJWSUVXX0RBVEFMRU5HVEhfT0ZGU0VUID4+PiAyXSA9IGxlbmd0aCA8PCBhbGlnbjtcbiAgICBpZiAoaW5mbyAmIEFSUkFZKSBVMzJbYXJyICsgQVJSQVlfTEVOR1RIX09GRlNFVCA+Pj4gMl0gPSBsZW5ndGg7XG4gICAgY29uc3QgdmlldyA9IGdldFZpZXcoYWxpZ24sIGluZm8gJiBWQUxfU0lHTkVELCBpbmZvICYgVkFMX0ZMT0FUKTtcbiAgICBpZiAoaW5mbyAmIFZBTF9NQU5BR0VEKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB2aWV3WyhidWYgPj4+IGFsaWduKSArIGldID0gcmV0YWluKHZhbHVlc1tpXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZpZXcuc2V0KHZhbHVlcywgYnVmID4+PiBhbGlnbik7XG4gICAgfVxuICAgIHJldHVybiBhcnI7XG4gIH1cblxuICBiYXNlTW9kdWxlLl9fYWxsb2NBcnJheSA9IF9fYWxsb2NBcnJheTtcblxuICAvKiogR2V0cyBhIGxpdmUgdmlldyBvbiBhbiBhcnJheSdzIHZhbHVlcyBpbiB0aGUgbW9kdWxlJ3MgbWVtb3J5LiBJbmZlcnMgdGhlIGFycmF5IHR5cGUgZnJvbSBSVFRJLiAqL1xuICBmdW5jdGlvbiBfX2dldEFycmF5VmlldyhhcnIpIHtcbiAgICBjb25zdCBVMzIgPSBuZXcgVWludDMyQXJyYXkobWVtb3J5LmJ1ZmZlcik7XG4gICAgY29uc3QgaWQgPSBVMzJbYXJyICsgSURfT0ZGU0VUID4+PiAyXTtcbiAgICBjb25zdCBpbmZvID0gZ2V0SW5mbyhpZCk7XG4gICAgaWYgKCEoaW5mbyAmIEFSUkFZQlVGRkVSVklFVykpIHRocm93IEVycm9yKFwibm90IGFuIGFycmF5OiBcIiArIGlkKTtcbiAgICBjb25zdCBhbGlnbiA9IGdldFZhbHVlQWxpZ24oaW5mbyk7XG4gICAgdmFyIGJ1ZiA9IFUzMlthcnIgKyBBUlJBWUJVRkZFUlZJRVdfREFUQVNUQVJUX09GRlNFVCA+Pj4gMl07XG4gICAgY29uc3QgbGVuZ3RoID0gaW5mbyAmIEFSUkFZXG4gICAgICA/IFUzMlthcnIgKyBBUlJBWV9MRU5HVEhfT0ZGU0VUID4+PiAyXVxuICAgICAgOiBVMzJbYnVmICsgU0laRV9PRkZTRVQgPj4+IDJdID4+PiBhbGlnbjtcbiAgICByZXR1cm4gZ2V0VmlldyhhbGlnbiwgaW5mbyAmIFZBTF9TSUdORUQsIGluZm8gJiBWQUxfRkxPQVQpXG4gICAgICAgICAgLnN1YmFycmF5KGJ1ZiA+Pj49IGFsaWduLCBidWYgKyBsZW5ndGgpO1xuICB9XG5cbiAgYmFzZU1vZHVsZS5fX2dldEFycmF5VmlldyA9IF9fZ2V0QXJyYXlWaWV3O1xuXG4gIC8qKiBDb3BpZXMgYW4gYXJyYXkncyB2YWx1ZXMgZnJvbSB0aGUgbW9kdWxlJ3MgbWVtb3J5LiBJbmZlcnMgdGhlIGFycmF5IHR5cGUgZnJvbSBSVFRJLiAqL1xuICBmdW5jdGlvbiBfX2dldEFycmF5KGFycikge1xuICAgIGNvbnN0IGlucHV0ID0gX19nZXRBcnJheVZpZXcoYXJyKTtcbiAgICBjb25zdCBsZW4gPSBpbnB1dC5sZW5ndGg7XG4gICAgY29uc3Qgb3V0ID0gbmV3IEFycmF5KGxlbik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykgb3V0W2ldID0gaW5wdXRbaV07XG4gICAgcmV0dXJuIG91dDtcbiAgfVxuXG4gIGJhc2VNb2R1bGUuX19nZXRBcnJheSA9IF9fZ2V0QXJyYXk7XG5cbiAgLyoqIENvcGllcyBhbiBBcnJheUJ1ZmZlcidzIHZhbHVlIGZyb20gdGhlIG1vZHVsZSdzIG1lbW9yeS4gKi9cbiAgZnVuY3Rpb24gX19nZXRBcnJheUJ1ZmZlcihwdHIpIHtcbiAgICBjb25zdCBidWZmZXIgPSBtZW1vcnkuYnVmZmVyO1xuICAgIGNvbnN0IGxlbmd0aCA9IG5ldyBVaW50MzJBcnJheShidWZmZXIpW3B0ciArIFNJWkVfT0ZGU0VUID4+PiAyXTtcbiAgICByZXR1cm4gYnVmZmVyLnNsaWNlKHB0ciwgcHRyICsgbGVuZ3RoKTtcbiAgfVxuXG4gIGJhc2VNb2R1bGUuX19nZXRBcnJheUJ1ZmZlciA9IF9fZ2V0QXJyYXlCdWZmZXI7XG5cbiAgLyoqIENvcGllcyBhIHR5cGVkIGFycmF5J3MgdmFsdWVzIGZyb20gdGhlIG1vZHVsZSdzIG1lbW9yeS4gKi9cbiAgZnVuY3Rpb24gZ2V0VHlwZWRBcnJheShUeXBlLCBhbGlnbkxvZzIsIHB0cikge1xuICAgIHJldHVybiBuZXcgVHlwZShnZXRUeXBlZEFycmF5VmlldyhUeXBlLCBhbGlnbkxvZzIsIHB0cikpO1xuICB9XG5cbiAgLyoqIEdldHMgYSBsaXZlIHZpZXcgb24gYSB0eXBlZCBhcnJheSdzIHZhbHVlcyBpbiB0aGUgbW9kdWxlJ3MgbWVtb3J5LiAqL1xuICBmdW5jdGlvbiBnZXRUeXBlZEFycmF5VmlldyhUeXBlLCBhbGlnbkxvZzIsIHB0cikge1xuICAgIGNvbnN0IGJ1ZmZlciA9IG1lbW9yeS5idWZmZXI7XG4gICAgY29uc3QgVTMyID0gbmV3IFVpbnQzMkFycmF5KGJ1ZmZlcik7XG4gICAgY29uc3QgYnVmUHRyID0gVTMyW3B0ciArIEFSUkFZQlVGRkVSVklFV19EQVRBU1RBUlRfT0ZGU0VUID4+PiAyXTtcbiAgICByZXR1cm4gbmV3IFR5cGUoYnVmZmVyLCBidWZQdHIsIFUzMltidWZQdHIgKyBTSVpFX09GRlNFVCA+Pj4gMl0gPj4+IGFsaWduTG9nMik7XG4gIH1cblxuICBiYXNlTW9kdWxlLl9fZ2V0SW50OEFycmF5ID0gZ2V0VHlwZWRBcnJheS5iaW5kKG51bGwsIEludDhBcnJheSwgMCk7XG4gIGJhc2VNb2R1bGUuX19nZXRJbnQ4QXJyYXlWaWV3ID0gZ2V0VHlwZWRBcnJheVZpZXcuYmluZChudWxsLCBJbnQ4QXJyYXksIDApO1xuICBiYXNlTW9kdWxlLl9fZ2V0VWludDhBcnJheSA9IGdldFR5cGVkQXJyYXkuYmluZChudWxsLCBVaW50OEFycmF5LCAwKTtcbiAgYmFzZU1vZHVsZS5fX2dldFVpbnQ4QXJyYXlWaWV3ID0gZ2V0VHlwZWRBcnJheVZpZXcuYmluZChudWxsLCBVaW50OEFycmF5LCAwKTtcbiAgYmFzZU1vZHVsZS5fX2dldFVpbnQ4Q2xhbXBlZEFycmF5ID0gZ2V0VHlwZWRBcnJheS5iaW5kKG51bGwsIFVpbnQ4Q2xhbXBlZEFycmF5LCAwKTtcbiAgYmFzZU1vZHVsZS5fX2dldFVpbnQ4Q2xhbXBlZEFycmF5VmlldyA9IGdldFR5cGVkQXJyYXlWaWV3LmJpbmQobnVsbCwgVWludDhDbGFtcGVkQXJyYXksIDApO1xuICBiYXNlTW9kdWxlLl9fZ2V0SW50MTZBcnJheSA9IGdldFR5cGVkQXJyYXkuYmluZChudWxsLCBJbnQxNkFycmF5LCAxKTtcbiAgYmFzZU1vZHVsZS5fX2dldEludDE2QXJyYXlWaWV3ID0gZ2V0VHlwZWRBcnJheVZpZXcuYmluZChudWxsLCBJbnQxNkFycmF5LCAxKTtcbiAgYmFzZU1vZHVsZS5fX2dldFVpbnQxNkFycmF5ID0gZ2V0VHlwZWRBcnJheS5iaW5kKG51bGwsIFVpbnQxNkFycmF5LCAxKTtcbiAgYmFzZU1vZHVsZS5fX2dldFVpbnQxNkFycmF5VmlldyA9IGdldFR5cGVkQXJyYXlWaWV3LmJpbmQobnVsbCwgVWludDE2QXJyYXksIDEpO1xuICBiYXNlTW9kdWxlLl9fZ2V0SW50MzJBcnJheSA9IGdldFR5cGVkQXJyYXkuYmluZChudWxsLCBJbnQzMkFycmF5LCAyKTtcbiAgYmFzZU1vZHVsZS5fX2dldEludDMyQXJyYXlWaWV3ID0gZ2V0VHlwZWRBcnJheVZpZXcuYmluZChudWxsLCBJbnQzMkFycmF5LCAyKTtcbiAgYmFzZU1vZHVsZS5fX2dldFVpbnQzMkFycmF5ID0gZ2V0VHlwZWRBcnJheS5iaW5kKG51bGwsIFVpbnQzMkFycmF5LCAyKTtcbiAgYmFzZU1vZHVsZS5fX2dldFVpbnQzMkFycmF5VmlldyA9IGdldFR5cGVkQXJyYXlWaWV3LmJpbmQobnVsbCwgVWludDMyQXJyYXksIDIpO1xuICBpZiAoQklHSU5UKSB7XG4gICAgYmFzZU1vZHVsZS5fX2dldEludDY0QXJyYXkgPSBnZXRUeXBlZEFycmF5LmJpbmQobnVsbCwgQmlnSW50NjRBcnJheSwgMyk7XG4gICAgYmFzZU1vZHVsZS5fX2dldEludDY0QXJyYXlWaWV3ID0gZ2V0VHlwZWRBcnJheVZpZXcuYmluZChudWxsLCBCaWdJbnQ2NEFycmF5LCAzKTtcbiAgICBiYXNlTW9kdWxlLl9fZ2V0VWludDY0QXJyYXkgPSBnZXRUeXBlZEFycmF5LmJpbmQobnVsbCwgQmlnVWludDY0QXJyYXksIDMpO1xuICAgIGJhc2VNb2R1bGUuX19nZXRVaW50NjRBcnJheVZpZXcgPSBnZXRUeXBlZEFycmF5Vmlldy5iaW5kKG51bGwsIEJpZ1VpbnQ2NEFycmF5LCAzKTtcbiAgfVxuICBiYXNlTW9kdWxlLl9fZ2V0RmxvYXQzMkFycmF5ID0gZ2V0VHlwZWRBcnJheS5iaW5kKG51bGwsIEZsb2F0MzJBcnJheSwgMik7XG4gIGJhc2VNb2R1bGUuX19nZXRGbG9hdDMyQXJyYXlWaWV3ID0gZ2V0VHlwZWRBcnJheVZpZXcuYmluZChudWxsLCBGbG9hdDMyQXJyYXksIDIpO1xuICBiYXNlTW9kdWxlLl9fZ2V0RmxvYXQ2NEFycmF5ID0gZ2V0VHlwZWRBcnJheS5iaW5kKG51bGwsIEZsb2F0NjRBcnJheSwgMyk7XG4gIGJhc2VNb2R1bGUuX19nZXRGbG9hdDY0QXJyYXlWaWV3ID0gZ2V0VHlwZWRBcnJheVZpZXcuYmluZChudWxsLCBGbG9hdDY0QXJyYXksIDMpO1xuXG4gIC8qKiBUZXN0cyB3aGV0aGVyIGFuIG9iamVjdCBpcyBhbiBpbnN0YW5jZSBvZiB0aGUgY2xhc3MgcmVwcmVzZW50ZWQgYnkgdGhlIHNwZWNpZmllZCBiYXNlIGlkLiAqL1xuICBmdW5jdGlvbiBfX2luc3RhbmNlb2YocHRyLCBiYXNlSWQpIHtcbiAgICBjb25zdCBVMzIgPSBuZXcgVWludDMyQXJyYXkobWVtb3J5LmJ1ZmZlcik7XG4gICAgdmFyIGlkID0gVTMyWyhwdHIgKyBJRF9PRkZTRVQpID4+PiAyXTtcbiAgICBpZiAoaWQgPD0gVTMyW3J0dGlCYXNlID4+PiAyXSkge1xuICAgICAgZG8gaWYgKGlkID09IGJhc2VJZCkgcmV0dXJuIHRydWU7XG4gICAgICB3aGlsZSAoaWQgPSBnZXRCYXNlKGlkKSk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGJhc2VNb2R1bGUuX19pbnN0YW5jZW9mID0gX19pbnN0YW5jZW9mO1xuXG4gIC8vIFB1bGwgYmFzaWMgZXhwb3J0cyB0byBiYXNlTW9kdWxlIHNvIGNvZGUgaW4gcHJlSW5zdGFudGlhdGUgY2FuIHVzZSB0aGVtXG4gIGJhc2VNb2R1bGUubWVtb3J5ID0gYmFzZU1vZHVsZS5tZW1vcnkgfHwgbWVtb3J5O1xuICBiYXNlTW9kdWxlLnRhYmxlICA9IGJhc2VNb2R1bGUudGFibGUgIHx8IHRhYmxlO1xuXG4gIC8vIERlbWFuZ2xlIGV4cG9ydHMgYW5kIHByb3ZpZGUgdGhlIHVzdWFsIHV0aWxpdHkgb24gdGhlIHByb3RvdHlwZVxuICByZXR1cm4gZGVtYW5nbGUocmF3RXhwb3J0cywgYmFzZU1vZHVsZSk7XG59XG5cbmZ1bmN0aW9uIGlzUmVzcG9uc2Uobykge1xuICByZXR1cm4gdHlwZW9mIFJlc3BvbnNlICE9PSBcInVuZGVmaW5lZFwiICYmIG8gaW5zdGFuY2VvZiBSZXNwb25zZTtcbn1cblxuLyoqIEFzeW5jaHJvbm91c2x5IGluc3RhbnRpYXRlcyBhbiBBc3NlbWJseVNjcmlwdCBtb2R1bGUgZnJvbSBhbnl0aGluZyB0aGF0IGNhbiBiZSBpbnN0YW50aWF0ZWQuICovXG5hc3luYyBmdW5jdGlvbiBpbnN0YW50aWF0ZShzb3VyY2UsIGltcG9ydHMpIHtcbiAgaWYgKGlzUmVzcG9uc2Uoc291cmNlID0gYXdhaXQgc291cmNlKSkgcmV0dXJuIGluc3RhbnRpYXRlU3RyZWFtaW5nKHNvdXJjZSwgaW1wb3J0cyk7XG4gIHJldHVybiBwb3N0SW5zdGFudGlhdGUoXG4gICAgcHJlSW5zdGFudGlhdGUoaW1wb3J0cyB8fCAoaW1wb3J0cyA9IHt9KSksXG4gICAgYXdhaXQgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGUoXG4gICAgICBzb3VyY2UgaW5zdGFuY2VvZiBXZWJBc3NlbWJseS5Nb2R1bGVcbiAgICAgICAgPyBzb3VyY2VcbiAgICAgICAgOiBhd2FpdCBXZWJBc3NlbWJseS5jb21waWxlKHNvdXJjZSksXG4gICAgICBpbXBvcnRzXG4gICAgKVxuICApO1xufVxuXG5leHBvcnRzLmluc3RhbnRpYXRlID0gaW5zdGFudGlhdGU7XG5cbi8qKiBTeW5jaHJvbm91c2x5IGluc3RhbnRpYXRlcyBhbiBBc3NlbWJseVNjcmlwdCBtb2R1bGUgZnJvbSBhIFdlYkFzc2VtYmx5Lk1vZHVsZSBvciBiaW5hcnkgYnVmZmVyLiAqL1xuZnVuY3Rpb24gaW5zdGFudGlhdGVTeW5jKHNvdXJjZSwgaW1wb3J0cykge1xuICByZXR1cm4gcG9zdEluc3RhbnRpYXRlKFxuICAgIHByZUluc3RhbnRpYXRlKGltcG9ydHMgfHwgKGltcG9ydHMgPSB7fSkpLFxuICAgIG5ldyBXZWJBc3NlbWJseS5JbnN0YW5jZShcbiAgICAgIHNvdXJjZSBpbnN0YW5jZW9mIFdlYkFzc2VtYmx5Lk1vZHVsZVxuICAgICAgICA/IHNvdXJjZVxuICAgICAgICA6IG5ldyBXZWJBc3NlbWJseS5Nb2R1bGUoc291cmNlKSxcbiAgICAgIGltcG9ydHNcbiAgICApXG4gIClcbn1cblxuZXhwb3J0cy5pbnN0YW50aWF0ZVN5bmMgPSBpbnN0YW50aWF0ZVN5bmM7XG5cbi8qKiBBc3luY2hyb25vdXNseSBpbnN0YW50aWF0ZXMgYW4gQXNzZW1ibHlTY3JpcHQgbW9kdWxlIGZyb20gYSByZXNwb25zZSwgaS5lLiBhcyBvYnRhaW5lZCBieSBgZmV0Y2hgLiAqL1xuYXN5bmMgZnVuY3Rpb24gaW5zdGFudGlhdGVTdHJlYW1pbmcoc291cmNlLCBpbXBvcnRzKSB7XG4gIGlmICghV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmcpIHtcbiAgICByZXR1cm4gaW5zdGFudGlhdGUoXG4gICAgICBpc1Jlc3BvbnNlKHNvdXJjZSA9IGF3YWl0IHNvdXJjZSlcbiAgICAgICAgPyBzb3VyY2UuYXJyYXlCdWZmZXIoKVxuICAgICAgICA6IHNvdXJjZSxcbiAgICAgIGltcG9ydHNcbiAgICApO1xuICB9XG4gIHJldHVybiBwb3N0SW5zdGFudGlhdGUoXG4gICAgcHJlSW5zdGFudGlhdGUoaW1wb3J0cyB8fCAoaW1wb3J0cyA9IHt9KSksXG4gICAgKGF3YWl0IFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nKHNvdXJjZSwgaW1wb3J0cykpLmluc3RhbmNlXG4gICk7XG59XG5cbmV4cG9ydHMuaW5zdGFudGlhdGVTdHJlYW1pbmcgPSBpbnN0YW50aWF0ZVN0cmVhbWluZztcblxuLyoqIERlbWFuZ2xlcyBhbiBBc3NlbWJseVNjcmlwdCBtb2R1bGUncyBleHBvcnRzIHRvIGEgZnJpZW5kbHkgb2JqZWN0IHN0cnVjdHVyZS4gKi9cbmZ1bmN0aW9uIGRlbWFuZ2xlKGV4cG9ydHMsIGJhc2VNb2R1bGUpIHtcbiAgdmFyIG1vZHVsZSA9IGJhc2VNb2R1bGUgPyBPYmplY3QuY3JlYXRlKGJhc2VNb2R1bGUpIDoge307XG4gIHZhciBzZXRBcmd1bWVudHNMZW5ndGggPSBleHBvcnRzW1wiX19hcmd1bWVudHNMZW5ndGhcIl1cbiAgICA/IGZ1bmN0aW9uKGxlbmd0aCkgeyBleHBvcnRzW1wiX19hcmd1bWVudHNMZW5ndGhcIl0udmFsdWUgPSBsZW5ndGg7IH1cbiAgICA6IGV4cG9ydHNbXCJfX3NldEFyZ3VtZW50c0xlbmd0aFwiXSB8fCBleHBvcnRzW1wiX19zZXRhcmdjXCJdIHx8IGZ1bmN0aW9uKCkge307XG4gIGZvciAobGV0IGludGVybmFsTmFtZSBpbiBleHBvcnRzKSB7XG4gICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgaW50ZXJuYWxOYW1lKSkgY29udGludWU7XG4gICAgY29uc3QgZWxlbSA9IGV4cG9ydHNbaW50ZXJuYWxOYW1lXTtcbiAgICBsZXQgcGFydHMgPSBpbnRlcm5hbE5hbWUuc3BsaXQoXCIuXCIpO1xuICAgIGxldCBjdXJyID0gbW9kdWxlO1xuICAgIHdoaWxlIChwYXJ0cy5sZW5ndGggPiAxKSB7XG4gICAgICBsZXQgcGFydCA9IHBhcnRzLnNoaWZ0KCk7XG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjdXJyLCBwYXJ0KSkgY3VycltwYXJ0XSA9IHt9O1xuICAgICAgY3VyciA9IGN1cnJbcGFydF07XG4gICAgfVxuICAgIGxldCBuYW1lID0gcGFydHNbMF07XG4gICAgbGV0IGhhc2ggPSBuYW1lLmluZGV4T2YoXCIjXCIpO1xuICAgIGlmIChoYXNoID49IDApIHtcbiAgICAgIGxldCBjbGFzc05hbWUgPSBuYW1lLnN1YnN0cmluZygwLCBoYXNoKTtcbiAgICAgIGxldCBjbGFzc0VsZW0gPSBjdXJyW2NsYXNzTmFtZV07XG4gICAgICBpZiAodHlwZW9mIGNsYXNzRWxlbSA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhY2xhc3NFbGVtLnByb3RvdHlwZSkge1xuICAgICAgICBsZXQgY3RvciA9IGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICAgICAgICByZXR1cm4gY3Rvci53cmFwKGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yKDAsIC4uLmFyZ3MpKTtcbiAgICAgICAgfTtcbiAgICAgICAgY3Rvci5wcm90b3R5cGUgPSB7XG4gICAgICAgICAgdmFsdWVPZjogZnVuY3Rpb24gdmFsdWVPZigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW1RISVNdO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY3Rvci53cmFwID0gZnVuY3Rpb24odGhpc1ZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIE9iamVjdC5jcmVhdGUoY3Rvci5wcm90b3R5cGUsIHsgW1RISVNdOiB7IHZhbHVlOiB0aGlzVmFsdWUsIHdyaXRhYmxlOiBmYWxzZSB9IH0pO1xuICAgICAgICB9O1xuICAgICAgICBpZiAoY2xhc3NFbGVtKSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhjbGFzc0VsZW0pLmZvckVhY2gobmFtZSA9PlxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdG9yLCBuYW1lLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNsYXNzRWxlbSwgbmFtZSkpXG4gICAgICAgICk7XG4gICAgICAgIGN1cnJbY2xhc3NOYW1lXSA9IGN0b3I7XG4gICAgICB9XG4gICAgICBuYW1lID0gbmFtZS5zdWJzdHJpbmcoaGFzaCArIDEpO1xuICAgICAgY3VyciA9IGN1cnJbY2xhc3NOYW1lXS5wcm90b3R5cGU7XG4gICAgICBpZiAoL14oZ2V0fHNldCk6Ly50ZXN0KG5hbWUpKSB7XG4gICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGN1cnIsIG5hbWUgPSBuYW1lLnN1YnN0cmluZyg0KSkpIHtcbiAgICAgICAgICBsZXQgZ2V0dGVyID0gZXhwb3J0c1tpbnRlcm5hbE5hbWUucmVwbGFjZShcInNldDpcIiwgXCJnZXQ6XCIpXTtcbiAgICAgICAgICBsZXQgc2V0dGVyID0gZXhwb3J0c1tpbnRlcm5hbE5hbWUucmVwbGFjZShcImdldDpcIiwgXCJzZXQ6XCIpXTtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VyciwgbmFtZSwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIGdldHRlcih0aGlzW1RISVNdKTsgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHsgc2V0dGVyKHRoaXNbVEhJU10sIHZhbHVlKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG5hbWUgPT09ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgICAgICAoY3VycltuYW1lXSA9ICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICBzZXRBcmd1bWVudHNMZW5ndGgoYXJncy5sZW5ndGgpO1xuICAgICAgICAgICAgcmV0dXJuIGVsZW0oLi4uYXJncyk7XG4gICAgICAgICAgfSkub3JpZ2luYWwgPSBlbGVtO1xuICAgICAgICB9IGVsc2UgeyAvLyBpbnN0YW5jZSBtZXRob2RcbiAgICAgICAgICAoY3VycltuYW1lXSA9IGZ1bmN0aW9uKC4uLmFyZ3MpIHsgLy8gIVxuICAgICAgICAgICAgc2V0QXJndW1lbnRzTGVuZ3RoKGFyZ3MubGVuZ3RoKTtcbiAgICAgICAgICAgIHJldHVybiBlbGVtKHRoaXNbVEhJU10sIC4uLmFyZ3MpO1xuICAgICAgICAgIH0pLm9yaWdpbmFsID0gZWxlbTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoL14oZ2V0fHNldCk6Ly50ZXN0KG5hbWUpKSB7XG4gICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGN1cnIsIG5hbWUgPSBuYW1lLnN1YnN0cmluZyg0KSkpIHtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VyciwgbmFtZSwge1xuICAgICAgICAgICAgZ2V0OiBleHBvcnRzW2ludGVybmFsTmFtZS5yZXBsYWNlKFwic2V0OlwiLCBcImdldDpcIildLFxuICAgICAgICAgICAgc2V0OiBleHBvcnRzW2ludGVybmFsTmFtZS5yZXBsYWNlKFwiZ2V0OlwiLCBcInNldDpcIildLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbGVtID09PSBcImZ1bmN0aW9uXCIgJiYgZWxlbSAhPT0gc2V0QXJndW1lbnRzTGVuZ3RoKSB7XG4gICAgICAgIChjdXJyW25hbWVdID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICBzZXRBcmd1bWVudHNMZW5ndGgoYXJncy5sZW5ndGgpO1xuICAgICAgICAgIHJldHVybiBlbGVtKC4uLmFyZ3MpO1xuICAgICAgICB9KS5vcmlnaW5hbCA9IGVsZW07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJyW25hbWVdID0gZWxlbTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1vZHVsZTtcbn1cblxuZXhwb3J0cy5kZW1hbmdsZSA9IGRlbWFuZ2xlO1xuIiwgIlxuY29uc3QgeyBpbnN0YW50aWF0ZVN5bmMgfSA9IHJlcXVpcmUoXCJAYXNzZW1ibHlzY3JpcHQvbG9hZGVyXCIpO1xuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpXG5cbmxvYWRXZWJBc3NlbWJseS5zdXBwb3J0ZWQgPSB0eXBlb2YgV2ViQXNzZW1ibHkgIT09ICd1bmRlZmluZWQnXG5cbmFzeW5jIGZ1bmN0aW9uIGxvYWRXZWJBc3NlbWJseSAoaW1wID0ge30pIHtcbiAgaWYgKCFsb2FkV2ViQXNzZW1ibHkuc3VwcG9ydGVkKSByZXR1cm4gbnVsbFxuICBcbiAgcmV0dXJuIGluc3RhbnRpYXRlU3luYyhmcy5yZWFkRmlsZVN5bmMoX19kaXJuYW1lICsgXCIvLi4vZGlzdC9yYWJpbi53YXNtXCIpLCBpbXApO1xufVxubW9kdWxlLmV4cG9ydHMgPSBsb2FkV2ViQXNzZW1ibHlcbiIsICJjb25zdCBSYWJpbiA9IHJlcXVpcmUoJy4vcmFiaW4nKVxuY29uc3QgZ2V0UmFiaW4gPSByZXF1aXJlKCcuLi9kaXN0L3JhYmluLXdhc20ubm9kZS5qcycpXG5cbmNvbnN0IGNyZWF0ZSA9IGFzeW5jIChhdmcsIG1pbiwgbWF4LCB3aW5kb3dTaXplLCBwb2x5bm9taWFsKSA9PiB7XG4gICAgY29uc3QgY29tcGlsZWQgPSBhd2FpdCBnZXRSYWJpbigpXG4gICAgcmV0dXJuIG5ldyBSYWJpbihjb21waWxlZCwgYXZnLCBtaW4sIG1heCwgd2luZG93U2l6ZSwgcG9seW5vbWlhbClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgUmFiaW4sXG4gICAgY3JlYXRlXG59XG4iLCAiJ3VzZSBzdHJpY3QnXG5cbi8vIEpTIHRyZWF0cyBzdWJqZWN0cyBvZiBiaXR3aXNlIG9wZXJhdG9ycyBhcyBTSUdORUQgMzIgYml0IG51bWJlcnMsXG4vLyB3aGljaCBtZWFucyB0aGUgbWF4aW11bSBhbW91bnQgb2YgYml0cyB3ZSBjYW4gc3RvcmUgaW5zaWRlIGVhY2ggYnl0ZVxuLy8gaXMgNy4uXG5jb25zdCBCSVRTX1BFUl9CWVRFID0gN1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIFNwYXJzZUFycmF5IHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHRoaXMuX2JpdEFycmF5cyA9IFtdXG4gICAgdGhpcy5fZGF0YSA9IFtdXG4gICAgdGhpcy5fbGVuZ3RoID0gMFxuICAgIHRoaXMuX2NoYW5nZWRMZW5ndGggPSBmYWxzZVxuICAgIHRoaXMuX2NoYW5nZWREYXRhID0gZmFsc2VcbiAgfVxuXG4gIHNldCAoaW5kZXgsIHZhbHVlKSB7XG4gICAgbGV0IHBvcyA9IHRoaXMuX2ludGVybmFsUG9zaXRpb25Gb3IoaW5kZXgsIGZhbHNlKVxuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyB1bnNldHRpbmdcbiAgICAgIGlmIChwb3MgIT09IC0xKSB7XG4gICAgICAgIC8vIHJlbW92ZSBpdGVtIGZyb20gYml0IGFycmF5IGFuZCBhcnJheSBpdHNlbGZcbiAgICAgICAgdGhpcy5fdW5zZXRJbnRlcm5hbFBvcyhwb3MpXG4gICAgICAgIHRoaXMuX3Vuc2V0Qml0KGluZGV4KVxuICAgICAgICB0aGlzLl9jaGFuZ2VkTGVuZ3RoID0gdHJ1ZVxuICAgICAgICB0aGlzLl9jaGFuZ2VkRGF0YSA9IHRydWVcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IG5lZWRzU29ydCA9IGZhbHNlXG4gICAgICBpZiAocG9zID09PSAtMSkge1xuICAgICAgICBwb3MgPSB0aGlzLl9kYXRhLmxlbmd0aFxuICAgICAgICB0aGlzLl9zZXRCaXQoaW5kZXgpXG4gICAgICAgIHRoaXMuX2NoYW5nZWREYXRhID0gdHJ1ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmVlZHNTb3J0ID0gdHJ1ZVxuICAgICAgfVxuICAgICAgdGhpcy5fc2V0SW50ZXJuYWxQb3MocG9zLCBpbmRleCwgdmFsdWUsIG5lZWRzU29ydClcbiAgICAgIHRoaXMuX2NoYW5nZWRMZW5ndGggPSB0cnVlXG4gICAgfVxuICB9XG5cbiAgdW5zZXQgKGluZGV4KSB7XG4gICAgdGhpcy5zZXQoaW5kZXgsIHVuZGVmaW5lZClcbiAgfVxuXG4gIGdldCAoaW5kZXgpIHtcbiAgICB0aGlzLl9zb3J0RGF0YSgpXG4gICAgY29uc3QgcG9zID0gdGhpcy5faW50ZXJuYWxQb3NpdGlvbkZvcihpbmRleCwgdHJ1ZSlcbiAgICBpZiAocG9zID09PSAtMSkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZGF0YVtwb3NdWzFdXG4gIH1cblxuICBwdXNoICh2YWx1ZSkge1xuICAgIHRoaXMuc2V0KHRoaXMubGVuZ3RoLCB2YWx1ZSlcbiAgICByZXR1cm4gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGdldCBsZW5ndGggKCkge1xuICAgIHRoaXMuX3NvcnREYXRhKClcbiAgICBpZiAodGhpcy5fY2hhbmdlZExlbmd0aCkge1xuICAgICAgY29uc3QgbGFzdCA9IHRoaXMuX2RhdGFbdGhpcy5fZGF0YS5sZW5ndGggLSAxXVxuICAgICAgdGhpcy5fbGVuZ3RoID0gbGFzdCA/IGxhc3RbMF0gKyAxIDogMFxuICAgICAgdGhpcy5fY2hhbmdlZExlbmd0aCA9IGZhbHNlXG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9sZW5ndGhcbiAgfVxuXG4gIGZvckVhY2ggKGl0ZXJhdG9yKSB7XG4gICAgbGV0IGkgPSAwXG4gICAgd2hpbGUoaSA8IHRoaXMubGVuZ3RoKSB7XG4gICAgICBpdGVyYXRvcih0aGlzLmdldChpKSwgaSwgdGhpcylcbiAgICAgIGkrK1xuICAgIH1cbiAgfVxuXG4gIG1hcCAoaXRlcmF0b3IpIHtcbiAgICBsZXQgaSA9IDBcbiAgICBsZXQgbWFwcGVkID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoKVxuICAgIHdoaWxlKGkgPCB0aGlzLmxlbmd0aCkge1xuICAgICAgbWFwcGVkW2ldID0gaXRlcmF0b3IodGhpcy5nZXQoaSksIGksIHRoaXMpXG4gICAgICBpKytcbiAgICB9XG4gICAgcmV0dXJuIG1hcHBlZFxuICB9XG5cbiAgcmVkdWNlIChyZWR1Y2VyLCBpbml0aWFsVmFsdWUpIHtcbiAgICBsZXQgaSA9IDBcbiAgICBsZXQgYWNjID0gaW5pdGlhbFZhbHVlXG4gICAgd2hpbGUoaSA8IHRoaXMubGVuZ3RoKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuZ2V0KGkpXG4gICAgICBhY2MgPSByZWR1Y2VyKGFjYywgdmFsdWUsIGkpXG4gICAgICBpKytcbiAgICB9XG4gICAgcmV0dXJuIGFjY1xuICB9XG5cbiAgZmluZCAoZmluZGVyKSB7XG4gICAgbGV0IGkgPSAwLCBmb3VuZCwgbGFzdFxuICAgIHdoaWxlICgoaSA8IHRoaXMubGVuZ3RoKSAmJiAhZm91bmQpIHtcbiAgICAgIGxhc3QgPSB0aGlzLmdldChpKVxuICAgICAgZm91bmQgPSBmaW5kZXIobGFzdClcbiAgICAgIGkrK1xuICAgIH1cbiAgICByZXR1cm4gZm91bmQgPyBsYXN0IDogdW5kZWZpbmVkXG4gIH1cblxuICBfaW50ZXJuYWxQb3NpdGlvbkZvciAoaW5kZXgsIG5vQ3JlYXRlKSB7XG4gICAgY29uc3QgYnl0ZVBvcyA9IHRoaXMuX2J5dGVQb3NGb3IoaW5kZXgsIG5vQ3JlYXRlKVxuICAgIGlmIChieXRlUG9zID49IHRoaXMuX2JpdEFycmF5cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICBjb25zdCBieXRlID0gdGhpcy5fYml0QXJyYXlzW2J5dGVQb3NdXG4gICAgY29uc3QgYml0UG9zID0gaW5kZXggLSBieXRlUG9zICogQklUU19QRVJfQllURVxuICAgIGNvbnN0IGV4aXN0cyA9IChieXRlICYgKDEgPDwgYml0UG9zKSkgPiAwXG4gICAgaWYgKCFleGlzdHMpIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICBjb25zdCBwcmV2aW91c1BvcENvdW50ID0gdGhpcy5fYml0QXJyYXlzLnNsaWNlKDAsIGJ5dGVQb3MpLnJlZHVjZShwb3BDb3VudFJlZHVjZSwgMClcblxuICAgIGNvbnN0IG1hc2sgPSB+KDB4ZmZmZmZmZmYgPDwgKGJpdFBvcyArIDEpKVxuICAgIGNvbnN0IGJ5dGVQb3BDb3VudCA9IHBvcENvdW50KGJ5dGUgJiBtYXNrKVxuICAgIGNvbnN0IGFycmF5UG9zID0gcHJldmlvdXNQb3BDb3VudCArIGJ5dGVQb3BDb3VudCAtIDFcbiAgICByZXR1cm4gYXJyYXlQb3NcbiAgfVxuXG4gIF9ieXRlUG9zRm9yIChpbmRleCwgbm9DcmVhdGUpIHtcbiAgICBjb25zdCBieXRlUG9zID0gTWF0aC5mbG9vcihpbmRleCAvIEJJVFNfUEVSX0JZVEUpXG4gICAgY29uc3QgdGFyZ2V0TGVuZ3RoID0gYnl0ZVBvcyArIDFcbiAgICB3aGlsZSAoIW5vQ3JlYXRlICYmIHRoaXMuX2JpdEFycmF5cy5sZW5ndGggPCB0YXJnZXRMZW5ndGgpIHtcbiAgICAgIHRoaXMuX2JpdEFycmF5cy5wdXNoKDApXG4gICAgfVxuICAgIHJldHVybiBieXRlUG9zXG4gIH1cblxuICBfc2V0Qml0IChpbmRleCkge1xuICAgIGNvbnN0IGJ5dGVQb3MgPSB0aGlzLl9ieXRlUG9zRm9yKGluZGV4LCBmYWxzZSlcbiAgICB0aGlzLl9iaXRBcnJheXNbYnl0ZVBvc10gfD0gKDEgPDwgKGluZGV4IC0gKGJ5dGVQb3MgKiBCSVRTX1BFUl9CWVRFKSkpXG4gIH1cblxuICBfdW5zZXRCaXQoaW5kZXgpIHtcbiAgICBjb25zdCBieXRlUG9zID0gdGhpcy5fYnl0ZVBvc0ZvcihpbmRleCwgZmFsc2UpXG4gICAgdGhpcy5fYml0QXJyYXlzW2J5dGVQb3NdICY9IH4oMSA8PCAoaW5kZXggLSAoYnl0ZVBvcyAqIEJJVFNfUEVSX0JZVEUpKSlcbiAgfVxuXG4gIF9zZXRJbnRlcm5hbFBvcyhwb3MsIGluZGV4LCB2YWx1ZSwgbmVlZHNTb3J0KSB7XG4gICAgY29uc3QgZGF0YSA9dGhpcy5fZGF0YVxuICAgIGNvbnN0IGVsZW0gPSBbaW5kZXgsIHZhbHVlXVxuICAgIGlmIChuZWVkc1NvcnQpIHtcbiAgICAgIHRoaXMuX3NvcnREYXRhKClcbiAgICAgIGRhdGFbcG9zXSA9IGVsZW1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbmV3IGVsZW1lbnQuIGp1c3Qgc2hvdmUgaXQgaW50byB0aGUgYXJyYXlcbiAgICAgIC8vIGJ1dCBiZSBuaWNlIGFib3V0IHdoZXJlIHdlIHNob3ZlIGl0XG4gICAgICAvLyBpbiBvcmRlciB0byBtYWtlIHNvcnRpbmcgaXQgbGF0ZXIgZWFzaWVyXG4gICAgICBpZiAoZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgaWYgKGRhdGFbZGF0YS5sZW5ndGggLSAxXVswXSA+PSBpbmRleCkge1xuICAgICAgICAgIGRhdGEucHVzaChlbGVtKVxuICAgICAgICB9IGVsc2UgaWYgKGRhdGFbMF1bMF0gPD0gaW5kZXgpIHtcbiAgICAgICAgICBkYXRhLnVuc2hpZnQoZWxlbSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCByYW5kb21JbmRleCA9IE1hdGgucm91bmQoZGF0YS5sZW5ndGggLyAyKVxuICAgICAgICAgIHRoaXMuX2RhdGEgPSBkYXRhLnNsaWNlKDAsIHJhbmRvbUluZGV4KS5jb25jYXQoZWxlbSkuY29uY2F0KGRhdGEuc2xpY2UocmFuZG9tSW5kZXgpKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9kYXRhLnB1c2goZWxlbSlcbiAgICAgIH1cbiAgICAgIHRoaXMuX2NoYW5nZWREYXRhID0gdHJ1ZVxuICAgICAgdGhpcy5fY2hhbmdlZExlbmd0aCA9IHRydWVcbiAgICB9XG4gIH1cblxuICBfdW5zZXRJbnRlcm5hbFBvcyAocG9zKSB7XG4gICAgdGhpcy5fZGF0YS5zcGxpY2UocG9zLCAxKVxuICB9XG5cbiAgX3NvcnREYXRhICgpIHtcbiAgICBpZiAodGhpcy5fY2hhbmdlZERhdGEpIHtcbiAgICAgIHRoaXMuX2RhdGEuc29ydChzb3J0SW50ZXJuYWwpXG4gICAgfVxuXG4gICAgdGhpcy5fY2hhbmdlZERhdGEgPSBmYWxzZVxuICB9XG5cbiAgYml0RmllbGQgKCkge1xuICAgIGNvbnN0IGJ5dGVzID0gW11cbiAgICBsZXQgcGVuZGluZ0JpdHNGb3JSZXN1bHRpbmdCeXRlID0gOFxuICAgIGxldCBwZW5kaW5nQml0c0Zvck5ld0J5dGUgPSAwXG4gICAgbGV0IHJlc3VsdGluZ0J5dGUgPSAwXG4gICAgbGV0IG5ld0J5dGVcbiAgICBjb25zdCBwZW5kaW5nID0gdGhpcy5fYml0QXJyYXlzLnNsaWNlKClcbiAgICB3aGlsZSAocGVuZGluZy5sZW5ndGggfHwgcGVuZGluZ0JpdHNGb3JOZXdCeXRlKSB7XG4gICAgICBpZiAocGVuZGluZ0JpdHNGb3JOZXdCeXRlID09PSAwKSB7XG4gICAgICAgIG5ld0J5dGUgPSBwZW5kaW5nLnNoaWZ0KClcbiAgICAgICAgcGVuZGluZ0JpdHNGb3JOZXdCeXRlID0gN1xuICAgICAgfVxuXG4gICAgICBjb25zdCB1c2luZ0JpdHMgPSBNYXRoLm1pbihwZW5kaW5nQml0c0Zvck5ld0J5dGUsIHBlbmRpbmdCaXRzRm9yUmVzdWx0aW5nQnl0ZSlcbiAgICAgIGNvbnN0IG1hc2sgPSB+KDBiMTExMTExMTEgPDwgdXNpbmdCaXRzKVxuICAgICAgY29uc3QgbWFza2VkID0gbmV3Qnl0ZSAmIG1hc2tcbiAgICAgIHJlc3VsdGluZ0J5dGUgfD0gbWFza2VkIDw8ICg4IC0gcGVuZGluZ0JpdHNGb3JSZXN1bHRpbmdCeXRlKVxuICAgICAgbmV3Qnl0ZSA9IG5ld0J5dGUgPj4+IHVzaW5nQml0c1xuICAgICAgcGVuZGluZ0JpdHNGb3JOZXdCeXRlIC09IHVzaW5nQml0c1xuICAgICAgcGVuZGluZ0JpdHNGb3JSZXN1bHRpbmdCeXRlIC09IHVzaW5nQml0c1xuXG4gICAgICBpZiAoIXBlbmRpbmdCaXRzRm9yUmVzdWx0aW5nQnl0ZSB8fCAoIXBlbmRpbmdCaXRzRm9yTmV3Qnl0ZSAmJiAhcGVuZGluZy5sZW5ndGgpKSB7XG4gICAgICAgIGJ5dGVzLnB1c2gocmVzdWx0aW5nQnl0ZSlcbiAgICAgICAgcmVzdWx0aW5nQnl0ZSA9IDBcbiAgICAgICAgcGVuZGluZ0JpdHNGb3JSZXN1bHRpbmdCeXRlID0gOFxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHJlbW92ZSB0cmFpbGluZyB6ZXJvZXNcbiAgICBmb3IodmFyIGkgPSBieXRlcy5sZW5ndGggLSAxOyBpID4gMDsgaS0tKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IGJ5dGVzW2ldXG4gICAgICBpZiAodmFsdWUgPT09IDApIHtcbiAgICAgICAgYnl0ZXMucG9wKClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ5dGVzXG4gIH1cblxuICBjb21wYWN0QXJyYXkgKCkge1xuICAgIHRoaXMuX3NvcnREYXRhKClcbiAgICByZXR1cm4gdGhpcy5fZGF0YS5tYXAodmFsdWVPbmx5KVxuICB9XG59XG5cbmZ1bmN0aW9uIHBvcENvdW50UmVkdWNlIChjb3VudCwgYnl0ZSkge1xuICByZXR1cm4gY291bnQgKyBwb3BDb3VudChieXRlKVxufVxuXG5mdW5jdGlvbiBwb3BDb3VudChfdikge1xuICBsZXQgdiA9IF92XG4gIHYgPSB2IC0gKCh2ID4+IDEpICYgMHg1NTU1NTU1NSkgICAgICAgICAgICAgICAgICAgIC8vIHJldXNlIGlucHV0IGFzIHRlbXBvcmFyeVxuICB2ID0gKHYgJiAweDMzMzMzMzMzKSArICgodiA+PiAyKSAmIDB4MzMzMzMzMzMpICAgICAvLyB0ZW1wXG4gIHJldHVybiAoKHYgKyAodiA+PiA0KSAmIDB4RjBGMEYwRikgKiAweDEwMTAxMDEpID4+IDI0XG59XG5cbmZ1bmN0aW9uIHNvcnRJbnRlcm5hbCAoYSwgYikge1xuICByZXR1cm4gYVswXSAtIGJbMF1cbn1cblxuZnVuY3Rpb24gdmFsdWVPbmx5IChlbGVtKSB7XG4gIHJldHVybiBlbGVtWzFdXG59IiwgIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gYmFzZShBTFBIQUJFVCwgbmFtZSkge1xuICBpZiAoQUxQSEFCRVQubGVuZ3RoID49IDI1NSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FscGhhYmV0IHRvbyBsb25nJyk7XG4gIH1cbiAgdmFyIEJBU0VfTUFQID0gbmV3IFVpbnQ4QXJyYXkoMjU2KTtcbiAgZm9yICh2YXIgaiA9IDA7IGogPCBCQVNFX01BUC5sZW5ndGg7IGorKykge1xuICAgIEJBU0VfTUFQW2pdID0gMjU1O1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgQUxQSEFCRVQubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgeCA9IEFMUEhBQkVULmNoYXJBdChpKTtcbiAgICB2YXIgeGMgPSB4LmNoYXJDb2RlQXQoMCk7XG4gICAgaWYgKEJBU0VfTUFQW3hjXSAhPT0gMjU1KSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHggKyAnIGlzIGFtYmlndW91cycpO1xuICAgIH1cbiAgICBCQVNFX01BUFt4Y10gPSBpO1xuICB9XG4gIHZhciBCQVNFID0gQUxQSEFCRVQubGVuZ3RoO1xuICB2YXIgTEVBREVSID0gQUxQSEFCRVQuY2hhckF0KDApO1xuICB2YXIgRkFDVE9SID0gTWF0aC5sb2coQkFTRSkgLyBNYXRoLmxvZygyNTYpO1xuICB2YXIgaUZBQ1RPUiA9IE1hdGgubG9nKDI1NikgLyBNYXRoLmxvZyhCQVNFKTtcbiAgZnVuY3Rpb24gZW5jb2RlKHNvdXJjZSkge1xuICAgIGlmIChzb3VyY2UgaW5zdGFuY2VvZiBVaW50OEFycmF5KTtcbiAgICBlbHNlIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoc291cmNlKSkge1xuICAgICAgc291cmNlID0gbmV3IFVpbnQ4QXJyYXkoc291cmNlLmJ1ZmZlciwgc291cmNlLmJ5dGVPZmZzZXQsIHNvdXJjZS5ieXRlTGVuZ3RoKTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoc291cmNlKSkge1xuICAgICAgc291cmNlID0gVWludDhBcnJheS5mcm9tKHNvdXJjZSk7XG4gICAgfVxuICAgIGlmICghKHNvdXJjZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBVaW50OEFycmF5Jyk7XG4gICAgfVxuICAgIGlmIChzb3VyY2UubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHZhciB6ZXJvZXMgPSAwO1xuICAgIHZhciBsZW5ndGggPSAwO1xuICAgIHZhciBwYmVnaW4gPSAwO1xuICAgIHZhciBwZW5kID0gc291cmNlLmxlbmd0aDtcbiAgICB3aGlsZSAocGJlZ2luICE9PSBwZW5kICYmIHNvdXJjZVtwYmVnaW5dID09PSAwKSB7XG4gICAgICBwYmVnaW4rKztcbiAgICAgIHplcm9lcysrO1xuICAgIH1cbiAgICB2YXIgc2l6ZSA9IChwZW5kIC0gcGJlZ2luKSAqIGlGQUNUT1IgKyAxID4+PiAwO1xuICAgIHZhciBiNTggPSBuZXcgVWludDhBcnJheShzaXplKTtcbiAgICB3aGlsZSAocGJlZ2luICE9PSBwZW5kKSB7XG4gICAgICB2YXIgY2FycnkgPSBzb3VyY2VbcGJlZ2luXTtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIGZvciAodmFyIGl0MSA9IHNpemUgLSAxOyAoY2FycnkgIT09IDAgfHwgaSA8IGxlbmd0aCkgJiYgaXQxICE9PSAtMTsgaXQxLS0sIGkrKykge1xuICAgICAgICBjYXJyeSArPSAyNTYgKiBiNThbaXQxXSA+Pj4gMDtcbiAgICAgICAgYjU4W2l0MV0gPSBjYXJyeSAlIEJBU0UgPj4+IDA7XG4gICAgICAgIGNhcnJ5ID0gY2FycnkgLyBCQVNFID4+PiAwO1xuICAgICAgfVxuICAgICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm9uLXplcm8gY2FycnknKTtcbiAgICAgIH1cbiAgICAgIGxlbmd0aCA9IGk7XG4gICAgICBwYmVnaW4rKztcbiAgICB9XG4gICAgdmFyIGl0MiA9IHNpemUgLSBsZW5ndGg7XG4gICAgd2hpbGUgKGl0MiAhPT0gc2l6ZSAmJiBiNThbaXQyXSA9PT0gMCkge1xuICAgICAgaXQyKys7XG4gICAgfVxuICAgIHZhciBzdHIgPSBMRUFERVIucmVwZWF0KHplcm9lcyk7XG4gICAgZm9yICg7IGl0MiA8IHNpemU7ICsraXQyKSB7XG4gICAgICBzdHIgKz0gQUxQSEFCRVQuY2hhckF0KGI1OFtpdDJdKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuICBmdW5jdGlvbiBkZWNvZGVVbnNhZmUoc291cmNlKSB7XG4gICAgaWYgKHR5cGVvZiBzb3VyY2UgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBTdHJpbmcnKTtcbiAgICB9XG4gICAgaWYgKHNvdXJjZS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBuZXcgVWludDhBcnJheSgpO1xuICAgIH1cbiAgICB2YXIgcHN6ID0gMDtcbiAgICBpZiAoc291cmNlW3Bzel0gPT09ICcgJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgemVyb2VzID0gMDtcbiAgICB2YXIgbGVuZ3RoID0gMDtcbiAgICB3aGlsZSAoc291cmNlW3Bzel0gPT09IExFQURFUikge1xuICAgICAgemVyb2VzKys7XG4gICAgICBwc3orKztcbiAgICB9XG4gICAgdmFyIHNpemUgPSAoc291cmNlLmxlbmd0aCAtIHBzeikgKiBGQUNUT1IgKyAxID4+PiAwO1xuICAgIHZhciBiMjU2ID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSk7XG4gICAgd2hpbGUgKHNvdXJjZVtwc3pdKSB7XG4gICAgICB2YXIgY2FycnkgPSBCQVNFX01BUFtzb3VyY2UuY2hhckNvZGVBdChwc3opXTtcbiAgICAgIGlmIChjYXJyeSA9PT0gMjU1KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBpID0gMDtcbiAgICAgIGZvciAodmFyIGl0MyA9IHNpemUgLSAxOyAoY2FycnkgIT09IDAgfHwgaSA8IGxlbmd0aCkgJiYgaXQzICE9PSAtMTsgaXQzLS0sIGkrKykge1xuICAgICAgICBjYXJyeSArPSBCQVNFICogYjI1NltpdDNdID4+PiAwO1xuICAgICAgICBiMjU2W2l0M10gPSBjYXJyeSAlIDI1NiA+Pj4gMDtcbiAgICAgICAgY2FycnkgPSBjYXJyeSAvIDI1NiA+Pj4gMDtcbiAgICAgIH1cbiAgICAgIGlmIChjYXJyeSAhPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vbi16ZXJvIGNhcnJ5Jyk7XG4gICAgICB9XG4gICAgICBsZW5ndGggPSBpO1xuICAgICAgcHN6Kys7XG4gICAgfVxuICAgIGlmIChzb3VyY2VbcHN6XSA9PT0gJyAnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBpdDQgPSBzaXplIC0gbGVuZ3RoO1xuICAgIHdoaWxlIChpdDQgIT09IHNpemUgJiYgYjI1NltpdDRdID09PSAwKSB7XG4gICAgICBpdDQrKztcbiAgICB9XG4gICAgdmFyIHZjaCA9IG5ldyBVaW50OEFycmF5KHplcm9lcyArIChzaXplIC0gaXQ0KSk7XG4gICAgdmFyIGogPSB6ZXJvZXM7XG4gICAgd2hpbGUgKGl0NCAhPT0gc2l6ZSkge1xuICAgICAgdmNoW2orK10gPSBiMjU2W2l0NCsrXTtcbiAgICB9XG4gICAgcmV0dXJuIHZjaDtcbiAgfVxuICBmdW5jdGlvbiBkZWNvZGUoc3RyaW5nKSB7XG4gICAgdmFyIGJ1ZmZlciA9IGRlY29kZVVuc2FmZShzdHJpbmcpO1xuICAgIGlmIChidWZmZXIpIHtcbiAgICAgIHJldHVybiBidWZmZXI7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgTm9uLSR7IG5hbWUgfSBjaGFyYWN0ZXJgKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGVuY29kZTogZW5jb2RlLFxuICAgIGRlY29kZVVuc2FmZTogZGVjb2RlVW5zYWZlLFxuICAgIGRlY29kZTogZGVjb2RlXG4gIH07XG59XG52YXIgc3JjID0gYmFzZTtcbnZhciBfYnJycF9fbXVsdGlmb3JtYXRzX3Njb3BlX2Jhc2VYID0gc3JjO1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9icnJwX19tdWx0aWZvcm1hdHNfc2NvcGVfYmFzZVg7XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5jb25zdCBlbXB0eSA9IG5ldyBVaW50OEFycmF5KDApO1xuY29uc3QgdG9IZXggPSBkID0+IGQucmVkdWNlKChoZXgsIGJ5dGUpID0+IGhleCArIGJ5dGUudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJyksICcnKTtcbmNvbnN0IGZyb21IZXggPSBoZXggPT4ge1xuICBjb25zdCBoZXhlcyA9IGhleC5tYXRjaCgvLi4vZyk7XG4gIHJldHVybiBoZXhlcyA/IG5ldyBVaW50OEFycmF5KGhleGVzLm1hcChiID0+IHBhcnNlSW50KGIsIDE2KSkpIDogZW1wdHk7XG59O1xuY29uc3QgZXF1YWxzID0gKGFhLCBiYikgPT4ge1xuICBpZiAoYWEgPT09IGJiKVxuICAgIHJldHVybiB0cnVlO1xuICBpZiAoYWEuYnl0ZUxlbmd0aCAhPT0gYmIuYnl0ZUxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGxldCBpaSA9IDA7IGlpIDwgYWEuYnl0ZUxlbmd0aDsgaWkrKykge1xuICAgIGlmIChhYVtpaV0gIT09IGJiW2lpXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5jb25zdCBjb2VyY2UgPSBvID0+IHtcbiAgaWYgKG8gaW5zdGFuY2VvZiBVaW50OEFycmF5ICYmIG8uY29uc3RydWN0b3IubmFtZSA9PT0gJ1VpbnQ4QXJyYXknKVxuICAgIHJldHVybiBvO1xuICBpZiAobyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKVxuICAgIHJldHVybiBuZXcgVWludDhBcnJheShvKTtcbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhvKSkge1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShvLmJ1ZmZlciwgby5ieXRlT2Zmc2V0LCBvLmJ5dGVMZW5ndGgpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcignVW5rbm93biB0eXBlLCBtdXN0IGJlIGJpbmFyeSB0eXBlJyk7XG59O1xuY29uc3QgaXNCaW5hcnkgPSBvID0+IG8gaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciB8fCBBcnJheUJ1ZmZlci5pc1ZpZXcobyk7XG5jb25zdCBmcm9tU3RyaW5nID0gc3RyID0+IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzdHIpO1xuY29uc3QgdG9TdHJpbmcgPSBiID0+IG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShiKTtcblxuZXhwb3J0cy5jb2VyY2UgPSBjb2VyY2U7XG5leHBvcnRzLmVtcHR5ID0gZW1wdHk7XG5leHBvcnRzLmVxdWFscyA9IGVxdWFscztcbmV4cG9ydHMuZnJvbUhleCA9IGZyb21IZXg7XG5leHBvcnRzLmZyb21TdHJpbmcgPSBmcm9tU3RyaW5nO1xuZXhwb3J0cy5pc0JpbmFyeSA9IGlzQmluYXJ5O1xuZXhwb3J0cy50b0hleCA9IHRvSGV4O1xuZXhwb3J0cy50b1N0cmluZyA9IHRvU3RyaW5nO1xuIiwgIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGJhc2VYJDEgPSByZXF1aXJlKCcuLi8uLi92ZW5kb3IvYmFzZS14LmpzJyk7XG52YXIgYnl0ZXMgPSByZXF1aXJlKCcuLi9ieXRlcy5qcycpO1xuXG5jbGFzcyBFbmNvZGVyIHtcbiAgY29uc3RydWN0b3IobmFtZSwgcHJlZml4LCBiYXNlRW5jb2RlKSB7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLnByZWZpeCA9IHByZWZpeDtcbiAgICB0aGlzLmJhc2VFbmNvZGUgPSBiYXNlRW5jb2RlO1xuICB9XG4gIGVuY29kZShieXRlcykge1xuICAgIGlmIChieXRlcyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgIHJldHVybiBgJHsgdGhpcy5wcmVmaXggfSR7IHRoaXMuYmFzZUVuY29kZShieXRlcykgfWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IEVycm9yKCdVbmtub3duIHR5cGUsIG11c3QgYmUgYmluYXJ5IHR5cGUnKTtcbiAgICB9XG4gIH1cbn1cbmNsYXNzIERlY29kZXIge1xuICBjb25zdHJ1Y3RvcihuYW1lLCBwcmVmaXgsIGJhc2VEZWNvZGUpIHtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMucHJlZml4ID0gcHJlZml4O1xuICAgIGlmIChwcmVmaXguY29kZVBvaW50QXQoMCkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHByZWZpeCBjaGFyYWN0ZXInKTtcbiAgICB9XG4gICAgdGhpcy5wcmVmaXhDb2RlUG9pbnQgPSBwcmVmaXguY29kZVBvaW50QXQoMCk7XG4gICAgdGhpcy5iYXNlRGVjb2RlID0gYmFzZURlY29kZTtcbiAgfVxuICBkZWNvZGUodGV4dCkge1xuICAgIGlmICh0eXBlb2YgdGV4dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmICh0ZXh0LmNvZGVQb2ludEF0KDApICE9PSB0aGlzLnByZWZpeENvZGVQb2ludCkge1xuICAgICAgICB0aHJvdyBFcnJvcihgVW5hYmxlIHRvIGRlY29kZSBtdWx0aWJhc2Ugc3RyaW5nICR7IEpTT04uc3RyaW5naWZ5KHRleHQpIH0sICR7IHRoaXMubmFtZSB9IGRlY29kZXIgb25seSBzdXBwb3J0cyBpbnB1dHMgcHJlZml4ZWQgd2l0aCAkeyB0aGlzLnByZWZpeCB9YCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5iYXNlRGVjb2RlKHRleHQuc2xpY2UodGhpcy5wcmVmaXgubGVuZ3RoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IEVycm9yKCdDYW4gb25seSBtdWx0aWJhc2UgZGVjb2RlIHN0cmluZ3MnKTtcbiAgICB9XG4gIH1cbiAgb3IoZGVjb2Rlcikge1xuICAgIHJldHVybiBvcih0aGlzLCBkZWNvZGVyKTtcbiAgfVxufVxuY2xhc3MgQ29tcG9zZWREZWNvZGVyIHtcbiAgY29uc3RydWN0b3IoZGVjb2RlcnMpIHtcbiAgICB0aGlzLmRlY29kZXJzID0gZGVjb2RlcnM7XG4gIH1cbiAgb3IoZGVjb2Rlcikge1xuICAgIHJldHVybiBvcih0aGlzLCBkZWNvZGVyKTtcbiAgfVxuICBkZWNvZGUoaW5wdXQpIHtcbiAgICBjb25zdCBwcmVmaXggPSBpbnB1dFswXTtcbiAgICBjb25zdCBkZWNvZGVyID0gdGhpcy5kZWNvZGVyc1twcmVmaXhdO1xuICAgIGlmIChkZWNvZGVyKSB7XG4gICAgICByZXR1cm4gZGVjb2Rlci5kZWNvZGUoaW5wdXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBSYW5nZUVycm9yKGBVbmFibGUgdG8gZGVjb2RlIG11bHRpYmFzZSBzdHJpbmcgJHsgSlNPTi5zdHJpbmdpZnkoaW5wdXQpIH0sIG9ubHkgaW5wdXRzIHByZWZpeGVkIHdpdGggJHsgT2JqZWN0LmtleXModGhpcy5kZWNvZGVycykgfSBhcmUgc3VwcG9ydGVkYCk7XG4gICAgfVxuICB9XG59XG5jb25zdCBvciA9IChsZWZ0LCByaWdodCkgPT4gbmV3IENvbXBvc2VkRGVjb2Rlcih7XG4gIC4uLmxlZnQuZGVjb2RlcnMgfHwgeyBbbGVmdC5wcmVmaXhdOiBsZWZ0IH0sXG4gIC4uLnJpZ2h0LmRlY29kZXJzIHx8IHsgW3JpZ2h0LnByZWZpeF06IHJpZ2h0IH1cbn0pO1xuY2xhc3MgQ29kZWMge1xuICBjb25zdHJ1Y3RvcihuYW1lLCBwcmVmaXgsIGJhc2VFbmNvZGUsIGJhc2VEZWNvZGUpIHtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMucHJlZml4ID0gcHJlZml4O1xuICAgIHRoaXMuYmFzZUVuY29kZSA9IGJhc2VFbmNvZGU7XG4gICAgdGhpcy5iYXNlRGVjb2RlID0gYmFzZURlY29kZTtcbiAgICB0aGlzLmVuY29kZXIgPSBuZXcgRW5jb2RlcihuYW1lLCBwcmVmaXgsIGJhc2VFbmNvZGUpO1xuICAgIHRoaXMuZGVjb2RlciA9IG5ldyBEZWNvZGVyKG5hbWUsIHByZWZpeCwgYmFzZURlY29kZSk7XG4gIH1cbiAgZW5jb2RlKGlucHV0KSB7XG4gICAgcmV0dXJuIHRoaXMuZW5jb2Rlci5lbmNvZGUoaW5wdXQpO1xuICB9XG4gIGRlY29kZShpbnB1dCkge1xuICAgIHJldHVybiB0aGlzLmRlY29kZXIuZGVjb2RlKGlucHV0KTtcbiAgfVxufVxuY29uc3QgZnJvbSA9ICh7bmFtZSwgcHJlZml4LCBlbmNvZGUsIGRlY29kZX0pID0+IG5ldyBDb2RlYyhuYW1lLCBwcmVmaXgsIGVuY29kZSwgZGVjb2RlKTtcbmNvbnN0IGJhc2VYID0gKHtwcmVmaXgsIG5hbWUsIGFscGhhYmV0fSkgPT4ge1xuICBjb25zdCB7ZW5jb2RlLCBkZWNvZGV9ID0gYmFzZVgkMShhbHBoYWJldCwgbmFtZSk7XG4gIHJldHVybiBmcm9tKHtcbiAgICBwcmVmaXgsXG4gICAgbmFtZSxcbiAgICBlbmNvZGUsXG4gICAgZGVjb2RlOiB0ZXh0ID0+IGJ5dGVzLmNvZXJjZShkZWNvZGUodGV4dCkpXG4gIH0pO1xufTtcbmNvbnN0IGRlY29kZSA9IChzdHJpbmcsIGFscGhhYmV0LCBiaXRzUGVyQ2hhciwgbmFtZSkgPT4ge1xuICBjb25zdCBjb2RlcyA9IHt9O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFscGhhYmV0Lmxlbmd0aDsgKytpKSB7XG4gICAgY29kZXNbYWxwaGFiZXRbaV1dID0gaTtcbiAgfVxuICBsZXQgZW5kID0gc3RyaW5nLmxlbmd0aDtcbiAgd2hpbGUgKHN0cmluZ1tlbmQgLSAxXSA9PT0gJz0nKSB7XG4gICAgLS1lbmQ7XG4gIH1cbiAgY29uc3Qgb3V0ID0gbmV3IFVpbnQ4QXJyYXkoZW5kICogYml0c1BlckNoYXIgLyA4IHwgMCk7XG4gIGxldCBiaXRzID0gMDtcbiAgbGV0IGJ1ZmZlciA9IDA7XG4gIGxldCB3cml0dGVuID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbmQ7ICsraSkge1xuICAgIGNvbnN0IHZhbHVlID0gY29kZXNbc3RyaW5nW2ldXTtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBOb24tJHsgbmFtZSB9IGNoYXJhY3RlcmApO1xuICAgIH1cbiAgICBidWZmZXIgPSBidWZmZXIgPDwgYml0c1BlckNoYXIgfCB2YWx1ZTtcbiAgICBiaXRzICs9IGJpdHNQZXJDaGFyO1xuICAgIGlmIChiaXRzID49IDgpIHtcbiAgICAgIGJpdHMgLT0gODtcbiAgICAgIG91dFt3cml0dGVuKytdID0gMjU1ICYgYnVmZmVyID4+IGJpdHM7XG4gICAgfVxuICB9XG4gIGlmIChiaXRzID49IGJpdHNQZXJDaGFyIHx8IDI1NSAmIGJ1ZmZlciA8PCA4IC0gYml0cykge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignVW5leHBlY3RlZCBlbmQgb2YgZGF0YScpO1xuICB9XG4gIHJldHVybiBvdXQ7XG59O1xuY29uc3QgZW5jb2RlID0gKGRhdGEsIGFscGhhYmV0LCBiaXRzUGVyQ2hhcikgPT4ge1xuICBjb25zdCBwYWQgPSBhbHBoYWJldFthbHBoYWJldC5sZW5ndGggLSAxXSA9PT0gJz0nO1xuICBjb25zdCBtYXNrID0gKDEgPDwgYml0c1BlckNoYXIpIC0gMTtcbiAgbGV0IG91dCA9ICcnO1xuICBsZXQgYml0cyA9IDA7XG4gIGxldCBidWZmZXIgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICBidWZmZXIgPSBidWZmZXIgPDwgOCB8IGRhdGFbaV07XG4gICAgYml0cyArPSA4O1xuICAgIHdoaWxlIChiaXRzID4gYml0c1BlckNoYXIpIHtcbiAgICAgIGJpdHMgLT0gYml0c1BlckNoYXI7XG4gICAgICBvdXQgKz0gYWxwaGFiZXRbbWFzayAmIGJ1ZmZlciA+PiBiaXRzXTtcbiAgICB9XG4gIH1cbiAgaWYgKGJpdHMpIHtcbiAgICBvdXQgKz0gYWxwaGFiZXRbbWFzayAmIGJ1ZmZlciA8PCBiaXRzUGVyQ2hhciAtIGJpdHNdO1xuICB9XG4gIGlmIChwYWQpIHtcbiAgICB3aGlsZSAob3V0Lmxlbmd0aCAqIGJpdHNQZXJDaGFyICYgNykge1xuICAgICAgb3V0ICs9ICc9JztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG91dDtcbn07XG5jb25zdCByZmM0NjQ4ID0gKHtuYW1lLCBwcmVmaXgsIGJpdHNQZXJDaGFyLCBhbHBoYWJldH0pID0+IHtcbiAgcmV0dXJuIGZyb20oe1xuICAgIHByZWZpeCxcbiAgICBuYW1lLFxuICAgIGVuY29kZShpbnB1dCkge1xuICAgICAgcmV0dXJuIGVuY29kZShpbnB1dCwgYWxwaGFiZXQsIGJpdHNQZXJDaGFyKTtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCkge1xuICAgICAgcmV0dXJuIGRlY29kZShpbnB1dCwgYWxwaGFiZXQsIGJpdHNQZXJDaGFyLCBuYW1lKTtcbiAgICB9XG4gIH0pO1xufTtcblxuZXhwb3J0cy5Db2RlYyA9IENvZGVjO1xuZXhwb3J0cy5iYXNlWCA9IGJhc2VYO1xuZXhwb3J0cy5mcm9tID0gZnJvbTtcbmV4cG9ydHMub3IgPSBvcjtcbmV4cG9ydHMucmZjNDY0OCA9IHJmYzQ2NDg7XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgYmFzZSA9IHJlcXVpcmUoJy4vYmFzZS5qcycpO1xudmFyIGJ5dGVzID0gcmVxdWlyZSgnLi4vYnl0ZXMuanMnKTtcblxuY29uc3QgaWRlbnRpdHkgPSBiYXNlLmZyb20oe1xuICBwcmVmaXg6ICdcXDAnLFxuICBuYW1lOiAnaWRlbnRpdHknLFxuICBlbmNvZGU6IGJ1ZiA9PiBieXRlcy50b1N0cmluZyhidWYpLFxuICBkZWNvZGU6IHN0ciA9PiBieXRlcy5mcm9tU3RyaW5nKHN0cilcbn0pO1xuXG5leHBvcnRzLmlkZW50aXR5ID0gaWRlbnRpdHk7XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgYmFzZSA9IHJlcXVpcmUoJy4vYmFzZS5qcycpO1xuXG5jb25zdCBiYXNlMiA9IGJhc2UucmZjNDY0OCh7XG4gIHByZWZpeDogJzAnLFxuICBuYW1lOiAnYmFzZTInLFxuICBhbHBoYWJldDogJzAxJyxcbiAgYml0c1BlckNoYXI6IDFcbn0pO1xuXG5leHBvcnRzLmJhc2UyID0gYmFzZTI7XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgYmFzZSA9IHJlcXVpcmUoJy4vYmFzZS5qcycpO1xuXG5jb25zdCBiYXNlOCA9IGJhc2UucmZjNDY0OCh7XG4gIHByZWZpeDogJzcnLFxuICBuYW1lOiAnYmFzZTgnLFxuICBhbHBoYWJldDogJzAxMjM0NTY3JyxcbiAgYml0c1BlckNoYXI6IDNcbn0pO1xuXG5leHBvcnRzLmJhc2U4ID0gYmFzZTg7XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgYmFzZSA9IHJlcXVpcmUoJy4vYmFzZS5qcycpO1xuXG5jb25zdCBiYXNlMTAgPSBiYXNlLmJhc2VYKHtcbiAgcHJlZml4OiAnOScsXG4gIG5hbWU6ICdiYXNlMTAnLFxuICBhbHBoYWJldDogJzAxMjM0NTY3ODknXG59KTtcblxuZXhwb3J0cy5iYXNlMTAgPSBiYXNlMTA7XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgYmFzZSA9IHJlcXVpcmUoJy4vYmFzZS5qcycpO1xuXG5jb25zdCBiYXNlMTYgPSBiYXNlLnJmYzQ2NDgoe1xuICBwcmVmaXg6ICdmJyxcbiAgbmFtZTogJ2Jhc2UxNicsXG4gIGFscGhhYmV0OiAnMDEyMzQ1Njc4OWFiY2RlZicsXG4gIGJpdHNQZXJDaGFyOiA0XG59KTtcbmNvbnN0IGJhc2UxNnVwcGVyID0gYmFzZS5yZmM0NjQ4KHtcbiAgcHJlZml4OiAnRicsXG4gIG5hbWU6ICdiYXNlMTZ1cHBlcicsXG4gIGFscGhhYmV0OiAnMDEyMzQ1Njc4OUFCQ0RFRicsXG4gIGJpdHNQZXJDaGFyOiA0XG59KTtcblxuZXhwb3J0cy5iYXNlMTYgPSBiYXNlMTY7XG5leHBvcnRzLmJhc2UxNnVwcGVyID0gYmFzZTE2dXBwZXI7XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgYmFzZSA9IHJlcXVpcmUoJy4vYmFzZS5qcycpO1xuXG5jb25zdCBiYXNlMzIgPSBiYXNlLnJmYzQ2NDgoe1xuICBwcmVmaXg6ICdiJyxcbiAgbmFtZTogJ2Jhc2UzMicsXG4gIGFscGhhYmV0OiAnYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoyMzQ1NjcnLFxuICBiaXRzUGVyQ2hhcjogNVxufSk7XG5jb25zdCBiYXNlMzJ1cHBlciA9IGJhc2UucmZjNDY0OCh7XG4gIHByZWZpeDogJ0InLFxuICBuYW1lOiAnYmFzZTMydXBwZXInLFxuICBhbHBoYWJldDogJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaMjM0NTY3JyxcbiAgYml0c1BlckNoYXI6IDVcbn0pO1xuY29uc3QgYmFzZTMycGFkID0gYmFzZS5yZmM0NjQ4KHtcbiAgcHJlZml4OiAnYycsXG4gIG5hbWU6ICdiYXNlMzJwYWQnLFxuICBhbHBoYWJldDogJ2FiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MjM0NTY3PScsXG4gIGJpdHNQZXJDaGFyOiA1XG59KTtcbmNvbnN0IGJhc2UzMnBhZHVwcGVyID0gYmFzZS5yZmM0NjQ4KHtcbiAgcHJlZml4OiAnQycsXG4gIG5hbWU6ICdiYXNlMzJwYWR1cHBlcicsXG4gIGFscGhhYmV0OiAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVoyMzQ1Njc9JyxcbiAgYml0c1BlckNoYXI6IDVcbn0pO1xuY29uc3QgYmFzZTMyaGV4ID0gYmFzZS5yZmM0NjQ4KHtcbiAgcHJlZml4OiAndicsXG4gIG5hbWU6ICdiYXNlMzJoZXgnLFxuICBhbHBoYWJldDogJzAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2JyxcbiAgYml0c1BlckNoYXI6IDVcbn0pO1xuY29uc3QgYmFzZTMyaGV4dXBwZXIgPSBiYXNlLnJmYzQ2NDgoe1xuICBwcmVmaXg6ICdWJyxcbiAgbmFtZTogJ2Jhc2UzMmhleHVwcGVyJyxcbiAgYWxwaGFiZXQ6ICcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVicsXG4gIGJpdHNQZXJDaGFyOiA1XG59KTtcbmNvbnN0IGJhc2UzMmhleHBhZCA9IGJhc2UucmZjNDY0OCh7XG4gIHByZWZpeDogJ3QnLFxuICBuYW1lOiAnYmFzZTMyaGV4cGFkJyxcbiAgYWxwaGFiZXQ6ICcwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dj0nLFxuICBiaXRzUGVyQ2hhcjogNVxufSk7XG5jb25zdCBiYXNlMzJoZXhwYWR1cHBlciA9IGJhc2UucmZjNDY0OCh7XG4gIHByZWZpeDogJ1QnLFxuICBuYW1lOiAnYmFzZTMyaGV4cGFkdXBwZXInLFxuICBhbHBoYWJldDogJzAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWPScsXG4gIGJpdHNQZXJDaGFyOiA1XG59KTtcbmNvbnN0IGJhc2UzMnogPSBiYXNlLnJmYzQ2NDgoe1xuICBwcmVmaXg6ICdoJyxcbiAgbmFtZTogJ2Jhc2UzMnonLFxuICBhbHBoYWJldDogJ3libmRyZmc4ZWprbWNwcXhvdDF1d2lzemEzNDVoNzY5JyxcbiAgYml0c1BlckNoYXI6IDVcbn0pO1xuXG5leHBvcnRzLmJhc2UzMiA9IGJhc2UzMjtcbmV4cG9ydHMuYmFzZTMyaGV4ID0gYmFzZTMyaGV4O1xuZXhwb3J0cy5iYXNlMzJoZXhwYWQgPSBiYXNlMzJoZXhwYWQ7XG5leHBvcnRzLmJhc2UzMmhleHBhZHVwcGVyID0gYmFzZTMyaGV4cGFkdXBwZXI7XG5leHBvcnRzLmJhc2UzMmhleHVwcGVyID0gYmFzZTMyaGV4dXBwZXI7XG5leHBvcnRzLmJhc2UzMnBhZCA9IGJhc2UzMnBhZDtcbmV4cG9ydHMuYmFzZTMycGFkdXBwZXIgPSBiYXNlMzJwYWR1cHBlcjtcbmV4cG9ydHMuYmFzZTMydXBwZXIgPSBiYXNlMzJ1cHBlcjtcbmV4cG9ydHMuYmFzZTMyeiA9IGJhc2UzMno7XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgYmFzZSA9IHJlcXVpcmUoJy4vYmFzZS5qcycpO1xuXG5jb25zdCBiYXNlMzYgPSBiYXNlLmJhc2VYKHtcbiAgcHJlZml4OiAnaycsXG4gIG5hbWU6ICdiYXNlMzYnLFxuICBhbHBoYWJldDogJzAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5eidcbn0pO1xuY29uc3QgYmFzZTM2dXBwZXIgPSBiYXNlLmJhc2VYKHtcbiAgcHJlZml4OiAnSycsXG4gIG5hbWU6ICdiYXNlMzZ1cHBlcicsXG4gIGFscGhhYmV0OiAnMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaJ1xufSk7XG5cbmV4cG9ydHMuYmFzZTM2ID0gYmFzZTM2O1xuZXhwb3J0cy5iYXNlMzZ1cHBlciA9IGJhc2UzNnVwcGVyO1xuIiwgIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGJhc2UgPSByZXF1aXJlKCcuL2Jhc2UuanMnKTtcblxuY29uc3QgYmFzZTU4YnRjID0gYmFzZS5iYXNlWCh7XG4gIG5hbWU6ICdiYXNlNThidGMnLFxuICBwcmVmaXg6ICd6JyxcbiAgYWxwaGFiZXQ6ICcxMjM0NTY3ODlBQkNERUZHSEpLTE1OUFFSU1RVVldYWVphYmNkZWZnaGlqa21ub3BxcnN0dXZ3eHl6J1xufSk7XG5jb25zdCBiYXNlNThmbGlja3IgPSBiYXNlLmJhc2VYKHtcbiAgbmFtZTogJ2Jhc2U1OGZsaWNrcicsXG4gIHByZWZpeDogJ1onLFxuICBhbHBoYWJldDogJzEyMzQ1Njc4OWFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXpBQkNERUZHSEpLTE1OUFFSU1RVVldYWVonXG59KTtcblxuZXhwb3J0cy5iYXNlNThidGMgPSBiYXNlNThidGM7XG5leHBvcnRzLmJhc2U1OGZsaWNrciA9IGJhc2U1OGZsaWNrcjtcbiIsICIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBiYXNlID0gcmVxdWlyZSgnLi9iYXNlLmpzJyk7XG5cbmNvbnN0IGJhc2U2NCA9IGJhc2UucmZjNDY0OCh7XG4gIHByZWZpeDogJ20nLFxuICBuYW1lOiAnYmFzZTY0JyxcbiAgYWxwaGFiZXQ6ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJyxcbiAgYml0c1BlckNoYXI6IDZcbn0pO1xuY29uc3QgYmFzZTY0cGFkID0gYmFzZS5yZmM0NjQ4KHtcbiAgcHJlZml4OiAnTScsXG4gIG5hbWU6ICdiYXNlNjRwYWQnLFxuICBhbHBoYWJldDogJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89JyxcbiAgYml0c1BlckNoYXI6IDZcbn0pO1xuY29uc3QgYmFzZTY0dXJsID0gYmFzZS5yZmM0NjQ4KHtcbiAgcHJlZml4OiAndScsXG4gIG5hbWU6ICdiYXNlNjR1cmwnLFxuICBhbHBoYWJldDogJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5LV8nLFxuICBiaXRzUGVyQ2hhcjogNlxufSk7XG5jb25zdCBiYXNlNjR1cmxwYWQgPSBiYXNlLnJmYzQ2NDgoe1xuICBwcmVmaXg6ICdVJyxcbiAgbmFtZTogJ2Jhc2U2NHVybHBhZCcsXG4gIGFscGhhYmV0OiAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODktXz0nLFxuICBiaXRzUGVyQ2hhcjogNlxufSk7XG5cbmV4cG9ydHMuYmFzZTY0ID0gYmFzZTY0O1xuZXhwb3J0cy5iYXNlNjRwYWQgPSBiYXNlNjRwYWQ7XG5leHBvcnRzLmJhc2U2NHVybCA9IGJhc2U2NHVybDtcbmV4cG9ydHMuYmFzZTY0dXJscGFkID0gYmFzZTY0dXJscGFkO1xuIiwgIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGJhc2UgPSByZXF1aXJlKCcuL2Jhc2UuanMnKTtcblxuY29uc3QgYWxwaGFiZXQgPSBBcnJheS5mcm9tKCdcXHVEODNEXFx1REU4MFxcdUQ4M0VcXHVERTkwXFx1MjYwNFxcdUQ4M0RcXHVERUYwXFx1RDgzQ1xcdURGMENcXHVEODNDXFx1REYxMVxcdUQ4M0NcXHVERjEyXFx1RDgzQ1xcdURGMTNcXHVEODNDXFx1REYxNFxcdUQ4M0NcXHVERjE1XFx1RDgzQ1xcdURGMTZcXHVEODNDXFx1REYxN1xcdUQ4M0NcXHVERjE4XFx1RDgzQ1xcdURGMERcXHVEODNDXFx1REYwRlxcdUQ4M0NcXHVERjBFXFx1RDgzRFxcdURDMDlcXHUyNjAwXFx1RDgzRFxcdURDQkJcXHVEODNEXFx1RERBNVxcdUQ4M0RcXHVEQ0JFXFx1RDgzRFxcdURDQkZcXHVEODNEXFx1REUwMlxcdTI3NjRcXHVEODNEXFx1REUwRFxcdUQ4M0VcXHVERDIzXFx1RDgzRFxcdURFMEFcXHVEODNEXFx1REU0RlxcdUQ4M0RcXHVEQzk1XFx1RDgzRFxcdURFMkRcXHVEODNEXFx1REUxOFxcdUQ4M0RcXHVEQzREXFx1RDgzRFxcdURFMDVcXHVEODNEXFx1REM0RlxcdUQ4M0RcXHVERTAxXFx1RDgzRFxcdUREMjVcXHVEODNFXFx1REQ3MFxcdUQ4M0RcXHVEQzk0XFx1RDgzRFxcdURDOTZcXHVEODNEXFx1REM5OVxcdUQ4M0RcXHVERTIyXFx1RDgzRVxcdUREMTRcXHVEODNEXFx1REUwNlxcdUQ4M0RcXHVERTQ0XFx1RDgzRFxcdURDQUFcXHVEODNEXFx1REUwOVxcdTI2M0FcXHVEODNEXFx1REM0Q1xcdUQ4M0VcXHVERDE3XFx1RDgzRFxcdURDOUNcXHVEODNEXFx1REUxNFxcdUQ4M0RcXHVERTBFXFx1RDgzRFxcdURFMDdcXHVEODNDXFx1REYzOVxcdUQ4M0VcXHVERDI2XFx1RDgzQ1xcdURGODlcXHVEODNEXFx1REM5RVxcdTI3MENcXHUyNzI4XFx1RDgzRVxcdUREMzdcXHVEODNEXFx1REUzMVxcdUQ4M0RcXHVERTBDXFx1RDgzQ1xcdURGMzhcXHVEODNEXFx1REU0Q1xcdUQ4M0RcXHVERTBCXFx1RDgzRFxcdURDOTdcXHVEODNEXFx1REM5QVxcdUQ4M0RcXHVERTBGXFx1RDgzRFxcdURDOUJcXHVEODNEXFx1REU0MlxcdUQ4M0RcXHVEQzkzXFx1RDgzRVxcdUREMjlcXHVEODNEXFx1REUwNFxcdUQ4M0RcXHVERTAwXFx1RDgzRFxcdUREQTRcXHVEODNEXFx1REUwM1xcdUQ4M0RcXHVEQ0FGXFx1RDgzRFxcdURFNDhcXHVEODNEXFx1REM0N1xcdUQ4M0NcXHVERkI2XFx1RDgzRFxcdURFMTJcXHVEODNFXFx1REQyRFxcdTI3NjNcXHVEODNEXFx1REUxQ1xcdUQ4M0RcXHVEQzhCXFx1RDgzRFxcdURDNDBcXHVEODNEXFx1REUyQVxcdUQ4M0RcXHVERTExXFx1RDgzRFxcdURDQTVcXHVEODNEXFx1REU0QlxcdUQ4M0RcXHVERTFFXFx1RDgzRFxcdURFMjlcXHVEODNEXFx1REUyMVxcdUQ4M0VcXHVERDJBXFx1RDgzRFxcdURDNEFcXHVEODNFXFx1REQ3M1xcdUQ4M0RcXHVERTI1XFx1RDgzRVxcdUREMjRcXHVEODNEXFx1REM0OVxcdUQ4M0RcXHVEQzgzXFx1RDgzRFxcdURFMzNcXHUyNzBCXFx1RDgzRFxcdURFMUFcXHVEODNEXFx1REUxRFxcdUQ4M0RcXHVERTM0XFx1RDgzQ1xcdURGMUZcXHVEODNEXFx1REUyQ1xcdUQ4M0RcXHVERTQzXFx1RDgzQ1xcdURGNDBcXHVEODNDXFx1REYzN1xcdUQ4M0RcXHVERTNCXFx1RDgzRFxcdURFMTNcXHUyQjUwXFx1MjcwNVxcdUQ4M0VcXHVERDdBXFx1RDgzQ1xcdURGMDhcXHVEODNEXFx1REUwOFxcdUQ4M0VcXHVERDE4XFx1RDgzRFxcdURDQTZcXHUyNzE0XFx1RDgzRFxcdURFMjNcXHVEODNDXFx1REZDM1xcdUQ4M0RcXHVEQzkwXFx1MjYzOVxcdUQ4M0NcXHVERjhBXFx1RDgzRFxcdURDOThcXHVEODNEXFx1REUyMFxcdTI2MURcXHVEODNEXFx1REUxNVxcdUQ4M0NcXHVERjNBXFx1RDgzQ1xcdURGODJcXHVEODNDXFx1REYzQlxcdUQ4M0RcXHVERTEwXFx1RDgzRFxcdUREOTVcXHVEODNEXFx1REM5RFxcdUQ4M0RcXHVERTRBXFx1RDgzRFxcdURFMzlcXHVEODNEXFx1RERFM1xcdUQ4M0RcXHVEQ0FCXFx1RDgzRFxcdURDODBcXHVEODNEXFx1REM1MVxcdUQ4M0NcXHVERkI1XFx1RDgzRVxcdUREMUVcXHVEODNEXFx1REUxQlxcdUQ4M0RcXHVERDM0XFx1RDgzRFxcdURFMjRcXHVEODNDXFx1REYzQ1xcdUQ4M0RcXHVERTJCXFx1MjZCRFxcdUQ4M0VcXHVERDE5XFx1MjYxNVxcdUQ4M0NcXHVERkM2XFx1RDgzRVxcdUREMkJcXHVEODNEXFx1REM0OFxcdUQ4M0RcXHVERTJFXFx1RDgzRFxcdURFNDZcXHVEODNDXFx1REY3QlxcdUQ4M0NcXHVERjQzXFx1RDgzRFxcdURDMzZcXHVEODNEXFx1REM4MVxcdUQ4M0RcXHVERTMyXFx1RDgzQ1xcdURGM0ZcXHVEODNFXFx1RERFMVxcdUQ4M0NcXHVERjgxXFx1MjZBMVxcdUQ4M0NcXHVERjFFXFx1RDgzQ1xcdURGODhcXHUyNzRDXFx1MjcwQVxcdUQ4M0RcXHVEQzRCXFx1RDgzRFxcdURFMzBcXHVEODNFXFx1REQyOFxcdUQ4M0RcXHVERTM2XFx1RDgzRVxcdUREMURcXHVEODNEXFx1REVCNlxcdUQ4M0RcXHVEQ0IwXFx1RDgzQ1xcdURGNTNcXHVEODNEXFx1RENBMlxcdUQ4M0VcXHVERDFGXFx1RDgzRFxcdURFNDFcXHVEODNEXFx1REVBOFxcdUQ4M0RcXHVEQ0E4XFx1RDgzRVxcdUREMkNcXHUyNzA4XFx1RDgzQ1xcdURGODBcXHVEODNDXFx1REY3QVxcdUQ4M0VcXHVERDEzXFx1RDgzRFxcdURFMTlcXHVEODNEXFx1REM5RlxcdUQ4M0NcXHVERjMxXFx1RDgzRFxcdURFMTZcXHVEODNEXFx1REM3NlxcdUQ4M0VcXHVERDc0XFx1MjVCNlxcdTI3QTFcXHUyNzUzXFx1RDgzRFxcdURDOEVcXHVEODNEXFx1RENCOFxcdTJCMDdcXHVEODNEXFx1REUyOFxcdUQ4M0NcXHVERjFBXFx1RDgzRVxcdUREOEJcXHVEODNEXFx1REUzN1xcdUQ4M0RcXHVERDdBXFx1MjZBMFxcdUQ4M0RcXHVERTQ1XFx1RDgzRFxcdURFMUZcXHVEODNEXFx1REUzNVxcdUQ4M0RcXHVEQzRFXFx1RDgzRVxcdUREMzJcXHVEODNFXFx1REQyMFxcdUQ4M0VcXHVERDI3XFx1RDgzRFxcdURDQ0NcXHVEODNEXFx1REQzNVxcdUQ4M0RcXHVEQzg1XFx1RDgzRVxcdURERDBcXHVEODNEXFx1REMzRVxcdUQ4M0NcXHVERjUyXFx1RDgzRFxcdURFMTdcXHVEODNFXFx1REQxMVxcdUQ4M0NcXHVERjBBXFx1RDgzRVxcdUREMkZcXHVEODNEXFx1REMzN1xcdTI2MEVcXHVEODNEXFx1RENBN1xcdUQ4M0RcXHVERTJGXFx1RDgzRFxcdURDODZcXHVEODNEXFx1REM0NlxcdUQ4M0NcXHVERkE0XFx1RDgzRFxcdURFNDdcXHVEODNDXFx1REY1MVxcdTI3NDRcXHVEODNDXFx1REYzNFxcdUQ4M0RcXHVEQ0EzXFx1RDgzRFxcdURDMzhcXHVEODNEXFx1REM4Q1xcdUQ4M0RcXHVEQ0NEXFx1RDgzRVxcdURENDBcXHVEODNFXFx1REQyMlxcdUQ4M0RcXHVEQzQ1XFx1RDgzRFxcdURDQTFcXHVEODNEXFx1RENBOVxcdUQ4M0RcXHVEQzUwXFx1RDgzRFxcdURDRjhcXHVEODNEXFx1REM3QlxcdUQ4M0VcXHVERDEwXFx1RDgzRVxcdUREMkVcXHVEODNDXFx1REZCQ1xcdUQ4M0VcXHVERDc1XFx1RDgzRFxcdURFQTlcXHVEODNDXFx1REY0RVxcdUQ4M0NcXHVERjRBXFx1RDgzRFxcdURDN0NcXHVEODNEXFx1REM4RFxcdUQ4M0RcXHVEQ0UzXFx1RDgzRVxcdURENDInKTtcbmNvbnN0IGFscGhhYmV0Qnl0ZXNUb0NoYXJzID0gYWxwaGFiZXQucmVkdWNlKChwLCBjLCBpKSA9PiB7XG4gIHBbaV0gPSBjO1xuICByZXR1cm4gcDtcbn0sIFtdKTtcbmNvbnN0IGFscGhhYmV0Q2hhcnNUb0J5dGVzID0gYWxwaGFiZXQucmVkdWNlKChwLCBjLCBpKSA9PiB7XG4gIHBbYy5jb2RlUG9pbnRBdCgwKV0gPSBpO1xuICByZXR1cm4gcDtcbn0sIFtdKTtcbmZ1bmN0aW9uIGVuY29kZShkYXRhKSB7XG4gIHJldHVybiBkYXRhLnJlZHVjZSgocCwgYykgPT4ge1xuICAgIHAgKz0gYWxwaGFiZXRCeXRlc1RvQ2hhcnNbY107XG4gICAgcmV0dXJuIHA7XG4gIH0sICcnKTtcbn1cbmZ1bmN0aW9uIGRlY29kZShzdHIpIHtcbiAgY29uc3QgYnl0cyA9IFtdO1xuICBmb3IgKGNvbnN0IGNoYXIgb2Ygc3RyKSB7XG4gICAgY29uc3QgYnl0ID0gYWxwaGFiZXRDaGFyc1RvQnl0ZXNbY2hhci5jb2RlUG9pbnRBdCgwKV07XG4gICAgaWYgKGJ5dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vbi1iYXNlMjU2ZW1vamkgY2hhcmFjdGVyOiAkeyBjaGFyIH1gKTtcbiAgICB9XG4gICAgYnl0cy5wdXNoKGJ5dCk7XG4gIH1cbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ5dHMpO1xufVxuY29uc3QgYmFzZTI1NmVtb2ppID0gYmFzZS5mcm9tKHtcbiAgcHJlZml4OiAnXFx1RDgzRFxcdURFODAnLFxuICBuYW1lOiAnYmFzZTI1NmVtb2ppJyxcbiAgZW5jb2RlLFxuICBkZWNvZGVcbn0pO1xuXG5leHBvcnRzLmJhc2UyNTZlbW9qaSA9IGJhc2UyNTZlbW9qaTtcbiIsICIndXNlIHN0cmljdCc7XG5cbnZhciBlbmNvZGVfMSA9IGVuY29kZTtcbnZhciBNU0IgPSAxMjgsIFJFU1QgPSAxMjcsIE1TQkFMTCA9IH5SRVNULCBJTlQgPSBNYXRoLnBvdygyLCAzMSk7XG5mdW5jdGlvbiBlbmNvZGUobnVtLCBvdXQsIG9mZnNldCkge1xuICBvdXQgPSBvdXQgfHwgW107XG4gIG9mZnNldCA9IG9mZnNldCB8fCAwO1xuICB2YXIgb2xkT2Zmc2V0ID0gb2Zmc2V0O1xuICB3aGlsZSAobnVtID49IElOVCkge1xuICAgIG91dFtvZmZzZXQrK10gPSBudW0gJiAyNTUgfCBNU0I7XG4gICAgbnVtIC89IDEyODtcbiAgfVxuICB3aGlsZSAobnVtICYgTVNCQUxMKSB7XG4gICAgb3V0W29mZnNldCsrXSA9IG51bSAmIDI1NSB8IE1TQjtcbiAgICBudW0gPj4+PSA3O1xuICB9XG4gIG91dFtvZmZzZXRdID0gbnVtIHwgMDtcbiAgZW5jb2RlLmJ5dGVzID0gb2Zmc2V0IC0gb2xkT2Zmc2V0ICsgMTtcbiAgcmV0dXJuIG91dDtcbn1cbnZhciBkZWNvZGUgPSByZWFkO1xudmFyIE1TQiQxID0gMTI4LCBSRVNUJDEgPSAxMjc7XG5mdW5jdGlvbiByZWFkKGJ1Ziwgb2Zmc2V0KSB7XG4gIHZhciByZXMgPSAwLCBvZmZzZXQgPSBvZmZzZXQgfHwgMCwgc2hpZnQgPSAwLCBjb3VudGVyID0gb2Zmc2V0LCBiLCBsID0gYnVmLmxlbmd0aDtcbiAgZG8ge1xuICAgIGlmIChjb3VudGVyID49IGwpIHtcbiAgICAgIHJlYWQuYnl0ZXMgPSAwO1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0NvdWxkIG5vdCBkZWNvZGUgdmFyaW50Jyk7XG4gICAgfVxuICAgIGIgPSBidWZbY291bnRlcisrXTtcbiAgICByZXMgKz0gc2hpZnQgPCAyOCA/IChiICYgUkVTVCQxKSA8PCBzaGlmdCA6IChiICYgUkVTVCQxKSAqIE1hdGgucG93KDIsIHNoaWZ0KTtcbiAgICBzaGlmdCArPSA3O1xuICB9IHdoaWxlIChiID49IE1TQiQxKTtcbiAgcmVhZC5ieXRlcyA9IGNvdW50ZXIgLSBvZmZzZXQ7XG4gIHJldHVybiByZXM7XG59XG52YXIgTjEgPSBNYXRoLnBvdygyLCA3KTtcbnZhciBOMiA9IE1hdGgucG93KDIsIDE0KTtcbnZhciBOMyA9IE1hdGgucG93KDIsIDIxKTtcbnZhciBONCA9IE1hdGgucG93KDIsIDI4KTtcbnZhciBONSA9IE1hdGgucG93KDIsIDM1KTtcbnZhciBONiA9IE1hdGgucG93KDIsIDQyKTtcbnZhciBONyA9IE1hdGgucG93KDIsIDQ5KTtcbnZhciBOOCA9IE1hdGgucG93KDIsIDU2KTtcbnZhciBOOSA9IE1hdGgucG93KDIsIDYzKTtcbnZhciBsZW5ndGggPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlIDwgTjEgPyAxIDogdmFsdWUgPCBOMiA/IDIgOiB2YWx1ZSA8IE4zID8gMyA6IHZhbHVlIDwgTjQgPyA0IDogdmFsdWUgPCBONSA/IDUgOiB2YWx1ZSA8IE42ID8gNiA6IHZhbHVlIDwgTjcgPyA3IDogdmFsdWUgPCBOOCA/IDggOiB2YWx1ZSA8IE45ID8gOSA6IDEwO1xufTtcbnZhciB2YXJpbnQgPSB7XG4gIGVuY29kZTogZW5jb2RlXzEsXG4gIGRlY29kZTogZGVjb2RlLFxuICBlbmNvZGluZ0xlbmd0aDogbGVuZ3RoXG59O1xudmFyIF9icnJwX3ZhcmludCA9IHZhcmludDtcbnZhciB2YXJpbnQkMSA9IF9icnJwX3ZhcmludDtcblxubW9kdWxlLmV4cG9ydHMgPSB2YXJpbnQkMTtcbiIsICIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciB2YXJpbnQkMSA9IHJlcXVpcmUoJy4uL3ZlbmRvci92YXJpbnQuanMnKTtcblxuY29uc3QgZGVjb2RlID0gKGRhdGEsIG9mZnNldCA9IDApID0+IHtcbiAgY29uc3QgY29kZSA9IHZhcmludCQxLmRlY29kZShkYXRhLCBvZmZzZXQpO1xuICByZXR1cm4gW1xuICAgIGNvZGUsXG4gICAgdmFyaW50JDEuZGVjb2RlLmJ5dGVzXG4gIF07XG59O1xuY29uc3QgZW5jb2RlVG8gPSAoaW50LCB0YXJnZXQsIG9mZnNldCA9IDApID0+IHtcbiAgdmFyaW50JDEuZW5jb2RlKGludCwgdGFyZ2V0LCBvZmZzZXQpO1xuICByZXR1cm4gdGFyZ2V0O1xufTtcbmNvbnN0IGVuY29kaW5nTGVuZ3RoID0gaW50ID0+IHtcbiAgcmV0dXJuIHZhcmludCQxLmVuY29kaW5nTGVuZ3RoKGludCk7XG59O1xuXG5leHBvcnRzLmRlY29kZSA9IGRlY29kZTtcbmV4cG9ydHMuZW5jb2RlVG8gPSBlbmNvZGVUbztcbmV4cG9ydHMuZW5jb2RpbmdMZW5ndGggPSBlbmNvZGluZ0xlbmd0aDtcbiIsICIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBieXRlcyA9IHJlcXVpcmUoJy4uL2J5dGVzLmpzJyk7XG52YXIgdmFyaW50ID0gcmVxdWlyZSgnLi4vdmFyaW50LmpzJyk7XG5cbmNvbnN0IGNyZWF0ZSA9IChjb2RlLCBkaWdlc3QpID0+IHtcbiAgY29uc3Qgc2l6ZSA9IGRpZ2VzdC5ieXRlTGVuZ3RoO1xuICBjb25zdCBzaXplT2Zmc2V0ID0gdmFyaW50LmVuY29kaW5nTGVuZ3RoKGNvZGUpO1xuICBjb25zdCBkaWdlc3RPZmZzZXQgPSBzaXplT2Zmc2V0ICsgdmFyaW50LmVuY29kaW5nTGVuZ3RoKHNpemUpO1xuICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGRpZ2VzdE9mZnNldCArIHNpemUpO1xuICB2YXJpbnQuZW5jb2RlVG8oY29kZSwgYnl0ZXMsIDApO1xuICB2YXJpbnQuZW5jb2RlVG8oc2l6ZSwgYnl0ZXMsIHNpemVPZmZzZXQpO1xuICBieXRlcy5zZXQoZGlnZXN0LCBkaWdlc3RPZmZzZXQpO1xuICByZXR1cm4gbmV3IERpZ2VzdChjb2RlLCBzaXplLCBkaWdlc3QsIGJ5dGVzKTtcbn07XG5jb25zdCBkZWNvZGUgPSBtdWx0aWhhc2ggPT4ge1xuICBjb25zdCBieXRlcyQxID0gYnl0ZXMuY29lcmNlKG11bHRpaGFzaCk7XG4gIGNvbnN0IFtjb2RlLCBzaXplT2Zmc2V0XSA9IHZhcmludC5kZWNvZGUoYnl0ZXMkMSk7XG4gIGNvbnN0IFtzaXplLCBkaWdlc3RPZmZzZXRdID0gdmFyaW50LmRlY29kZShieXRlcyQxLnN1YmFycmF5KHNpemVPZmZzZXQpKTtcbiAgY29uc3QgZGlnZXN0ID0gYnl0ZXMkMS5zdWJhcnJheShzaXplT2Zmc2V0ICsgZGlnZXN0T2Zmc2V0KTtcbiAgaWYgKGRpZ2VzdC5ieXRlTGVuZ3RoICE9PSBzaXplKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbmNvcnJlY3QgbGVuZ3RoJyk7XG4gIH1cbiAgcmV0dXJuIG5ldyBEaWdlc3QoY29kZSwgc2l6ZSwgZGlnZXN0LCBieXRlcyQxKTtcbn07XG5jb25zdCBlcXVhbHMgPSAoYSwgYikgPT4ge1xuICBpZiAoYSA9PT0gYikge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBhLmNvZGUgPT09IGIuY29kZSAmJiBhLnNpemUgPT09IGIuc2l6ZSAmJiBieXRlcy5lcXVhbHMoYS5ieXRlcywgYi5ieXRlcyk7XG4gIH1cbn07XG5jbGFzcyBEaWdlc3Qge1xuICBjb25zdHJ1Y3Rvcihjb2RlLCBzaXplLCBkaWdlc3QsIGJ5dGVzKSB7XG4gICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICB0aGlzLnNpemUgPSBzaXplO1xuICAgIHRoaXMuZGlnZXN0ID0gZGlnZXN0O1xuICAgIHRoaXMuYnl0ZXMgPSBieXRlcztcbiAgfVxufVxuXG5leHBvcnRzLkRpZ2VzdCA9IERpZ2VzdDtcbmV4cG9ydHMuY3JlYXRlID0gY3JlYXRlO1xuZXhwb3J0cy5kZWNvZGUgPSBkZWNvZGU7XG5leHBvcnRzLmVxdWFscyA9IGVxdWFscztcbiIsICIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBkaWdlc3QgPSByZXF1aXJlKCcuL2RpZ2VzdC5qcycpO1xuXG5jb25zdCBmcm9tID0gKHtuYW1lLCBjb2RlLCBlbmNvZGV9KSA9PiBuZXcgSGFzaGVyKG5hbWUsIGNvZGUsIGVuY29kZSk7XG5jbGFzcyBIYXNoZXIge1xuICBjb25zdHJ1Y3RvcihuYW1lLCBjb2RlLCBlbmNvZGUpIHtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgdGhpcy5lbmNvZGUgPSBlbmNvZGU7XG4gIH1cbiAgZGlnZXN0KGlucHV0KSB7XG4gICAgaWYgKGlucHV0IGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5lbmNvZGUoaW5wdXQpO1xuICAgICAgcmV0dXJuIHJlc3VsdCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgPyBkaWdlc3QuY3JlYXRlKHRoaXMuY29kZSwgcmVzdWx0KSA6IHJlc3VsdC50aGVuKGRpZ2VzdCQxID0+IGRpZ2VzdC5jcmVhdGUodGhpcy5jb2RlLCBkaWdlc3QkMSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBFcnJvcignVW5rbm93biB0eXBlLCBtdXN0IGJlIGJpbmFyeSB0eXBlJyk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydHMuSGFzaGVyID0gSGFzaGVyO1xuZXhwb3J0cy5mcm9tID0gZnJvbTtcbiIsICIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcbnZhciBoYXNoZXIgPSByZXF1aXJlKCcuL2hhc2hlci5qcycpO1xudmFyIGJ5dGVzID0gcmVxdWlyZSgnLi4vYnl0ZXMuanMnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BEZWZhdWx0TGVnYWN5IChlKSB7IHJldHVybiBlICYmIHR5cGVvZiBlID09PSAnb2JqZWN0JyAmJiAnZGVmYXVsdCcgaW4gZSA/IGUgOiB7ICdkZWZhdWx0JzogZSB9OyB9XG5cbnZhciBjcnlwdG9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BEZWZhdWx0TGVnYWN5KGNyeXB0byk7XG5cbmNvbnN0IHNoYTI1NiA9IGhhc2hlci5mcm9tKHtcbiAgbmFtZTogJ3NoYTItMjU2JyxcbiAgY29kZTogMTgsXG4gIGVuY29kZTogaW5wdXQgPT4gYnl0ZXMuY29lcmNlKGNyeXB0b19fZGVmYXVsdFtcImRlZmF1bHRcIl0uY3JlYXRlSGFzaCgnc2hhMjU2JykudXBkYXRlKGlucHV0KS5kaWdlc3QoKSlcbn0pO1xuY29uc3Qgc2hhNTEyID0gaGFzaGVyLmZyb20oe1xuICBuYW1lOiAnc2hhMi01MTInLFxuICBjb2RlOiAxOSxcbiAgZW5jb2RlOiBpbnB1dCA9PiBieXRlcy5jb2VyY2UoY3J5cHRvX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5jcmVhdGVIYXNoKCdzaGE1MTInKS51cGRhdGUoaW5wdXQpLmRpZ2VzdCgpKVxufSk7XG5cbmV4cG9ydHMuc2hhMjU2ID0gc2hhMjU2O1xuZXhwb3J0cy5zaGE1MTIgPSBzaGE1MTI7XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgYnl0ZXMgPSByZXF1aXJlKCcuLi9ieXRlcy5qcycpO1xudmFyIGRpZ2VzdCQxID0gcmVxdWlyZSgnLi9kaWdlc3QuanMnKTtcblxuY29uc3QgY29kZSA9IDA7XG5jb25zdCBuYW1lID0gJ2lkZW50aXR5JztcbmNvbnN0IGVuY29kZSA9IGJ5dGVzLmNvZXJjZTtcbmNvbnN0IGRpZ2VzdCA9IGlucHV0ID0+IGRpZ2VzdCQxLmNyZWF0ZShjb2RlLCBlbmNvZGUoaW5wdXQpKTtcbmNvbnN0IGlkZW50aXR5ID0ge1xuICBjb2RlLFxuICBuYW1lLFxuICBlbmNvZGUsXG4gIGRpZ2VzdFxufTtcblxuZXhwb3J0cy5pZGVudGl0eSA9IGlkZW50aXR5O1xuIiwgIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGJ5dGVzID0gcmVxdWlyZSgnLi4vYnl0ZXMuanMnKTtcblxuY29uc3QgbmFtZSA9ICdyYXcnO1xuY29uc3QgY29kZSA9IDg1O1xuY29uc3QgZW5jb2RlID0gbm9kZSA9PiBieXRlcy5jb2VyY2Uobm9kZSk7XG5jb25zdCBkZWNvZGUgPSBkYXRhID0+IGJ5dGVzLmNvZXJjZShkYXRhKTtcblxuZXhwb3J0cy5jb2RlID0gY29kZTtcbmV4cG9ydHMuZGVjb2RlID0gZGVjb2RlO1xuZXhwb3J0cy5lbmNvZGUgPSBlbmNvZGU7XG5leHBvcnRzLm5hbWUgPSBuYW1lO1xuIiwgIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuY29uc3QgdGV4dEVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbmNvbnN0IHRleHREZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG5jb25zdCBuYW1lID0gJ2pzb24nO1xuY29uc3QgY29kZSA9IDUxMjtcbmNvbnN0IGVuY29kZSA9IG5vZGUgPT4gdGV4dEVuY29kZXIuZW5jb2RlKEpTT04uc3RyaW5naWZ5KG5vZGUpKTtcbmNvbnN0IGRlY29kZSA9IGRhdGEgPT4gSlNPTi5wYXJzZSh0ZXh0RGVjb2Rlci5kZWNvZGUoZGF0YSkpO1xuXG5leHBvcnRzLmNvZGUgPSBjb2RlO1xuZXhwb3J0cy5kZWNvZGUgPSBkZWNvZGU7XG5leHBvcnRzLmVuY29kZSA9IGVuY29kZTtcbmV4cG9ydHMubmFtZSA9IG5hbWU7XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgdmFyaW50ID0gcmVxdWlyZSgnLi92YXJpbnQuanMnKTtcbnZhciBkaWdlc3QgPSByZXF1aXJlKCcuL2hhc2hlcy9kaWdlc3QuanMnKTtcbnZhciBiYXNlNTggPSByZXF1aXJlKCcuL2Jhc2VzL2Jhc2U1OC5qcycpO1xudmFyIGJhc2UzMiA9IHJlcXVpcmUoJy4vYmFzZXMvYmFzZTMyLmpzJyk7XG52YXIgYnl0ZXMgPSByZXF1aXJlKCcuL2J5dGVzLmpzJyk7XG5cbmNsYXNzIENJRCB7XG4gIGNvbnN0cnVjdG9yKHZlcnNpb24sIGNvZGUsIG11bHRpaGFzaCwgYnl0ZXMpIHtcbiAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgIHRoaXMudmVyc2lvbiA9IHZlcnNpb247XG4gICAgdGhpcy5tdWx0aWhhc2ggPSBtdWx0aWhhc2g7XG4gICAgdGhpcy5ieXRlcyA9IGJ5dGVzO1xuICAgIHRoaXMuYnl0ZU9mZnNldCA9IGJ5dGVzLmJ5dGVPZmZzZXQ7XG4gICAgdGhpcy5ieXRlTGVuZ3RoID0gYnl0ZXMuYnl0ZUxlbmd0aDtcbiAgICB0aGlzLmFzQ0lEID0gdGhpcztcbiAgICB0aGlzLl9iYXNlQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgYnl0ZU9mZnNldDogaGlkZGVuLFxuICAgICAgYnl0ZUxlbmd0aDogaGlkZGVuLFxuICAgICAgY29kZTogcmVhZG9ubHksXG4gICAgICB2ZXJzaW9uOiByZWFkb25seSxcbiAgICAgIG11bHRpaGFzaDogcmVhZG9ubHksXG4gICAgICBieXRlczogcmVhZG9ubHksXG4gICAgICBfYmFzZUNhY2hlOiBoaWRkZW4sXG4gICAgICBhc0NJRDogaGlkZGVuXG4gICAgfSk7XG4gIH1cbiAgdG9WMCgpIHtcbiAgICBzd2l0Y2ggKHRoaXMudmVyc2lvbikge1xuICAgIGNhc2UgMDoge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICAgIGNvbnN0IHtjb2RlLCBtdWx0aWhhc2h9ID0gdGhpcztcbiAgICAgICAgaWYgKGNvZGUgIT09IERBR19QQl9DT0RFKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY29udmVydCBhIG5vbiBkYWctcGIgQ0lEIHRvIENJRHYwJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG11bHRpaGFzaC5jb2RlICE9PSBTSEFfMjU2X0NPREUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IG5vbiBzaGEyLTI1NiBtdWx0aWhhc2ggQ0lEIHRvIENJRHYwJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIENJRC5jcmVhdGVWMChtdWx0aWhhc2gpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICB0b1YxKCkge1xuICAgIHN3aXRjaCAodGhpcy52ZXJzaW9uKSB7XG4gICAgY2FzZSAwOiB7XG4gICAgICAgIGNvbnN0IHtjb2RlLCBkaWdlc3Q6IGRpZ2VzdCQxfSA9IHRoaXMubXVsdGloYXNoO1xuICAgICAgICBjb25zdCBtdWx0aWhhc2ggPSBkaWdlc3QuY3JlYXRlKGNvZGUsIGRpZ2VzdCQxKTtcbiAgICAgICAgcmV0dXJuIENJRC5jcmVhdGVWMSh0aGlzLmNvZGUsIG11bHRpaGFzaCk7XG4gICAgICB9XG4gICAgY2FzZSAxOiB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYENhbiBub3QgY29udmVydCBDSUQgdmVyc2lvbiAkeyB0aGlzLnZlcnNpb24gfSB0byB2ZXJzaW9uIDAuIFRoaXMgaXMgYSBidWcgcGxlYXNlIHJlcG9ydGApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBlcXVhbHMob3RoZXIpIHtcbiAgICByZXR1cm4gb3RoZXIgJiYgdGhpcy5jb2RlID09PSBvdGhlci5jb2RlICYmIHRoaXMudmVyc2lvbiA9PT0gb3RoZXIudmVyc2lvbiAmJiBkaWdlc3QuZXF1YWxzKHRoaXMubXVsdGloYXNoLCBvdGhlci5tdWx0aWhhc2gpO1xuICB9XG4gIHRvU3RyaW5nKGJhc2UpIHtcbiAgICBjb25zdCB7Ynl0ZXMsIHZlcnNpb24sIF9iYXNlQ2FjaGV9ID0gdGhpcztcbiAgICBzd2l0Y2ggKHZlcnNpb24pIHtcbiAgICBjYXNlIDA6XG4gICAgICByZXR1cm4gdG9TdHJpbmdWMChieXRlcywgX2Jhc2VDYWNoZSwgYmFzZSB8fCBiYXNlNTguYmFzZTU4YnRjLmVuY29kZXIpO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdG9TdHJpbmdWMShieXRlcywgX2Jhc2VDYWNoZSwgYmFzZSB8fCBiYXNlMzIuYmFzZTMyLmVuY29kZXIpO1xuICAgIH1cbiAgfVxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvZGU6IHRoaXMuY29kZSxcbiAgICAgIHZlcnNpb246IHRoaXMudmVyc2lvbixcbiAgICAgIGhhc2g6IHRoaXMubXVsdGloYXNoLmJ5dGVzXG4gICAgfTtcbiAgfVxuICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG4gICAgcmV0dXJuICdDSUQnO1xuICB9XG4gIFtTeW1ib2wuZm9yKCdub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbScpXSgpIHtcbiAgICByZXR1cm4gJ0NJRCgnICsgdGhpcy50b1N0cmluZygpICsgJyknO1xuICB9XG4gIHN0YXRpYyBpc0NJRCh2YWx1ZSkge1xuICAgIGRlcHJlY2F0ZSgvXjBcXC4wLywgSVNfQ0lEX0RFUFJFQ0FUSU9OKTtcbiAgICByZXR1cm4gISEodmFsdWUgJiYgKHZhbHVlW2NpZFN5bWJvbF0gfHwgdmFsdWUuYXNDSUQgPT09IHZhbHVlKSk7XG4gIH1cbiAgZ2V0IHRvQmFzZUVuY29kZWRTdHJpbmcoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdEZXByZWNhdGVkLCB1c2UgLnRvU3RyaW5nKCknKTtcbiAgfVxuICBnZXQgY29kZWMoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdcImNvZGVjXCIgcHJvcGVydHkgaXMgZGVwcmVjYXRlZCwgdXNlIGludGVnZXIgXCJjb2RlXCIgcHJvcGVydHkgaW5zdGVhZCcpO1xuICB9XG4gIGdldCBidWZmZXIoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdEZXByZWNhdGVkIC5idWZmZXIgcHJvcGVydHksIHVzZSAuYnl0ZXMgdG8gZ2V0IFVpbnQ4QXJyYXkgaW5zdGVhZCcpO1xuICB9XG4gIGdldCBtdWx0aWJhc2VOYW1lKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignXCJtdWx0aWJhc2VOYW1lXCIgcHJvcGVydHkgaXMgZGVwcmVjYXRlZCcpO1xuICB9XG4gIGdldCBwcmVmaXgoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdcInByZWZpeFwiIHByb3BlcnR5IGlzIGRlcHJlY2F0ZWQnKTtcbiAgfVxuICBzdGF0aWMgYXNDSUQodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBDSUQpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlICE9IG51bGwgJiYgdmFsdWUuYXNDSUQgPT09IHZhbHVlKSB7XG4gICAgICBjb25zdCB7dmVyc2lvbiwgY29kZSwgbXVsdGloYXNoLCBieXRlc30gPSB2YWx1ZTtcbiAgICAgIHJldHVybiBuZXcgQ0lEKHZlcnNpb24sIGNvZGUsIG11bHRpaGFzaCwgYnl0ZXMgfHwgZW5jb2RlQ0lEKHZlcnNpb24sIGNvZGUsIG11bHRpaGFzaC5ieXRlcykpO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgIT0gbnVsbCAmJiB2YWx1ZVtjaWRTeW1ib2xdID09PSB0cnVlKSB7XG4gICAgICBjb25zdCB7dmVyc2lvbiwgbXVsdGloYXNoLCBjb2RlfSA9IHZhbHVlO1xuICAgICAgY29uc3QgZGlnZXN0JDEgPSBkaWdlc3QuZGVjb2RlKG11bHRpaGFzaCk7XG4gICAgICByZXR1cm4gQ0lELmNyZWF0ZSh2ZXJzaW9uLCBjb2RlLCBkaWdlc3QkMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgY3JlYXRlKHZlcnNpb24sIGNvZGUsIGRpZ2VzdCkge1xuICAgIGlmICh0eXBlb2YgY29kZSAhPT0gJ251bWJlcicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignU3RyaW5nIGNvZGVjcyBhcmUgbm8gbG9uZ2VyIHN1cHBvcnRlZCcpO1xuICAgIH1cbiAgICBzd2l0Y2ggKHZlcnNpb24pIHtcbiAgICBjYXNlIDA6IHtcbiAgICAgICAgaWYgKGNvZGUgIT09IERBR19QQl9DT0RFKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBWZXJzaW9uIDAgQ0lEIG11c3QgdXNlIGRhZy1wYiAoY29kZTogJHsgREFHX1BCX0NPREUgfSkgYmxvY2sgZW5jb2RpbmdgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbmV3IENJRCh2ZXJzaW9uLCBjb2RlLCBkaWdlc3QsIGRpZ2VzdC5ieXRlcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBjYXNlIDE6IHtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSBlbmNvZGVDSUQodmVyc2lvbiwgY29kZSwgZGlnZXN0LmJ5dGVzKTtcbiAgICAgICAgcmV0dXJuIG5ldyBDSUQodmVyc2lvbiwgY29kZSwgZGlnZXN0LCBieXRlcyk7XG4gICAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdmVyc2lvbicpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBzdGF0aWMgY3JlYXRlVjAoZGlnZXN0KSB7XG4gICAgcmV0dXJuIENJRC5jcmVhdGUoMCwgREFHX1BCX0NPREUsIGRpZ2VzdCk7XG4gIH1cbiAgc3RhdGljIGNyZWF0ZVYxKGNvZGUsIGRpZ2VzdCkge1xuICAgIHJldHVybiBDSUQuY3JlYXRlKDEsIGNvZGUsIGRpZ2VzdCk7XG4gIH1cbiAgc3RhdGljIGRlY29kZShieXRlcykge1xuICAgIGNvbnN0IFtjaWQsIHJlbWFpbmRlcl0gPSBDSUQuZGVjb2RlRmlyc3QoYnl0ZXMpO1xuICAgIGlmIChyZW1haW5kZXIubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luY29ycmVjdCBsZW5ndGgnKTtcbiAgICB9XG4gICAgcmV0dXJuIGNpZDtcbiAgfVxuICBzdGF0aWMgZGVjb2RlRmlyc3QoYnl0ZXMkMSkge1xuICAgIGNvbnN0IHNwZWNzID0gQ0lELmluc3BlY3RCeXRlcyhieXRlcyQxKTtcbiAgICBjb25zdCBwcmVmaXhTaXplID0gc3BlY3Muc2l6ZSAtIHNwZWNzLm11bHRpaGFzaFNpemU7XG4gICAgY29uc3QgbXVsdGloYXNoQnl0ZXMgPSBieXRlcy5jb2VyY2UoYnl0ZXMkMS5zdWJhcnJheShwcmVmaXhTaXplLCBwcmVmaXhTaXplICsgc3BlY3MubXVsdGloYXNoU2l6ZSkpO1xuICAgIGlmIChtdWx0aWhhc2hCeXRlcy5ieXRlTGVuZ3RoICE9PSBzcGVjcy5tdWx0aWhhc2hTaXplKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luY29ycmVjdCBsZW5ndGgnKTtcbiAgICB9XG4gICAgY29uc3QgZGlnZXN0Qnl0ZXMgPSBtdWx0aWhhc2hCeXRlcy5zdWJhcnJheShzcGVjcy5tdWx0aWhhc2hTaXplIC0gc3BlY3MuZGlnZXN0U2l6ZSk7XG4gICAgY29uc3QgZGlnZXN0JDEgPSBuZXcgZGlnZXN0LkRpZ2VzdChzcGVjcy5tdWx0aWhhc2hDb2RlLCBzcGVjcy5kaWdlc3RTaXplLCBkaWdlc3RCeXRlcywgbXVsdGloYXNoQnl0ZXMpO1xuICAgIGNvbnN0IGNpZCA9IHNwZWNzLnZlcnNpb24gPT09IDAgPyBDSUQuY3JlYXRlVjAoZGlnZXN0JDEpIDogQ0lELmNyZWF0ZVYxKHNwZWNzLmNvZGVjLCBkaWdlc3QkMSk7XG4gICAgcmV0dXJuIFtcbiAgICAgIGNpZCxcbiAgICAgIGJ5dGVzJDEuc3ViYXJyYXkoc3BlY3Muc2l6ZSlcbiAgICBdO1xuICB9XG4gIHN0YXRpYyBpbnNwZWN0Qnl0ZXMoaW5pdGlhbEJ5dGVzKSB7XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgY29uc3QgbmV4dCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IFtpLCBsZW5ndGhdID0gdmFyaW50LmRlY29kZShpbml0aWFsQnl0ZXMuc3ViYXJyYXkob2Zmc2V0KSk7XG4gICAgICBvZmZzZXQgKz0gbGVuZ3RoO1xuICAgICAgcmV0dXJuIGk7XG4gICAgfTtcbiAgICBsZXQgdmVyc2lvbiA9IG5leHQoKTtcbiAgICBsZXQgY29kZWMgPSBEQUdfUEJfQ09ERTtcbiAgICBpZiAodmVyc2lvbiA9PT0gMTgpIHtcbiAgICAgIHZlcnNpb24gPSAwO1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9IGVsc2UgaWYgKHZlcnNpb24gPT09IDEpIHtcbiAgICAgIGNvZGVjID0gbmV4dCgpO1xuICAgIH1cbiAgICBpZiAodmVyc2lvbiAhPT0gMCAmJiB2ZXJzaW9uICE9PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgSW52YWxpZCBDSUQgdmVyc2lvbiAkeyB2ZXJzaW9uIH1gKTtcbiAgICB9XG4gICAgY29uc3QgcHJlZml4U2l6ZSA9IG9mZnNldDtcbiAgICBjb25zdCBtdWx0aWhhc2hDb2RlID0gbmV4dCgpO1xuICAgIGNvbnN0IGRpZ2VzdFNpemUgPSBuZXh0KCk7XG4gICAgY29uc3Qgc2l6ZSA9IG9mZnNldCArIGRpZ2VzdFNpemU7XG4gICAgY29uc3QgbXVsdGloYXNoU2l6ZSA9IHNpemUgLSBwcmVmaXhTaXplO1xuICAgIHJldHVybiB7XG4gICAgICB2ZXJzaW9uLFxuICAgICAgY29kZWMsXG4gICAgICBtdWx0aWhhc2hDb2RlLFxuICAgICAgZGlnZXN0U2l6ZSxcbiAgICAgIG11bHRpaGFzaFNpemUsXG4gICAgICBzaXplXG4gICAgfTtcbiAgfVxuICBzdGF0aWMgcGFyc2Uoc291cmNlLCBiYXNlKSB7XG4gICAgY29uc3QgW3ByZWZpeCwgYnl0ZXNdID0gcGFyc2VDSUR0b0J5dGVzKHNvdXJjZSwgYmFzZSk7XG4gICAgY29uc3QgY2lkID0gQ0lELmRlY29kZShieXRlcyk7XG4gICAgY2lkLl9iYXNlQ2FjaGUuc2V0KHByZWZpeCwgc291cmNlKTtcbiAgICByZXR1cm4gY2lkO1xuICB9XG59XG5jb25zdCBwYXJzZUNJRHRvQnl0ZXMgPSAoc291cmNlLCBiYXNlKSA9PiB7XG4gIHN3aXRjaCAoc291cmNlWzBdKSB7XG4gIGNhc2UgJ1EnOiB7XG4gICAgICBjb25zdCBkZWNvZGVyID0gYmFzZSB8fCBiYXNlNTguYmFzZTU4YnRjO1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgYmFzZTU4LmJhc2U1OGJ0Yy5wcmVmaXgsXG4gICAgICAgIGRlY29kZXIuZGVjb2RlKGAkeyBiYXNlNTguYmFzZTU4YnRjLnByZWZpeCB9JHsgc291cmNlIH1gKVxuICAgICAgXTtcbiAgICB9XG4gIGNhc2UgYmFzZTU4LmJhc2U1OGJ0Yy5wcmVmaXg6IHtcbiAgICAgIGNvbnN0IGRlY29kZXIgPSBiYXNlIHx8IGJhc2U1OC5iYXNlNThidGM7XG4gICAgICByZXR1cm4gW1xuICAgICAgICBiYXNlNTguYmFzZTU4YnRjLnByZWZpeCxcbiAgICAgICAgZGVjb2Rlci5kZWNvZGUoc291cmNlKVxuICAgICAgXTtcbiAgICB9XG4gIGNhc2UgYmFzZTMyLmJhc2UzMi5wcmVmaXg6IHtcbiAgICAgIGNvbnN0IGRlY29kZXIgPSBiYXNlIHx8IGJhc2UzMi5iYXNlMzI7XG4gICAgICByZXR1cm4gW1xuICAgICAgICBiYXNlMzIuYmFzZTMyLnByZWZpeCxcbiAgICAgICAgZGVjb2Rlci5kZWNvZGUoc291cmNlKVxuICAgICAgXTtcbiAgICB9XG4gIGRlZmF1bHQ6IHtcbiAgICAgIGlmIChiYXNlID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ1RvIHBhcnNlIG5vbiBiYXNlMzIgb3IgYmFzZTU4YnRjIGVuY29kZWQgQ0lEIG11bHRpYmFzZSBkZWNvZGVyIG11c3QgYmUgcHJvdmlkZWQnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbXG4gICAgICAgIHNvdXJjZVswXSxcbiAgICAgICAgYmFzZS5kZWNvZGUoc291cmNlKVxuICAgICAgXTtcbiAgICB9XG4gIH1cbn07XG5jb25zdCB0b1N0cmluZ1YwID0gKGJ5dGVzLCBjYWNoZSwgYmFzZSkgPT4ge1xuICBjb25zdCB7cHJlZml4fSA9IGJhc2U7XG4gIGlmIChwcmVmaXggIT09IGJhc2U1OC5iYXNlNThidGMucHJlZml4KSB7XG4gICAgdGhyb3cgRXJyb3IoYENhbm5vdCBzdHJpbmcgZW5jb2RlIFYwIGluICR7IGJhc2UubmFtZSB9IGVuY29kaW5nYCk7XG4gIH1cbiAgY29uc3QgY2lkID0gY2FjaGUuZ2V0KHByZWZpeCk7XG4gIGlmIChjaWQgPT0gbnVsbCkge1xuICAgIGNvbnN0IGNpZCA9IGJhc2UuZW5jb2RlKGJ5dGVzKS5zbGljZSgxKTtcbiAgICBjYWNoZS5zZXQocHJlZml4LCBjaWQpO1xuICAgIHJldHVybiBjaWQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNpZDtcbiAgfVxufTtcbmNvbnN0IHRvU3RyaW5nVjEgPSAoYnl0ZXMsIGNhY2hlLCBiYXNlKSA9PiB7XG4gIGNvbnN0IHtwcmVmaXh9ID0gYmFzZTtcbiAgY29uc3QgY2lkID0gY2FjaGUuZ2V0KHByZWZpeCk7XG4gIGlmIChjaWQgPT0gbnVsbCkge1xuICAgIGNvbnN0IGNpZCA9IGJhc2UuZW5jb2RlKGJ5dGVzKTtcbiAgICBjYWNoZS5zZXQocHJlZml4LCBjaWQpO1xuICAgIHJldHVybiBjaWQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNpZDtcbiAgfVxufTtcbmNvbnN0IERBR19QQl9DT0RFID0gMTEyO1xuY29uc3QgU0hBXzI1Nl9DT0RFID0gMTg7XG5jb25zdCBlbmNvZGVDSUQgPSAodmVyc2lvbiwgY29kZSwgbXVsdGloYXNoKSA9PiB7XG4gIGNvbnN0IGNvZGVPZmZzZXQgPSB2YXJpbnQuZW5jb2RpbmdMZW5ndGgodmVyc2lvbik7XG4gIGNvbnN0IGhhc2hPZmZzZXQgPSBjb2RlT2Zmc2V0ICsgdmFyaW50LmVuY29kaW5nTGVuZ3RoKGNvZGUpO1xuICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGhhc2hPZmZzZXQgKyBtdWx0aWhhc2guYnl0ZUxlbmd0aCk7XG4gIHZhcmludC5lbmNvZGVUbyh2ZXJzaW9uLCBieXRlcywgMCk7XG4gIHZhcmludC5lbmNvZGVUbyhjb2RlLCBieXRlcywgY29kZU9mZnNldCk7XG4gIGJ5dGVzLnNldChtdWx0aWhhc2gsIGhhc2hPZmZzZXQpO1xuICByZXR1cm4gYnl0ZXM7XG59O1xuY29uc3QgY2lkU3ltYm9sID0gU3ltYm9sLmZvcignQGlwbGQvanMtY2lkL0NJRCcpO1xuY29uc3QgcmVhZG9ubHkgPSB7XG4gIHdyaXRhYmxlOiBmYWxzZSxcbiAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgZW51bWVyYWJsZTogdHJ1ZVxufTtcbmNvbnN0IGhpZGRlbiA9IHtcbiAgd3JpdGFibGU6IGZhbHNlLFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgY29uZmlndXJhYmxlOiBmYWxzZVxufTtcbmNvbnN0IHZlcnNpb24gPSAnMC4wLjAtZGV2JztcbmNvbnN0IGRlcHJlY2F0ZSA9IChyYW5nZSwgbWVzc2FnZSkgPT4ge1xuICBpZiAocmFuZ2UudGVzdCh2ZXJzaW9uKSkge1xuICAgIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIH1cbn07XG5jb25zdCBJU19DSURfREVQUkVDQVRJT04gPSBgQ0lELmlzQ0lEKHYpIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlLlxuRm9sbG93aW5nIGNvZGUgcGF0dGVybjpcblxuaWYgKENJRC5pc0NJRCh2YWx1ZSkpIHtcbiAgZG9Tb21ldGhpbmdXaXRoQ0lEKHZhbHVlKVxufVxuXG5JcyByZXBsYWNlZCB3aXRoOlxuXG5jb25zdCBjaWQgPSBDSUQuYXNDSUQodmFsdWUpXG5pZiAoY2lkKSB7XG4gIC8vIE1ha2Ugc3VyZSB0byB1c2UgY2lkIGluc3RlYWQgb2YgdmFsdWVcbiAgZG9Tb21ldGhpbmdXaXRoQ0lEKGNpZClcbn1cbmA7XG5cbmV4cG9ydHMuQ0lEID0gQ0lEO1xuIiwgIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGNpZCA9IHJlcXVpcmUoJy4vY2lkLmpzJyk7XG52YXIgdmFyaW50ID0gcmVxdWlyZSgnLi92YXJpbnQuanMnKTtcbnZhciBieXRlcyA9IHJlcXVpcmUoJy4vYnl0ZXMuanMnKTtcbnZhciBoYXNoZXIgPSByZXF1aXJlKCcuL2hhc2hlcy9oYXNoZXIuanMnKTtcbnZhciBkaWdlc3QgPSByZXF1aXJlKCcuL2hhc2hlcy9kaWdlc3QuanMnKTtcblxuXG5cbmV4cG9ydHMuQ0lEID0gY2lkLkNJRDtcbmV4cG9ydHMudmFyaW50ID0gdmFyaW50O1xuZXhwb3J0cy5ieXRlcyA9IGJ5dGVzO1xuZXhwb3J0cy5oYXNoZXIgPSBoYXNoZXI7XG5leHBvcnRzLmRpZ2VzdCA9IGRpZ2VzdDtcbiIsICIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBpZGVudGl0eSA9IHJlcXVpcmUoJy4vYmFzZXMvaWRlbnRpdHkuanMnKTtcbnZhciBiYXNlMiA9IHJlcXVpcmUoJy4vYmFzZXMvYmFzZTIuanMnKTtcbnZhciBiYXNlOCA9IHJlcXVpcmUoJy4vYmFzZXMvYmFzZTguanMnKTtcbnZhciBiYXNlMTAgPSByZXF1aXJlKCcuL2Jhc2VzL2Jhc2UxMC5qcycpO1xudmFyIGJhc2UxNiA9IHJlcXVpcmUoJy4vYmFzZXMvYmFzZTE2LmpzJyk7XG52YXIgYmFzZTMyID0gcmVxdWlyZSgnLi9iYXNlcy9iYXNlMzIuanMnKTtcbnZhciBiYXNlMzYgPSByZXF1aXJlKCcuL2Jhc2VzL2Jhc2UzNi5qcycpO1xudmFyIGJhc2U1OCA9IHJlcXVpcmUoJy4vYmFzZXMvYmFzZTU4LmpzJyk7XG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnLi9iYXNlcy9iYXNlNjQuanMnKTtcbnZhciBiYXNlMjU2ZW1vamkgPSByZXF1aXJlKCcuL2Jhc2VzL2Jhc2UyNTZlbW9qaS5qcycpO1xudmFyIHNoYTIgPSByZXF1aXJlKCcuL2hhc2hlcy9zaGEyLmpzJyk7XG52YXIgaWRlbnRpdHkkMSA9IHJlcXVpcmUoJy4vaGFzaGVzL2lkZW50aXR5LmpzJyk7XG52YXIgcmF3ID0gcmVxdWlyZSgnLi9jb2RlY3MvcmF3LmpzJyk7XG52YXIganNvbiA9IHJlcXVpcmUoJy4vY29kZWNzL2pzb24uanMnKTtcbnJlcXVpcmUoJy4vaW5kZXguanMnKTtcbnZhciBjaWQgPSByZXF1aXJlKCcuL2NpZC5qcycpO1xudmFyIGhhc2hlciA9IHJlcXVpcmUoJy4vaGFzaGVzL2hhc2hlci5qcycpO1xudmFyIGRpZ2VzdCA9IHJlcXVpcmUoJy4vaGFzaGVzL2RpZ2VzdC5qcycpO1xudmFyIHZhcmludCA9IHJlcXVpcmUoJy4vdmFyaW50LmpzJyk7XG52YXIgYnl0ZXMgPSByZXF1aXJlKCcuL2J5dGVzLmpzJyk7XG5cbmNvbnN0IGJhc2VzID0ge1xuICAuLi5pZGVudGl0eSxcbiAgLi4uYmFzZTIsXG4gIC4uLmJhc2U4LFxuICAuLi5iYXNlMTAsXG4gIC4uLmJhc2UxNixcbiAgLi4uYmFzZTMyLFxuICAuLi5iYXNlMzYsXG4gIC4uLmJhc2U1OCxcbiAgLi4uYmFzZTY0LFxuICAuLi5iYXNlMjU2ZW1vamlcbn07XG5jb25zdCBoYXNoZXMgPSB7XG4gIC4uLnNoYTIsXG4gIC4uLmlkZW50aXR5JDFcbn07XG5jb25zdCBjb2RlY3MgPSB7XG4gIHJhdyxcbiAganNvblxufTtcblxuZXhwb3J0cy5DSUQgPSBjaWQuQ0lEO1xuZXhwb3J0cy5oYXNoZXIgPSBoYXNoZXI7XG5leHBvcnRzLmRpZ2VzdCA9IGRpZ2VzdDtcbmV4cG9ydHMudmFyaW50ID0gdmFyaW50O1xuZXhwb3J0cy5ieXRlcyA9IGJ5dGVzO1xuZXhwb3J0cy5iYXNlcyA9IGJhc2VzO1xuZXhwb3J0cy5jb2RlY3MgPSBjb2RlY3M7XG5leHBvcnRzLmhhc2hlcyA9IGhhc2hlcztcbiIsICIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbmZ1bmN0aW9uIGFzVWludDhBcnJheShidWYpIHtcbiAgaWYgKGdsb2JhbFRoaXMuQnVmZmVyICE9IG51bGwpIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnVmLmJ1ZmZlciwgYnVmLmJ5dGVPZmZzZXQsIGJ1Zi5ieXRlTGVuZ3RoKTtcbiAgfVxuICByZXR1cm4gYnVmO1xufVxuXG5leHBvcnRzLmFzVWludDhBcnJheSA9IGFzVWludDhBcnJheTtcbiIsICIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBhc1VpbnQ4YXJyYXkgPSByZXF1aXJlKCcuL3V0aWwvYXMtdWludDhhcnJheS5qcycpO1xuXG5mdW5jdGlvbiBhbGxvYyhzaXplID0gMCkge1xuICBpZiAoZ2xvYmFsVGhpcy5CdWZmZXIgIT0gbnVsbCAmJiBnbG9iYWxUaGlzLkJ1ZmZlci5hbGxvYyAhPSBudWxsKSB7XG4gICAgcmV0dXJuIGFzVWludDhhcnJheS5hc1VpbnQ4QXJyYXkoZ2xvYmFsVGhpcy5CdWZmZXIuYWxsb2Moc2l6ZSkpO1xuICB9XG4gIHJldHVybiBuZXcgVWludDhBcnJheShzaXplKTtcbn1cbmZ1bmN0aW9uIGFsbG9jVW5zYWZlKHNpemUgPSAwKSB7XG4gIGlmIChnbG9iYWxUaGlzLkJ1ZmZlciAhPSBudWxsICYmIGdsb2JhbFRoaXMuQnVmZmVyLmFsbG9jVW5zYWZlICE9IG51bGwpIHtcbiAgICByZXR1cm4gYXNVaW50OGFycmF5LmFzVWludDhBcnJheShnbG9iYWxUaGlzLkJ1ZmZlci5hbGxvY1Vuc2FmZShzaXplKSk7XG4gIH1cbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHNpemUpO1xufVxuXG5leHBvcnRzLmFsbG9jID0gYWxsb2M7XG5leHBvcnRzLmFsbG9jVW5zYWZlID0gYWxsb2NVbnNhZmU7XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYmFzaWNzID0gcmVxdWlyZSgnbXVsdGlmb3JtYXRzL2Jhc2ljcycpO1xudmFyIGFsbG9jID0gcmVxdWlyZSgnLi4vYWxsb2MuanMnKTtcblxuZnVuY3Rpb24gY3JlYXRlQ29kZWMobmFtZSwgcHJlZml4LCBlbmNvZGUsIGRlY29kZSkge1xuICByZXR1cm4ge1xuICAgIG5hbWUsXG4gICAgcHJlZml4LFxuICAgIGVuY29kZXI6IHtcbiAgICAgIG5hbWUsXG4gICAgICBwcmVmaXgsXG4gICAgICBlbmNvZGVcbiAgICB9LFxuICAgIGRlY29kZXI6IHsgZGVjb2RlIH1cbiAgfTtcbn1cbmNvbnN0IHN0cmluZyA9IGNyZWF0ZUNvZGVjKCd1dGY4JywgJ3UnLCBidWYgPT4ge1xuICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCd1dGY4Jyk7XG4gIHJldHVybiAndScgKyBkZWNvZGVyLmRlY29kZShidWYpO1xufSwgc3RyID0+IHtcbiAgY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICByZXR1cm4gZW5jb2Rlci5lbmNvZGUoc3RyLnN1YnN0cmluZygxKSk7XG59KTtcbmNvbnN0IGFzY2lpID0gY3JlYXRlQ29kZWMoJ2FzY2lpJywgJ2EnLCBidWYgPT4ge1xuICBsZXQgc3RyaW5nID0gJ2EnO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1Zi5sZW5ndGg7IGkrKykge1xuICAgIHN0cmluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSk7XG4gIH1cbiAgcmV0dXJuIHN0cmluZztcbn0sIHN0ciA9PiB7XG4gIHN0ciA9IHN0ci5zdWJzdHJpbmcoMSk7XG4gIGNvbnN0IGJ1ZiA9IGFsbG9jLmFsbG9jVW5zYWZlKHN0ci5sZW5ndGgpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIGJ1ZltpXSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICB9XG4gIHJldHVybiBidWY7XG59KTtcbmNvbnN0IEJBU0VTID0ge1xuICB1dGY4OiBzdHJpbmcsXG4gICd1dGYtOCc6IHN0cmluZyxcbiAgaGV4OiBiYXNpY3MuYmFzZXMuYmFzZTE2LFxuICBsYXRpbjE6IGFzY2lpLFxuICBhc2NpaTogYXNjaWksXG4gIGJpbmFyeTogYXNjaWksXG4gIC4uLmJhc2ljcy5iYXNlc1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCQVNFUztcbiIsICIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBiYXNlcyA9IHJlcXVpcmUoJy4vdXRpbC9iYXNlcy5qcycpO1xudmFyIGFzVWludDhhcnJheSA9IHJlcXVpcmUoJy4vdXRpbC9hcy11aW50OGFycmF5LmpzJyk7XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcoc3RyaW5nLCBlbmNvZGluZyA9ICd1dGY4Jykge1xuICBjb25zdCBiYXNlID0gYmFzZXNbZW5jb2RpbmddO1xuICBpZiAoIWJhc2UpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGVuY29kaW5nIFwiJHsgZW5jb2RpbmcgfVwiYCk7XG4gIH1cbiAgaWYgKChlbmNvZGluZyA9PT0gJ3V0ZjgnIHx8IGVuY29kaW5nID09PSAndXRmLTgnKSAmJiBnbG9iYWxUaGlzLkJ1ZmZlciAhPSBudWxsICYmIGdsb2JhbFRoaXMuQnVmZmVyLmZyb20gIT0gbnVsbCkge1xuICAgIHJldHVybiBhc1VpbnQ4YXJyYXkuYXNVaW50OEFycmF5KGdsb2JhbFRoaXMuQnVmZmVyLmZyb20oc3RyaW5nLCAndXRmLTgnKSk7XG4gIH1cbiAgcmV0dXJuIGJhc2UuZGVjb2Rlci5kZWNvZGUoYCR7IGJhc2UucHJlZml4IH0keyBzdHJpbmcgfWApO1xufVxuXG5leHBvcnRzLmZyb21TdHJpbmcgPSBmcm9tU3RyaW5nO1xuIiwgIid1c2Ugc3RyaWN0J1xuXG4vLyBAdHMtaWdub3JlXG5jb25zdCBTcGFyc2VBcnJheSA9IHJlcXVpcmUoJ3NwYXJzZS1hcnJheScpXG5jb25zdCB7IGZyb21TdHJpbmc6IHVpbnQ4QXJyYXlGcm9tU3RyaW5nIH0gPSByZXF1aXJlKCd1aW50OGFycmF5cy9mcm9tLXN0cmluZycpXG5cbi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnLi9jb25zdW1hYmxlLWhhc2gnKS5JbmZpbml0ZUhhc2h9IEluZmluaXRlSGFzaFxuICogQHR5cGVkZWYge2ltcG9ydCgnLi4vJykuVXNlckJ1Y2tldE9wdGlvbnN9IFVzZXJCdWNrZXRPcHRpb25zXG4gKi9cblxuLyoqXG4gKiBAdGVtcGxhdGUgVlxuICogQHR5cGVkZWYge29iamVjdH0gQnVja2V0Q2hpbGQ8Vj5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBrZXlcbiAqIEBwcm9wZXJ0eSB7Vn0gdmFsdWVcbiAqIEBwcm9wZXJ0eSB7SW5maW5pdGVIYXNofSBoYXNoXG4gKi9cblxuLyoqXG4gKiBAdGVtcGxhdGUgQlxuICpcbiAqIEB0eXBlZGVmIHtvYmplY3R9IFNBPEI+XG4gKiBAcHJvcGVydHkge251bWJlcn0gbGVuZ3RoXG4gKiBAcHJvcGVydHkgeygpID0+IEJbXX0gY29tcGFjdEFycmF5XG4gKiBAcHJvcGVydHkgeyhpOiBudW1iZXIpID0+IEJ9IGdldFxuICogQHByb3BlcnR5IHsoaTogbnVtYmVyLCB2YWx1ZTogQikgPT4gdm9pZH0gc2V0XG4gKiBAcHJvcGVydHkgezxBPiAoZm46IChhY2M6IEEsIGN1cnI6IEIsIGluZGV4OiBudW1iZXIpID0+IEEsIGluaXRpYWw6IEEpID0+IEJ9IHJlZHVjZVxuICogQHByb3BlcnR5IHsoZm46IChpdGVtOiBCKSA9PiBib29sZWFuKSA9PiBCIHwgdW5kZWZpbmVkfSBmaW5kXG4gKiBAcHJvcGVydHkgeygpID0+IG51bWJlcltdfSBiaXRGaWVsZFxuICogQHByb3BlcnR5IHsoaTogbnVtYmVyKSA9PiB2b2lkfSB1bnNldFxuICovXG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBCdWNrZXRQb3NpdGlvbjxUPlxuICogQHByb3BlcnR5IHtCdWNrZXQ8VD59IGJ1Y2tldFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHBvc1xuICogQHByb3BlcnR5IHtJbmZpbml0ZUhhc2h9IGhhc2hcbiAqIEBwcm9wZXJ0eSB7QnVja2V0Q2hpbGQ8VD59IFtleGlzdGluZ0NoaWxkXVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge29iamVjdH0gQnVja2V0T3B0aW9uc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IGJpdHNcbiAqIEBwcm9wZXJ0eSB7KHZhbHVlOiBVaW50OEFycmF5IHwgSW5maW5pdGVIYXNoKSA9PiBJbmZpbml0ZUhhc2h9IGhhc2hcbiAqL1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKi9cbmNsYXNzIEJ1Y2tldCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0J1Y2tldE9wdGlvbnN9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtCdWNrZXQ8VD59IFtwYXJlbnRdXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbcG9zQXRQYXJlbnQ9MF1cbiAgICovXG4gIGNvbnN0cnVjdG9yIChvcHRpb25zLCBwYXJlbnQsIHBvc0F0UGFyZW50ID0gMCkge1xuICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zXG4gICAgdGhpcy5fcG9wQ291bnQgPSAwXG4gICAgdGhpcy5fcGFyZW50ID0gcGFyZW50XG4gICAgdGhpcy5fcG9zQXRQYXJlbnQgPSBwb3NBdFBhcmVudFxuXG4gICAgLyoqIEB0eXBlIHtTQTxCdWNrZXQ8VD4gfCBCdWNrZXRDaGlsZDxUPj59ICovXG4gICAgdGhpcy5fY2hpbGRyZW4gPSBuZXcgU3BhcnNlQXJyYXkoKVxuXG4gICAgLyoqIEB0eXBlIHtzdHJpbmcgfCBudWxsfSAqL1xuICAgIHRoaXMua2V5ID0gbnVsbFxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICogQHBhcmFtIHtUfSB2YWx1ZVxuICAgKi9cbiAgYXN5bmMgcHV0IChrZXksIHZhbHVlKSB7XG4gICAgY29uc3QgcGxhY2UgPSBhd2FpdCB0aGlzLl9maW5kTmV3QnVja2V0QW5kUG9zKGtleSlcblxuICAgIGF3YWl0IHBsYWNlLmJ1Y2tldC5fcHV0QXQocGxhY2UsIGtleSwgdmFsdWUpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgKi9cbiAgYXN5bmMgZ2V0IChrZXkpIHtcbiAgICBjb25zdCBjaGlsZCA9IGF3YWl0IHRoaXMuX2ZpbmRDaGlsZChrZXkpXG5cbiAgICBpZiAoY2hpbGQpIHtcbiAgICAgIHJldHVybiBjaGlsZC52YWx1ZVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAqL1xuICBhc3luYyBkZWwgKGtleSkge1xuICAgIGNvbnN0IHBsYWNlID0gYXdhaXQgdGhpcy5fZmluZFBsYWNlKGtleSlcbiAgICBjb25zdCBjaGlsZCA9IHBsYWNlLmJ1Y2tldC5fYXQocGxhY2UucG9zKVxuXG4gICAgaWYgKGNoaWxkICYmIGNoaWxkLmtleSA9PT0ga2V5KSB7XG4gICAgICBwbGFjZS5idWNrZXQuX2RlbEF0KHBsYWNlLnBvcylcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICovXG4gIGxlYWZDb3VudCAoKSB7XG4gICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbi5jb21wYWN0QXJyYXkoKVxuXG4gICAgcmV0dXJuIGNoaWxkcmVuLnJlZHVjZSgoYWNjLCBjaGlsZCkgPT4ge1xuICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgQnVja2V0KSB7XG4gICAgICAgIHJldHVybiBhY2MgKyBjaGlsZC5sZWFmQ291bnQoKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gYWNjICsgMVxuICAgIH0sIDApXG4gIH1cblxuICBjaGlsZHJlbkNvdW50ICgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2hpbGRyZW4ubGVuZ3RoXG4gIH1cblxuICBvbmx5Q2hpbGQgKCkge1xuICAgIHJldHVybiB0aGlzLl9jaGlsZHJlbi5nZXQoMClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7SXRlcmFibGU8QnVja2V0Q2hpbGQ8VD4+fVxuICAgKi9cbiAgKiBlYWNoTGVhZlNlcmllcyAoKSB7XG4gICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbi5jb21wYWN0QXJyYXkoKVxuXG4gICAgZm9yIChjb25zdCBjaGlsZCBvZiBjaGlsZHJlbikge1xuICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgQnVja2V0KSB7XG4gICAgICAgIHlpZWxkICogY2hpbGQuZWFjaExlYWZTZXJpZXMoKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeWllbGQgY2hpbGRcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB0aGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHRzYyByZXF1aXJlcyBhIEByZXR1cm4gYW5ub3RhdGlvbiBhcyBpdFxuICAgIC8vIGNhbid0IGRlcml2ZSBhIHJldHVybiB0eXBlIGR1ZSB0byB0aGUgcmVjdXJzaW9uLCBhbmQgZXNsaW50IHJlcXVpcmVzXG4gICAgLy8gYSByZXR1cm4gc3RhdGVtZW50IHdoZW4gdGhlcmUgaXMgYSBAcmV0dXJuIGFubm90YXRpb25cbiAgICByZXR1cm4gW11cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyh2YWx1ZTogQnVja2V0Q2hpbGQ8VD4sIGluZGV4OiBudW1iZXIpID0+IFR9IG1hcFxuICAgKiBAcGFyYW0geyhyZWR1Y2VkOiBhbnkpID0+IGFueX0gcmVkdWNlXG4gICAqL1xuICBzZXJpYWxpemUgKG1hcCwgcmVkdWNlKSB7XG4gICAgLyoqIEB0eXBlIHtUW119ICovXG4gICAgY29uc3QgYWNjID0gW11cbiAgICAvLyBzZXJpYWxpemUgdG8gYSBjdXN0b20gbm9uLXNwYXJzZSByZXByZXNlbnRhdGlvblxuICAgIHJldHVybiByZWR1Y2UodGhpcy5fY2hpbGRyZW4ucmVkdWNlKChhY2MsIGNoaWxkLCBpbmRleCkgPT4ge1xuICAgICAgaWYgKGNoaWxkKSB7XG4gICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIEJ1Y2tldCkge1xuICAgICAgICAgIGFjYy5wdXNoKGNoaWxkLnNlcmlhbGl6ZShtYXAsIHJlZHVjZSkpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWNjLnB1c2gobWFwKGNoaWxkLCBpbmRleCkpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBhY2NcbiAgICB9LCBhY2MpKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7KHZhbHVlOiBCdWNrZXRDaGlsZDxUPikgPT4gUHJvbWlzZTxUW10+fSBhc3luY01hcFxuICAgKiBAcGFyYW0geyhyZWR1Y2VkOiBhbnkpID0+IFByb21pc2U8YW55Pn0gYXN5bmNSZWR1Y2VcbiAgICovXG4gIGFzeW5jVHJhbnNmb3JtIChhc3luY01hcCwgYXN5bmNSZWR1Y2UpIHtcbiAgICByZXR1cm4gYXN5bmNUcmFuc2Zvcm1CdWNrZXQodGhpcywgYXN5bmNNYXAsIGFzeW5jUmVkdWNlKVxuICB9XG5cbiAgdG9KU09OICgpIHtcbiAgICByZXR1cm4gdGhpcy5zZXJpYWxpemUobWFwTm9kZSwgcmVkdWNlTm9kZXMpXG4gIH1cblxuICBwcmV0dHlQcmludCAoKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMudG9KU09OKCksIG51bGwsICcgICcpXG4gIH1cblxuICB0YWJsZVNpemUgKCkge1xuICAgIHJldHVybiBNYXRoLnBvdygyLCB0aGlzLl9vcHRpb25zLmJpdHMpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxCdWNrZXRDaGlsZDxUPiB8IHVuZGVmaW5lZD59XG4gICAqL1xuICBhc3luYyBfZmluZENoaWxkIChrZXkpIHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLl9maW5kUGxhY2Uoa2V5KVxuICAgIGNvbnN0IGNoaWxkID0gcmVzdWx0LmJ1Y2tldC5fYXQocmVzdWx0LnBvcylcblxuICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIEJ1Y2tldCkge1xuICAgICAgLy8gc2hvdWxkIG5vdCBiZSBwb3NzaWJsZSwgdGhpcy5fZmluZFBsYWNlIHNob3VsZCBhbHdheXNcbiAgICAgIC8vIHJldHVybiBhIGxvY2F0aW9uIGZvciBhIGNoaWxkLCBub3QgYSBidWNrZXRcbiAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICB9XG5cbiAgICBpZiAoY2hpbGQgJiYgY2hpbGQua2V5ID09PSBrZXkpIHtcbiAgICAgIHJldHVybiBjaGlsZFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IEluZmluaXRlSGFzaH0ga2V5XG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEJ1Y2tldFBvc2l0aW9uPFQ+Pn1cbiAgICovXG4gIGFzeW5jIF9maW5kUGxhY2UgKGtleSkge1xuICAgIGNvbnN0IGhhc2hWYWx1ZSA9IHRoaXMuX29wdGlvbnMuaGFzaCh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyA/IHVpbnQ4QXJyYXlGcm9tU3RyaW5nKGtleSkgOiBrZXkpXG4gICAgY29uc3QgaW5kZXggPSBhd2FpdCBoYXNoVmFsdWUudGFrZSh0aGlzLl9vcHRpb25zLmJpdHMpXG5cbiAgICBjb25zdCBjaGlsZCA9IHRoaXMuX2NoaWxkcmVuLmdldChpbmRleClcblxuICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIEJ1Y2tldCkge1xuICAgICAgcmV0dXJuIGNoaWxkLl9maW5kUGxhY2UoaGFzaFZhbHVlKVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBidWNrZXQ6IHRoaXMsXG4gICAgICBwb3M6IGluZGV4LFxuICAgICAgaGFzaDogaGFzaFZhbHVlLFxuICAgICAgZXhpc3RpbmdDaGlsZDogY2hpbGRcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmcgfCBJbmZpbml0ZUhhc2h9IGtleVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxCdWNrZXRQb3NpdGlvbjxUPj59XG4gICAqL1xuICBhc3luYyBfZmluZE5ld0J1Y2tldEFuZFBvcyAoa2V5KSB7XG4gICAgY29uc3QgcGxhY2UgPSBhd2FpdCB0aGlzLl9maW5kUGxhY2Uoa2V5KVxuXG4gICAgaWYgKHBsYWNlLmV4aXN0aW5nQ2hpbGQgJiYgcGxhY2UuZXhpc3RpbmdDaGlsZC5rZXkgIT09IGtleSkge1xuICAgICAgLy8gY29uZmxpY3RcbiAgICAgIGNvbnN0IGJ1Y2tldCA9IG5ldyBCdWNrZXQodGhpcy5fb3B0aW9ucywgcGxhY2UuYnVja2V0LCBwbGFjZS5wb3MpXG4gICAgICBwbGFjZS5idWNrZXQuX3B1dE9iamVjdEF0KHBsYWNlLnBvcywgYnVja2V0KVxuXG4gICAgICAvLyBwdXQgdGhlIHByZXZpb3VzIHZhbHVlXG4gICAgICBjb25zdCBuZXdQbGFjZSA9IGF3YWl0IGJ1Y2tldC5fZmluZFBsYWNlKHBsYWNlLmV4aXN0aW5nQ2hpbGQuaGFzaClcbiAgICAgIG5ld1BsYWNlLmJ1Y2tldC5fcHV0QXQobmV3UGxhY2UsIHBsYWNlLmV4aXN0aW5nQ2hpbGQua2V5LCBwbGFjZS5leGlzdGluZ0NoaWxkLnZhbHVlKVxuXG4gICAgICByZXR1cm4gYnVja2V0Ll9maW5kTmV3QnVja2V0QW5kUG9zKHBsYWNlLmhhc2gpXG4gICAgfVxuXG4gICAgLy8gbm8gY29uZmxpY3QsIHdlIGZvdW5kIHRoZSBwbGFjZVxuICAgIHJldHVybiBwbGFjZVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QnVja2V0UG9zaXRpb248VD59IHBsYWNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICogQHBhcmFtIHtUfSB2YWx1ZVxuICAgKi9cbiAgX3B1dEF0IChwbGFjZSwga2V5LCB2YWx1ZSkge1xuICAgIHRoaXMuX3B1dE9iamVjdEF0KHBsYWNlLnBvcywge1xuICAgICAga2V5OiBrZXksXG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBoYXNoOiBwbGFjZS5oYXNoXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gcG9zXG4gICAqIEBwYXJhbSB7QnVja2V0PFQ+IHwgQnVja2V0Q2hpbGQ8VD59IG9iamVjdFxuICAgKi9cbiAgX3B1dE9iamVjdEF0IChwb3MsIG9iamVjdCkge1xuICAgIGlmICghdGhpcy5fY2hpbGRyZW4uZ2V0KHBvcykpIHtcbiAgICAgIHRoaXMuX3BvcENvdW50KytcbiAgICB9XG4gICAgdGhpcy5fY2hpbGRyZW4uc2V0KHBvcywgb2JqZWN0KVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwb3NcbiAgICovXG4gIF9kZWxBdCAocG9zKSB7XG4gICAgaWYgKHBvcyA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwb3NpdGlvbicpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2NoaWxkcmVuLmdldChwb3MpKSB7XG4gICAgICB0aGlzLl9wb3BDb3VudC0tXG4gICAgfVxuICAgIHRoaXMuX2NoaWxkcmVuLnVuc2V0KHBvcylcbiAgICB0aGlzLl9sZXZlbCgpXG4gIH1cblxuICBfbGV2ZWwgKCkge1xuICAgIGlmICh0aGlzLl9wYXJlbnQgJiYgdGhpcy5fcG9wQ291bnQgPD0gMSkge1xuICAgICAgaWYgKHRoaXMuX3BvcENvdW50ID09PSAxKSB7XG4gICAgICAgIC8vIHJlbW92ZSBteXNlbGYgZnJvbSBwYXJlbnQsIHJlcGxhY2luZyBtZSB3aXRoIG15IG9ubHkgY2hpbGRcbiAgICAgICAgY29uc3Qgb25seUNoaWxkID0gdGhpcy5fY2hpbGRyZW4uZmluZChleGlzdHMpXG5cbiAgICAgICAgaWYgKG9ubHlDaGlsZCAmJiAhKG9ubHlDaGlsZCBpbnN0YW5jZW9mIEJ1Y2tldCkpIHtcbiAgICAgICAgICBjb25zdCBoYXNoID0gb25seUNoaWxkLmhhc2hcbiAgICAgICAgICBoYXNoLnVudGFrZSh0aGlzLl9vcHRpb25zLmJpdHMpXG4gICAgICAgICAgY29uc3QgcGxhY2UgPSB7XG4gICAgICAgICAgICBwb3M6IHRoaXMuX3Bvc0F0UGFyZW50LFxuICAgICAgICAgICAgaGFzaDogaGFzaCxcbiAgICAgICAgICAgIGJ1Y2tldDogdGhpcy5fcGFyZW50XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX3BhcmVudC5fcHV0QXQocGxhY2UsIG9ubHlDaGlsZC5rZXksIG9ubHlDaGlsZC52YWx1ZSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fcGFyZW50Ll9kZWxBdCh0aGlzLl9wb3NBdFBhcmVudClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAqIEByZXR1cm5zIHtCdWNrZXRDaGlsZDxUPiB8IEJ1Y2tldDxUPiB8IHVuZGVmaW5lZH1cbiAgICovXG4gIF9hdCAoaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2hpbGRyZW4uZ2V0KGluZGV4KVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHthbnl9IG9cbiAqL1xuZnVuY3Rpb24gZXhpc3RzIChvKSB7XG4gIHJldHVybiBCb29sZWFuKG8pXG59XG5cbi8qKlxuICpcbiAqIEBwYXJhbSB7Kn0gbm9kZVxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gKi9cbmZ1bmN0aW9uIG1hcE5vZGUgKG5vZGUsIGluZGV4KSB7XG4gIHJldHVybiBub2RlLmtleVxufVxuXG4vKipcbiAqIEBwYXJhbSB7Kn0gbm9kZXNcbiAqL1xuZnVuY3Rpb24gcmVkdWNlTm9kZXMgKG5vZGVzKSB7XG4gIHJldHVybiBub2Rlc1xufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKlxuICogQHBhcmFtIHtCdWNrZXQ8VD59IGJ1Y2tldFxuICogQHBhcmFtIHsodmFsdWU6IEJ1Y2tldENoaWxkPFQ+KSA9PiBQcm9taXNlPFRbXT59IGFzeW5jTWFwXG4gKiBAcGFyYW0geyhyZWR1Y2VkOiBhbnkpID0+IFByb21pc2U8YW55Pn0gYXN5bmNSZWR1Y2VcbiAqL1xuYXN5bmMgZnVuY3Rpb24gYXN5bmNUcmFuc2Zvcm1CdWNrZXQgKGJ1Y2tldCwgYXN5bmNNYXAsIGFzeW5jUmVkdWNlKSB7XG4gIGNvbnN0IG91dHB1dCA9IFtdXG5cbiAgZm9yIChjb25zdCBjaGlsZCBvZiBidWNrZXQuX2NoaWxkcmVuLmNvbXBhY3RBcnJheSgpKSB7XG4gICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgQnVja2V0KSB7XG4gICAgICBhd2FpdCBhc3luY1RyYW5zZm9ybUJ1Y2tldChjaGlsZCwgYXN5bmNNYXAsIGFzeW5jUmVkdWNlKVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBtYXBwZWRDaGlsZHJlbiA9IGF3YWl0IGFzeW5jTWFwKGNoaWxkKVxuXG4gICAgICBvdXRwdXQucHVzaCh7XG4gICAgICAgIGJpdEZpZWxkOiBidWNrZXQuX2NoaWxkcmVuLmJpdEZpZWxkKCksXG4gICAgICAgIGNoaWxkcmVuOiBtYXBwZWRDaGlsZHJlblxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYXN5bmNSZWR1Y2Uob3V0cHV0KVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEJ1Y2tldFxuIiwgIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBTVEFSVF9NQVNLUyA9IFtcbiAgMGIxMTExMTExMSxcbiAgMGIxMTExMTExMCxcbiAgMGIxMTExMTEwMCxcbiAgMGIxMTExMTAwMCxcbiAgMGIxMTExMDAwMCxcbiAgMGIxMTEwMDAwMCxcbiAgMGIxMTAwMDAwMCxcbiAgMGIxMDAwMDAwMFxuXVxuXG5jb25zdCBTVE9QX01BU0tTID0gW1xuICAwYjAwMDAwMDAxLFxuICAwYjAwMDAwMDExLFxuICAwYjAwMDAwMTExLFxuICAwYjAwMDAxMTExLFxuICAwYjAwMDExMTExLFxuICAwYjAwMTExMTExLFxuICAwYjAxMTExMTExLFxuICAwYjExMTExMTExXG5dXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgQ29uc3VtYWJsZUJ1ZmZlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHZhbHVlXG4gICAqL1xuICBjb25zdHJ1Y3RvciAodmFsdWUpIHtcbiAgICB0aGlzLl92YWx1ZSA9IHZhbHVlXG4gICAgdGhpcy5fY3VycmVudEJ5dGVQb3MgPSB2YWx1ZS5sZW5ndGggLSAxXG4gICAgdGhpcy5fY3VycmVudEJpdFBvcyA9IDdcbiAgfVxuXG4gIGF2YWlsYWJsZUJpdHMgKCkge1xuICAgIHJldHVybiB0aGlzLl9jdXJyZW50Qml0UG9zICsgMSArIHRoaXMuX2N1cnJlbnRCeXRlUG9zICogOFxuICB9XG5cbiAgdG90YWxCaXRzICgpIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsdWUubGVuZ3RoICogOFxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRzXG4gICAqL1xuICB0YWtlIChiaXRzKSB7XG4gICAgbGV0IHBlbmRpbmdCaXRzID0gYml0c1xuICAgIGxldCByZXN1bHQgPSAwXG4gICAgd2hpbGUgKHBlbmRpbmdCaXRzICYmIHRoaXMuX2hhdmVCaXRzKCkpIHtcbiAgICAgIGNvbnN0IGJ5dGUgPSB0aGlzLl92YWx1ZVt0aGlzLl9jdXJyZW50Qnl0ZVBvc11cbiAgICAgIGNvbnN0IGF2YWlsYWJsZUJpdHMgPSB0aGlzLl9jdXJyZW50Qml0UG9zICsgMVxuICAgICAgY29uc3QgdGFraW5nID0gTWF0aC5taW4oYXZhaWxhYmxlQml0cywgcGVuZGluZ0JpdHMpXG4gICAgICBjb25zdCB2YWx1ZSA9IGJ5dGVCaXRzVG9JbnQoYnl0ZSwgYXZhaWxhYmxlQml0cyAtIHRha2luZywgdGFraW5nKVxuICAgICAgcmVzdWx0ID0gKHJlc3VsdCA8PCB0YWtpbmcpICsgdmFsdWVcblxuICAgICAgcGVuZGluZ0JpdHMgLT0gdGFraW5nXG5cbiAgICAgIHRoaXMuX2N1cnJlbnRCaXRQb3MgLT0gdGFraW5nXG4gICAgICBpZiAodGhpcy5fY3VycmVudEJpdFBvcyA8IDApIHtcbiAgICAgICAgdGhpcy5fY3VycmVudEJpdFBvcyA9IDdcbiAgICAgICAgdGhpcy5fY3VycmVudEJ5dGVQb3MtLVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gYml0c1xuICAgKi9cbiAgdW50YWtlIChiaXRzKSB7XG4gICAgdGhpcy5fY3VycmVudEJpdFBvcyArPSBiaXRzXG4gICAgd2hpbGUgKHRoaXMuX2N1cnJlbnRCaXRQb3MgPiA3KSB7XG4gICAgICB0aGlzLl9jdXJyZW50Qml0UG9zIC09IDhcbiAgICAgIHRoaXMuX2N1cnJlbnRCeXRlUG9zICs9IDFcbiAgICB9XG4gIH1cblxuICBfaGF2ZUJpdHMgKCkge1xuICAgIHJldHVybiB0aGlzLl9jdXJyZW50Qnl0ZVBvcyA+PSAwXG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gYnl0ZVxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0XG4gKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoXG4gKi9cbmZ1bmN0aW9uIGJ5dGVCaXRzVG9JbnQgKGJ5dGUsIHN0YXJ0LCBsZW5ndGgpIHtcbiAgY29uc3QgbWFzayA9IG1hc2tGb3Ioc3RhcnQsIGxlbmd0aClcbiAgcmV0dXJuIChieXRlICYgbWFzaykgPj4+IHN0YXJ0XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0XG4gKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoXG4gKi9cbmZ1bmN0aW9uIG1hc2tGb3IgKHN0YXJ0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIFNUQVJUX01BU0tTW3N0YXJ0XSAmIFNUT1BfTUFTS1NbTWF0aC5taW4obGVuZ3RoICsgc3RhcnQgLSAxLCA3KV1cbn1cbiIsICIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBhbGxvYyA9IHJlcXVpcmUoJy4vYWxsb2MuanMnKTtcbnZhciBhc1VpbnQ4YXJyYXkgPSByZXF1aXJlKCcuL3V0aWwvYXMtdWludDhhcnJheS5qcycpO1xuXG5mdW5jdGlvbiBjb25jYXQoYXJyYXlzLCBsZW5ndGgpIHtcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSBhcnJheXMucmVkdWNlKChhY2MsIGN1cnIpID0+IGFjYyArIGN1cnIubGVuZ3RoLCAwKTtcbiAgfVxuICBjb25zdCBvdXRwdXQgPSBhbGxvYy5hbGxvY1Vuc2FmZShsZW5ndGgpO1xuICBsZXQgb2Zmc2V0ID0gMDtcbiAgZm9yIChjb25zdCBhcnIgb2YgYXJyYXlzKSB7XG4gICAgb3V0cHV0LnNldChhcnIsIG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IGFyci5sZW5ndGg7XG4gIH1cbiAgcmV0dXJuIGFzVWludDhhcnJheS5hc1VpbnQ4QXJyYXkob3V0cHV0KTtcbn1cblxuZXhwb3J0cy5jb25jYXQgPSBjb25jYXQ7XG4iLCAiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IENvbnN1bWFibGVCdWZmZXIgPSByZXF1aXJlKCcuL2NvbnN1bWFibGUtYnVmZmVyJylcbmNvbnN0IHsgY29uY2F0OiB1aW50OEFycmF5Q29uY2F0IH0gPSByZXF1aXJlKCd1aW50OGFycmF5cy9jb25jYXQnKVxuXG4vKipcbiAqIEBwYXJhbSB7KHZhbHVlOiBVaW50OEFycmF5KSA9PiBQcm9taXNlPFVpbnQ4QXJyYXk+fSBoYXNoRm5cbiAqL1xuZnVuY3Rpb24gd3JhcEhhc2ggKGhhc2hGbikge1xuICAvKipcbiAgICogQHBhcmFtIHtJbmZpbml0ZUhhc2ggfCBVaW50OEFycmF5fSB2YWx1ZVxuICAgKi9cbiAgZnVuY3Rpb24gaGFzaGluZyAodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBJbmZpbml0ZUhhc2gpIHtcbiAgICAgIC8vIGFscmVhZHkgYSBoYXNoLiByZXR1cm4gaXRcbiAgICAgIHJldHVybiB2YWx1ZVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IEluZmluaXRlSGFzaCh2YWx1ZSwgaGFzaEZuKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBoYXNoaW5nXG59XG5cbmNsYXNzIEluZmluaXRlSGFzaCB7XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHZhbHVlXG4gICAqIEBwYXJhbSB7KHZhbHVlOiBVaW50OEFycmF5KSA9PiBQcm9taXNlPFVpbnQ4QXJyYXk+fSBoYXNoRm5cbiAgICovXG4gIGNvbnN0cnVjdG9yICh2YWx1ZSwgaGFzaEZuKSB7XG4gICAgaWYgKCEodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW4gb25seSBoYXNoIFVpbnQ4QXJyYXlzJylcbiAgICB9XG5cbiAgICB0aGlzLl92YWx1ZSA9IHZhbHVlXG4gICAgdGhpcy5faGFzaEZuID0gaGFzaEZuXG4gICAgdGhpcy5fZGVwdGggPSAtMVxuICAgIHRoaXMuX2F2YWlsYWJsZUJpdHMgPSAwXG4gICAgdGhpcy5fY3VycmVudEJ1ZmZlckluZGV4ID0gMFxuXG4gICAgLyoqIEB0eXBlIHtDb25zdW1hYmxlQnVmZmVyW119ICovXG4gICAgdGhpcy5fYnVmZmVycyA9IFtdXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IGJpdHNcbiAgICovXG4gIGFzeW5jIHRha2UgKGJpdHMpIHtcbiAgICBsZXQgcGVuZGluZ0JpdHMgPSBiaXRzXG5cbiAgICB3aGlsZSAodGhpcy5fYXZhaWxhYmxlQml0cyA8IHBlbmRpbmdCaXRzKSB7XG4gICAgICBhd2FpdCB0aGlzLl9wcm9kdWNlTW9yZUJpdHMoKVxuICAgIH1cblxuICAgIGxldCByZXN1bHQgPSAwXG5cbiAgICB3aGlsZSAocGVuZGluZ0JpdHMgPiAwKSB7XG4gICAgICBjb25zdCBoYXNoID0gdGhpcy5fYnVmZmVyc1t0aGlzLl9jdXJyZW50QnVmZmVySW5kZXhdXG4gICAgICBjb25zdCBhdmFpbGFibGUgPSBNYXRoLm1pbihoYXNoLmF2YWlsYWJsZUJpdHMoKSwgcGVuZGluZ0JpdHMpXG4gICAgICBjb25zdCB0b29rID0gaGFzaC50YWtlKGF2YWlsYWJsZSlcbiAgICAgIHJlc3VsdCA9IChyZXN1bHQgPDwgYXZhaWxhYmxlKSArIHRvb2tcbiAgICAgIHBlbmRpbmdCaXRzIC09IGF2YWlsYWJsZVxuICAgICAgdGhpcy5fYXZhaWxhYmxlQml0cyAtPSBhdmFpbGFibGVcblxuICAgICAgaWYgKGhhc2guYXZhaWxhYmxlQml0cygpID09PSAwKSB7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRCdWZmZXJJbmRleCsrXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRzXG4gICAqL1xuICB1bnRha2UgKGJpdHMpIHtcbiAgICBsZXQgcGVuZGluZ0JpdHMgPSBiaXRzXG5cbiAgICB3aGlsZSAocGVuZGluZ0JpdHMgPiAwKSB7XG4gICAgICBjb25zdCBoYXNoID0gdGhpcy5fYnVmZmVyc1t0aGlzLl9jdXJyZW50QnVmZmVySW5kZXhdXG4gICAgICBjb25zdCBhdmFpbGFibGVGb3JVbnRha2UgPSBNYXRoLm1pbihoYXNoLnRvdGFsQml0cygpIC0gaGFzaC5hdmFpbGFibGVCaXRzKCksIHBlbmRpbmdCaXRzKVxuICAgICAgaGFzaC51bnRha2UoYXZhaWxhYmxlRm9yVW50YWtlKVxuICAgICAgcGVuZGluZ0JpdHMgLT0gYXZhaWxhYmxlRm9yVW50YWtlXG4gICAgICB0aGlzLl9hdmFpbGFibGVCaXRzICs9IGF2YWlsYWJsZUZvclVudGFrZVxuXG4gICAgICBpZiAodGhpcy5fY3VycmVudEJ1ZmZlckluZGV4ID4gMCAmJiBoYXNoLnRvdGFsQml0cygpID09PSBoYXNoLmF2YWlsYWJsZUJpdHMoKSkge1xuICAgICAgICB0aGlzLl9kZXB0aC0tXG4gICAgICAgIHRoaXMuX2N1cnJlbnRCdWZmZXJJbmRleC0tXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgX3Byb2R1Y2VNb3JlQml0cyAoKSB7XG4gICAgdGhpcy5fZGVwdGgrK1xuXG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLl9kZXB0aCA/IHVpbnQ4QXJyYXlDb25jYXQoW3RoaXMuX3ZhbHVlLCBVaW50OEFycmF5LmZyb20oW3RoaXMuX2RlcHRoXSldKSA6IHRoaXMuX3ZhbHVlXG4gICAgY29uc3QgaGFzaFZhbHVlID0gYXdhaXQgdGhpcy5faGFzaEZuKHZhbHVlKVxuICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBDb25zdW1hYmxlQnVmZmVyKGhhc2hWYWx1ZSlcblxuICAgIHRoaXMuX2J1ZmZlcnMucHVzaChidWZmZXIpXG4gICAgdGhpcy5fYXZhaWxhYmxlQml0cyArPSBidWZmZXIuYXZhaWxhYmxlQml0cygpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB3cmFwSGFzaFxubW9kdWxlLmV4cG9ydHMuSW5maW5pdGVIYXNoID0gSW5maW5pdGVIYXNoXG4iLCAiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IEJ1Y2tldCA9IHJlcXVpcmUoJy4vYnVja2V0JylcbmNvbnN0IHdyYXBIYXNoID0gcmVxdWlyZSgnLi9jb25zdW1hYmxlLWhhc2gnKVxuXG4vKipcbiAqIEB0eXBlZGVmIHtvYmplY3R9IFVzZXJCdWNrZXRPcHRpb25zXG4gKiBAcHJvcGVydHkgeyh2YWx1ZTogVWludDhBcnJheSkgPT4gUHJvbWlzZTxVaW50OEFycmF5Pn0gaGFzaEZuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2JpdHM9OF1cbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7VXNlckJ1Y2tldE9wdGlvbnN9IG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gY3JlYXRlSEFNVCAob3B0aW9ucykge1xuICBpZiAoIW9wdGlvbnMgfHwgIW9wdGlvbnMuaGFzaEZuKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwbGVhc2UgZGVmaW5lIGFuIG9wdGlvbnMuaGFzaEZuJylcbiAgfVxuXG4gIGNvbnN0IGJ1Y2tldE9wdGlvbnMgPSB7XG4gICAgYml0czogb3B0aW9ucy5iaXRzIHx8IDgsXG4gICAgaGFzaDogd3JhcEhhc2gob3B0aW9ucy5oYXNoRm4pXG4gIH1cblxuICByZXR1cm4gbmV3IEJ1Y2tldChidWNrZXRPcHRpb25zKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY3JlYXRlSEFNVCxcbiAgQnVja2V0XG59XG4iLCAiJ3VzZSBzdHJpY3QnXG5cbi8qKlxuICogVHVybnMgYSBicm93c2VyIHJlYWRhYmxlIHN0cmVhbSBpbnRvIGFuIGFzeW5jIGl0ZXJhYmxlLiBBc3luYyBpdGVyYXRpb24gb3ZlclxuICogcmV0dXJuZWQgaXRlcmFibGUgd2lsbCBsb2NrIGdpdmUgc3RyZWFtLCBwcmV2ZW50aW5nIGFueSBvdGhlciBjb25zdW1lciBmcm9tXG4gKiBhY3F1aXJpbmcgYSByZWFkZXIuIFRoZSBsb2NrIHdpbGwgYmUgcmVsZWFzZWQgaWYgaXRlcmF0aW9uIGxvb3AgaXMgYnJva2VuLiBUb1xuICogcHJldmVudCBzdHJlYW0gY2FuY2VsbGluZyBvcHRpb25hbCBgeyBwcmV2ZW50Q2FuY2VsOiB0cnVlIH1gIGNvdWxkIGJlIHBhc3NlZFxuICogYXMgYSBzZWNvbmQgYXJndW1lbnQuXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtSZWFkYWJsZVN0cmVhbTxUPn0gc3RyZWFtXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnByZXZlbnRDYW5jZWw9Ym9vbGVhbl1cbiAqIEByZXR1cm5zIHtBc3luY0l0ZXJhYmxlPFQ+fVxuICovXG5hc3luYyBmdW5jdGlvbiAqIGJyb3dzZXJSZWFkYWJsZVN0cmVhbVRvSXQgKHN0cmVhbSwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHJlYWRlciA9IHN0cmVhbS5nZXRSZWFkZXIoKVxuXG4gIHRyeSB7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlYWRlci5yZWFkKClcblxuICAgICAgaWYgKHJlc3VsdC5kb25lKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICB5aWVsZCByZXN1bHQudmFsdWVcbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgaWYgKG9wdGlvbnMucHJldmVudENhbmNlbCAhPT0gdHJ1ZSkge1xuICAgICAgcmVhZGVyLmNhbmNlbCgpXG4gICAgfVxuXG4gICAgcmVhZGVyLnJlbGVhc2VMb2NrKClcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJyb3dzZXJSZWFkYWJsZVN0cmVhbVRvSXRcbiIsICIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGJyb3dzZXJSZWFkYWJsZVN0cmVhbVRvSXQgPSByZXF1aXJlKCdicm93c2VyLXJlYWRhYmxlc3RyZWFtLXRvLWl0JylcblxuLyoqXG4gKiBAcGFyYW0ge0Jsb2J9IGJsb2JcbiAqIEByZXR1cm5zIHtBc3luY0l0ZXJhYmxlPFVpbnQ4QXJyYXk+fVxuICovXG5mdW5jdGlvbiBibG9iVG9JdCAoYmxvYikge1xuICBpZiAodHlwZW9mIGJsb2Iuc3RyZWFtID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gQHRzLWlnbm9yZSBtaXNzaW5nIHNvbWUgcHJvcGVydGllc1xuICAgIHJldHVybiBicm93c2VyUmVhZGFibGVTdHJlYW1Ub0l0KGJsb2Iuc3RyZWFtKCkpXG4gIH1cblxuICAvLyBmaXJlZm94IDwgNjkgZG9lcyBub3Qgc3VwcG9ydCBibG9iLnN0cmVhbSgpXG4gIC8vIEB0cy1pZ25vcmUgLSByZXNwb25zZS5ib2R5IGlzIG9wdGlvbmFsLCBidXQgaW4gcHJhY3RpY2UgaXQncyBhIHN0cmVhbS5cbiAgcmV0dXJuIGJyb3dzZXJSZWFkYWJsZVN0cmVhbVRvSXQobmV3IFJlc3BvbnNlKGJsb2IpLmJvZHkpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmxvYlRvSXRcbiIsICIndXNlIHN0cmljdCdcblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHR5cGVkZWYge09iamVjdH0gUGVla1xuICogQHByb3BlcnR5IHsoKSA9PiBJdGVyYXRvclJlc3VsdDxULCB2b2lkPn0gcGVla1xuICovXG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEFzeW5jUGVla1xuICogQHByb3BlcnR5IHsoKSA9PiBQcm9taXNlPEl0ZXJhdG9yUmVzdWx0PFQsIHZvaWQ+Pn0gcGVla1xuICovXG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFB1c2hcbiAqIEBwcm9wZXJ0eSB7KHZhbHVlOlQpID0+IHZvaWR9IHB1c2hcbiAqL1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAdHlwZWRlZiB7SXRlcmFibGU8VD4gJiBQZWVrPFQ+ICYgUHVzaDxUPiAmIEl0ZXJhdG9yPFQ+fSBQZWVrYWJsZTxUPlxuICovXG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEB0eXBlZGVmIHtBc3luY0l0ZXJhYmxlPFQ+ICYgQXN5bmNQZWVrPFQ+ICYgUHVzaDxUPiAmIEFzeW5jSXRlcmF0b3I8VD59IEFzeW5jUGVla2FibGU8VD5cbiAqL1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSB7SXRlcmFibGU8YW55PiB8IEFzeW5jSXRlcmFibGU8YW55Pn0gSVxuICogQHBhcmFtIHtJfSBpdGVyYWJsZVxuICogQHJldHVybnMge0kgZXh0ZW5kcyBJdGVyYWJsZTxpbmZlciBUPlxuICogID8gUGVla2FibGU8VD5cbiAqICA6IEkgZXh0ZW5kcyBBc3luY0l0ZXJhYmxlPGluZmVyIFQ+XG4gKiAgPyBBc3luY1BlZWthYmxlPFQ+XG4gKiAgOiBuZXZlclxuICogfVxuICovXG5mdW5jdGlvbiBwZWVrYWJsZUl0ZXJhdG9yIChpdGVyYWJsZSkge1xuICAvLyBAdHMtaWdub3JlXG4gIGNvbnN0IFtpdGVyYXRvciwgc3ltYm9sXSA9IGl0ZXJhYmxlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXVxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICA/IFtpdGVyYWJsZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSwgU3ltYm9sLmFzeW5jSXRlcmF0b3JdXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIDogW2l0ZXJhYmxlW1N5bWJvbC5pdGVyYXRvcl0oKSwgU3ltYm9sLml0ZXJhdG9yXVxuXG4gIC8qKiBAdHlwZSB7YW55W119ICovXG4gIGNvbnN0IHF1ZXVlID0gW11cblxuICAvLyBAdHMtaWdub3JlXG4gIHJldHVybiB7XG4gICAgcGVlazogKCkgPT4ge1xuICAgICAgcmV0dXJuIGl0ZXJhdG9yLm5leHQoKVxuICAgIH0sXG4gICAgcHVzaDogKHZhbHVlKSA9PiB7XG4gICAgICBxdWV1ZS5wdXNoKHZhbHVlKVxuICAgIH0sXG4gICAgbmV4dDogKCkgPT4ge1xuICAgICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICAgIHZhbHVlOiBxdWV1ZS5zaGlmdCgpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGl0ZXJhdG9yLm5leHQoKVxuICAgIH0sXG4gICAgW3N5bWJvbF0gKCkge1xuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwZWVrYWJsZUl0ZXJhdG9yXG4iLCAiJ3VzZSBzdHJpY3QnXG5cbi8qKlxuICogVGFrZXMgYW4gKGFzeW5jKSBpdGVyYWJsZSBhbmQgcmV0dXJucyBvbmUgd2l0aCBlYWNoIGl0ZW0gbWFwcGVkIGJ5IHRoZSBwYXNzZWRcbiAqIGZ1bmN0aW9uLlxuICpcbiAqIEB0ZW1wbGF0ZSBJLE9cbiAqIEBwYXJhbSB7QXN5bmNJdGVyYWJsZTxJPnxJdGVyYWJsZTxJPn0gc291cmNlXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEkpOk98UHJvbWlzZTxPPn0gZnVuY1xuICogQHJldHVybnMge0FzeW5jSXRlcmFibGU8Tz59XG4gKi9cbmNvbnN0IG1hcCA9IGFzeW5jIGZ1bmN0aW9uICogKHNvdXJjZSwgZnVuYykge1xuICBmb3IgYXdhaXQgKGNvbnN0IHZhbCBvZiBzb3VyY2UpIHtcbiAgICB5aWVsZCBmdW5jKHZhbClcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcFxuIiwgIid1c2Ugc3RyaWN0J1xuXG4vKipcbiAqIERyYWlucyBhbiAoYXN5bmMpIGl0ZXJhYmxlIGRpc2NhcmRpbmcgaXRzJyBjb250ZW50IGFuZCBkb2VzIG5vdCByZXR1cm5cbiAqIGFueXRoaW5nLlxuICpcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge0FzeW5jSXRlcmFibGU8VD58SXRlcmFibGU8VD59IHNvdXJjZVxuICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gKi9cbmNvbnN0IGRyYWluID0gYXN5bmMgKHNvdXJjZSkgPT4ge1xuICBmb3IgYXdhaXQgKGNvbnN0IF8gb2Ygc291cmNlKSB7IH0gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFycyxuby1lbXB0eVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGRyYWluXG4iLCAiJ3VzZSBzdHJpY3QnXG5cbi8qKlxuICogRmlsdGVycyB0aGUgcGFzc2VkIChhc3luYykgaXRlcmFibGUgYnkgdXNpbmcgdGhlIGZpbHRlciBmdW5jdGlvblxuICpcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge0FzeW5jSXRlcmFibGU8VD58SXRlcmFibGU8VD59IHNvdXJjZVxuICogQHBhcmFtIHtmdW5jdGlvbihUKTpib29sZWFufFByb21pc2U8Ym9vbGVhbj59IGZuXG4gKi9cbmNvbnN0IGZpbHRlciA9IGFzeW5jIGZ1bmN0aW9uICogKHNvdXJjZSwgZm4pIHtcbiAgZm9yIGF3YWl0IChjb25zdCBlbnRyeSBvZiBzb3VyY2UpIHtcbiAgICBpZiAoYXdhaXQgZm4oZW50cnkpKSB7XG4gICAgICB5aWVsZCBlbnRyeVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZpbHRlclxuIiwgIid1c2Ugc3RyaWN0J1xuXG4vKipcbiAqIFN0b3AgaXRlcmF0aW9uIGFmdGVyIG4gaXRlbXMgaGF2ZSBiZWVuIHJlY2VpdmVkLlxuICpcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge0FzeW5jSXRlcmFibGU8VD58SXRlcmFibGU8VD59IHNvdXJjZVxuICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0XG4gKiBAcmV0dXJucyB7QXN5bmNJdGVyYWJsZTxUPn1cbiAqL1xuY29uc3QgdGFrZSA9IGFzeW5jIGZ1bmN0aW9uICogKHNvdXJjZSwgbGltaXQpIHtcbiAgbGV0IGl0ZW1zID0gMFxuXG4gIGlmIChsaW1pdCA8IDEpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGZvciBhd2FpdCAoY29uc3QgZW50cnkgb2Ygc291cmNlKSB7XG4gICAgeWllbGQgZW50cnlcblxuICAgIGl0ZW1zKytcblxuICAgIGlmIChpdGVtcyA9PT0gbGltaXQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRha2VcbiIsICJmdW5jdGlvbiB0aHJvdHRsZWRRdWV1ZShcbiAgbWF4UmVxdWVzdHNQZXJJbnRlcnZhbDogbnVtYmVyLFxuICBpbnRlcnZhbDogbnVtYmVyLFxuICBldmVubHlTcGFjZWQgPSBmYWxzZSxcbikge1xuICAvKipcbiAgICogSWYgYWxsIHJlcXVlc3RzIHNob3VsZCBiZSBldmVubHkgc3BhY2VkLCBhZGp1c3QgdG8gc3VpdC5cbiAgICovXG4gIGlmIChldmVubHlTcGFjZWQpIHtcbiAgICBpbnRlcnZhbCA9IGludGVydmFsIC8gbWF4UmVxdWVzdHNQZXJJbnRlcnZhbDtcbiAgICBtYXhSZXF1ZXN0c1BlckludGVydmFsID0gMTtcbiAgfVxuICBjb25zdCBxdWV1ZTogQXJyYXk8KCkgPT4gUHJvbWlzZTx2b2lkPj4gPSBbXTtcbiAgbGV0IGxhc3RJbnRlcnZhbFN0YXJ0ID0gMDtcbiAgbGV0IG51bVJlcXVlc3RzUGVySW50ZXJ2YWwgPSAwO1xuICBsZXQgdGltZW91dDogTm9kZUpTLlRpbWVvdXQgfCB1bmRlZmluZWQ7XG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCBhdCBhIHNldCBpbnRlcnZhbCB0byByZW1vdmUgaXRlbXMgZnJvbSB0aGUgcXVldWUuXG4gICAqIFRoaXMgaXMgYSBzZWxmLWFkanVzdGluZyB0aW1lciwgc2luY2UgdGhlIGJyb3dzZXIncyBzZXRUaW1lb3V0IGlzIGhpZ2hseSBpbmFjY3VyYXRlLlxuICAgKi9cbiAgY29uc3QgZGVxdWV1ZSA9ICgpID0+IHtcbiAgICBjb25zdCBpbnRlcnZhbEVuZCA9IGxhc3RJbnRlcnZhbFN0YXJ0ICsgaW50ZXJ2YWw7XG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAvKipcbiAgICAgKiBBZGp1c3QgdGhlIHRpbWVyIGlmIGl0IHdhcyBjYWxsZWQgdG9vIGVhcmx5LlxuICAgICAqL1xuICAgIGlmIChub3cgPCBpbnRlcnZhbEVuZCkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXJndW1lbnRcbiAgICAgIHRpbWVvdXQgIT09IHVuZGVmaW5lZCAmJiBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChkZXF1ZXVlLCBpbnRlcnZhbEVuZCAtIG5vdyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxhc3RJbnRlcnZhbFN0YXJ0ID0gbm93O1xuICAgIG51bVJlcXVlc3RzUGVySW50ZXJ2YWwgPSAwO1xuICAgIGZvciAoY29uc3QgY2FsbGJhY2sgb2YgcXVldWUuc3BsaWNlKDAsIG1heFJlcXVlc3RzUGVySW50ZXJ2YWwpKSB7XG4gICAgICBudW1SZXF1ZXN0c1BlckludGVydmFsKys7XG4gICAgICB2b2lkIGNhbGxiYWNrKCk7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGRlcXVldWUsIGludGVydmFsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGltZW91dCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIDxSZXR1cm4gPSB1bmtub3duPihmbjogKCkgPT4gUHJvbWlzZTxSZXR1cm4+IHwgUmV0dXJuKTogUHJvbWlzZTxSZXR1cm4+ID0+IG5ldyBQcm9taXNlPFJldHVybj4oXG4gICAgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgY2FsbGJhY2sgPSAoKSA9PiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZuKS50aGVuKHJlc29sdmUpLmNhdGNoKHJlamVjdCk7XG4gICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgaWYgKHRpbWVvdXQgPT09IHVuZGVmaW5lZCAmJiAobm93IC0gbGFzdEludGVydmFsU3RhcnQpID4gaW50ZXJ2YWwpIHtcbiAgICAgICAgbGFzdEludGVydmFsU3RhcnQgPSBub3c7XG4gICAgICAgIG51bVJlcXVlc3RzUGVySW50ZXJ2YWwgPSAwO1xuICAgICAgfVxuICAgICAgaWYgKG51bVJlcXVlc3RzUGVySW50ZXJ2YWwrKyA8IG1heFJlcXVlc3RzUGVySW50ZXJ2YWwpIHtcbiAgICAgICAgdm9pZCBjYWxsYmFjaygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWUucHVzaChjYWxsYmFjayk7XG4gICAgICAgIGlmICh0aW1lb3V0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChkZXF1ZXVlLCBsYXN0SW50ZXJ2YWxTdGFydCArIGludGVydmFsIC0gbm93KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IHRocm90dGxlZFF1ZXVlO1xuZXhwb3J0IGRlZmF1bHQgdGhyb3R0bGVkUXVldWU7XG5cbiIsIG51bGwsICIvLy8gPHJlZmVyZW5jZSBsaWI9XCJlczIwMTUuc3ltYm9sXCIgLz5cblxuY29uc3QgU3ltYm9sUG9seWZpbGw6IChkZXNjcmlwdGlvbj86IHN0cmluZykgPT4gc3ltYm9sID1cbiAgdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSAnc3ltYm9sJyA/XG4gICAgU3ltYm9sIDpcbiAgICBkZXNjcmlwdGlvbiA9PiBgU3ltYm9sKCR7ZGVzY3JpcHRpb259KWAgYXMgYW55IGFzIHN5bWJvbDtcblxuZXhwb3J0IGRlZmF1bHQgU3ltYm9sUG9seWZpbGw7XG4iLCAiLy8vIDxyZWZlcmVuY2UgbGliPVwiZG9tXCIgLz5cblxuZXhwb3J0IGZ1bmN0aW9uIG5vb3AoKTogdW5kZWZpbmVkIHtcbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gZ2V0R2xvYmFscygpIHtcbiAgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBzZWxmO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIHdpbmRvdztcbiAgfSBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBnbG9iYWw7XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IGNvbnN0IGdsb2JhbHMgPSBnZXRHbG9iYWxzKCk7XG4iLCAiaW1wb3J0IHsgbm9vcCB9IGZyb20gJy4uLy4uL3V0aWxzJztcbmltcG9ydCB7IEFzc2VydGlvbkVycm9yIH0gZnJvbSAnLi4vLi4vc3R1Yi9hc3NlcnQnO1xuXG5leHBvcnQgZnVuY3Rpb24gdHlwZUlzT2JqZWN0KHg6IGFueSk6IHggaXMgb2JqZWN0IHtcbiAgcmV0dXJuICh0eXBlb2YgeCA9PT0gJ29iamVjdCcgJiYgeCAhPT0gbnVsbCkgfHwgdHlwZW9mIHggPT09ICdmdW5jdGlvbic7XG59XG5cbmV4cG9ydCBjb25zdCByZXRocm93QXNzZXJ0aW9uRXJyb3JSZWplY3Rpb246IChlOiBhbnkpID0+IHZvaWQgPVxuICBERUJVRyA/IGUgPT4ge1xuICAgIC8vIFVzZWQgdGhyb3VnaG91dCB0aGUgcmVmZXJlbmNlIGltcGxlbWVudGF0aW9uLCBhcyBgLmNhdGNoKHJldGhyb3dBc3NlcnRpb25FcnJvclJlamVjdGlvbilgLCB0byBlbnN1cmUgYW55IGVycm9yc1xuICAgIC8vIGdldCBzaG93bi4gVGhlcmUgYXJlIHBsYWNlcyBpbiB0aGUgc3BlYyB3aGVyZSB3ZSBkbyBwcm9taXNlIHRyYW5zZm9ybWF0aW9ucyBhbmQgcHVycG9zZWZ1bGx5IGlnbm9yZSBvciBkb24ndFxuICAgIC8vIGV4cGVjdCBhbnkgZXJyb3JzLCBidXQgYXNzZXJ0aW9uIGVycm9ycyBhcmUgYWx3YXlzIHByb2JsZW1hdGljLlxuICAgIGlmIChlICYmIGUgaW5zdGFuY2VvZiBBc3NlcnRpb25FcnJvcikge1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9LCAwKTtcbiAgICB9XG4gIH0gOiBub29wO1xuIiwgImltcG9ydCB7IGdsb2JhbHMgfSBmcm9tICcuLi8uLi91dGlscyc7XG5pbXBvcnQgeyByZXRocm93QXNzZXJ0aW9uRXJyb3JSZWplY3Rpb24gfSBmcm9tICcuL21pc2NlbGxhbmVvdXMnO1xuaW1wb3J0IGFzc2VydCBmcm9tICcuLi8uLi9zdHViL2Fzc2VydCc7XG5cbmNvbnN0IG9yaWdpbmFsUHJvbWlzZSA9IFByb21pc2U7XG5jb25zdCBvcmlnaW5hbFByb21pc2VUaGVuID0gUHJvbWlzZS5wcm90b3R5cGUudGhlbjtcbmNvbnN0IG9yaWdpbmFsUHJvbWlzZVJlc29sdmUgPSBQcm9taXNlLnJlc29sdmUuYmluZChvcmlnaW5hbFByb21pc2UpO1xuY29uc3Qgb3JpZ2luYWxQcm9taXNlUmVqZWN0ID0gUHJvbWlzZS5yZWplY3QuYmluZChvcmlnaW5hbFByb21pc2UpO1xuXG5leHBvcnQgZnVuY3Rpb24gbmV3UHJvbWlzZTxUPihleGVjdXRvcjogKFxuICByZXNvbHZlOiAodmFsdWU6IFQgfCBQcm9taXNlTGlrZTxUPikgPT4gdm9pZCxcbiAgcmVqZWN0OiAocmVhc29uPzogYW55KSA9PiB2b2lkXG4pID0+IHZvaWQpOiBQcm9taXNlPFQ+IHtcbiAgcmV0dXJuIG5ldyBvcmlnaW5hbFByb21pc2UoZXhlY3V0b3IpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcHJvbWlzZVJlc29sdmVkV2l0aDxUPih2YWx1ZTogVCB8IFByb21pc2VMaWtlPFQ+KTogUHJvbWlzZTxUPiB7XG4gIHJldHVybiBvcmlnaW5hbFByb21pc2VSZXNvbHZlKHZhbHVlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHByb21pc2VSZWplY3RlZFdpdGg8VCA9IG5ldmVyPihyZWFzb246IGFueSk6IFByb21pc2U8VD4ge1xuICByZXR1cm4gb3JpZ2luYWxQcm9taXNlUmVqZWN0KHJlYXNvbik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBQZXJmb3JtUHJvbWlzZVRoZW48VCwgVFJlc3VsdDEgPSBULCBUUmVzdWx0MiA9IG5ldmVyPihcbiAgcHJvbWlzZTogUHJvbWlzZTxUPixcbiAgb25GdWxmaWxsZWQ/OiAodmFsdWU6IFQpID0+IFRSZXN1bHQxIHwgUHJvbWlzZUxpa2U8VFJlc3VsdDE+LFxuICBvblJlamVjdGVkPzogKHJlYXNvbjogYW55KSA9PiBUUmVzdWx0MiB8IFByb21pc2VMaWtlPFRSZXN1bHQyPik6IFByb21pc2U8VFJlc3VsdDEgfCBUUmVzdWx0Mj4ge1xuICAvLyBUaGVyZSBkb2Vzbid0IGFwcGVhciB0byBiZSBhbnkgd2F5IHRvIGNvcnJlY3RseSBlbXVsYXRlIHRoZSBiZWhhdmlvdXIgZnJvbSBKYXZhU2NyaXB0LCBzbyB0aGlzIGlzIGp1c3QgYW5cbiAgLy8gYXBwcm94aW1hdGlvbi5cbiAgcmV0dXJuIG9yaWdpbmFsUHJvbWlzZVRoZW4uY2FsbChwcm9taXNlLCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkgYXMgUHJvbWlzZTxUUmVzdWx0MSB8IFRSZXN1bHQyPjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVwb25Qcm9taXNlPFQ+KFxuICBwcm9taXNlOiBQcm9taXNlPFQ+LFxuICBvbkZ1bGZpbGxlZD86ICh2YWx1ZTogVCkgPT4gdm9pZCB8IFByb21pc2VMaWtlPHZvaWQ+LFxuICBvblJlamVjdGVkPzogKHJlYXNvbjogYW55KSA9PiB2b2lkIHwgUHJvbWlzZUxpa2U8dm9pZD4pOiB2b2lkIHtcbiAgUGVyZm9ybVByb21pc2VUaGVuKFxuICAgIFBlcmZvcm1Qcm9taXNlVGhlbihwcm9taXNlLCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCksXG4gICAgdW5kZWZpbmVkLFxuICAgIHJldGhyb3dBc3NlcnRpb25FcnJvclJlamVjdGlvblxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXBvbkZ1bGZpbGxtZW50PFQ+KHByb21pc2U6IFByb21pc2U8VD4sIG9uRnVsZmlsbGVkOiAodmFsdWU6IFQpID0+IHZvaWQgfCBQcm9taXNlTGlrZTx2b2lkPik6IHZvaWQge1xuICB1cG9uUHJvbWlzZShwcm9taXNlLCBvbkZ1bGZpbGxlZCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1cG9uUmVqZWN0aW9uKHByb21pc2U6IFByb21pc2U8dW5rbm93bj4sIG9uUmVqZWN0ZWQ6IChyZWFzb246IGFueSkgPT4gdm9pZCB8IFByb21pc2VMaWtlPHZvaWQ+KTogdm9pZCB7XG4gIHVwb25Qcm9taXNlKHByb21pc2UsIHVuZGVmaW5lZCwgb25SZWplY3RlZCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1Qcm9taXNlV2l0aDxULCBUUmVzdWx0MSA9IFQsIFRSZXN1bHQyID0gbmV2ZXI+KFxuICBwcm9taXNlOiBQcm9taXNlPFQ+LFxuICBmdWxmaWxsbWVudEhhbmRsZXI/OiAodmFsdWU6IFQpID0+IFRSZXN1bHQxIHwgUHJvbWlzZUxpa2U8VFJlc3VsdDE+LFxuICByZWplY3Rpb25IYW5kbGVyPzogKHJlYXNvbjogYW55KSA9PiBUUmVzdWx0MiB8IFByb21pc2VMaWtlPFRSZXN1bHQyPik6IFByb21pc2U8VFJlc3VsdDEgfCBUUmVzdWx0Mj4ge1xuICByZXR1cm4gUGVyZm9ybVByb21pc2VUaGVuKHByb21pc2UsIGZ1bGZpbGxtZW50SGFuZGxlciwgcmVqZWN0aW9uSGFuZGxlcik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRQcm9taXNlSXNIYW5kbGVkVG9UcnVlKHByb21pc2U6IFByb21pc2U8dW5rbm93bj4pOiB2b2lkIHtcbiAgUGVyZm9ybVByb21pc2VUaGVuKHByb21pc2UsIHVuZGVmaW5lZCwgcmV0aHJvd0Fzc2VydGlvbkVycm9yUmVqZWN0aW9uKTtcbn1cblxuZXhwb3J0IGNvbnN0IHF1ZXVlTWljcm90YXNrOiAoZm46ICgpID0+IHZvaWQpID0+IHZvaWQgPSAoKCkgPT4ge1xuICBjb25zdCBnbG9iYWxRdWV1ZU1pY3JvdGFzayA9IGdsb2JhbHMgJiYgZ2xvYmFscy5xdWV1ZU1pY3JvdGFzaztcbiAgaWYgKHR5cGVvZiBnbG9iYWxRdWV1ZU1pY3JvdGFzayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBnbG9iYWxRdWV1ZU1pY3JvdGFzaztcbiAgfVxuXG4gIGNvbnN0IHJlc29sdmVkUHJvbWlzZSA9IHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcbiAgcmV0dXJuIChmbjogKCkgPT4gdm9pZCkgPT4gUGVyZm9ybVByb21pc2VUaGVuKHJlc29sdmVkUHJvbWlzZSwgZm4pO1xufSkoKTtcblxuZXhwb3J0IGZ1bmN0aW9uIHJlZmxlY3RDYWxsPFQsIEEgZXh0ZW5kcyBhbnlbXSwgUj4oRjogKHRoaXM6IFQsIC4uLmZuQXJnczogQSkgPT4gUiwgVjogVCwgYXJnczogQSk6IFIge1xuICBpZiAodHlwZW9mIEYgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBpcyBub3QgYSBmdW5jdGlvbicpO1xuICB9XG4gIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChGLCBWLCBhcmdzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHByb21pc2VDYWxsPFQsIEEgZXh0ZW5kcyBhbnlbXSwgUj4oRjogKHRoaXM6IFQsIC4uLmZuQXJnczogQSkgPT4gUiB8IFByb21pc2VMaWtlPFI+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVjogVCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IEEpOiBQcm9taXNlPFI+IHtcbiAgYXNzZXJ0KHR5cGVvZiBGID09PSAnZnVuY3Rpb24nKTtcbiAgYXNzZXJ0KFYgIT09IHVuZGVmaW5lZCk7XG4gIGFzc2VydChBcnJheS5pc0FycmF5KGFyZ3MpKTtcbiAgdHJ5IHtcbiAgICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aChyZWZsZWN0Q2FsbChGLCBWLCBhcmdzKSk7XG4gIH0gY2F0Y2ggKHZhbHVlKSB7XG4gICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgodmFsdWUpO1xuICB9XG59XG4iLCAiaW1wb3J0IGFzc2VydCBmcm9tICcuLi9zdHViL2Fzc2VydCc7XG5cbi8vIE9yaWdpbmFsIGZyb20gQ2hyb21pdW1cbi8vIGh0dHBzOi8vY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMvKy8wYWVlNDQzNGE0ZGJhNDJhNDJhYmFlYTliZmJjMGNkMTk2YTYzYmMxL3RoaXJkX3BhcnR5L2JsaW5rL3JlbmRlcmVyL2NvcmUvc3RyZWFtcy9TaW1wbGVRdWV1ZS5qc1xuXG5jb25zdCBRVUVVRV9NQVhfQVJSQVlfU0laRSA9IDE2Mzg0O1xuXG5pbnRlcmZhY2UgTm9kZTxUPiB7XG4gIF9lbGVtZW50czogVFtdO1xuICBfbmV4dDogTm9kZTxUPiB8IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBTaW1wbGUgcXVldWUgc3RydWN0dXJlLlxuICpcbiAqIEF2b2lkcyBzY2FsYWJpbGl0eSBpc3N1ZXMgd2l0aCB1c2luZyBhIHBhY2tlZCBhcnJheSBkaXJlY3RseSBieSB1c2luZ1xuICogbXVsdGlwbGUgYXJyYXlzIGluIGEgbGlua2VkIGxpc3QgYW5kIGtlZXBpbmcgdGhlIGFycmF5IHNpemUgYm91bmRlZC5cbiAqL1xuZXhwb3J0IGNsYXNzIFNpbXBsZVF1ZXVlPFQ+IHtcbiAgcHJpdmF0ZSBfZnJvbnQ6IE5vZGU8VD47XG4gIHByaXZhdGUgX2JhY2s6IE5vZGU8VD47XG4gIHByaXZhdGUgX2N1cnNvciA9IDA7XG4gIHByaXZhdGUgX3NpemUgPSAwO1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIC8vIF9mcm9udCBhbmQgX2JhY2sgYXJlIGFsd2F5cyBkZWZpbmVkLlxuICAgIHRoaXMuX2Zyb250ID0ge1xuICAgICAgX2VsZW1lbnRzOiBbXSxcbiAgICAgIF9uZXh0OiB1bmRlZmluZWRcbiAgICB9O1xuICAgIHRoaXMuX2JhY2sgPSB0aGlzLl9mcm9udDtcbiAgICAvLyBUaGUgY3Vyc29yIGlzIHVzZWQgdG8gYXZvaWQgY2FsbGluZyBBcnJheS5zaGlmdCgpLlxuICAgIC8vIEl0IGNvbnRhaW5zIHRoZSBpbmRleCBvZiB0aGUgZnJvbnQgZWxlbWVudCBvZiB0aGUgYXJyYXkgaW5zaWRlIHRoZVxuICAgIC8vIGZyb250LW1vc3Qgbm9kZS4gSXQgaXMgYWx3YXlzIGluIHRoZSByYW5nZSBbMCwgUVVFVUVfTUFYX0FSUkFZX1NJWkUpLlxuICAgIHRoaXMuX2N1cnNvciA9IDA7XG4gICAgLy8gV2hlbiB0aGVyZSBpcyBvbmx5IG9uZSBub2RlLCBzaXplID09PSBlbGVtZW50cy5sZW5ndGggLSBjdXJzb3IuXG4gICAgdGhpcy5fc2l6ZSA9IDA7XG4gIH1cblxuICBnZXQgbGVuZ3RoKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX3NpemU7XG4gIH1cblxuICAvLyBGb3IgZXhjZXB0aW9uIHNhZmV0eSwgdGhpcyBtZXRob2QgaXMgc3RydWN0dXJlZCBpbiBvcmRlcjpcbiAgLy8gMS4gUmVhZCBzdGF0ZVxuICAvLyAyLiBDYWxjdWxhdGUgcmVxdWlyZWQgc3RhdGUgbXV0YXRpb25zXG4gIC8vIDMuIFBlcmZvcm0gc3RhdGUgbXV0YXRpb25zXG4gIHB1c2goZWxlbWVudDogVCk6IHZvaWQge1xuICAgIGNvbnN0IG9sZEJhY2sgPSB0aGlzLl9iYWNrO1xuICAgIGxldCBuZXdCYWNrID0gb2xkQmFjaztcbiAgICBhc3NlcnQob2xkQmFjay5fbmV4dCA9PT0gdW5kZWZpbmVkKTtcbiAgICBpZiAob2xkQmFjay5fZWxlbWVudHMubGVuZ3RoID09PSBRVUVVRV9NQVhfQVJSQVlfU0laRSAtIDEpIHtcbiAgICAgIG5ld0JhY2sgPSB7XG4gICAgICAgIF9lbGVtZW50czogW10sXG4gICAgICAgIF9uZXh0OiB1bmRlZmluZWRcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gcHVzaCgpIGlzIHRoZSBtdXRhdGlvbiBtb3N0IGxpa2VseSB0byB0aHJvdyBhbiBleGNlcHRpb24sIHNvIGl0XG4gICAgLy8gZ29lcyBmaXJzdC5cbiAgICBvbGRCYWNrLl9lbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xuICAgIGlmIChuZXdCYWNrICE9PSBvbGRCYWNrKSB7XG4gICAgICB0aGlzLl9iYWNrID0gbmV3QmFjaztcbiAgICAgIG9sZEJhY2suX25leHQgPSBuZXdCYWNrO1xuICAgIH1cbiAgICArK3RoaXMuX3NpemU7XG4gIH1cblxuICAvLyBMaWtlIHB1c2goKSwgc2hpZnQoKSBmb2xsb3dzIHRoZSByZWFkIC0+IGNhbGN1bGF0ZSAtPiBtdXRhdGUgcGF0dGVybiBmb3JcbiAgLy8gZXhjZXB0aW9uIHNhZmV0eS5cbiAgc2hpZnQoKTogVCB7XG4gICAgYXNzZXJ0KHRoaXMuX3NpemUgPiAwKTsgLy8gbXVzdCBub3QgYmUgY2FsbGVkIG9uIGFuIGVtcHR5IHF1ZXVlXG5cbiAgICBjb25zdCBvbGRGcm9udCA9IHRoaXMuX2Zyb250O1xuICAgIGxldCBuZXdGcm9udCA9IG9sZEZyb250O1xuICAgIGNvbnN0IG9sZEN1cnNvciA9IHRoaXMuX2N1cnNvcjtcbiAgICBsZXQgbmV3Q3Vyc29yID0gb2xkQ3Vyc29yICsgMTtcblxuICAgIGNvbnN0IGVsZW1lbnRzID0gb2xkRnJvbnQuX2VsZW1lbnRzO1xuICAgIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50c1tvbGRDdXJzb3JdO1xuXG4gICAgaWYgKG5ld0N1cnNvciA9PT0gUVVFVUVfTUFYX0FSUkFZX1NJWkUpIHtcbiAgICAgIGFzc2VydChlbGVtZW50cy5sZW5ndGggPT09IFFVRVVFX01BWF9BUlJBWV9TSVpFKTtcbiAgICAgIGFzc2VydChvbGRGcm9udC5fbmV4dCAhPT0gdW5kZWZpbmVkKTtcbiAgICAgIG5ld0Zyb250ID0gb2xkRnJvbnQuX25leHQhO1xuICAgICAgbmV3Q3Vyc29yID0gMDtcbiAgICB9XG5cbiAgICAvLyBObyBtdXRhdGlvbnMgYmVmb3JlIHRoaXMgcG9pbnQuXG4gICAgLS10aGlzLl9zaXplO1xuICAgIHRoaXMuX2N1cnNvciA9IG5ld0N1cnNvcjtcbiAgICBpZiAob2xkRnJvbnQgIT09IG5ld0Zyb250KSB7XG4gICAgICB0aGlzLl9mcm9udCA9IG5ld0Zyb250O1xuICAgIH1cblxuICAgIC8vIFBlcm1pdCBzaGlmdGVkIGVsZW1lbnQgdG8gYmUgZ2FyYmFnZSBjb2xsZWN0ZWQuXG4gICAgZWxlbWVudHNbb2xkQ3Vyc29yXSA9IHVuZGVmaW5lZCE7XG5cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIC8vIFRoZSB0cmlja3kgdGhpbmcgYWJvdXQgZm9yRWFjaCgpIGlzIHRoYXQgaXQgY2FuIGJlIGNhbGxlZFxuICAvLyByZS1lbnRyYW50bHkuIFRoZSBxdWV1ZSBtYXkgYmUgbXV0YXRlZCBpbnNpZGUgdGhlIGNhbGxiYWNrLiBJdCBpcyBlYXN5IHRvXG4gIC8vIHNlZSB0aGF0IHB1c2goKSB3aXRoaW4gdGhlIGNhbGxiYWNrIGhhcyBubyBuZWdhdGl2ZSBlZmZlY3RzIHNpbmNlIHRoZSBlbmRcbiAgLy8gb2YgdGhlIHF1ZXVlIGlzIGNoZWNrZWQgZm9yIG9uIGV2ZXJ5IGl0ZXJhdGlvbi4gSWYgc2hpZnQoKSBpcyBjYWxsZWRcbiAgLy8gcmVwZWF0ZWRseSB3aXRoaW4gdGhlIGNhbGxiYWNrIHRoZW4gdGhlIG5leHQgaXRlcmF0aW9uIG1heSByZXR1cm4gYW5cbiAgLy8gZWxlbWVudCB0aGF0IGhhcyBiZWVuIHJlbW92ZWQuIEluIHRoaXMgY2FzZSB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWRcbiAgLy8gd2l0aCB1bmRlZmluZWQgdmFsdWVzIHVudGlsIHdlIGVpdGhlciBcImNhdGNoIHVwXCIgd2l0aCBlbGVtZW50cyB0aGF0IHN0aWxsXG4gIC8vIGV4aXN0IG9yIHJlYWNoIHRoZSBiYWNrIG9mIHRoZSBxdWV1ZS5cbiAgZm9yRWFjaChjYWxsYmFjazogKGVsZW1lbnQ6IFQpID0+IHZvaWQpOiB2b2lkIHtcbiAgICBsZXQgaSA9IHRoaXMuX2N1cnNvcjtcbiAgICBsZXQgbm9kZSA9IHRoaXMuX2Zyb250O1xuICAgIGxldCBlbGVtZW50cyA9IG5vZGUuX2VsZW1lbnRzO1xuICAgIHdoaWxlIChpICE9PSBlbGVtZW50cy5sZW5ndGggfHwgbm9kZS5fbmV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoaSA9PT0gZWxlbWVudHMubGVuZ3RoKSB7XG4gICAgICAgIGFzc2VydChub2RlLl9uZXh0ICE9PSB1bmRlZmluZWQpO1xuICAgICAgICBhc3NlcnQoaSA9PT0gUVVFVUVfTUFYX0FSUkFZX1NJWkUpO1xuICAgICAgICBub2RlID0gbm9kZS5fbmV4dCE7XG4gICAgICAgIGVsZW1lbnRzID0gbm9kZS5fZWxlbWVudHM7XG4gICAgICAgIGkgPSAwO1xuICAgICAgICBpZiAoZWxlbWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNhbGxiYWNrKGVsZW1lbnRzW2ldKTtcbiAgICAgICsraTtcbiAgICB9XG4gIH1cblxuICAvLyBSZXR1cm4gdGhlIGVsZW1lbnQgdGhhdCB3b3VsZCBiZSByZXR1cm5lZCBpZiBzaGlmdCgpIHdhcyBjYWxsZWQgbm93LFxuICAvLyB3aXRob3V0IG1vZGlmeWluZyB0aGUgcXVldWUuXG4gIHBlZWsoKTogVCB7XG4gICAgYXNzZXJ0KHRoaXMuX3NpemUgPiAwKTsgLy8gbXVzdCBub3QgYmUgY2FsbGVkIG9uIGFuIGVtcHR5IHF1ZXVlXG5cbiAgICBjb25zdCBmcm9udCA9IHRoaXMuX2Zyb250O1xuICAgIGNvbnN0IGN1cnNvciA9IHRoaXMuX2N1cnNvcjtcbiAgICByZXR1cm4gZnJvbnQuX2VsZW1lbnRzW2N1cnNvcl07XG4gIH1cbn1cbiIsICJpbXBvcnQgYXNzZXJ0IGZyb20gJy4uLy4uL3N0dWIvYXNzZXJ0JztcbmltcG9ydCB7IFJlYWRhYmxlU3RyZWFtLCBSZWFkYWJsZVN0cmVhbUNhbmNlbCwgUmVhZGFibGVTdHJlYW1SZWFkZXIgfSBmcm9tICcuLi9yZWFkYWJsZS1zdHJlYW0nO1xuaW1wb3J0IHsgbmV3UHJvbWlzZSwgc2V0UHJvbWlzZUlzSGFuZGxlZFRvVHJ1ZSB9IGZyb20gJy4uL2hlbHBlcnMvd2ViaWRsJztcblxuZXhwb3J0IGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY0luaXRpYWxpemU8Uj4ocmVhZGVyOiBSZWFkYWJsZVN0cmVhbVJlYWRlcjxSPiwgc3RyZWFtOiBSZWFkYWJsZVN0cmVhbTxSPikge1xuICByZWFkZXIuX293bmVyUmVhZGFibGVTdHJlYW0gPSBzdHJlYW07XG4gIHN0cmVhbS5fcmVhZGVyID0gcmVhZGVyO1xuXG4gIGlmIChzdHJlYW0uX3N0YXRlID09PSAncmVhZGFibGUnKSB7XG4gICAgZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VJbml0aWFsaXplKHJlYWRlcik7XG4gIH0gZWxzZSBpZiAoc3RyZWFtLl9zdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICBkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemVBc1Jlc29sdmVkKHJlYWRlcik7XG4gIH0gZWxzZSB7XG4gICAgYXNzZXJ0KHN0cmVhbS5fc3RhdGUgPT09ICdlcnJvcmVkJyk7XG5cbiAgICBkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemVBc1JlamVjdGVkKHJlYWRlciwgc3RyZWFtLl9zdG9yZWRFcnJvcik7XG4gIH1cbn1cblxuLy8gQSBjbGllbnQgb2YgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyIGFuZCBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIgbWF5IHVzZSB0aGVzZSBmdW5jdGlvbnMgZGlyZWN0bHkgdG8gYnlwYXNzIHN0YXRlXG4vLyBjaGVjay5cblxuZXhwb3J0IGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY0NhbmNlbChyZWFkZXI6IFJlYWRhYmxlU3RyZWFtUmVhZGVyPGFueT4sIHJlYXNvbjogYW55KTogUHJvbWlzZTx1bmRlZmluZWQ+IHtcbiAgY29uc3Qgc3RyZWFtID0gcmVhZGVyLl9vd25lclJlYWRhYmxlU3RyZWFtO1xuICBhc3NlcnQoc3RyZWFtICE9PSB1bmRlZmluZWQpO1xuICByZXR1cm4gUmVhZGFibGVTdHJlYW1DYW5jZWwoc3RyZWFtLCByZWFzb24pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljUmVsZWFzZShyZWFkZXI6IFJlYWRhYmxlU3RyZWFtUmVhZGVyPGFueT4pIHtcbiAgYXNzZXJ0KHJlYWRlci5fb3duZXJSZWFkYWJsZVN0cmVhbSAhPT0gdW5kZWZpbmVkKTtcbiAgYXNzZXJ0KHJlYWRlci5fb3duZXJSZWFkYWJsZVN0cmVhbS5fcmVhZGVyID09PSByZWFkZXIpO1xuXG4gIGlmIChyZWFkZXIuX293bmVyUmVhZGFibGVTdHJlYW0uX3N0YXRlID09PSAncmVhZGFibGUnKSB7XG4gICAgZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VSZWplY3QoXG4gICAgICByZWFkZXIsXG4gICAgICBuZXcgVHlwZUVycm9yKGBSZWFkZXIgd2FzIHJlbGVhc2VkIGFuZCBjYW4gbm8gbG9uZ2VyIGJlIHVzZWQgdG8gbW9uaXRvciB0aGUgc3RyZWFtJ3MgY2xvc2VkbmVzc2ApKTtcbiAgfSBlbHNlIHtcbiAgICBkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZVJlc2V0VG9SZWplY3RlZChcbiAgICAgIHJlYWRlcixcbiAgICAgIG5ldyBUeXBlRXJyb3IoYFJlYWRlciB3YXMgcmVsZWFzZWQgYW5kIGNhbiBubyBsb25nZXIgYmUgdXNlZCB0byBtb25pdG9yIHRoZSBzdHJlYW0ncyBjbG9zZWRuZXNzYCkpO1xuICB9XG5cbiAgcmVhZGVyLl9vd25lclJlYWRhYmxlU3RyZWFtLl9yZWFkZXIgPSB1bmRlZmluZWQ7XG4gIHJlYWRlci5fb3duZXJSZWFkYWJsZVN0cmVhbSA9IHVuZGVmaW5lZCE7XG59XG5cbi8vIEhlbHBlciBmdW5jdGlvbnMgZm9yIHRoZSByZWFkZXJzLlxuXG5leHBvcnQgZnVuY3Rpb24gcmVhZGVyTG9ja0V4Y2VwdGlvbihuYW1lOiBzdHJpbmcpOiBUeXBlRXJyb3Ige1xuICByZXR1cm4gbmV3IFR5cGVFcnJvcignQ2Fubm90ICcgKyBuYW1lICsgJyBhIHN0cmVhbSB1c2luZyBhIHJlbGVhc2VkIHJlYWRlcicpO1xufVxuXG4vLyBIZWxwZXIgZnVuY3Rpb25zIGZvciB0aGUgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyLlxuXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VJbml0aWFsaXplKHJlYWRlcjogUmVhZGFibGVTdHJlYW1SZWFkZXI8YW55Pikge1xuICByZWFkZXIuX2Nsb3NlZFByb21pc2UgPSBuZXdQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICByZWFkZXIuX2Nsb3NlZFByb21pc2VfcmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgcmVhZGVyLl9jbG9zZWRQcm9taXNlX3JlamVjdCA9IHJlamVjdDtcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemVBc1JlamVjdGVkKHJlYWRlcjogUmVhZGFibGVTdHJlYW1SZWFkZXI8YW55PiwgcmVhc29uOiBhbnkpIHtcbiAgZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VJbml0aWFsaXplKHJlYWRlcik7XG4gIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlUmVqZWN0KHJlYWRlciwgcmVhc29uKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZUFzUmVzb2x2ZWQocmVhZGVyOiBSZWFkYWJsZVN0cmVhbVJlYWRlcjxhbnk+KSB7XG4gIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZShyZWFkZXIpO1xuICBkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZVJlc29sdmUocmVhZGVyKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlUmVqZWN0KHJlYWRlcjogUmVhZGFibGVTdHJlYW1SZWFkZXI8YW55PiwgcmVhc29uOiBhbnkpIHtcbiAgaWYgKHJlYWRlci5fY2xvc2VkUHJvbWlzZV9yZWplY3QgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHNldFByb21pc2VJc0hhbmRsZWRUb1RydWUocmVhZGVyLl9jbG9zZWRQcm9taXNlKTtcbiAgcmVhZGVyLl9jbG9zZWRQcm9taXNlX3JlamVjdChyZWFzb24pO1xuICByZWFkZXIuX2Nsb3NlZFByb21pc2VfcmVzb2x2ZSA9IHVuZGVmaW5lZDtcbiAgcmVhZGVyLl9jbG9zZWRQcm9taXNlX3JlamVjdCA9IHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlUmVzZXRUb1JlamVjdGVkKHJlYWRlcjogUmVhZGFibGVTdHJlYW1SZWFkZXI8YW55PiwgcmVhc29uOiBhbnkpIHtcbiAgYXNzZXJ0KHJlYWRlci5fY2xvc2VkUHJvbWlzZV9yZXNvbHZlID09PSB1bmRlZmluZWQpO1xuICBhc3NlcnQocmVhZGVyLl9jbG9zZWRQcm9taXNlX3JlamVjdCA9PT0gdW5kZWZpbmVkKTtcblxuICBkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemVBc1JlamVjdGVkKHJlYWRlciwgcmVhc29uKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlUmVzb2x2ZShyZWFkZXI6IFJlYWRhYmxlU3RyZWFtUmVhZGVyPGFueT4pIHtcbiAgaWYgKHJlYWRlci5fY2xvc2VkUHJvbWlzZV9yZXNvbHZlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICByZWFkZXIuX2Nsb3NlZFByb21pc2VfcmVzb2x2ZSh1bmRlZmluZWQpO1xuICByZWFkZXIuX2Nsb3NlZFByb21pc2VfcmVzb2x2ZSA9IHVuZGVmaW5lZDtcbiAgcmVhZGVyLl9jbG9zZWRQcm9taXNlX3JlamVjdCA9IHVuZGVmaW5lZDtcbn1cbiIsICJleHBvcnQgY29uc3QgQWJvcnRTdGVwcyA9IFN5bWJvbCgnW1tBYm9ydFN0ZXBzXV0nKTtcbmV4cG9ydCBjb25zdCBFcnJvclN0ZXBzID0gU3ltYm9sKCdbW0Vycm9yU3RlcHNdXScpO1xuZXhwb3J0IGNvbnN0IENhbmNlbFN0ZXBzID0gU3ltYm9sKCdbW0NhbmNlbFN0ZXBzXV0nKTtcbmV4cG9ydCBjb25zdCBQdWxsU3RlcHMgPSBTeW1ib2woJ1tbUHVsbFN0ZXBzXV0nKTtcbiIsICIvLy8gPHJlZmVyZW5jZSBsaWI9XCJlczIwMTUuY29yZVwiIC8+XG5cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL051bWJlci9pc0Zpbml0ZSNQb2x5ZmlsbFxuY29uc3QgTnVtYmVySXNGaW5pdGU6IHR5cGVvZiBOdW1iZXIuaXNGaW5pdGUgPSBOdW1iZXIuaXNGaW5pdGUgfHwgZnVuY3Rpb24gKHgpIHtcbiAgcmV0dXJuIHR5cGVvZiB4ID09PSAnbnVtYmVyJyAmJiBpc0Zpbml0ZSh4KTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IE51bWJlcklzRmluaXRlO1xuIiwgIi8vLyA8cmVmZXJlbmNlIGxpYj1cImVzMjAxNS5jb3JlXCIgLz5cblxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aC90cnVuYyNQb2x5ZmlsbFxuY29uc3QgTWF0aFRydW5jOiB0eXBlb2YgTWF0aC50cnVuYyA9IE1hdGgudHJ1bmMgfHwgZnVuY3Rpb24gKHYpIHtcbiAgcmV0dXJuIHYgPCAwID8gTWF0aC5jZWlsKHYpIDogTWF0aC5mbG9vcih2KTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IE1hdGhUcnVuYztcbiIsICJpbXBvcnQgTnVtYmVySXNGaW5pdGUgZnJvbSAnLi4vLi4vc3R1Yi9udW1iZXItaXNmaW5pdGUnO1xuaW1wb3J0IE1hdGhUcnVuYyBmcm9tICcuLi8uLi9zdHViL21hdGgtdHJ1bmMnO1xuXG4vLyBodHRwczovL2hleWNhbS5naXRodWIuaW8vd2ViaWRsLyNpZGwtZGljdGlvbmFyaWVzXG5leHBvcnQgZnVuY3Rpb24gaXNEaWN0aW9uYXJ5KHg6IGFueSk6IHggaXMgb2JqZWN0IHwgbnVsbCB7XG4gIHJldHVybiB0eXBlb2YgeCA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIHggPT09ICdmdW5jdGlvbic7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnREaWN0aW9uYXJ5KG9iajogdW5rbm93bixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IHN0cmluZyk6IGFzc2VydHMgb2JqIGlzIG9iamVjdCB8IG51bGwgfCB1bmRlZmluZWQge1xuICBpZiAob2JqICE9PSB1bmRlZmluZWQgJiYgIWlzRGljdGlvbmFyeShvYmopKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtjb250ZXh0fSBpcyBub3QgYW4gb2JqZWN0LmApO1xuICB9XG59XG5cbmV4cG9ydCB0eXBlIEFueUZ1bmN0aW9uID0gKC4uLmFyZ3M6IGFueVtdKSA9PiBhbnk7XG5cbi8vIGh0dHBzOi8vaGV5Y2FtLmdpdGh1Yi5pby93ZWJpZGwvI2lkbC1jYWxsYmFjay1mdW5jdGlvbnNcbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRGdW5jdGlvbih4OiB1bmtub3duLCBjb250ZXh0OiBzdHJpbmcpOiBhc3NlcnRzIHggaXMgQW55RnVuY3Rpb24ge1xuICBpZiAodHlwZW9mIHggIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke2NvbnRleHR9IGlzIG5vdCBhIGZ1bmN0aW9uLmApO1xuICB9XG59XG5cbi8vIGh0dHBzOi8vaGV5Y2FtLmdpdGh1Yi5pby93ZWJpZGwvI2lkbC1vYmplY3RcbmV4cG9ydCBmdW5jdGlvbiBpc09iamVjdCh4OiBhbnkpOiB4IGlzIG9iamVjdCB7XG4gIHJldHVybiAodHlwZW9mIHggPT09ICdvYmplY3QnICYmIHggIT09IG51bGwpIHx8IHR5cGVvZiB4ID09PSAnZnVuY3Rpb24nO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0T2JqZWN0KHg6IHVua25vd24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IHN0cmluZyk6IGFzc2VydHMgeCBpcyBvYmplY3Qge1xuICBpZiAoIWlzT2JqZWN0KHgpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtjb250ZXh0fSBpcyBub3QgYW4gb2JqZWN0LmApO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRSZXF1aXJlZEFyZ3VtZW50PFQgZXh0ZW5kcyBhbnk+KHg6IFQgfCB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogbnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dDogc3RyaW5nKTogYXNzZXJ0cyB4IGlzIFQge1xuICBpZiAoeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgUGFyYW1ldGVyICR7cG9zaXRpb259IGlzIHJlcXVpcmVkIGluICcke2NvbnRleHR9Jy5gKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0UmVxdWlyZWRGaWVsZDxUIGV4dGVuZHMgYW55Pih4OiBUIHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQ6IHN0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IHN0cmluZyk6IGFzc2VydHMgeCBpcyBUIHtcbiAgaWYgKHggPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7ZmllbGR9IGlzIHJlcXVpcmVkIGluICcke2NvbnRleHR9Jy5gKTtcbiAgfVxufVxuXG4vLyBodHRwczovL2hleWNhbS5naXRodWIuaW8vd2ViaWRsLyNpZGwtdW5yZXN0cmljdGVkLWRvdWJsZVxuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRVbnJlc3RyaWN0ZWREb3VibGUodmFsdWU6IHVua25vd24pOiBudW1iZXIge1xuICByZXR1cm4gTnVtYmVyKHZhbHVlKTtcbn1cblxuZnVuY3Rpb24gY2Vuc29yTmVnYXRpdmVaZXJvKHg6IG51bWJlcik6IG51bWJlciB7XG4gIHJldHVybiB4ID09PSAwID8gMCA6IHg7XG59XG5cbmZ1bmN0aW9uIGludGVnZXJQYXJ0KHg6IG51bWJlcik6IG51bWJlciB7XG4gIHJldHVybiBjZW5zb3JOZWdhdGl2ZVplcm8oTWF0aFRydW5jKHgpKTtcbn1cblxuLy8gaHR0cHM6Ly9oZXljYW0uZ2l0aHViLmlvL3dlYmlkbC8jaWRsLXVuc2lnbmVkLWxvbmctbG9uZ1xuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRVbnNpZ25lZExvbmdMb25nV2l0aEVuZm9yY2VSYW5nZSh2YWx1ZTogdW5rbm93biwgY29udGV4dDogc3RyaW5nKTogbnVtYmVyIHtcbiAgY29uc3QgbG93ZXJCb3VuZCA9IDA7XG4gIGNvbnN0IHVwcGVyQm91bmQgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcblxuICBsZXQgeCA9IE51bWJlcih2YWx1ZSk7XG4gIHggPSBjZW5zb3JOZWdhdGl2ZVplcm8oeCk7XG5cbiAgaWYgKCFOdW1iZXJJc0Zpbml0ZSh4KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7Y29udGV4dH0gaXMgbm90IGEgZmluaXRlIG51bWJlcmApO1xuICB9XG5cbiAgeCA9IGludGVnZXJQYXJ0KHgpO1xuXG4gIGlmICh4IDwgbG93ZXJCb3VuZCB8fCB4ID4gdXBwZXJCb3VuZCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7Y29udGV4dH0gaXMgb3V0c2lkZSB0aGUgYWNjZXB0ZWQgcmFuZ2Ugb2YgJHtsb3dlckJvdW5kfSB0byAke3VwcGVyQm91bmR9LCBpbmNsdXNpdmVgKTtcbiAgfVxuXG4gIGlmICghTnVtYmVySXNGaW5pdGUoeCkgfHwgeCA9PT0gMCkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgLy8gVE9ETyBVc2UgQmlnSW50IGlmIHN1cHBvcnRlZD9cbiAgLy8gbGV0IHhCaWdJbnQgPSBCaWdJbnQoaW50ZWdlclBhcnQoeCkpO1xuICAvLyB4QmlnSW50ID0gQmlnSW50LmFzVWludE4oNjQsIHhCaWdJbnQpO1xuICAvLyByZXR1cm4gTnVtYmVyKHhCaWdJbnQpO1xuXG4gIHJldHVybiB4O1xufVxuIiwgImltcG9ydCB7IElzUmVhZGFibGVTdHJlYW0sIFJlYWRhYmxlU3RyZWFtIH0gZnJvbSAnLi4vcmVhZGFibGUtc3RyZWFtJztcblxuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydFJlYWRhYmxlU3RyZWFtKHg6IHVua25vd24sIGNvbnRleHQ6IHN0cmluZyk6IGFzc2VydHMgeCBpcyBSZWFkYWJsZVN0cmVhbSB7XG4gIGlmICghSXNSZWFkYWJsZVN0cmVhbSh4KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7Y29udGV4dH0gaXMgbm90IGEgUmVhZGFibGVTdHJlYW0uYCk7XG4gIH1cbn1cbiIsICJpbXBvcnQgYXNzZXJ0IGZyb20gJy4uLy4uL3N0dWIvYXNzZXJ0JztcbmltcG9ydCB7IFNpbXBsZVF1ZXVlIH0gZnJvbSAnLi4vc2ltcGxlLXF1ZXVlJztcbmltcG9ydCB7XG4gIFJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY0NhbmNlbCxcbiAgUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljSW5pdGlhbGl6ZSxcbiAgUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljUmVsZWFzZSxcbiAgcmVhZGVyTG9ja0V4Y2VwdGlvblxufSBmcm9tICcuL2dlbmVyaWMtcmVhZGVyJztcbmltcG9ydCB7IElzUmVhZGFibGVTdHJlYW1Mb2NrZWQsIFJlYWRhYmxlU3RyZWFtIH0gZnJvbSAnLi4vcmVhZGFibGUtc3RyZWFtJztcbmltcG9ydCB7IHR5cGVJc09iamVjdCB9IGZyb20gJy4uL2hlbHBlcnMvbWlzY2VsbGFuZW91cyc7XG5pbXBvcnQgeyBQdWxsU3RlcHMgfSBmcm9tICcuLi9hYnN0cmFjdC1vcHMvaW50ZXJuYWwtbWV0aG9kcyc7XG5pbXBvcnQgeyBuZXdQcm9taXNlLCBwcm9taXNlUmVqZWN0ZWRXaXRoIH0gZnJvbSAnLi4vaGVscGVycy93ZWJpZGwnO1xuaW1wb3J0IHsgYXNzZXJ0UmVxdWlyZWRBcmd1bWVudCB9IGZyb20gJy4uL3ZhbGlkYXRvcnMvYmFzaWMnO1xuaW1wb3J0IHsgYXNzZXJ0UmVhZGFibGVTdHJlYW0gfSBmcm9tICcuLi92YWxpZGF0b3JzL3JlYWRhYmxlLXN0cmVhbSc7XG5cbi8qKlxuICogQSByZXN1bHQgcmV0dXJuZWQgYnkge0BsaW5rIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlci5yZWFkfS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCB0eXBlIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRSZXN1bHQ8VD4gPSB7XG4gIGRvbmU6IGZhbHNlO1xuICB2YWx1ZTogVDtcbn0gfCB7XG4gIGRvbmU6IHRydWU7XG4gIHZhbHVlPzogdW5kZWZpbmVkO1xufVxuXG4vLyBBYnN0cmFjdCBvcGVyYXRpb25zIGZvciB0aGUgUmVhZGFibGVTdHJlYW0uXG5cbmV4cG9ydCBmdW5jdGlvbiBBY3F1aXJlUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyPFI+KHN0cmVhbTogUmVhZGFibGVTdHJlYW0pOiBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXI8Uj4ge1xuICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcihzdHJlYW0pO1xufVxuXG4vLyBSZWFkYWJsZVN0cmVhbSBBUEkgZXhwb3NlZCBmb3IgY29udHJvbGxlcnMuXG5cbmV4cG9ydCBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbUFkZFJlYWRSZXF1ZXN0PFI+KHN0cmVhbTogUmVhZGFibGVTdHJlYW08Uj4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkUmVxdWVzdDogUmVhZFJlcXVlc3Q8Uj4pOiB2b2lkIHtcbiAgYXNzZXJ0KElzUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyKHN0cmVhbS5fcmVhZGVyKSk7XG4gIGFzc2VydChzdHJlYW0uX3N0YXRlID09PSAncmVhZGFibGUnKTtcblxuICAoc3RyZWFtLl9yZWFkZXIhIGFzIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcjxSPikuX3JlYWRSZXF1ZXN0cy5wdXNoKHJlYWRSZXF1ZXN0KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtRnVsZmlsbFJlYWRSZXF1ZXN0PFI+KHN0cmVhbTogUmVhZGFibGVTdHJlYW08Uj4sIGNodW5rOiBSIHwgdW5kZWZpbmVkLCBkb25lOiBib29sZWFuKSB7XG4gIGNvbnN0IHJlYWRlciA9IHN0cmVhbS5fcmVhZGVyIGFzIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcjxSPjtcblxuICBhc3NlcnQocmVhZGVyLl9yZWFkUmVxdWVzdHMubGVuZ3RoID4gMCk7XG5cbiAgY29uc3QgcmVhZFJlcXVlc3QgPSByZWFkZXIuX3JlYWRSZXF1ZXN0cy5zaGlmdCgpITtcbiAgaWYgKGRvbmUpIHtcbiAgICByZWFkUmVxdWVzdC5fY2xvc2VTdGVwcygpO1xuICB9IGVsc2Uge1xuICAgIHJlYWRSZXF1ZXN0Ll9jaHVua1N0ZXBzKGNodW5rISk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtR2V0TnVtUmVhZFJlcXVlc3RzPFI+KHN0cmVhbTogUmVhZGFibGVTdHJlYW08Uj4pOiBudW1iZXIge1xuICByZXR1cm4gKHN0cmVhbS5fcmVhZGVyIGFzIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcjxSPikuX3JlYWRSZXF1ZXN0cy5sZW5ndGg7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbUhhc0RlZmF1bHRSZWFkZXIoc3RyZWFtOiBSZWFkYWJsZVN0cmVhbSk6IGJvb2xlYW4ge1xuICBjb25zdCByZWFkZXIgPSBzdHJlYW0uX3JlYWRlcjtcblxuICBpZiAocmVhZGVyID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoIUlzUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyKHJlYWRlcikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gUmVhZGVyc1xuXG5leHBvcnQgaW50ZXJmYWNlIFJlYWRSZXF1ZXN0PFI+IHtcbiAgX2NodW5rU3RlcHMoY2h1bms6IFIpOiB2b2lkO1xuXG4gIF9jbG9zZVN0ZXBzKCk6IHZvaWQ7XG5cbiAgX2Vycm9yU3RlcHMoZTogYW55KTogdm9pZDtcbn1cblxuLyoqXG4gKiBBIGRlZmF1bHQgcmVhZGVyIHZlbmRlZCBieSBhIHtAbGluayBSZWFkYWJsZVN0cmVhbX0uXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyPFIgPSBhbnk+IHtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfb3duZXJSZWFkYWJsZVN0cmVhbSE6IFJlYWRhYmxlU3RyZWFtPFI+O1xuICAvKiogQGludGVybmFsICovXG4gIF9jbG9zZWRQcm9taXNlITogUHJvbWlzZTx1bmRlZmluZWQ+O1xuICAvKiogQGludGVybmFsICovXG4gIF9jbG9zZWRQcm9taXNlX3Jlc29sdmU/OiAodmFsdWU/OiB1bmRlZmluZWQpID0+IHZvaWQ7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2Nsb3NlZFByb21pc2VfcmVqZWN0PzogKHJlYXNvbjogYW55KSA9PiB2b2lkO1xuICAvKiogQGludGVybmFsICovXG4gIF9yZWFkUmVxdWVzdHM6IFNpbXBsZVF1ZXVlPFJlYWRSZXF1ZXN0PFI+PjtcblxuICBjb25zdHJ1Y3RvcihzdHJlYW06IFJlYWRhYmxlU3RyZWFtPFI+KSB7XG4gICAgYXNzZXJ0UmVxdWlyZWRBcmd1bWVudChzdHJlYW0sIDEsICdSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXInKTtcbiAgICBhc3NlcnRSZWFkYWJsZVN0cmVhbShzdHJlYW0sICdGaXJzdCBwYXJhbWV0ZXInKTtcblxuICAgIGlmIChJc1JlYWRhYmxlU3RyZWFtTG9ja2VkKHN0cmVhbSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoaXMgc3RyZWFtIGhhcyBhbHJlYWR5IGJlZW4gbG9ja2VkIGZvciBleGNsdXNpdmUgcmVhZGluZyBieSBhbm90aGVyIHJlYWRlcicpO1xuICAgIH1cblxuICAgIFJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY0luaXRpYWxpemUodGhpcywgc3RyZWFtKTtcblxuICAgIHRoaXMuX3JlYWRSZXF1ZXN0cyA9IG5ldyBTaW1wbGVRdWV1ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBwcm9taXNlIHRoYXQgd2lsbCBiZSBmdWxmaWxsZWQgd2hlbiB0aGUgc3RyZWFtIGJlY29tZXMgY2xvc2VkLFxuICAgKiBvciByZWplY3RlZCBpZiB0aGUgc3RyZWFtIGV2ZXIgZXJyb3JzIG9yIHRoZSByZWFkZXIncyBsb2NrIGlzIHJlbGVhc2VkIGJlZm9yZSB0aGUgc3RyZWFtIGZpbmlzaGVzIGNsb3NpbmcuXG4gICAqL1xuICBnZXQgY2xvc2VkKCk6IFByb21pc2U8dW5kZWZpbmVkPiB7XG4gICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcih0aGlzKSkge1xuICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoZGVmYXVsdFJlYWRlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ2Nsb3NlZCcpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fY2xvc2VkUHJvbWlzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJZiB0aGUgcmVhZGVyIGlzIGFjdGl2ZSwgYmVoYXZlcyB0aGUgc2FtZSBhcyB7QGxpbmsgUmVhZGFibGVTdHJlYW0uY2FuY2VsIHwgc3RyZWFtLmNhbmNlbChyZWFzb24pfS5cbiAgICovXG4gIGNhbmNlbChyZWFzb246IGFueSA9IHVuZGVmaW5lZCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIodGhpcykpIHtcbiAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGRlZmF1bHRSZWFkZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdjYW5jZWwnKSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX293bmVyUmVhZGFibGVTdHJlYW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgocmVhZGVyTG9ja0V4Y2VwdGlvbignY2FuY2VsJykpO1xuICAgIH1cblxuICAgIHJldHVybiBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNDYW5jZWwodGhpcywgcmVhc29uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IGFsbG93cyBhY2Nlc3MgdG8gdGhlIG5leHQgY2h1bmsgZnJvbSB0aGUgc3RyZWFtJ3MgaW50ZXJuYWwgcXVldWUsIGlmIGF2YWlsYWJsZS5cbiAgICpcbiAgICogSWYgcmVhZGluZyBhIGNodW5rIGNhdXNlcyB0aGUgcXVldWUgdG8gYmVjb21lIGVtcHR5LCBtb3JlIGRhdGEgd2lsbCBiZSBwdWxsZWQgZnJvbSB0aGUgdW5kZXJseWluZyBzb3VyY2UuXG4gICAqL1xuICByZWFkKCk6IFByb21pc2U8UmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZFJlc3VsdDxSPj4ge1xuICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIodGhpcykpIHtcbiAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGRlZmF1bHRSZWFkZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdyZWFkJykpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9vd25lclJlYWRhYmxlU3RyZWFtID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKHJlYWRlckxvY2tFeGNlcHRpb24oJ3JlYWQgZnJvbScpKTtcbiAgICB9XG5cbiAgICBsZXQgcmVzb2x2ZVByb21pc2UhOiAocmVzdWx0OiBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkUmVzdWx0PFI+KSA9PiB2b2lkO1xuICAgIGxldCByZWplY3RQcm9taXNlITogKHJlYXNvbjogYW55KSA9PiB2b2lkO1xuICAgIGNvbnN0IHByb21pc2UgPSBuZXdQcm9taXNlPFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRSZXN1bHQ8Uj4+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHJlc29sdmVQcm9taXNlID0gcmVzb2x2ZTtcbiAgICAgIHJlamVjdFByb21pc2UgPSByZWplY3Q7XG4gICAgfSk7XG4gICAgY29uc3QgcmVhZFJlcXVlc3Q6IFJlYWRSZXF1ZXN0PFI+ID0ge1xuICAgICAgX2NodW5rU3RlcHM6IGNodW5rID0+IHJlc29sdmVQcm9taXNlKHsgdmFsdWU6IGNodW5rLCBkb25lOiBmYWxzZSB9KSxcbiAgICAgIF9jbG9zZVN0ZXBzOiAoKSA9PiByZXNvbHZlUHJvbWlzZSh7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfSksXG4gICAgICBfZXJyb3JTdGVwczogZSA9PiByZWplY3RQcm9taXNlKGUpXG4gICAgfTtcbiAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXJSZWFkKHRoaXMsIHJlYWRSZXF1ZXN0KTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWxlYXNlcyB0aGUgcmVhZGVyJ3MgbG9jayBvbiB0aGUgY29ycmVzcG9uZGluZyBzdHJlYW0uIEFmdGVyIHRoZSBsb2NrIGlzIHJlbGVhc2VkLCB0aGUgcmVhZGVyIGlzIG5vIGxvbmdlciBhY3RpdmUuXG4gICAqIElmIHRoZSBhc3NvY2lhdGVkIHN0cmVhbSBpcyBlcnJvcmVkIHdoZW4gdGhlIGxvY2sgaXMgcmVsZWFzZWQsIHRoZSByZWFkZXIgd2lsbCBhcHBlYXIgZXJyb3JlZCBpbiB0aGUgc2FtZSB3YXlcbiAgICogZnJvbSBub3cgb247IG90aGVyd2lzZSwgdGhlIHJlYWRlciB3aWxsIGFwcGVhciBjbG9zZWQuXG4gICAqXG4gICAqIEEgcmVhZGVyJ3MgbG9jayBjYW5ub3QgYmUgcmVsZWFzZWQgd2hpbGUgaXQgc3RpbGwgaGFzIGEgcGVuZGluZyByZWFkIHJlcXVlc3QsIGkuZS4sIGlmIGEgcHJvbWlzZSByZXR1cm5lZCBieVxuICAgKiB0aGUgcmVhZGVyJ3Mge0BsaW5rIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlci5yZWFkIHwgcmVhZCgpfSBtZXRob2QgaGFzIG5vdCB5ZXQgYmVlbiBzZXR0bGVkLiBBdHRlbXB0aW5nIHRvXG4gICAqIGRvIHNvIHdpbGwgdGhyb3cgYSBgVHlwZUVycm9yYCBhbmQgbGVhdmUgdGhlIHJlYWRlciBsb2NrZWQgdG8gdGhlIHN0cmVhbS5cbiAgICovXG4gIHJlbGVhc2VMb2NrKCk6IHZvaWQge1xuICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIodGhpcykpIHtcbiAgICAgIHRocm93IGRlZmF1bHRSZWFkZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdyZWxlYXNlTG9jaycpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9vd25lclJlYWRhYmxlU3RyZWFtID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcmVhZFJlcXVlc3RzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RyaWVkIHRvIHJlbGVhc2UgYSByZWFkZXIgbG9jayB3aGVuIHRoYXQgcmVhZGVyIGhhcyBwZW5kaW5nIHJlYWQoKSBjYWxscyB1bi1zZXR0bGVkJyk7XG4gICAgfVxuXG4gICAgUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljUmVsZWFzZSh0aGlzKTtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIucHJvdG90eXBlLCB7XG4gIGNhbmNlbDogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gIHJlYWQ6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICByZWxlYXNlTG9jazogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gIGNsb3NlZDogeyBlbnVtZXJhYmxlOiB0cnVlIH1cbn0pO1xuaWYgKHR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWcgPT09ICdzeW1ib2wnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIucHJvdG90eXBlLCBTeW1ib2wudG9TdHJpbmdUYWcsIHtcbiAgICB2YWx1ZTogJ1JlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcicsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG4vLyBBYnN0cmFjdCBvcGVyYXRpb25zIGZvciB0aGUgcmVhZGVycy5cblxuZXhwb3J0IGZ1bmN0aW9uIElzUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyPFIgPSBhbnk+KHg6IGFueSk6IHggaXMgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyPFI+IHtcbiAgaWYgKCF0eXBlSXNPYmplY3QoeCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnX3JlYWRSZXF1ZXN0cycpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHggaW5zdGFuY2VvZiBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXJSZWFkPFI+KHJlYWRlcjogUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyPFI+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZFJlcXVlc3Q6IFJlYWRSZXF1ZXN0PFI+KTogdm9pZCB7XG4gIGNvbnN0IHN0cmVhbSA9IHJlYWRlci5fb3duZXJSZWFkYWJsZVN0cmVhbTtcblxuICBhc3NlcnQoc3RyZWFtICE9PSB1bmRlZmluZWQpO1xuXG4gIHN0cmVhbS5fZGlzdHVyYmVkID0gdHJ1ZTtcblxuICBpZiAoc3RyZWFtLl9zdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICByZWFkUmVxdWVzdC5fY2xvc2VTdGVwcygpO1xuICB9IGVsc2UgaWYgKHN0cmVhbS5fc3RhdGUgPT09ICdlcnJvcmVkJykge1xuICAgIHJlYWRSZXF1ZXN0Ll9lcnJvclN0ZXBzKHN0cmVhbS5fc3RvcmVkRXJyb3IpO1xuICB9IGVsc2Uge1xuICAgIGFzc2VydChzdHJlYW0uX3N0YXRlID09PSAncmVhZGFibGUnKTtcbiAgICBzdHJlYW0uX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcltQdWxsU3RlcHNdKHJlYWRSZXF1ZXN0IGFzIFJlYWRSZXF1ZXN0PGFueT4pO1xuICB9XG59XG5cbi8vIEhlbHBlciBmdW5jdGlvbnMgZm9yIHRoZSBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIuXG5cbmZ1bmN0aW9uIGRlZmF1bHRSZWFkZXJCcmFuZENoZWNrRXhjZXB0aW9uKG5hbWU6IHN0cmluZyk6IFR5cGVFcnJvciB7XG4gIHJldHVybiBuZXcgVHlwZUVycm9yKFxuICAgIGBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIucHJvdG90eXBlLiR7bmFtZX0gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcmApO1xufVxuIiwgIi8vLyA8cmVmZXJlbmNlIGxpYj1cImVzMjAxOC5hc3luY2l0ZXJhYmxlXCIgLz5cblxuZXhwb3J0IGxldCBBc3luY0l0ZXJhdG9yUHJvdG90eXBlOiBBc3luY0l0ZXJhYmxlPGFueT4gfCB1bmRlZmluZWQ7XG5cbmlmICh0eXBlb2YgU3ltYm9sLmFzeW5jSXRlcmF0b3IgPT09ICdzeW1ib2wnKSB7XG4gIC8vIFdlJ3JlIHJ1bm5pbmcgaW5zaWRlIGEgRVMyMDE4KyBlbnZpcm9ubWVudCwgYnV0IHdlJ3JlIGNvbXBpbGluZyB0byBhbiBvbGRlciBzeW50YXguXG4gIC8vIFdlIGNhbm5vdCBhY2Nlc3MgJUFzeW5jSXRlcmF0b3JQcm90b3R5cGUlIHdpdGhvdXQgbm9uLUVTMjAxOCBzeW50YXgsIGJ1dCB3ZSBjYW4gcmUtY3JlYXRlIGl0LlxuICBBc3luY0l0ZXJhdG9yUHJvdG90eXBlID0ge1xuICAgIC8vIDI1LjEuMy4xICVBc3luY0l0ZXJhdG9yUHJvdG90eXBlJSBbIEBAYXN5bmNJdGVyYXRvciBdICggKVxuICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFzeW5jaXRlcmF0b3Jwcm90b3R5cGUtYXN5bmNpdGVyYXRvclxuICAgIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0odGhpczogQXN5bmNJdGVyYXRvcjxhbnk+KSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBc3luY0l0ZXJhdG9yUHJvdG90eXBlLCBTeW1ib2wuYXN5bmNJdGVyYXRvciwgeyBlbnVtZXJhYmxlOiBmYWxzZSB9KTtcbn1cbiIsICIvLy8gPHJlZmVyZW5jZSBsaWI9XCJlczIwMTguYXN5bmNpdGVyYWJsZVwiIC8+XG5cbmltcG9ydCB7IFJlYWRhYmxlU3RyZWFtIH0gZnJvbSAnLi4vcmVhZGFibGUtc3RyZWFtJztcbmltcG9ydCB7XG4gIEFjcXVpcmVSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIsXG4gIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcixcbiAgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyUmVhZCxcbiAgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZFJlc3VsdCxcbiAgUmVhZFJlcXVlc3Rcbn0gZnJvbSAnLi9kZWZhdWx0LXJlYWRlcic7XG5pbXBvcnQge1xuICBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNDYW5jZWwsXG4gIFJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY1JlbGVhc2UsXG4gIHJlYWRlckxvY2tFeGNlcHRpb25cbn0gZnJvbSAnLi9nZW5lcmljLXJlYWRlcic7XG5pbXBvcnQgYXNzZXJ0IGZyb20gJy4uLy4uL3N0dWIvYXNzZXJ0JztcbmltcG9ydCB7IEFzeW5jSXRlcmF0b3JQcm90b3R5cGUgfSBmcm9tICdAQHRhcmdldC9zdHViL2FzeW5jLWl0ZXJhdG9yLXByb3RvdHlwZSc7XG5pbXBvcnQgeyB0eXBlSXNPYmplY3QgfSBmcm9tICcuLi9oZWxwZXJzL21pc2NlbGxhbmVvdXMnO1xuaW1wb3J0IHtcbiAgbmV3UHJvbWlzZSxcbiAgcHJvbWlzZVJlamVjdGVkV2l0aCxcbiAgcHJvbWlzZVJlc29sdmVkV2l0aCxcbiAgcXVldWVNaWNyb3Rhc2ssXG4gIHRyYW5zZm9ybVByb21pc2VXaXRoXG59IGZyb20gJy4uL2hlbHBlcnMvd2ViaWRsJztcblxuLyoqXG4gKiBBbiBhc3luYyBpdGVyYXRvciByZXR1cm5lZCBieSB7QGxpbmsgUmVhZGFibGVTdHJlYW0udmFsdWVzfS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yPFI+IGV4dGVuZHMgQXN5bmNJdGVyYXRvcjxSPiB7XG4gIG5leHQoKTogUHJvbWlzZTxJdGVyYXRvclJlc3VsdDxSLCB1bmRlZmluZWQ+PjtcblxuICByZXR1cm4odmFsdWU/OiBhbnkpOiBQcm9taXNlPEl0ZXJhdG9yUmVzdWx0PGFueT4+O1xufVxuXG5leHBvcnQgY2xhc3MgUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9ySW1wbDxSPiB7XG4gIHByaXZhdGUgcmVhZG9ubHkgX3JlYWRlcjogUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyPFI+O1xuICBwcml2YXRlIHJlYWRvbmx5IF9wcmV2ZW50Q2FuY2VsOiBib29sZWFuO1xuICBwcml2YXRlIF9vbmdvaW5nUHJvbWlzZTogUHJvbWlzZTxSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkUmVzdWx0PFI+PiB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgcHJpdmF0ZSBfaXNGaW5pc2hlZCA9IGZhbHNlO1xuXG4gIGNvbnN0cnVjdG9yKHJlYWRlcjogUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyPFI+LCBwcmV2ZW50Q2FuY2VsOiBib29sZWFuKSB7XG4gICAgdGhpcy5fcmVhZGVyID0gcmVhZGVyO1xuICAgIHRoaXMuX3ByZXZlbnRDYW5jZWwgPSBwcmV2ZW50Q2FuY2VsO1xuICB9XG5cbiAgbmV4dCgpOiBQcm9taXNlPFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRSZXN1bHQ8Uj4+IHtcbiAgICBjb25zdCBuZXh0U3RlcHMgPSAoKSA9PiB0aGlzLl9uZXh0U3RlcHMoKTtcbiAgICB0aGlzLl9vbmdvaW5nUHJvbWlzZSA9IHRoaXMuX29uZ29pbmdQcm9taXNlID9cbiAgICAgIHRyYW5zZm9ybVByb21pc2VXaXRoKHRoaXMuX29uZ29pbmdQcm9taXNlLCBuZXh0U3RlcHMsIG5leHRTdGVwcykgOlxuICAgICAgbmV4dFN0ZXBzKCk7XG4gICAgcmV0dXJuIHRoaXMuX29uZ29pbmdQcm9taXNlO1xuICB9XG5cbiAgcmV0dXJuKHZhbHVlOiBhbnkpOiBQcm9taXNlPFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRSZXN1bHQ8YW55Pj4ge1xuICAgIGNvbnN0IHJldHVyblN0ZXBzID0gKCkgPT4gdGhpcy5fcmV0dXJuU3RlcHModmFsdWUpO1xuICAgIHJldHVybiB0aGlzLl9vbmdvaW5nUHJvbWlzZSA/XG4gICAgICB0cmFuc2Zvcm1Qcm9taXNlV2l0aCh0aGlzLl9vbmdvaW5nUHJvbWlzZSwgcmV0dXJuU3RlcHMsIHJldHVyblN0ZXBzKSA6XG4gICAgICByZXR1cm5TdGVwcygpO1xuICB9XG5cbiAgcHJpdmF0ZSBfbmV4dFN0ZXBzKCk6IFByb21pc2U8UmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZFJlc3VsdDxSPj4ge1xuICAgIGlmICh0aGlzLl9pc0ZpbmlzaGVkKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9KTtcbiAgICB9XG5cbiAgICBjb25zdCByZWFkZXIgPSB0aGlzLl9yZWFkZXI7XG4gICAgaWYgKHJlYWRlci5fb3duZXJSZWFkYWJsZVN0cmVhbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChyZWFkZXJMb2NrRXhjZXB0aW9uKCdpdGVyYXRlJykpO1xuICAgIH1cblxuICAgIGxldCByZXNvbHZlUHJvbWlzZSE6IChyZXN1bHQ6IFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRSZXN1bHQ8Uj4pID0+IHZvaWQ7XG4gICAgbGV0IHJlamVjdFByb21pc2UhOiAocmVhc29uOiBhbnkpID0+IHZvaWQ7XG4gICAgY29uc3QgcHJvbWlzZSA9IG5ld1Byb21pc2U8UmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZFJlc3VsdDxSPj4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgcmVzb2x2ZVByb21pc2UgPSByZXNvbHZlO1xuICAgICAgcmVqZWN0UHJvbWlzZSA9IHJlamVjdDtcbiAgICB9KTtcbiAgICBjb25zdCByZWFkUmVxdWVzdDogUmVhZFJlcXVlc3Q8Uj4gPSB7XG4gICAgICBfY2h1bmtTdGVwczogY2h1bmsgPT4ge1xuICAgICAgICB0aGlzLl9vbmdvaW5nUHJvbWlzZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgLy8gVGhpcyBuZWVkcyB0byBiZSBkZWxheWVkIGJ5IG9uZSBtaWNyb3Rhc2ssIG90aGVyd2lzZSB3ZSBzdG9wIHB1bGxpbmcgdG9vIGVhcmx5IHdoaWNoIGJyZWFrcyBhIHRlc3QuXG4gICAgICAgIC8vIEZJWE1FIElzIHRoaXMgYSBidWcgaW4gdGhlIHNwZWNpZmljYXRpb24sIG9yIGluIHRoZSB0ZXN0P1xuICAgICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiByZXNvbHZlUHJvbWlzZSh7IHZhbHVlOiBjaHVuaywgZG9uZTogZmFsc2UgfSkpO1xuICAgICAgfSxcbiAgICAgIF9jbG9zZVN0ZXBzOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuX29uZ29pbmdQcm9taXNlID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9pc0ZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljUmVsZWFzZShyZWFkZXIpO1xuICAgICAgICByZXNvbHZlUHJvbWlzZSh7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfSk7XG4gICAgICB9LFxuICAgICAgX2Vycm9yU3RlcHM6IHJlYXNvbiA9PiB7XG4gICAgICAgIHRoaXMuX29uZ29pbmdQcm9taXNlID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9pc0ZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljUmVsZWFzZShyZWFkZXIpO1xuICAgICAgICByZWplY3RQcm9taXNlKHJlYXNvbik7XG4gICAgICB9XG4gICAgfTtcbiAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXJSZWFkKHJlYWRlciwgcmVhZFJlcXVlc3QpO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG5cbiAgcHJpdmF0ZSBfcmV0dXJuU3RlcHModmFsdWU6IGFueSk6IFByb21pc2U8UmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZFJlc3VsdDxhbnk+PiB7XG4gICAgaWYgKHRoaXMuX2lzRmluaXNoZWQpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoeyB2YWx1ZSwgZG9uZTogdHJ1ZSB9KTtcbiAgICB9XG4gICAgdGhpcy5faXNGaW5pc2hlZCA9IHRydWU7XG5cbiAgICBjb25zdCByZWFkZXIgPSB0aGlzLl9yZWFkZXI7XG4gICAgaWYgKHJlYWRlci5fb3duZXJSZWFkYWJsZVN0cmVhbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChyZWFkZXJMb2NrRXhjZXB0aW9uKCdmaW5pc2ggaXRlcmF0aW5nJykpO1xuICAgIH1cblxuICAgIGFzc2VydChyZWFkZXIuX3JlYWRSZXF1ZXN0cy5sZW5ndGggPT09IDApO1xuXG4gICAgaWYgKCF0aGlzLl9wcmV2ZW50Q2FuY2VsKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNDYW5jZWwocmVhZGVyLCB2YWx1ZSk7XG4gICAgICBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNSZWxlYXNlKHJlYWRlcik7XG4gICAgICByZXR1cm4gdHJhbnNmb3JtUHJvbWlzZVdpdGgocmVzdWx0LCAoKSA9PiAoeyB2YWx1ZSwgZG9uZTogdHJ1ZSB9KSk7XG4gICAgfVxuXG4gICAgUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljUmVsZWFzZShyZWFkZXIpO1xuICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZWRXaXRoKHsgdmFsdWUsIGRvbmU6IHRydWUgfSk7XG4gIH1cbn1cblxuZGVjbGFyZSBjbGFzcyBSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3JJbnN0YW5jZTxSPiBpbXBsZW1lbnRzIFJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvcjxSPiB7XG4gIC8qKiBAaW50ZXJhbCAqL1xuICBfYXN5bmNJdGVyYXRvckltcGw6IFJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvckltcGw8Uj47XG5cbiAgbmV4dCgpOiBQcm9taXNlPEl0ZXJhdG9yUmVzdWx0PFIsIHVuZGVmaW5lZD4+O1xuXG4gIHJldHVybih2YWx1ZT86IGFueSk6IFByb21pc2U8SXRlcmF0b3JSZXN1bHQ8YW55Pj47XG59XG5cbmNvbnN0IFJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvclByb3RvdHlwZTogUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9ySW5zdGFuY2U8YW55PiA9IHtcbiAgbmV4dCh0aGlzOiBSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3JJbnN0YW5jZTxhbnk+KTogUHJvbWlzZTxSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkUmVzdWx0PGFueT4+IHtcbiAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yKHRoaXMpKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChzdHJlYW1Bc3luY0l0ZXJhdG9yQnJhbmRDaGVja0V4Y2VwdGlvbignbmV4dCcpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2FzeW5jSXRlcmF0b3JJbXBsLm5leHQoKTtcbiAgfSxcblxuICByZXR1cm4odGhpczogUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9ySW5zdGFuY2U8YW55PiwgdmFsdWU6IGFueSk6IFByb21pc2U8UmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZFJlc3VsdDxhbnk+PiB7XG4gICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvcih0aGlzKSkge1xuICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoc3RyZWFtQXN5bmNJdGVyYXRvckJyYW5kQ2hlY2tFeGNlcHRpb24oJ3JldHVybicpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2FzeW5jSXRlcmF0b3JJbXBsLnJldHVybih2YWx1ZSk7XG4gIH1cbn0gYXMgYW55O1xuaWYgKEFzeW5jSXRlcmF0b3JQcm90b3R5cGUgIT09IHVuZGVmaW5lZCkge1xuICBPYmplY3Quc2V0UHJvdG90eXBlT2YoUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yUHJvdG90eXBlLCBBc3luY0l0ZXJhdG9yUHJvdG90eXBlKTtcbn1cblxuLy8gQWJzdHJhY3Qgb3BlcmF0aW9ucyBmb3IgdGhlIFJlYWRhYmxlU3RyZWFtLlxuXG5leHBvcnQgZnVuY3Rpb24gQWNxdWlyZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvcjxSPihzdHJlYW06IFJlYWRhYmxlU3RyZWFtPFI+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldmVudENhbmNlbDogYm9vbGVhbik6IFJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvcjxSPiB7XG4gIGNvbnN0IHJlYWRlciA9IEFjcXVpcmVSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXI8Uj4oc3RyZWFtKTtcbiAgY29uc3QgaW1wbCA9IG5ldyBSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3JJbXBsKHJlYWRlciwgcHJldmVudENhbmNlbCk7XG4gIGNvbnN0IGl0ZXJhdG9yOiBSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3JJbnN0YW5jZTxSPiA9IE9iamVjdC5jcmVhdGUoUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yUHJvdG90eXBlKTtcbiAgaXRlcmF0b3IuX2FzeW5jSXRlcmF0b3JJbXBsID0gaW1wbDtcbiAgcmV0dXJuIGl0ZXJhdG9yO1xufVxuXG5mdW5jdGlvbiBJc1JlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvcjxSID0gYW55Pih4OiBhbnkpOiB4IGlzIFJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvcjxSPiB7XG4gIGlmICghdHlwZUlzT2JqZWN0KHgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ19hc3luY0l0ZXJhdG9ySW1wbCcpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdHJ5IHtcbiAgICAvLyBub2luc3BlY3Rpb24gU3VzcGljaW91c1R5cGVPZkd1YXJkXG4gICAgcmV0dXJuICh4IGFzIFJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvckluc3RhbmNlPGFueT4pLl9hc3luY0l0ZXJhdG9ySW1wbCBpbnN0YW5jZW9mXG4gICAgICBSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3JJbXBsO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLy8gSGVscGVyIGZ1bmN0aW9ucyBmb3IgdGhlIFJlYWRhYmxlU3RyZWFtLlxuXG5mdW5jdGlvbiBzdHJlYW1Bc3luY0l0ZXJhdG9yQnJhbmRDaGVja0V4Y2VwdGlvbihuYW1lOiBzdHJpbmcpOiBUeXBlRXJyb3Ige1xuICByZXR1cm4gbmV3IFR5cGVFcnJvcihgUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yLiR7bmFtZX0gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIFJlYWRhYmxlU3RlYW1Bc3luY0l0ZXJhdG9yYCk7XG59XG4iLCAiLy8vIDxyZWZlcmVuY2UgbGliPVwiZXMyMDE1LmNvcmVcIiAvPlxuXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9OdW1iZXIvaXNOYU4jUG9seWZpbGxcbmNvbnN0IE51bWJlcklzTmFOOiB0eXBlb2YgTnVtYmVyLmlzTmFOID0gTnVtYmVyLmlzTmFOIHx8IGZ1bmN0aW9uICh4KSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgcmV0dXJuIHggIT09IHg7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBOdW1iZXJJc05hTjtcbiIsICJleHBvcnQgZnVuY3Rpb24gQ3JlYXRlQXJyYXlGcm9tTGlzdDxUIGV4dGVuZHMgYW55W10+KGVsZW1lbnRzOiBUKTogVCB7XG4gIC8vIFdlIHVzZSBhcnJheXMgdG8gcmVwcmVzZW50IGxpc3RzLCBzbyB0aGlzIGlzIGJhc2ljYWxseSBhIG5vLW9wLlxuICAvLyBEbyBhIHNsaWNlIHRob3VnaCBqdXN0IGluIGNhc2Ugd2UgaGFwcGVuIHRvIGRlcGVuZCBvbiB0aGUgdW5pcXVlLW5lc3MuXG4gIHJldHVybiBlbGVtZW50cy5zbGljZSgpIGFzIFQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBDb3B5RGF0YUJsb2NrQnl0ZXMoZGVzdDogQXJyYXlCdWZmZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlc3RPZmZzZXQ6IG51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjOiBBcnJheUJ1ZmZlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjT2Zmc2V0OiBudW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG46IG51bWJlcikge1xuICBuZXcgVWludDhBcnJheShkZXN0KS5zZXQobmV3IFVpbnQ4QXJyYXkoc3JjLCBzcmNPZmZzZXQsIG4pLCBkZXN0T2Zmc2V0KTtcbn1cblxuLy8gTm90IGltcGxlbWVudGVkIGNvcnJlY3RseVxuZXhwb3J0IGZ1bmN0aW9uIFRyYW5zZmVyQXJyYXlCdWZmZXI8VCBleHRlbmRzIEFycmF5QnVmZmVyTGlrZT4oTzogVCk6IFQge1xuICByZXR1cm4gTztcbn1cblxuLy8gTm90IGltcGxlbWVudGVkIGNvcnJlY3RseVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuZXhwb3J0IGZ1bmN0aW9uIENhblRyYW5zZmVyQXJyYXlCdWZmZXIoTzogQXJyYXlCdWZmZXJMaWtlKTogYm9vbGVhbiB7XG4gIHJldHVybiB0cnVlO1xufVxuXG4vLyBOb3QgaW1wbGVtZW50ZWQgY29ycmVjdGx5XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG5leHBvcnQgZnVuY3Rpb24gSXNEZXRhY2hlZEJ1ZmZlcihPOiBBcnJheUJ1ZmZlckxpa2UpOiBib29sZWFuIHtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gQXJyYXlCdWZmZXJTbGljZShidWZmZXI6IEFycmF5QnVmZmVyTGlrZSwgYmVnaW46IG51bWJlciwgZW5kOiBudW1iZXIpOiBBcnJheUJ1ZmZlckxpa2Uge1xuICAvLyBBcnJheUJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgaXMgbm90IGF2YWlsYWJsZSBvbiBJRTEwXG4gIC8vIGh0dHBzOi8vd3d3LmNhbml1c2UuY29tL21kbi1qYXZhc2NyaXB0X2J1aWx0aW5zX2FycmF5YnVmZmVyX3NsaWNlXG4gIGlmIChidWZmZXIuc2xpY2UpIHtcbiAgICByZXR1cm4gYnVmZmVyLnNsaWNlKGJlZ2luLCBlbmQpO1xuICB9XG4gIGNvbnN0IGxlbmd0aCA9IGVuZCAtIGJlZ2luO1xuICBjb25zdCBzbGljZSA9IG5ldyBBcnJheUJ1ZmZlcihsZW5ndGgpO1xuICBDb3B5RGF0YUJsb2NrQnl0ZXMoc2xpY2UsIDAsIGJ1ZmZlciwgYmVnaW4sIGxlbmd0aCk7XG4gIHJldHVybiBzbGljZTtcbn1cbiIsICJpbXBvcnQgTnVtYmVySXNOYU4gZnJvbSAnLi4vLi4vc3R1Yi9udW1iZXItaXNuYW4nO1xuaW1wb3J0IHsgQXJyYXlCdWZmZXJTbGljZSB9IGZyb20gJy4vZWNtYXNjcmlwdCc7XG5cbmV4cG9ydCBmdW5jdGlvbiBJc05vbk5lZ2F0aXZlTnVtYmVyKHY6IG51bWJlcik6IGJvb2xlYW4ge1xuICBpZiAodHlwZW9mIHYgIT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKE51bWJlcklzTmFOKHYpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHYgPCAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBDbG9uZUFzVWludDhBcnJheShPOiBBcnJheUJ1ZmZlclZpZXcpOiBVaW50OEFycmF5IHtcbiAgY29uc3QgYnVmZmVyID0gQXJyYXlCdWZmZXJTbGljZShPLmJ1ZmZlciwgTy5ieXRlT2Zmc2V0LCBPLmJ5dGVPZmZzZXQgKyBPLmJ5dGVMZW5ndGgpO1xuICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbn1cbiIsICJpbXBvcnQgYXNzZXJ0IGZyb20gJy4uLy4uL3N0dWIvYXNzZXJ0JztcbmltcG9ydCB7IFNpbXBsZVF1ZXVlIH0gZnJvbSAnLi4vc2ltcGxlLXF1ZXVlJztcbmltcG9ydCB7IElzTm9uTmVnYXRpdmVOdW1iZXIgfSBmcm9tICcuL21pc2NlbGxhbmVvdXMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFF1ZXVlQ29udGFpbmVyPFQ+IHtcbiAgX3F1ZXVlOiBTaW1wbGVRdWV1ZTxUPjtcbiAgX3F1ZXVlVG90YWxTaXplOiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUXVldWVQYWlyPFQ+IHtcbiAgdmFsdWU6IFQ7XG4gIHNpemU6IG51bWJlcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIERlcXVldWVWYWx1ZTxUPihjb250YWluZXI6IFF1ZXVlQ29udGFpbmVyPFF1ZXVlUGFpcjxUPj4pOiBUIHtcbiAgYXNzZXJ0KCdfcXVldWUnIGluIGNvbnRhaW5lciAmJiAnX3F1ZXVlVG90YWxTaXplJyBpbiBjb250YWluZXIpO1xuICBhc3NlcnQoY29udGFpbmVyLl9xdWV1ZS5sZW5ndGggPiAwKTtcblxuICBjb25zdCBwYWlyID0gY29udGFpbmVyLl9xdWV1ZS5zaGlmdCgpITtcbiAgY29udGFpbmVyLl9xdWV1ZVRvdGFsU2l6ZSAtPSBwYWlyLnNpemU7XG4gIGlmIChjb250YWluZXIuX3F1ZXVlVG90YWxTaXplIDwgMCkge1xuICAgIGNvbnRhaW5lci5fcXVldWVUb3RhbFNpemUgPSAwO1xuICB9XG5cbiAgcmV0dXJuIHBhaXIudmFsdWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBFbnF1ZXVlVmFsdWVXaXRoU2l6ZTxUPihjb250YWluZXI6IFF1ZXVlQ29udGFpbmVyPFF1ZXVlUGFpcjxUPj4sIHZhbHVlOiBULCBzaXplOiBudW1iZXIpIHtcbiAgYXNzZXJ0KCdfcXVldWUnIGluIGNvbnRhaW5lciAmJiAnX3F1ZXVlVG90YWxTaXplJyBpbiBjb250YWluZXIpO1xuXG4gIGlmICghSXNOb25OZWdhdGl2ZU51bWJlcihzaXplKSB8fCBzaXplID09PSBJbmZpbml0eSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdTaXplIG11c3QgYmUgYSBmaW5pdGUsIG5vbi1OYU4sIG5vbi1uZWdhdGl2ZSBudW1iZXIuJyk7XG4gIH1cblxuICBjb250YWluZXIuX3F1ZXVlLnB1c2goeyB2YWx1ZSwgc2l6ZSB9KTtcbiAgY29udGFpbmVyLl9xdWV1ZVRvdGFsU2l6ZSArPSBzaXplO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gUGVla1F1ZXVlVmFsdWU8VD4oY29udGFpbmVyOiBRdWV1ZUNvbnRhaW5lcjxRdWV1ZVBhaXI8VD4+KTogVCB7XG4gIGFzc2VydCgnX3F1ZXVlJyBpbiBjb250YWluZXIgJiYgJ19xdWV1ZVRvdGFsU2l6ZScgaW4gY29udGFpbmVyKTtcbiAgYXNzZXJ0KGNvbnRhaW5lci5fcXVldWUubGVuZ3RoID4gMCk7XG5cbiAgY29uc3QgcGFpciA9IGNvbnRhaW5lci5fcXVldWUucGVlaygpO1xuICByZXR1cm4gcGFpci52YWx1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFJlc2V0UXVldWU8VD4oY29udGFpbmVyOiBRdWV1ZUNvbnRhaW5lcjxUPikge1xuICBhc3NlcnQoJ19xdWV1ZScgaW4gY29udGFpbmVyICYmICdfcXVldWVUb3RhbFNpemUnIGluIGNvbnRhaW5lcik7XG5cbiAgY29udGFpbmVyLl9xdWV1ZSA9IG5ldyBTaW1wbGVRdWV1ZTxUPigpO1xuICBjb250YWluZXIuX3F1ZXVlVG90YWxTaXplID0gMDtcbn1cbiIsICJpbXBvcnQgYXNzZXJ0IGZyb20gJy4uLy4uL3N0dWIvYXNzZXJ0JztcbmltcG9ydCB7IFNpbXBsZVF1ZXVlIH0gZnJvbSAnLi4vc2ltcGxlLXF1ZXVlJztcbmltcG9ydCB7IFJlc2V0UXVldWUgfSBmcm9tICcuLi9hYnN0cmFjdC1vcHMvcXVldWUtd2l0aC1zaXplcyc7XG5pbXBvcnQge1xuICBSZWFkYWJsZVN0cmVhbUFkZFJlYWRSZXF1ZXN0LFxuICBSZWFkYWJsZVN0cmVhbUZ1bGZpbGxSZWFkUmVxdWVzdCxcbiAgUmVhZGFibGVTdHJlYW1HZXROdW1SZWFkUmVxdWVzdHMsXG4gIFJlYWRhYmxlU3RyZWFtSGFzRGVmYXVsdFJlYWRlcixcbiAgUmVhZFJlcXVlc3Rcbn0gZnJvbSAnLi9kZWZhdWx0LXJlYWRlcic7XG5pbXBvcnQge1xuICBSZWFkYWJsZVN0cmVhbUFkZFJlYWRJbnRvUmVxdWVzdCxcbiAgUmVhZGFibGVTdHJlYW1GdWxmaWxsUmVhZEludG9SZXF1ZXN0LFxuICBSZWFkYWJsZVN0cmVhbUdldE51bVJlYWRJbnRvUmVxdWVzdHMsXG4gIFJlYWRhYmxlU3RyZWFtSGFzQllPQlJlYWRlcixcbiAgUmVhZEludG9SZXF1ZXN0XG59IGZyb20gJy4vYnlvYi1yZWFkZXInO1xuaW1wb3J0IE51bWJlcklzSW50ZWdlciBmcm9tICcuLi8uLi9zdHViL251bWJlci1pc2ludGVnZXInO1xuaW1wb3J0IHtcbiAgSXNSZWFkYWJsZVN0cmVhbUxvY2tlZCxcbiAgUmVhZGFibGVCeXRlU3RyZWFtLFxuICBSZWFkYWJsZVN0cmVhbUNsb3NlLFxuICBSZWFkYWJsZVN0cmVhbUVycm9yXG59IGZyb20gJy4uL3JlYWRhYmxlLXN0cmVhbSc7XG5pbXBvcnQgeyBWYWxpZGF0ZWRVbmRlcmx5aW5nQnl0ZVNvdXJjZSB9IGZyb20gJy4vdW5kZXJseWluZy1zb3VyY2UnO1xuaW1wb3J0IHsgdHlwZUlzT2JqZWN0IH0gZnJvbSAnLi4vaGVscGVycy9taXNjZWxsYW5lb3VzJztcbmltcG9ydCB7XG4gIEFycmF5QnVmZmVyU2xpY2UsXG4gIENhblRyYW5zZmVyQXJyYXlCdWZmZXIsXG4gIENvcHlEYXRhQmxvY2tCeXRlcyxcbiAgSXNEZXRhY2hlZEJ1ZmZlcixcbiAgVHJhbnNmZXJBcnJheUJ1ZmZlclxufSBmcm9tICcuLi9hYnN0cmFjdC1vcHMvZWNtYXNjcmlwdCc7XG5pbXBvcnQgeyBDYW5jZWxTdGVwcywgUHVsbFN0ZXBzIH0gZnJvbSAnLi4vYWJzdHJhY3Qtb3BzL2ludGVybmFsLW1ldGhvZHMnO1xuaW1wb3J0IHsgcHJvbWlzZVJlc29sdmVkV2l0aCwgdXBvblByb21pc2UgfSBmcm9tICcuLi9oZWxwZXJzL3dlYmlkbCc7XG5pbXBvcnQgeyBhc3NlcnRSZXF1aXJlZEFyZ3VtZW50LCBjb252ZXJ0VW5zaWduZWRMb25nTG9uZ1dpdGhFbmZvcmNlUmFuZ2UgfSBmcm9tICcuLi92YWxpZGF0b3JzL2Jhc2ljJztcblxuLyoqXG4gKiBBIHB1bGwtaW50byByZXF1ZXN0IGluIGEge0BsaW5rIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJ9LlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNsYXNzIFJlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3Qge1xuICAvKiogQGludGVybmFsICovXG4gIF9hc3NvY2lhdGVkUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlciE6IFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXI7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3ZpZXchOiBBcnJheUJ1ZmZlclZpZXcgfCBudWxsO1xuXG4gIHByaXZhdGUgY29uc3RydWN0b3IoKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSWxsZWdhbCBjb25zdHJ1Y3RvcicpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHZpZXcgZm9yIHdyaXRpbmcgaW4gdG8sIG9yIGBudWxsYCBpZiB0aGUgQllPQiByZXF1ZXN0IGhhcyBhbHJlYWR5IGJlZW4gcmVzcG9uZGVkIHRvLlxuICAgKi9cbiAgZ2V0IHZpZXcoKTogQXJyYXlCdWZmZXJWaWV3IHwgbnVsbCB7XG4gICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QodGhpcykpIHtcbiAgICAgIHRocm93IGJ5b2JSZXF1ZXN0QnJhbmRDaGVja0V4Y2VwdGlvbigndmlldycpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl92aWV3O1xuICB9XG5cbiAgLyoqXG4gICAqIEluZGljYXRlcyB0byB0aGUgYXNzb2NpYXRlZCByZWFkYWJsZSBieXRlIHN0cmVhbSB0aGF0IGBieXRlc1dyaXR0ZW5gIGJ5dGVzIHdlcmUgd3JpdHRlbiBpbnRvXG4gICAqIHtAbGluayBSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0LnZpZXcgfCB2aWV3fSwgY2F1c2luZyB0aGUgcmVzdWx0IGJlIHN1cmZhY2VkIHRvIHRoZSBjb25zdW1lci5cbiAgICpcbiAgICogQWZ0ZXIgdGhpcyBtZXRob2QgaXMgY2FsbGVkLCB7QGxpbmsgUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdC52aWV3IHwgdmlld30gd2lsbCBiZSB0cmFuc2ZlcnJlZCBhbmQgbm8gbG9uZ2VyXG4gICAqIG1vZGlmaWFibGUuXG4gICAqL1xuICByZXNwb25kKGJ5dGVzV3JpdHRlbjogbnVtYmVyKTogdm9pZDtcbiAgcmVzcG9uZChieXRlc1dyaXR0ZW46IG51bWJlciB8IHVuZGVmaW5lZCk6IHZvaWQge1xuICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0KHRoaXMpKSB7XG4gICAgICB0aHJvdyBieW9iUmVxdWVzdEJyYW5kQ2hlY2tFeGNlcHRpb24oJ3Jlc3BvbmQnKTtcbiAgICB9XG4gICAgYXNzZXJ0UmVxdWlyZWRBcmd1bWVudChieXRlc1dyaXR0ZW4sIDEsICdyZXNwb25kJyk7XG4gICAgYnl0ZXNXcml0dGVuID0gY29udmVydFVuc2lnbmVkTG9uZ0xvbmdXaXRoRW5mb3JjZVJhbmdlKGJ5dGVzV3JpdHRlbiwgJ0ZpcnN0IHBhcmFtZXRlcicpO1xuXG4gICAgaWYgKHRoaXMuX2Fzc29jaWF0ZWRSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoaXMgQllPQiByZXF1ZXN0IGhhcyBiZWVuIGludmFsaWRhdGVkJyk7XG4gICAgfVxuXG4gICAgaWYgKElzRGV0YWNoZWRCdWZmZXIodGhpcy5fdmlldyEuYnVmZmVyKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIEJZT0IgcmVxdWVzdCdzIGJ1ZmZlciBoYXMgYmVlbiBkZXRhY2hlZCBhbmQgc28gY2Fubm90IGJlIHVzZWQgYXMgYSByZXNwb25zZWApO1xuICAgIH1cblxuICAgIGFzc2VydCh0aGlzLl92aWV3IS5ieXRlTGVuZ3RoID4gMCk7XG4gICAgYXNzZXJ0KHRoaXMuX3ZpZXchLmJ1ZmZlci5ieXRlTGVuZ3RoID4gMCk7XG5cbiAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZCh0aGlzLl9hc3NvY2lhdGVkUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlciwgYnl0ZXNXcml0dGVuKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgdG8gdGhlIGFzc29jaWF0ZWQgcmVhZGFibGUgYnl0ZSBzdHJlYW0gdGhhdCBpbnN0ZWFkIG9mIHdyaXRpbmcgaW50b1xuICAgKiB7QGxpbmsgUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdC52aWV3IHwgdmlld30sIHRoZSB1bmRlcmx5aW5nIGJ5dGUgc291cmNlIGlzIHByb3ZpZGluZyBhIG5ldyBgQXJyYXlCdWZmZXJWaWV3YCxcbiAgICogd2hpY2ggd2lsbCBiZSBnaXZlbiB0byB0aGUgY29uc3VtZXIgb2YgdGhlIHJlYWRhYmxlIGJ5dGUgc3RyZWFtLlxuICAgKlxuICAgKiBBZnRlciB0aGlzIG1ldGhvZCBpcyBjYWxsZWQsIGB2aWV3YCB3aWxsIGJlIHRyYW5zZmVycmVkIGFuZCBubyBsb25nZXIgbW9kaWZpYWJsZS5cbiAgICovXG4gIHJlc3BvbmRXaXRoTmV3Vmlldyh2aWV3OiBBcnJheUJ1ZmZlclZpZXcpOiB2b2lkO1xuICByZXNwb25kV2l0aE5ld1ZpZXcodmlldzogQXJyYXlCdWZmZXJWaWV3IHwgdW5kZWZpbmVkKTogdm9pZCB7XG4gICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QodGhpcykpIHtcbiAgICAgIHRocm93IGJ5b2JSZXF1ZXN0QnJhbmRDaGVja0V4Y2VwdGlvbigncmVzcG9uZFdpdGhOZXdWaWV3Jyk7XG4gICAgfVxuICAgIGFzc2VydFJlcXVpcmVkQXJndW1lbnQodmlldywgMSwgJ3Jlc3BvbmRXaXRoTmV3VmlldycpO1xuXG4gICAgaWYgKCFBcnJheUJ1ZmZlci5pc1ZpZXcodmlldykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1lvdSBjYW4gb25seSByZXNwb25kIHdpdGggYXJyYXkgYnVmZmVyIHZpZXdzJyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2Fzc29jaWF0ZWRSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoaXMgQllPQiByZXF1ZXN0IGhhcyBiZWVuIGludmFsaWRhdGVkJyk7XG4gICAgfVxuXG4gICAgaWYgKElzRGV0YWNoZWRCdWZmZXIodmlldy5idWZmZXIpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgZ2l2ZW4gdmlld1xcJ3MgYnVmZmVyIGhhcyBiZWVuIGRldGFjaGVkIGFuZCBzbyBjYW5ub3QgYmUgdXNlZCBhcyBhIHJlc3BvbnNlJyk7XG4gICAgfVxuXG4gICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmRXaXRoTmV3Vmlldyh0aGlzLl9hc3NvY2lhdGVkUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlciwgdmlldyk7XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdC5wcm90b3R5cGUsIHtcbiAgcmVzcG9uZDogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gIHJlc3BvbmRXaXRoTmV3VmlldzogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gIHZpZXc6IHsgZW51bWVyYWJsZTogdHJ1ZSB9XG59KTtcbmlmICh0eXBlb2YgU3ltYm9sLnRvU3RyaW5nVGFnID09PSAnc3ltYm9sJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdC5wcm90b3R5cGUsIFN5bWJvbC50b1N0cmluZ1RhZywge1xuICAgIHZhbHVlOiAnUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdCcsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG5pbnRlcmZhY2UgQXJyYXlCdWZmZXJWaWV3Q29uc3RydWN0b3I8VCBleHRlbmRzIEFycmF5QnVmZmVyVmlldyA9IEFycmF5QnVmZmVyVmlldz4ge1xuICBuZXcoYnVmZmVyOiBBcnJheUJ1ZmZlckxpa2UsIGJ5dGVPZmZzZXQ6IG51bWJlciwgbGVuZ3RoPzogbnVtYmVyKTogVDtcblxuICByZWFkb25seSBwcm90b3R5cGU6IFQ7XG4gIHJlYWRvbmx5IEJZVEVTX1BFUl9FTEVNRU5UOiBudW1iZXI7XG59XG5cbmludGVyZmFjZSBCeXRlUXVldWVFbGVtZW50IHtcbiAgYnVmZmVyOiBBcnJheUJ1ZmZlckxpa2U7XG4gIGJ5dGVPZmZzZXQ6IG51bWJlcjtcbiAgYnl0ZUxlbmd0aDogbnVtYmVyO1xufVxuXG50eXBlIFB1bGxJbnRvRGVzY3JpcHRvcjxUIGV4dGVuZHMgQXJyYXlCdWZmZXJWaWV3ID0gQXJyYXlCdWZmZXJWaWV3PiA9XG4gIERlZmF1bHRQdWxsSW50b0Rlc2NyaXB0b3JcbiAgfCBCWU9CUHVsbEludG9EZXNjcmlwdG9yPFQ+O1xuXG5pbnRlcmZhY2UgRGVmYXVsdFB1bGxJbnRvRGVzY3JpcHRvciB7XG4gIGJ1ZmZlcjogQXJyYXlCdWZmZXJMaWtlO1xuICBidWZmZXJCeXRlTGVuZ3RoOiBudW1iZXI7XG4gIGJ5dGVPZmZzZXQ6IG51bWJlcjtcbiAgYnl0ZUxlbmd0aDogbnVtYmVyO1xuICBieXRlc0ZpbGxlZDogbnVtYmVyO1xuICBlbGVtZW50U2l6ZTogbnVtYmVyO1xuICB2aWV3Q29uc3RydWN0b3I6IEFycmF5QnVmZmVyVmlld0NvbnN0cnVjdG9yPFVpbnQ4QXJyYXk+O1xuICByZWFkZXJUeXBlOiAnZGVmYXVsdCc7XG59XG5cbmludGVyZmFjZSBCWU9CUHVsbEludG9EZXNjcmlwdG9yPFQgZXh0ZW5kcyBBcnJheUJ1ZmZlclZpZXcgPSBBcnJheUJ1ZmZlclZpZXc+IHtcbiAgYnVmZmVyOiBBcnJheUJ1ZmZlckxpa2U7XG4gIGJ1ZmZlckJ5dGVMZW5ndGg6IG51bWJlcjtcbiAgYnl0ZU9mZnNldDogbnVtYmVyO1xuICBieXRlTGVuZ3RoOiBudW1iZXI7XG4gIGJ5dGVzRmlsbGVkOiBudW1iZXI7XG4gIGVsZW1lbnRTaXplOiBudW1iZXI7XG4gIHZpZXdDb25zdHJ1Y3RvcjogQXJyYXlCdWZmZXJWaWV3Q29uc3RydWN0b3I8VD47XG4gIHJlYWRlclR5cGU6ICdieW9iJztcbn1cblxuLyoqXG4gKiBBbGxvd3MgY29udHJvbCBvZiBhIHtAbGluayBSZWFkYWJsZVN0cmVhbSB8IHJlYWRhYmxlIGJ5dGUgc3RyZWFtfSdzIHN0YXRlIGFuZCBpbnRlcm5hbCBxdWV1ZS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyIHtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbSE6IFJlYWRhYmxlQnl0ZVN0cmVhbTtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfcXVldWUhOiBTaW1wbGVRdWV1ZTxCeXRlUXVldWVFbGVtZW50PjtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfcXVldWVUb3RhbFNpemUhOiBudW1iZXI7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3N0YXJ0ZWQhOiBib29sZWFuO1xuICAvKiogQGludGVybmFsICovXG4gIF9jbG9zZVJlcXVlc3RlZCE6IGJvb2xlYW47XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3B1bGxBZ2FpbiE6IGJvb2xlYW47XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3B1bGxpbmcgITogYm9vbGVhbjtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfc3RyYXRlZ3lIV00hOiBudW1iZXI7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3B1bGxBbGdvcml0aG0hOiAoKSA9PiBQcm9taXNlPHZvaWQ+O1xuICAvKiogQGludGVybmFsICovXG4gIF9jYW5jZWxBbGdvcml0aG0hOiAocmVhc29uOiBhbnkpID0+IFByb21pc2U8dm9pZD47XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2F1dG9BbGxvY2F0ZUNodW5rU2l6ZTogbnVtYmVyIHwgdW5kZWZpbmVkO1xuICAvKiogQGludGVybmFsICovXG4gIF9ieW9iUmVxdWVzdDogUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdCB8IG51bGw7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3BlbmRpbmdQdWxsSW50b3MhOiBTaW1wbGVRdWV1ZTxQdWxsSW50b0Rlc2NyaXB0b3I+O1xuXG4gIHByaXZhdGUgY29uc3RydWN0b3IoKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSWxsZWdhbCBjb25zdHJ1Y3RvcicpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgQllPQiBwdWxsIHJlcXVlc3QsIG9yIGBudWxsYCBpZiB0aGVyZSBpc24ndCBvbmUuXG4gICAqL1xuICBnZXQgYnlvYlJlcXVlc3QoKTogUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdCB8IG51bGwge1xuICAgIGlmICghSXNSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyKHRoaXMpKSB7XG4gICAgICB0aHJvdyBieXRlU3RyZWFtQ29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ2J5b2JSZXF1ZXN0Jyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJHZXRCWU9CUmVxdWVzdCh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBkZXNpcmVkIHNpemUgdG8gZmlsbCB0aGUgY29udHJvbGxlZCBzdHJlYW0ncyBpbnRlcm5hbCBxdWV1ZS4gSXQgY2FuIGJlIG5lZ2F0aXZlLCBpZiB0aGUgcXVldWUgaXNcbiAgICogb3Zlci1mdWxsLiBBbiB1bmRlcmx5aW5nIGJ5dGUgc291cmNlIG91Z2h0IHRvIHVzZSB0aGlzIGluZm9ybWF0aW9uIHRvIGRldGVybWluZSB3aGVuIGFuZCBob3cgdG8gYXBwbHkgYmFja3ByZXNzdXJlLlxuICAgKi9cbiAgZ2V0IGRlc2lyZWRTaXplKCk6IG51bWJlciB8IG51bGwge1xuICAgIGlmICghSXNSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyKHRoaXMpKSB7XG4gICAgICB0aHJvdyBieXRlU3RyZWFtQ29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ2Rlc2lyZWRTaXplJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJHZXREZXNpcmVkU2l6ZSh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9zZXMgdGhlIGNvbnRyb2xsZWQgcmVhZGFibGUgc3RyZWFtLiBDb25zdW1lcnMgd2lsbCBzdGlsbCBiZSBhYmxlIHRvIHJlYWQgYW55IHByZXZpb3VzbHktZW5xdWV1ZWQgY2h1bmtzIGZyb21cbiAgICogdGhlIHN0cmVhbSwgYnV0IG9uY2UgdGhvc2UgYXJlIHJlYWQsIHRoZSBzdHJlYW0gd2lsbCBiZWNvbWUgY2xvc2VkLlxuICAgKi9cbiAgY2xvc2UoKTogdm9pZCB7XG4gICAgaWYgKCFJc1JlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIodGhpcykpIHtcbiAgICAgIHRocm93IGJ5dGVTdHJlYW1Db250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbignY2xvc2UnKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fY2xvc2VSZXF1ZXN0ZWQpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBzdHJlYW0gaGFzIGFscmVhZHkgYmVlbiBjbG9zZWQ7IGRvIG5vdCBjbG9zZSBpdCBhZ2FpbiEnKTtcbiAgICB9XG5cbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW0uX3N0YXRlO1xuICAgIGlmIChzdGF0ZSAhPT0gJ3JlYWRhYmxlJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIHN0cmVhbSAoaW4gJHtzdGF0ZX0gc3RhdGUpIGlzIG5vdCBpbiB0aGUgcmVhZGFibGUgc3RhdGUgYW5kIGNhbm5vdCBiZSBjbG9zZWRgKTtcbiAgICB9XG5cbiAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2xvc2UodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogRW5xdWV1ZXMgdGhlIGdpdmVuIGNodW5rIGNodW5rIGluIHRoZSBjb250cm9sbGVkIHJlYWRhYmxlIHN0cmVhbS5cbiAgICogVGhlIGNodW5rIGhhcyB0byBiZSBhbiBgQXJyYXlCdWZmZXJWaWV3YCBpbnN0YW5jZSwgb3IgZWxzZSBhIGBUeXBlRXJyb3JgIHdpbGwgYmUgdGhyb3duLlxuICAgKi9cbiAgZW5xdWV1ZShjaHVuazogQXJyYXlCdWZmZXJWaWV3KTogdm9pZDtcbiAgZW5xdWV1ZShjaHVuazogQXJyYXlCdWZmZXJWaWV3IHwgdW5kZWZpbmVkKTogdm9pZCB7XG4gICAgaWYgKCFJc1JlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIodGhpcykpIHtcbiAgICAgIHRocm93IGJ5dGVTdHJlYW1Db250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbignZW5xdWV1ZScpO1xuICAgIH1cblxuICAgIGFzc2VydFJlcXVpcmVkQXJndW1lbnQoY2h1bmssIDEsICdlbnF1ZXVlJyk7XG4gICAgaWYgKCFBcnJheUJ1ZmZlci5pc1ZpZXcoY2h1bmspKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjaHVuayBtdXN0IGJlIGFuIGFycmF5IGJ1ZmZlciB2aWV3Jyk7XG4gICAgfVxuICAgIGlmIChjaHVuay5ieXRlTGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjaHVuayBtdXN0IGhhdmUgbm9uLXplcm8gYnl0ZUxlbmd0aCcpO1xuICAgIH1cbiAgICBpZiAoY2h1bmsuYnVmZmVyLmJ5dGVMZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGNodW5rJ3MgYnVmZmVyIG11c3QgaGF2ZSBub24temVybyBieXRlTGVuZ3RoYCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2Nsb3NlUmVxdWVzdGVkKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdzdHJlYW0gaXMgY2xvc2VkIG9yIGRyYWluaW5nJyk7XG4gICAgfVxuXG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtLl9zdGF0ZTtcbiAgICBpZiAoc3RhdGUgIT09ICdyZWFkYWJsZScpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBzdHJlYW0gKGluICR7c3RhdGV9IHN0YXRlKSBpcyBub3QgaW4gdGhlIHJlYWRhYmxlIHN0YXRlIGFuZCBjYW5ub3QgYmUgZW5xdWV1ZWQgdG9gKTtcbiAgICB9XG5cbiAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRW5xdWV1ZSh0aGlzLCBjaHVuayk7XG4gIH1cblxuICAvKipcbiAgICogRXJyb3JzIHRoZSBjb250cm9sbGVkIHJlYWRhYmxlIHN0cmVhbSwgbWFraW5nIGFsbCBmdXR1cmUgaW50ZXJhY3Rpb25zIHdpdGggaXQgZmFpbCB3aXRoIHRoZSBnaXZlbiBlcnJvciBgZWAuXG4gICAqL1xuICBlcnJvcihlOiBhbnkgPSB1bmRlZmluZWQpOiB2b2lkIHtcbiAgICBpZiAoIUlzUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcih0aGlzKSkge1xuICAgICAgdGhyb3cgYnl0ZVN0cmVhbUNvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdlcnJvcicpO1xuICAgIH1cblxuICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFcnJvcih0aGlzLCBlKTtcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgW0NhbmNlbFN0ZXBzXShyZWFzb246IGFueSk6IFByb21pc2U8dm9pZD4ge1xuICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDbGVhclBlbmRpbmdQdWxsSW50b3ModGhpcyk7XG5cbiAgICBSZXNldFF1ZXVlKHRoaXMpO1xuXG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fY2FuY2VsQWxnb3JpdGhtKHJlYXNvbik7XG4gICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyh0aGlzKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBbUHVsbFN0ZXBzXShyZWFkUmVxdWVzdDogUmVhZFJlcXVlc3Q8VWludDhBcnJheT4pOiB2b2lkIHtcbiAgICBjb25zdCBzdHJlYW0gPSB0aGlzLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtO1xuICAgIGFzc2VydChSZWFkYWJsZVN0cmVhbUhhc0RlZmF1bHRSZWFkZXIoc3RyZWFtKSk7XG5cbiAgICBpZiAodGhpcy5fcXVldWVUb3RhbFNpemUgPiAwKSB7XG4gICAgICBhc3NlcnQoUmVhZGFibGVTdHJlYW1HZXROdW1SZWFkUmVxdWVzdHMoc3RyZWFtKSA9PT0gMCk7XG5cbiAgICAgIGNvbnN0IGVudHJ5ID0gdGhpcy5fcXVldWUuc2hpZnQoKSE7XG4gICAgICB0aGlzLl9xdWV1ZVRvdGFsU2l6ZSAtPSBlbnRyeS5ieXRlTGVuZ3RoO1xuXG4gICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVySGFuZGxlUXVldWVEcmFpbih0aGlzKTtcblxuICAgICAgY29uc3QgdmlldyA9IG5ldyBVaW50OEFycmF5KGVudHJ5LmJ1ZmZlciwgZW50cnkuYnl0ZU9mZnNldCwgZW50cnkuYnl0ZUxlbmd0aCk7XG5cbiAgICAgIHJlYWRSZXF1ZXN0Ll9jaHVua1N0ZXBzKHZpZXcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGF1dG9BbGxvY2F0ZUNodW5rU2l6ZSA9IHRoaXMuX2F1dG9BbGxvY2F0ZUNodW5rU2l6ZTtcbiAgICBpZiAoYXV0b0FsbG9jYXRlQ2h1bmtTaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGxldCBidWZmZXI6IEFycmF5QnVmZmVyO1xuICAgICAgdHJ5IHtcbiAgICAgICAgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGF1dG9BbGxvY2F0ZUNodW5rU2l6ZSk7XG4gICAgICB9IGNhdGNoIChidWZmZXJFKSB7XG4gICAgICAgIHJlYWRSZXF1ZXN0Ll9lcnJvclN0ZXBzKGJ1ZmZlckUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHB1bGxJbnRvRGVzY3JpcHRvcjogRGVmYXVsdFB1bGxJbnRvRGVzY3JpcHRvciA9IHtcbiAgICAgICAgYnVmZmVyLFxuICAgICAgICBidWZmZXJCeXRlTGVuZ3RoOiBhdXRvQWxsb2NhdGVDaHVua1NpemUsXG4gICAgICAgIGJ5dGVPZmZzZXQ6IDAsXG4gICAgICAgIGJ5dGVMZW5ndGg6IGF1dG9BbGxvY2F0ZUNodW5rU2l6ZSxcbiAgICAgICAgYnl0ZXNGaWxsZWQ6IDAsXG4gICAgICAgIGVsZW1lbnRTaXplOiAxLFxuICAgICAgICB2aWV3Q29uc3RydWN0b3I6IFVpbnQ4QXJyYXksXG4gICAgICAgIHJlYWRlclR5cGU6ICdkZWZhdWx0J1xuICAgICAgfTtcblxuICAgICAgdGhpcy5fcGVuZGluZ1B1bGxJbnRvcy5wdXNoKHB1bGxJbnRvRGVzY3JpcHRvcik7XG4gICAgfVxuXG4gICAgUmVhZGFibGVTdHJlYW1BZGRSZWFkUmVxdWVzdChzdHJlYW0sIHJlYWRSZXF1ZXN0KTtcbiAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2FsbFB1bGxJZk5lZWRlZCh0aGlzKTtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZSwge1xuICBjbG9zZTogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gIGVucXVldWU6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICBlcnJvcjogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gIGJ5b2JSZXF1ZXN0OiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgZGVzaXJlZFNpemU6IHsgZW51bWVyYWJsZTogdHJ1ZSB9XG59KTtcbmlmICh0eXBlb2YgU3ltYm9sLnRvU3RyaW5nVGFnID09PSAnc3ltYm9sJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUsIFN5bWJvbC50b1N0cmluZ1RhZywge1xuICAgIHZhbHVlOiAnUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcicsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG4vLyBBYnN0cmFjdCBvcGVyYXRpb25zIGZvciB0aGUgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlci5cblxuZXhwb3J0IGZ1bmN0aW9uIElzUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcih4OiBhbnkpOiB4IGlzIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIge1xuICBpZiAoIXR5cGVJc09iamVjdCh4KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdfY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbScpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHggaW5zdGFuY2VvZiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyO1xufVxuXG5mdW5jdGlvbiBJc1JlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QoeDogYW55KTogeCBpcyBSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0IHtcbiAgaWYgKCF0eXBlSXNPYmplY3QoeCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnX2Fzc29jaWF0ZWRSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyJykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4geCBpbnN0YW5jZW9mIFJlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3Q7XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDYWxsUHVsbElmTmVlZGVkKGNvbnRyb2xsZXI6IFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIpOiB2b2lkIHtcbiAgY29uc3Qgc2hvdWxkUHVsbCA9IFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJTaG91bGRDYWxsUHVsbChjb250cm9sbGVyKTtcbiAgaWYgKCFzaG91bGRQdWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGNvbnRyb2xsZXIuX3B1bGxpbmcpIHtcbiAgICBjb250cm9sbGVyLl9wdWxsQWdhaW4gPSB0cnVlO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGFzc2VydCghY29udHJvbGxlci5fcHVsbEFnYWluKTtcblxuICBjb250cm9sbGVyLl9wdWxsaW5nID0gdHJ1ZTtcblxuICAvLyBUT0RPOiBUZXN0IGNvbnRyb2xsZXIgYXJndW1lbnRcbiAgY29uc3QgcHVsbFByb21pc2UgPSBjb250cm9sbGVyLl9wdWxsQWxnb3JpdGhtKCk7XG4gIHVwb25Qcm9taXNlKFxuICAgIHB1bGxQcm9taXNlLFxuICAgICgpID0+IHtcbiAgICAgIGNvbnRyb2xsZXIuX3B1bGxpbmcgPSBmYWxzZTtcblxuICAgICAgaWYgKGNvbnRyb2xsZXIuX3B1bGxBZ2Fpbikge1xuICAgICAgICBjb250cm9sbGVyLl9wdWxsQWdhaW4gPSBmYWxzZTtcbiAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNhbGxQdWxsSWZOZWVkZWQoY29udHJvbGxlcik7XG4gICAgICB9XG4gICAgfSxcbiAgICBlID0+IHtcbiAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFcnJvcihjb250cm9sbGVyLCBlKTtcbiAgICB9XG4gICk7XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDbGVhclBlbmRpbmdQdWxsSW50b3MoY29udHJvbGxlcjogUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcikge1xuICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVySW52YWxpZGF0ZUJZT0JSZXF1ZXN0KGNvbnRyb2xsZXIpO1xuICBjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zID0gbmV3IFNpbXBsZVF1ZXVlKCk7XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDb21taXRQdWxsSW50b0Rlc2NyaXB0b3I8VCBleHRlbmRzIEFycmF5QnVmZmVyVmlldz4oXG4gIHN0cmVhbTogUmVhZGFibGVCeXRlU3RyZWFtLFxuICBwdWxsSW50b0Rlc2NyaXB0b3I6IFB1bGxJbnRvRGVzY3JpcHRvcjxUPlxuKSB7XG4gIGFzc2VydChzdHJlYW0uX3N0YXRlICE9PSAnZXJyb3JlZCcpO1xuXG4gIGxldCBkb25lID0gZmFsc2U7XG4gIGlmIChzdHJlYW0uX3N0YXRlID09PSAnY2xvc2VkJykge1xuICAgIGFzc2VydChwdWxsSW50b0Rlc2NyaXB0b3IuYnl0ZXNGaWxsZWQgPT09IDApO1xuICAgIGRvbmUgPSB0cnVlO1xuICB9XG5cbiAgY29uc3QgZmlsbGVkVmlldyA9IFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDb252ZXJ0UHVsbEludG9EZXNjcmlwdG9yPFQ+KHB1bGxJbnRvRGVzY3JpcHRvcik7XG4gIGlmIChwdWxsSW50b0Rlc2NyaXB0b3IucmVhZGVyVHlwZSA9PT0gJ2RlZmF1bHQnKSB7XG4gICAgUmVhZGFibGVTdHJlYW1GdWxmaWxsUmVhZFJlcXVlc3Qoc3RyZWFtLCBmaWxsZWRWaWV3IGFzIHVua25vd24gYXMgVWludDhBcnJheSwgZG9uZSk7XG4gIH0gZWxzZSB7XG4gICAgYXNzZXJ0KHB1bGxJbnRvRGVzY3JpcHRvci5yZWFkZXJUeXBlID09PSAnYnlvYicpO1xuICAgIFJlYWRhYmxlU3RyZWFtRnVsZmlsbFJlYWRJbnRvUmVxdWVzdChzdHJlYW0sIGZpbGxlZFZpZXcsIGRvbmUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDb252ZXJ0UHVsbEludG9EZXNjcmlwdG9yPFQgZXh0ZW5kcyBBcnJheUJ1ZmZlclZpZXc+KFxuICBwdWxsSW50b0Rlc2NyaXB0b3I6IFB1bGxJbnRvRGVzY3JpcHRvcjxUPlxuKTogVCB7XG4gIGNvbnN0IGJ5dGVzRmlsbGVkID0gcHVsbEludG9EZXNjcmlwdG9yLmJ5dGVzRmlsbGVkO1xuICBjb25zdCBlbGVtZW50U2l6ZSA9IHB1bGxJbnRvRGVzY3JpcHRvci5lbGVtZW50U2l6ZTtcblxuICBhc3NlcnQoYnl0ZXNGaWxsZWQgPD0gcHVsbEludG9EZXNjcmlwdG9yLmJ5dGVMZW5ndGgpO1xuICBhc3NlcnQoYnl0ZXNGaWxsZWQgJSBlbGVtZW50U2l6ZSA9PT0gMCk7XG5cbiAgcmV0dXJuIG5ldyBwdWxsSW50b0Rlc2NyaXB0b3Iudmlld0NvbnN0cnVjdG9yKFxuICAgIHB1bGxJbnRvRGVzY3JpcHRvci5idWZmZXIsIHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlT2Zmc2V0LCBieXRlc0ZpbGxlZCAvIGVsZW1lbnRTaXplKSBhcyBUO1xufVxuXG5mdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRW5xdWV1ZUNodW5rVG9RdWV1ZShjb250cm9sbGVyOiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyOiBBcnJheUJ1ZmZlckxpa2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBieXRlT2Zmc2V0OiBudW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBieXRlTGVuZ3RoOiBudW1iZXIpIHtcbiAgY29udHJvbGxlci5fcXVldWUucHVzaCh7IGJ1ZmZlciwgYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aCB9KTtcbiAgY29udHJvbGxlci5fcXVldWVUb3RhbFNpemUgKz0gYnl0ZUxlbmd0aDtcbn1cblxuZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckZpbGxQdWxsSW50b0Rlc2NyaXB0b3JGcm9tUXVldWUoY29udHJvbGxlcjogUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1bGxJbnRvRGVzY3JpcHRvcjogUHVsbEludG9EZXNjcmlwdG9yKSB7XG4gIGNvbnN0IGVsZW1lbnRTaXplID0gcHVsbEludG9EZXNjcmlwdG9yLmVsZW1lbnRTaXplO1xuXG4gIGNvbnN0IGN1cnJlbnRBbGlnbmVkQnl0ZXMgPSBwdWxsSW50b0Rlc2NyaXB0b3IuYnl0ZXNGaWxsZWQgLSBwdWxsSW50b0Rlc2NyaXB0b3IuYnl0ZXNGaWxsZWQgJSBlbGVtZW50U2l6ZTtcblxuICBjb25zdCBtYXhCeXRlc1RvQ29weSA9IE1hdGgubWluKGNvbnRyb2xsZXIuX3F1ZXVlVG90YWxTaXplLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlTGVuZ3RoIC0gcHVsbEludG9EZXNjcmlwdG9yLmJ5dGVzRmlsbGVkKTtcbiAgY29uc3QgbWF4Qnl0ZXNGaWxsZWQgPSBwdWxsSW50b0Rlc2NyaXB0b3IuYnl0ZXNGaWxsZWQgKyBtYXhCeXRlc1RvQ29weTtcbiAgY29uc3QgbWF4QWxpZ25lZEJ5dGVzID0gbWF4Qnl0ZXNGaWxsZWQgLSBtYXhCeXRlc0ZpbGxlZCAlIGVsZW1lbnRTaXplO1xuXG4gIGxldCB0b3RhbEJ5dGVzVG9Db3B5UmVtYWluaW5nID0gbWF4Qnl0ZXNUb0NvcHk7XG4gIGxldCByZWFkeSA9IGZhbHNlO1xuICBpZiAobWF4QWxpZ25lZEJ5dGVzID4gY3VycmVudEFsaWduZWRCeXRlcykge1xuICAgIHRvdGFsQnl0ZXNUb0NvcHlSZW1haW5pbmcgPSBtYXhBbGlnbmVkQnl0ZXMgLSBwdWxsSW50b0Rlc2NyaXB0b3IuYnl0ZXNGaWxsZWQ7XG4gICAgcmVhZHkgPSB0cnVlO1xuICB9XG5cbiAgY29uc3QgcXVldWUgPSBjb250cm9sbGVyLl9xdWV1ZTtcblxuICB3aGlsZSAodG90YWxCeXRlc1RvQ29weVJlbWFpbmluZyA+IDApIHtcbiAgICBjb25zdCBoZWFkT2ZRdWV1ZSA9IHF1ZXVlLnBlZWsoKTtcblxuICAgIGNvbnN0IGJ5dGVzVG9Db3B5ID0gTWF0aC5taW4odG90YWxCeXRlc1RvQ29weVJlbWFpbmluZywgaGVhZE9mUXVldWUuYnl0ZUxlbmd0aCk7XG5cbiAgICBjb25zdCBkZXN0U3RhcnQgPSBwdWxsSW50b0Rlc2NyaXB0b3IuYnl0ZU9mZnNldCArIHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlc0ZpbGxlZDtcbiAgICBDb3B5RGF0YUJsb2NrQnl0ZXMocHVsbEludG9EZXNjcmlwdG9yLmJ1ZmZlciwgZGVzdFN0YXJ0LCBoZWFkT2ZRdWV1ZS5idWZmZXIsIGhlYWRPZlF1ZXVlLmJ5dGVPZmZzZXQsIGJ5dGVzVG9Db3B5KTtcblxuICAgIGlmIChoZWFkT2ZRdWV1ZS5ieXRlTGVuZ3RoID09PSBieXRlc1RvQ29weSkge1xuICAgICAgcXVldWUuc2hpZnQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGVhZE9mUXVldWUuYnl0ZU9mZnNldCArPSBieXRlc1RvQ29weTtcbiAgICAgIGhlYWRPZlF1ZXVlLmJ5dGVMZW5ndGggLT0gYnl0ZXNUb0NvcHk7XG4gICAgfVxuICAgIGNvbnRyb2xsZXIuX3F1ZXVlVG90YWxTaXplIC09IGJ5dGVzVG9Db3B5O1xuXG4gICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckZpbGxIZWFkUHVsbEludG9EZXNjcmlwdG9yKGNvbnRyb2xsZXIsIGJ5dGVzVG9Db3B5LCBwdWxsSW50b0Rlc2NyaXB0b3IpO1xuXG4gICAgdG90YWxCeXRlc1RvQ29weVJlbWFpbmluZyAtPSBieXRlc1RvQ29weTtcbiAgfVxuXG4gIGlmICghcmVhZHkpIHtcbiAgICBhc3NlcnQoY29udHJvbGxlci5fcXVldWVUb3RhbFNpemUgPT09IDApO1xuICAgIGFzc2VydChwdWxsSW50b0Rlc2NyaXB0b3IuYnl0ZXNGaWxsZWQgPiAwKTtcbiAgICBhc3NlcnQocHVsbEludG9EZXNjcmlwdG9yLmJ5dGVzRmlsbGVkIDwgcHVsbEludG9EZXNjcmlwdG9yLmVsZW1lbnRTaXplKTtcbiAgfVxuXG4gIHJldHVybiByZWFkeTtcbn1cblxuZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckZpbGxIZWFkUHVsbEludG9EZXNjcmlwdG9yKGNvbnRyb2xsZXI6IFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZTogbnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1bGxJbnRvRGVzY3JpcHRvcjogUHVsbEludG9EZXNjcmlwdG9yKSB7XG4gIGFzc2VydChjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLmxlbmd0aCA9PT0gMCB8fCBjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLnBlZWsoKSA9PT0gcHVsbEludG9EZXNjcmlwdG9yKTtcbiAgYXNzZXJ0KGNvbnRyb2xsZXIuX2J5b2JSZXF1ZXN0ID09PSBudWxsKTtcbiAgcHVsbEludG9EZXNjcmlwdG9yLmJ5dGVzRmlsbGVkICs9IHNpemU7XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJIYW5kbGVRdWV1ZURyYWluKGNvbnRyb2xsZXI6IFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIpIHtcbiAgYXNzZXJ0KGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW0uX3N0YXRlID09PSAncmVhZGFibGUnKTtcblxuICBpZiAoY29udHJvbGxlci5fcXVldWVUb3RhbFNpemUgPT09IDAgJiYgY29udHJvbGxlci5fY2xvc2VSZXF1ZXN0ZWQpIHtcbiAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKGNvbnRyb2xsZXIpO1xuICAgIFJlYWRhYmxlU3RyZWFtQ2xvc2UoY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbSk7XG4gIH0gZWxzZSB7XG4gICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNhbGxQdWxsSWZOZWVkZWQoY29udHJvbGxlcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckludmFsaWRhdGVCWU9CUmVxdWVzdChjb250cm9sbGVyOiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyKSB7XG4gIGlmIChjb250cm9sbGVyLl9ieW9iUmVxdWVzdCA9PT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnRyb2xsZXIuX2J5b2JSZXF1ZXN0Ll9hc3NvY2lhdGVkUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlciA9IHVuZGVmaW5lZCE7XG4gIGNvbnRyb2xsZXIuX2J5b2JSZXF1ZXN0Ll92aWV3ID0gbnVsbCE7XG4gIGNvbnRyb2xsZXIuX2J5b2JSZXF1ZXN0ID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclByb2Nlc3NQdWxsSW50b0Rlc2NyaXB0b3JzVXNpbmdRdWV1ZShjb250cm9sbGVyOiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyKSB7XG4gIGFzc2VydCghY29udHJvbGxlci5fY2xvc2VSZXF1ZXN0ZWQpO1xuXG4gIHdoaWxlIChjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLmxlbmd0aCA+IDApIHtcbiAgICBpZiAoY29udHJvbGxlci5fcXVldWVUb3RhbFNpemUgPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBwdWxsSW50b0Rlc2NyaXB0b3IgPSBjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLnBlZWsoKTtcblxuICAgIGlmIChSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRmlsbFB1bGxJbnRvRGVzY3JpcHRvckZyb21RdWV1ZShjb250cm9sbGVyLCBwdWxsSW50b0Rlc2NyaXB0b3IpKSB7XG4gICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyU2hpZnRQZW5kaW5nUHVsbEludG8oY29udHJvbGxlcik7XG5cbiAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDb21taXRQdWxsSW50b0Rlc2NyaXB0b3IoXG4gICAgICAgIGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW0sXG4gICAgICAgIHB1bGxJbnRvRGVzY3JpcHRvclxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJQdWxsSW50bzxUIGV4dGVuZHMgQXJyYXlCdWZmZXJWaWV3PihcbiAgY29udHJvbGxlcjogUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcixcbiAgdmlldzogVCxcbiAgcmVhZEludG9SZXF1ZXN0OiBSZWFkSW50b1JlcXVlc3Q8VD5cbik6IHZvaWQge1xuICBjb25zdCBzdHJlYW0gPSBjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtO1xuXG4gIGxldCBlbGVtZW50U2l6ZSA9IDE7XG4gIGlmICh2aWV3LmNvbnN0cnVjdG9yICE9PSBEYXRhVmlldykge1xuICAgIGVsZW1lbnRTaXplID0gKHZpZXcuY29uc3RydWN0b3IgYXMgQXJyYXlCdWZmZXJWaWV3Q29uc3RydWN0b3I8VD4pLkJZVEVTX1BFUl9FTEVNRU5UO1xuICB9XG5cbiAgY29uc3QgY3RvciA9IHZpZXcuY29uc3RydWN0b3IgYXMgQXJyYXlCdWZmZXJWaWV3Q29uc3RydWN0b3I8VD47XG5cbiAgLy8gdHJ5IHtcbiAgY29uc3QgYnVmZmVyID0gVHJhbnNmZXJBcnJheUJ1ZmZlcih2aWV3LmJ1ZmZlcik7XG4gIC8vIH0gY2F0Y2ggKGUpIHtcbiAgLy8gICByZWFkSW50b1JlcXVlc3QuX2Vycm9yU3RlcHMoZSk7XG4gIC8vICAgcmV0dXJuO1xuICAvLyB9XG5cbiAgY29uc3QgcHVsbEludG9EZXNjcmlwdG9yOiBCWU9CUHVsbEludG9EZXNjcmlwdG9yPFQ+ID0ge1xuICAgIGJ1ZmZlcixcbiAgICBidWZmZXJCeXRlTGVuZ3RoOiBidWZmZXIuYnl0ZUxlbmd0aCxcbiAgICBieXRlT2Zmc2V0OiB2aWV3LmJ5dGVPZmZzZXQsXG4gICAgYnl0ZUxlbmd0aDogdmlldy5ieXRlTGVuZ3RoLFxuICAgIGJ5dGVzRmlsbGVkOiAwLFxuICAgIGVsZW1lbnRTaXplLFxuICAgIHZpZXdDb25zdHJ1Y3RvcjogY3RvcixcbiAgICByZWFkZXJUeXBlOiAnYnlvYidcbiAgfTtcblxuICBpZiAoY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5sZW5ndGggPiAwKSB7XG4gICAgY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5wdXNoKHB1bGxJbnRvRGVzY3JpcHRvcik7XG5cbiAgICAvLyBObyBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2FsbFB1bGxJZk5lZWRlZCgpIGNhbGwgc2luY2U6XG4gICAgLy8gLSBObyBjaGFuZ2UgaGFwcGVucyBvbiBkZXNpcmVkU2l6ZVxuICAgIC8vIC0gVGhlIHNvdXJjZSBoYXMgYWxyZWFkeSBiZWVuIG5vdGlmaWVkIG9mIHRoYXQgdGhlcmUncyBhdCBsZWFzdCAxIHBlbmRpbmcgcmVhZCh2aWV3KVxuXG4gICAgUmVhZGFibGVTdHJlYW1BZGRSZWFkSW50b1JlcXVlc3Qoc3RyZWFtLCByZWFkSW50b1JlcXVlc3QpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChzdHJlYW0uX3N0YXRlID09PSAnY2xvc2VkJykge1xuICAgIGNvbnN0IGVtcHR5VmlldyA9IG5ldyBjdG9yKHB1bGxJbnRvRGVzY3JpcHRvci5idWZmZXIsIHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlT2Zmc2V0LCAwKTtcbiAgICByZWFkSW50b1JlcXVlc3QuX2Nsb3NlU3RlcHMoZW1wdHlWaWV3KTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoY29udHJvbGxlci5fcXVldWVUb3RhbFNpemUgPiAwKSB7XG4gICAgaWYgKFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJGaWxsUHVsbEludG9EZXNjcmlwdG9yRnJvbVF1ZXVlKGNvbnRyb2xsZXIsIHB1bGxJbnRvRGVzY3JpcHRvcikpIHtcbiAgICAgIGNvbnN0IGZpbGxlZFZpZXcgPSBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ29udmVydFB1bGxJbnRvRGVzY3JpcHRvcjxUPihwdWxsSW50b0Rlc2NyaXB0b3IpO1xuXG4gICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVySGFuZGxlUXVldWVEcmFpbihjb250cm9sbGVyKTtcblxuICAgICAgcmVhZEludG9SZXF1ZXN0Ll9jaHVua1N0ZXBzKGZpbGxlZFZpZXcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChjb250cm9sbGVyLl9jbG9zZVJlcXVlc3RlZCkge1xuICAgICAgY29uc3QgZSA9IG5ldyBUeXBlRXJyb3IoJ0luc3VmZmljaWVudCBieXRlcyB0byBmaWxsIGVsZW1lbnRzIGluIHRoZSBnaXZlbiBidWZmZXInKTtcbiAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFcnJvcihjb250cm9sbGVyLCBlKTtcblxuICAgICAgcmVhZEludG9SZXF1ZXN0Ll9lcnJvclN0ZXBzKGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIGNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MucHVzaChwdWxsSW50b0Rlc2NyaXB0b3IpO1xuXG4gIFJlYWRhYmxlU3RyZWFtQWRkUmVhZEludG9SZXF1ZXN0PFQ+KHN0cmVhbSwgcmVhZEludG9SZXF1ZXN0KTtcbiAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNhbGxQdWxsSWZOZWVkZWQoY29udHJvbGxlcik7XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kSW5DbG9zZWRTdGF0ZShjb250cm9sbGVyOiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0RGVzY3JpcHRvcjogUHVsbEludG9EZXNjcmlwdG9yKSB7XG4gIGFzc2VydChmaXJzdERlc2NyaXB0b3IuYnl0ZXNGaWxsZWQgPT09IDApO1xuXG4gIGNvbnN0IHN0cmVhbSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW07XG4gIGlmIChSZWFkYWJsZVN0cmVhbUhhc0JZT0JSZWFkZXIoc3RyZWFtKSkge1xuICAgIHdoaWxlIChSZWFkYWJsZVN0cmVhbUdldE51bVJlYWRJbnRvUmVxdWVzdHMoc3RyZWFtKSA+IDApIHtcbiAgICAgIGNvbnN0IHB1bGxJbnRvRGVzY3JpcHRvciA9IFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJTaGlmdFBlbmRpbmdQdWxsSW50byhjb250cm9sbGVyKTtcbiAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDb21taXRQdWxsSW50b0Rlc2NyaXB0b3Ioc3RyZWFtLCBwdWxsSW50b0Rlc2NyaXB0b3IpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZEluUmVhZGFibGVTdGF0ZShjb250cm9sbGVyOiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZXNXcml0dGVuOiBudW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdWxsSW50b0Rlc2NyaXB0b3I6IFB1bGxJbnRvRGVzY3JpcHRvcikge1xuICBhc3NlcnQocHVsbEludG9EZXNjcmlwdG9yLmJ5dGVzRmlsbGVkICsgYnl0ZXNXcml0dGVuIDw9IHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlTGVuZ3RoKTtcblxuICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRmlsbEhlYWRQdWxsSW50b0Rlc2NyaXB0b3IoY29udHJvbGxlciwgYnl0ZXNXcml0dGVuLCBwdWxsSW50b0Rlc2NyaXB0b3IpO1xuXG4gIGlmIChwdWxsSW50b0Rlc2NyaXB0b3IuYnl0ZXNGaWxsZWQgPCBwdWxsSW50b0Rlc2NyaXB0b3IuZWxlbWVudFNpemUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyU2hpZnRQZW5kaW5nUHVsbEludG8oY29udHJvbGxlcik7XG5cbiAgY29uc3QgcmVtYWluZGVyU2l6ZSA9IHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlc0ZpbGxlZCAlIHB1bGxJbnRvRGVzY3JpcHRvci5lbGVtZW50U2l6ZTtcbiAgaWYgKHJlbWFpbmRlclNpemUgPiAwKSB7XG4gICAgY29uc3QgZW5kID0gcHVsbEludG9EZXNjcmlwdG9yLmJ5dGVPZmZzZXQgKyBwdWxsSW50b0Rlc2NyaXB0b3IuYnl0ZXNGaWxsZWQ7XG4gICAgY29uc3QgcmVtYWluZGVyID0gQXJyYXlCdWZmZXJTbGljZShwdWxsSW50b0Rlc2NyaXB0b3IuYnVmZmVyLCBlbmQgLSByZW1haW5kZXJTaXplLCBlbmQpO1xuICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFbnF1ZXVlQ2h1bmtUb1F1ZXVlKGNvbnRyb2xsZXIsIHJlbWFpbmRlciwgMCwgcmVtYWluZGVyLmJ5dGVMZW5ndGgpO1xuICB9XG5cbiAgcHVsbEludG9EZXNjcmlwdG9yLmJ5dGVzRmlsbGVkIC09IHJlbWFpbmRlclNpemU7XG4gIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDb21taXRQdWxsSW50b0Rlc2NyaXB0b3IoY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbSwgcHVsbEludG9EZXNjcmlwdG9yKTtcblxuICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUHJvY2Vzc1B1bGxJbnRvRGVzY3JpcHRvcnNVc2luZ1F1ZXVlKGNvbnRyb2xsZXIpO1xufVxuXG5mdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZEludGVybmFsKGNvbnRyb2xsZXI6IFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIsIGJ5dGVzV3JpdHRlbjogbnVtYmVyKSB7XG4gIGNvbnN0IGZpcnN0RGVzY3JpcHRvciA9IGNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MucGVlaygpO1xuICBhc3NlcnQoQ2FuVHJhbnNmZXJBcnJheUJ1ZmZlcihmaXJzdERlc2NyaXB0b3IuYnVmZmVyKSk7XG5cbiAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckludmFsaWRhdGVCWU9CUmVxdWVzdChjb250cm9sbGVyKTtcblxuICBjb25zdCBzdGF0ZSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW0uX3N0YXRlO1xuICBpZiAoc3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICAgYXNzZXJ0KGJ5dGVzV3JpdHRlbiA9PT0gMCk7XG4gICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmRJbkNsb3NlZFN0YXRlKGNvbnRyb2xsZXIsIGZpcnN0RGVzY3JpcHRvcik7XG4gIH0gZWxzZSB7XG4gICAgYXNzZXJ0KHN0YXRlID09PSAncmVhZGFibGUnKTtcbiAgICBhc3NlcnQoYnl0ZXNXcml0dGVuID4gMCk7XG4gICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmRJblJlYWRhYmxlU3RhdGUoY29udHJvbGxlciwgYnl0ZXNXcml0dGVuLCBmaXJzdERlc2NyaXB0b3IpO1xuICB9XG5cbiAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNhbGxQdWxsSWZOZWVkZWQoY29udHJvbGxlcik7XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJTaGlmdFBlbmRpbmdQdWxsSW50byhcbiAgY29udHJvbGxlcjogUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclxuKTogUHVsbEludG9EZXNjcmlwdG9yIHtcbiAgYXNzZXJ0KGNvbnRyb2xsZXIuX2J5b2JSZXF1ZXN0ID09PSBudWxsKTtcbiAgY29uc3QgZGVzY3JpcHRvciA9IGNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3Muc2hpZnQoKSE7XG4gIHJldHVybiBkZXNjcmlwdG9yO1xufVxuXG5mdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyU2hvdWxkQ2FsbFB1bGwoY29udHJvbGxlcjogUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcik6IGJvb2xlYW4ge1xuICBjb25zdCBzdHJlYW0gPSBjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtO1xuXG4gIGlmIChzdHJlYW0uX3N0YXRlICE9PSAncmVhZGFibGUnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGNvbnRyb2xsZXIuX2Nsb3NlUmVxdWVzdGVkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCFjb250cm9sbGVyLl9zdGFydGVkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKFJlYWRhYmxlU3RyZWFtSGFzRGVmYXVsdFJlYWRlcihzdHJlYW0pICYmIFJlYWRhYmxlU3RyZWFtR2V0TnVtUmVhZFJlcXVlc3RzKHN0cmVhbSkgPiAwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoUmVhZGFibGVTdHJlYW1IYXNCWU9CUmVhZGVyKHN0cmVhbSkgJiYgUmVhZGFibGVTdHJlYW1HZXROdW1SZWFkSW50b1JlcXVlc3RzKHN0cmVhbSkgPiAwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBjb25zdCBkZXNpcmVkU2l6ZSA9IFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJHZXREZXNpcmVkU2l6ZShjb250cm9sbGVyKTtcbiAgYXNzZXJ0KGRlc2lyZWRTaXplICE9PSBudWxsKTtcbiAgaWYgKGRlc2lyZWRTaXplISA+IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyhjb250cm9sbGVyOiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyKSB7XG4gIGNvbnRyb2xsZXIuX3B1bGxBbGdvcml0aG0gPSB1bmRlZmluZWQhO1xuICBjb250cm9sbGVyLl9jYW5jZWxBbGdvcml0aG0gPSB1bmRlZmluZWQhO1xufVxuXG4vLyBBIGNsaWVudCBvZiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyIG1heSB1c2UgdGhlc2UgZnVuY3Rpb25zIGRpcmVjdGx5IHRvIGJ5cGFzcyBzdGF0ZSBjaGVjay5cblxuZXhwb3J0IGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDbG9zZShjb250cm9sbGVyOiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyKSB7XG4gIGNvbnN0IHN0cmVhbSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW07XG5cbiAgaWYgKGNvbnRyb2xsZXIuX2Nsb3NlUmVxdWVzdGVkIHx8IHN0cmVhbS5fc3RhdGUgIT09ICdyZWFkYWJsZScpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoY29udHJvbGxlci5fcXVldWVUb3RhbFNpemUgPiAwKSB7XG4gICAgY29udHJvbGxlci5fY2xvc2VSZXF1ZXN0ZWQgPSB0cnVlO1xuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IGZpcnN0UGVuZGluZ1B1bGxJbnRvID0gY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5wZWVrKCk7XG4gICAgaWYgKGZpcnN0UGVuZGluZ1B1bGxJbnRvLmJ5dGVzRmlsbGVkID4gMCkge1xuICAgICAgY29uc3QgZSA9IG5ldyBUeXBlRXJyb3IoJ0luc3VmZmljaWVudCBieXRlcyB0byBmaWxsIGVsZW1lbnRzIGluIHRoZSBnaXZlbiBidWZmZXInKTtcbiAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFcnJvcihjb250cm9sbGVyLCBlKTtcblxuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gIH1cblxuICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKGNvbnRyb2xsZXIpO1xuICBSZWFkYWJsZVN0cmVhbUNsb3NlKHN0cmVhbSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRW5xdWV1ZShjb250cm9sbGVyOiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyLCBjaHVuazogQXJyYXlCdWZmZXJWaWV3KSB7XG4gIGNvbnN0IHN0cmVhbSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW07XG5cbiAgaWYgKGNvbnRyb2xsZXIuX2Nsb3NlUmVxdWVzdGVkIHx8IHN0cmVhbS5fc3RhdGUgIT09ICdyZWFkYWJsZScpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBidWZmZXIgPSBjaHVuay5idWZmZXI7XG4gIGNvbnN0IGJ5dGVPZmZzZXQgPSBjaHVuay5ieXRlT2Zmc2V0O1xuICBjb25zdCBieXRlTGVuZ3RoID0gY2h1bmsuYnl0ZUxlbmd0aDtcbiAgaWYgKElzRGV0YWNoZWRCdWZmZXIoYnVmZmVyKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NodW5rXFwncyBidWZmZXIgaXMgZGV0YWNoZWQgYW5kIHNvIGNhbm5vdCBiZSBlbnF1ZXVlZCcpO1xuICB9XG4gIGNvbnN0IHRyYW5zZmVycmVkQnVmZmVyID0gVHJhbnNmZXJBcnJheUJ1ZmZlcihidWZmZXIpO1xuXG4gIGlmIChjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCBmaXJzdFBlbmRpbmdQdWxsSW50byA9IGNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MucGVlaygpO1xuICAgIGlmIChJc0RldGFjaGVkQnVmZmVyKGZpcnN0UGVuZGluZ1B1bGxJbnRvLmJ1ZmZlcikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICdUaGUgQllPQiByZXF1ZXN0XFwncyBidWZmZXIgaGFzIGJlZW4gZGV0YWNoZWQgYW5kIHNvIGNhbm5vdCBiZSBmaWxsZWQgd2l0aCBhbiBlbnF1ZXVlZCBjaHVuaydcbiAgICAgICk7XG4gICAgfVxuICAgIGZpcnN0UGVuZGluZ1B1bGxJbnRvLmJ1ZmZlciA9IFRyYW5zZmVyQXJyYXlCdWZmZXIoZmlyc3RQZW5kaW5nUHVsbEludG8uYnVmZmVyKTtcbiAgfVxuXG4gIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJJbnZhbGlkYXRlQllPQlJlcXVlc3QoY29udHJvbGxlcik7XG5cbiAgaWYgKFJlYWRhYmxlU3RyZWFtSGFzRGVmYXVsdFJlYWRlcihzdHJlYW0pKSB7XG4gICAgaWYgKFJlYWRhYmxlU3RyZWFtR2V0TnVtUmVhZFJlcXVlc3RzKHN0cmVhbSkgPT09IDApIHtcbiAgICAgIGFzc2VydChjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLmxlbmd0aCA9PT0gMCk7XG4gICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRW5xdWV1ZUNodW5rVG9RdWV1ZShjb250cm9sbGVyLCB0cmFuc2ZlcnJlZEJ1ZmZlciwgYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2VydChjb250cm9sbGVyLl9xdWV1ZS5sZW5ndGggPT09IDApO1xuICAgICAgaWYgKGNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MubGVuZ3RoID4gMCkge1xuICAgICAgICBhc3NlcnQoY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5wZWVrKCkucmVhZGVyVHlwZSA9PT0gJ2RlZmF1bHQnKTtcbiAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclNoaWZ0UGVuZGluZ1B1bGxJbnRvKGNvbnRyb2xsZXIpO1xuICAgICAgfVxuICAgICAgY29uc3QgdHJhbnNmZXJyZWRWaWV3ID0gbmV3IFVpbnQ4QXJyYXkodHJhbnNmZXJyZWRCdWZmZXIsIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGgpO1xuICAgICAgUmVhZGFibGVTdHJlYW1GdWxmaWxsUmVhZFJlcXVlc3Qoc3RyZWFtLCB0cmFuc2ZlcnJlZFZpZXcsIGZhbHNlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoUmVhZGFibGVTdHJlYW1IYXNCWU9CUmVhZGVyKHN0cmVhbSkpIHtcbiAgICAvLyBUT0RPOiBJZGVhbGx5IGluIHRoaXMgYnJhbmNoIGRldGFjaGluZyBzaG91bGQgaGFwcGVuIG9ubHkgaWYgdGhlIGJ1ZmZlciBpcyBub3QgY29uc3VtZWQgZnVsbHkuXG4gICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVucXVldWVDaHVua1RvUXVldWUoY29udHJvbGxlciwgdHJhbnNmZXJyZWRCdWZmZXIsIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGgpO1xuICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJQcm9jZXNzUHVsbEludG9EZXNjcmlwdG9yc1VzaW5nUXVldWUoY29udHJvbGxlcik7XG4gIH0gZWxzZSB7XG4gICAgYXNzZXJ0KCFJc1JlYWRhYmxlU3RyZWFtTG9ja2VkKHN0cmVhbSkpO1xuICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFbnF1ZXVlQ2h1bmtUb1F1ZXVlKGNvbnRyb2xsZXIsIHRyYW5zZmVycmVkQnVmZmVyLCBieXRlT2Zmc2V0LCBieXRlTGVuZ3RoKTtcbiAgfVxuXG4gIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDYWxsUHVsbElmTmVlZGVkKGNvbnRyb2xsZXIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVycm9yKGNvbnRyb2xsZXI6IFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIsIGU6IGFueSkge1xuICBjb25zdCBzdHJlYW0gPSBjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtO1xuXG4gIGlmIChzdHJlYW0uX3N0YXRlICE9PSAncmVhZGFibGUnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNsZWFyUGVuZGluZ1B1bGxJbnRvcyhjb250cm9sbGVyKTtcblxuICBSZXNldFF1ZXVlKGNvbnRyb2xsZXIpO1xuICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKGNvbnRyb2xsZXIpO1xuICBSZWFkYWJsZVN0cmVhbUVycm9yKHN0cmVhbSwgZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyR2V0QllPQlJlcXVlc3QoXG4gIGNvbnRyb2xsZXI6IFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJcbik6IFJlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QgfCBudWxsIHtcbiAgaWYgKGNvbnRyb2xsZXIuX2J5b2JSZXF1ZXN0ID09PSBudWxsICYmIGNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IGZpcnN0RGVzY3JpcHRvciA9IGNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MucGVlaygpO1xuICAgIGNvbnN0IHZpZXcgPSBuZXcgVWludDhBcnJheShmaXJzdERlc2NyaXB0b3IuYnVmZmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXJzdERlc2NyaXB0b3IuYnl0ZU9mZnNldCArIGZpcnN0RGVzY3JpcHRvci5ieXRlc0ZpbGxlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3REZXNjcmlwdG9yLmJ5dGVMZW5ndGggLSBmaXJzdERlc2NyaXB0b3IuYnl0ZXNGaWxsZWQpO1xuXG4gICAgY29uc3QgYnlvYlJlcXVlc3Q6IFJlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QgPSBPYmplY3QuY3JlYXRlKFJlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QucHJvdG90eXBlKTtcbiAgICBTZXRVcFJlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QoYnlvYlJlcXVlc3QsIGNvbnRyb2xsZXIsIHZpZXcpO1xuICAgIGNvbnRyb2xsZXIuX2J5b2JSZXF1ZXN0ID0gYnlvYlJlcXVlc3Q7XG4gIH1cbiAgcmV0dXJuIGNvbnRyb2xsZXIuX2J5b2JSZXF1ZXN0O1xufVxuXG5mdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyR2V0RGVzaXJlZFNpemUoY29udHJvbGxlcjogUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcik6IG51bWJlciB8IG51bGwge1xuICBjb25zdCBzdGF0ZSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW0uX3N0YXRlO1xuXG4gIGlmIChzdGF0ZSA9PT0gJ2Vycm9yZWQnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKHN0YXRlID09PSAnY2xvc2VkJykge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgcmV0dXJuIGNvbnRyb2xsZXIuX3N0cmF0ZWd5SFdNIC0gY29udHJvbGxlci5fcXVldWVUb3RhbFNpemU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZChjb250cm9sbGVyOiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyLCBieXRlc1dyaXR0ZW46IG51bWJlcikge1xuICBhc3NlcnQoY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5sZW5ndGggPiAwKTtcblxuICBjb25zdCBmaXJzdERlc2NyaXB0b3IgPSBjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLnBlZWsoKTtcbiAgY29uc3Qgc3RhdGUgPSBjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtLl9zdGF0ZTtcblxuICBpZiAoc3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICAgaWYgKGJ5dGVzV3JpdHRlbiAhPT0gMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYnl0ZXNXcml0dGVuIG11c3QgYmUgMCB3aGVuIGNhbGxpbmcgcmVzcG9uZCgpIG9uIGEgY2xvc2VkIHN0cmVhbScpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBhc3NlcnQoc3RhdGUgPT09ICdyZWFkYWJsZScpO1xuICAgIGlmIChieXRlc1dyaXR0ZW4gPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2J5dGVzV3JpdHRlbiBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwIHdoZW4gY2FsbGluZyByZXNwb25kKCkgb24gYSByZWFkYWJsZSBzdHJlYW0nKTtcbiAgICB9XG4gICAgaWYgKGZpcnN0RGVzY3JpcHRvci5ieXRlc0ZpbGxlZCArIGJ5dGVzV3JpdHRlbiA+IGZpcnN0RGVzY3JpcHRvci5ieXRlTGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignYnl0ZXNXcml0dGVuIG91dCBvZiByYW5nZScpO1xuICAgIH1cbiAgfVxuXG4gIGZpcnN0RGVzY3JpcHRvci5idWZmZXIgPSBUcmFuc2ZlckFycmF5QnVmZmVyKGZpcnN0RGVzY3JpcHRvci5idWZmZXIpO1xuXG4gIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kSW50ZXJuYWwoY29udHJvbGxlciwgYnl0ZXNXcml0dGVuKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kV2l0aE5ld1ZpZXcoY29udHJvbGxlcjogUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZXc6IEFycmF5QnVmZmVyVmlldykge1xuICBhc3NlcnQoY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5sZW5ndGggPiAwKTtcbiAgYXNzZXJ0KCFJc0RldGFjaGVkQnVmZmVyKHZpZXcuYnVmZmVyKSk7XG5cbiAgY29uc3QgZmlyc3REZXNjcmlwdG9yID0gY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5wZWVrKCk7XG4gIGNvbnN0IHN0YXRlID0gY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbS5fc3RhdGU7XG5cbiAgaWYgKHN0YXRlID09PSAnY2xvc2VkJykge1xuICAgIGlmICh2aWV3LmJ5dGVMZW5ndGggIT09IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSB2aWV3XFwncyBsZW5ndGggbXVzdCBiZSAwIHdoZW4gY2FsbGluZyByZXNwb25kV2l0aE5ld1ZpZXcoKSBvbiBhIGNsb3NlZCBzdHJlYW0nKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYXNzZXJ0KHN0YXRlID09PSAncmVhZGFibGUnKTtcbiAgICBpZiAodmlldy5ieXRlTGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAnVGhlIHZpZXdcXCdzIGxlbmd0aCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwIHdoZW4gY2FsbGluZyByZXNwb25kV2l0aE5ld1ZpZXcoKSBvbiBhIHJlYWRhYmxlIHN0cmVhbSdcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGZpcnN0RGVzY3JpcHRvci5ieXRlT2Zmc2V0ICsgZmlyc3REZXNjcmlwdG9yLmJ5dGVzRmlsbGVkICE9PSB2aWV3LmJ5dGVPZmZzZXQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHJlZ2lvbiBzcGVjaWZpZWQgYnkgdmlldyBkb2VzIG5vdCBtYXRjaCBieW9iUmVxdWVzdCcpO1xuICB9XG4gIGlmIChmaXJzdERlc2NyaXB0b3IuYnVmZmVyQnl0ZUxlbmd0aCAhPT0gdmlldy5idWZmZXIuYnl0ZUxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgYnVmZmVyIG9mIHZpZXcgaGFzIGRpZmZlcmVudCBjYXBhY2l0eSB0aGFuIGJ5b2JSZXF1ZXN0Jyk7XG4gIH1cbiAgaWYgKGZpcnN0RGVzY3JpcHRvci5ieXRlc0ZpbGxlZCArIHZpZXcuYnl0ZUxlbmd0aCA+IGZpcnN0RGVzY3JpcHRvci5ieXRlTGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSByZWdpb24gc3BlY2lmaWVkIGJ5IHZpZXcgaXMgbGFyZ2VyIHRoYW4gYnlvYlJlcXVlc3QnKTtcbiAgfVxuXG4gIGNvbnN0IHZpZXdCeXRlTGVuZ3RoID0gdmlldy5ieXRlTGVuZ3RoO1xuICBmaXJzdERlc2NyaXB0b3IuYnVmZmVyID0gVHJhbnNmZXJBcnJheUJ1ZmZlcih2aWV3LmJ1ZmZlcik7XG4gIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kSW50ZXJuYWwoY29udHJvbGxlciwgdmlld0J5dGVMZW5ndGgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gU2V0VXBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyKHN0cmVhbTogUmVhZGFibGVCeXRlU3RyZWFtLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyOiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydEFsZ29yaXRobTogKCkgPT4gdm9pZCB8IFByb21pc2VMaWtlPHZvaWQ+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdWxsQWxnb3JpdGhtOiAoKSA9PiBQcm9taXNlPHZvaWQ+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5jZWxBbGdvcml0aG06IChyZWFzb246IGFueSkgPT4gUHJvbWlzZTx2b2lkPixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGlnaFdhdGVyTWFyazogbnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdXRvQWxsb2NhdGVDaHVua1NpemU6IG51bWJlciB8IHVuZGVmaW5lZCkge1xuICBhc3NlcnQoc3RyZWFtLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIgPT09IHVuZGVmaW5lZCk7XG4gIGlmIChhdXRvQWxsb2NhdGVDaHVua1NpemUgIT09IHVuZGVmaW5lZCkge1xuICAgIGFzc2VydChOdW1iZXJJc0ludGVnZXIoYXV0b0FsbG9jYXRlQ2h1bmtTaXplKSk7XG4gICAgYXNzZXJ0KGF1dG9BbGxvY2F0ZUNodW5rU2l6ZSA+IDApO1xuICB9XG5cbiAgY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbSA9IHN0cmVhbTtcblxuICBjb250cm9sbGVyLl9wdWxsQWdhaW4gPSBmYWxzZTtcbiAgY29udHJvbGxlci5fcHVsbGluZyA9IGZhbHNlO1xuXG4gIGNvbnRyb2xsZXIuX2J5b2JSZXF1ZXN0ID0gbnVsbDtcblxuICAvLyBOZWVkIHRvIHNldCB0aGUgc2xvdHMgc28gdGhhdCB0aGUgYXNzZXJ0IGRvZXNuJ3QgZmlyZS4gSW4gdGhlIHNwZWMgdGhlIHNsb3RzIGFscmVhZHkgZXhpc3QgaW1wbGljaXRseS5cbiAgY29udHJvbGxlci5fcXVldWUgPSBjb250cm9sbGVyLl9xdWV1ZVRvdGFsU2l6ZSA9IHVuZGVmaW5lZCE7XG4gIFJlc2V0UXVldWUoY29udHJvbGxlcik7XG5cbiAgY29udHJvbGxlci5fY2xvc2VSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgY29udHJvbGxlci5fc3RhcnRlZCA9IGZhbHNlO1xuXG4gIGNvbnRyb2xsZXIuX3N0cmF0ZWd5SFdNID0gaGlnaFdhdGVyTWFyaztcblxuICBjb250cm9sbGVyLl9wdWxsQWxnb3JpdGhtID0gcHVsbEFsZ29yaXRobTtcbiAgY29udHJvbGxlci5fY2FuY2VsQWxnb3JpdGhtID0gY2FuY2VsQWxnb3JpdGhtO1xuXG4gIGNvbnRyb2xsZXIuX2F1dG9BbGxvY2F0ZUNodW5rU2l6ZSA9IGF1dG9BbGxvY2F0ZUNodW5rU2l6ZTtcblxuICBjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zID0gbmV3IFNpbXBsZVF1ZXVlKCk7XG5cbiAgc3RyZWFtLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIgPSBjb250cm9sbGVyO1xuXG4gIGNvbnN0IHN0YXJ0UmVzdWx0ID0gc3RhcnRBbGdvcml0aG0oKTtcbiAgdXBvblByb21pc2UoXG4gICAgcHJvbWlzZVJlc29sdmVkV2l0aChzdGFydFJlc3VsdCksXG4gICAgKCkgPT4ge1xuICAgICAgY29udHJvbGxlci5fc3RhcnRlZCA9IHRydWU7XG5cbiAgICAgIGFzc2VydCghY29udHJvbGxlci5fcHVsbGluZyk7XG4gICAgICBhc3NlcnQoIWNvbnRyb2xsZXIuX3B1bGxBZ2Fpbik7XG5cbiAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDYWxsUHVsbElmTmVlZGVkKGNvbnRyb2xsZXIpO1xuICAgIH0sXG4gICAgciA9PiB7XG4gICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRXJyb3IoY29udHJvbGxlciwgcik7XG4gICAgfVxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gU2V0VXBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRnJvbVVuZGVybHlpbmdTb3VyY2UoXG4gIHN0cmVhbTogUmVhZGFibGVCeXRlU3RyZWFtLFxuICB1bmRlcmx5aW5nQnl0ZVNvdXJjZTogVmFsaWRhdGVkVW5kZXJseWluZ0J5dGVTb3VyY2UsXG4gIGhpZ2hXYXRlck1hcms6IG51bWJlclxuKSB7XG4gIGNvbnN0IGNvbnRyb2xsZXI6IFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIgPSBPYmplY3QuY3JlYXRlKFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlKTtcblxuICBsZXQgc3RhcnRBbGdvcml0aG06ICgpID0+IHZvaWQgfCBQcm9taXNlTGlrZTx2b2lkPiA9ICgpID0+IHVuZGVmaW5lZDtcbiAgbGV0IHB1bGxBbGdvcml0aG06ICgpID0+IFByb21pc2U8dm9pZD4gPSAoKSA9PiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG4gIGxldCBjYW5jZWxBbGdvcml0aG06IChyZWFzb246IGFueSkgPT4gUHJvbWlzZTx2b2lkPiA9ICgpID0+IHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcblxuICBpZiAodW5kZXJseWluZ0J5dGVTb3VyY2Uuc3RhcnQgIT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0QWxnb3JpdGhtID0gKCkgPT4gdW5kZXJseWluZ0J5dGVTb3VyY2Uuc3RhcnQhKGNvbnRyb2xsZXIpO1xuICB9XG4gIGlmICh1bmRlcmx5aW5nQnl0ZVNvdXJjZS5wdWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICBwdWxsQWxnb3JpdGhtID0gKCkgPT4gdW5kZXJseWluZ0J5dGVTb3VyY2UucHVsbCEoY29udHJvbGxlcik7XG4gIH1cbiAgaWYgKHVuZGVybHlpbmdCeXRlU291cmNlLmNhbmNlbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY2FuY2VsQWxnb3JpdGhtID0gcmVhc29uID0+IHVuZGVybHlpbmdCeXRlU291cmNlLmNhbmNlbCEocmVhc29uKTtcbiAgfVxuXG4gIGNvbnN0IGF1dG9BbGxvY2F0ZUNodW5rU2l6ZSA9IHVuZGVybHlpbmdCeXRlU291cmNlLmF1dG9BbGxvY2F0ZUNodW5rU2l6ZTtcbiAgaWYgKGF1dG9BbGxvY2F0ZUNodW5rU2l6ZSA9PT0gMCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2F1dG9BbGxvY2F0ZUNodW5rU2l6ZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwJyk7XG4gIH1cblxuICBTZXRVcFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIoXG4gICAgc3RyZWFtLCBjb250cm9sbGVyLCBzdGFydEFsZ29yaXRobSwgcHVsbEFsZ29yaXRobSwgY2FuY2VsQWxnb3JpdGhtLCBoaWdoV2F0ZXJNYXJrLCBhdXRvQWxsb2NhdGVDaHVua1NpemVcbiAgKTtcbn1cblxuZnVuY3Rpb24gU2V0VXBSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0KHJlcXVlc3Q6IFJlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlcjogUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWV3OiBBcnJheUJ1ZmZlclZpZXcpIHtcbiAgYXNzZXJ0KElzUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcihjb250cm9sbGVyKSk7XG4gIGFzc2VydCh0eXBlb2YgdmlldyA9PT0gJ29iamVjdCcpO1xuICBhc3NlcnQoQXJyYXlCdWZmZXIuaXNWaWV3KHZpZXcpKTtcbiAgYXNzZXJ0KCFJc0RldGFjaGVkQnVmZmVyKHZpZXcuYnVmZmVyKSk7XG4gIHJlcXVlc3QuX2Fzc29jaWF0ZWRSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyID0gY29udHJvbGxlcjtcbiAgcmVxdWVzdC5fdmlldyA9IHZpZXc7XG59XG5cbi8vIEhlbHBlciBmdW5jdGlvbnMgZm9yIHRoZSBSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0LlxuXG5mdW5jdGlvbiBieW9iUmVxdWVzdEJyYW5kQ2hlY2tFeGNlcHRpb24obmFtZTogc3RyaW5nKTogVHlwZUVycm9yIHtcbiAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoXG4gICAgYFJlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QucHJvdG90eXBlLiR7bmFtZX0gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIFJlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3RgKTtcbn1cblxuLy8gSGVscGVyIGZ1bmN0aW9ucyBmb3IgdGhlIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIuXG5cbmZ1bmN0aW9uIGJ5dGVTdHJlYW1Db250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbihuYW1lOiBzdHJpbmcpOiBUeXBlRXJyb3Ige1xuICByZXR1cm4gbmV3IFR5cGVFcnJvcihcbiAgICBgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUuJHtuYW1lfSBjYW4gb25seSBiZSB1c2VkIG9uIGEgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcmApO1xufVxuIiwgImltcG9ydCBhc3NlcnQgZnJvbSAnLi4vLi4vc3R1Yi9hc3NlcnQnO1xuaW1wb3J0IHsgU2ltcGxlUXVldWUgfSBmcm9tICcuLi9zaW1wbGUtcXVldWUnO1xuaW1wb3J0IHtcbiAgUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljQ2FuY2VsLFxuICBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNJbml0aWFsaXplLFxuICBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNSZWxlYXNlLFxuICByZWFkZXJMb2NrRXhjZXB0aW9uXG59IGZyb20gJy4vZ2VuZXJpYy1yZWFkZXInO1xuaW1wb3J0IHsgSXNSZWFkYWJsZVN0cmVhbUxvY2tlZCwgUmVhZGFibGVCeXRlU3RyZWFtLCBSZWFkYWJsZVN0cmVhbSB9IGZyb20gJy4uL3JlYWRhYmxlLXN0cmVhbSc7XG5pbXBvcnQge1xuICBJc1JlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIsXG4gIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIsXG4gIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJQdWxsSW50b1xufSBmcm9tICcuL2J5dGUtc3RyZWFtLWNvbnRyb2xsZXInO1xuaW1wb3J0IHsgdHlwZUlzT2JqZWN0IH0gZnJvbSAnLi4vaGVscGVycy9taXNjZWxsYW5lb3VzJztcbmltcG9ydCB7IG5ld1Byb21pc2UsIHByb21pc2VSZWplY3RlZFdpdGggfSBmcm9tICcuLi9oZWxwZXJzL3dlYmlkbCc7XG5pbXBvcnQgeyBhc3NlcnRSZXF1aXJlZEFyZ3VtZW50IH0gZnJvbSAnLi4vdmFsaWRhdG9ycy9iYXNpYyc7XG5pbXBvcnQgeyBhc3NlcnRSZWFkYWJsZVN0cmVhbSB9IGZyb20gJy4uL3ZhbGlkYXRvcnMvcmVhZGFibGUtc3RyZWFtJztcbmltcG9ydCB7IElzRGV0YWNoZWRCdWZmZXIgfSBmcm9tICcuLi9hYnN0cmFjdC1vcHMvZWNtYXNjcmlwdCc7XG5cbi8qKlxuICogQSByZXN1bHQgcmV0dXJuZWQgYnkge0BsaW5rIFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlci5yZWFkfS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCB0eXBlIFJlYWRhYmxlU3RyZWFtQllPQlJlYWRSZXN1bHQ8VCBleHRlbmRzIEFycmF5QnVmZmVyVmlldz4gPSB7XG4gIGRvbmU6IGZhbHNlO1xuICB2YWx1ZTogVDtcbn0gfCB7XG4gIGRvbmU6IHRydWU7XG4gIHZhbHVlOiBUIHwgdW5kZWZpbmVkO1xufTtcblxuLy8gQWJzdHJhY3Qgb3BlcmF0aW9ucyBmb3IgdGhlIFJlYWRhYmxlU3RyZWFtLlxuXG5leHBvcnQgZnVuY3Rpb24gQWNxdWlyZVJlYWRhYmxlU3RyZWFtQllPQlJlYWRlcihzdHJlYW06IFJlYWRhYmxlQnl0ZVN0cmVhbSk6IFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlciB7XG4gIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyKHN0cmVhbSk7XG59XG5cbi8vIFJlYWRhYmxlU3RyZWFtIEFQSSBleHBvc2VkIGZvciBjb250cm9sbGVycy5cblxuZXhwb3J0IGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtQWRkUmVhZEludG9SZXF1ZXN0PFQgZXh0ZW5kcyBBcnJheUJ1ZmZlclZpZXc+KHN0cmVhbTogUmVhZGFibGVCeXRlU3RyZWFtLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRJbnRvUmVxdWVzdDogUmVhZEludG9SZXF1ZXN0PFQ+KTogdm9pZCB7XG4gIGFzc2VydChJc1JlYWRhYmxlU3RyZWFtQllPQlJlYWRlcihzdHJlYW0uX3JlYWRlcikpO1xuICBhc3NlcnQoc3RyZWFtLl9zdGF0ZSA9PT0gJ3JlYWRhYmxlJyB8fCBzdHJlYW0uX3N0YXRlID09PSAnY2xvc2VkJyk7XG5cbiAgKHN0cmVhbS5fcmVhZGVyISBhcyBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIpLl9yZWFkSW50b1JlcXVlc3RzLnB1c2gocmVhZEludG9SZXF1ZXN0KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtRnVsZmlsbFJlYWRJbnRvUmVxdWVzdChzdHJlYW06IFJlYWRhYmxlQnl0ZVN0cmVhbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2h1bms6IEFycmF5QnVmZmVyVmlldyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZTogYm9vbGVhbikge1xuICBjb25zdCByZWFkZXIgPSBzdHJlYW0uX3JlYWRlciBhcyBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXI7XG5cbiAgYXNzZXJ0KHJlYWRlci5fcmVhZEludG9SZXF1ZXN0cy5sZW5ndGggPiAwKTtcblxuICBjb25zdCByZWFkSW50b1JlcXVlc3QgPSByZWFkZXIuX3JlYWRJbnRvUmVxdWVzdHMuc2hpZnQoKSE7XG4gIGlmIChkb25lKSB7XG4gICAgcmVhZEludG9SZXF1ZXN0Ll9jbG9zZVN0ZXBzKGNodW5rKTtcbiAgfSBlbHNlIHtcbiAgICByZWFkSW50b1JlcXVlc3QuX2NodW5rU3RlcHMoY2h1bmspO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbUdldE51bVJlYWRJbnRvUmVxdWVzdHMoc3RyZWFtOiBSZWFkYWJsZUJ5dGVTdHJlYW0pOiBudW1iZXIge1xuICByZXR1cm4gKHN0cmVhbS5fcmVhZGVyIGFzIFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlcikuX3JlYWRJbnRvUmVxdWVzdHMubGVuZ3RoO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1IYXNCWU9CUmVhZGVyKHN0cmVhbTogUmVhZGFibGVCeXRlU3RyZWFtKTogYm9vbGVhbiB7XG4gIGNvbnN0IHJlYWRlciA9IHN0cmVhbS5fcmVhZGVyO1xuXG4gIGlmIChyZWFkZXIgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICghSXNSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIocmVhZGVyKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG4vLyBSZWFkZXJzXG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVhZEludG9SZXF1ZXN0PFQgZXh0ZW5kcyBBcnJheUJ1ZmZlclZpZXc+IHtcbiAgX2NodW5rU3RlcHMoY2h1bms6IFQpOiB2b2lkO1xuXG4gIF9jbG9zZVN0ZXBzKGNodW5rOiBUIHwgdW5kZWZpbmVkKTogdm9pZDtcblxuICBfZXJyb3JTdGVwcyhlOiBhbnkpOiB2b2lkO1xufVxuXG4vKipcbiAqIEEgQllPQiByZWFkZXIgdmVuZGVkIGJ5IGEge0BsaW5rIFJlYWRhYmxlU3RyZWFtfS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIge1xuICAvKiogQGludGVybmFsICovXG4gIF9vd25lclJlYWRhYmxlU3RyZWFtITogUmVhZGFibGVCeXRlU3RyZWFtO1xuICAvKiogQGludGVybmFsICovXG4gIF9jbG9zZWRQcm9taXNlITogUHJvbWlzZTx1bmRlZmluZWQ+O1xuICAvKiogQGludGVybmFsICovXG4gIF9jbG9zZWRQcm9taXNlX3Jlc29sdmU/OiAodmFsdWU/OiB1bmRlZmluZWQpID0+IHZvaWQ7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2Nsb3NlZFByb21pc2VfcmVqZWN0PzogKHJlYXNvbjogYW55KSA9PiB2b2lkO1xuICAvKiogQGludGVybmFsICovXG4gIF9yZWFkSW50b1JlcXVlc3RzOiBTaW1wbGVRdWV1ZTxSZWFkSW50b1JlcXVlc3Q8YW55Pj47XG5cbiAgY29uc3RydWN0b3Ioc3RyZWFtOiBSZWFkYWJsZUJ5dGVTdHJlYW0pIHtcbiAgICBhc3NlcnRSZXF1aXJlZEFyZ3VtZW50KHN0cmVhbSwgMSwgJ1JlYWRhYmxlU3RyZWFtQllPQlJlYWRlcicpO1xuICAgIGFzc2VydFJlYWRhYmxlU3RyZWFtKHN0cmVhbSwgJ0ZpcnN0IHBhcmFtZXRlcicpO1xuXG4gICAgaWYgKElzUmVhZGFibGVTdHJlYW1Mb2NrZWQoc3RyZWFtKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhpcyBzdHJlYW0gaGFzIGFscmVhZHkgYmVlbiBsb2NrZWQgZm9yIGV4Y2x1c2l2ZSByZWFkaW5nIGJ5IGFub3RoZXIgcmVhZGVyJyk7XG4gICAgfVxuXG4gICAgaWYgKCFJc1JlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIoc3RyZWFtLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY29uc3RydWN0IGEgUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyIGZvciBhIHN0cmVhbSBub3QgY29uc3RydWN0ZWQgd2l0aCBhIGJ5dGUgJyArXG4gICAgICAgICdzb3VyY2UnKTtcbiAgICB9XG5cbiAgICBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNJbml0aWFsaXplKHRoaXMsIHN0cmVhbSk7XG5cbiAgICB0aGlzLl9yZWFkSW50b1JlcXVlc3RzID0gbmV3IFNpbXBsZVF1ZXVlKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHByb21pc2UgdGhhdCB3aWxsIGJlIGZ1bGZpbGxlZCB3aGVuIHRoZSBzdHJlYW0gYmVjb21lcyBjbG9zZWQsIG9yIHJlamVjdGVkIGlmIHRoZSBzdHJlYW0gZXZlciBlcnJvcnMgb3JcbiAgICogdGhlIHJlYWRlcidzIGxvY2sgaXMgcmVsZWFzZWQgYmVmb3JlIHRoZSBzdHJlYW0gZmluaXNoZXMgY2xvc2luZy5cbiAgICovXG4gIGdldCBjbG9zZWQoKTogUHJvbWlzZTx1bmRlZmluZWQ+IHtcbiAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyKHRoaXMpKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChieW9iUmVhZGVyQnJhbmRDaGVja0V4Y2VwdGlvbignY2xvc2VkJykpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9jbG9zZWRQcm9taXNlO1xuICB9XG5cbiAgLyoqXG4gICAqIElmIHRoZSByZWFkZXIgaXMgYWN0aXZlLCBiZWhhdmVzIHRoZSBzYW1lIGFzIHtAbGluayBSZWFkYWJsZVN0cmVhbS5jYW5jZWwgfCBzdHJlYW0uY2FuY2VsKHJlYXNvbil9LlxuICAgKi9cbiAgY2FuY2VsKHJlYXNvbjogYW55ID0gdW5kZWZpbmVkKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtQllPQlJlYWRlcih0aGlzKSkge1xuICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoYnlvYlJlYWRlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ2NhbmNlbCcpKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fb3duZXJSZWFkYWJsZVN0cmVhbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChyZWFkZXJMb2NrRXhjZXB0aW9uKCdjYW5jZWwnKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY0NhbmNlbCh0aGlzLCByZWFzb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIEF0dGVtcHRzIHRvIHJlYWRzIGJ5dGVzIGludG8gdmlldywgYW5kIHJldHVybnMgYSBwcm9taXNlIHJlc29sdmVkIHdpdGggdGhlIHJlc3VsdC5cbiAgICpcbiAgICogSWYgcmVhZGluZyBhIGNodW5rIGNhdXNlcyB0aGUgcXVldWUgdG8gYmVjb21lIGVtcHR5LCBtb3JlIGRhdGEgd2lsbCBiZSBwdWxsZWQgZnJvbSB0aGUgdW5kZXJseWluZyBzb3VyY2UuXG4gICAqL1xuICByZWFkPFQgZXh0ZW5kcyBBcnJheUJ1ZmZlclZpZXc+KHZpZXc6IFQpOiBQcm9taXNlPFJlYWRhYmxlU3RyZWFtQllPQlJlYWRSZXN1bHQ8VD4+IHtcbiAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyKHRoaXMpKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChieW9iUmVhZGVyQnJhbmRDaGVja0V4Y2VwdGlvbigncmVhZCcpKTtcbiAgICB9XG5cbiAgICBpZiAoIUFycmF5QnVmZmVyLmlzVmlldyh2aWV3KSkge1xuICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgobmV3IFR5cGVFcnJvcigndmlldyBtdXN0IGJlIGFuIGFycmF5IGJ1ZmZlciB2aWV3JykpO1xuICAgIH1cbiAgICBpZiAodmlldy5ieXRlTGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChuZXcgVHlwZUVycm9yKCd2aWV3IG11c3QgaGF2ZSBub24temVybyBieXRlTGVuZ3RoJykpO1xuICAgIH1cbiAgICBpZiAodmlldy5idWZmZXIuYnl0ZUxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgobmV3IFR5cGVFcnJvcihgdmlldydzIGJ1ZmZlciBtdXN0IGhhdmUgbm9uLXplcm8gYnl0ZUxlbmd0aGApKTtcbiAgICB9XG4gICAgaWYgKElzRGV0YWNoZWRCdWZmZXIodmlldy5idWZmZXIpKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChuZXcgVHlwZUVycm9yKCd2aWV3XFwncyBidWZmZXIgaGFzIGJlZW4gZGV0YWNoZWQnKSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX293bmVyUmVhZGFibGVTdHJlYW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgocmVhZGVyTG9ja0V4Y2VwdGlvbigncmVhZCBmcm9tJykpO1xuICAgIH1cblxuICAgIGxldCByZXNvbHZlUHJvbWlzZSE6IChyZXN1bHQ6IFJlYWRhYmxlU3RyZWFtQllPQlJlYWRSZXN1bHQ8VD4pID0+IHZvaWQ7XG4gICAgbGV0IHJlamVjdFByb21pc2UhOiAocmVhc29uOiBhbnkpID0+IHZvaWQ7XG4gICAgY29uc3QgcHJvbWlzZSA9IG5ld1Byb21pc2U8UmVhZGFibGVTdHJlYW1CWU9CUmVhZFJlc3VsdDxUPj4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgcmVzb2x2ZVByb21pc2UgPSByZXNvbHZlO1xuICAgICAgcmVqZWN0UHJvbWlzZSA9IHJlamVjdDtcbiAgICB9KTtcbiAgICBjb25zdCByZWFkSW50b1JlcXVlc3Q6IFJlYWRJbnRvUmVxdWVzdDxUPiA9IHtcbiAgICAgIF9jaHVua1N0ZXBzOiBjaHVuayA9PiByZXNvbHZlUHJvbWlzZSh7IHZhbHVlOiBjaHVuaywgZG9uZTogZmFsc2UgfSksXG4gICAgICBfY2xvc2VTdGVwczogY2h1bmsgPT4gcmVzb2x2ZVByb21pc2UoeyB2YWx1ZTogY2h1bmssIGRvbmU6IHRydWUgfSksXG4gICAgICBfZXJyb3JTdGVwczogZSA9PiByZWplY3RQcm9taXNlKGUpXG4gICAgfTtcbiAgICBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXJSZWFkKHRoaXMsIHZpZXcsIHJlYWRJbnRvUmVxdWVzdCk7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cblxuICAvKipcbiAgICogUmVsZWFzZXMgdGhlIHJlYWRlcidzIGxvY2sgb24gdGhlIGNvcnJlc3BvbmRpbmcgc3RyZWFtLiBBZnRlciB0aGUgbG9jayBpcyByZWxlYXNlZCwgdGhlIHJlYWRlciBpcyBubyBsb25nZXIgYWN0aXZlLlxuICAgKiBJZiB0aGUgYXNzb2NpYXRlZCBzdHJlYW0gaXMgZXJyb3JlZCB3aGVuIHRoZSBsb2NrIGlzIHJlbGVhc2VkLCB0aGUgcmVhZGVyIHdpbGwgYXBwZWFyIGVycm9yZWQgaW4gdGhlIHNhbWUgd2F5XG4gICAqIGZyb20gbm93IG9uOyBvdGhlcndpc2UsIHRoZSByZWFkZXIgd2lsbCBhcHBlYXIgY2xvc2VkLlxuICAgKlxuICAgKiBBIHJlYWRlcidzIGxvY2sgY2Fubm90IGJlIHJlbGVhc2VkIHdoaWxlIGl0IHN0aWxsIGhhcyBhIHBlbmRpbmcgcmVhZCByZXF1ZXN0LCBpLmUuLCBpZiBhIHByb21pc2UgcmV0dXJuZWQgYnlcbiAgICogdGhlIHJlYWRlcidzIHtAbGluayBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIucmVhZCB8IHJlYWQoKX0gbWV0aG9kIGhhcyBub3QgeWV0IGJlZW4gc2V0dGxlZC4gQXR0ZW1wdGluZyB0b1xuICAgKiBkbyBzbyB3aWxsIHRocm93IGEgYFR5cGVFcnJvcmAgYW5kIGxlYXZlIHRoZSByZWFkZXIgbG9ja2VkIHRvIHRoZSBzdHJlYW0uXG4gICAqL1xuICByZWxlYXNlTG9jaygpOiB2b2lkIHtcbiAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyKHRoaXMpKSB7XG4gICAgICB0aHJvdyBieW9iUmVhZGVyQnJhbmRDaGVja0V4Y2VwdGlvbigncmVsZWFzZUxvY2snKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fb3duZXJSZWFkYWJsZVN0cmVhbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3JlYWRJbnRvUmVxdWVzdHMubGVuZ3RoID4gMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVHJpZWQgdG8gcmVsZWFzZSBhIHJlYWRlciBsb2NrIHdoZW4gdGhhdCByZWFkZXIgaGFzIHBlbmRpbmcgcmVhZCgpIGNhbGxzIHVuLXNldHRsZWQnKTtcbiAgICB9XG5cbiAgICBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNSZWxlYXNlKHRoaXMpO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlci5wcm90b3R5cGUsIHtcbiAgY2FuY2VsOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgcmVhZDogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gIHJlbGVhc2VMb2NrOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgY2xvc2VkOiB7IGVudW1lcmFibGU6IHRydWUgfVxufSk7XG5pZiAodHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlci5wcm90b3R5cGUsIFN5bWJvbC50b1N0cmluZ1RhZywge1xuICAgIHZhbHVlOiAnUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyJyxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbi8vIEFic3RyYWN0IG9wZXJhdGlvbnMgZm9yIHRoZSByZWFkZXJzLlxuXG5leHBvcnQgZnVuY3Rpb24gSXNSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIoeDogYW55KTogeCBpcyBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIge1xuICBpZiAoIXR5cGVJc09iamVjdCh4KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdfcmVhZEludG9SZXF1ZXN0cycpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHggaW5zdGFuY2VvZiBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXJSZWFkPFQgZXh0ZW5kcyBBcnJheUJ1ZmZlclZpZXc+KFxuICByZWFkZXI6IFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlcixcbiAgdmlldzogVCxcbiAgcmVhZEludG9SZXF1ZXN0OiBSZWFkSW50b1JlcXVlc3Q8VD5cbik6IHZvaWQge1xuICBjb25zdCBzdHJlYW0gPSByZWFkZXIuX293bmVyUmVhZGFibGVTdHJlYW07XG5cbiAgYXNzZXJ0KHN0cmVhbSAhPT0gdW5kZWZpbmVkKTtcblxuICBzdHJlYW0uX2Rpc3R1cmJlZCA9IHRydWU7XG5cbiAgaWYgKHN0cmVhbS5fc3RhdGUgPT09ICdlcnJvcmVkJykge1xuICAgIHJlYWRJbnRvUmVxdWVzdC5fZXJyb3JTdGVwcyhzdHJlYW0uX3N0b3JlZEVycm9yKTtcbiAgfSBlbHNlIHtcbiAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUHVsbEludG8oXG4gICAgICBzdHJlYW0uX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciBhcyBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyLFxuICAgICAgdmlldyxcbiAgICAgIHJlYWRJbnRvUmVxdWVzdFxuICAgICk7XG4gIH1cbn1cblxuLy8gSGVscGVyIGZ1bmN0aW9ucyBmb3IgdGhlIFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlci5cblxuZnVuY3Rpb24gYnlvYlJlYWRlckJyYW5kQ2hlY2tFeGNlcHRpb24obmFtZTogc3RyaW5nKTogVHlwZUVycm9yIHtcbiAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoXG4gICAgYFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlci5wcm90b3R5cGUuJHtuYW1lfSBjYW4gb25seSBiZSB1c2VkIG9uIGEgUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyYCk7XG59XG4iLCAiaW1wb3J0IHsgUXVldWluZ1N0cmF0ZWd5LCBRdWV1aW5nU3RyYXRlZ3lTaXplQ2FsbGJhY2sgfSBmcm9tICcuLi9xdWV1aW5nLXN0cmF0ZWd5JztcbmltcG9ydCBOdW1iZXJJc05hTiBmcm9tICcuLi8uLi9zdHViL251bWJlci1pc25hbic7XG5cbmV4cG9ydCBmdW5jdGlvbiBFeHRyYWN0SGlnaFdhdGVyTWFyayhzdHJhdGVneTogUXVldWluZ1N0cmF0ZWd5LCBkZWZhdWx0SFdNOiBudW1iZXIpOiBudW1iZXIge1xuICBjb25zdCB7IGhpZ2hXYXRlck1hcmsgfSA9IHN0cmF0ZWd5O1xuXG4gIGlmIChoaWdoV2F0ZXJNYXJrID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gZGVmYXVsdEhXTTtcbiAgfVxuXG4gIGlmIChOdW1iZXJJc05hTihoaWdoV2F0ZXJNYXJrKSB8fCBoaWdoV2F0ZXJNYXJrIDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIGhpZ2hXYXRlck1hcmsnKTtcbiAgfVxuXG4gIHJldHVybiBoaWdoV2F0ZXJNYXJrO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gRXh0cmFjdFNpemVBbGdvcml0aG08VD4oc3RyYXRlZ3k6IFF1ZXVpbmdTdHJhdGVneTxUPik6IFF1ZXVpbmdTdHJhdGVneVNpemVDYWxsYmFjazxUPiB7XG4gIGNvbnN0IHsgc2l6ZSB9ID0gc3RyYXRlZ3k7XG5cbiAgaWYgKCFzaXplKSB7XG4gICAgcmV0dXJuICgpID0+IDE7XG4gIH1cblxuICByZXR1cm4gc2l6ZTtcbn1cbiIsICJpbXBvcnQgeyBRdWV1aW5nU3RyYXRlZ3ksIFF1ZXVpbmdTdHJhdGVneVNpemVDYWxsYmFjayB9IGZyb20gJy4uL3F1ZXVpbmctc3RyYXRlZ3knO1xuaW1wb3J0IHsgYXNzZXJ0RGljdGlvbmFyeSwgYXNzZXJ0RnVuY3Rpb24sIGNvbnZlcnRVbnJlc3RyaWN0ZWREb3VibGUgfSBmcm9tICcuL2Jhc2ljJztcblxuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRRdWV1aW5nU3RyYXRlZ3k8VD4oaW5pdDogUXVldWluZ1N0cmF0ZWd5PFQ+IHwgbnVsbCB8IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IHN0cmluZyk6IFF1ZXVpbmdTdHJhdGVneTxUPiB7XG4gIGFzc2VydERpY3Rpb25hcnkoaW5pdCwgY29udGV4dCk7XG4gIGNvbnN0IGhpZ2hXYXRlck1hcmsgPSBpbml0Py5oaWdoV2F0ZXJNYXJrO1xuICBjb25zdCBzaXplID0gaW5pdD8uc2l6ZTtcbiAgcmV0dXJuIHtcbiAgICBoaWdoV2F0ZXJNYXJrOiBoaWdoV2F0ZXJNYXJrID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBjb252ZXJ0VW5yZXN0cmljdGVkRG91YmxlKGhpZ2hXYXRlck1hcmspLFxuICAgIHNpemU6IHNpemUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IGNvbnZlcnRRdWV1aW5nU3RyYXRlZ3lTaXplKHNpemUsIGAke2NvbnRleHR9IGhhcyBtZW1iZXIgJ3NpemUnIHRoYXRgKVxuICB9O1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0UXVldWluZ1N0cmF0ZWd5U2l6ZTxUPihmbjogUXVldWluZ1N0cmF0ZWd5U2l6ZUNhbGxiYWNrPFQ+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dDogc3RyaW5nKTogUXVldWluZ1N0cmF0ZWd5U2l6ZUNhbGxiYWNrPFQ+IHtcbiAgYXNzZXJ0RnVuY3Rpb24oZm4sIGNvbnRleHQpO1xuICByZXR1cm4gY2h1bmsgPT4gY29udmVydFVucmVzdHJpY3RlZERvdWJsZShmbihjaHVuaykpO1xufVxuIiwgImltcG9ydCB7IGFzc2VydERpY3Rpb25hcnksIGFzc2VydEZ1bmN0aW9uIH0gZnJvbSAnLi9iYXNpYyc7XG5pbXBvcnQgeyBwcm9taXNlQ2FsbCwgcmVmbGVjdENhbGwgfSBmcm9tICcuLi9oZWxwZXJzL3dlYmlkbCc7XG5pbXBvcnQge1xuICBVbmRlcmx5aW5nU2luayxcbiAgVW5kZXJseWluZ1NpbmtBYm9ydENhbGxiYWNrLFxuICBVbmRlcmx5aW5nU2lua0Nsb3NlQ2FsbGJhY2ssXG4gIFVuZGVybHlpbmdTaW5rU3RhcnRDYWxsYmFjayxcbiAgVW5kZXJseWluZ1NpbmtXcml0ZUNhbGxiYWNrLFxuICBWYWxpZGF0ZWRVbmRlcmx5aW5nU2lua1xufSBmcm9tICcuLi93cml0YWJsZS1zdHJlYW0vdW5kZXJseWluZy1zaW5rJztcbmltcG9ydCB7IFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIgfSBmcm9tICcuLi93cml0YWJsZS1zdHJlYW0nO1xuXG5leHBvcnQgZnVuY3Rpb24gY29udmVydFVuZGVybHlpbmdTaW5rPFc+KG9yaWdpbmFsOiBVbmRlcmx5aW5nU2luazxXPiB8IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IHN0cmluZyk6IFZhbGlkYXRlZFVuZGVybHlpbmdTaW5rPFc+IHtcbiAgYXNzZXJ0RGljdGlvbmFyeShvcmlnaW5hbCwgY29udGV4dCk7XG4gIGNvbnN0IGFib3J0ID0gb3JpZ2luYWw/LmFib3J0O1xuICBjb25zdCBjbG9zZSA9IG9yaWdpbmFsPy5jbG9zZTtcbiAgY29uc3Qgc3RhcnQgPSBvcmlnaW5hbD8uc3RhcnQ7XG4gIGNvbnN0IHR5cGUgPSBvcmlnaW5hbD8udHlwZTtcbiAgY29uc3Qgd3JpdGUgPSBvcmlnaW5hbD8ud3JpdGU7XG4gIHJldHVybiB7XG4gICAgYWJvcnQ6IGFib3J0ID09PSB1bmRlZmluZWQgP1xuICAgICAgdW5kZWZpbmVkIDpcbiAgICAgIGNvbnZlcnRVbmRlcmx5aW5nU2lua0Fib3J0Q2FsbGJhY2soYWJvcnQsIG9yaWdpbmFsISwgYCR7Y29udGV4dH0gaGFzIG1lbWJlciAnYWJvcnQnIHRoYXRgKSxcbiAgICBjbG9zZTogY2xvc2UgPT09IHVuZGVmaW5lZCA/XG4gICAgICB1bmRlZmluZWQgOlxuICAgICAgY29udmVydFVuZGVybHlpbmdTaW5rQ2xvc2VDYWxsYmFjayhjbG9zZSwgb3JpZ2luYWwhLCBgJHtjb250ZXh0fSBoYXMgbWVtYmVyICdjbG9zZScgdGhhdGApLFxuICAgIHN0YXJ0OiBzdGFydCA9PT0gdW5kZWZpbmVkID9cbiAgICAgIHVuZGVmaW5lZCA6XG4gICAgICBjb252ZXJ0VW5kZXJseWluZ1NpbmtTdGFydENhbGxiYWNrKHN0YXJ0LCBvcmlnaW5hbCEsIGAke2NvbnRleHR9IGhhcyBtZW1iZXIgJ3N0YXJ0JyB0aGF0YCksXG4gICAgd3JpdGU6IHdyaXRlID09PSB1bmRlZmluZWQgP1xuICAgICAgdW5kZWZpbmVkIDpcbiAgICAgIGNvbnZlcnRVbmRlcmx5aW5nU2lua1dyaXRlQ2FsbGJhY2sod3JpdGUsIG9yaWdpbmFsISwgYCR7Y29udGV4dH0gaGFzIG1lbWJlciAnd3JpdGUnIHRoYXRgKSxcbiAgICB0eXBlXG4gIH07XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRVbmRlcmx5aW5nU2lua0Fib3J0Q2FsbGJhY2soXG4gIGZuOiBVbmRlcmx5aW5nU2lua0Fib3J0Q2FsbGJhY2ssXG4gIG9yaWdpbmFsOiBVbmRlcmx5aW5nU2luayxcbiAgY29udGV4dDogc3RyaW5nXG4pOiAocmVhc29uOiBhbnkpID0+IFByb21pc2U8dm9pZD4ge1xuICBhc3NlcnRGdW5jdGlvbihmbiwgY29udGV4dCk7XG4gIHJldHVybiAocmVhc29uOiBhbnkpID0+IHByb21pc2VDYWxsKGZuLCBvcmlnaW5hbCwgW3JlYXNvbl0pO1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0VW5kZXJseWluZ1NpbmtDbG9zZUNhbGxiYWNrKFxuICBmbjogVW5kZXJseWluZ1NpbmtDbG9zZUNhbGxiYWNrLFxuICBvcmlnaW5hbDogVW5kZXJseWluZ1NpbmssXG4gIGNvbnRleHQ6IHN0cmluZ1xuKTogKCkgPT4gUHJvbWlzZTx2b2lkPiB7XG4gIGFzc2VydEZ1bmN0aW9uKGZuLCBjb250ZXh0KTtcbiAgcmV0dXJuICgpID0+IHByb21pc2VDYWxsKGZuLCBvcmlnaW5hbCwgW10pO1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0VW5kZXJseWluZ1NpbmtTdGFydENhbGxiYWNrKFxuICBmbjogVW5kZXJseWluZ1NpbmtTdGFydENhbGxiYWNrLFxuICBvcmlnaW5hbDogVW5kZXJseWluZ1NpbmssXG4gIGNvbnRleHQ6IHN0cmluZ1xuKTogVW5kZXJseWluZ1NpbmtTdGFydENhbGxiYWNrIHtcbiAgYXNzZXJ0RnVuY3Rpb24oZm4sIGNvbnRleHQpO1xuICByZXR1cm4gKGNvbnRyb2xsZXI6IFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIpID0+IHJlZmxlY3RDYWxsKGZuLCBvcmlnaW5hbCwgW2NvbnRyb2xsZXJdKTtcbn1cblxuZnVuY3Rpb24gY29udmVydFVuZGVybHlpbmdTaW5rV3JpdGVDYWxsYmFjazxXPihcbiAgZm46IFVuZGVybHlpbmdTaW5rV3JpdGVDYWxsYmFjazxXPixcbiAgb3JpZ2luYWw6IFVuZGVybHlpbmdTaW5rPFc+LFxuICBjb250ZXh0OiBzdHJpbmdcbik6IChjaHVuazogVywgY29udHJvbGxlcjogV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcikgPT4gUHJvbWlzZTx2b2lkPiB7XG4gIGFzc2VydEZ1bmN0aW9uKGZuLCBjb250ZXh0KTtcbiAgcmV0dXJuIChjaHVuazogVywgY29udHJvbGxlcjogV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcikgPT4gcHJvbWlzZUNhbGwoZm4sIG9yaWdpbmFsLCBbY2h1bmssIGNvbnRyb2xsZXJdKTtcbn1cbiIsICJpbXBvcnQgeyBJc1dyaXRhYmxlU3RyZWFtLCBXcml0YWJsZVN0cmVhbSB9IGZyb20gJy4uL3dyaXRhYmxlLXN0cmVhbSc7XG5cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRXcml0YWJsZVN0cmVhbSh4OiB1bmtub3duLCBjb250ZXh0OiBzdHJpbmcpOiBhc3NlcnRzIHggaXMgV3JpdGFibGVTdHJlYW0ge1xuICBpZiAoIUlzV3JpdGFibGVTdHJlYW0oeCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke2NvbnRleHR9IGlzIG5vdCBhIFdyaXRhYmxlU3RyZWFtLmApO1xuICB9XG59XG4iLCAiLyoqXG4gKiBBIHNpZ25hbCBvYmplY3QgdGhhdCBhbGxvd3MgeW91IHRvIGNvbW11bmljYXRlIHdpdGggYSByZXF1ZXN0IGFuZCBhYm9ydCBpdCBpZiByZXF1aXJlZFxuICogdmlhIGl0cyBhc3NvY2lhdGVkIGBBYm9ydENvbnRyb2xsZXJgIG9iamVjdC5cbiAqXG4gKiBAcmVtYXJrc1xuICogICBUaGlzIGludGVyZmFjZSBpcyBjb21wYXRpYmxlIHdpdGggdGhlIGBBYm9ydFNpZ25hbGAgaW50ZXJmYWNlIGRlZmluZWQgaW4gVHlwZVNjcmlwdCdzIERPTSB0eXBlcy5cbiAqICAgSXQgaXMgcmVkZWZpbmVkIGhlcmUsIHNvIGl0IGNhbiBiZSBwb2x5ZmlsbGVkIHdpdGhvdXQgYSBET00sIGZvciBleGFtcGxlIHdpdGhcbiAqICAge0BsaW5rIGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL2Fib3J0Y29udHJvbGxlci1wb2x5ZmlsbCB8IGFib3J0Y29udHJvbGxlci1wb2x5ZmlsbH0gaW4gYSBOb2RlIGVudmlyb25tZW50LlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBBYm9ydFNpZ25hbCB7XG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSByZXF1ZXN0IGlzIGFib3J0ZWQuXG4gICAqL1xuICByZWFkb25seSBhYm9ydGVkOiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBBZGQgYW4gZXZlbnQgbGlzdGVuZXIgdG8gYmUgdHJpZ2dlcmVkIHdoZW4gdGhpcyBzaWduYWwgYmVjb21lcyBhYm9ydGVkLlxuICAgKi9cbiAgYWRkRXZlbnRMaXN0ZW5lcih0eXBlOiAnYWJvcnQnLCBsaXN0ZW5lcjogKCkgPT4gdm9pZCk6IHZvaWQ7XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbiBldmVudCBsaXN0ZW5lciB0aGF0IHdhcyBwcmV2aW91c2x5IGFkZGVkIHdpdGgge0BsaW5rIEFib3J0U2lnbmFsLmFkZEV2ZW50TGlzdGVuZXJ9LlxuICAgKi9cbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlOiAnYWJvcnQnLCBsaXN0ZW5lcjogKCkgPT4gdm9pZCk6IHZvaWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0Fib3J0U2lnbmFsKHZhbHVlOiB1bmtub3duKTogdmFsdWUgaXMgQWJvcnRTaWduYWwge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JyB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB0cnkge1xuICAgIHJldHVybiB0eXBlb2YgKHZhbHVlIGFzIEFib3J0U2lnbmFsKS5hYm9ydGVkID09PSAnYm9vbGVhbic7XG4gIH0gY2F0Y2gge1xuICAgIC8vIEFib3J0U2lnbmFsLnByb3RvdHlwZS5hYm9ydGVkIHRocm93cyBpZiBpdHMgYnJhbmQgY2hlY2sgZmFpbHNcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLyoqXG4gKiBBIGNvbnRyb2xsZXIgb2JqZWN0IHRoYXQgYWxsb3dzIHlvdSB0byBhYm9ydCBhbiBgQWJvcnRTaWduYWxgIHdoZW4gZGVzaXJlZC5cbiAqXG4gKiBAcmVtYXJrc1xuICogICBUaGlzIGludGVyZmFjZSBpcyBjb21wYXRpYmxlIHdpdGggdGhlIGBBYm9ydENvbnRyb2xsZXJgIGludGVyZmFjZSBkZWZpbmVkIGluIFR5cGVTY3JpcHQncyBET00gdHlwZXMuXG4gKiAgIEl0IGlzIHJlZGVmaW5lZCBoZXJlLCBzbyBpdCBjYW4gYmUgcG9seWZpbGxlZCB3aXRob3V0IGEgRE9NLCBmb3IgZXhhbXBsZSB3aXRoXG4gKiAgIHtAbGluayBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9hYm9ydGNvbnRyb2xsZXItcG9seWZpbGwgfCBhYm9ydGNvbnRyb2xsZXItcG9seWZpbGx9IGluIGEgTm9kZSBlbnZpcm9ubWVudC5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBBYm9ydENvbnRyb2xsZXIge1xuICByZWFkb25seSBzaWduYWw6IEFib3J0U2lnbmFsO1xuXG4gIGFib3J0KCk6IHZvaWQ7XG59XG5cbmludGVyZmFjZSBBYm9ydENvbnRyb2xsZXJDb25zdHJ1Y3RvciB7XG4gIG5ldygpOiBBYm9ydENvbnRyb2xsZXI7XG59XG5cbmNvbnN0IHN1cHBvcnRzQWJvcnRDb250cm9sbGVyID0gdHlwZW9mIChBYm9ydENvbnRyb2xsZXIgYXMgYW55KSA9PT0gJ2Z1bmN0aW9uJztcblxuLyoqXG4gKiBDb25zdHJ1Y3QgYSBuZXcgQWJvcnRDb250cm9sbGVyLCBpZiBzdXBwb3J0ZWQgYnkgdGhlIHBsYXRmb3JtLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQWJvcnRDb250cm9sbGVyKCk6IEFib3J0Q29udHJvbGxlciB8IHVuZGVmaW5lZCB7XG4gIGlmIChzdXBwb3J0c0Fib3J0Q29udHJvbGxlcikge1xuICAgIHJldHVybiBuZXcgKEFib3J0Q29udHJvbGxlciBhcyBBYm9ydENvbnRyb2xsZXJDb25zdHJ1Y3RvcikoKTtcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuIiwgImltcG9ydCBhc3NlcnQgZnJvbSAnLi4vc3R1Yi9hc3NlcnQnO1xuaW1wb3J0IHtcbiAgbmV3UHJvbWlzZSxcbiAgcHJvbWlzZVJlamVjdGVkV2l0aCxcbiAgcHJvbWlzZVJlc29sdmVkV2l0aCxcbiAgc2V0UHJvbWlzZUlzSGFuZGxlZFRvVHJ1ZSxcbiAgdXBvblByb21pc2Vcbn0gZnJvbSAnLi9oZWxwZXJzL3dlYmlkbCc7XG5pbXBvcnQge1xuICBEZXF1ZXVlVmFsdWUsXG4gIEVucXVldWVWYWx1ZVdpdGhTaXplLFxuICBQZWVrUXVldWVWYWx1ZSxcbiAgUXVldWVQYWlyLFxuICBSZXNldFF1ZXVlXG59IGZyb20gJy4vYWJzdHJhY3Qtb3BzL3F1ZXVlLXdpdGgtc2l6ZXMnO1xuaW1wb3J0IHsgUXVldWluZ1N0cmF0ZWd5LCBRdWV1aW5nU3RyYXRlZ3lTaXplQ2FsbGJhY2sgfSBmcm9tICcuL3F1ZXVpbmctc3RyYXRlZ3knO1xuaW1wb3J0IHsgU2ltcGxlUXVldWUgfSBmcm9tICcuL3NpbXBsZS1xdWV1ZSc7XG5pbXBvcnQgeyB0eXBlSXNPYmplY3QgfSBmcm9tICcuL2hlbHBlcnMvbWlzY2VsbGFuZW91cyc7XG5pbXBvcnQgeyBBYm9ydFN0ZXBzLCBFcnJvclN0ZXBzIH0gZnJvbSAnLi9hYnN0cmFjdC1vcHMvaW50ZXJuYWwtbWV0aG9kcyc7XG5pbXBvcnQgeyBJc05vbk5lZ2F0aXZlTnVtYmVyIH0gZnJvbSAnLi9hYnN0cmFjdC1vcHMvbWlzY2VsbGFuZW91cyc7XG5pbXBvcnQgeyBFeHRyYWN0SGlnaFdhdGVyTWFyaywgRXh0cmFjdFNpemVBbGdvcml0aG0gfSBmcm9tICcuL2Fic3RyYWN0LW9wcy9xdWV1aW5nLXN0cmF0ZWd5JztcbmltcG9ydCB7IGNvbnZlcnRRdWV1aW5nU3RyYXRlZ3kgfSBmcm9tICcuL3ZhbGlkYXRvcnMvcXVldWluZy1zdHJhdGVneSc7XG5pbXBvcnQge1xuICBVbmRlcmx5aW5nU2luayxcbiAgVW5kZXJseWluZ1NpbmtBYm9ydENhbGxiYWNrLFxuICBVbmRlcmx5aW5nU2lua0Nsb3NlQ2FsbGJhY2ssXG4gIFVuZGVybHlpbmdTaW5rU3RhcnRDYWxsYmFjayxcbiAgVW5kZXJseWluZ1NpbmtXcml0ZUNhbGxiYWNrLFxuICBWYWxpZGF0ZWRVbmRlcmx5aW5nU2lua1xufSBmcm9tICcuL3dyaXRhYmxlLXN0cmVhbS91bmRlcmx5aW5nLXNpbmsnO1xuaW1wb3J0IHsgYXNzZXJ0T2JqZWN0LCBhc3NlcnRSZXF1aXJlZEFyZ3VtZW50IH0gZnJvbSAnLi92YWxpZGF0b3JzL2Jhc2ljJztcbmltcG9ydCB7IGNvbnZlcnRVbmRlcmx5aW5nU2luayB9IGZyb20gJy4vdmFsaWRhdG9ycy91bmRlcmx5aW5nLXNpbmsnO1xuaW1wb3J0IHsgYXNzZXJ0V3JpdGFibGVTdHJlYW0gfSBmcm9tICcuL3ZhbGlkYXRvcnMvd3JpdGFibGUtc3RyZWFtJztcbmltcG9ydCB7IEFib3J0Q29udHJvbGxlciwgQWJvcnRTaWduYWwsIGNyZWF0ZUFib3J0Q29udHJvbGxlciB9IGZyb20gJy4vYWJvcnQtc2lnbmFsJztcblxudHlwZSBXcml0YWJsZVN0cmVhbVN0YXRlID0gJ3dyaXRhYmxlJyB8ICdjbG9zZWQnIHwgJ2Vycm9yaW5nJyB8ICdlcnJvcmVkJztcblxuaW50ZXJmYWNlIFdyaXRlT3JDbG9zZVJlcXVlc3Qge1xuICBfcmVzb2x2ZTogKHZhbHVlPzogdW5kZWZpbmVkKSA9PiB2b2lkO1xuICBfcmVqZWN0OiAocmVhc29uOiBhbnkpID0+IHZvaWQ7XG59XG5cbnR5cGUgV3JpdGVSZXF1ZXN0ID0gV3JpdGVPckNsb3NlUmVxdWVzdDtcbnR5cGUgQ2xvc2VSZXF1ZXN0ID0gV3JpdGVPckNsb3NlUmVxdWVzdDtcblxuaW50ZXJmYWNlIFBlbmRpbmdBYm9ydFJlcXVlc3Qge1xuICBfcHJvbWlzZTogUHJvbWlzZTx1bmRlZmluZWQ+O1xuICBfcmVzb2x2ZTogKHZhbHVlPzogdW5kZWZpbmVkKSA9PiB2b2lkO1xuICBfcmVqZWN0OiAocmVhc29uOiBhbnkpID0+IHZvaWQ7XG4gIF9yZWFzb246IGFueTtcbiAgX3dhc0FscmVhZHlFcnJvcmluZzogYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBBIHdyaXRhYmxlIHN0cmVhbSByZXByZXNlbnRzIGEgZGVzdGluYXRpb24gZm9yIGRhdGEsIGludG8gd2hpY2ggeW91IGNhbiB3cml0ZS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmNsYXNzIFdyaXRhYmxlU3RyZWFtPFcgPSBhbnk+IHtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfc3RhdGUhOiBXcml0YWJsZVN0cmVhbVN0YXRlO1xuICAvKiogQGludGVybmFsICovXG4gIF9zdG9yZWRFcnJvcjogYW55O1xuICAvKiogQGludGVybmFsICovXG4gIF93cml0ZXI6IFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcjxXPiB8IHVuZGVmaW5lZDtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfd3JpdGFibGVTdHJlYW1Db250cm9sbGVyITogV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxXPjtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfd3JpdGVSZXF1ZXN0cyE6IFNpbXBsZVF1ZXVlPFdyaXRlUmVxdWVzdD47XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2luRmxpZ2h0V3JpdGVSZXF1ZXN0OiBXcml0ZVJlcXVlc3QgfCB1bmRlZmluZWQ7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2Nsb3NlUmVxdWVzdDogQ2xvc2VSZXF1ZXN0IHwgdW5kZWZpbmVkO1xuICAvKiogQGludGVybmFsICovXG4gIF9pbkZsaWdodENsb3NlUmVxdWVzdDogQ2xvc2VSZXF1ZXN0IHwgdW5kZWZpbmVkO1xuICAvKiogQGludGVybmFsICovXG4gIF9wZW5kaW5nQWJvcnRSZXF1ZXN0OiBQZW5kaW5nQWJvcnRSZXF1ZXN0IHwgdW5kZWZpbmVkO1xuICAvKiogQGludGVybmFsICovXG4gIF9iYWNrcHJlc3N1cmUhOiBib29sZWFuO1xuXG4gIGNvbnN0cnVjdG9yKHVuZGVybHlpbmdTaW5rPzogVW5kZXJseWluZ1Npbms8Vz4sIHN0cmF0ZWd5PzogUXVldWluZ1N0cmF0ZWd5PFc+KTtcbiAgY29uc3RydWN0b3IocmF3VW5kZXJseWluZ1Npbms6IFVuZGVybHlpbmdTaW5rPFc+IHwgbnVsbCB8IHVuZGVmaW5lZCA9IHt9LFxuICAgICAgICAgICAgICByYXdTdHJhdGVneTogUXVldWluZ1N0cmF0ZWd5PFc+IHwgbnVsbCB8IHVuZGVmaW5lZCA9IHt9KSB7XG4gICAgaWYgKHJhd1VuZGVybHlpbmdTaW5rID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJhd1VuZGVybHlpbmdTaW5rID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzZXJ0T2JqZWN0KHJhd1VuZGVybHlpbmdTaW5rLCAnRmlyc3QgcGFyYW1ldGVyJyk7XG4gICAgfVxuXG4gICAgY29uc3Qgc3RyYXRlZ3kgPSBjb252ZXJ0UXVldWluZ1N0cmF0ZWd5KHJhd1N0cmF0ZWd5LCAnU2Vjb25kIHBhcmFtZXRlcicpO1xuICAgIGNvbnN0IHVuZGVybHlpbmdTaW5rID0gY29udmVydFVuZGVybHlpbmdTaW5rKHJhd1VuZGVybHlpbmdTaW5rLCAnRmlyc3QgcGFyYW1ldGVyJyk7XG5cbiAgICBJbml0aWFsaXplV3JpdGFibGVTdHJlYW0odGhpcyk7XG5cbiAgICBjb25zdCB0eXBlID0gdW5kZXJseWluZ1NpbmsudHlwZTtcbiAgICBpZiAodHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCB0eXBlIGlzIHNwZWNpZmllZCcpO1xuICAgIH1cblxuICAgIGNvbnN0IHNpemVBbGdvcml0aG0gPSBFeHRyYWN0U2l6ZUFsZ29yaXRobShzdHJhdGVneSk7XG4gICAgY29uc3QgaGlnaFdhdGVyTWFyayA9IEV4dHJhY3RIaWdoV2F0ZXJNYXJrKHN0cmF0ZWd5LCAxKTtcblxuICAgIFNldFVwV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckZyb21VbmRlcmx5aW5nU2luayh0aGlzLCB1bmRlcmx5aW5nU2luaywgaGlnaFdhdGVyTWFyaywgc2l6ZUFsZ29yaXRobSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgd3JpdGFibGUgc3RyZWFtIGlzIGxvY2tlZCB0byBhIHdyaXRlci5cbiAgICovXG4gIGdldCBsb2NrZWQoKTogYm9vbGVhbiB7XG4gICAgaWYgKCFJc1dyaXRhYmxlU3RyZWFtKHRoaXMpKSB7XG4gICAgICB0aHJvdyBzdHJlYW1CcmFuZENoZWNrRXhjZXB0aW9uKCdsb2NrZWQnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gSXNXcml0YWJsZVN0cmVhbUxvY2tlZCh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBYm9ydHMgdGhlIHN0cmVhbSwgc2lnbmFsaW5nIHRoYXQgdGhlIHByb2R1Y2VyIGNhbiBubyBsb25nZXIgc3VjY2Vzc2Z1bGx5IHdyaXRlIHRvIHRoZSBzdHJlYW0gYW5kIGl0IGlzIHRvIGJlXG4gICAqIGltbWVkaWF0ZWx5IG1vdmVkIHRvIGFuIGVycm9yZWQgc3RhdGUsIHdpdGggYW55IHF1ZXVlZC11cCB3cml0ZXMgZGlzY2FyZGVkLiBUaGlzIHdpbGwgYWxzbyBleGVjdXRlIGFueSBhYm9ydFxuICAgKiBtZWNoYW5pc20gb2YgdGhlIHVuZGVybHlpbmcgc2luay5cbiAgICpcbiAgICogVGhlIHJldHVybmVkIHByb21pc2Ugd2lsbCBmdWxmaWxsIGlmIHRoZSBzdHJlYW0gc2h1dHMgZG93biBzdWNjZXNzZnVsbHksIG9yIHJlamVjdCBpZiB0aGUgdW5kZXJseWluZyBzaW5rIHNpZ25hbGVkXG4gICAqIHRoYXQgdGhlcmUgd2FzIGFuIGVycm9yIGRvaW5nIHNvLiBBZGRpdGlvbmFsbHksIGl0IHdpbGwgcmVqZWN0IHdpdGggYSBgVHlwZUVycm9yYCAod2l0aG91dCBhdHRlbXB0aW5nIHRvIGNhbmNlbFxuICAgKiB0aGUgc3RyZWFtKSBpZiB0aGUgc3RyZWFtIGlzIGN1cnJlbnRseSBsb2NrZWQuXG4gICAqL1xuICBhYm9ydChyZWFzb246IGFueSA9IHVuZGVmaW5lZCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICghSXNXcml0YWJsZVN0cmVhbSh0aGlzKSkge1xuICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoc3RyZWFtQnJhbmRDaGVja0V4Y2VwdGlvbignYWJvcnQnKSk7XG4gICAgfVxuXG4gICAgaWYgKElzV3JpdGFibGVTdHJlYW1Mb2NrZWQodGhpcykpIHtcbiAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBhYm9ydCBhIHN0cmVhbSB0aGF0IGFscmVhZHkgaGFzIGEgd3JpdGVyJykpO1xuICAgIH1cblxuICAgIHJldHVybiBXcml0YWJsZVN0cmVhbUFib3J0KHRoaXMsIHJlYXNvbik7XG4gIH1cblxuICAvKipcbiAgICogQ2xvc2VzIHRoZSBzdHJlYW0uIFRoZSB1bmRlcmx5aW5nIHNpbmsgd2lsbCBmaW5pc2ggcHJvY2Vzc2luZyBhbnkgcHJldmlvdXNseS13cml0dGVuIGNodW5rcywgYmVmb3JlIGludm9raW5nIGl0c1xuICAgKiBjbG9zZSBiZWhhdmlvci4gRHVyaW5nIHRoaXMgdGltZSBhbnkgZnVydGhlciBhdHRlbXB0cyB0byB3cml0ZSB3aWxsIGZhaWwgKHdpdGhvdXQgZXJyb3JpbmcgdGhlIHN0cmVhbSkuXG4gICAqXG4gICAqIFRoZSBtZXRob2QgcmV0dXJucyBhIHByb21pc2UgdGhhdCB3aWxsIGZ1bGZpbGwgaWYgYWxsIHJlbWFpbmluZyBjaHVua3MgYXJlIHN1Y2Nlc3NmdWxseSB3cml0dGVuIGFuZCB0aGUgc3RyZWFtXG4gICAqIHN1Y2Nlc3NmdWxseSBjbG9zZXMsIG9yIHJlamVjdHMgaWYgYW4gZXJyb3IgaXMgZW5jb3VudGVyZWQgZHVyaW5nIHRoaXMgcHJvY2Vzcy4gQWRkaXRpb25hbGx5LCBpdCB3aWxsIHJlamVjdCB3aXRoXG4gICAqIGEgYFR5cGVFcnJvcmAgKHdpdGhvdXQgYXR0ZW1wdGluZyB0byBjYW5jZWwgdGhlIHN0cmVhbSkgaWYgdGhlIHN0cmVhbSBpcyBjdXJyZW50bHkgbG9ja2VkLlxuICAgKi9cbiAgY2xvc2UoKSB7XG4gICAgaWYgKCFJc1dyaXRhYmxlU3RyZWFtKHRoaXMpKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChzdHJlYW1CcmFuZENoZWNrRXhjZXB0aW9uKCdjbG9zZScpKTtcbiAgICB9XG5cbiAgICBpZiAoSXNXcml0YWJsZVN0cmVhbUxvY2tlZCh0aGlzKSkge1xuICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgobmV3IFR5cGVFcnJvcignQ2Fubm90IGNsb3NlIGEgc3RyZWFtIHRoYXQgYWxyZWFkeSBoYXMgYSB3cml0ZXInKSk7XG4gICAgfVxuXG4gICAgaWYgKFdyaXRhYmxlU3RyZWFtQ2xvc2VRdWV1ZWRPckluRmxpZ2h0KHRoaXMpKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2xvc2UgYW4gYWxyZWFkeS1jbG9zaW5nIHN0cmVhbScpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gV3JpdGFibGVTdHJlYW1DbG9zZSh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEge0BsaW5rIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlciB8IHdyaXRlcn0gYW5kIGxvY2tzIHRoZSBzdHJlYW0gdG8gdGhlIG5ldyB3cml0ZXIuIFdoaWxlIHRoZSBzdHJlYW1cbiAgICogaXMgbG9ja2VkLCBubyBvdGhlciB3cml0ZXIgY2FuIGJlIGFjcXVpcmVkIHVudGlsIHRoaXMgb25lIGlzIHJlbGVhc2VkLlxuICAgKlxuICAgKiBUaGlzIGZ1bmN0aW9uYWxpdHkgaXMgZXNwZWNpYWxseSB1c2VmdWwgZm9yIGNyZWF0aW5nIGFic3RyYWN0aW9ucyB0aGF0IGRlc2lyZSB0aGUgYWJpbGl0eSB0byB3cml0ZSB0byBhIHN0cmVhbVxuICAgKiB3aXRob3V0IGludGVycnVwdGlvbiBvciBpbnRlcmxlYXZpbmcuIEJ5IGdldHRpbmcgYSB3cml0ZXIgZm9yIHRoZSBzdHJlYW0sIHlvdSBjYW4gZW5zdXJlIG5vYm9keSBlbHNlIGNhbiB3cml0ZSBhdFxuICAgKiB0aGUgc2FtZSB0aW1lLCB3aGljaCB3b3VsZCBjYXVzZSB0aGUgcmVzdWx0aW5nIHdyaXR0ZW4gZGF0YSB0byBiZSB1bnByZWRpY3RhYmxlIGFuZCBwcm9iYWJseSB1c2VsZXNzLlxuICAgKi9cbiAgZ2V0V3JpdGVyKCk6IFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcjxXPiB7XG4gICAgaWYgKCFJc1dyaXRhYmxlU3RyZWFtKHRoaXMpKSB7XG4gICAgICB0aHJvdyBzdHJlYW1CcmFuZENoZWNrRXhjZXB0aW9uKCdnZXRXcml0ZXInKTtcbiAgICB9XG5cbiAgICByZXR1cm4gQWNxdWlyZVdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcih0aGlzKTtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhXcml0YWJsZVN0cmVhbS5wcm90b3R5cGUsIHtcbiAgYWJvcnQ6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICBjbG9zZTogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gIGdldFdyaXRlcjogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gIGxvY2tlZDogeyBlbnVtZXJhYmxlOiB0cnVlIH1cbn0pO1xuaWYgKHR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWcgPT09ICdzeW1ib2wnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZVN0cmVhbS5wcm90b3R5cGUsIFN5bWJvbC50b1N0cmluZ1RhZywge1xuICAgIHZhbHVlOiAnV3JpdGFibGVTdHJlYW0nLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuZXhwb3J0IHtcbiAgQWNxdWlyZVdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcixcbiAgQ3JlYXRlV3JpdGFibGVTdHJlYW0sXG4gIElzV3JpdGFibGVTdHJlYW0sXG4gIElzV3JpdGFibGVTdHJlYW1Mb2NrZWQsXG4gIFdyaXRhYmxlU3RyZWFtLFxuICBXcml0YWJsZVN0cmVhbUFib3J0LFxuICBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3JJZk5lZWRlZCxcbiAgV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyQ2xvc2VXaXRoRXJyb3JQcm9wYWdhdGlvbixcbiAgV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyUmVsZWFzZSxcbiAgV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyV3JpdGUsXG4gIFdyaXRhYmxlU3RyZWFtQ2xvc2VRdWV1ZWRPckluRmxpZ2h0LFxuICBVbmRlcmx5aW5nU2luayxcbiAgVW5kZXJseWluZ1NpbmtTdGFydENhbGxiYWNrLFxuICBVbmRlcmx5aW5nU2lua1dyaXRlQ2FsbGJhY2ssXG4gIFVuZGVybHlpbmdTaW5rQ2xvc2VDYWxsYmFjayxcbiAgVW5kZXJseWluZ1NpbmtBYm9ydENhbGxiYWNrXG59O1xuXG4vLyBBYnN0cmFjdCBvcGVyYXRpb25zIGZvciB0aGUgV3JpdGFibGVTdHJlYW0uXG5cbmZ1bmN0aW9uIEFjcXVpcmVXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXI8Vz4oc3RyZWFtOiBXcml0YWJsZVN0cmVhbTxXPik6IFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcjxXPiB7XG4gIHJldHVybiBuZXcgV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyKHN0cmVhbSk7XG59XG5cbi8vIFRocm93cyBpZiBhbmQgb25seSBpZiBzdGFydEFsZ29yaXRobSB0aHJvd3MuXG5mdW5jdGlvbiBDcmVhdGVXcml0YWJsZVN0cmVhbTxXPihzdGFydEFsZ29yaXRobTogKCkgPT4gdm9pZCB8IFByb21pc2VMaWtlPHZvaWQ+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGVBbGdvcml0aG06IChjaHVuazogVykgPT4gUHJvbWlzZTx2b2lkPixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb3NlQWxnb3JpdGhtOiAoKSA9PiBQcm9taXNlPHZvaWQ+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWJvcnRBbGdvcml0aG06IChyZWFzb246IGFueSkgPT4gUHJvbWlzZTx2b2lkPixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpZ2hXYXRlck1hcmsgPSAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZUFsZ29yaXRobTogUXVldWluZ1N0cmF0ZWd5U2l6ZUNhbGxiYWNrPFc+ID0gKCkgPT4gMSkge1xuICBhc3NlcnQoSXNOb25OZWdhdGl2ZU51bWJlcihoaWdoV2F0ZXJNYXJrKSk7XG5cbiAgY29uc3Qgc3RyZWFtOiBXcml0YWJsZVN0cmVhbTxXPiA9IE9iamVjdC5jcmVhdGUoV3JpdGFibGVTdHJlYW0ucHJvdG90eXBlKTtcbiAgSW5pdGlhbGl6ZVdyaXRhYmxlU3RyZWFtKHN0cmVhbSk7XG5cbiAgY29uc3QgY29udHJvbGxlcjogV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxXPiA9IE9iamVjdC5jcmVhdGUoV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUpO1xuXG4gIFNldFVwV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcihzdHJlYW0sIGNvbnRyb2xsZXIsIHN0YXJ0QWxnb3JpdGhtLCB3cml0ZUFsZ29yaXRobSwgY2xvc2VBbGdvcml0aG0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhYm9ydEFsZ29yaXRobSwgaGlnaFdhdGVyTWFyaywgc2l6ZUFsZ29yaXRobSk7XG4gIHJldHVybiBzdHJlYW07XG59XG5cbmZ1bmN0aW9uIEluaXRpYWxpemVXcml0YWJsZVN0cmVhbTxXPihzdHJlYW06IFdyaXRhYmxlU3RyZWFtPFc+KSB7XG4gIHN0cmVhbS5fc3RhdGUgPSAnd3JpdGFibGUnO1xuXG4gIC8vIFRoZSBlcnJvciB0aGF0IHdpbGwgYmUgcmVwb3J0ZWQgYnkgbmV3IG1ldGhvZCBjYWxscyBvbmNlIHRoZSBzdGF0ZSBiZWNvbWVzIGVycm9yZWQuIE9ubHkgc2V0IHdoZW4gW1tzdGF0ZV1dIGlzXG4gIC8vICdlcnJvcmluZycgb3IgJ2Vycm9yZWQnLiBNYXkgYmUgc2V0IHRvIGFuIHVuZGVmaW5lZCB2YWx1ZS5cbiAgc3RyZWFtLl9zdG9yZWRFcnJvciA9IHVuZGVmaW5lZDtcblxuICBzdHJlYW0uX3dyaXRlciA9IHVuZGVmaW5lZDtcblxuICAvLyBJbml0aWFsaXplIHRvIHVuZGVmaW5lZCBmaXJzdCBiZWNhdXNlIHRoZSBjb25zdHJ1Y3RvciBvZiB0aGUgY29udHJvbGxlciBjaGVja3MgdGhpc1xuICAvLyB2YXJpYWJsZSB0byB2YWxpZGF0ZSB0aGUgY2FsbGVyLlxuICBzdHJlYW0uX3dyaXRhYmxlU3RyZWFtQ29udHJvbGxlciA9IHVuZGVmaW5lZCE7XG5cbiAgLy8gVGhpcyBxdWV1ZSBpcyBwbGFjZWQgaGVyZSBpbnN0ZWFkIG9mIHRoZSB3cml0ZXIgY2xhc3MgaW4gb3JkZXIgdG8gYWxsb3cgZm9yIHBhc3NpbmcgYSB3cml0ZXIgdG8gdGhlIG5leHQgZGF0YVxuICAvLyBwcm9kdWNlciB3aXRob3V0IHdhaXRpbmcgZm9yIHRoZSBxdWV1ZWQgd3JpdGVzIHRvIGZpbmlzaC5cbiAgc3RyZWFtLl93cml0ZVJlcXVlc3RzID0gbmV3IFNpbXBsZVF1ZXVlKCk7XG5cbiAgLy8gV3JpdGUgcmVxdWVzdHMgYXJlIHJlbW92ZWQgZnJvbSBfd3JpdGVSZXF1ZXN0cyB3aGVuIHdyaXRlKCkgaXMgY2FsbGVkIG9uIHRoZSB1bmRlcmx5aW5nIHNpbmsuIFRoaXMgcHJldmVudHNcbiAgLy8gdGhlbSBmcm9tIGJlaW5nIGVycm9uZW91c2x5IHJlamVjdGVkIG9uIGVycm9yLiBJZiBhIHdyaXRlKCkgY2FsbCBpcyBpbi1mbGlnaHQsIHRoZSByZXF1ZXN0IGlzIHN0b3JlZCBoZXJlLlxuICBzdHJlYW0uX2luRmxpZ2h0V3JpdGVSZXF1ZXN0ID0gdW5kZWZpbmVkO1xuXG4gIC8vIFRoZSBwcm9taXNlIHRoYXQgd2FzIHJldHVybmVkIGZyb20gd3JpdGVyLmNsb3NlKCkuIFN0b3JlZCBoZXJlIGJlY2F1c2UgaXQgbWF5IGJlIGZ1bGZpbGxlZCBhZnRlciB0aGUgd3JpdGVyXG4gIC8vIGhhcyBiZWVuIGRldGFjaGVkLlxuICBzdHJlYW0uX2Nsb3NlUmVxdWVzdCA9IHVuZGVmaW5lZDtcblxuICAvLyBDbG9zZSByZXF1ZXN0IGlzIHJlbW92ZWQgZnJvbSBfY2xvc2VSZXF1ZXN0IHdoZW4gY2xvc2UoKSBpcyBjYWxsZWQgb24gdGhlIHVuZGVybHlpbmcgc2luay4gVGhpcyBwcmV2ZW50cyBpdFxuICAvLyBmcm9tIGJlaW5nIGVycm9uZW91c2x5IHJlamVjdGVkIG9uIGVycm9yLiBJZiBhIGNsb3NlKCkgY2FsbCBpcyBpbi1mbGlnaHQsIHRoZSByZXF1ZXN0IGlzIHN0b3JlZCBoZXJlLlxuICBzdHJlYW0uX2luRmxpZ2h0Q2xvc2VSZXF1ZXN0ID0gdW5kZWZpbmVkO1xuXG4gIC8vIFRoZSBwcm9taXNlIHRoYXQgd2FzIHJldHVybmVkIGZyb20gd3JpdGVyLmFib3J0KCkuIFRoaXMgbWF5IGFsc28gYmUgZnVsZmlsbGVkIGFmdGVyIHRoZSB3cml0ZXIgaGFzIGRldGFjaGVkLlxuICBzdHJlYW0uX3BlbmRpbmdBYm9ydFJlcXVlc3QgPSB1bmRlZmluZWQ7XG5cbiAgLy8gVGhlIGJhY2twcmVzc3VyZSBzaWduYWwgc2V0IGJ5IHRoZSBjb250cm9sbGVyLlxuICBzdHJlYW0uX2JhY2twcmVzc3VyZSA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBJc1dyaXRhYmxlU3RyZWFtKHg6IHVua25vd24pOiB4IGlzIFdyaXRhYmxlU3RyZWFtIHtcbiAgaWYgKCF0eXBlSXNPYmplY3QoeCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnX3dyaXRhYmxlU3RyZWFtQ29udHJvbGxlcicpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHggaW5zdGFuY2VvZiBXcml0YWJsZVN0cmVhbTtcbn1cblxuZnVuY3Rpb24gSXNXcml0YWJsZVN0cmVhbUxvY2tlZChzdHJlYW06IFdyaXRhYmxlU3RyZWFtKTogYm9vbGVhbiB7XG4gIGFzc2VydChJc1dyaXRhYmxlU3RyZWFtKHN0cmVhbSkpO1xuXG4gIGlmIChzdHJlYW0uX3dyaXRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtQWJvcnQoc3RyZWFtOiBXcml0YWJsZVN0cmVhbSwgcmVhc29uOiBhbnkpOiBQcm9taXNlPHVuZGVmaW5lZD4ge1xuICBpZiAoc3RyZWFtLl9zdGF0ZSA9PT0gJ2Nsb3NlZCcgfHwgc3RyZWFtLl9zdGF0ZSA9PT0gJ2Vycm9yZWQnKSB7XG4gICAgcmV0dXJuIHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcbiAgfVxuICBzdHJlYW0uX3dyaXRhYmxlU3RyZWFtQ29udHJvbGxlci5fYWJvcnRSZWFzb24gPSByZWFzb247XG4gIHN0cmVhbS5fd3JpdGFibGVTdHJlYW1Db250cm9sbGVyLl9hYm9ydENvbnRyb2xsZXI/LmFib3J0KCk7XG5cbiAgLy8gVHlwZVNjcmlwdCBuYXJyb3dzIHRoZSB0eXBlIG9mIGBzdHJlYW0uX3N0YXRlYCBkb3duIHRvICd3cml0YWJsZScgfCAnZXJyb3JpbmcnLFxuICAvLyBidXQgaXQgZG9lc24ndCBrbm93IHRoYXQgc2lnbmFsaW5nIGFib3J0IHJ1bnMgYXV0aG9yIGNvZGUgdGhhdCBtaWdodCBoYXZlIGNoYW5nZWQgdGhlIHN0YXRlLlxuICAvLyBXaWRlbiB0aGUgdHlwZSBhZ2FpbiBieSBjYXN0aW5nIHRvIFdyaXRhYmxlU3RyZWFtU3RhdGUuXG4gIGNvbnN0IHN0YXRlID0gc3RyZWFtLl9zdGF0ZSBhcyBXcml0YWJsZVN0cmVhbVN0YXRlO1xuXG4gIGlmIChzdGF0ZSA9PT0gJ2Nsb3NlZCcgfHwgc3RhdGUgPT09ICdlcnJvcmVkJykge1xuICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG4gIH1cbiAgaWYgKHN0cmVhbS5fcGVuZGluZ0Fib3J0UmVxdWVzdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHN0cmVhbS5fcGVuZGluZ0Fib3J0UmVxdWVzdC5fcHJvbWlzZTtcbiAgfVxuXG4gIGFzc2VydChzdGF0ZSA9PT0gJ3dyaXRhYmxlJyB8fCBzdGF0ZSA9PT0gJ2Vycm9yaW5nJyk7XG5cbiAgbGV0IHdhc0FscmVhZHlFcnJvcmluZyA9IGZhbHNlO1xuICBpZiAoc3RhdGUgPT09ICdlcnJvcmluZycpIHtcbiAgICB3YXNBbHJlYWR5RXJyb3JpbmcgPSB0cnVlO1xuICAgIC8vIHJlYXNvbiB3aWxsIG5vdCBiZSB1c2VkLCBzbyBkb24ndCBrZWVwIGEgcmVmZXJlbmNlIHRvIGl0LlxuICAgIHJlYXNvbiA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGNvbnN0IHByb21pc2UgPSBuZXdQcm9taXNlPHVuZGVmaW5lZD4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHN0cmVhbS5fcGVuZGluZ0Fib3J0UmVxdWVzdCA9IHtcbiAgICAgIF9wcm9taXNlOiB1bmRlZmluZWQhLFxuICAgICAgX3Jlc29sdmU6IHJlc29sdmUsXG4gICAgICBfcmVqZWN0OiByZWplY3QsXG4gICAgICBfcmVhc29uOiByZWFzb24sXG4gICAgICBfd2FzQWxyZWFkeUVycm9yaW5nOiB3YXNBbHJlYWR5RXJyb3JpbmdcbiAgICB9O1xuICB9KTtcbiAgc3RyZWFtLl9wZW5kaW5nQWJvcnRSZXF1ZXN0IS5fcHJvbWlzZSA9IHByb21pc2U7XG5cbiAgaWYgKCF3YXNBbHJlYWR5RXJyb3JpbmcpIHtcbiAgICBXcml0YWJsZVN0cmVhbVN0YXJ0RXJyb3Jpbmcoc3RyZWFtLCByZWFzb24pO1xuICB9XG5cbiAgcmV0dXJuIHByb21pc2U7XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtQ2xvc2Uoc3RyZWFtOiBXcml0YWJsZVN0cmVhbTxhbnk+KTogUHJvbWlzZTx1bmRlZmluZWQ+IHtcbiAgY29uc3Qgc3RhdGUgPSBzdHJlYW0uX3N0YXRlO1xuICBpZiAoc3RhdGUgPT09ICdjbG9zZWQnIHx8IHN0YXRlID09PSAnZXJyb3JlZCcpIHtcbiAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChuZXcgVHlwZUVycm9yKFxuICAgICAgYFRoZSBzdHJlYW0gKGluICR7c3RhdGV9IHN0YXRlKSBpcyBub3QgaW4gdGhlIHdyaXRhYmxlIHN0YXRlIGFuZCBjYW5ub3QgYmUgY2xvc2VkYCkpO1xuICB9XG5cbiAgYXNzZXJ0KHN0YXRlID09PSAnd3JpdGFibGUnIHx8IHN0YXRlID09PSAnZXJyb3JpbmcnKTtcbiAgYXNzZXJ0KCFXcml0YWJsZVN0cmVhbUNsb3NlUXVldWVkT3JJbkZsaWdodChzdHJlYW0pKTtcblxuICBjb25zdCBwcm9taXNlID0gbmV3UHJvbWlzZTx1bmRlZmluZWQ+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCBjbG9zZVJlcXVlc3Q6IENsb3NlUmVxdWVzdCA9IHtcbiAgICAgIF9yZXNvbHZlOiByZXNvbHZlLFxuICAgICAgX3JlamVjdDogcmVqZWN0XG4gICAgfTtcblxuICAgIHN0cmVhbS5fY2xvc2VSZXF1ZXN0ID0gY2xvc2VSZXF1ZXN0O1xuICB9KTtcblxuICBjb25zdCB3cml0ZXIgPSBzdHJlYW0uX3dyaXRlcjtcbiAgaWYgKHdyaXRlciAhPT0gdW5kZWZpbmVkICYmIHN0cmVhbS5fYmFja3ByZXNzdXJlICYmIHN0YXRlID09PSAnd3JpdGFibGUnKSB7XG4gICAgZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZVJlc29sdmUod3JpdGVyKTtcbiAgfVxuXG4gIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbG9zZShzdHJlYW0uX3dyaXRhYmxlU3RyZWFtQ29udHJvbGxlcik7XG5cbiAgcmV0dXJuIHByb21pc2U7XG59XG5cbi8vIFdyaXRhYmxlU3RyZWFtIEFQSSBleHBvc2VkIGZvciBjb250cm9sbGVycy5cblxuZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1BZGRXcml0ZVJlcXVlc3Qoc3RyZWFtOiBXcml0YWJsZVN0cmVhbSk6IFByb21pc2U8dW5kZWZpbmVkPiB7XG4gIGFzc2VydChJc1dyaXRhYmxlU3RyZWFtTG9ja2VkKHN0cmVhbSkpO1xuICBhc3NlcnQoc3RyZWFtLl9zdGF0ZSA9PT0gJ3dyaXRhYmxlJyk7XG5cbiAgY29uc3QgcHJvbWlzZSA9IG5ld1Byb21pc2U8dW5kZWZpbmVkPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3Qgd3JpdGVSZXF1ZXN0OiBXcml0ZVJlcXVlc3QgPSB7XG4gICAgICBfcmVzb2x2ZTogcmVzb2x2ZSxcbiAgICAgIF9yZWplY3Q6IHJlamVjdFxuICAgIH07XG5cbiAgICBzdHJlYW0uX3dyaXRlUmVxdWVzdHMucHVzaCh3cml0ZVJlcXVlc3QpO1xuICB9KTtcblxuICByZXR1cm4gcHJvbWlzZTtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1EZWFsV2l0aFJlamVjdGlvbihzdHJlYW06IFdyaXRhYmxlU3RyZWFtLCBlcnJvcjogYW55KSB7XG4gIGNvbnN0IHN0YXRlID0gc3RyZWFtLl9zdGF0ZTtcblxuICBpZiAoc3RhdGUgPT09ICd3cml0YWJsZScpIHtcbiAgICBXcml0YWJsZVN0cmVhbVN0YXJ0RXJyb3Jpbmcoc3RyZWFtLCBlcnJvcik7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgYXNzZXJ0KHN0YXRlID09PSAnZXJyb3JpbmcnKTtcbiAgV3JpdGFibGVTdHJlYW1GaW5pc2hFcnJvcmluZyhzdHJlYW0pO1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0cmVhbVN0YXJ0RXJyb3Jpbmcoc3RyZWFtOiBXcml0YWJsZVN0cmVhbSwgcmVhc29uOiBhbnkpIHtcbiAgYXNzZXJ0KHN0cmVhbS5fc3RvcmVkRXJyb3IgPT09IHVuZGVmaW5lZCk7XG4gIGFzc2VydChzdHJlYW0uX3N0YXRlID09PSAnd3JpdGFibGUnKTtcblxuICBjb25zdCBjb250cm9sbGVyID0gc3RyZWFtLl93cml0YWJsZVN0cmVhbUNvbnRyb2xsZXI7XG4gIGFzc2VydChjb250cm9sbGVyICE9PSB1bmRlZmluZWQpO1xuXG4gIHN0cmVhbS5fc3RhdGUgPSAnZXJyb3JpbmcnO1xuICBzdHJlYW0uX3N0b3JlZEVycm9yID0gcmVhc29uO1xuICBjb25zdCB3cml0ZXIgPSBzdHJlYW0uX3dyaXRlcjtcbiAgaWYgKHdyaXRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyRW5zdXJlUmVhZHlQcm9taXNlUmVqZWN0ZWQod3JpdGVyLCByZWFzb24pO1xuICB9XG5cbiAgaWYgKCFXcml0YWJsZVN0cmVhbUhhc09wZXJhdGlvbk1hcmtlZEluRmxpZ2h0KHN0cmVhbSkgJiYgY29udHJvbGxlci5fc3RhcnRlZCkge1xuICAgIFdyaXRhYmxlU3RyZWFtRmluaXNoRXJyb3Jpbmcoc3RyZWFtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0cmVhbUZpbmlzaEVycm9yaW5nKHN0cmVhbTogV3JpdGFibGVTdHJlYW0pIHtcbiAgYXNzZXJ0KHN0cmVhbS5fc3RhdGUgPT09ICdlcnJvcmluZycpO1xuICBhc3NlcnQoIVdyaXRhYmxlU3RyZWFtSGFzT3BlcmF0aW9uTWFya2VkSW5GbGlnaHQoc3RyZWFtKSk7XG4gIHN0cmVhbS5fc3RhdGUgPSAnZXJyb3JlZCc7XG4gIHN0cmVhbS5fd3JpdGFibGVTdHJlYW1Db250cm9sbGVyW0Vycm9yU3RlcHNdKCk7XG5cbiAgY29uc3Qgc3RvcmVkRXJyb3IgPSBzdHJlYW0uX3N0b3JlZEVycm9yO1xuICBzdHJlYW0uX3dyaXRlUmVxdWVzdHMuZm9yRWFjaCh3cml0ZVJlcXVlc3QgPT4ge1xuICAgIHdyaXRlUmVxdWVzdC5fcmVqZWN0KHN0b3JlZEVycm9yKTtcbiAgfSk7XG4gIHN0cmVhbS5fd3JpdGVSZXF1ZXN0cyA9IG5ldyBTaW1wbGVRdWV1ZSgpO1xuXG4gIGlmIChzdHJlYW0uX3BlbmRpbmdBYm9ydFJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgIFdyaXRhYmxlU3RyZWFtUmVqZWN0Q2xvc2VBbmRDbG9zZWRQcm9taXNlSWZOZWVkZWQoc3RyZWFtKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBhYm9ydFJlcXVlc3QgPSBzdHJlYW0uX3BlbmRpbmdBYm9ydFJlcXVlc3Q7XG4gIHN0cmVhbS5fcGVuZGluZ0Fib3J0UmVxdWVzdCA9IHVuZGVmaW5lZDtcblxuICBpZiAoYWJvcnRSZXF1ZXN0Ll93YXNBbHJlYWR5RXJyb3JpbmcpIHtcbiAgICBhYm9ydFJlcXVlc3QuX3JlamVjdChzdG9yZWRFcnJvcik7XG4gICAgV3JpdGFibGVTdHJlYW1SZWplY3RDbG9zZUFuZENsb3NlZFByb21pc2VJZk5lZWRlZChzdHJlYW0pO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHByb21pc2UgPSBzdHJlYW0uX3dyaXRhYmxlU3RyZWFtQ29udHJvbGxlcltBYm9ydFN0ZXBzXShhYm9ydFJlcXVlc3QuX3JlYXNvbik7XG4gIHVwb25Qcm9taXNlKFxuICAgIHByb21pc2UsXG4gICAgKCkgPT4ge1xuICAgICAgYWJvcnRSZXF1ZXN0Ll9yZXNvbHZlKCk7XG4gICAgICBXcml0YWJsZVN0cmVhbVJlamVjdENsb3NlQW5kQ2xvc2VkUHJvbWlzZUlmTmVlZGVkKHN0cmVhbSk7XG4gICAgfSxcbiAgICAocmVhc29uOiBhbnkpID0+IHtcbiAgICAgIGFib3J0UmVxdWVzdC5fcmVqZWN0KHJlYXNvbik7XG4gICAgICBXcml0YWJsZVN0cmVhbVJlamVjdENsb3NlQW5kQ2xvc2VkUHJvbWlzZUlmTmVlZGVkKHN0cmVhbSk7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRmluaXNoSW5GbGlnaHRXcml0ZShzdHJlYW06IFdyaXRhYmxlU3RyZWFtKSB7XG4gIGFzc2VydChzdHJlYW0uX2luRmxpZ2h0V3JpdGVSZXF1ZXN0ICE9PSB1bmRlZmluZWQpO1xuICBzdHJlYW0uX2luRmxpZ2h0V3JpdGVSZXF1ZXN0IS5fcmVzb2x2ZSh1bmRlZmluZWQpO1xuICBzdHJlYW0uX2luRmxpZ2h0V3JpdGVSZXF1ZXN0ID0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0cmVhbUZpbmlzaEluRmxpZ2h0V3JpdGVXaXRoRXJyb3Ioc3RyZWFtOiBXcml0YWJsZVN0cmVhbSwgZXJyb3I6IGFueSkge1xuICBhc3NlcnQoc3RyZWFtLl9pbkZsaWdodFdyaXRlUmVxdWVzdCAhPT0gdW5kZWZpbmVkKTtcbiAgc3RyZWFtLl9pbkZsaWdodFdyaXRlUmVxdWVzdCEuX3JlamVjdChlcnJvcik7XG4gIHN0cmVhbS5faW5GbGlnaHRXcml0ZVJlcXVlc3QgPSB1bmRlZmluZWQ7XG5cbiAgYXNzZXJ0KHN0cmVhbS5fc3RhdGUgPT09ICd3cml0YWJsZScgfHwgc3RyZWFtLl9zdGF0ZSA9PT0gJ2Vycm9yaW5nJyk7XG5cbiAgV3JpdGFibGVTdHJlYW1EZWFsV2l0aFJlamVjdGlvbihzdHJlYW0sIGVycm9yKTtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1GaW5pc2hJbkZsaWdodENsb3NlKHN0cmVhbTogV3JpdGFibGVTdHJlYW0pIHtcbiAgYXNzZXJ0KHN0cmVhbS5faW5GbGlnaHRDbG9zZVJlcXVlc3QgIT09IHVuZGVmaW5lZCk7XG4gIHN0cmVhbS5faW5GbGlnaHRDbG9zZVJlcXVlc3QhLl9yZXNvbHZlKHVuZGVmaW5lZCk7XG4gIHN0cmVhbS5faW5GbGlnaHRDbG9zZVJlcXVlc3QgPSB1bmRlZmluZWQ7XG5cbiAgY29uc3Qgc3RhdGUgPSBzdHJlYW0uX3N0YXRlO1xuXG4gIGFzc2VydChzdGF0ZSA9PT0gJ3dyaXRhYmxlJyB8fCBzdGF0ZSA9PT0gJ2Vycm9yaW5nJyk7XG5cbiAgaWYgKHN0YXRlID09PSAnZXJyb3JpbmcnKSB7XG4gICAgLy8gVGhlIGVycm9yIHdhcyB0b28gbGF0ZSB0byBkbyBhbnl0aGluZywgc28gaXQgaXMgaWdub3JlZC5cbiAgICBzdHJlYW0uX3N0b3JlZEVycm9yID0gdW5kZWZpbmVkO1xuICAgIGlmIChzdHJlYW0uX3BlbmRpbmdBYm9ydFJlcXVlc3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgc3RyZWFtLl9wZW5kaW5nQWJvcnRSZXF1ZXN0Ll9yZXNvbHZlKCk7XG4gICAgICBzdHJlYW0uX3BlbmRpbmdBYm9ydFJlcXVlc3QgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG5cbiAgc3RyZWFtLl9zdGF0ZSA9ICdjbG9zZWQnO1xuXG4gIGNvbnN0IHdyaXRlciA9IHN0cmVhbS5fd3JpdGVyO1xuICBpZiAod3JpdGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICBkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZVJlc29sdmUod3JpdGVyKTtcbiAgfVxuXG4gIGFzc2VydChzdHJlYW0uX3BlbmRpbmdBYm9ydFJlcXVlc3QgPT09IHVuZGVmaW5lZCk7XG4gIGFzc2VydChzdHJlYW0uX3N0b3JlZEVycm9yID09PSB1bmRlZmluZWQpO1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0cmVhbUZpbmlzaEluRmxpZ2h0Q2xvc2VXaXRoRXJyb3Ioc3RyZWFtOiBXcml0YWJsZVN0cmVhbSwgZXJyb3I6IGFueSkge1xuICBhc3NlcnQoc3RyZWFtLl9pbkZsaWdodENsb3NlUmVxdWVzdCAhPT0gdW5kZWZpbmVkKTtcbiAgc3RyZWFtLl9pbkZsaWdodENsb3NlUmVxdWVzdCEuX3JlamVjdChlcnJvcik7XG4gIHN0cmVhbS5faW5GbGlnaHRDbG9zZVJlcXVlc3QgPSB1bmRlZmluZWQ7XG5cbiAgYXNzZXJ0KHN0cmVhbS5fc3RhdGUgPT09ICd3cml0YWJsZScgfHwgc3RyZWFtLl9zdGF0ZSA9PT0gJ2Vycm9yaW5nJyk7XG5cbiAgLy8gTmV2ZXIgZXhlY3V0ZSBzaW5rIGFib3J0KCkgYWZ0ZXIgc2luayBjbG9zZSgpLlxuICBpZiAoc3RyZWFtLl9wZW5kaW5nQWJvcnRSZXF1ZXN0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBzdHJlYW0uX3BlbmRpbmdBYm9ydFJlcXVlc3QuX3JlamVjdChlcnJvcik7XG4gICAgc3RyZWFtLl9wZW5kaW5nQWJvcnRSZXF1ZXN0ID0gdW5kZWZpbmVkO1xuICB9XG4gIFdyaXRhYmxlU3RyZWFtRGVhbFdpdGhSZWplY3Rpb24oc3RyZWFtLCBlcnJvcik7XG59XG5cbi8vIFRPRE8ocmljZWEpOiBGaXggYWxwaGFiZXRpY2FsIG9yZGVyLlxuZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1DbG9zZVF1ZXVlZE9ySW5GbGlnaHQoc3RyZWFtOiBXcml0YWJsZVN0cmVhbSk6IGJvb2xlYW4ge1xuICBpZiAoc3RyZWFtLl9jbG9zZVJlcXVlc3QgPT09IHVuZGVmaW5lZCAmJiBzdHJlYW0uX2luRmxpZ2h0Q2xvc2VSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1IYXNPcGVyYXRpb25NYXJrZWRJbkZsaWdodChzdHJlYW06IFdyaXRhYmxlU3RyZWFtKTogYm9vbGVhbiB7XG4gIGlmIChzdHJlYW0uX2luRmxpZ2h0V3JpdGVSZXF1ZXN0ID09PSB1bmRlZmluZWQgJiYgc3RyZWFtLl9pbkZsaWdodENsb3NlUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtTWFya0Nsb3NlUmVxdWVzdEluRmxpZ2h0KHN0cmVhbTogV3JpdGFibGVTdHJlYW0pIHtcbiAgYXNzZXJ0KHN0cmVhbS5faW5GbGlnaHRDbG9zZVJlcXVlc3QgPT09IHVuZGVmaW5lZCk7XG4gIGFzc2VydChzdHJlYW0uX2Nsb3NlUmVxdWVzdCAhPT0gdW5kZWZpbmVkKTtcbiAgc3RyZWFtLl9pbkZsaWdodENsb3NlUmVxdWVzdCA9IHN0cmVhbS5fY2xvc2VSZXF1ZXN0O1xuICBzdHJlYW0uX2Nsb3NlUmVxdWVzdCA9IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1NYXJrRmlyc3RXcml0ZVJlcXVlc3RJbkZsaWdodChzdHJlYW06IFdyaXRhYmxlU3RyZWFtKSB7XG4gIGFzc2VydChzdHJlYW0uX2luRmxpZ2h0V3JpdGVSZXF1ZXN0ID09PSB1bmRlZmluZWQpO1xuICBhc3NlcnQoc3RyZWFtLl93cml0ZVJlcXVlc3RzLmxlbmd0aCAhPT0gMCk7XG4gIHN0cmVhbS5faW5GbGlnaHRXcml0ZVJlcXVlc3QgPSBzdHJlYW0uX3dyaXRlUmVxdWVzdHMuc2hpZnQoKTtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1SZWplY3RDbG9zZUFuZENsb3NlZFByb21pc2VJZk5lZWRlZChzdHJlYW06IFdyaXRhYmxlU3RyZWFtKSB7XG4gIGFzc2VydChzdHJlYW0uX3N0YXRlID09PSAnZXJyb3JlZCcpO1xuICBpZiAoc3RyZWFtLl9jbG9zZVJlcXVlc3QgIT09IHVuZGVmaW5lZCkge1xuICAgIGFzc2VydChzdHJlYW0uX2luRmxpZ2h0Q2xvc2VSZXF1ZXN0ID09PSB1bmRlZmluZWQpO1xuXG4gICAgc3RyZWFtLl9jbG9zZVJlcXVlc3QuX3JlamVjdChzdHJlYW0uX3N0b3JlZEVycm9yKTtcbiAgICBzdHJlYW0uX2Nsb3NlUmVxdWVzdCA9IHVuZGVmaW5lZDtcbiAgfVxuICBjb25zdCB3cml0ZXIgPSBzdHJlYW0uX3dyaXRlcjtcbiAgaWYgKHdyaXRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VSZWplY3Qod3JpdGVyLCBzdHJlYW0uX3N0b3JlZEVycm9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0cmVhbVVwZGF0ZUJhY2twcmVzc3VyZShzdHJlYW06IFdyaXRhYmxlU3RyZWFtLCBiYWNrcHJlc3N1cmU6IGJvb2xlYW4pIHtcbiAgYXNzZXJ0KHN0cmVhbS5fc3RhdGUgPT09ICd3cml0YWJsZScpO1xuICBhc3NlcnQoIVdyaXRhYmxlU3RyZWFtQ2xvc2VRdWV1ZWRPckluRmxpZ2h0KHN0cmVhbSkpO1xuXG4gIGNvbnN0IHdyaXRlciA9IHN0cmVhbS5fd3JpdGVyO1xuICBpZiAod3JpdGVyICE9PSB1bmRlZmluZWQgJiYgYmFja3ByZXNzdXJlICE9PSBzdHJlYW0uX2JhY2twcmVzc3VyZSkge1xuICAgIGlmIChiYWNrcHJlc3N1cmUpIHtcbiAgICAgIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VSZXNldCh3cml0ZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NlcnQoIWJhY2twcmVzc3VyZSk7XG5cbiAgICAgIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VSZXNvbHZlKHdyaXRlcik7XG4gICAgfVxuICB9XG5cbiAgc3RyZWFtLl9iYWNrcHJlc3N1cmUgPSBiYWNrcHJlc3N1cmU7XG59XG5cbi8qKlxuICogQSBkZWZhdWx0IHdyaXRlciB2ZW5kZWQgYnkgYSB7QGxpbmsgV3JpdGFibGVTdHJlYW19LlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNsYXNzIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcjxXID0gYW55PiB7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX293bmVyV3JpdGFibGVTdHJlYW06IFdyaXRhYmxlU3RyZWFtPFc+O1xuICAvKiogQGludGVybmFsICovXG4gIF9jbG9zZWRQcm9taXNlITogUHJvbWlzZTx1bmRlZmluZWQ+O1xuICAvKiogQGludGVybmFsICovXG4gIF9jbG9zZWRQcm9taXNlX3Jlc29sdmU/OiAodmFsdWU/OiB1bmRlZmluZWQpID0+IHZvaWQ7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2Nsb3NlZFByb21pc2VfcmVqZWN0PzogKHJlYXNvbjogYW55KSA9PiB2b2lkO1xuICAvKiogQGludGVybmFsICovXG4gIF9jbG9zZWRQcm9taXNlU3RhdGUhOiAncGVuZGluZycgfCAncmVzb2x2ZWQnIHwgJ3JlamVjdGVkJztcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfcmVhZHlQcm9taXNlITogUHJvbWlzZTx1bmRlZmluZWQ+O1xuICAvKiogQGludGVybmFsICovXG4gIF9yZWFkeVByb21pc2VfcmVzb2x2ZT86ICh2YWx1ZT86IHVuZGVmaW5lZCkgPT4gdm9pZDtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfcmVhZHlQcm9taXNlX3JlamVjdD86IChyZWFzb246IGFueSkgPT4gdm9pZDtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfcmVhZHlQcm9taXNlU3RhdGUhOiAncGVuZGluZycgfCAnZnVsZmlsbGVkJyB8ICdyZWplY3RlZCc7XG5cbiAgY29uc3RydWN0b3Ioc3RyZWFtOiBXcml0YWJsZVN0cmVhbTxXPikge1xuICAgIGFzc2VydFJlcXVpcmVkQXJndW1lbnQoc3RyZWFtLCAxLCAnV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyJyk7XG4gICAgYXNzZXJ0V3JpdGFibGVTdHJlYW0oc3RyZWFtLCAnRmlyc3QgcGFyYW1ldGVyJyk7XG5cbiAgICBpZiAoSXNXcml0YWJsZVN0cmVhbUxvY2tlZChzdHJlYW0pKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGlzIHN0cmVhbSBoYXMgYWxyZWFkeSBiZWVuIGxvY2tlZCBmb3IgZXhjbHVzaXZlIHdyaXRpbmcgYnkgYW5vdGhlciB3cml0ZXInKTtcbiAgICB9XG5cbiAgICB0aGlzLl9vd25lcldyaXRhYmxlU3RyZWFtID0gc3RyZWFtO1xuICAgIHN0cmVhbS5fd3JpdGVyID0gdGhpcztcblxuICAgIGNvbnN0IHN0YXRlID0gc3RyZWFtLl9zdGF0ZTtcblxuICAgIGlmIChzdGF0ZSA9PT0gJ3dyaXRhYmxlJykge1xuICAgICAgaWYgKCFXcml0YWJsZVN0cmVhbUNsb3NlUXVldWVkT3JJbkZsaWdodChzdHJlYW0pICYmIHN0cmVhbS5fYmFja3ByZXNzdXJlKSB7XG4gICAgICAgIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VJbml0aWFsaXplKHRoaXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZUluaXRpYWxpemVBc1Jlc29sdmVkKHRoaXMpO1xuICAgICAgfVxuXG4gICAgICBkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemUodGhpcyk7XG4gICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gJ2Vycm9yaW5nJykge1xuICAgICAgZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZUluaXRpYWxpemVBc1JlamVjdGVkKHRoaXMsIHN0cmVhbS5fc3RvcmVkRXJyb3IpO1xuICAgICAgZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VJbml0aWFsaXplKHRoaXMpO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICAgICBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlSW5pdGlhbGl6ZUFzUmVzb2x2ZWQodGhpcyk7XG4gICAgICBkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemVBc1Jlc29sdmVkKHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NlcnQoc3RhdGUgPT09ICdlcnJvcmVkJyk7XG5cbiAgICAgIGNvbnN0IHN0b3JlZEVycm9yID0gc3RyZWFtLl9zdG9yZWRFcnJvcjtcbiAgICAgIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VJbml0aWFsaXplQXNSZWplY3RlZCh0aGlzLCBzdG9yZWRFcnJvcik7XG4gICAgICBkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemVBc1JlamVjdGVkKHRoaXMsIHN0b3JlZEVycm9yKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHByb21pc2UgdGhhdCB3aWxsIGJlIGZ1bGZpbGxlZCB3aGVuIHRoZSBzdHJlYW0gYmVjb21lcyBjbG9zZWQsIG9yIHJlamVjdGVkIGlmIHRoZSBzdHJlYW0gZXZlciBlcnJvcnMgb3JcbiAgICogdGhlIHdyaXRlcuKAmXMgbG9jayBpcyByZWxlYXNlZCBiZWZvcmUgdGhlIHN0cmVhbSBmaW5pc2hlcyBjbG9zaW5nLlxuICAgKi9cbiAgZ2V0IGNsb3NlZCgpOiBQcm9taXNlPHVuZGVmaW5lZD4ge1xuICAgIGlmICghSXNXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIodGhpcykpIHtcbiAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGRlZmF1bHRXcml0ZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdjbG9zZWQnKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX2Nsb3NlZFByb21pc2U7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZGVzaXJlZCBzaXplIHRvIGZpbGwgdGhlIHN0cmVhbeKAmXMgaW50ZXJuYWwgcXVldWUuIEl0IGNhbiBiZSBuZWdhdGl2ZSwgaWYgdGhlIHF1ZXVlIGlzIG92ZXItZnVsbC5cbiAgICogQSBwcm9kdWNlciBjYW4gdXNlIHRoaXMgaW5mb3JtYXRpb24gdG8gZGV0ZXJtaW5lIHRoZSByaWdodCBhbW91bnQgb2YgZGF0YSB0byB3cml0ZS5cbiAgICpcbiAgICogSXQgd2lsbCBiZSBgbnVsbGAgaWYgdGhlIHN0cmVhbSBjYW5ub3QgYmUgc3VjY2Vzc2Z1bGx5IHdyaXR0ZW4gdG8gKGR1ZSB0byBlaXRoZXIgYmVpbmcgZXJyb3JlZCwgb3IgaGF2aW5nIGFuIGFib3J0XG4gICAqIHF1ZXVlZCB1cCkuIEl0IHdpbGwgcmV0dXJuIHplcm8gaWYgdGhlIHN0cmVhbSBpcyBjbG9zZWQuIEFuZCB0aGUgZ2V0dGVyIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGludm9rZWQgd2hlblxuICAgKiB0aGUgd3JpdGVy4oCZcyBsb2NrIGlzIHJlbGVhc2VkLlxuICAgKi9cbiAgZ2V0IGRlc2lyZWRTaXplKCk6IG51bWJlciB8IG51bGwge1xuICAgIGlmICghSXNXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIodGhpcykpIHtcbiAgICAgIHRocm93IGRlZmF1bHRXcml0ZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdkZXNpcmVkU2l6ZScpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9vd25lcldyaXRhYmxlU3RyZWFtID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IGRlZmF1bHRXcml0ZXJMb2NrRXhjZXB0aW9uKCdkZXNpcmVkU2l6ZScpO1xuICAgIH1cblxuICAgIHJldHVybiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJHZXREZXNpcmVkU2l6ZSh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHdpbGwgYmUgZnVsZmlsbGVkIHdoZW4gdGhlIGRlc2lyZWQgc2l6ZSB0byBmaWxsIHRoZSBzdHJlYW3igJlzIGludGVybmFsIHF1ZXVlIHRyYW5zaXRpb25zXG4gICAqIGZyb20gbm9uLXBvc2l0aXZlIHRvIHBvc2l0aXZlLCBzaWduYWxpbmcgdGhhdCBpdCBpcyBubyBsb25nZXIgYXBwbHlpbmcgYmFja3ByZXNzdXJlLiBPbmNlIHRoZSBkZXNpcmVkIHNpemUgZGlwc1xuICAgKiBiYWNrIHRvIHplcm8gb3IgYmVsb3csIHRoZSBnZXR0ZXIgd2lsbCByZXR1cm4gYSBuZXcgcHJvbWlzZSB0aGF0IHN0YXlzIHBlbmRpbmcgdW50aWwgdGhlIG5leHQgdHJhbnNpdGlvbi5cbiAgICpcbiAgICogSWYgdGhlIHN0cmVhbSBiZWNvbWVzIGVycm9yZWQgb3IgYWJvcnRlZCwgb3IgdGhlIHdyaXRlcuKAmXMgbG9jayBpcyByZWxlYXNlZCwgdGhlIHJldHVybmVkIHByb21pc2Ugd2lsbCBiZWNvbWVcbiAgICogcmVqZWN0ZWQuXG4gICAqL1xuICBnZXQgcmVhZHkoKTogUHJvbWlzZTx1bmRlZmluZWQ+IHtcbiAgICBpZiAoIUlzV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyKHRoaXMpKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChkZWZhdWx0V3JpdGVyQnJhbmRDaGVja0V4Y2VwdGlvbigncmVhZHknKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3JlYWR5UHJvbWlzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJZiB0aGUgcmVhZGVyIGlzIGFjdGl2ZSwgYmVoYXZlcyB0aGUgc2FtZSBhcyB7QGxpbmsgV3JpdGFibGVTdHJlYW0uYWJvcnQgfCBzdHJlYW0uYWJvcnQocmVhc29uKX0uXG4gICAqL1xuICBhYm9ydChyZWFzb246IGFueSA9IHVuZGVmaW5lZCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICghSXNXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIodGhpcykpIHtcbiAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGRlZmF1bHRXcml0ZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdhYm9ydCcpKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fb3duZXJXcml0YWJsZVN0cmVhbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChkZWZhdWx0V3JpdGVyTG9ja0V4Y2VwdGlvbignYWJvcnQnKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckFib3J0KHRoaXMsIHJlYXNvbik7XG4gIH1cblxuICAvKipcbiAgICogSWYgdGhlIHJlYWRlciBpcyBhY3RpdmUsIGJlaGF2ZXMgdGhlIHNhbWUgYXMge0BsaW5rIFdyaXRhYmxlU3RyZWFtLmNsb3NlIHwgc3RyZWFtLmNsb3NlKCl9LlxuICAgKi9cbiAgY2xvc2UoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKCFJc1dyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcih0aGlzKSkge1xuICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoZGVmYXVsdFdyaXRlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ2Nsb3NlJykpO1xuICAgIH1cblxuICAgIGNvbnN0IHN0cmVhbSA9IHRoaXMuX293bmVyV3JpdGFibGVTdHJlYW07XG5cbiAgICBpZiAoc3RyZWFtID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGRlZmF1bHRXcml0ZXJMb2NrRXhjZXB0aW9uKCdjbG9zZScpKTtcbiAgICB9XG5cbiAgICBpZiAoV3JpdGFibGVTdHJlYW1DbG9zZVF1ZXVlZE9ySW5GbGlnaHQoc3RyZWFtKSkge1xuICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgobmV3IFR5cGVFcnJvcignQ2Fubm90IGNsb3NlIGFuIGFscmVhZHktY2xvc2luZyBzdHJlYW0nKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckNsb3NlKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbGVhc2VzIHRoZSB3cml0ZXLigJlzIGxvY2sgb24gdGhlIGNvcnJlc3BvbmRpbmcgc3RyZWFtLiBBZnRlciB0aGUgbG9jayBpcyByZWxlYXNlZCwgdGhlIHdyaXRlciBpcyBubyBsb25nZXIgYWN0aXZlLlxuICAgKiBJZiB0aGUgYXNzb2NpYXRlZCBzdHJlYW0gaXMgZXJyb3JlZCB3aGVuIHRoZSBsb2NrIGlzIHJlbGVhc2VkLCB0aGUgd3JpdGVyIHdpbGwgYXBwZWFyIGVycm9yZWQgaW4gdGhlIHNhbWUgd2F5IGZyb21cbiAgICogbm93IG9uOyBvdGhlcndpc2UsIHRoZSB3cml0ZXIgd2lsbCBhcHBlYXIgY2xvc2VkLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgdGhlIGxvY2sgY2FuIHN0aWxsIGJlIHJlbGVhc2VkIGV2ZW4gaWYgc29tZSBvbmdvaW5nIHdyaXRlcyBoYXZlIG5vdCB5ZXQgZmluaXNoZWQgKGkuZS4gZXZlbiBpZiB0aGVcbiAgICogcHJvbWlzZXMgcmV0dXJuZWQgZnJvbSBwcmV2aW91cyBjYWxscyB0byB7QGxpbmsgV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyLndyaXRlIHwgd3JpdGUoKX0gaGF2ZSBub3QgeWV0IHNldHRsZWQpLlxuICAgKiBJdOKAmXMgbm90IG5lY2Vzc2FyeSB0byBob2xkIHRoZSBsb2NrIG9uIHRoZSB3cml0ZXIgZm9yIHRoZSBkdXJhdGlvbiBvZiB0aGUgd3JpdGU7IHRoZSBsb2NrIGluc3RlYWQgc2ltcGx5IHByZXZlbnRzXG4gICAqIG90aGVyIHByb2R1Y2VycyBmcm9tIHdyaXRpbmcgaW4gYW4gaW50ZXJsZWF2ZWQgbWFubmVyLlxuICAgKi9cbiAgcmVsZWFzZUxvY2soKTogdm9pZCB7XG4gICAgaWYgKCFJc1dyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcih0aGlzKSkge1xuICAgICAgdGhyb3cgZGVmYXVsdFdyaXRlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ3JlbGVhc2VMb2NrJyk7XG4gICAgfVxuXG4gICAgY29uc3Qgc3RyZWFtID0gdGhpcy5fb3duZXJXcml0YWJsZVN0cmVhbTtcblxuICAgIGlmIChzdHJlYW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGFzc2VydChzdHJlYW0uX3dyaXRlciAhPT0gdW5kZWZpbmVkKTtcblxuICAgIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlclJlbGVhc2UodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogV3JpdGVzIHRoZSBnaXZlbiBjaHVuayB0byB0aGUgd3JpdGFibGUgc3RyZWFtLCBieSB3YWl0aW5nIHVudGlsIGFueSBwcmV2aW91cyB3cml0ZXMgaGF2ZSBmaW5pc2hlZCBzdWNjZXNzZnVsbHksXG4gICAqIGFuZCB0aGVuIHNlbmRpbmcgdGhlIGNodW5rIHRvIHRoZSB1bmRlcmx5aW5nIHNpbmsncyB7QGxpbmsgVW5kZXJseWluZ1Npbmsud3JpdGUgfCB3cml0ZSgpfSBtZXRob2QuIEl0IHdpbGwgcmV0dXJuXG4gICAqIGEgcHJvbWlzZSB0aGF0IGZ1bGZpbGxzIHdpdGggdW5kZWZpbmVkIHVwb24gYSBzdWNjZXNzZnVsIHdyaXRlLCBvciByZWplY3RzIGlmIHRoZSB3cml0ZSBmYWlscyBvciBzdHJlYW0gYmVjb21lc1xuICAgKiBlcnJvcmVkIGJlZm9yZSB0aGUgd3JpdGluZyBwcm9jZXNzIGlzIGluaXRpYXRlZC5cbiAgICpcbiAgICogTm90ZSB0aGF0IHdoYXQgXCJzdWNjZXNzXCIgbWVhbnMgaXMgdXAgdG8gdGhlIHVuZGVybHlpbmcgc2luazsgaXQgbWlnaHQgaW5kaWNhdGUgc2ltcGx5IHRoYXQgdGhlIGNodW5rIGhhcyBiZWVuXG4gICAqIGFjY2VwdGVkLCBhbmQgbm90IG5lY2Vzc2FyaWx5IHRoYXQgaXQgaXMgc2FmZWx5IHNhdmVkIHRvIGl0cyB1bHRpbWF0ZSBkZXN0aW5hdGlvbi5cbiAgICovXG4gIHdyaXRlKGNodW5rOiBXKTogUHJvbWlzZTx2b2lkPjtcbiAgd3JpdGUoY2h1bms6IFcgPSB1bmRlZmluZWQhKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKCFJc1dyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcih0aGlzKSkge1xuICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoZGVmYXVsdFdyaXRlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ3dyaXRlJykpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9vd25lcldyaXRhYmxlU3RyZWFtID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGRlZmF1bHRXcml0ZXJMb2NrRXhjZXB0aW9uKCd3cml0ZSB0bycpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyV3JpdGUodGhpcywgY2h1bmspO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlci5wcm90b3R5cGUsIHtcbiAgYWJvcnQ6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICBjbG9zZTogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gIHJlbGVhc2VMb2NrOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgd3JpdGU6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICBjbG9zZWQ6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICBkZXNpcmVkU2l6ZTogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gIHJlYWR5OiB7IGVudW1lcmFibGU6IHRydWUgfVxufSk7XG5pZiAodHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlci5wcm90b3R5cGUsIFN5bWJvbC50b1N0cmluZ1RhZywge1xuICAgIHZhbHVlOiAnV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyJyxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbi8vIEFic3RyYWN0IG9wZXJhdGlvbnMgZm9yIHRoZSBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIuXG5cbmZ1bmN0aW9uIElzV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyPFcgPSBhbnk+KHg6IGFueSk6IHggaXMgV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyPFc+IHtcbiAgaWYgKCF0eXBlSXNPYmplY3QoeCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnX293bmVyV3JpdGFibGVTdHJlYW0nKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB4IGluc3RhbmNlb2YgV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyO1xufVxuXG4vLyBBIGNsaWVudCBvZiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIgbWF5IHVzZSB0aGVzZSBmdW5jdGlvbnMgZGlyZWN0bHkgdG8gYnlwYXNzIHN0YXRlIGNoZWNrLlxuXG5mdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJBYm9ydCh3cml0ZXI6IFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlciwgcmVhc29uOiBhbnkpIHtcbiAgY29uc3Qgc3RyZWFtID0gd3JpdGVyLl9vd25lcldyaXRhYmxlU3RyZWFtO1xuXG4gIGFzc2VydChzdHJlYW0gIT09IHVuZGVmaW5lZCk7XG5cbiAgcmV0dXJuIFdyaXRhYmxlU3RyZWFtQWJvcnQoc3RyZWFtLCByZWFzb24pO1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJDbG9zZSh3cml0ZXI6IFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcik6IFByb21pc2U8dW5kZWZpbmVkPiB7XG4gIGNvbnN0IHN0cmVhbSA9IHdyaXRlci5fb3duZXJXcml0YWJsZVN0cmVhbTtcblxuICBhc3NlcnQoc3RyZWFtICE9PSB1bmRlZmluZWQpO1xuXG4gIHJldHVybiBXcml0YWJsZVN0cmVhbUNsb3NlKHN0cmVhbSk7XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckNsb3NlV2l0aEVycm9yUHJvcGFnYXRpb24od3JpdGVyOiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIpOiBQcm9taXNlPHVuZGVmaW5lZD4ge1xuICBjb25zdCBzdHJlYW0gPSB3cml0ZXIuX293bmVyV3JpdGFibGVTdHJlYW07XG5cbiAgYXNzZXJ0KHN0cmVhbSAhPT0gdW5kZWZpbmVkKTtcblxuICBjb25zdCBzdGF0ZSA9IHN0cmVhbS5fc3RhdGU7XG4gIGlmIChXcml0YWJsZVN0cmVhbUNsb3NlUXVldWVkT3JJbkZsaWdodChzdHJlYW0pIHx8IHN0YXRlID09PSAnY2xvc2VkJykge1xuICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG4gIH1cblxuICBpZiAoc3RhdGUgPT09ICdlcnJvcmVkJykge1xuICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKHN0cmVhbS5fc3RvcmVkRXJyb3IpO1xuICB9XG5cbiAgYXNzZXJ0KHN0YXRlID09PSAnd3JpdGFibGUnIHx8IHN0YXRlID09PSAnZXJyb3JpbmcnKTtcblxuICByZXR1cm4gV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyQ2xvc2Uod3JpdGVyKTtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyRW5zdXJlQ2xvc2VkUHJvbWlzZVJlamVjdGVkKHdyaXRlcjogV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyLCBlcnJvcjogYW55KSB7XG4gIGlmICh3cml0ZXIuX2Nsb3NlZFByb21pc2VTdGF0ZSA9PT0gJ3BlbmRpbmcnKSB7XG4gICAgZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VSZWplY3Qod3JpdGVyLCBlcnJvcik7XG4gIH0gZWxzZSB7XG4gICAgZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VSZXNldFRvUmVqZWN0ZWQod3JpdGVyLCBlcnJvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyRW5zdXJlUmVhZHlQcm9taXNlUmVqZWN0ZWQod3JpdGVyOiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIsIGVycm9yOiBhbnkpIHtcbiAgaWYgKHdyaXRlci5fcmVhZHlQcm9taXNlU3RhdGUgPT09ICdwZW5kaW5nJykge1xuICAgIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VSZWplY3Qod3JpdGVyLCBlcnJvcik7XG4gIH0gZWxzZSB7XG4gICAgZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZVJlc2V0VG9SZWplY3RlZCh3cml0ZXIsIGVycm9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJHZXREZXNpcmVkU2l6ZSh3cml0ZXI6IFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcik6IG51bWJlciB8IG51bGwge1xuICBjb25zdCBzdHJlYW0gPSB3cml0ZXIuX293bmVyV3JpdGFibGVTdHJlYW07XG4gIGNvbnN0IHN0YXRlID0gc3RyZWFtLl9zdGF0ZTtcblxuICBpZiAoc3RhdGUgPT09ICdlcnJvcmVkJyB8fCBzdGF0ZSA9PT0gJ2Vycm9yaW5nJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHN0YXRlID09PSAnY2xvc2VkJykge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgcmV0dXJuIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJHZXREZXNpcmVkU2l6ZShzdHJlYW0uX3dyaXRhYmxlU3RyZWFtQ29udHJvbGxlcik7XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlclJlbGVhc2Uod3JpdGVyOiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIpIHtcbiAgY29uc3Qgc3RyZWFtID0gd3JpdGVyLl9vd25lcldyaXRhYmxlU3RyZWFtO1xuICBhc3NlcnQoc3RyZWFtICE9PSB1bmRlZmluZWQpO1xuICBhc3NlcnQoc3RyZWFtLl93cml0ZXIgPT09IHdyaXRlcik7XG5cbiAgY29uc3QgcmVsZWFzZWRFcnJvciA9IG5ldyBUeXBlRXJyb3IoXG4gICAgYFdyaXRlciB3YXMgcmVsZWFzZWQgYW5kIGNhbiBubyBsb25nZXIgYmUgdXNlZCB0byBtb25pdG9yIHRoZSBzdHJlYW0ncyBjbG9zZWRuZXNzYCk7XG5cbiAgV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyRW5zdXJlUmVhZHlQcm9taXNlUmVqZWN0ZWQod3JpdGVyLCByZWxlYXNlZEVycm9yKTtcblxuICAvLyBUaGUgc3RhdGUgdHJhbnNpdGlvbnMgdG8gXCJlcnJvcmVkXCIgYmVmb3JlIHRoZSBzaW5rIGFib3J0KCkgbWV0aG9kIHJ1bnMsIGJ1dCB0aGUgd3JpdGVyLmNsb3NlZCBwcm9taXNlIGlzIG5vdFxuICAvLyByZWplY3RlZCB1bnRpbCBhZnRlcndhcmRzLiBUaGlzIG1lYW5zIHRoYXQgc2ltcGx5IHRlc3Rpbmcgc3RhdGUgd2lsbCBub3Qgd29yay5cbiAgV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyRW5zdXJlQ2xvc2VkUHJvbWlzZVJlamVjdGVkKHdyaXRlciwgcmVsZWFzZWRFcnJvcik7XG5cbiAgc3RyZWFtLl93cml0ZXIgPSB1bmRlZmluZWQ7XG4gIHdyaXRlci5fb3duZXJXcml0YWJsZVN0cmVhbSA9IHVuZGVmaW5lZCE7XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcldyaXRlPFc+KHdyaXRlcjogV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyPFc+LCBjaHVuazogVyk6IFByb21pc2U8dW5kZWZpbmVkPiB7XG4gIGNvbnN0IHN0cmVhbSA9IHdyaXRlci5fb3duZXJXcml0YWJsZVN0cmVhbTtcblxuICBhc3NlcnQoc3RyZWFtICE9PSB1bmRlZmluZWQpO1xuXG4gIGNvbnN0IGNvbnRyb2xsZXIgPSBzdHJlYW0uX3dyaXRhYmxlU3RyZWFtQ29udHJvbGxlcjtcblxuICBjb25zdCBjaHVua1NpemUgPSBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyR2V0Q2h1bmtTaXplKGNvbnRyb2xsZXIsIGNodW5rKTtcblxuICBpZiAoc3RyZWFtICE9PSB3cml0ZXIuX293bmVyV3JpdGFibGVTdHJlYW0pIHtcbiAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChkZWZhdWx0V3JpdGVyTG9ja0V4Y2VwdGlvbignd3JpdGUgdG8nKSk7XG4gIH1cblxuICBjb25zdCBzdGF0ZSA9IHN0cmVhbS5fc3RhdGU7XG4gIGlmIChzdGF0ZSA9PT0gJ2Vycm9yZWQnKSB7XG4gICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoc3RyZWFtLl9zdG9yZWRFcnJvcik7XG4gIH1cbiAgaWYgKFdyaXRhYmxlU3RyZWFtQ2xvc2VRdWV1ZWRPckluRmxpZ2h0KHN0cmVhbSkgfHwgc3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgobmV3IFR5cGVFcnJvcignVGhlIHN0cmVhbSBpcyBjbG9zaW5nIG9yIGNsb3NlZCBhbmQgY2Fubm90IGJlIHdyaXR0ZW4gdG8nKSk7XG4gIH1cbiAgaWYgKHN0YXRlID09PSAnZXJyb3JpbmcnKSB7XG4gICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoc3RyZWFtLl9zdG9yZWRFcnJvcik7XG4gIH1cblxuICBhc3NlcnQoc3RhdGUgPT09ICd3cml0YWJsZScpO1xuXG4gIGNvbnN0IHByb21pc2UgPSBXcml0YWJsZVN0cmVhbUFkZFdyaXRlUmVxdWVzdChzdHJlYW0pO1xuXG4gIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJXcml0ZShjb250cm9sbGVyLCBjaHVuaywgY2h1bmtTaXplKTtcblxuICByZXR1cm4gcHJvbWlzZTtcbn1cblxuY29uc3QgY2xvc2VTZW50aW5lbDogdW5pcXVlIHN5bWJvbCA9IHt9IGFzIGFueTtcblxudHlwZSBRdWV1ZVJlY29yZDxXPiA9IFcgfCB0eXBlb2YgY2xvc2VTZW50aW5lbDtcblxuLyoqXG4gKiBBbGxvd3MgY29udHJvbCBvZiBhIHtAbGluayBXcml0YWJsZVN0cmVhbSB8IHdyaXRhYmxlIHN0cmVhbX0ncyBzdGF0ZSBhbmQgaW50ZXJuYWwgcXVldWUuXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxXID0gYW55PiB7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2NvbnRyb2xsZWRXcml0YWJsZVN0cmVhbSE6IFdyaXRhYmxlU3RyZWFtPFc+O1xuICAvKiogQGludGVybmFsICovXG4gIF9xdWV1ZSE6IFNpbXBsZVF1ZXVlPFF1ZXVlUGFpcjxRdWV1ZVJlY29yZDxXPj4+O1xuICAvKiogQGludGVybmFsICovXG4gIF9xdWV1ZVRvdGFsU2l6ZSE6IG51bWJlcjtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYWJvcnRSZWFzb246IGFueTtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYWJvcnRDb250cm9sbGVyOiBBYm9ydENvbnRyb2xsZXIgfCB1bmRlZmluZWQ7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3N0YXJ0ZWQhOiBib29sZWFuO1xuICAvKiogQGludGVybmFsICovXG4gIF9zdHJhdGVneVNpemVBbGdvcml0aG0hOiBRdWV1aW5nU3RyYXRlZ3lTaXplQ2FsbGJhY2s8Vz47XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3N0cmF0ZWd5SFdNITogbnVtYmVyO1xuICAvKiogQGludGVybmFsICovXG4gIF93cml0ZUFsZ29yaXRobSE6IChjaHVuazogVykgPT4gUHJvbWlzZTx2b2lkPjtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfY2xvc2VBbGdvcml0aG0hOiAoKSA9PiBQcm9taXNlPHZvaWQ+O1xuICAvKiogQGludGVybmFsICovXG4gIF9hYm9ydEFsZ29yaXRobSE6IChyZWFzb246IGFueSkgPT4gUHJvbWlzZTx2b2lkPjtcblxuICBwcml2YXRlIGNvbnN0cnVjdG9yKCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0lsbGVnYWwgY29uc3RydWN0b3InKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgcmVhc29uIHdoaWNoIHdhcyBwYXNzZWQgdG8gYFdyaXRhYmxlU3RyZWFtLmFib3J0KHJlYXNvbilgIHdoZW4gdGhlIHN0cmVhbSB3YXMgYWJvcnRlZC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWRcbiAgICogIFRoaXMgcHJvcGVydHkgaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSBzcGVjaWZpY2F0aW9uLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3doYXR3Zy9zdHJlYW1zL3B1bGwvMTE3Ny5cbiAgICogIFVzZSB7QGxpbmsgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlci5zaWduYWx9J3MgYHJlYXNvbmAgaW5zdGVhZC5cbiAgICovXG4gIGdldCBhYm9ydFJlYXNvbigpOiBhbnkge1xuICAgIGlmICghSXNXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyKHRoaXMpKSB7XG4gICAgICB0aHJvdyBkZWZhdWx0Q29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ2Fib3J0UmVhc29uJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9hYm9ydFJlYXNvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbiBgQWJvcnRTaWduYWxgIHRoYXQgY2FuIGJlIHVzZWQgdG8gYWJvcnQgdGhlIHBlbmRpbmcgd3JpdGUgb3IgY2xvc2Ugb3BlcmF0aW9uIHdoZW4gdGhlIHN0cmVhbSBpcyBhYm9ydGVkLlxuICAgKi9cbiAgZ2V0IHNpZ25hbCgpOiBBYm9ydFNpZ25hbCB7XG4gICAgaWYgKCFJc1dyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIodGhpcykpIHtcbiAgICAgIHRocm93IGRlZmF1bHRDb250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbignc2lnbmFsJyk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9hYm9ydENvbnRyb2xsZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gT2xkZXIgYnJvd3NlcnMgb3Igb2xkZXIgTm9kZSB2ZXJzaW9ucyBtYXkgbm90IHN1cHBvcnQgYEFib3J0Q29udHJvbGxlcmAgb3IgYEFib3J0U2lnbmFsYC5cbiAgICAgIC8vIFdlIGRvbid0IHdhbnQgdG8gYnVuZGxlIGFuZCBzaGlwIGFuIGBBYm9ydENvbnRyb2xsZXJgIHBvbHlmaWxsIHRvZ2V0aGVyIHdpdGggb3VyIHBvbHlmaWxsLFxuICAgICAgLy8gc28gaW5zdGVhZCB3ZSBvbmx5IGltcGxlbWVudCBzdXBwb3J0IGZvciBgc2lnbmFsYCBpZiB3ZSBmaW5kIGEgZ2xvYmFsIGBBYm9ydENvbnRyb2xsZXJgIGNvbnN0cnVjdG9yLlxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUuc2lnbmFsIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2Fib3J0Q29udHJvbGxlci5zaWduYWw7XG4gIH1cblxuICAvKipcbiAgICogQ2xvc2VzIHRoZSBjb250cm9sbGVkIHdyaXRhYmxlIHN0cmVhbSwgbWFraW5nIGFsbCBmdXR1cmUgaW50ZXJhY3Rpb25zIHdpdGggaXQgZmFpbCB3aXRoIHRoZSBnaXZlbiBlcnJvciBgZWAuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGlzIHJhcmVseSB1c2VkLCBzaW5jZSB1c3VhbGx5IGl0IHN1ZmZpY2VzIHRvIHJldHVybiBhIHJlamVjdGVkIHByb21pc2UgZnJvbSBvbmUgb2YgdGhlIHVuZGVybHlpbmdcbiAgICogc2luaydzIG1ldGhvZHMuIEhvd2V2ZXIsIGl0IGNhbiBiZSB1c2VmdWwgZm9yIHN1ZGRlbmx5IHNodXR0aW5nIGRvd24gYSBzdHJlYW0gaW4gcmVzcG9uc2UgdG8gYW4gZXZlbnQgb3V0c2lkZSB0aGVcbiAgICogbm9ybWFsIGxpZmVjeWNsZSBvZiBpbnRlcmFjdGlvbnMgd2l0aCB0aGUgdW5kZXJseWluZyBzaW5rLlxuICAgKi9cbiAgZXJyb3IoZTogYW55ID0gdW5kZWZpbmVkKTogdm9pZCB7XG4gICAgaWYgKCFJc1dyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIodGhpcykpIHtcbiAgICAgIHRocm93IGRlZmF1bHRDb250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbignZXJyb3InKTtcbiAgICB9XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLl9jb250cm9sbGVkV3JpdGFibGVTdHJlYW0uX3N0YXRlO1xuICAgIGlmIChzdGF0ZSAhPT0gJ3dyaXRhYmxlJykge1xuICAgICAgLy8gVGhlIHN0cmVhbSBpcyBjbG9zZWQsIGVycm9yZWQgb3Igd2lsbCBiZSBzb29uLiBUaGUgc2luayBjYW4ndCBkbyBhbnl0aGluZyB1c2VmdWwgaWYgaXQgZ2V0cyBhbiBlcnJvciBoZXJlLCBzb1xuICAgICAgLy8ganVzdCB0cmVhdCBpdCBhcyBhIG5vLW9wLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcih0aGlzLCBlKTtcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgW0Fib3J0U3RlcHNdKHJlYXNvbjogYW55KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fYWJvcnRBbGdvcml0aG0ocmVhc29uKTtcbiAgICBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKHRoaXMpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIFtFcnJvclN0ZXBzXSgpIHtcbiAgICBSZXNldFF1ZXVlKHRoaXMpO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIucHJvdG90eXBlLCB7XG4gIGFib3J0UmVhc29uOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgc2lnbmFsOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgZXJyb3I6IHsgZW51bWVyYWJsZTogdHJ1ZSB9XG59KTtcbmlmICh0eXBlb2YgU3ltYm9sLnRvU3RyaW5nVGFnID09PSAnc3ltYm9sJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUsIFN5bWJvbC50b1N0cmluZ1RhZywge1xuICAgIHZhbHVlOiAnV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcicsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG4vLyBBYnN0cmFjdCBvcGVyYXRpb25zIGltcGxlbWVudGluZyBpbnRlcmZhY2UgcmVxdWlyZWQgYnkgdGhlIFdyaXRhYmxlU3RyZWFtLlxuXG5mdW5jdGlvbiBJc1dyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIoeDogYW55KTogeCBpcyBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyPGFueT4ge1xuICBpZiAoIXR5cGVJc09iamVjdCh4KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdfY29udHJvbGxlZFdyaXRhYmxlU3RyZWFtJykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4geCBpbnN0YW5jZW9mIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI7XG59XG5cbmZ1bmN0aW9uIFNldFVwV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxXPihzdHJlYW06IFdyaXRhYmxlU3RyZWFtPFc+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXI6IFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8Vz4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRBbGdvcml0aG06ICgpID0+IHZvaWQgfCBQcm9taXNlTGlrZTx2b2lkPixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3cml0ZUFsZ29yaXRobTogKGNodW5rOiBXKSA9PiBQcm9taXNlPHZvaWQ+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb3NlQWxnb3JpdGhtOiAoKSA9PiBQcm9taXNlPHZvaWQ+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFib3J0QWxnb3JpdGhtOiAocmVhc29uOiBhbnkpID0+IFByb21pc2U8dm9pZD4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGlnaFdhdGVyTWFyazogbnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpemVBbGdvcml0aG06IFF1ZXVpbmdTdHJhdGVneVNpemVDYWxsYmFjazxXPikge1xuICBhc3NlcnQoSXNXcml0YWJsZVN0cmVhbShzdHJlYW0pKTtcbiAgYXNzZXJ0KHN0cmVhbS5fd3JpdGFibGVTdHJlYW1Db250cm9sbGVyID09PSB1bmRlZmluZWQpO1xuXG4gIGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRXcml0YWJsZVN0cmVhbSA9IHN0cmVhbTtcbiAgc3RyZWFtLl93cml0YWJsZVN0cmVhbUNvbnRyb2xsZXIgPSBjb250cm9sbGVyO1xuXG4gIC8vIE5lZWQgdG8gc2V0IHRoZSBzbG90cyBzbyB0aGF0IHRoZSBhc3NlcnQgZG9lc24ndCBmaXJlLiBJbiB0aGUgc3BlYyB0aGUgc2xvdHMgYWxyZWFkeSBleGlzdCBpbXBsaWNpdGx5LlxuICBjb250cm9sbGVyLl9xdWV1ZSA9IHVuZGVmaW5lZCE7XG4gIGNvbnRyb2xsZXIuX3F1ZXVlVG90YWxTaXplID0gdW5kZWZpbmVkITtcbiAgUmVzZXRRdWV1ZShjb250cm9sbGVyKTtcblxuICBjb250cm9sbGVyLl9hYm9ydFJlYXNvbiA9IHVuZGVmaW5lZDtcbiAgY29udHJvbGxlci5fYWJvcnRDb250cm9sbGVyID0gY3JlYXRlQWJvcnRDb250cm9sbGVyKCk7XG4gIGNvbnRyb2xsZXIuX3N0YXJ0ZWQgPSBmYWxzZTtcblxuICBjb250cm9sbGVyLl9zdHJhdGVneVNpemVBbGdvcml0aG0gPSBzaXplQWxnb3JpdGhtO1xuICBjb250cm9sbGVyLl9zdHJhdGVneUhXTSA9IGhpZ2hXYXRlck1hcms7XG5cbiAgY29udHJvbGxlci5fd3JpdGVBbGdvcml0aG0gPSB3cml0ZUFsZ29yaXRobTtcbiAgY29udHJvbGxlci5fY2xvc2VBbGdvcml0aG0gPSBjbG9zZUFsZ29yaXRobTtcbiAgY29udHJvbGxlci5fYWJvcnRBbGdvcml0aG0gPSBhYm9ydEFsZ29yaXRobTtcblxuICBjb25zdCBiYWNrcHJlc3N1cmUgPSBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyR2V0QmFja3ByZXNzdXJlKGNvbnRyb2xsZXIpO1xuICBXcml0YWJsZVN0cmVhbVVwZGF0ZUJhY2twcmVzc3VyZShzdHJlYW0sIGJhY2twcmVzc3VyZSk7XG5cbiAgY29uc3Qgc3RhcnRSZXN1bHQgPSBzdGFydEFsZ29yaXRobSgpO1xuICBjb25zdCBzdGFydFByb21pc2UgPSBwcm9taXNlUmVzb2x2ZWRXaXRoKHN0YXJ0UmVzdWx0KTtcbiAgdXBvblByb21pc2UoXG4gICAgc3RhcnRQcm9taXNlLFxuICAgICgpID0+IHtcbiAgICAgIGFzc2VydChzdHJlYW0uX3N0YXRlID09PSAnd3JpdGFibGUnIHx8IHN0cmVhbS5fc3RhdGUgPT09ICdlcnJvcmluZycpO1xuICAgICAgY29udHJvbGxlci5fc3RhcnRlZCA9IHRydWU7XG4gICAgICBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQWR2YW5jZVF1ZXVlSWZOZWVkZWQoY29udHJvbGxlcik7XG4gICAgfSxcbiAgICByID0+IHtcbiAgICAgIGFzc2VydChzdHJlYW0uX3N0YXRlID09PSAnd3JpdGFibGUnIHx8IHN0cmVhbS5fc3RhdGUgPT09ICdlcnJvcmluZycpO1xuICAgICAgY29udHJvbGxlci5fc3RhcnRlZCA9IHRydWU7XG4gICAgICBXcml0YWJsZVN0cmVhbURlYWxXaXRoUmVqZWN0aW9uKHN0cmVhbSwgcik7XG4gICAgfVxuICApO1xufVxuXG5mdW5jdGlvbiBTZXRVcFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJGcm9tVW5kZXJseWluZ1Npbms8Vz4oc3RyZWFtOiBXcml0YWJsZVN0cmVhbTxXPixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmRlcmx5aW5nU2luazogVmFsaWRhdGVkVW5kZXJseWluZ1Npbms8Vz4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGlnaFdhdGVyTWFyazogbnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpemVBbGdvcml0aG06IFF1ZXVpbmdTdHJhdGVneVNpemVDYWxsYmFjazxXPikge1xuICBjb25zdCBjb250cm9sbGVyID0gT2JqZWN0LmNyZWF0ZShXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZSk7XG5cbiAgbGV0IHN0YXJ0QWxnb3JpdGhtOiAoKSA9PiB2b2lkIHwgUHJvbWlzZUxpa2U8dm9pZD4gPSAoKSA9PiB1bmRlZmluZWQ7XG4gIGxldCB3cml0ZUFsZ29yaXRobTogKGNodW5rOiBXKSA9PiBQcm9taXNlPHZvaWQ+ID0gKCkgPT4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuICBsZXQgY2xvc2VBbGdvcml0aG06ICgpID0+IFByb21pc2U8dm9pZD4gPSAoKSA9PiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG4gIGxldCBhYm9ydEFsZ29yaXRobTogKHJlYXNvbjogYW55KSA9PiBQcm9taXNlPHZvaWQ+ID0gKCkgPT4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuXG4gIGlmICh1bmRlcmx5aW5nU2luay5zdGFydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnRBbGdvcml0aG0gPSAoKSA9PiB1bmRlcmx5aW5nU2luay5zdGFydCEoY29udHJvbGxlcik7XG4gIH1cbiAgaWYgKHVuZGVybHlpbmdTaW5rLndyaXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICB3cml0ZUFsZ29yaXRobSA9IGNodW5rID0+IHVuZGVybHlpbmdTaW5rLndyaXRlIShjaHVuaywgY29udHJvbGxlcik7XG4gIH1cbiAgaWYgKHVuZGVybHlpbmdTaW5rLmNsb3NlICE9PSB1bmRlZmluZWQpIHtcbiAgICBjbG9zZUFsZ29yaXRobSA9ICgpID0+IHVuZGVybHlpbmdTaW5rLmNsb3NlISgpO1xuICB9XG4gIGlmICh1bmRlcmx5aW5nU2luay5hYm9ydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgYWJvcnRBbGdvcml0aG0gPSByZWFzb24gPT4gdW5kZXJseWluZ1NpbmsuYWJvcnQhKHJlYXNvbik7XG4gIH1cblxuICBTZXRVcFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIoXG4gICAgc3RyZWFtLCBjb250cm9sbGVyLCBzdGFydEFsZ29yaXRobSwgd3JpdGVBbGdvcml0aG0sIGNsb3NlQWxnb3JpdGhtLCBhYm9ydEFsZ29yaXRobSwgaGlnaFdhdGVyTWFyaywgc2l6ZUFsZ29yaXRobVxuICApO1xufVxuXG4vLyBDbGVhckFsZ29yaXRobXMgbWF5IGJlIGNhbGxlZCB0d2ljZS4gRXJyb3JpbmcgdGhlIHNhbWUgc3RyZWFtIGluIG11bHRpcGxlIHdheXMgd2lsbCBvZnRlbiByZXN1bHQgaW4gcmVkdW5kYW50IGNhbGxzLlxuZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyhjb250cm9sbGVyOiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyPGFueT4pIHtcbiAgY29udHJvbGxlci5fd3JpdGVBbGdvcml0aG0gPSB1bmRlZmluZWQhO1xuICBjb250cm9sbGVyLl9jbG9zZUFsZ29yaXRobSA9IHVuZGVmaW5lZCE7XG4gIGNvbnRyb2xsZXIuX2Fib3J0QWxnb3JpdGhtID0gdW5kZWZpbmVkITtcbiAgY29udHJvbGxlci5fc3RyYXRlZ3lTaXplQWxnb3JpdGhtID0gdW5kZWZpbmVkITtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsb3NlPFc+KGNvbnRyb2xsZXI6IFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8Vz4pIHtcbiAgRW5xdWV1ZVZhbHVlV2l0aFNpemUoY29udHJvbGxlciwgY2xvc2VTZW50aW5lbCwgMCk7XG4gIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJBZHZhbmNlUXVldWVJZk5lZWRlZChjb250cm9sbGVyKTtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckdldENodW5rU2l6ZTxXPihjb250cm9sbGVyOiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyPFc+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaHVuazogVyk6IG51bWJlciB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGNvbnRyb2xsZXIuX3N0cmF0ZWd5U2l6ZUFsZ29yaXRobShjaHVuayk7XG4gIH0gY2F0Y2ggKGNodW5rU2l6ZUUpIHtcbiAgICBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3JJZk5lZWRlZChjb250cm9sbGVyLCBjaHVua1NpemVFKTtcbiAgICByZXR1cm4gMTtcbiAgfVxufVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyR2V0RGVzaXJlZFNpemUoY29udHJvbGxlcjogV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxhbnk+KTogbnVtYmVyIHtcbiAgcmV0dXJuIGNvbnRyb2xsZXIuX3N0cmF0ZWd5SFdNIC0gY29udHJvbGxlci5fcXVldWVUb3RhbFNpemU7XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJXcml0ZTxXPihjb250cm9sbGVyOiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyPFc+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rOiBXLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rU2l6ZTogbnVtYmVyKSB7XG4gIHRyeSB7XG4gICAgRW5xdWV1ZVZhbHVlV2l0aFNpemUoY29udHJvbGxlciwgY2h1bmssIGNodW5rU2l6ZSk7XG4gIH0gY2F0Y2ggKGVucXVldWVFKSB7XG4gICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9ySWZOZWVkZWQoY29udHJvbGxlciwgZW5xdWV1ZUUpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHN0cmVhbSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRXcml0YWJsZVN0cmVhbTtcbiAgaWYgKCFXcml0YWJsZVN0cmVhbUNsb3NlUXVldWVkT3JJbkZsaWdodChzdHJlYW0pICYmIHN0cmVhbS5fc3RhdGUgPT09ICd3cml0YWJsZScpIHtcbiAgICBjb25zdCBiYWNrcHJlc3N1cmUgPSBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyR2V0QmFja3ByZXNzdXJlKGNvbnRyb2xsZXIpO1xuICAgIFdyaXRhYmxlU3RyZWFtVXBkYXRlQmFja3ByZXNzdXJlKHN0cmVhbSwgYmFja3ByZXNzdXJlKTtcbiAgfVxuXG4gIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJBZHZhbmNlUXVldWVJZk5lZWRlZChjb250cm9sbGVyKTtcbn1cblxuLy8gQWJzdHJhY3Qgb3BlcmF0aW9ucyBmb3IgdGhlIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIuXG5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJBZHZhbmNlUXVldWVJZk5lZWRlZDxXPihjb250cm9sbGVyOiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyPFc+KSB7XG4gIGNvbnN0IHN0cmVhbSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRXcml0YWJsZVN0cmVhbTtcblxuICBpZiAoIWNvbnRyb2xsZXIuX3N0YXJ0ZWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoc3RyZWFtLl9pbkZsaWdodFdyaXRlUmVxdWVzdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3Qgc3RhdGUgPSBzdHJlYW0uX3N0YXRlO1xuICBhc3NlcnQoc3RhdGUgIT09ICdjbG9zZWQnICYmIHN0YXRlICE9PSAnZXJyb3JlZCcpO1xuICBpZiAoc3RhdGUgPT09ICdlcnJvcmluZycpIHtcbiAgICBXcml0YWJsZVN0cmVhbUZpbmlzaEVycm9yaW5nKHN0cmVhbSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGNvbnRyb2xsZXIuX3F1ZXVlLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHZhbHVlID0gUGVla1F1ZXVlVmFsdWUoY29udHJvbGxlcik7XG4gIGlmICh2YWx1ZSA9PT0gY2xvc2VTZW50aW5lbCkge1xuICAgIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJQcm9jZXNzQ2xvc2UoY29udHJvbGxlcik7XG4gIH0gZWxzZSB7XG4gICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlclByb2Nlc3NXcml0ZShjb250cm9sbGVyLCB2YWx1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9ySWZOZWVkZWQoY29udHJvbGxlcjogV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxhbnk+LCBlcnJvcjogYW55KSB7XG4gIGlmIChjb250cm9sbGVyLl9jb250cm9sbGVkV3JpdGFibGVTdHJlYW0uX3N0YXRlID09PSAnd3JpdGFibGUnKSB7XG4gICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9yKGNvbnRyb2xsZXIsIGVycm9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyUHJvY2Vzc0Nsb3NlKGNvbnRyb2xsZXI6IFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8YW55Pikge1xuICBjb25zdCBzdHJlYW0gPSBjb250cm9sbGVyLl9jb250cm9sbGVkV3JpdGFibGVTdHJlYW07XG5cbiAgV3JpdGFibGVTdHJlYW1NYXJrQ2xvc2VSZXF1ZXN0SW5GbGlnaHQoc3RyZWFtKTtcblxuICBEZXF1ZXVlVmFsdWUoY29udHJvbGxlcik7XG4gIGFzc2VydChjb250cm9sbGVyLl9xdWV1ZS5sZW5ndGggPT09IDApO1xuXG4gIGNvbnN0IHNpbmtDbG9zZVByb21pc2UgPSBjb250cm9sbGVyLl9jbG9zZUFsZ29yaXRobSgpO1xuICBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKGNvbnRyb2xsZXIpO1xuICB1cG9uUHJvbWlzZShcbiAgICBzaW5rQ2xvc2VQcm9taXNlLFxuICAgICgpID0+IHtcbiAgICAgIFdyaXRhYmxlU3RyZWFtRmluaXNoSW5GbGlnaHRDbG9zZShzdHJlYW0pO1xuICAgIH0sXG4gICAgcmVhc29uID0+IHtcbiAgICAgIFdyaXRhYmxlU3RyZWFtRmluaXNoSW5GbGlnaHRDbG9zZVdpdGhFcnJvcihzdHJlYW0sIHJlYXNvbik7XG4gICAgfVxuICApO1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyUHJvY2Vzc1dyaXRlPFc+KGNvbnRyb2xsZXI6IFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8Vz4sIGNodW5rOiBXKSB7XG4gIGNvbnN0IHN0cmVhbSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRXcml0YWJsZVN0cmVhbTtcblxuICBXcml0YWJsZVN0cmVhbU1hcmtGaXJzdFdyaXRlUmVxdWVzdEluRmxpZ2h0KHN0cmVhbSk7XG5cbiAgY29uc3Qgc2lua1dyaXRlUHJvbWlzZSA9IGNvbnRyb2xsZXIuX3dyaXRlQWxnb3JpdGhtKGNodW5rKTtcbiAgdXBvblByb21pc2UoXG4gICAgc2lua1dyaXRlUHJvbWlzZSxcbiAgICAoKSA9PiB7XG4gICAgICBXcml0YWJsZVN0cmVhbUZpbmlzaEluRmxpZ2h0V3JpdGUoc3RyZWFtKTtcblxuICAgICAgY29uc3Qgc3RhdGUgPSBzdHJlYW0uX3N0YXRlO1xuICAgICAgYXNzZXJ0KHN0YXRlID09PSAnd3JpdGFibGUnIHx8IHN0YXRlID09PSAnZXJyb3JpbmcnKTtcblxuICAgICAgRGVxdWV1ZVZhbHVlKGNvbnRyb2xsZXIpO1xuXG4gICAgICBpZiAoIVdyaXRhYmxlU3RyZWFtQ2xvc2VRdWV1ZWRPckluRmxpZ2h0KHN0cmVhbSkgJiYgc3RhdGUgPT09ICd3cml0YWJsZScpIHtcbiAgICAgICAgY29uc3QgYmFja3ByZXNzdXJlID0gV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckdldEJhY2twcmVzc3VyZShjb250cm9sbGVyKTtcbiAgICAgICAgV3JpdGFibGVTdHJlYW1VcGRhdGVCYWNrcHJlc3N1cmUoc3RyZWFtLCBiYWNrcHJlc3N1cmUpO1xuICAgICAgfVxuXG4gICAgICBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQWR2YW5jZVF1ZXVlSWZOZWVkZWQoY29udHJvbGxlcik7XG4gICAgfSxcbiAgICByZWFzb24gPT4ge1xuICAgICAgaWYgKHN0cmVhbS5fc3RhdGUgPT09ICd3cml0YWJsZScpIHtcbiAgICAgICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyhjb250cm9sbGVyKTtcbiAgICAgIH1cbiAgICAgIFdyaXRhYmxlU3RyZWFtRmluaXNoSW5GbGlnaHRXcml0ZVdpdGhFcnJvcihzdHJlYW0sIHJlYXNvbik7XG4gICAgfVxuICApO1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyR2V0QmFja3ByZXNzdXJlKGNvbnRyb2xsZXI6IFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8YW55Pik6IGJvb2xlYW4ge1xuICBjb25zdCBkZXNpcmVkU2l6ZSA9IFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJHZXREZXNpcmVkU2l6ZShjb250cm9sbGVyKTtcbiAgcmV0dXJuIGRlc2lyZWRTaXplIDw9IDA7XG59XG5cbi8vIEEgY2xpZW50IG9mIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIgbWF5IHVzZSB0aGVzZSBmdW5jdGlvbnMgZGlyZWN0bHkgdG8gYnlwYXNzIHN0YXRlIGNoZWNrLlxuXG5mdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3IoY29udHJvbGxlcjogV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxhbnk+LCBlcnJvcjogYW55KSB7XG4gIGNvbnN0IHN0cmVhbSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRXcml0YWJsZVN0cmVhbTtcblxuICBhc3NlcnQoc3RyZWFtLl9zdGF0ZSA9PT0gJ3dyaXRhYmxlJyk7XG5cbiAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyhjb250cm9sbGVyKTtcbiAgV3JpdGFibGVTdHJlYW1TdGFydEVycm9yaW5nKHN0cmVhbSwgZXJyb3IpO1xufVxuXG4vLyBIZWxwZXIgZnVuY3Rpb25zIGZvciB0aGUgV3JpdGFibGVTdHJlYW0uXG5cbmZ1bmN0aW9uIHN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24obmFtZTogc3RyaW5nKTogVHlwZUVycm9yIHtcbiAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoYFdyaXRhYmxlU3RyZWFtLnByb3RvdHlwZS4ke25hbWV9IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBXcml0YWJsZVN0cmVhbWApO1xufVxuXG4vLyBIZWxwZXIgZnVuY3Rpb25zIGZvciB0aGUgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlci5cblxuZnVuY3Rpb24gZGVmYXVsdENvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uKG5hbWU6IHN0cmluZyk6IFR5cGVFcnJvciB7XG4gIHJldHVybiBuZXcgVHlwZUVycm9yKFxuICAgIGBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZS4ke25hbWV9IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyYCk7XG59XG5cblxuLy8gSGVscGVyIGZ1bmN0aW9ucyBmb3IgdGhlIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlci5cblxuZnVuY3Rpb24gZGVmYXVsdFdyaXRlckJyYW5kQ2hlY2tFeGNlcHRpb24obmFtZTogc3RyaW5nKTogVHlwZUVycm9yIHtcbiAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoXG4gICAgYFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlci5wcm90b3R5cGUuJHtuYW1lfSBjYW4gb25seSBiZSB1c2VkIG9uIGEgV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyYCk7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRXcml0ZXJMb2NrRXhjZXB0aW9uKG5hbWU6IHN0cmluZyk6IFR5cGVFcnJvciB7XG4gIHJldHVybiBuZXcgVHlwZUVycm9yKCdDYW5ub3QgJyArIG5hbWUgKyAnIGEgc3RyZWFtIHVzaW5nIGEgcmVsZWFzZWQgd3JpdGVyJyk7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZSh3cml0ZXI6IFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcikge1xuICB3cml0ZXIuX2Nsb3NlZFByb21pc2UgPSBuZXdQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICB3cml0ZXIuX2Nsb3NlZFByb21pc2VfcmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgd3JpdGVyLl9jbG9zZWRQcm9taXNlX3JlamVjdCA9IHJlamVjdDtcbiAgICB3cml0ZXIuX2Nsb3NlZFByb21pc2VTdGF0ZSA9ICdwZW5kaW5nJztcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZUFzUmVqZWN0ZWQod3JpdGVyOiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIsIHJlYXNvbjogYW55KSB7XG4gIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZSh3cml0ZXIpO1xuICBkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZVJlamVjdCh3cml0ZXIsIHJlYXNvbik7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZUFzUmVzb2x2ZWQod3JpdGVyOiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIpIHtcbiAgZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VJbml0aWFsaXplKHdyaXRlcik7XG4gIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlUmVzb2x2ZSh3cml0ZXIpO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZVJlamVjdCh3cml0ZXI6IFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlciwgcmVhc29uOiBhbnkpIHtcbiAgaWYgKHdyaXRlci5fY2xvc2VkUHJvbWlzZV9yZWplY3QgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybjtcbiAgfVxuICBhc3NlcnQod3JpdGVyLl9jbG9zZWRQcm9taXNlU3RhdGUgPT09ICdwZW5kaW5nJyk7XG5cbiAgc2V0UHJvbWlzZUlzSGFuZGxlZFRvVHJ1ZSh3cml0ZXIuX2Nsb3NlZFByb21pc2UpO1xuICB3cml0ZXIuX2Nsb3NlZFByb21pc2VfcmVqZWN0KHJlYXNvbik7XG4gIHdyaXRlci5fY2xvc2VkUHJvbWlzZV9yZXNvbHZlID0gdW5kZWZpbmVkO1xuICB3cml0ZXIuX2Nsb3NlZFByb21pc2VfcmVqZWN0ID0gdW5kZWZpbmVkO1xuICB3cml0ZXIuX2Nsb3NlZFByb21pc2VTdGF0ZSA9ICdyZWplY3RlZCc7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlUmVzZXRUb1JlamVjdGVkKHdyaXRlcjogV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyLCByZWFzb246IGFueSkge1xuICBhc3NlcnQod3JpdGVyLl9jbG9zZWRQcm9taXNlX3Jlc29sdmUgPT09IHVuZGVmaW5lZCk7XG4gIGFzc2VydCh3cml0ZXIuX2Nsb3NlZFByb21pc2VfcmVqZWN0ID09PSB1bmRlZmluZWQpO1xuICBhc3NlcnQod3JpdGVyLl9jbG9zZWRQcm9taXNlU3RhdGUgIT09ICdwZW5kaW5nJyk7XG5cbiAgZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VJbml0aWFsaXplQXNSZWplY3RlZCh3cml0ZXIsIHJlYXNvbik7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlUmVzb2x2ZSh3cml0ZXI6IFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcikge1xuICBpZiAod3JpdGVyLl9jbG9zZWRQcm9taXNlX3Jlc29sdmUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybjtcbiAgfVxuICBhc3NlcnQod3JpdGVyLl9jbG9zZWRQcm9taXNlU3RhdGUgPT09ICdwZW5kaW5nJyk7XG5cbiAgd3JpdGVyLl9jbG9zZWRQcm9taXNlX3Jlc29sdmUodW5kZWZpbmVkKTtcbiAgd3JpdGVyLl9jbG9zZWRQcm9taXNlX3Jlc29sdmUgPSB1bmRlZmluZWQ7XG4gIHdyaXRlci5fY2xvc2VkUHJvbWlzZV9yZWplY3QgPSB1bmRlZmluZWQ7XG4gIHdyaXRlci5fY2xvc2VkUHJvbWlzZVN0YXRlID0gJ3Jlc29sdmVkJztcbn1cblxuZnVuY3Rpb24gZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZUluaXRpYWxpemUod3JpdGVyOiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIpIHtcbiAgd3JpdGVyLl9yZWFkeVByb21pc2UgPSBuZXdQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICB3cml0ZXIuX3JlYWR5UHJvbWlzZV9yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICB3cml0ZXIuX3JlYWR5UHJvbWlzZV9yZWplY3QgPSByZWplY3Q7XG4gIH0pO1xuICB3cml0ZXIuX3JlYWR5UHJvbWlzZVN0YXRlID0gJ3BlbmRpbmcnO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlSW5pdGlhbGl6ZUFzUmVqZWN0ZWQod3JpdGVyOiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIsIHJlYXNvbjogYW55KSB7XG4gIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VJbml0aWFsaXplKHdyaXRlcik7XG4gIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VSZWplY3Qod3JpdGVyLCByZWFzb24pO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlSW5pdGlhbGl6ZUFzUmVzb2x2ZWQod3JpdGVyOiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIpIHtcbiAgZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZUluaXRpYWxpemUod3JpdGVyKTtcbiAgZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZVJlc29sdmUod3JpdGVyKTtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZVJlamVjdCh3cml0ZXI6IFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlciwgcmVhc29uOiBhbnkpIHtcbiAgaWYgKHdyaXRlci5fcmVhZHlQcm9taXNlX3JlamVjdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc2V0UHJvbWlzZUlzSGFuZGxlZFRvVHJ1ZSh3cml0ZXIuX3JlYWR5UHJvbWlzZSk7XG4gIHdyaXRlci5fcmVhZHlQcm9taXNlX3JlamVjdChyZWFzb24pO1xuICB3cml0ZXIuX3JlYWR5UHJvbWlzZV9yZXNvbHZlID0gdW5kZWZpbmVkO1xuICB3cml0ZXIuX3JlYWR5UHJvbWlzZV9yZWplY3QgPSB1bmRlZmluZWQ7XG4gIHdyaXRlci5fcmVhZHlQcm9taXNlU3RhdGUgPSAncmVqZWN0ZWQnO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlUmVzZXQod3JpdGVyOiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIpIHtcbiAgYXNzZXJ0KHdyaXRlci5fcmVhZHlQcm9taXNlX3Jlc29sdmUgPT09IHVuZGVmaW5lZCk7XG4gIGFzc2VydCh3cml0ZXIuX3JlYWR5UHJvbWlzZV9yZWplY3QgPT09IHVuZGVmaW5lZCk7XG5cbiAgZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZUluaXRpYWxpemUod3JpdGVyKTtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZVJlc2V0VG9SZWplY3RlZCh3cml0ZXI6IFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlciwgcmVhc29uOiBhbnkpIHtcbiAgYXNzZXJ0KHdyaXRlci5fcmVhZHlQcm9taXNlX3Jlc29sdmUgPT09IHVuZGVmaW5lZCk7XG4gIGFzc2VydCh3cml0ZXIuX3JlYWR5UHJvbWlzZV9yZWplY3QgPT09IHVuZGVmaW5lZCk7XG5cbiAgZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZUluaXRpYWxpemVBc1JlamVjdGVkKHdyaXRlciwgcmVhc29uKTtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZVJlc29sdmUod3JpdGVyOiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIpIHtcbiAgaWYgKHdyaXRlci5fcmVhZHlQcm9taXNlX3Jlc29sdmUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHdyaXRlci5fcmVhZHlQcm9taXNlX3Jlc29sdmUodW5kZWZpbmVkKTtcbiAgd3JpdGVyLl9yZWFkeVByb21pc2VfcmVzb2x2ZSA9IHVuZGVmaW5lZDtcbiAgd3JpdGVyLl9yZWFkeVByb21pc2VfcmVqZWN0ID0gdW5kZWZpbmVkO1xuICB3cml0ZXIuX3JlYWR5UHJvbWlzZVN0YXRlID0gJ2Z1bGZpbGxlZCc7XG59XG4iLCAiLy8vIDxyZWZlcmVuY2UgbGliPVwiZG9tXCIgLz5cbmV4cG9ydCBjb25zdCBOYXRpdmVET01FeGNlcHRpb246IHR5cGVvZiBET01FeGNlcHRpb24gfCB1bmRlZmluZWQgPVxuICB0eXBlb2YgRE9NRXhjZXB0aW9uICE9PSAndW5kZWZpbmVkJyA/IERPTUV4Y2VwdGlvbiA6IHVuZGVmaW5lZDtcbiIsICIvLy8gPHJlZmVyZW5jZSB0eXBlcz1cIm5vZGVcIiAvPlxuaW1wb3J0IHsgTmF0aXZlRE9NRXhjZXB0aW9uIH0gZnJvbSAnLi9uYXRpdmUnO1xuXG5kZWNsYXJlIGNsYXNzIERPTUV4Y2VwdGlvbkNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlPzogc3RyaW5nLCBuYW1lPzogc3RyaW5nKTtcblxuICBuYW1lOiBzdHJpbmc7XG4gIG1lc3NhZ2U6IHN0cmluZztcbn1cblxudHlwZSBET01FeGNlcHRpb24gPSBET01FeGNlcHRpb25DbGFzcztcbnR5cGUgRE9NRXhjZXB0aW9uQ29uc3RydWN0b3IgPSB0eXBlb2YgRE9NRXhjZXB0aW9uQ2xhc3M7XG5cbmZ1bmN0aW9uIGlzRE9NRXhjZXB0aW9uQ29uc3RydWN0b3IoY3RvcjogdW5rbm93bik6IGN0b3IgaXMgRE9NRXhjZXB0aW9uQ29uc3RydWN0b3Ige1xuICBpZiAoISh0eXBlb2YgY3RvciA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgY3RvciA9PT0gJ29iamVjdCcpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHRyeSB7XG4gICAgbmV3IChjdG9yIGFzIERPTUV4Y2VwdGlvbkNvbnN0cnVjdG9yKSgpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRE9NRXhjZXB0aW9uUG9seWZpbGwoKTogRE9NRXhjZXB0aW9uQ29uc3RydWN0b3Ige1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2hhZG93XG4gIGNvbnN0IGN0b3IgPSBmdW5jdGlvbiBET01FeGNlcHRpb24odGhpczogRE9NRXhjZXB0aW9uLCBtZXNzYWdlPzogc3RyaW5nLCBuYW1lPzogc3RyaW5nKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCAnJztcbiAgICB0aGlzLm5hbWUgPSBuYW1lIHx8ICdFcnJvcic7XG4gICAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgICB9XG4gIH0gYXMgYW55O1xuICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0b3IucHJvdG90eXBlLCAnY29uc3RydWN0b3InLCB7IHZhbHVlOiBjdG9yLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0pO1xuICByZXR1cm4gY3Rvcjtcbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuY29uc3QgRE9NRXhjZXB0aW9uOiBET01FeGNlcHRpb25Db25zdHJ1Y3RvciA9XG4gIGlzRE9NRXhjZXB0aW9uQ29uc3RydWN0b3IoTmF0aXZlRE9NRXhjZXB0aW9uKSA/IE5hdGl2ZURPTUV4Y2VwdGlvbiA6IGNyZWF0ZURPTUV4Y2VwdGlvblBvbHlmaWxsKCk7XG5cbmV4cG9ydCB7IERPTUV4Y2VwdGlvbiB9O1xuIiwgImltcG9ydCB7IElzUmVhZGFibGVTdHJlYW0sIElzUmVhZGFibGVTdHJlYW1Mb2NrZWQsIFJlYWRhYmxlU3RyZWFtLCBSZWFkYWJsZVN0cmVhbUNhbmNlbCB9IGZyb20gJy4uL3JlYWRhYmxlLXN0cmVhbSc7XG5pbXBvcnQgeyBBY3F1aXJlUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyLCBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXJSZWFkIH0gZnJvbSAnLi9kZWZhdWx0LXJlYWRlcic7XG5pbXBvcnQgeyBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNSZWxlYXNlIH0gZnJvbSAnLi9nZW5lcmljLXJlYWRlcic7XG5pbXBvcnQge1xuICBBY3F1aXJlV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyLFxuICBJc1dyaXRhYmxlU3RyZWFtLFxuICBJc1dyaXRhYmxlU3RyZWFtTG9ja2VkLFxuICBXcml0YWJsZVN0cmVhbSxcbiAgV3JpdGFibGVTdHJlYW1BYm9ydCxcbiAgV3JpdGFibGVTdHJlYW1DbG9zZVF1ZXVlZE9ySW5GbGlnaHQsXG4gIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckNsb3NlV2l0aEVycm9yUHJvcGFnYXRpb24sXG4gIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlclJlbGVhc2UsXG4gIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcldyaXRlXG59IGZyb20gJy4uL3dyaXRhYmxlLXN0cmVhbSc7XG5pbXBvcnQgYXNzZXJ0IGZyb20gJy4uLy4uL3N0dWIvYXNzZXJ0JztcbmltcG9ydCB7XG4gIG5ld1Byb21pc2UsXG4gIFBlcmZvcm1Qcm9taXNlVGhlbixcbiAgcHJvbWlzZVJlc29sdmVkV2l0aCxcbiAgc2V0UHJvbWlzZUlzSGFuZGxlZFRvVHJ1ZSxcbiAgdXBvbkZ1bGZpbGxtZW50LFxuICB1cG9uUHJvbWlzZSxcbiAgdXBvblJlamVjdGlvblxufSBmcm9tICcuLi9oZWxwZXJzL3dlYmlkbCc7XG5pbXBvcnQgeyBub29wIH0gZnJvbSAnLi4vLi4vdXRpbHMnO1xuaW1wb3J0IHsgQWJvcnRTaWduYWwsIGlzQWJvcnRTaWduYWwgfSBmcm9tICcuLi9hYm9ydC1zaWduYWwnO1xuaW1wb3J0IHsgRE9NRXhjZXB0aW9uIH0gZnJvbSAnLi4vLi4vc3R1Yi9kb20tZXhjZXB0aW9uJztcblxuZXhwb3J0IGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtUGlwZVRvPFQ+KHNvdXJjZTogUmVhZGFibGVTdHJlYW08VD4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzdDogV3JpdGFibGVTdHJlYW08VD4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldmVudENsb3NlOiBib29sZWFuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZlbnRBYm9ydDogYm9vbGVhbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2ZW50Q2FuY2VsOiBib29sZWFuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwgfCB1bmRlZmluZWQpOiBQcm9taXNlPHVuZGVmaW5lZD4ge1xuICBhc3NlcnQoSXNSZWFkYWJsZVN0cmVhbShzb3VyY2UpKTtcbiAgYXNzZXJ0KElzV3JpdGFibGVTdHJlYW0oZGVzdCkpO1xuICBhc3NlcnQodHlwZW9mIHByZXZlbnRDbG9zZSA9PT0gJ2Jvb2xlYW4nKTtcbiAgYXNzZXJ0KHR5cGVvZiBwcmV2ZW50QWJvcnQgPT09ICdib29sZWFuJyk7XG4gIGFzc2VydCh0eXBlb2YgcHJldmVudENhbmNlbCA9PT0gJ2Jvb2xlYW4nKTtcbiAgYXNzZXJ0KHNpZ25hbCA9PT0gdW5kZWZpbmVkIHx8IGlzQWJvcnRTaWduYWwoc2lnbmFsKSk7XG4gIGFzc2VydCghSXNSZWFkYWJsZVN0cmVhbUxvY2tlZChzb3VyY2UpKTtcbiAgYXNzZXJ0KCFJc1dyaXRhYmxlU3RyZWFtTG9ja2VkKGRlc3QpKTtcblxuICBjb25zdCByZWFkZXIgPSBBY3F1aXJlUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyPFQ+KHNvdXJjZSk7XG4gIGNvbnN0IHdyaXRlciA9IEFjcXVpcmVXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXI8VD4oZGVzdCk7XG5cbiAgc291cmNlLl9kaXN0dXJiZWQgPSB0cnVlO1xuXG4gIGxldCBzaHV0dGluZ0Rvd24gPSBmYWxzZTtcblxuICAvLyBUaGlzIGlzIHVzZWQgdG8ga2VlcCB0cmFjayBvZiB0aGUgc3BlYydzIHJlcXVpcmVtZW50IHRoYXQgd2Ugd2FpdCBmb3Igb25nb2luZyB3cml0ZXMgZHVyaW5nIHNodXRkb3duLlxuICBsZXQgY3VycmVudFdyaXRlID0gcHJvbWlzZVJlc29sdmVkV2l0aDx2b2lkPih1bmRlZmluZWQpO1xuXG4gIHJldHVybiBuZXdQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBsZXQgYWJvcnRBbGdvcml0aG06ICgpID0+IHZvaWQ7XG4gICAgaWYgKHNpZ25hbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBhYm9ydEFsZ29yaXRobSA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRE9NRXhjZXB0aW9uKCdBYm9ydGVkJywgJ0Fib3J0RXJyb3InKTtcbiAgICAgICAgY29uc3QgYWN0aW9uczogQXJyYXk8KCkgPT4gUHJvbWlzZTx2b2lkPj4gPSBbXTtcbiAgICAgICAgaWYgKCFwcmV2ZW50QWJvcnQpIHtcbiAgICAgICAgICBhY3Rpb25zLnB1c2goKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGRlc3QuX3N0YXRlID09PSAnd3JpdGFibGUnKSB7XG4gICAgICAgICAgICAgIHJldHVybiBXcml0YWJsZVN0cmVhbUFib3J0KGRlc3QsIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwcmV2ZW50Q2FuY2VsKSB7XG4gICAgICAgICAgYWN0aW9ucy5wdXNoKCgpID0+IHtcbiAgICAgICAgICAgIGlmIChzb3VyY2UuX3N0YXRlID09PSAncmVhZGFibGUnKSB7XG4gICAgICAgICAgICAgIHJldHVybiBSZWFkYWJsZVN0cmVhbUNhbmNlbChzb3VyY2UsIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2h1dGRvd25XaXRoQWN0aW9uKCgpID0+IFByb21pc2UuYWxsKGFjdGlvbnMubWFwKGFjdGlvbiA9PiBhY3Rpb24oKSkpLCB0cnVlLCBlcnJvcik7XG4gICAgICB9O1xuXG4gICAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgYWJvcnRBbGdvcml0aG0oKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydEFsZ29yaXRobSk7XG4gICAgfVxuXG4gICAgLy8gVXNpbmcgcmVhZGVyIGFuZCB3cml0ZXIsIHJlYWQgYWxsIGNodW5rcyBmcm9tIHRoaXMgYW5kIHdyaXRlIHRoZW0gdG8gZGVzdFxuICAgIC8vIC0gQmFja3ByZXNzdXJlIG11c3QgYmUgZW5mb3JjZWRcbiAgICAvLyAtIFNodXRkb3duIG11c3Qgc3RvcCBhbGwgYWN0aXZpdHlcbiAgICBmdW5jdGlvbiBwaXBlTG9vcCgpIHtcbiAgICAgIHJldHVybiBuZXdQcm9taXNlPHZvaWQ+KChyZXNvbHZlTG9vcCwgcmVqZWN0TG9vcCkgPT4ge1xuICAgICAgICBmdW5jdGlvbiBuZXh0KGRvbmU6IGJvb2xlYW4pIHtcbiAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgcmVzb2x2ZUxvb3AoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gVXNlIGBQZXJmb3JtUHJvbWlzZVRoZW5gIGluc3RlYWQgb2YgYHVwb25Qcm9taXNlYCB0byBhdm9pZFxuICAgICAgICAgICAgLy8gYWRkaW5nIHVubmVjZXNzYXJ5IGAuY2F0Y2gocmV0aHJvd0Fzc2VydGlvbkVycm9yUmVqZWN0aW9uKWAgaGFuZGxlcnNcbiAgICAgICAgICAgIFBlcmZvcm1Qcm9taXNlVGhlbihwaXBlU3RlcCgpLCBuZXh0LCByZWplY3RMb29wKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBuZXh0KGZhbHNlKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBpcGVTdGVwKCk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgICAgaWYgKHNodXR0aW5nRG93bikge1xuICAgICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aCh0cnVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFBlcmZvcm1Qcm9taXNlVGhlbih3cml0ZXIuX3JlYWR5UHJvbWlzZSwgKCkgPT4ge1xuICAgICAgICByZXR1cm4gbmV3UHJvbWlzZTxib29sZWFuPigocmVzb2x2ZVJlYWQsIHJlamVjdFJlYWQpID0+IHtcbiAgICAgICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXJSZWFkKFxuICAgICAgICAgICAgcmVhZGVyLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBfY2h1bmtTdGVwczogY2h1bmsgPT4ge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRXcml0ZSA9IFBlcmZvcm1Qcm9taXNlVGhlbihXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJXcml0ZSh3cml0ZXIsIGNodW5rKSwgdW5kZWZpbmVkLCBub29wKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlUmVhZChmYWxzZSk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIF9jbG9zZVN0ZXBzOiAoKSA9PiByZXNvbHZlUmVhZCh0cnVlKSxcbiAgICAgICAgICAgICAgX2Vycm9yU3RlcHM6IHJlamVjdFJlYWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEVycm9ycyBtdXN0IGJlIHByb3BhZ2F0ZWQgZm9yd2FyZFxuICAgIGlzT3JCZWNvbWVzRXJyb3JlZChzb3VyY2UsIHJlYWRlci5fY2xvc2VkUHJvbWlzZSwgc3RvcmVkRXJyb3IgPT4ge1xuICAgICAgaWYgKCFwcmV2ZW50QWJvcnQpIHtcbiAgICAgICAgc2h1dGRvd25XaXRoQWN0aW9uKCgpID0+IFdyaXRhYmxlU3RyZWFtQWJvcnQoZGVzdCwgc3RvcmVkRXJyb3IpLCB0cnVlLCBzdG9yZWRFcnJvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzaHV0ZG93bih0cnVlLCBzdG9yZWRFcnJvcik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBFcnJvcnMgbXVzdCBiZSBwcm9wYWdhdGVkIGJhY2t3YXJkXG4gICAgaXNPckJlY29tZXNFcnJvcmVkKGRlc3QsIHdyaXRlci5fY2xvc2VkUHJvbWlzZSwgc3RvcmVkRXJyb3IgPT4ge1xuICAgICAgaWYgKCFwcmV2ZW50Q2FuY2VsKSB7XG4gICAgICAgIHNodXRkb3duV2l0aEFjdGlvbigoKSA9PiBSZWFkYWJsZVN0cmVhbUNhbmNlbChzb3VyY2UsIHN0b3JlZEVycm9yKSwgdHJ1ZSwgc3RvcmVkRXJyb3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2h1dGRvd24odHJ1ZSwgc3RvcmVkRXJyb3IpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gQ2xvc2luZyBtdXN0IGJlIHByb3BhZ2F0ZWQgZm9yd2FyZFxuICAgIGlzT3JCZWNvbWVzQ2xvc2VkKHNvdXJjZSwgcmVhZGVyLl9jbG9zZWRQcm9taXNlLCAoKSA9PiB7XG4gICAgICBpZiAoIXByZXZlbnRDbG9zZSkge1xuICAgICAgICBzaHV0ZG93bldpdGhBY3Rpb24oKCkgPT4gV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyQ2xvc2VXaXRoRXJyb3JQcm9wYWdhdGlvbih3cml0ZXIpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNodXRkb3duKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBDbG9zaW5nIG11c3QgYmUgcHJvcGFnYXRlZCBiYWNrd2FyZFxuICAgIGlmIChXcml0YWJsZVN0cmVhbUNsb3NlUXVldWVkT3JJbkZsaWdodChkZXN0KSB8fCBkZXN0Ll9zdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICAgIGNvbnN0IGRlc3RDbG9zZWQgPSBuZXcgVHlwZUVycm9yKCd0aGUgZGVzdGluYXRpb24gd3JpdGFibGUgc3RyZWFtIGNsb3NlZCBiZWZvcmUgYWxsIGRhdGEgY291bGQgYmUgcGlwZWQgdG8gaXQnKTtcblxuICAgICAgaWYgKCFwcmV2ZW50Q2FuY2VsKSB7XG4gICAgICAgIHNodXRkb3duV2l0aEFjdGlvbigoKSA9PiBSZWFkYWJsZVN0cmVhbUNhbmNlbChzb3VyY2UsIGRlc3RDbG9zZWQpLCB0cnVlLCBkZXN0Q2xvc2VkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNodXRkb3duKHRydWUsIGRlc3RDbG9zZWQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNldFByb21pc2VJc0hhbmRsZWRUb1RydWUocGlwZUxvb3AoKSk7XG5cbiAgICBmdW5jdGlvbiB3YWl0Rm9yV3JpdGVzVG9GaW5pc2goKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAvLyBBbm90aGVyIHdyaXRlIG1heSBoYXZlIHN0YXJ0ZWQgd2hpbGUgd2Ugd2VyZSB3YWl0aW5nIG9uIHRoaXMgY3VycmVudFdyaXRlLCBzbyB3ZSBoYXZlIHRvIGJlIHN1cmUgdG8gd2FpdFxuICAgICAgLy8gZm9yIHRoYXQgdG9vLlxuICAgICAgY29uc3Qgb2xkQ3VycmVudFdyaXRlID0gY3VycmVudFdyaXRlO1xuICAgICAgcmV0dXJuIFBlcmZvcm1Qcm9taXNlVGhlbihcbiAgICAgICAgY3VycmVudFdyaXRlLFxuICAgICAgICAoKSA9PiBvbGRDdXJyZW50V3JpdGUgIT09IGN1cnJlbnRXcml0ZSA/IHdhaXRGb3JXcml0ZXNUb0ZpbmlzaCgpIDogdW5kZWZpbmVkXG4gICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzT3JCZWNvbWVzRXJyb3JlZChzdHJlYW06IFJlYWRhYmxlU3RyZWFtIHwgV3JpdGFibGVTdHJlYW0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2U6IFByb21pc2U8dm9pZD4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogKHJlYXNvbjogYW55KSA9PiB2b2lkKSB7XG4gICAgICBpZiAoc3RyZWFtLl9zdGF0ZSA9PT0gJ2Vycm9yZWQnKSB7XG4gICAgICAgIGFjdGlvbihzdHJlYW0uX3N0b3JlZEVycm9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVwb25SZWplY3Rpb24ocHJvbWlzZSwgYWN0aW9uKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc09yQmVjb21lc0Nsb3NlZChzdHJlYW06IFJlYWRhYmxlU3RyZWFtIHwgV3JpdGFibGVTdHJlYW0sIHByb21pc2U6IFByb21pc2U8dm9pZD4sIGFjdGlvbjogKCkgPT4gdm9pZCkge1xuICAgICAgaWYgKHN0cmVhbS5fc3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICAgICAgIGFjdGlvbigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXBvbkZ1bGZpbGxtZW50KHByb21pc2UsIGFjdGlvbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2h1dGRvd25XaXRoQWN0aW9uKGFjdGlvbjogKCkgPT4gUHJvbWlzZTx1bmtub3duPiwgb3JpZ2luYWxJc0Vycm9yPzogYm9vbGVhbiwgb3JpZ2luYWxFcnJvcj86IGFueSkge1xuICAgICAgaWYgKHNodXR0aW5nRG93bikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzaHV0dGluZ0Rvd24gPSB0cnVlO1xuXG4gICAgICBpZiAoZGVzdC5fc3RhdGUgPT09ICd3cml0YWJsZScgJiYgIVdyaXRhYmxlU3RyZWFtQ2xvc2VRdWV1ZWRPckluRmxpZ2h0KGRlc3QpKSB7XG4gICAgICAgIHVwb25GdWxmaWxsbWVudCh3YWl0Rm9yV3JpdGVzVG9GaW5pc2goKSwgZG9UaGVSZXN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRvVGhlUmVzdCgpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBkb1RoZVJlc3QoKSB7XG4gICAgICAgIHVwb25Qcm9taXNlKFxuICAgICAgICAgIGFjdGlvbigpLFxuICAgICAgICAgICgpID0+IGZpbmFsaXplKG9yaWdpbmFsSXNFcnJvciwgb3JpZ2luYWxFcnJvciksXG4gICAgICAgICAgbmV3RXJyb3IgPT4gZmluYWxpemUodHJ1ZSwgbmV3RXJyb3IpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2h1dGRvd24oaXNFcnJvcj86IGJvb2xlYW4sIGVycm9yPzogYW55KSB7XG4gICAgICBpZiAoc2h1dHRpbmdEb3duKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHNodXR0aW5nRG93biA9IHRydWU7XG5cbiAgICAgIGlmIChkZXN0Ll9zdGF0ZSA9PT0gJ3dyaXRhYmxlJyAmJiAhV3JpdGFibGVTdHJlYW1DbG9zZVF1ZXVlZE9ySW5GbGlnaHQoZGVzdCkpIHtcbiAgICAgICAgdXBvbkZ1bGZpbGxtZW50KHdhaXRGb3JXcml0ZXNUb0ZpbmlzaCgpLCAoKSA9PiBmaW5hbGl6ZShpc0Vycm9yLCBlcnJvcikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmluYWxpemUoaXNFcnJvciwgZXJyb3IpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpbmFsaXplKGlzRXJyb3I/OiBib29sZWFuLCBlcnJvcj86IGFueSkge1xuICAgICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyUmVsZWFzZSh3cml0ZXIpO1xuICAgICAgUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljUmVsZWFzZShyZWFkZXIpO1xuXG4gICAgICBpZiAoc2lnbmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRBbGdvcml0aG0pO1xuICAgICAgfVxuICAgICAgaWYgKGlzRXJyb3IpIHtcbiAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc29sdmUodW5kZWZpbmVkKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuIiwgImltcG9ydCB7IFF1ZXVpbmdTdHJhdGVneVNpemVDYWxsYmFjayB9IGZyb20gJy4uL3F1ZXVpbmctc3RyYXRlZ3knO1xuaW1wb3J0IGFzc2VydCBmcm9tICcuLi8uLi9zdHViL2Fzc2VydCc7XG5pbXBvcnQgeyBEZXF1ZXVlVmFsdWUsIEVucXVldWVWYWx1ZVdpdGhTaXplLCBRdWV1ZVBhaXIsIFJlc2V0UXVldWUgfSBmcm9tICcuLi9hYnN0cmFjdC1vcHMvcXVldWUtd2l0aC1zaXplcyc7XG5pbXBvcnQge1xuICBSZWFkYWJsZVN0cmVhbUFkZFJlYWRSZXF1ZXN0LFxuICBSZWFkYWJsZVN0cmVhbUZ1bGZpbGxSZWFkUmVxdWVzdCxcbiAgUmVhZGFibGVTdHJlYW1HZXROdW1SZWFkUmVxdWVzdHMsXG4gIFJlYWRSZXF1ZXN0XG59IGZyb20gJy4vZGVmYXVsdC1yZWFkZXInO1xuaW1wb3J0IHsgU2ltcGxlUXVldWUgfSBmcm9tICcuLi9zaW1wbGUtcXVldWUnO1xuaW1wb3J0IHsgSXNSZWFkYWJsZVN0cmVhbUxvY2tlZCwgUmVhZGFibGVTdHJlYW0sIFJlYWRhYmxlU3RyZWFtQ2xvc2UsIFJlYWRhYmxlU3RyZWFtRXJyb3IgfSBmcm9tICcuLi9yZWFkYWJsZS1zdHJlYW0nO1xuaW1wb3J0IHsgVmFsaWRhdGVkVW5kZXJseWluZ1NvdXJjZSB9IGZyb20gJy4vdW5kZXJseWluZy1zb3VyY2UnO1xuaW1wb3J0IHsgdHlwZUlzT2JqZWN0IH0gZnJvbSAnLi4vaGVscGVycy9taXNjZWxsYW5lb3VzJztcbmltcG9ydCB7IENhbmNlbFN0ZXBzLCBQdWxsU3RlcHMgfSBmcm9tICcuLi9hYnN0cmFjdC1vcHMvaW50ZXJuYWwtbWV0aG9kcyc7XG5pbXBvcnQgeyBwcm9taXNlUmVzb2x2ZWRXaXRoLCB1cG9uUHJvbWlzZSB9IGZyb20gJy4uL2hlbHBlcnMvd2ViaWRsJztcblxuLyoqXG4gKiBBbGxvd3MgY29udHJvbCBvZiBhIHtAbGluayBSZWFkYWJsZVN0cmVhbSB8IHJlYWRhYmxlIHN0cmVhbX0ncyBzdGF0ZSBhbmQgaW50ZXJuYWwgcXVldWUuXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxSPiB7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2NvbnRyb2xsZWRSZWFkYWJsZVN0cmVhbSE6IFJlYWRhYmxlU3RyZWFtPFI+O1xuICAvKiogQGludGVybmFsICovXG4gIF9xdWV1ZSE6IFNpbXBsZVF1ZXVlPFF1ZXVlUGFpcjxSPj47XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3F1ZXVlVG90YWxTaXplITogbnVtYmVyO1xuICAvKiogQGludGVybmFsICovXG4gIF9zdGFydGVkITogYm9vbGVhbjtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfY2xvc2VSZXF1ZXN0ZWQhOiBib29sZWFuO1xuICAvKiogQGludGVybmFsICovXG4gIF9wdWxsQWdhaW4hOiBib29sZWFuO1xuICAvKiogQGludGVybmFsICovXG4gIF9wdWxsaW5nICE6IGJvb2xlYW47XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3N0cmF0ZWd5U2l6ZUFsZ29yaXRobSE6IFF1ZXVpbmdTdHJhdGVneVNpemVDYWxsYmFjazxSPjtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfc3RyYXRlZ3lIV00hOiBudW1iZXI7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3B1bGxBbGdvcml0aG0hOiAoKSA9PiBQcm9taXNlPHZvaWQ+O1xuICAvKiogQGludGVybmFsICovXG4gIF9jYW5jZWxBbGdvcml0aG0hOiAocmVhc29uOiBhbnkpID0+IFByb21pc2U8dm9pZD47XG5cbiAgcHJpdmF0ZSBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbGxlZ2FsIGNvbnN0cnVjdG9yJyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZGVzaXJlZCBzaXplIHRvIGZpbGwgdGhlIGNvbnRyb2xsZWQgc3RyZWFtJ3MgaW50ZXJuYWwgcXVldWUuIEl0IGNhbiBiZSBuZWdhdGl2ZSwgaWYgdGhlIHF1ZXVlIGlzXG4gICAqIG92ZXItZnVsbC4gQW4gdW5kZXJseWluZyBzb3VyY2Ugb3VnaHQgdG8gdXNlIHRoaXMgaW5mb3JtYXRpb24gdG8gZGV0ZXJtaW5lIHdoZW4gYW5kIGhvdyB0byBhcHBseSBiYWNrcHJlc3N1cmUuXG4gICAqL1xuICBnZXQgZGVzaXJlZFNpemUoKTogbnVtYmVyIHwgbnVsbCB7XG4gICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIodGhpcykpIHtcbiAgICAgIHRocm93IGRlZmF1bHRDb250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbignZGVzaXJlZFNpemUnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckdldERlc2lyZWRTaXplKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENsb3NlcyB0aGUgY29udHJvbGxlZCByZWFkYWJsZSBzdHJlYW0uIENvbnN1bWVycyB3aWxsIHN0aWxsIGJlIGFibGUgdG8gcmVhZCBhbnkgcHJldmlvdXNseS1lbnF1ZXVlZCBjaHVua3MgZnJvbVxuICAgKiB0aGUgc3RyZWFtLCBidXQgb25jZSB0aG9zZSBhcmUgcmVhZCwgdGhlIHN0cmVhbSB3aWxsIGJlY29tZSBjbG9zZWQuXG4gICAqL1xuICBjbG9zZSgpOiB2b2lkIHtcbiAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcih0aGlzKSkge1xuICAgICAgdGhyb3cgZGVmYXVsdENvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdjbG9zZScpO1xuICAgIH1cblxuICAgIGlmICghUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNhbkNsb3NlT3JFbnF1ZXVlKHRoaXMpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgc3RyZWFtIGlzIG5vdCBpbiBhIHN0YXRlIHRoYXQgcGVybWl0cyBjbG9zZScpO1xuICAgIH1cblxuICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbG9zZSh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbnF1ZXVlcyB0aGUgZ2l2ZW4gY2h1bmsgYGNodW5rYCBpbiB0aGUgY29udHJvbGxlZCByZWFkYWJsZSBzdHJlYW0uXG4gICAqL1xuICBlbnF1ZXVlKGNodW5rOiBSKTogdm9pZDtcbiAgZW5xdWV1ZShjaHVuazogUiA9IHVuZGVmaW5lZCEpOiB2b2lkIHtcbiAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcih0aGlzKSkge1xuICAgICAgdGhyb3cgZGVmYXVsdENvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdlbnF1ZXVlJyk7XG4gICAgfVxuXG4gICAgaWYgKCFSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2FuQ2xvc2VPckVucXVldWUodGhpcykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBzdHJlYW0gaXMgbm90IGluIGEgc3RhdGUgdGhhdCBwZXJtaXRzIGVucXVldWUnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVucXVldWUodGhpcywgY2h1bmspO1xuICB9XG5cbiAgLyoqXG4gICAqIEVycm9ycyB0aGUgY29udHJvbGxlZCByZWFkYWJsZSBzdHJlYW0sIG1ha2luZyBhbGwgZnV0dXJlIGludGVyYWN0aW9ucyB3aXRoIGl0IGZhaWwgd2l0aCB0aGUgZ2l2ZW4gZXJyb3IgYGVgLlxuICAgKi9cbiAgZXJyb3IoZTogYW55ID0gdW5kZWZpbmVkKTogdm9pZCB7XG4gICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIodGhpcykpIHtcbiAgICAgIHRocm93IGRlZmF1bHRDb250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbignZXJyb3InKTtcbiAgICB9XG5cbiAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3IodGhpcywgZSk7XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIFtDYW5jZWxTdGVwc10ocmVhc29uOiBhbnkpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBSZXNldFF1ZXVlKHRoaXMpO1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX2NhbmNlbEFsZ29yaXRobShyZWFzb24pO1xuICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbGVhckFsZ29yaXRobXModGhpcyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgW1B1bGxTdGVwc10ocmVhZFJlcXVlc3Q6IFJlYWRSZXF1ZXN0PFI+KTogdm9pZCB7XG4gICAgY29uc3Qgc3RyZWFtID0gdGhpcy5fY29udHJvbGxlZFJlYWRhYmxlU3RyZWFtO1xuXG4gICAgaWYgKHRoaXMuX3F1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGNodW5rID0gRGVxdWV1ZVZhbHVlKHRoaXMpO1xuXG4gICAgICBpZiAodGhpcy5fY2xvc2VSZXF1ZXN0ZWQgJiYgdGhpcy5fcXVldWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbGVhckFsZ29yaXRobXModGhpcyk7XG4gICAgICAgIFJlYWRhYmxlU3RyZWFtQ2xvc2Uoc3RyZWFtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDYWxsUHVsbElmTmVlZGVkKHRoaXMpO1xuICAgICAgfVxuXG4gICAgICByZWFkUmVxdWVzdC5fY2h1bmtTdGVwcyhjaHVuayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWRhYmxlU3RyZWFtQWRkUmVhZFJlcXVlc3Qoc3RyZWFtLCByZWFkUmVxdWVzdCk7XG4gICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2FsbFB1bGxJZk5lZWRlZCh0aGlzKTtcbiAgICB9XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUsIHtcbiAgY2xvc2U6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICBlbnF1ZXVlOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgZXJyb3I6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICBkZXNpcmVkU2l6ZTogeyBlbnVtZXJhYmxlOiB0cnVlIH1cbn0pO1xuaWYgKHR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWcgPT09ICdzeW1ib2wnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7XG4gICAgdmFsdWU6ICdSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyJyxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbi8vIEFic3RyYWN0IG9wZXJhdGlvbnMgZm9yIHRoZSBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLlxuXG5mdW5jdGlvbiBJc1JlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8UiA9IGFueT4oeDogYW55KTogeCBpcyBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyPFI+IHtcbiAgaWYgKCF0eXBlSXNPYmplY3QoeCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnX2NvbnRyb2xsZWRSZWFkYWJsZVN0cmVhbScpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHggaW5zdGFuY2VvZiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyO1xufVxuXG5mdW5jdGlvbiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2FsbFB1bGxJZk5lZWRlZChjb250cm9sbGVyOiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyPGFueT4pOiB2b2lkIHtcbiAgY29uc3Qgc2hvdWxkUHVsbCA9IFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJTaG91bGRDYWxsUHVsbChjb250cm9sbGVyKTtcbiAgaWYgKCFzaG91bGRQdWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGNvbnRyb2xsZXIuX3B1bGxpbmcpIHtcbiAgICBjb250cm9sbGVyLl9wdWxsQWdhaW4gPSB0cnVlO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGFzc2VydCghY29udHJvbGxlci5fcHVsbEFnYWluKTtcblxuICBjb250cm9sbGVyLl9wdWxsaW5nID0gdHJ1ZTtcblxuICBjb25zdCBwdWxsUHJvbWlzZSA9IGNvbnRyb2xsZXIuX3B1bGxBbGdvcml0aG0oKTtcbiAgdXBvblByb21pc2UoXG4gICAgcHVsbFByb21pc2UsXG4gICAgKCkgPT4ge1xuICAgICAgY29udHJvbGxlci5fcHVsbGluZyA9IGZhbHNlO1xuXG4gICAgICBpZiAoY29udHJvbGxlci5fcHVsbEFnYWluKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuX3B1bGxBZ2FpbiA9IGZhbHNlO1xuICAgICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2FsbFB1bGxJZk5lZWRlZChjb250cm9sbGVyKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGUgPT4ge1xuICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9yKGNvbnRyb2xsZXIsIGUpO1xuICAgIH1cbiAgKTtcbn1cblxuZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlclNob3VsZENhbGxQdWxsKGNvbnRyb2xsZXI6IFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8YW55Pik6IGJvb2xlYW4ge1xuICBjb25zdCBzdHJlYW0gPSBjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVTdHJlYW07XG5cbiAgaWYgKCFSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2FuQ2xvc2VPckVucXVldWUoY29udHJvbGxlcikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoIWNvbnRyb2xsZXIuX3N0YXJ0ZWQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoSXNSZWFkYWJsZVN0cmVhbUxvY2tlZChzdHJlYW0pICYmIFJlYWRhYmxlU3RyZWFtR2V0TnVtUmVhZFJlcXVlc3RzKHN0cmVhbSkgPiAwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBjb25zdCBkZXNpcmVkU2l6ZSA9IFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJHZXREZXNpcmVkU2l6ZShjb250cm9sbGVyKTtcbiAgYXNzZXJ0KGRlc2lyZWRTaXplICE9PSBudWxsKTtcbiAgaWYgKGRlc2lyZWRTaXplISA+IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyhjb250cm9sbGVyOiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyPGFueT4pIHtcbiAgY29udHJvbGxlci5fcHVsbEFsZ29yaXRobSA9IHVuZGVmaW5lZCE7XG4gIGNvbnRyb2xsZXIuX2NhbmNlbEFsZ29yaXRobSA9IHVuZGVmaW5lZCE7XG4gIGNvbnRyb2xsZXIuX3N0cmF0ZWd5U2l6ZUFsZ29yaXRobSA9IHVuZGVmaW5lZCE7XG59XG5cbi8vIEEgY2xpZW50IG9mIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIgbWF5IHVzZSB0aGVzZSBmdW5jdGlvbnMgZGlyZWN0bHkgdG8gYnlwYXNzIHN0YXRlIGNoZWNrLlxuXG5leHBvcnQgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsb3NlKGNvbnRyb2xsZXI6IFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8YW55Pikge1xuICBpZiAoIVJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDYW5DbG9zZU9yRW5xdWV1ZShjb250cm9sbGVyKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHN0cmVhbSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZVN0cmVhbTtcblxuICBjb250cm9sbGVyLl9jbG9zZVJlcXVlc3RlZCA9IHRydWU7XG5cbiAgaWYgKGNvbnRyb2xsZXIuX3F1ZXVlLmxlbmd0aCA9PT0gMCkge1xuICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbGVhckFsZ29yaXRobXMoY29udHJvbGxlcik7XG4gICAgUmVhZGFibGVTdHJlYW1DbG9zZShzdHJlYW0pO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRW5xdWV1ZTxSPihcbiAgY29udHJvbGxlcjogUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxSPixcbiAgY2h1bms6IFJcbik6IHZvaWQge1xuICBpZiAoIVJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDYW5DbG9zZU9yRW5xdWV1ZShjb250cm9sbGVyKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHN0cmVhbSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZVN0cmVhbTtcblxuICBpZiAoSXNSZWFkYWJsZVN0cmVhbUxvY2tlZChzdHJlYW0pICYmIFJlYWRhYmxlU3RyZWFtR2V0TnVtUmVhZFJlcXVlc3RzKHN0cmVhbSkgPiAwKSB7XG4gICAgUmVhZGFibGVTdHJlYW1GdWxmaWxsUmVhZFJlcXVlc3Qoc3RyZWFtLCBjaHVuaywgZmFsc2UpO1xuICB9IGVsc2Uge1xuICAgIGxldCBjaHVua1NpemU7XG4gICAgdHJ5IHtcbiAgICAgIGNodW5rU2l6ZSA9IGNvbnRyb2xsZXIuX3N0cmF0ZWd5U2l6ZUFsZ29yaXRobShjaHVuayk7XG4gICAgfSBjYXRjaCAoY2h1bmtTaXplRSkge1xuICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9yKGNvbnRyb2xsZXIsIGNodW5rU2l6ZUUpO1xuICAgICAgdGhyb3cgY2h1bmtTaXplRTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgRW5xdWV1ZVZhbHVlV2l0aFNpemUoY29udHJvbGxlciwgY2h1bmssIGNodW5rU2l6ZSk7XG4gICAgfSBjYXRjaCAoZW5xdWV1ZUUpIHtcbiAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcihjb250cm9sbGVyLCBlbnF1ZXVlRSk7XG4gICAgICB0aHJvdyBlbnF1ZXVlRTtcbiAgICB9XG4gIH1cblxuICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2FsbFB1bGxJZk5lZWRlZChjb250cm9sbGVyKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcihjb250cm9sbGVyOiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyPGFueT4sIGU6IGFueSkge1xuICBjb25zdCBzdHJlYW0gPSBjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVTdHJlYW07XG5cbiAgaWYgKHN0cmVhbS5fc3RhdGUgIT09ICdyZWFkYWJsZScpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBSZXNldFF1ZXVlKGNvbnRyb2xsZXIpO1xuXG4gIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbGVhckFsZ29yaXRobXMoY29udHJvbGxlcik7XG4gIFJlYWRhYmxlU3RyZWFtRXJyb3Ioc3RyZWFtLCBlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJHZXREZXNpcmVkU2l6ZShcbiAgY29udHJvbGxlcjogUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxhbnk+XG4pOiBudW1iZXIgfCBudWxsIHtcbiAgY29uc3Qgc3RhdGUgPSBjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVTdHJlYW0uX3N0YXRlO1xuXG4gIGlmIChzdGF0ZSA9PT0gJ2Vycm9yZWQnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKHN0YXRlID09PSAnY2xvc2VkJykge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgcmV0dXJuIGNvbnRyb2xsZXIuX3N0cmF0ZWd5SFdNIC0gY29udHJvbGxlci5fcXVldWVUb3RhbFNpemU7XG59XG5cbi8vIFRoaXMgaXMgdXNlZCBpbiB0aGUgaW1wbGVtZW50YXRpb24gb2YgVHJhbnNmb3JtU3RyZWFtLlxuZXhwb3J0IGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJIYXNCYWNrcHJlc3N1cmUoXG4gIGNvbnRyb2xsZXI6IFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8YW55PlxuKTogYm9vbGVhbiB7XG4gIGlmIChSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyU2hvdWxkQ2FsbFB1bGwoY29udHJvbGxlcikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDYW5DbG9zZU9yRW5xdWV1ZShcbiAgY29udHJvbGxlcjogUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxhbnk+XG4pOiBib29sZWFuIHtcbiAgY29uc3Qgc3RhdGUgPSBjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVTdHJlYW0uX3N0YXRlO1xuXG4gIGlmICghY29udHJvbGxlci5fY2xvc2VSZXF1ZXN0ZWQgJiYgc3RhdGUgPT09ICdyZWFkYWJsZScpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFNldFVwUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxSPihzdHJlYW06IFJlYWRhYmxlU3RyZWFtPFI+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyOiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyPFI+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydEFsZ29yaXRobTogKCkgPT4gdm9pZCB8IFByb21pc2VMaWtlPHZvaWQ+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdWxsQWxnb3JpdGhtOiAoKSA9PiBQcm9taXNlPHZvaWQ+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5jZWxBbGdvcml0aG06IChyZWFzb246IGFueSkgPT4gUHJvbWlzZTx2b2lkPixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGlnaFdhdGVyTWFyazogbnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaXplQWxnb3JpdGhtOiBRdWV1aW5nU3RyYXRlZ3lTaXplQ2FsbGJhY2s8Uj4pIHtcbiAgYXNzZXJ0KHN0cmVhbS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyID09PSB1bmRlZmluZWQpO1xuXG4gIGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZVN0cmVhbSA9IHN0cmVhbTtcblxuICBjb250cm9sbGVyLl9xdWV1ZSA9IHVuZGVmaW5lZCE7XG4gIGNvbnRyb2xsZXIuX3F1ZXVlVG90YWxTaXplID0gdW5kZWZpbmVkITtcbiAgUmVzZXRRdWV1ZShjb250cm9sbGVyKTtcblxuICBjb250cm9sbGVyLl9zdGFydGVkID0gZmFsc2U7XG4gIGNvbnRyb2xsZXIuX2Nsb3NlUmVxdWVzdGVkID0gZmFsc2U7XG4gIGNvbnRyb2xsZXIuX3B1bGxBZ2FpbiA9IGZhbHNlO1xuICBjb250cm9sbGVyLl9wdWxsaW5nID0gZmFsc2U7XG5cbiAgY29udHJvbGxlci5fc3RyYXRlZ3lTaXplQWxnb3JpdGhtID0gc2l6ZUFsZ29yaXRobTtcbiAgY29udHJvbGxlci5fc3RyYXRlZ3lIV00gPSBoaWdoV2F0ZXJNYXJrO1xuXG4gIGNvbnRyb2xsZXIuX3B1bGxBbGdvcml0aG0gPSBwdWxsQWxnb3JpdGhtO1xuICBjb250cm9sbGVyLl9jYW5jZWxBbGdvcml0aG0gPSBjYW5jZWxBbGdvcml0aG07XG5cbiAgc3RyZWFtLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIgPSBjb250cm9sbGVyO1xuXG4gIGNvbnN0IHN0YXJ0UmVzdWx0ID0gc3RhcnRBbGdvcml0aG0oKTtcbiAgdXBvblByb21pc2UoXG4gICAgcHJvbWlzZVJlc29sdmVkV2l0aChzdGFydFJlc3VsdCksXG4gICAgKCkgPT4ge1xuICAgICAgY29udHJvbGxlci5fc3RhcnRlZCA9IHRydWU7XG5cbiAgICAgIGFzc2VydCghY29udHJvbGxlci5fcHVsbGluZyk7XG4gICAgICBhc3NlcnQoIWNvbnRyb2xsZXIuX3B1bGxBZ2Fpbik7XG5cbiAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDYWxsUHVsbElmTmVlZGVkKGNvbnRyb2xsZXIpO1xuICAgIH0sXG4gICAgciA9PiB7XG4gICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3IoY29udHJvbGxlciwgcik7XG4gICAgfVxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gU2V0VXBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRnJvbVVuZGVybHlpbmdTb3VyY2U8Uj4oXG4gIHN0cmVhbTogUmVhZGFibGVTdHJlYW08Uj4sXG4gIHVuZGVybHlpbmdTb3VyY2U6IFZhbGlkYXRlZFVuZGVybHlpbmdTb3VyY2U8Uj4sXG4gIGhpZ2hXYXRlck1hcms6IG51bWJlcixcbiAgc2l6ZUFsZ29yaXRobTogUXVldWluZ1N0cmF0ZWd5U2l6ZUNhbGxiYWNrPFI+XG4pIHtcbiAgY29uc3QgY29udHJvbGxlcjogUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxSPiA9IE9iamVjdC5jcmVhdGUoUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUpO1xuXG4gIGxldCBzdGFydEFsZ29yaXRobTogKCkgPT4gdm9pZCB8IFByb21pc2VMaWtlPHZvaWQ+ID0gKCkgPT4gdW5kZWZpbmVkO1xuICBsZXQgcHVsbEFsZ29yaXRobTogKCkgPT4gUHJvbWlzZTx2b2lkPiA9ICgpID0+IHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcbiAgbGV0IGNhbmNlbEFsZ29yaXRobTogKHJlYXNvbjogYW55KSA9PiBQcm9taXNlPHZvaWQ+ID0gKCkgPT4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuXG4gIGlmICh1bmRlcmx5aW5nU291cmNlLnN0YXJ0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBzdGFydEFsZ29yaXRobSA9ICgpID0+IHVuZGVybHlpbmdTb3VyY2Uuc3RhcnQhKGNvbnRyb2xsZXIpO1xuICB9XG4gIGlmICh1bmRlcmx5aW5nU291cmNlLnB1bGwgIT09IHVuZGVmaW5lZCkge1xuICAgIHB1bGxBbGdvcml0aG0gPSAoKSA9PiB1bmRlcmx5aW5nU291cmNlLnB1bGwhKGNvbnRyb2xsZXIpO1xuICB9XG4gIGlmICh1bmRlcmx5aW5nU291cmNlLmNhbmNlbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY2FuY2VsQWxnb3JpdGhtID0gcmVhc29uID0+IHVuZGVybHlpbmdTb3VyY2UuY2FuY2VsIShyZWFzb24pO1xuICB9XG5cbiAgU2V0VXBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyKFxuICAgIHN0cmVhbSwgY29udHJvbGxlciwgc3RhcnRBbGdvcml0aG0sIHB1bGxBbGdvcml0aG0sIGNhbmNlbEFsZ29yaXRobSwgaGlnaFdhdGVyTWFyaywgc2l6ZUFsZ29yaXRobVxuICApO1xufVxuXG4vLyBIZWxwZXIgZnVuY3Rpb25zIGZvciB0aGUgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlci5cblxuZnVuY3Rpb24gZGVmYXVsdENvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uKG5hbWU6IHN0cmluZyk6IFR5cGVFcnJvciB7XG4gIHJldHVybiBuZXcgVHlwZUVycm9yKFxuICAgIGBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZS4ke25hbWV9IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyYCk7XG59XG4iLCAiaW1wb3J0IHtcbiAgQ3JlYXRlUmVhZGFibGVCeXRlU3RyZWFtLFxuICBDcmVhdGVSZWFkYWJsZVN0cmVhbSxcbiAgSXNSZWFkYWJsZVN0cmVhbSxcbiAgUmVhZGFibGVCeXRlU3RyZWFtLFxuICBSZWFkYWJsZVN0cmVhbSxcbiAgUmVhZGFibGVTdHJlYW1DYW5jZWwsXG4gIFJlYWRhYmxlU3RyZWFtUmVhZGVyXG59IGZyb20gJy4uL3JlYWRhYmxlLXN0cmVhbSc7XG5pbXBvcnQgeyBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNSZWxlYXNlIH0gZnJvbSAnLi9nZW5lcmljLXJlYWRlcic7XG5pbXBvcnQge1xuICBBY3F1aXJlUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyLFxuICBJc1JlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcixcbiAgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyUmVhZCxcbiAgUmVhZFJlcXVlc3Rcbn0gZnJvbSAnLi9kZWZhdWx0LXJlYWRlcic7XG5pbXBvcnQge1xuICBBY3F1aXJlUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyLFxuICBJc1JlYWRhYmxlU3RyZWFtQllPQlJlYWRlcixcbiAgUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyUmVhZCxcbiAgUmVhZEludG9SZXF1ZXN0XG59IGZyb20gJy4vYnlvYi1yZWFkZXInO1xuaW1wb3J0IGFzc2VydCBmcm9tICcuLi8uLi9zdHViL2Fzc2VydCc7XG5pbXBvcnQgeyBuZXdQcm9taXNlLCBwcm9taXNlUmVzb2x2ZWRXaXRoLCBxdWV1ZU1pY3JvdGFzaywgdXBvblJlamVjdGlvbiB9IGZyb20gJy4uL2hlbHBlcnMvd2ViaWRsJztcbmltcG9ydCB7XG4gIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIsXG4gIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbG9zZSxcbiAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVucXVldWUsXG4gIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvclxufSBmcm9tICcuL2RlZmF1bHQtY29udHJvbGxlcic7XG5pbXBvcnQge1xuICBJc1JlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIsXG4gIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDbG9zZSxcbiAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVucXVldWUsXG4gIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFcnJvcixcbiAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckdldEJZT0JSZXF1ZXN0LFxuICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZCxcbiAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmRXaXRoTmV3Vmlld1xufSBmcm9tICcuL2J5dGUtc3RyZWFtLWNvbnRyb2xsZXInO1xuaW1wb3J0IHsgQ3JlYXRlQXJyYXlGcm9tTGlzdCB9IGZyb20gJy4uL2Fic3RyYWN0LW9wcy9lY21hc2NyaXB0JztcbmltcG9ydCB7IENsb25lQXNVaW50OEFycmF5IH0gZnJvbSAnLi4vYWJzdHJhY3Qtb3BzL21pc2NlbGxhbmVvdXMnO1xuXG5leHBvcnQgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1UZWU8Uj4oc3RyZWFtOiBSZWFkYWJsZVN0cmVhbTxSPixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9uZUZvckJyYW5jaDI6IGJvb2xlYW4pOiBbUmVhZGFibGVTdHJlYW08Uj4sIFJlYWRhYmxlU3RyZWFtPFI+XSB7XG4gIGFzc2VydChJc1JlYWRhYmxlU3RyZWFtKHN0cmVhbSkpO1xuICBhc3NlcnQodHlwZW9mIGNsb25lRm9yQnJhbmNoMiA9PT0gJ2Jvb2xlYW4nKTtcbiAgaWYgKElzUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcihzdHJlYW0uX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcikpIHtcbiAgICByZXR1cm4gUmVhZGFibGVCeXRlU3RyZWFtVGVlKHN0cmVhbSBhcyB1bmtub3duIGFzIFJlYWRhYmxlQnl0ZVN0cmVhbSkgYXNcbiAgICAgIHVua25vd24gYXMgW1JlYWRhYmxlU3RyZWFtPFI+LCBSZWFkYWJsZVN0cmVhbTxSPl07XG4gIH1cbiAgcmV0dXJuIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFRlZShzdHJlYW0sIGNsb25lRm9yQnJhbmNoMik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbURlZmF1bHRUZWU8Uj4oc3RyZWFtOiBSZWFkYWJsZVN0cmVhbTxSPixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvbmVGb3JCcmFuY2gyOiBib29sZWFuKTogW1JlYWRhYmxlU3RyZWFtPFI+LCBSZWFkYWJsZVN0cmVhbTxSPl0ge1xuICBhc3NlcnQoSXNSZWFkYWJsZVN0cmVhbShzdHJlYW0pKTtcbiAgYXNzZXJ0KHR5cGVvZiBjbG9uZUZvckJyYW5jaDIgPT09ICdib29sZWFuJyk7XG5cbiAgY29uc3QgcmVhZGVyID0gQWNxdWlyZVJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcjxSPihzdHJlYW0pO1xuXG4gIGxldCByZWFkaW5nID0gZmFsc2U7XG4gIGxldCByZWFkQWdhaW4gPSBmYWxzZTtcbiAgbGV0IGNhbmNlbGVkMSA9IGZhbHNlO1xuICBsZXQgY2FuY2VsZWQyID0gZmFsc2U7XG4gIGxldCByZWFzb24xOiBhbnk7XG4gIGxldCByZWFzb24yOiBhbnk7XG4gIGxldCBicmFuY2gxOiBSZWFkYWJsZVN0cmVhbTxSPjtcbiAgbGV0IGJyYW5jaDI6IFJlYWRhYmxlU3RyZWFtPFI+O1xuXG4gIGxldCByZXNvbHZlQ2FuY2VsUHJvbWlzZTogKHZhbHVlOiB1bmRlZmluZWQgfCBQcm9taXNlPHVuZGVmaW5lZD4pID0+IHZvaWQ7XG4gIGNvbnN0IGNhbmNlbFByb21pc2UgPSBuZXdQcm9taXNlPHVuZGVmaW5lZD4ocmVzb2x2ZSA9PiB7XG4gICAgcmVzb2x2ZUNhbmNlbFByb21pc2UgPSByZXNvbHZlO1xuICB9KTtcblxuICBmdW5jdGlvbiBwdWxsQWxnb3JpdGhtKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmIChyZWFkaW5nKSB7XG4gICAgICByZWFkQWdhaW4gPSB0cnVlO1xuICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcbiAgICB9XG5cbiAgICByZWFkaW5nID0gdHJ1ZTtcblxuICAgIGNvbnN0IHJlYWRSZXF1ZXN0OiBSZWFkUmVxdWVzdDxSPiA9IHtcbiAgICAgIF9jaHVua1N0ZXBzOiBjaHVuayA9PiB7XG4gICAgICAgIC8vIFRoaXMgbmVlZHMgdG8gYmUgZGVsYXllZCBhIG1pY3JvdGFzayBiZWNhdXNlIGl0IHRha2VzIGF0IGxlYXN0IGEgbWljcm90YXNrIHRvIGRldGVjdCBlcnJvcnMgKHVzaW5nXG4gICAgICAgIC8vIHJlYWRlci5fY2xvc2VkUHJvbWlzZSBiZWxvdyksIGFuZCB3ZSB3YW50IGVycm9ycyBpbiBzdHJlYW0gdG8gZXJyb3IgYm90aCBicmFuY2hlcyBpbW1lZGlhdGVseS4gV2UgY2Fubm90IGxldFxuICAgICAgICAvLyBzdWNjZXNzZnVsIHN5bmNocm9ub3VzbHktYXZhaWxhYmxlIHJlYWRzIGdldCBhaGVhZCBvZiBhc3luY2hyb25vdXNseS1hdmFpbGFibGUgZXJyb3JzLlxuICAgICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAgICAgcmVhZEFnYWluID0gZmFsc2U7XG4gICAgICAgICAgY29uc3QgY2h1bmsxID0gY2h1bms7XG4gICAgICAgICAgY29uc3QgY2h1bmsyID0gY2h1bms7XG5cbiAgICAgICAgICAvLyBUaGVyZSBpcyBubyB3YXkgdG8gYWNjZXNzIHRoZSBjbG9uaW5nIGNvZGUgcmlnaHQgbm93IGluIHRoZSByZWZlcmVuY2UgaW1wbGVtZW50YXRpb24uXG4gICAgICAgICAgLy8gSWYgd2UgYWRkIG9uZSB0aGVuIHdlJ2xsIG5lZWQgYW4gaW1wbGVtZW50YXRpb24gZm9yIHNlcmlhbGl6YWJsZSBvYmplY3RzLlxuICAgICAgICAgIC8vIGlmICghY2FuY2VsZWQyICYmIGNsb25lRm9yQnJhbmNoMikge1xuICAgICAgICAgIC8vICAgY2h1bmsyID0gU3RydWN0dXJlZERlc2VyaWFsaXplKFN0cnVjdHVyZWRTZXJpYWxpemUoY2h1bmsyKSk7XG4gICAgICAgICAgLy8gfVxuXG4gICAgICAgICAgaWYgKCFjYW5jZWxlZDEpIHtcbiAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFbnF1ZXVlKFxuICAgICAgICAgICAgICBicmFuY2gxLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIgYXMgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxSPixcbiAgICAgICAgICAgICAgY2h1bmsxXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWNhbmNlbGVkMikge1xuICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVucXVldWUoXG4gICAgICAgICAgICAgIGJyYW5jaDIuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciBhcyBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyPFI+LFxuICAgICAgICAgICAgICBjaHVuazJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVhZGluZyA9IGZhbHNlO1xuICAgICAgICAgIGlmIChyZWFkQWdhaW4pIHtcbiAgICAgICAgICAgIHB1bGxBbGdvcml0aG0oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIF9jbG9zZVN0ZXBzOiAoKSA9PiB7XG4gICAgICAgIHJlYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgaWYgKCFjYW5jZWxlZDEpIHtcbiAgICAgICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xvc2UoYnJhbmNoMS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyIGFzIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8Uj4pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY2FuY2VsZWQyKSB7XG4gICAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsb3NlKGJyYW5jaDIuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciBhcyBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyPFI+KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghY2FuY2VsZWQxIHx8ICFjYW5jZWxlZDIpIHtcbiAgICAgICAgICByZXNvbHZlQ2FuY2VsUHJvbWlzZSh1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgX2Vycm9yU3RlcHM6ICgpID0+IHtcbiAgICAgICAgcmVhZGluZyA9IGZhbHNlO1xuICAgICAgfVxuICAgIH07XG4gICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyUmVhZChyZWFkZXIsIHJlYWRSZXF1ZXN0KTtcblxuICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG4gIH1cblxuICBmdW5jdGlvbiBjYW5jZWwxQWxnb3JpdGhtKHJlYXNvbjogYW55KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY2FuY2VsZWQxID0gdHJ1ZTtcbiAgICByZWFzb24xID0gcmVhc29uO1xuICAgIGlmIChjYW5jZWxlZDIpIHtcbiAgICAgIGNvbnN0IGNvbXBvc2l0ZVJlYXNvbiA9IENyZWF0ZUFycmF5RnJvbUxpc3QoW3JlYXNvbjEsIHJlYXNvbjJdKTtcbiAgICAgIGNvbnN0IGNhbmNlbFJlc3VsdCA9IFJlYWRhYmxlU3RyZWFtQ2FuY2VsKHN0cmVhbSwgY29tcG9zaXRlUmVhc29uKTtcbiAgICAgIHJlc29sdmVDYW5jZWxQcm9taXNlKGNhbmNlbFJlc3VsdCk7XG4gICAgfVxuICAgIHJldHVybiBjYW5jZWxQcm9taXNlO1xuICB9XG5cbiAgZnVuY3Rpb24gY2FuY2VsMkFsZ29yaXRobShyZWFzb246IGFueSk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNhbmNlbGVkMiA9IHRydWU7XG4gICAgcmVhc29uMiA9IHJlYXNvbjtcbiAgICBpZiAoY2FuY2VsZWQxKSB7XG4gICAgICBjb25zdCBjb21wb3NpdGVSZWFzb24gPSBDcmVhdGVBcnJheUZyb21MaXN0KFtyZWFzb24xLCByZWFzb24yXSk7XG4gICAgICBjb25zdCBjYW5jZWxSZXN1bHQgPSBSZWFkYWJsZVN0cmVhbUNhbmNlbChzdHJlYW0sIGNvbXBvc2l0ZVJlYXNvbik7XG4gICAgICByZXNvbHZlQ2FuY2VsUHJvbWlzZShjYW5jZWxSZXN1bHQpO1xuICAgIH1cbiAgICByZXR1cm4gY2FuY2VsUHJvbWlzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHN0YXJ0QWxnb3JpdGhtKCkge1xuICAgIC8vIGRvIG5vdGhpbmdcbiAgfVxuXG4gIGJyYW5jaDEgPSBDcmVhdGVSZWFkYWJsZVN0cmVhbShzdGFydEFsZ29yaXRobSwgcHVsbEFsZ29yaXRobSwgY2FuY2VsMUFsZ29yaXRobSk7XG4gIGJyYW5jaDIgPSBDcmVhdGVSZWFkYWJsZVN0cmVhbShzdGFydEFsZ29yaXRobSwgcHVsbEFsZ29yaXRobSwgY2FuY2VsMkFsZ29yaXRobSk7XG5cbiAgdXBvblJlamVjdGlvbihyZWFkZXIuX2Nsb3NlZFByb21pc2UsIChyOiBhbnkpID0+IHtcbiAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3IoYnJhbmNoMS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyIGFzIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8Uj4sIHIpO1xuICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcihicmFuY2gyLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIgYXMgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxSPiwgcik7XG4gICAgaWYgKCFjYW5jZWxlZDEgfHwgIWNhbmNlbGVkMikge1xuICAgICAgcmVzb2x2ZUNhbmNlbFByb21pc2UodW5kZWZpbmVkKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBbYnJhbmNoMSwgYnJhbmNoMl07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1UZWUoc3RyZWFtOiBSZWFkYWJsZUJ5dGVTdHJlYW0pOiBbUmVhZGFibGVCeXRlU3RyZWFtLCBSZWFkYWJsZUJ5dGVTdHJlYW1dIHtcbiAgYXNzZXJ0KElzUmVhZGFibGVTdHJlYW0oc3RyZWFtKSk7XG4gIGFzc2VydChJc1JlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIoc3RyZWFtLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIpKTtcblxuICBsZXQgcmVhZGVyOiBSZWFkYWJsZVN0cmVhbVJlYWRlcjxVaW50OEFycmF5PiA9IEFjcXVpcmVSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIoc3RyZWFtKTtcbiAgbGV0IHJlYWRpbmcgPSBmYWxzZTtcbiAgbGV0IHJlYWRBZ2FpbkZvckJyYW5jaDEgPSBmYWxzZTtcbiAgbGV0IHJlYWRBZ2FpbkZvckJyYW5jaDIgPSBmYWxzZTtcbiAgbGV0IGNhbmNlbGVkMSA9IGZhbHNlO1xuICBsZXQgY2FuY2VsZWQyID0gZmFsc2U7XG4gIGxldCByZWFzb24xOiBhbnk7XG4gIGxldCByZWFzb24yOiBhbnk7XG4gIGxldCBicmFuY2gxOiBSZWFkYWJsZUJ5dGVTdHJlYW07XG4gIGxldCBicmFuY2gyOiBSZWFkYWJsZUJ5dGVTdHJlYW07XG5cbiAgbGV0IHJlc29sdmVDYW5jZWxQcm9taXNlOiAodmFsdWU6IHVuZGVmaW5lZCB8IFByb21pc2U8dW5kZWZpbmVkPikgPT4gdm9pZDtcbiAgY29uc3QgY2FuY2VsUHJvbWlzZSA9IG5ld1Byb21pc2U8dm9pZD4ocmVzb2x2ZSA9PiB7XG4gICAgcmVzb2x2ZUNhbmNlbFByb21pc2UgPSByZXNvbHZlO1xuICB9KTtcblxuICBmdW5jdGlvbiBmb3J3YXJkUmVhZGVyRXJyb3IodGhpc1JlYWRlcjogUmVhZGFibGVTdHJlYW1SZWFkZXI8VWludDhBcnJheT4pIHtcbiAgICB1cG9uUmVqZWN0aW9uKHRoaXNSZWFkZXIuX2Nsb3NlZFByb21pc2UsIHIgPT4ge1xuICAgICAgaWYgKHRoaXNSZWFkZXIgIT09IHJlYWRlcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRXJyb3IoYnJhbmNoMS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLCByKTtcbiAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFcnJvcihicmFuY2gyLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIHIpO1xuICAgICAgaWYgKCFjYW5jZWxlZDEgfHwgIWNhbmNlbGVkMikge1xuICAgICAgICByZXNvbHZlQ2FuY2VsUHJvbWlzZSh1bmRlZmluZWQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcHVsbFdpdGhEZWZhdWx0UmVhZGVyKCkge1xuICAgIGlmIChJc1JlYWRhYmxlU3RyZWFtQllPQlJlYWRlcihyZWFkZXIpKSB7XG4gICAgICBhc3NlcnQocmVhZGVyLl9yZWFkSW50b1JlcXVlc3RzLmxlbmd0aCA9PT0gMCk7XG4gICAgICBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNSZWxlYXNlKHJlYWRlcik7XG5cbiAgICAgIHJlYWRlciA9IEFjcXVpcmVSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIoc3RyZWFtKTtcbiAgICAgIGZvcndhcmRSZWFkZXJFcnJvcihyZWFkZXIpO1xuICAgIH1cblxuICAgIGNvbnN0IHJlYWRSZXF1ZXN0OiBSZWFkUmVxdWVzdDxVaW50OEFycmF5PiA9IHtcbiAgICAgIF9jaHVua1N0ZXBzOiBjaHVuayA9PiB7XG4gICAgICAgIC8vIFRoaXMgbmVlZHMgdG8gYmUgZGVsYXllZCBhIG1pY3JvdGFzayBiZWNhdXNlIGl0IHRha2VzIGF0IGxlYXN0IGEgbWljcm90YXNrIHRvIGRldGVjdCBlcnJvcnMgKHVzaW5nXG4gICAgICAgIC8vIHJlYWRlci5fY2xvc2VkUHJvbWlzZSBiZWxvdyksIGFuZCB3ZSB3YW50IGVycm9ycyBpbiBzdHJlYW0gdG8gZXJyb3IgYm90aCBicmFuY2hlcyBpbW1lZGlhdGVseS4gV2UgY2Fubm90IGxldFxuICAgICAgICAvLyBzdWNjZXNzZnVsIHN5bmNocm9ub3VzbHktYXZhaWxhYmxlIHJlYWRzIGdldCBhaGVhZCBvZiBhc3luY2hyb25vdXNseS1hdmFpbGFibGUgZXJyb3JzLlxuICAgICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAgICAgcmVhZEFnYWluRm9yQnJhbmNoMSA9IGZhbHNlO1xuICAgICAgICAgIHJlYWRBZ2FpbkZvckJyYW5jaDIgPSBmYWxzZTtcblxuICAgICAgICAgIGNvbnN0IGNodW5rMSA9IGNodW5rO1xuICAgICAgICAgIGxldCBjaHVuazIgPSBjaHVuaztcbiAgICAgICAgICBpZiAoIWNhbmNlbGVkMSAmJiAhY2FuY2VsZWQyKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjaHVuazIgPSBDbG9uZUFzVWludDhBcnJheShjaHVuayk7XG4gICAgICAgICAgICB9IGNhdGNoIChjbG9uZUUpIHtcbiAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVycm9yKGJyYW5jaDEuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwgY2xvbmVFKTtcbiAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVycm9yKGJyYW5jaDIuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwgY2xvbmVFKTtcbiAgICAgICAgICAgICAgcmVzb2x2ZUNhbmNlbFByb21pc2UoUmVhZGFibGVTdHJlYW1DYW5jZWwoc3RyZWFtLCBjbG9uZUUpKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghY2FuY2VsZWQxKSB7XG4gICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRW5xdWV1ZShicmFuY2gxLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIGNodW5rMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghY2FuY2VsZWQyKSB7XG4gICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRW5xdWV1ZShicmFuY2gyLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIGNodW5rMik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVhZGluZyA9IGZhbHNlO1xuICAgICAgICAgIGlmIChyZWFkQWdhaW5Gb3JCcmFuY2gxKSB7XG4gICAgICAgICAgICBwdWxsMUFsZ29yaXRobSgpO1xuICAgICAgICAgIH0gZWxzZSBpZiAocmVhZEFnYWluRm9yQnJhbmNoMikge1xuICAgICAgICAgICAgcHVsbDJBbGdvcml0aG0oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIF9jbG9zZVN0ZXBzOiAoKSA9PiB7XG4gICAgICAgIHJlYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgaWYgKCFjYW5jZWxlZDEpIHtcbiAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2xvc2UoYnJhbmNoMS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNhbmNlbGVkMikge1xuICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDbG9zZShicmFuY2gyLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChicmFuY2gxLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kKGJyYW5jaDEuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJyYW5jaDIuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmQoYnJhbmNoMi5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNhbmNlbGVkMSB8fCAhY2FuY2VsZWQyKSB7XG4gICAgICAgICAgcmVzb2x2ZUNhbmNlbFByb21pc2UodW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIF9lcnJvclN0ZXBzOiAoKSA9PiB7XG4gICAgICAgIHJlYWRpbmcgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlclJlYWQocmVhZGVyLCByZWFkUmVxdWVzdCk7XG4gIH1cblxuICBmdW5jdGlvbiBwdWxsV2l0aEJZT0JSZWFkZXIodmlldzogQXJyYXlCdWZmZXJWaWV3LCBmb3JCcmFuY2gyOiBib29sZWFuKSB7XG4gICAgaWYgKElzUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyPFVpbnQ4QXJyYXk+KHJlYWRlcikpIHtcbiAgICAgIGFzc2VydChyZWFkZXIuX3JlYWRSZXF1ZXN0cy5sZW5ndGggPT09IDApO1xuICAgICAgUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljUmVsZWFzZShyZWFkZXIpO1xuXG4gICAgICByZWFkZXIgPSBBY3F1aXJlUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyKHN0cmVhbSk7XG4gICAgICBmb3J3YXJkUmVhZGVyRXJyb3IocmVhZGVyKTtcbiAgICB9XG5cbiAgICBjb25zdCBieW9iQnJhbmNoID0gZm9yQnJhbmNoMiA/IGJyYW5jaDIgOiBicmFuY2gxO1xuICAgIGNvbnN0IG90aGVyQnJhbmNoID0gZm9yQnJhbmNoMiA/IGJyYW5jaDEgOiBicmFuY2gyO1xuXG4gICAgY29uc3QgcmVhZEludG9SZXF1ZXN0OiBSZWFkSW50b1JlcXVlc3Q8QXJyYXlCdWZmZXJWaWV3PiA9IHtcbiAgICAgIF9jaHVua1N0ZXBzOiBjaHVuayA9PiB7XG4gICAgICAgIC8vIFRoaXMgbmVlZHMgdG8gYmUgZGVsYXllZCBhIG1pY3JvdGFzayBiZWNhdXNlIGl0IHRha2VzIGF0IGxlYXN0IGEgbWljcm90YXNrIHRvIGRldGVjdCBlcnJvcnMgKHVzaW5nXG4gICAgICAgIC8vIHJlYWRlci5fY2xvc2VkUHJvbWlzZSBiZWxvdyksIGFuZCB3ZSB3YW50IGVycm9ycyBpbiBzdHJlYW0gdG8gZXJyb3IgYm90aCBicmFuY2hlcyBpbW1lZGlhdGVseS4gV2UgY2Fubm90IGxldFxuICAgICAgICAvLyBzdWNjZXNzZnVsIHN5bmNocm9ub3VzbHktYXZhaWxhYmxlIHJlYWRzIGdldCBhaGVhZCBvZiBhc3luY2hyb25vdXNseS1hdmFpbGFibGUgZXJyb3JzLlxuICAgICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAgICAgcmVhZEFnYWluRm9yQnJhbmNoMSA9IGZhbHNlO1xuICAgICAgICAgIHJlYWRBZ2FpbkZvckJyYW5jaDIgPSBmYWxzZTtcblxuICAgICAgICAgIGNvbnN0IGJ5b2JDYW5jZWxlZCA9IGZvckJyYW5jaDIgPyBjYW5jZWxlZDIgOiBjYW5jZWxlZDE7XG4gICAgICAgICAgY29uc3Qgb3RoZXJDYW5jZWxlZCA9IGZvckJyYW5jaDIgPyBjYW5jZWxlZDEgOiBjYW5jZWxlZDI7XG5cbiAgICAgICAgICBpZiAoIW90aGVyQ2FuY2VsZWQpIHtcbiAgICAgICAgICAgIGxldCBjbG9uZWRDaHVuaztcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNsb25lZENodW5rID0gQ2xvbmVBc1VpbnQ4QXJyYXkoY2h1bmspO1xuICAgICAgICAgICAgfSBjYXRjaCAoY2xvbmVFKSB7XG4gICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFcnJvcihieW9iQnJhbmNoLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIGNsb25lRSk7XG4gICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFcnJvcihvdGhlckJyYW5jaC5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLCBjbG9uZUUpO1xuICAgICAgICAgICAgICByZXNvbHZlQ2FuY2VsUHJvbWlzZShSZWFkYWJsZVN0cmVhbUNhbmNlbChzdHJlYW0sIGNsb25lRSkpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWJ5b2JDYW5jZWxlZCkge1xuICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZFdpdGhOZXdWaWV3KGJ5b2JCcmFuY2guX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwgY2h1bmspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVucXVldWUob3RoZXJCcmFuY2guX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwgY2xvbmVkQ2h1bmspO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIWJ5b2JDYW5jZWxlZCkge1xuICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmRXaXRoTmV3VmlldyhieW9iQnJhbmNoLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIGNodW5rKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZWFkaW5nID0gZmFsc2U7XG4gICAgICAgICAgaWYgKHJlYWRBZ2FpbkZvckJyYW5jaDEpIHtcbiAgICAgICAgICAgIHB1bGwxQWxnb3JpdGhtKCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChyZWFkQWdhaW5Gb3JCcmFuY2gyKSB7XG4gICAgICAgICAgICBwdWxsMkFsZ29yaXRobSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgX2Nsb3NlU3RlcHM6IGNodW5rID0+IHtcbiAgICAgICAgcmVhZGluZyA9IGZhbHNlO1xuXG4gICAgICAgIGNvbnN0IGJ5b2JDYW5jZWxlZCA9IGZvckJyYW5jaDIgPyBjYW5jZWxlZDIgOiBjYW5jZWxlZDE7XG4gICAgICAgIGNvbnN0IG90aGVyQ2FuY2VsZWQgPSBmb3JCcmFuY2gyID8gY2FuY2VsZWQxIDogY2FuY2VsZWQyO1xuXG4gICAgICAgIGlmICghYnlvYkNhbmNlbGVkKSB7XG4gICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNsb3NlKGJ5b2JCcmFuY2guX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFvdGhlckNhbmNlbGVkKSB7XG4gICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNsb3NlKG90aGVyQnJhbmNoLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNodW5rICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBhc3NlcnQoY2h1bmsuYnl0ZUxlbmd0aCA9PT0gMCk7XG5cbiAgICAgICAgICBpZiAoIWJ5b2JDYW5jZWxlZCkge1xuICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmRXaXRoTmV3VmlldyhieW9iQnJhbmNoLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIGNodW5rKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFvdGhlckNhbmNlbGVkICYmIG90aGVyQnJhbmNoLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmQob3RoZXJCcmFuY2guX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwgMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFieW9iQ2FuY2VsZWQgfHwgIW90aGVyQ2FuY2VsZWQpIHtcbiAgICAgICAgICByZXNvbHZlQ2FuY2VsUHJvbWlzZSh1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgX2Vycm9yU3RlcHM6ICgpID0+IHtcbiAgICAgICAgcmVhZGluZyA9IGZhbHNlO1xuICAgICAgfVxuICAgIH07XG4gICAgUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyUmVhZChyZWFkZXIsIHZpZXcsIHJlYWRJbnRvUmVxdWVzdCk7XG4gIH1cblxuICBmdW5jdGlvbiBwdWxsMUFsZ29yaXRobSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAocmVhZGluZykge1xuICAgICAgcmVhZEFnYWluRm9yQnJhbmNoMSA9IHRydWU7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuICAgIH1cblxuICAgIHJlYWRpbmcgPSB0cnVlO1xuXG4gICAgY29uc3QgYnlvYlJlcXVlc3QgPSBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyR2V0QllPQlJlcXVlc3QoYnJhbmNoMS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyKTtcbiAgICBpZiAoYnlvYlJlcXVlc3QgPT09IG51bGwpIHtcbiAgICAgIHB1bGxXaXRoRGVmYXVsdFJlYWRlcigpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwdWxsV2l0aEJZT0JSZWFkZXIoYnlvYlJlcXVlc3QuX3ZpZXchLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHB1bGwyQWxnb3JpdGhtKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmIChyZWFkaW5nKSB7XG4gICAgICByZWFkQWdhaW5Gb3JCcmFuY2gyID0gdHJ1ZTtcbiAgICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG4gICAgfVxuXG4gICAgcmVhZGluZyA9IHRydWU7XG5cbiAgICBjb25zdCBieW9iUmVxdWVzdCA9IFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJHZXRCWU9CUmVxdWVzdChicmFuY2gyLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIpO1xuICAgIGlmIChieW9iUmVxdWVzdCA9PT0gbnVsbCkge1xuICAgICAgcHVsbFdpdGhEZWZhdWx0UmVhZGVyKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHB1bGxXaXRoQllPQlJlYWRlcihieW9iUmVxdWVzdC5fdmlldyEsIHRydWUpO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG4gIH1cblxuICBmdW5jdGlvbiBjYW5jZWwxQWxnb3JpdGhtKHJlYXNvbjogYW55KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY2FuY2VsZWQxID0gdHJ1ZTtcbiAgICByZWFzb24xID0gcmVhc29uO1xuICAgIGlmIChjYW5jZWxlZDIpIHtcbiAgICAgIGNvbnN0IGNvbXBvc2l0ZVJlYXNvbiA9IENyZWF0ZUFycmF5RnJvbUxpc3QoW3JlYXNvbjEsIHJlYXNvbjJdKTtcbiAgICAgIGNvbnN0IGNhbmNlbFJlc3VsdCA9IFJlYWRhYmxlU3RyZWFtQ2FuY2VsKHN0cmVhbSwgY29tcG9zaXRlUmVhc29uKTtcbiAgICAgIHJlc29sdmVDYW5jZWxQcm9taXNlKGNhbmNlbFJlc3VsdCk7XG4gICAgfVxuICAgIHJldHVybiBjYW5jZWxQcm9taXNlO1xuICB9XG5cbiAgZnVuY3Rpb24gY2FuY2VsMkFsZ29yaXRobShyZWFzb246IGFueSk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNhbmNlbGVkMiA9IHRydWU7XG4gICAgcmVhc29uMiA9IHJlYXNvbjtcbiAgICBpZiAoY2FuY2VsZWQxKSB7XG4gICAgICBjb25zdCBjb21wb3NpdGVSZWFzb24gPSBDcmVhdGVBcnJheUZyb21MaXN0KFtyZWFzb24xLCByZWFzb24yXSk7XG4gICAgICBjb25zdCBjYW5jZWxSZXN1bHQgPSBSZWFkYWJsZVN0cmVhbUNhbmNlbChzdHJlYW0sIGNvbXBvc2l0ZVJlYXNvbik7XG4gICAgICByZXNvbHZlQ2FuY2VsUHJvbWlzZShjYW5jZWxSZXN1bHQpO1xuICAgIH1cbiAgICByZXR1cm4gY2FuY2VsUHJvbWlzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHN0YXJ0QWxnb3JpdGhtKCk6IHZvaWQge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGJyYW5jaDEgPSBDcmVhdGVSZWFkYWJsZUJ5dGVTdHJlYW0oc3RhcnRBbGdvcml0aG0sIHB1bGwxQWxnb3JpdGhtLCBjYW5jZWwxQWxnb3JpdGhtKTtcbiAgYnJhbmNoMiA9IENyZWF0ZVJlYWRhYmxlQnl0ZVN0cmVhbShzdGFydEFsZ29yaXRobSwgcHVsbDJBbGdvcml0aG0sIGNhbmNlbDJBbGdvcml0aG0pO1xuXG4gIGZvcndhcmRSZWFkZXJFcnJvcihyZWFkZXIpO1xuXG4gIHJldHVybiBbYnJhbmNoMSwgYnJhbmNoMl07XG59XG4iLCAiaW1wb3J0IHsgYXNzZXJ0RGljdGlvbmFyeSwgYXNzZXJ0RnVuY3Rpb24sIGNvbnZlcnRVbnNpZ25lZExvbmdMb25nV2l0aEVuZm9yY2VSYW5nZSB9IGZyb20gJy4vYmFzaWMnO1xuaW1wb3J0IHtcbiAgUmVhZGFibGVTdHJlYW1Db250cm9sbGVyLFxuICBVbmRlcmx5aW5nQnl0ZVNvdXJjZSxcbiAgVW5kZXJseWluZ0RlZmF1bHRPckJ5dGVTb3VyY2UsXG4gIFVuZGVybHlpbmdEZWZhdWx0T3JCeXRlU291cmNlUHVsbENhbGxiYWNrLFxuICBVbmRlcmx5aW5nRGVmYXVsdE9yQnl0ZVNvdXJjZVN0YXJ0Q2FsbGJhY2ssXG4gIFVuZGVybHlpbmdTb3VyY2UsXG4gIFVuZGVybHlpbmdTb3VyY2VDYW5jZWxDYWxsYmFjayxcbiAgVmFsaWRhdGVkVW5kZXJseWluZ0RlZmF1bHRPckJ5dGVTb3VyY2Vcbn0gZnJvbSAnLi4vcmVhZGFibGUtc3RyZWFtL3VuZGVybHlpbmctc291cmNlJztcbmltcG9ydCB7IHByb21pc2VDYWxsLCByZWZsZWN0Q2FsbCB9IGZyb20gJy4uL2hlbHBlcnMvd2ViaWRsJztcblxuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRVbmRlcmx5aW5nRGVmYXVsdE9yQnl0ZVNvdXJjZTxSPihcbiAgc291cmNlOiBVbmRlcmx5aW5nU291cmNlPFI+IHwgVW5kZXJseWluZ0J5dGVTb3VyY2UgfCBudWxsLFxuICBjb250ZXh0OiBzdHJpbmdcbik6IFZhbGlkYXRlZFVuZGVybHlpbmdEZWZhdWx0T3JCeXRlU291cmNlPFI+IHtcbiAgYXNzZXJ0RGljdGlvbmFyeShzb3VyY2UsIGNvbnRleHQpO1xuICBjb25zdCBvcmlnaW5hbCA9IHNvdXJjZSBhcyAoVW5kZXJseWluZ0RlZmF1bHRPckJ5dGVTb3VyY2U8Uj4gfCBudWxsKTtcbiAgY29uc3QgYXV0b0FsbG9jYXRlQ2h1bmtTaXplID0gb3JpZ2luYWw/LmF1dG9BbGxvY2F0ZUNodW5rU2l6ZTtcbiAgY29uc3QgY2FuY2VsID0gb3JpZ2luYWw/LmNhbmNlbDtcbiAgY29uc3QgcHVsbCA9IG9yaWdpbmFsPy5wdWxsO1xuICBjb25zdCBzdGFydCA9IG9yaWdpbmFsPy5zdGFydDtcbiAgY29uc3QgdHlwZSA9IG9yaWdpbmFsPy50eXBlO1xuICByZXR1cm4ge1xuICAgIGF1dG9BbGxvY2F0ZUNodW5rU2l6ZTogYXV0b0FsbG9jYXRlQ2h1bmtTaXplID09PSB1bmRlZmluZWQgP1xuICAgICAgdW5kZWZpbmVkIDpcbiAgICAgIGNvbnZlcnRVbnNpZ25lZExvbmdMb25nV2l0aEVuZm9yY2VSYW5nZShcbiAgICAgICAgYXV0b0FsbG9jYXRlQ2h1bmtTaXplLFxuICAgICAgICBgJHtjb250ZXh0fSBoYXMgbWVtYmVyICdhdXRvQWxsb2NhdGVDaHVua1NpemUnIHRoYXRgXG4gICAgICApLFxuICAgIGNhbmNlbDogY2FuY2VsID09PSB1bmRlZmluZWQgP1xuICAgICAgdW5kZWZpbmVkIDpcbiAgICAgIGNvbnZlcnRVbmRlcmx5aW5nU291cmNlQ2FuY2VsQ2FsbGJhY2soY2FuY2VsLCBvcmlnaW5hbCEsIGAke2NvbnRleHR9IGhhcyBtZW1iZXIgJ2NhbmNlbCcgdGhhdGApLFxuICAgIHB1bGw6IHB1bGwgPT09IHVuZGVmaW5lZCA/XG4gICAgICB1bmRlZmluZWQgOlxuICAgICAgY29udmVydFVuZGVybHlpbmdTb3VyY2VQdWxsQ2FsbGJhY2socHVsbCwgb3JpZ2luYWwhLCBgJHtjb250ZXh0fSBoYXMgbWVtYmVyICdwdWxsJyB0aGF0YCksXG4gICAgc3RhcnQ6IHN0YXJ0ID09PSB1bmRlZmluZWQgP1xuICAgICAgdW5kZWZpbmVkIDpcbiAgICAgIGNvbnZlcnRVbmRlcmx5aW5nU291cmNlU3RhcnRDYWxsYmFjayhzdGFydCwgb3JpZ2luYWwhLCBgJHtjb250ZXh0fSBoYXMgbWVtYmVyICdzdGFydCcgdGhhdGApLFxuICAgIHR5cGU6IHR5cGUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IGNvbnZlcnRSZWFkYWJsZVN0cmVhbVR5cGUodHlwZSwgYCR7Y29udGV4dH0gaGFzIG1lbWJlciAndHlwZScgdGhhdGApXG4gIH07XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRVbmRlcmx5aW5nU291cmNlQ2FuY2VsQ2FsbGJhY2soXG4gIGZuOiBVbmRlcmx5aW5nU291cmNlQ2FuY2VsQ2FsbGJhY2ssXG4gIG9yaWdpbmFsOiBVbmRlcmx5aW5nRGVmYXVsdE9yQnl0ZVNvdXJjZSxcbiAgY29udGV4dDogc3RyaW5nXG4pOiAocmVhc29uOiBhbnkpID0+IFByb21pc2U8dm9pZD4ge1xuICBhc3NlcnRGdW5jdGlvbihmbiwgY29udGV4dCk7XG4gIHJldHVybiAocmVhc29uOiBhbnkpID0+IHByb21pc2VDYWxsKGZuLCBvcmlnaW5hbCwgW3JlYXNvbl0pO1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0VW5kZXJseWluZ1NvdXJjZVB1bGxDYWxsYmFjazxSPihcbiAgZm46IFVuZGVybHlpbmdEZWZhdWx0T3JCeXRlU291cmNlUHVsbENhbGxiYWNrPFI+LFxuICBvcmlnaW5hbDogVW5kZXJseWluZ0RlZmF1bHRPckJ5dGVTb3VyY2U8Uj4sXG4gIGNvbnRleHQ6IHN0cmluZ1xuKTogKGNvbnRyb2xsZXI6IFJlYWRhYmxlU3RyZWFtQ29udHJvbGxlcjxSPikgPT4gUHJvbWlzZTx2b2lkPiB7XG4gIGFzc2VydEZ1bmN0aW9uKGZuLCBjb250ZXh0KTtcbiAgcmV0dXJuIChjb250cm9sbGVyOiBSZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXI8Uj4pID0+IHByb21pc2VDYWxsKGZuLCBvcmlnaW5hbCwgW2NvbnRyb2xsZXJdKTtcbn1cblxuZnVuY3Rpb24gY29udmVydFVuZGVybHlpbmdTb3VyY2VTdGFydENhbGxiYWNrPFI+KFxuICBmbjogVW5kZXJseWluZ0RlZmF1bHRPckJ5dGVTb3VyY2VTdGFydENhbGxiYWNrPFI+LFxuICBvcmlnaW5hbDogVW5kZXJseWluZ0RlZmF1bHRPckJ5dGVTb3VyY2U8Uj4sXG4gIGNvbnRleHQ6IHN0cmluZ1xuKTogVW5kZXJseWluZ0RlZmF1bHRPckJ5dGVTb3VyY2VTdGFydENhbGxiYWNrPFI+IHtcbiAgYXNzZXJ0RnVuY3Rpb24oZm4sIGNvbnRleHQpO1xuICByZXR1cm4gKGNvbnRyb2xsZXI6IFJlYWRhYmxlU3RyZWFtQ29udHJvbGxlcjxSPikgPT4gcmVmbGVjdENhbGwoZm4sIG9yaWdpbmFsLCBbY29udHJvbGxlcl0pO1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0UmVhZGFibGVTdHJlYW1UeXBlKHR5cGU6IHN0cmluZywgY29udGV4dDogc3RyaW5nKTogJ2J5dGVzJyB7XG4gIHR5cGUgPSBgJHt0eXBlfWA7XG4gIGlmICh0eXBlICE9PSAnYnl0ZXMnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtjb250ZXh0fSAnJHt0eXBlfScgaXMgbm90IGEgdmFsaWQgZW51bWVyYXRpb24gdmFsdWUgZm9yIFJlYWRhYmxlU3RyZWFtVHlwZWApO1xuICB9XG4gIHJldHVybiB0eXBlO1xufVxuIiwgImltcG9ydCB7IGFzc2VydERpY3Rpb25hcnkgfSBmcm9tICcuL2Jhc2ljJztcbmltcG9ydCB7IFJlYWRhYmxlU3RyZWFtR2V0UmVhZGVyT3B0aW9ucyB9IGZyb20gJy4uL3JlYWRhYmxlLXN0cmVhbS9yZWFkZXItb3B0aW9ucyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0UmVhZGVyT3B0aW9ucyhvcHRpb25zOiBSZWFkYWJsZVN0cmVhbUdldFJlYWRlck9wdGlvbnMgfCBudWxsIHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IHN0cmluZyk6IFJlYWRhYmxlU3RyZWFtR2V0UmVhZGVyT3B0aW9ucyB7XG4gIGFzc2VydERpY3Rpb25hcnkob3B0aW9ucywgY29udGV4dCk7XG4gIGNvbnN0IG1vZGUgPSBvcHRpb25zPy5tb2RlO1xuICByZXR1cm4ge1xuICAgIG1vZGU6IG1vZGUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IGNvbnZlcnRSZWFkYWJsZVN0cmVhbVJlYWRlck1vZGUobW9kZSwgYCR7Y29udGV4dH0gaGFzIG1lbWJlciAnbW9kZScgdGhhdGApXG4gIH07XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRSZWFkYWJsZVN0cmVhbVJlYWRlck1vZGUobW9kZTogc3RyaW5nLCBjb250ZXh0OiBzdHJpbmcpOiAnYnlvYicge1xuICBtb2RlID0gYCR7bW9kZX1gO1xuICBpZiAobW9kZSAhPT0gJ2J5b2InKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtjb250ZXh0fSAnJHttb2RlfScgaXMgbm90IGEgdmFsaWQgZW51bWVyYXRpb24gdmFsdWUgZm9yIFJlYWRhYmxlU3RyZWFtUmVhZGVyTW9kZWApO1xuICB9XG4gIHJldHVybiBtb2RlO1xufVxuIiwgImltcG9ydCB7IGFzc2VydERpY3Rpb25hcnkgfSBmcm9tICcuL2Jhc2ljJztcbmltcG9ydCB7XG4gIFJlYWRhYmxlU3RyZWFtSXRlcmF0b3JPcHRpb25zLFxuICBWYWxpZGF0ZWRSZWFkYWJsZVN0cmVhbUl0ZXJhdG9yT3B0aW9uc1xufSBmcm9tICcuLi9yZWFkYWJsZS1zdHJlYW0vaXRlcmF0b3Itb3B0aW9ucyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0SXRlcmF0b3JPcHRpb25zKG9wdGlvbnM6IFJlYWRhYmxlU3RyZWFtSXRlcmF0b3JPcHRpb25zIHwgbnVsbCB8IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IHN0cmluZyk6IFZhbGlkYXRlZFJlYWRhYmxlU3RyZWFtSXRlcmF0b3JPcHRpb25zIHtcbiAgYXNzZXJ0RGljdGlvbmFyeShvcHRpb25zLCBjb250ZXh0KTtcbiAgY29uc3QgcHJldmVudENhbmNlbCA9IG9wdGlvbnM/LnByZXZlbnRDYW5jZWw7XG4gIHJldHVybiB7IHByZXZlbnRDYW5jZWw6IEJvb2xlYW4ocHJldmVudENhbmNlbCkgfTtcbn1cbiIsICJpbXBvcnQgeyBhc3NlcnREaWN0aW9uYXJ5IH0gZnJvbSAnLi9iYXNpYyc7XG5pbXBvcnQgeyBTdHJlYW1QaXBlT3B0aW9ucywgVmFsaWRhdGVkU3RyZWFtUGlwZU9wdGlvbnMgfSBmcm9tICcuLi9yZWFkYWJsZS1zdHJlYW0vcGlwZS1vcHRpb25zJztcbmltcG9ydCB7IEFib3J0U2lnbmFsLCBpc0Fib3J0U2lnbmFsIH0gZnJvbSAnLi4vYWJvcnQtc2lnbmFsJztcblxuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRQaXBlT3B0aW9ucyhvcHRpb25zOiBTdHJlYW1QaXBlT3B0aW9ucyB8IG51bGwgfCB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IHN0cmluZyk6IFZhbGlkYXRlZFN0cmVhbVBpcGVPcHRpb25zIHtcbiAgYXNzZXJ0RGljdGlvbmFyeShvcHRpb25zLCBjb250ZXh0KTtcbiAgY29uc3QgcHJldmVudEFib3J0ID0gb3B0aW9ucz8ucHJldmVudEFib3J0O1xuICBjb25zdCBwcmV2ZW50Q2FuY2VsID0gb3B0aW9ucz8ucHJldmVudENhbmNlbDtcbiAgY29uc3QgcHJldmVudENsb3NlID0gb3B0aW9ucz8ucHJldmVudENsb3NlO1xuICBjb25zdCBzaWduYWwgPSBvcHRpb25zPy5zaWduYWw7XG4gIGlmIChzaWduYWwgIT09IHVuZGVmaW5lZCkge1xuICAgIGFzc2VydEFib3J0U2lnbmFsKHNpZ25hbCwgYCR7Y29udGV4dH0gaGFzIG1lbWJlciAnc2lnbmFsJyB0aGF0YCk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBwcmV2ZW50QWJvcnQ6IEJvb2xlYW4ocHJldmVudEFib3J0KSxcbiAgICBwcmV2ZW50Q2FuY2VsOiBCb29sZWFuKHByZXZlbnRDYW5jZWwpLFxuICAgIHByZXZlbnRDbG9zZTogQm9vbGVhbihwcmV2ZW50Q2xvc2UpLFxuICAgIHNpZ25hbFxuICB9O1xufVxuXG5mdW5jdGlvbiBhc3NlcnRBYm9ydFNpZ25hbChzaWduYWw6IHVua25vd24sIGNvbnRleHQ6IHN0cmluZyk6IGFzc2VydHMgc2lnbmFsIGlzIEFib3J0U2lnbmFsIHtcbiAgaWYgKCFpc0Fib3J0U2lnbmFsKHNpZ25hbCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke2NvbnRleHR9IGlzIG5vdCBhbiBBYm9ydFNpZ25hbC5gKTtcbiAgfVxufVxuIiwgImltcG9ydCB7IGFzc2VydERpY3Rpb25hcnksIGFzc2VydFJlcXVpcmVkRmllbGQgfSBmcm9tICcuL2Jhc2ljJztcbmltcG9ydCB7IFJlYWRhYmxlU3RyZWFtIH0gZnJvbSAnLi4vcmVhZGFibGUtc3RyZWFtJztcbmltcG9ydCB7IFdyaXRhYmxlU3RyZWFtIH0gZnJvbSAnLi4vd3JpdGFibGUtc3RyZWFtJztcbmltcG9ydCB7IGFzc2VydFJlYWRhYmxlU3RyZWFtIH0gZnJvbSAnLi9yZWFkYWJsZS1zdHJlYW0nO1xuaW1wb3J0IHsgYXNzZXJ0V3JpdGFibGVTdHJlYW0gfSBmcm9tICcuL3dyaXRhYmxlLXN0cmVhbSc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0UmVhZGFibGVXcml0YWJsZVBhaXI8UlMgZXh0ZW5kcyBSZWFkYWJsZVN0cmVhbSwgV1MgZXh0ZW5kcyBXcml0YWJsZVN0cmVhbT4oXG4gIHBhaXI6IHsgcmVhZGFibGU6IFJTOyB3cml0YWJsZTogV1MgfSB8IG51bGwgfCB1bmRlZmluZWQsXG4gIGNvbnRleHQ6IHN0cmluZ1xuKTogeyByZWFkYWJsZTogUlM7IHdyaXRhYmxlOiBXUyB9IHtcbiAgYXNzZXJ0RGljdGlvbmFyeShwYWlyLCBjb250ZXh0KTtcblxuICBjb25zdCByZWFkYWJsZSA9IHBhaXI/LnJlYWRhYmxlO1xuICBhc3NlcnRSZXF1aXJlZEZpZWxkKHJlYWRhYmxlLCAncmVhZGFibGUnLCAnUmVhZGFibGVXcml0YWJsZVBhaXInKTtcbiAgYXNzZXJ0UmVhZGFibGVTdHJlYW0ocmVhZGFibGUsIGAke2NvbnRleHR9IGhhcyBtZW1iZXIgJ3JlYWRhYmxlJyB0aGF0YCk7XG5cbiAgY29uc3Qgd3JpdGFibGUgPSBwYWlyPy53cml0YWJsZTtcbiAgYXNzZXJ0UmVxdWlyZWRGaWVsZCh3cml0YWJsZSwgJ3dyaXRhYmxlJywgJ1JlYWRhYmxlV3JpdGFibGVQYWlyJyk7XG4gIGFzc2VydFdyaXRhYmxlU3RyZWFtKHdyaXRhYmxlLCBgJHtjb250ZXh0fSBoYXMgbWVtYmVyICd3cml0YWJsZScgdGhhdGApO1xuXG4gIHJldHVybiB7IHJlYWRhYmxlLCB3cml0YWJsZSB9O1xufVxuIiwgImltcG9ydCBhc3NlcnQgZnJvbSAnLi4vc3R1Yi9hc3NlcnQnO1xuaW1wb3J0IHtcbiAgcHJvbWlzZVJlamVjdGVkV2l0aCxcbiAgcHJvbWlzZVJlc29sdmVkV2l0aCxcbiAgc2V0UHJvbWlzZUlzSGFuZGxlZFRvVHJ1ZSxcbiAgdHJhbnNmb3JtUHJvbWlzZVdpdGhcbn0gZnJvbSAnLi9oZWxwZXJzL3dlYmlkbCc7XG5pbXBvcnQgeyBRdWV1aW5nU3RyYXRlZ3ksIFF1ZXVpbmdTdHJhdGVneVNpemVDYWxsYmFjayB9IGZyb20gJy4vcXVldWluZy1zdHJhdGVneSc7XG5pbXBvcnQgeyBBY3F1aXJlUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yLCBSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IgfSBmcm9tICcuL3JlYWRhYmxlLXN0cmVhbS9hc3luYy1pdGVyYXRvcic7XG5pbXBvcnQgeyBkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZVJlamVjdCwgZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VSZXNvbHZlIH0gZnJvbSAnLi9yZWFkYWJsZS1zdHJlYW0vZ2VuZXJpYy1yZWFkZXInO1xuaW1wb3J0IHtcbiAgQWNxdWlyZVJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcixcbiAgSXNSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIsXG4gIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcixcbiAgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZFJlc3VsdFxufSBmcm9tICcuL3JlYWRhYmxlLXN0cmVhbS9kZWZhdWx0LXJlYWRlcic7XG5pbXBvcnQge1xuICBBY3F1aXJlUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyLFxuICBJc1JlYWRhYmxlU3RyZWFtQllPQlJlYWRlcixcbiAgUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyLFxuICBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkUmVzdWx0XG59IGZyb20gJy4vcmVhZGFibGUtc3RyZWFtL2J5b2ItcmVhZGVyJztcbmltcG9ydCB7IFJlYWRhYmxlU3RyZWFtUGlwZVRvIH0gZnJvbSAnLi9yZWFkYWJsZS1zdHJlYW0vcGlwZSc7XG5pbXBvcnQgeyBSZWFkYWJsZVN0cmVhbVRlZSB9IGZyb20gJy4vcmVhZGFibGUtc3RyZWFtL3RlZSc7XG5pbXBvcnQgeyBJc1dyaXRhYmxlU3RyZWFtLCBJc1dyaXRhYmxlU3RyZWFtTG9ja2VkLCBXcml0YWJsZVN0cmVhbSB9IGZyb20gJy4vd3JpdGFibGUtc3RyZWFtJztcbmltcG9ydCB7IFNpbXBsZVF1ZXVlIH0gZnJvbSAnLi9zaW1wbGUtcXVldWUnO1xuaW1wb3J0IHtcbiAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcixcbiAgUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdCxcbiAgU2V0VXBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyLFxuICBTZXRVcFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJGcm9tVW5kZXJseWluZ1NvdXJjZVxufSBmcm9tICcuL3JlYWRhYmxlLXN0cmVhbS9ieXRlLXN0cmVhbS1jb250cm9sbGVyJztcbmltcG9ydCB7XG4gIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIsXG4gIFNldFVwUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcixcbiAgU2V0VXBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRnJvbVVuZGVybHlpbmdTb3VyY2Vcbn0gZnJvbSAnLi9yZWFkYWJsZS1zdHJlYW0vZGVmYXVsdC1jb250cm9sbGVyJztcbmltcG9ydCB7XG4gIFVuZGVybHlpbmdCeXRlU291cmNlLFxuICBVbmRlcmx5aW5nQnl0ZVNvdXJjZVB1bGxDYWxsYmFjayxcbiAgVW5kZXJseWluZ0J5dGVTb3VyY2VTdGFydENhbGxiYWNrLFxuICBVbmRlcmx5aW5nU291cmNlLFxuICBVbmRlcmx5aW5nU291cmNlQ2FuY2VsQ2FsbGJhY2ssXG4gIFVuZGVybHlpbmdTb3VyY2VQdWxsQ2FsbGJhY2ssXG4gIFVuZGVybHlpbmdTb3VyY2VTdGFydENhbGxiYWNrXG59IGZyb20gJy4vcmVhZGFibGUtc3RyZWFtL3VuZGVybHlpbmctc291cmNlJztcbmltcG9ydCB7IG5vb3AgfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgeyB0eXBlSXNPYmplY3QgfSBmcm9tICcuL2hlbHBlcnMvbWlzY2VsbGFuZW91cyc7XG5pbXBvcnQgeyBDcmVhdGVBcnJheUZyb21MaXN0IH0gZnJvbSAnLi9hYnN0cmFjdC1vcHMvZWNtYXNjcmlwdCc7XG5pbXBvcnQgeyBDYW5jZWxTdGVwcyB9IGZyb20gJy4vYWJzdHJhY3Qtb3BzL2ludGVybmFsLW1ldGhvZHMnO1xuaW1wb3J0IHsgSXNOb25OZWdhdGl2ZU51bWJlciB9IGZyb20gJy4vYWJzdHJhY3Qtb3BzL21pc2NlbGxhbmVvdXMnO1xuaW1wb3J0IHsgYXNzZXJ0T2JqZWN0LCBhc3NlcnRSZXF1aXJlZEFyZ3VtZW50IH0gZnJvbSAnLi92YWxpZGF0b3JzL2Jhc2ljJztcbmltcG9ydCB7IGNvbnZlcnRRdWV1aW5nU3RyYXRlZ3kgfSBmcm9tICcuL3ZhbGlkYXRvcnMvcXVldWluZy1zdHJhdGVneSc7XG5pbXBvcnQgeyBFeHRyYWN0SGlnaFdhdGVyTWFyaywgRXh0cmFjdFNpemVBbGdvcml0aG0gfSBmcm9tICcuL2Fic3RyYWN0LW9wcy9xdWV1aW5nLXN0cmF0ZWd5JztcbmltcG9ydCB7IGNvbnZlcnRVbmRlcmx5aW5nRGVmYXVsdE9yQnl0ZVNvdXJjZSB9IGZyb20gJy4vdmFsaWRhdG9ycy91bmRlcmx5aW5nLXNvdXJjZSc7XG5pbXBvcnQgeyBSZWFkYWJsZVN0cmVhbUdldFJlYWRlck9wdGlvbnMgfSBmcm9tICcuL3JlYWRhYmxlLXN0cmVhbS9yZWFkZXItb3B0aW9ucyc7XG5pbXBvcnQgeyBjb252ZXJ0UmVhZGVyT3B0aW9ucyB9IGZyb20gJy4vdmFsaWRhdG9ycy9yZWFkZXItb3B0aW9ucyc7XG5pbXBvcnQgeyBTdHJlYW1QaXBlT3B0aW9ucywgVmFsaWRhdGVkU3RyZWFtUGlwZU9wdGlvbnMgfSBmcm9tICcuL3JlYWRhYmxlLXN0cmVhbS9waXBlLW9wdGlvbnMnO1xuaW1wb3J0IHsgUmVhZGFibGVTdHJlYW1JdGVyYXRvck9wdGlvbnMgfSBmcm9tICcuL3JlYWRhYmxlLXN0cmVhbS9pdGVyYXRvci1vcHRpb25zJztcbmltcG9ydCB7IGNvbnZlcnRJdGVyYXRvck9wdGlvbnMgfSBmcm9tICcuL3ZhbGlkYXRvcnMvaXRlcmF0b3Itb3B0aW9ucyc7XG5pbXBvcnQgeyBjb252ZXJ0UGlwZU9wdGlvbnMgfSBmcm9tICcuL3ZhbGlkYXRvcnMvcGlwZS1vcHRpb25zJztcbmltcG9ydCB7IFJlYWRhYmxlV3JpdGFibGVQYWlyIH0gZnJvbSAnLi9yZWFkYWJsZS1zdHJlYW0vcmVhZGFibGUtd3JpdGFibGUtcGFpcic7XG5pbXBvcnQgeyBjb252ZXJ0UmVhZGFibGVXcml0YWJsZVBhaXIgfSBmcm9tICcuL3ZhbGlkYXRvcnMvcmVhZGFibGUtd3JpdGFibGUtcGFpcic7XG5cbmV4cG9ydCB0eXBlIFJlYWRhYmxlQnl0ZVN0cmVhbSA9IFJlYWRhYmxlU3RyZWFtPFVpbnQ4QXJyYXk+ICYge1xuICBfcmVhZGFibGVTdHJlYW1Db250cm9sbGVyOiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyXG59O1xuXG50eXBlIFJlYWRhYmxlU3RyZWFtU3RhdGUgPSAncmVhZGFibGUnIHwgJ2Nsb3NlZCcgfCAnZXJyb3JlZCc7XG5cbi8qKlxuICogQSByZWFkYWJsZSBzdHJlYW0gcmVwcmVzZW50cyBhIHNvdXJjZSBvZiBkYXRhLCBmcm9tIHdoaWNoIHlvdSBjYW4gcmVhZC5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBSZWFkYWJsZVN0cmVhbTxSID0gYW55PiB7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3N0YXRlITogUmVhZGFibGVTdHJlYW1TdGF0ZTtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfcmVhZGVyOiBSZWFkYWJsZVN0cmVhbVJlYWRlcjxSPiB8IHVuZGVmaW5lZDtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfc3RvcmVkRXJyb3I6IGFueTtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfZGlzdHVyYmVkITogYm9vbGVhbjtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfcmVhZGFibGVTdHJlYW1Db250cm9sbGVyITogUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxSPiB8IFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXI7XG5cbiAgY29uc3RydWN0b3IodW5kZXJseWluZ1NvdXJjZTogVW5kZXJseWluZ0J5dGVTb3VyY2UsIHN0cmF0ZWd5PzogeyBoaWdoV2F0ZXJNYXJrPzogbnVtYmVyOyBzaXplPzogdW5kZWZpbmVkIH0pO1xuICBjb25zdHJ1Y3Rvcih1bmRlcmx5aW5nU291cmNlPzogVW5kZXJseWluZ1NvdXJjZTxSPiwgc3RyYXRlZ3k/OiBRdWV1aW5nU3RyYXRlZ3k8Uj4pO1xuICBjb25zdHJ1Y3RvcihyYXdVbmRlcmx5aW5nU291cmNlOiBVbmRlcmx5aW5nU291cmNlPFI+IHwgVW5kZXJseWluZ0J5dGVTb3VyY2UgfCBudWxsIHwgdW5kZWZpbmVkID0ge30sXG4gICAgICAgICAgICAgIHJhd1N0cmF0ZWd5OiBRdWV1aW5nU3RyYXRlZ3k8Uj4gfCBudWxsIHwgdW5kZWZpbmVkID0ge30pIHtcbiAgICBpZiAocmF3VW5kZXJseWluZ1NvdXJjZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByYXdVbmRlcmx5aW5nU291cmNlID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzZXJ0T2JqZWN0KHJhd1VuZGVybHlpbmdTb3VyY2UsICdGaXJzdCBwYXJhbWV0ZXInKTtcbiAgICB9XG5cbiAgICBjb25zdCBzdHJhdGVneSA9IGNvbnZlcnRRdWV1aW5nU3RyYXRlZ3kocmF3U3RyYXRlZ3ksICdTZWNvbmQgcGFyYW1ldGVyJyk7XG4gICAgY29uc3QgdW5kZXJseWluZ1NvdXJjZSA9IGNvbnZlcnRVbmRlcmx5aW5nRGVmYXVsdE9yQnl0ZVNvdXJjZShyYXdVbmRlcmx5aW5nU291cmNlLCAnRmlyc3QgcGFyYW1ldGVyJyk7XG5cbiAgICBJbml0aWFsaXplUmVhZGFibGVTdHJlYW0odGhpcyk7XG5cbiAgICBpZiAodW5kZXJseWluZ1NvdXJjZS50eXBlID09PSAnYnl0ZXMnKSB7XG4gICAgICBpZiAoc3RyYXRlZ3kuc2l6ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgc3RyYXRlZ3kgZm9yIGEgYnl0ZSBzdHJlYW0gY2Fubm90IGhhdmUgYSBzaXplIGZ1bmN0aW9uJyk7XG4gICAgICB9XG4gICAgICBjb25zdCBoaWdoV2F0ZXJNYXJrID0gRXh0cmFjdEhpZ2hXYXRlck1hcmsoc3RyYXRlZ3ksIDApO1xuICAgICAgU2V0VXBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRnJvbVVuZGVybHlpbmdTb3VyY2UoXG4gICAgICAgIHRoaXMgYXMgdW5rbm93biBhcyBSZWFkYWJsZUJ5dGVTdHJlYW0sXG4gICAgICAgIHVuZGVybHlpbmdTb3VyY2UsXG4gICAgICAgIGhpZ2hXYXRlck1hcmtcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2VydCh1bmRlcmx5aW5nU291cmNlLnR5cGUgPT09IHVuZGVmaW5lZCk7XG4gICAgICBjb25zdCBzaXplQWxnb3JpdGhtID0gRXh0cmFjdFNpemVBbGdvcml0aG0oc3RyYXRlZ3kpO1xuICAgICAgY29uc3QgaGlnaFdhdGVyTWFyayA9IEV4dHJhY3RIaWdoV2F0ZXJNYXJrKHN0cmF0ZWd5LCAxKTtcbiAgICAgIFNldFVwUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckZyb21VbmRlcmx5aW5nU291cmNlKFxuICAgICAgICB0aGlzLFxuICAgICAgICB1bmRlcmx5aW5nU291cmNlLFxuICAgICAgICBoaWdoV2F0ZXJNYXJrLFxuICAgICAgICBzaXplQWxnb3JpdGhtXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgcmVhZGFibGUgc3RyZWFtIGlzIGxvY2tlZCB0byBhIHtAbGluayBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIgfCByZWFkZXJ9LlxuICAgKi9cbiAgZ2V0IGxvY2tlZCgpOiBib29sZWFuIHtcbiAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW0odGhpcykpIHtcbiAgICAgIHRocm93IHN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24oJ2xvY2tlZCcpO1xuICAgIH1cblxuICAgIHJldHVybiBJc1JlYWRhYmxlU3RyZWFtTG9ja2VkKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbmNlbHMgdGhlIHN0cmVhbSwgc2lnbmFsaW5nIGEgbG9zcyBvZiBpbnRlcmVzdCBpbiB0aGUgc3RyZWFtIGJ5IGEgY29uc3VtZXIuXG4gICAqXG4gICAqIFRoZSBzdXBwbGllZCBgcmVhc29uYCBhcmd1bWVudCB3aWxsIGJlIGdpdmVuIHRvIHRoZSB1bmRlcmx5aW5nIHNvdXJjZSdzIHtAbGluayBVbmRlcmx5aW5nU291cmNlLmNhbmNlbCB8IGNhbmNlbCgpfVxuICAgKiBtZXRob2QsIHdoaWNoIG1pZ2h0IG9yIG1pZ2h0IG5vdCB1c2UgaXQuXG4gICAqL1xuICBjYW5jZWwocmVhc29uOiBhbnkgPSB1bmRlZmluZWQpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW0odGhpcykpIHtcbiAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKHN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24oJ2NhbmNlbCcpKTtcbiAgICB9XG5cbiAgICBpZiAoSXNSZWFkYWJsZVN0cmVhbUxvY2tlZCh0aGlzKSkge1xuICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgobmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbmNlbCBhIHN0cmVhbSB0aGF0IGFscmVhZHkgaGFzIGEgcmVhZGVyJykpO1xuICAgIH1cblxuICAgIHJldHVybiBSZWFkYWJsZVN0cmVhbUNhbmNlbCh0aGlzLCByZWFzb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSB7QGxpbmsgUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyfSBhbmQgbG9ja3MgdGhlIHN0cmVhbSB0byB0aGUgbmV3IHJlYWRlci5cbiAgICpcbiAgICogVGhpcyBjYWxsIGJlaGF2ZXMgdGhlIHNhbWUgd2F5IGFzIHRoZSBuby1hcmd1bWVudCB2YXJpYW50LCBleGNlcHQgdGhhdCBpdCBvbmx5IHdvcmtzIG9uIHJlYWRhYmxlIGJ5dGUgc3RyZWFtcyxcbiAgICogaS5lLiBzdHJlYW1zIHdoaWNoIHdlcmUgY29uc3RydWN0ZWQgc3BlY2lmaWNhbGx5IHdpdGggdGhlIGFiaWxpdHkgdG8gaGFuZGxlIFwiYnJpbmcgeW91ciBvd24gYnVmZmVyXCIgcmVhZGluZy5cbiAgICogVGhlIHJldHVybmVkIEJZT0IgcmVhZGVyIHByb3ZpZGVzIHRoZSBhYmlsaXR5IHRvIGRpcmVjdGx5IHJlYWQgaW5kaXZpZHVhbCBjaHVua3MgZnJvbSB0aGUgc3RyZWFtIHZpYSBpdHNcbiAgICoge0BsaW5rIFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlci5yZWFkIHwgcmVhZCgpfSBtZXRob2QsIGludG8gZGV2ZWxvcGVyLXN1cHBsaWVkIGJ1ZmZlcnMsIGFsbG93aW5nIG1vcmUgcHJlY2lzZVxuICAgKiBjb250cm9sIG92ZXIgYWxsb2NhdGlvbi5cbiAgICovXG4gIGdldFJlYWRlcih7IG1vZGUgfTogeyBtb2RlOiAnYnlvYicgfSk6IFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlcjtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSB7QGxpbmsgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyfSBhbmQgbG9ja3MgdGhlIHN0cmVhbSB0byB0aGUgbmV3IHJlYWRlci5cbiAgICogV2hpbGUgdGhlIHN0cmVhbSBpcyBsb2NrZWQsIG5vIG90aGVyIHJlYWRlciBjYW4gYmUgYWNxdWlyZWQgdW50aWwgdGhpcyBvbmUgaXMgcmVsZWFzZWQuXG4gICAqXG4gICAqIFRoaXMgZnVuY3Rpb25hbGl0eSBpcyBlc3BlY2lhbGx5IHVzZWZ1bCBmb3IgY3JlYXRpbmcgYWJzdHJhY3Rpb25zIHRoYXQgZGVzaXJlIHRoZSBhYmlsaXR5IHRvIGNvbnN1bWUgYSBzdHJlYW1cbiAgICogaW4gaXRzIGVudGlyZXR5LiBCeSBnZXR0aW5nIGEgcmVhZGVyIGZvciB0aGUgc3RyZWFtLCB5b3UgY2FuIGVuc3VyZSBub2JvZHkgZWxzZSBjYW4gaW50ZXJsZWF2ZSByZWFkcyB3aXRoIHlvdXJzXG4gICAqIG9yIGNhbmNlbCB0aGUgc3RyZWFtLCB3aGljaCB3b3VsZCBpbnRlcmZlcmUgd2l0aCB5b3VyIGFic3RyYWN0aW9uLlxuICAgKi9cbiAgZ2V0UmVhZGVyKCk6IFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcjxSPjtcbiAgZ2V0UmVhZGVyKFxuICAgIHJhd09wdGlvbnM6IFJlYWRhYmxlU3RyZWFtR2V0UmVhZGVyT3B0aW9ucyB8IG51bGwgfCB1bmRlZmluZWQgPSB1bmRlZmluZWRcbiAgKTogUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyPFI+IHwgUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyIHtcbiAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW0odGhpcykpIHtcbiAgICAgIHRocm93IHN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24oJ2dldFJlYWRlcicpO1xuICAgIH1cblxuICAgIGNvbnN0IG9wdGlvbnMgPSBjb252ZXJ0UmVhZGVyT3B0aW9ucyhyYXdPcHRpb25zLCAnRmlyc3QgcGFyYW1ldGVyJyk7XG5cbiAgICBpZiAob3B0aW9ucy5tb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBBY3F1aXJlUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyKHRoaXMpO1xuICAgIH1cblxuICAgIGFzc2VydChvcHRpb25zLm1vZGUgPT09ICdieW9iJyk7XG4gICAgcmV0dXJuIEFjcXVpcmVSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIodGhpcyBhcyB1bmtub3duIGFzIFJlYWRhYmxlQnl0ZVN0cmVhbSk7XG4gIH1cblxuICAvKipcbiAgICogUHJvdmlkZXMgYSBjb252ZW5pZW50LCBjaGFpbmFibGUgd2F5IG9mIHBpcGluZyB0aGlzIHJlYWRhYmxlIHN0cmVhbSB0aHJvdWdoIGEgdHJhbnNmb3JtIHN0cmVhbVxuICAgKiAob3IgYW55IG90aGVyIGB7IHdyaXRhYmxlLCByZWFkYWJsZSB9YCBwYWlyKS4gSXQgc2ltcGx5IHtAbGluayBSZWFkYWJsZVN0cmVhbS5waXBlVG8gfCBwaXBlc30gdGhlIHN0cmVhbVxuICAgKiBpbnRvIHRoZSB3cml0YWJsZSBzaWRlIG9mIHRoZSBzdXBwbGllZCBwYWlyLCBhbmQgcmV0dXJucyB0aGUgcmVhZGFibGUgc2lkZSBmb3IgZnVydGhlciB1c2UuXG4gICAqXG4gICAqIFBpcGluZyBhIHN0cmVhbSB3aWxsIGxvY2sgaXQgZm9yIHRoZSBkdXJhdGlvbiBvZiB0aGUgcGlwZSwgcHJldmVudGluZyBhbnkgb3RoZXIgY29uc3VtZXIgZnJvbSBhY3F1aXJpbmcgYSByZWFkZXIuXG4gICAqL1xuICBwaXBlVGhyb3VnaDxSUyBleHRlbmRzIFJlYWRhYmxlU3RyZWFtPihcbiAgICB0cmFuc2Zvcm06IHsgcmVhZGFibGU6IFJTOyB3cml0YWJsZTogV3JpdGFibGVTdHJlYW08Uj4gfSxcbiAgICBvcHRpb25zPzogU3RyZWFtUGlwZU9wdGlvbnNcbiAgKTogUlM7XG4gIHBpcGVUaHJvdWdoPFJTIGV4dGVuZHMgUmVhZGFibGVTdHJlYW0+KFxuICAgIHJhd1RyYW5zZm9ybTogeyByZWFkYWJsZTogUlM7IHdyaXRhYmxlOiBXcml0YWJsZVN0cmVhbTxSPiB9IHwgbnVsbCB8IHVuZGVmaW5lZCxcbiAgICByYXdPcHRpb25zOiBTdHJlYW1QaXBlT3B0aW9ucyB8IG51bGwgfCB1bmRlZmluZWQgPSB7fVxuICApOiBSUyB7XG4gICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtKHRoaXMpKSB7XG4gICAgICB0aHJvdyBzdHJlYW1CcmFuZENoZWNrRXhjZXB0aW9uKCdwaXBlVGhyb3VnaCcpO1xuICAgIH1cbiAgICBhc3NlcnRSZXF1aXJlZEFyZ3VtZW50KHJhd1RyYW5zZm9ybSwgMSwgJ3BpcGVUaHJvdWdoJyk7XG5cbiAgICBjb25zdCB0cmFuc2Zvcm0gPSBjb252ZXJ0UmVhZGFibGVXcml0YWJsZVBhaXIocmF3VHJhbnNmb3JtLCAnRmlyc3QgcGFyYW1ldGVyJyk7XG4gICAgY29uc3Qgb3B0aW9ucyA9IGNvbnZlcnRQaXBlT3B0aW9ucyhyYXdPcHRpb25zLCAnU2Vjb25kIHBhcmFtZXRlcicpO1xuXG4gICAgaWYgKElzUmVhZGFibGVTdHJlYW1Mb2NrZWQodGhpcykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1JlYWRhYmxlU3RyZWFtLnByb3RvdHlwZS5waXBlVGhyb3VnaCBjYW5ub3QgYmUgdXNlZCBvbiBhIGxvY2tlZCBSZWFkYWJsZVN0cmVhbScpO1xuICAgIH1cbiAgICBpZiAoSXNXcml0YWJsZVN0cmVhbUxvY2tlZCh0cmFuc2Zvcm0ud3JpdGFibGUpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGUucGlwZVRocm91Z2ggY2Fubm90IGJlIHVzZWQgb24gYSBsb2NrZWQgV3JpdGFibGVTdHJlYW0nKTtcbiAgICB9XG5cbiAgICBjb25zdCBwcm9taXNlID0gUmVhZGFibGVTdHJlYW1QaXBlVG8oXG4gICAgICB0aGlzLCB0cmFuc2Zvcm0ud3JpdGFibGUsIG9wdGlvbnMucHJldmVudENsb3NlLCBvcHRpb25zLnByZXZlbnRBYm9ydCwgb3B0aW9ucy5wcmV2ZW50Q2FuY2VsLCBvcHRpb25zLnNpZ25hbFxuICAgICk7XG5cbiAgICBzZXRQcm9taXNlSXNIYW5kbGVkVG9UcnVlKHByb21pc2UpO1xuXG4gICAgcmV0dXJuIHRyYW5zZm9ybS5yZWFkYWJsZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQaXBlcyB0aGlzIHJlYWRhYmxlIHN0cmVhbSB0byBhIGdpdmVuIHdyaXRhYmxlIHN0cmVhbS4gVGhlIHdheSBpbiB3aGljaCB0aGUgcGlwaW5nIHByb2Nlc3MgYmVoYXZlcyB1bmRlclxuICAgKiB2YXJpb3VzIGVycm9yIGNvbmRpdGlvbnMgY2FuIGJlIGN1c3RvbWl6ZWQgd2l0aCBhIG51bWJlciBvZiBwYXNzZWQgb3B0aW9ucy4gSXQgcmV0dXJucyBhIHByb21pc2UgdGhhdCBmdWxmaWxsc1xuICAgKiB3aGVuIHRoZSBwaXBpbmcgcHJvY2VzcyBjb21wbGV0ZXMgc3VjY2Vzc2Z1bGx5LCBvciByZWplY3RzIGlmIGFueSBlcnJvcnMgd2VyZSBlbmNvdW50ZXJlZC5cbiAgICpcbiAgICogUGlwaW5nIGEgc3RyZWFtIHdpbGwgbG9jayBpdCBmb3IgdGhlIGR1cmF0aW9uIG9mIHRoZSBwaXBlLCBwcmV2ZW50aW5nIGFueSBvdGhlciBjb25zdW1lciBmcm9tIGFjcXVpcmluZyBhIHJlYWRlci5cbiAgICovXG4gIHBpcGVUbyhkZXN0aW5hdGlvbjogV3JpdGFibGVTdHJlYW08Uj4sIG9wdGlvbnM/OiBTdHJlYW1QaXBlT3B0aW9ucyk6IFByb21pc2U8dm9pZD47XG4gIHBpcGVUbyhkZXN0aW5hdGlvbjogV3JpdGFibGVTdHJlYW08Uj4gfCBudWxsIHwgdW5kZWZpbmVkLFxuICAgICAgICAgcmF3T3B0aW9uczogU3RyZWFtUGlwZU9wdGlvbnMgfCBudWxsIHwgdW5kZWZpbmVkID0ge30pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW0odGhpcykpIHtcbiAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKHN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24oJ3BpcGVUbycpKTtcbiAgICB9XG5cbiAgICBpZiAoZGVzdGluYXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoYFBhcmFtZXRlciAxIGlzIHJlcXVpcmVkIGluICdwaXBlVG8nLmApO1xuICAgIH1cbiAgICBpZiAoIUlzV3JpdGFibGVTdHJlYW0oZGVzdGluYXRpb24pKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChcbiAgICAgICAgbmV3IFR5cGVFcnJvcihgUmVhZGFibGVTdHJlYW0ucHJvdG90eXBlLnBpcGVUbydzIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBXcml0YWJsZVN0cmVhbWApXG4gICAgICApO1xuICAgIH1cblxuICAgIGxldCBvcHRpb25zOiBWYWxpZGF0ZWRTdHJlYW1QaXBlT3B0aW9ucztcbiAgICB0cnkge1xuICAgICAgb3B0aW9ucyA9IGNvbnZlcnRQaXBlT3B0aW9ucyhyYXdPcHRpb25zLCAnU2Vjb25kIHBhcmFtZXRlcicpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGUpO1xuICAgIH1cblxuICAgIGlmIChJc1JlYWRhYmxlU3RyZWFtTG9ja2VkKHRoaXMpKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChcbiAgICAgICAgbmV3IFR5cGVFcnJvcignUmVhZGFibGVTdHJlYW0ucHJvdG90eXBlLnBpcGVUbyBjYW5ub3QgYmUgdXNlZCBvbiBhIGxvY2tlZCBSZWFkYWJsZVN0cmVhbScpXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoSXNXcml0YWJsZVN0cmVhbUxvY2tlZChkZXN0aW5hdGlvbikpIHtcbiAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKFxuICAgICAgICBuZXcgVHlwZUVycm9yKCdSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGUucGlwZVRvIGNhbm5vdCBiZSB1c2VkIG9uIGEgbG9ja2VkIFdyaXRhYmxlU3RyZWFtJylcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFJlYWRhYmxlU3RyZWFtUGlwZVRvPFI+KFxuICAgICAgdGhpcywgZGVzdGluYXRpb24sIG9wdGlvbnMucHJldmVudENsb3NlLCBvcHRpb25zLnByZXZlbnRBYm9ydCwgb3B0aW9ucy5wcmV2ZW50Q2FuY2VsLCBvcHRpb25zLnNpZ25hbFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogVGVlcyB0aGlzIHJlYWRhYmxlIHN0cmVhbSwgcmV0dXJuaW5nIGEgdHdvLWVsZW1lbnQgYXJyYXkgY29udGFpbmluZyB0aGUgdHdvIHJlc3VsdGluZyBicmFuY2hlcyBhc1xuICAgKiBuZXcge0BsaW5rIFJlYWRhYmxlU3RyZWFtfSBpbnN0YW5jZXMuXG4gICAqXG4gICAqIFRlZWluZyBhIHN0cmVhbSB3aWxsIGxvY2sgaXQsIHByZXZlbnRpbmcgYW55IG90aGVyIGNvbnN1bWVyIGZyb20gYWNxdWlyaW5nIGEgcmVhZGVyLlxuICAgKiBUbyBjYW5jZWwgdGhlIHN0cmVhbSwgY2FuY2VsIGJvdGggb2YgdGhlIHJlc3VsdGluZyBicmFuY2hlczsgYSBjb21wb3NpdGUgY2FuY2VsbGF0aW9uIHJlYXNvbiB3aWxsIHRoZW4gYmVcbiAgICogcHJvcGFnYXRlZCB0byB0aGUgc3RyZWFtJ3MgdW5kZXJseWluZyBzb3VyY2UuXG4gICAqXG4gICAqIE5vdGUgdGhhdCB0aGUgY2h1bmtzIHNlZW4gaW4gZWFjaCBicmFuY2ggd2lsbCBiZSB0aGUgc2FtZSBvYmplY3QuIElmIHRoZSBjaHVua3MgYXJlIG5vdCBpbW11dGFibGUsXG4gICAqIHRoaXMgY291bGQgYWxsb3cgaW50ZXJmZXJlbmNlIGJldHdlZW4gdGhlIHR3byBicmFuY2hlcy5cbiAgICovXG4gIHRlZSgpOiBbUmVhZGFibGVTdHJlYW08Uj4sIFJlYWRhYmxlU3RyZWFtPFI+XSB7XG4gICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtKHRoaXMpKSB7XG4gICAgICB0aHJvdyBzdHJlYW1CcmFuZENoZWNrRXhjZXB0aW9uKCd0ZWUnKTtcbiAgICB9XG5cbiAgICBjb25zdCBicmFuY2hlcyA9IFJlYWRhYmxlU3RyZWFtVGVlKHRoaXMsIGZhbHNlKTtcbiAgICByZXR1cm4gQ3JlYXRlQXJyYXlGcm9tTGlzdChicmFuY2hlcyk7XG4gIH1cblxuICAvKipcbiAgICogQXN5bmNocm9ub3VzbHkgaXRlcmF0ZXMgb3ZlciB0aGUgY2h1bmtzIGluIHRoZSBzdHJlYW0ncyBpbnRlcm5hbCBxdWV1ZS5cbiAgICpcbiAgICogQXN5bmNocm9ub3VzbHkgaXRlcmF0aW5nIG92ZXIgdGhlIHN0cmVhbSB3aWxsIGxvY2sgaXQsIHByZXZlbnRpbmcgYW55IG90aGVyIGNvbnN1bWVyIGZyb20gYWNxdWlyaW5nIGEgcmVhZGVyLlxuICAgKiBUaGUgbG9jayB3aWxsIGJlIHJlbGVhc2VkIGlmIHRoZSBhc3luYyBpdGVyYXRvcidzIHtAbGluayBSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IucmV0dXJuIHwgcmV0dXJuKCl9IG1ldGhvZFxuICAgKiBpcyBjYWxsZWQsIGUuZy4gYnkgYnJlYWtpbmcgb3V0IG9mIHRoZSBsb29wLlxuICAgKlxuICAgKiBCeSBkZWZhdWx0LCBjYWxsaW5nIHRoZSBhc3luYyBpdGVyYXRvcidzIHtAbGluayBSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IucmV0dXJuIHwgcmV0dXJuKCl9IG1ldGhvZCB3aWxsIGFsc29cbiAgICogY2FuY2VsIHRoZSBzdHJlYW0uIFRvIHByZXZlbnQgdGhpcywgdXNlIHRoZSBzdHJlYW0ncyB7QGxpbmsgUmVhZGFibGVTdHJlYW0udmFsdWVzIHwgdmFsdWVzKCl9IG1ldGhvZCwgcGFzc2luZ1xuICAgKiBgdHJ1ZWAgZm9yIHRoZSBgcHJldmVudENhbmNlbGAgb3B0aW9uLlxuICAgKi9cbiAgdmFsdWVzKG9wdGlvbnM/OiBSZWFkYWJsZVN0cmVhbUl0ZXJhdG9yT3B0aW9ucyk6IFJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvcjxSPjtcbiAgdmFsdWVzKHJhd09wdGlvbnM6IFJlYWRhYmxlU3RyZWFtSXRlcmF0b3JPcHRpb25zIHwgbnVsbCB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZCk6IFJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvcjxSPiB7XG4gICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtKHRoaXMpKSB7XG4gICAgICB0aHJvdyBzdHJlYW1CcmFuZENoZWNrRXhjZXB0aW9uKCd2YWx1ZXMnKTtcbiAgICB9XG5cbiAgICBjb25zdCBvcHRpb25zID0gY29udmVydEl0ZXJhdG9yT3B0aW9ucyhyYXdPcHRpb25zLCAnRmlyc3QgcGFyYW1ldGVyJyk7XG4gICAgcmV0dXJuIEFjcXVpcmVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3I8Uj4odGhpcywgb3B0aW9ucy5wcmV2ZW50Q2FuY2VsKTtcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGluaGVyaXREb2MgUmVhZGFibGVTdHJlYW0udmFsdWVzfVxuICAgKi9cbiAgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXTogKG9wdGlvbnM/OiBSZWFkYWJsZVN0cmVhbUl0ZXJhdG9yT3B0aW9ucykgPT4gUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yPFI+O1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGUsIHtcbiAgY2FuY2VsOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgZ2V0UmVhZGVyOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgcGlwZVRocm91Z2g6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICBwaXBlVG86IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICB0ZWU6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICB2YWx1ZXM6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICBsb2NrZWQ6IHsgZW51bWVyYWJsZTogdHJ1ZSB9XG59KTtcbmlmICh0eXBlb2YgU3ltYm9sLnRvU3RyaW5nVGFnID09PSAnc3ltYm9sJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGVTdHJlYW0ucHJvdG90eXBlLCBTeW1ib2wudG9TdHJpbmdUYWcsIHtcbiAgICB2YWx1ZTogJ1JlYWRhYmxlU3RyZWFtJyxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5pZiAodHlwZW9mIFN5bWJvbC5hc3luY0l0ZXJhdG9yID09PSAnc3ltYm9sJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGVTdHJlYW0ucHJvdG90eXBlLCBTeW1ib2wuYXN5bmNJdGVyYXRvciwge1xuICAgIHZhbHVlOiBSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGUudmFsdWVzLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuZXhwb3J0IHtcbiAgUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yLFxuICBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkUmVzdWx0LFxuICBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkUmVzdWx0LFxuICBVbmRlcmx5aW5nQnl0ZVNvdXJjZSxcbiAgVW5kZXJseWluZ1NvdXJjZSxcbiAgVW5kZXJseWluZ1NvdXJjZVN0YXJ0Q2FsbGJhY2ssXG4gIFVuZGVybHlpbmdTb3VyY2VQdWxsQ2FsbGJhY2ssXG4gIFVuZGVybHlpbmdTb3VyY2VDYW5jZWxDYWxsYmFjayxcbiAgVW5kZXJseWluZ0J5dGVTb3VyY2VTdGFydENhbGxiYWNrLFxuICBVbmRlcmx5aW5nQnl0ZVNvdXJjZVB1bGxDYWxsYmFjayxcbiAgU3RyZWFtUGlwZU9wdGlvbnMsXG4gIFJlYWRhYmxlV3JpdGFibGVQYWlyLFxuICBSZWFkYWJsZVN0cmVhbUl0ZXJhdG9yT3B0aW9uc1xufTtcblxuLy8gQWJzdHJhY3Qgb3BlcmF0aW9ucyBmb3IgdGhlIFJlYWRhYmxlU3RyZWFtLlxuXG4vLyBUaHJvd3MgaWYgYW5kIG9ubHkgaWYgc3RhcnRBbGdvcml0aG0gdGhyb3dzLlxuZXhwb3J0IGZ1bmN0aW9uIENyZWF0ZVJlYWRhYmxlU3RyZWFtPFI+KHN0YXJ0QWxnb3JpdGhtOiAoKSA9PiB2b2lkIHwgUHJvbWlzZUxpa2U8dm9pZD4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHVsbEFsZ29yaXRobTogKCkgPT4gUHJvbWlzZTx2b2lkPixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5jZWxBbGdvcml0aG06IChyZWFzb246IGFueSkgPT4gUHJvbWlzZTx2b2lkPixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaWdoV2F0ZXJNYXJrID0gMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaXplQWxnb3JpdGhtOiBRdWV1aW5nU3RyYXRlZ3lTaXplQ2FsbGJhY2s8Uj4gPSAoKSA9PiAxKTogUmVhZGFibGVTdHJlYW08Uj4ge1xuICBhc3NlcnQoSXNOb25OZWdhdGl2ZU51bWJlcihoaWdoV2F0ZXJNYXJrKSk7XG5cbiAgY29uc3Qgc3RyZWFtOiBSZWFkYWJsZVN0cmVhbTxSPiA9IE9iamVjdC5jcmVhdGUoUmVhZGFibGVTdHJlYW0ucHJvdG90eXBlKTtcbiAgSW5pdGlhbGl6ZVJlYWRhYmxlU3RyZWFtKHN0cmVhbSk7XG5cbiAgY29uc3QgY29udHJvbGxlcjogUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxSPiA9IE9iamVjdC5jcmVhdGUoUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUpO1xuICBTZXRVcFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIoXG4gICAgc3RyZWFtLCBjb250cm9sbGVyLCBzdGFydEFsZ29yaXRobSwgcHVsbEFsZ29yaXRobSwgY2FuY2VsQWxnb3JpdGhtLCBoaWdoV2F0ZXJNYXJrLCBzaXplQWxnb3JpdGhtXG4gICk7XG5cbiAgcmV0dXJuIHN0cmVhbTtcbn1cblxuLy8gVGhyb3dzIGlmIGFuZCBvbmx5IGlmIHN0YXJ0QWxnb3JpdGhtIHRocm93cy5cbmV4cG9ydCBmdW5jdGlvbiBDcmVhdGVSZWFkYWJsZUJ5dGVTdHJlYW0oXG4gIHN0YXJ0QWxnb3JpdGhtOiAoKSA9PiB2b2lkIHwgUHJvbWlzZUxpa2U8dm9pZD4sXG4gIHB1bGxBbGdvcml0aG06ICgpID0+IFByb21pc2U8dm9pZD4sXG4gIGNhbmNlbEFsZ29yaXRobTogKHJlYXNvbjogYW55KSA9PiBQcm9taXNlPHZvaWQ+XG4pOiBSZWFkYWJsZUJ5dGVTdHJlYW0ge1xuICBjb25zdCBzdHJlYW06IFJlYWRhYmxlQnl0ZVN0cmVhbSA9IE9iamVjdC5jcmVhdGUoUmVhZGFibGVTdHJlYW0ucHJvdG90eXBlKTtcbiAgSW5pdGlhbGl6ZVJlYWRhYmxlU3RyZWFtKHN0cmVhbSk7XG5cbiAgY29uc3QgY29udHJvbGxlcjogUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlciA9IE9iamVjdC5jcmVhdGUoUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUpO1xuICBTZXRVcFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIoc3RyZWFtLCBjb250cm9sbGVyLCBzdGFydEFsZ29yaXRobSwgcHVsbEFsZ29yaXRobSwgY2FuY2VsQWxnb3JpdGhtLCAwLCB1bmRlZmluZWQpO1xuXG4gIHJldHVybiBzdHJlYW07XG59XG5cbmZ1bmN0aW9uIEluaXRpYWxpemVSZWFkYWJsZVN0cmVhbShzdHJlYW06IFJlYWRhYmxlU3RyZWFtKSB7XG4gIHN0cmVhbS5fc3RhdGUgPSAncmVhZGFibGUnO1xuICBzdHJlYW0uX3JlYWRlciA9IHVuZGVmaW5lZDtcbiAgc3RyZWFtLl9zdG9yZWRFcnJvciA9IHVuZGVmaW5lZDtcbiAgc3RyZWFtLl9kaXN0dXJiZWQgPSBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIElzUmVhZGFibGVTdHJlYW0oeDogdW5rbm93bik6IHggaXMgUmVhZGFibGVTdHJlYW0ge1xuICBpZiAoIXR5cGVJc09iamVjdCh4KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdfcmVhZGFibGVTdHJlYW1Db250cm9sbGVyJykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4geCBpbnN0YW5jZW9mIFJlYWRhYmxlU3RyZWFtO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gSXNSZWFkYWJsZVN0cmVhbURpc3R1cmJlZChzdHJlYW06IFJlYWRhYmxlU3RyZWFtKTogYm9vbGVhbiB7XG4gIGFzc2VydChJc1JlYWRhYmxlU3RyZWFtKHN0cmVhbSkpO1xuXG4gIHJldHVybiBzdHJlYW0uX2Rpc3R1cmJlZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIElzUmVhZGFibGVTdHJlYW1Mb2NrZWQoc3RyZWFtOiBSZWFkYWJsZVN0cmVhbSk6IGJvb2xlYW4ge1xuICBhc3NlcnQoSXNSZWFkYWJsZVN0cmVhbShzdHJlYW0pKTtcblxuICBpZiAoc3RyZWFtLl9yZWFkZXIgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG4vLyBSZWFkYWJsZVN0cmVhbSBBUEkgZXhwb3NlZCBmb3IgY29udHJvbGxlcnMuXG5cbmV4cG9ydCBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbUNhbmNlbDxSPihzdHJlYW06IFJlYWRhYmxlU3RyZWFtPFI+LCByZWFzb246IGFueSk6IFByb21pc2U8dW5kZWZpbmVkPiB7XG4gIHN0cmVhbS5fZGlzdHVyYmVkID0gdHJ1ZTtcblxuICBpZiAoc3RyZWFtLl9zdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuICB9XG4gIGlmIChzdHJlYW0uX3N0YXRlID09PSAnZXJyb3JlZCcpIHtcbiAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChzdHJlYW0uX3N0b3JlZEVycm9yKTtcbiAgfVxuXG4gIFJlYWRhYmxlU3RyZWFtQ2xvc2Uoc3RyZWFtKTtcblxuICBjb25zdCByZWFkZXIgPSBzdHJlYW0uX3JlYWRlcjtcbiAgaWYgKHJlYWRlciAhPT0gdW5kZWZpbmVkICYmIElzUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyKHJlYWRlcikpIHtcbiAgICByZWFkZXIuX3JlYWRJbnRvUmVxdWVzdHMuZm9yRWFjaChyZWFkSW50b1JlcXVlc3QgPT4ge1xuICAgICAgcmVhZEludG9SZXF1ZXN0Ll9jbG9zZVN0ZXBzKHVuZGVmaW5lZCk7XG4gICAgfSk7XG4gICAgcmVhZGVyLl9yZWFkSW50b1JlcXVlc3RzID0gbmV3IFNpbXBsZVF1ZXVlKCk7XG4gIH1cblxuICBjb25zdCBzb3VyY2VDYW5jZWxQcm9taXNlID0gc3RyZWFtLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXJbQ2FuY2VsU3RlcHNdKHJlYXNvbik7XG4gIHJldHVybiB0cmFuc2Zvcm1Qcm9taXNlV2l0aChzb3VyY2VDYW5jZWxQcm9taXNlLCBub29wKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtQ2xvc2U8Uj4oc3RyZWFtOiBSZWFkYWJsZVN0cmVhbTxSPik6IHZvaWQge1xuICBhc3NlcnQoc3RyZWFtLl9zdGF0ZSA9PT0gJ3JlYWRhYmxlJyk7XG5cbiAgc3RyZWFtLl9zdGF0ZSA9ICdjbG9zZWQnO1xuXG4gIGNvbnN0IHJlYWRlciA9IHN0cmVhbS5fcmVhZGVyO1xuXG4gIGlmIChyZWFkZXIgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlUmVzb2x2ZShyZWFkZXIpO1xuXG4gIGlmIChJc1JlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcjxSPihyZWFkZXIpKSB7XG4gICAgcmVhZGVyLl9yZWFkUmVxdWVzdHMuZm9yRWFjaChyZWFkUmVxdWVzdCA9PiB7XG4gICAgICByZWFkUmVxdWVzdC5fY2xvc2VTdGVwcygpO1xuICAgIH0pO1xuICAgIHJlYWRlci5fcmVhZFJlcXVlc3RzID0gbmV3IFNpbXBsZVF1ZXVlKCk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtRXJyb3I8Uj4oc3RyZWFtOiBSZWFkYWJsZVN0cmVhbTxSPiwgZTogYW55KTogdm9pZCB7XG4gIGFzc2VydChJc1JlYWRhYmxlU3RyZWFtKHN0cmVhbSkpO1xuICBhc3NlcnQoc3RyZWFtLl9zdGF0ZSA9PT0gJ3JlYWRhYmxlJyk7XG5cbiAgc3RyZWFtLl9zdGF0ZSA9ICdlcnJvcmVkJztcbiAgc3RyZWFtLl9zdG9yZWRFcnJvciA9IGU7XG5cbiAgY29uc3QgcmVhZGVyID0gc3RyZWFtLl9yZWFkZXI7XG5cbiAgaWYgKHJlYWRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VSZWplY3QocmVhZGVyLCBlKTtcblxuICBpZiAoSXNSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXI8Uj4ocmVhZGVyKSkge1xuICAgIHJlYWRlci5fcmVhZFJlcXVlc3RzLmZvckVhY2gocmVhZFJlcXVlc3QgPT4ge1xuICAgICAgcmVhZFJlcXVlc3QuX2Vycm9yU3RlcHMoZSk7XG4gICAgfSk7XG5cbiAgICByZWFkZXIuX3JlYWRSZXF1ZXN0cyA9IG5ldyBTaW1wbGVRdWV1ZSgpO1xuICB9IGVsc2Uge1xuICAgIGFzc2VydChJc1JlYWRhYmxlU3RyZWFtQllPQlJlYWRlcihyZWFkZXIpKTtcblxuICAgIHJlYWRlci5fcmVhZEludG9SZXF1ZXN0cy5mb3JFYWNoKHJlYWRJbnRvUmVxdWVzdCA9PiB7XG4gICAgICByZWFkSW50b1JlcXVlc3QuX2Vycm9yU3RlcHMoZSk7XG4gICAgfSk7XG5cbiAgICByZWFkZXIuX3JlYWRJbnRvUmVxdWVzdHMgPSBuZXcgU2ltcGxlUXVldWUoKTtcbiAgfVxufVxuXG4vLyBSZWFkZXJzXG5cbmV4cG9ydCB0eXBlIFJlYWRhYmxlU3RyZWFtUmVhZGVyPFI+ID0gUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyPFI+IHwgUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyO1xuXG5leHBvcnQge1xuICBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIsXG4gIFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlclxufTtcblxuLy8gQ29udHJvbGxlcnNcblxuZXhwb3J0IHtcbiAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcixcbiAgUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdCxcbiAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclxufTtcblxuLy8gSGVscGVyIGZ1bmN0aW9ucyBmb3IgdGhlIFJlYWRhYmxlU3RyZWFtLlxuXG5mdW5jdGlvbiBzdHJlYW1CcmFuZENoZWNrRXhjZXB0aW9uKG5hbWU6IHN0cmluZyk6IFR5cGVFcnJvciB7XG4gIHJldHVybiBuZXcgVHlwZUVycm9yKGBSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGUuJHtuYW1lfSBjYW4gb25seSBiZSB1c2VkIG9uIGEgUmVhZGFibGVTdHJlYW1gKTtcbn1cbiIsICJpbXBvcnQgeyBRdWV1aW5nU3RyYXRlZ3lJbml0IH0gZnJvbSAnLi4vcXVldWluZy1zdHJhdGVneSc7XG5pbXBvcnQgeyBhc3NlcnREaWN0aW9uYXJ5LCBhc3NlcnRSZXF1aXJlZEZpZWxkLCBjb252ZXJ0VW5yZXN0cmljdGVkRG91YmxlIH0gZnJvbSAnLi9iYXNpYyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0UXVldWluZ1N0cmF0ZWd5SW5pdChpbml0OiBRdWV1aW5nU3RyYXRlZ3lJbml0IHwgbnVsbCB8IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiBzdHJpbmcpOiBRdWV1aW5nU3RyYXRlZ3lJbml0IHtcbiAgYXNzZXJ0RGljdGlvbmFyeShpbml0LCBjb250ZXh0KTtcbiAgY29uc3QgaGlnaFdhdGVyTWFyayA9IGluaXQ/LmhpZ2hXYXRlck1hcms7XG4gIGFzc2VydFJlcXVpcmVkRmllbGQoaGlnaFdhdGVyTWFyaywgJ2hpZ2hXYXRlck1hcmsnLCAnUXVldWluZ1N0cmF0ZWd5SW5pdCcpO1xuICByZXR1cm4ge1xuICAgIGhpZ2hXYXRlck1hcms6IGNvbnZlcnRVbnJlc3RyaWN0ZWREb3VibGUoaGlnaFdhdGVyTWFyaylcbiAgfTtcbn1cbiIsICJpbXBvcnQgeyBRdWV1aW5nU3RyYXRlZ3ksIFF1ZXVpbmdTdHJhdGVneUluaXQgfSBmcm9tICcuL3F1ZXVpbmctc3RyYXRlZ3knO1xuaW1wb3J0IHsgdHlwZUlzT2JqZWN0IH0gZnJvbSAnLi9oZWxwZXJzL21pc2NlbGxhbmVvdXMnO1xuaW1wb3J0IHsgYXNzZXJ0UmVxdWlyZWRBcmd1bWVudCB9IGZyb20gJy4vdmFsaWRhdG9ycy9iYXNpYyc7XG5pbXBvcnQgeyBjb252ZXJ0UXVldWluZ1N0cmF0ZWd5SW5pdCB9IGZyb20gJy4vdmFsaWRhdG9ycy9xdWV1aW5nLXN0cmF0ZWd5LWluaXQnO1xuXG4vLyBUaGUgc2l6ZSBmdW5jdGlvbiBtdXN0IG5vdCBoYXZlIGEgcHJvdG90eXBlIHByb3BlcnR5IG5vciBiZSBhIGNvbnN0cnVjdG9yXG5jb25zdCBieXRlTGVuZ3RoU2l6ZUZ1bmN0aW9uID0gKGNodW5rOiBBcnJheUJ1ZmZlclZpZXcpOiBudW1iZXIgPT4ge1xuICByZXR1cm4gY2h1bmsuYnl0ZUxlbmd0aDtcbn07XG50cnkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYnl0ZUxlbmd0aFNpemVGdW5jdGlvbiwgJ25hbWUnLCB7XG4gICAgdmFsdWU6ICdzaXplJyxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59IGNhdGNoIHtcbiAgLy8gVGhpcyBwcm9wZXJ0eSBpcyBub24tY29uZmlndXJhYmxlIGluIG9sZGVyIGJyb3dzZXJzLCBzbyBpZ25vcmUgaWYgdGhpcyB0aHJvd3MuXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0Z1bmN0aW9uL25hbWUjYnJvd3Nlcl9jb21wYXRpYmlsaXR5XG59XG5cbi8qKlxuICogQSBxdWV1aW5nIHN0cmF0ZWd5IHRoYXQgY291bnRzIHRoZSBudW1iZXIgb2YgYnl0ZXMgaW4gZWFjaCBjaHVuay5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJ5dGVMZW5ndGhRdWV1aW5nU3RyYXRlZ3kgaW1wbGVtZW50cyBRdWV1aW5nU3RyYXRlZ3k8QXJyYXlCdWZmZXJWaWV3PiB7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcmVhZG9ubHkgX2J5dGVMZW5ndGhRdWV1aW5nU3RyYXRlZ3lIaWdoV2F0ZXJNYXJrOiBudW1iZXI7XG5cbiAgY29uc3RydWN0b3Iob3B0aW9uczogUXVldWluZ1N0cmF0ZWd5SW5pdCkge1xuICAgIGFzc2VydFJlcXVpcmVkQXJndW1lbnQob3B0aW9ucywgMSwgJ0J5dGVMZW5ndGhRdWV1aW5nU3RyYXRlZ3knKTtcbiAgICBvcHRpb25zID0gY29udmVydFF1ZXVpbmdTdHJhdGVneUluaXQob3B0aW9ucywgJ0ZpcnN0IHBhcmFtZXRlcicpO1xuICAgIHRoaXMuX2J5dGVMZW5ndGhRdWV1aW5nU3RyYXRlZ3lIaWdoV2F0ZXJNYXJrID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGhpZ2ggd2F0ZXIgbWFyayBwcm92aWRlZCB0byB0aGUgY29uc3RydWN0b3IuXG4gICAqL1xuICBnZXQgaGlnaFdhdGVyTWFyaygpOiBudW1iZXIge1xuICAgIGlmICghSXNCeXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5KHRoaXMpKSB7XG4gICAgICB0aHJvdyBieXRlTGVuZ3RoQnJhbmRDaGVja0V4Y2VwdGlvbignaGlnaFdhdGVyTWFyaycpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fYnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneUhpZ2hXYXRlck1hcms7XG4gIH1cblxuICAvKipcbiAgICogTWVhc3VyZXMgdGhlIHNpemUgb2YgYGNodW5rYCBieSByZXR1cm5pbmcgdGhlIHZhbHVlIG9mIGl0cyBgYnl0ZUxlbmd0aGAgcHJvcGVydHkuXG4gICAqL1xuICBnZXQgc2l6ZSgpOiAoY2h1bms6IEFycmF5QnVmZmVyVmlldykgPT4gbnVtYmVyIHtcbiAgICBpZiAoIUlzQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneSh0aGlzKSkge1xuICAgICAgdGhyb3cgYnl0ZUxlbmd0aEJyYW5kQ2hlY2tFeGNlcHRpb24oJ3NpemUnKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVMZW5ndGhTaXplRnVuY3Rpb247XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneS5wcm90b3R5cGUsIHtcbiAgaGlnaFdhdGVyTWFyazogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gIHNpemU6IHsgZW51bWVyYWJsZTogdHJ1ZSB9XG59KTtcbmlmICh0eXBlb2YgU3ltYm9sLnRvU3RyaW5nVGFnID09PSAnc3ltYm9sJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneS5wcm90b3R5cGUsIFN5bWJvbC50b1N0cmluZ1RhZywge1xuICAgIHZhbHVlOiAnQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneScsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG4vLyBIZWxwZXIgZnVuY3Rpb25zIGZvciB0aGUgQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneS5cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aEJyYW5kQ2hlY2tFeGNlcHRpb24obmFtZTogc3RyaW5nKTogVHlwZUVycm9yIHtcbiAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoYEJ5dGVMZW5ndGhRdWV1aW5nU3RyYXRlZ3kucHJvdG90eXBlLiR7bmFtZX0gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIEJ5dGVMZW5ndGhRdWV1aW5nU3RyYXRlZ3lgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIElzQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneSh4OiBhbnkpOiB4IGlzIEJ5dGVMZW5ndGhRdWV1aW5nU3RyYXRlZ3kge1xuICBpZiAoIXR5cGVJc09iamVjdCh4KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdfYnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneUhpZ2hXYXRlck1hcmsnKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB4IGluc3RhbmNlb2YgQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneTtcbn1cbiIsICJpbXBvcnQgeyBRdWV1aW5nU3RyYXRlZ3ksIFF1ZXVpbmdTdHJhdGVneUluaXQgfSBmcm9tICcuL3F1ZXVpbmctc3RyYXRlZ3knO1xuaW1wb3J0IHsgdHlwZUlzT2JqZWN0IH0gZnJvbSAnLi9oZWxwZXJzL21pc2NlbGxhbmVvdXMnO1xuaW1wb3J0IHsgYXNzZXJ0UmVxdWlyZWRBcmd1bWVudCB9IGZyb20gJy4vdmFsaWRhdG9ycy9iYXNpYyc7XG5pbXBvcnQgeyBjb252ZXJ0UXVldWluZ1N0cmF0ZWd5SW5pdCB9IGZyb20gJy4vdmFsaWRhdG9ycy9xdWV1aW5nLXN0cmF0ZWd5LWluaXQnO1xuXG4vLyBUaGUgc2l6ZSBmdW5jdGlvbiBtdXN0IG5vdCBoYXZlIGEgcHJvdG90eXBlIHByb3BlcnR5IG5vciBiZSBhIGNvbnN0cnVjdG9yXG5jb25zdCBjb3VudFNpemVGdW5jdGlvbiA9ICgpOiAxID0+IHtcbiAgcmV0dXJuIDE7XG59O1xudHJ5IHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvdW50U2l6ZUZ1bmN0aW9uLCAnbmFtZScsIHtcbiAgICB2YWx1ZTogJ3NpemUnLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn0gY2F0Y2gge1xuICAvLyBUaGlzIHByb3BlcnR5IGlzIG5vbi1jb25maWd1cmFibGUgaW4gb2xkZXIgYnJvd3NlcnMsIHNvIGlnbm9yZSBpZiB0aGlzIHRocm93cy5cbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRnVuY3Rpb24vbmFtZSNicm93c2VyX2NvbXBhdGliaWxpdHlcbn1cblxuLyoqXG4gKiBBIHF1ZXVpbmcgc3RyYXRlZ3kgdGhhdCBjb3VudHMgdGhlIG51bWJlciBvZiBjaHVua3MuXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb3VudFF1ZXVpbmdTdHJhdGVneSBpbXBsZW1lbnRzIFF1ZXVpbmdTdHJhdGVneTxhbnk+IHtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICByZWFkb25seSBfY291bnRRdWV1aW5nU3RyYXRlZ3lIaWdoV2F0ZXJNYXJrITogbnVtYmVyO1xuXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnM6IFF1ZXVpbmdTdHJhdGVneUluaXQpIHtcbiAgICBhc3NlcnRSZXF1aXJlZEFyZ3VtZW50KG9wdGlvbnMsIDEsICdDb3VudFF1ZXVpbmdTdHJhdGVneScpO1xuICAgIG9wdGlvbnMgPSBjb252ZXJ0UXVldWluZ1N0cmF0ZWd5SW5pdChvcHRpb25zLCAnRmlyc3QgcGFyYW1ldGVyJyk7XG4gICAgdGhpcy5fY291bnRRdWV1aW5nU3RyYXRlZ3lIaWdoV2F0ZXJNYXJrID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGhpZ2ggd2F0ZXIgbWFyayBwcm92aWRlZCB0byB0aGUgY29uc3RydWN0b3IuXG4gICAqL1xuICBnZXQgaGlnaFdhdGVyTWFyaygpOiBudW1iZXIge1xuICAgIGlmICghSXNDb3VudFF1ZXVpbmdTdHJhdGVneSh0aGlzKSkge1xuICAgICAgdGhyb3cgY291bnRCcmFuZENoZWNrRXhjZXB0aW9uKCdoaWdoV2F0ZXJNYXJrJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jb3VudFF1ZXVpbmdTdHJhdGVneUhpZ2hXYXRlck1hcms7XG4gIH1cblxuICAvKipcbiAgICogTWVhc3VyZXMgdGhlIHNpemUgb2YgYGNodW5rYCBieSBhbHdheXMgcmV0dXJuaW5nIDEuXG4gICAqIFRoaXMgZW5zdXJlcyB0aGF0IHRoZSB0b3RhbCBxdWV1ZSBzaXplIGlzIGEgY291bnQgb2YgdGhlIG51bWJlciBvZiBjaHVua3MgaW4gdGhlIHF1ZXVlLlxuICAgKi9cbiAgZ2V0IHNpemUoKTogKGNodW5rOiBhbnkpID0+IDEge1xuICAgIGlmICghSXNDb3VudFF1ZXVpbmdTdHJhdGVneSh0aGlzKSkge1xuICAgICAgdGhyb3cgY291bnRCcmFuZENoZWNrRXhjZXB0aW9uKCdzaXplJyk7XG4gICAgfVxuICAgIHJldHVybiBjb3VudFNpemVGdW5jdGlvbjtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhDb3VudFF1ZXVpbmdTdHJhdGVneS5wcm90b3R5cGUsIHtcbiAgaGlnaFdhdGVyTWFyazogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gIHNpemU6IHsgZW51bWVyYWJsZTogdHJ1ZSB9XG59KTtcbmlmICh0eXBlb2YgU3ltYm9sLnRvU3RyaW5nVGFnID09PSAnc3ltYm9sJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ291bnRRdWV1aW5nU3RyYXRlZ3kucHJvdG90eXBlLCBTeW1ib2wudG9TdHJpbmdUYWcsIHtcbiAgICB2YWx1ZTogJ0NvdW50UXVldWluZ1N0cmF0ZWd5JyxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbi8vIEhlbHBlciBmdW5jdGlvbnMgZm9yIHRoZSBDb3VudFF1ZXVpbmdTdHJhdGVneS5cblxuZnVuY3Rpb24gY291bnRCcmFuZENoZWNrRXhjZXB0aW9uKG5hbWU6IHN0cmluZyk6IFR5cGVFcnJvciB7XG4gIHJldHVybiBuZXcgVHlwZUVycm9yKGBDb3VudFF1ZXVpbmdTdHJhdGVneS5wcm90b3R5cGUuJHtuYW1lfSBjYW4gb25seSBiZSB1c2VkIG9uIGEgQ291bnRRdWV1aW5nU3RyYXRlZ3lgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIElzQ291bnRRdWV1aW5nU3RyYXRlZ3koeDogYW55KTogeCBpcyBDb3VudFF1ZXVpbmdTdHJhdGVneSB7XG4gIGlmICghdHlwZUlzT2JqZWN0KHgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ19jb3VudFF1ZXVpbmdTdHJhdGVneUhpZ2hXYXRlck1hcmsnKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB4IGluc3RhbmNlb2YgQ291bnRRdWV1aW5nU3RyYXRlZ3k7XG59XG4iLCAiaW1wb3J0IHsgYXNzZXJ0RGljdGlvbmFyeSwgYXNzZXJ0RnVuY3Rpb24gfSBmcm9tICcuL2Jhc2ljJztcbmltcG9ydCB7IHByb21pc2VDYWxsLCByZWZsZWN0Q2FsbCB9IGZyb20gJy4uL2hlbHBlcnMvd2ViaWRsJztcbmltcG9ydCB7XG4gIFRyYW5zZm9ybWVyLFxuICBUcmFuc2Zvcm1lckZsdXNoQ2FsbGJhY2ssXG4gIFRyYW5zZm9ybWVyU3RhcnRDYWxsYmFjayxcbiAgVHJhbnNmb3JtZXJUcmFuc2Zvcm1DYWxsYmFjayxcbiAgVmFsaWRhdGVkVHJhbnNmb3JtZXJcbn0gZnJvbSAnLi4vdHJhbnNmb3JtLXN0cmVhbS90cmFuc2Zvcm1lcic7XG5pbXBvcnQgeyBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlciB9IGZyb20gJy4uL3RyYW5zZm9ybS1zdHJlYW0nO1xuXG5leHBvcnQgZnVuY3Rpb24gY29udmVydFRyYW5zZm9ybWVyPEksIE8+KG9yaWdpbmFsOiBUcmFuc2Zvcm1lcjxJLCBPPiB8IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IHN0cmluZyk6IFZhbGlkYXRlZFRyYW5zZm9ybWVyPEksIE8+IHtcbiAgYXNzZXJ0RGljdGlvbmFyeShvcmlnaW5hbCwgY29udGV4dCk7XG4gIGNvbnN0IGZsdXNoID0gb3JpZ2luYWw/LmZsdXNoO1xuICBjb25zdCByZWFkYWJsZVR5cGUgPSBvcmlnaW5hbD8ucmVhZGFibGVUeXBlO1xuICBjb25zdCBzdGFydCA9IG9yaWdpbmFsPy5zdGFydDtcbiAgY29uc3QgdHJhbnNmb3JtID0gb3JpZ2luYWw/LnRyYW5zZm9ybTtcbiAgY29uc3Qgd3JpdGFibGVUeXBlID0gb3JpZ2luYWw/LndyaXRhYmxlVHlwZTtcbiAgcmV0dXJuIHtcbiAgICBmbHVzaDogZmx1c2ggPT09IHVuZGVmaW5lZCA/XG4gICAgICB1bmRlZmluZWQgOlxuICAgICAgY29udmVydFRyYW5zZm9ybWVyRmx1c2hDYWxsYmFjayhmbHVzaCwgb3JpZ2luYWwhLCBgJHtjb250ZXh0fSBoYXMgbWVtYmVyICdmbHVzaCcgdGhhdGApLFxuICAgIHJlYWRhYmxlVHlwZSxcbiAgICBzdGFydDogc3RhcnQgPT09IHVuZGVmaW5lZCA/XG4gICAgICB1bmRlZmluZWQgOlxuICAgICAgY29udmVydFRyYW5zZm9ybWVyU3RhcnRDYWxsYmFjayhzdGFydCwgb3JpZ2luYWwhLCBgJHtjb250ZXh0fSBoYXMgbWVtYmVyICdzdGFydCcgdGhhdGApLFxuICAgIHRyYW5zZm9ybTogdHJhbnNmb3JtID09PSB1bmRlZmluZWQgP1xuICAgICAgdW5kZWZpbmVkIDpcbiAgICAgIGNvbnZlcnRUcmFuc2Zvcm1lclRyYW5zZm9ybUNhbGxiYWNrKHRyYW5zZm9ybSwgb3JpZ2luYWwhLCBgJHtjb250ZXh0fSBoYXMgbWVtYmVyICd0cmFuc2Zvcm0nIHRoYXRgKSxcbiAgICB3cml0YWJsZVR5cGVcbiAgfTtcbn1cblxuZnVuY3Rpb24gY29udmVydFRyYW5zZm9ybWVyRmx1c2hDYWxsYmFjazxJLCBPPihcbiAgZm46IFRyYW5zZm9ybWVyRmx1c2hDYWxsYmFjazxPPixcbiAgb3JpZ2luYWw6IFRyYW5zZm9ybWVyPEksIE8+LFxuICBjb250ZXh0OiBzdHJpbmdcbik6IChjb250cm9sbGVyOiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxPPikgPT4gUHJvbWlzZTx2b2lkPiB7XG4gIGFzc2VydEZ1bmN0aW9uKGZuLCBjb250ZXh0KTtcbiAgcmV0dXJuIChjb250cm9sbGVyOiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxPPikgPT4gcHJvbWlzZUNhbGwoZm4sIG9yaWdpbmFsLCBbY29udHJvbGxlcl0pO1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0VHJhbnNmb3JtZXJTdGFydENhbGxiYWNrPEksIE8+KFxuICBmbjogVHJhbnNmb3JtZXJTdGFydENhbGxiYWNrPE8+LFxuICBvcmlnaW5hbDogVHJhbnNmb3JtZXI8SSwgTz4sXG4gIGNvbnRleHQ6IHN0cmluZ1xuKTogVHJhbnNmb3JtZXJTdGFydENhbGxiYWNrPE8+IHtcbiAgYXNzZXJ0RnVuY3Rpb24oZm4sIGNvbnRleHQpO1xuICByZXR1cm4gKGNvbnRyb2xsZXI6IFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyPE8+KSA9PiByZWZsZWN0Q2FsbChmbiwgb3JpZ2luYWwsIFtjb250cm9sbGVyXSk7XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRUcmFuc2Zvcm1lclRyYW5zZm9ybUNhbGxiYWNrPEksIE8+KFxuICBmbjogVHJhbnNmb3JtZXJUcmFuc2Zvcm1DYWxsYmFjazxJLCBPPixcbiAgb3JpZ2luYWw6IFRyYW5zZm9ybWVyPEksIE8+LFxuICBjb250ZXh0OiBzdHJpbmdcbik6IChjaHVuazogSSwgY29udHJvbGxlcjogVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8Tz4pID0+IFByb21pc2U8dm9pZD4ge1xuICBhc3NlcnRGdW5jdGlvbihmbiwgY29udGV4dCk7XG4gIHJldHVybiAoY2h1bms6IEksIGNvbnRyb2xsZXI6IFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyPE8+KSA9PiBwcm9taXNlQ2FsbChmbiwgb3JpZ2luYWwsIFtjaHVuaywgY29udHJvbGxlcl0pO1xufVxuIiwgImltcG9ydCBhc3NlcnQgZnJvbSAnLi4vc3R1Yi9hc3NlcnQnO1xuaW1wb3J0IHsgbmV3UHJvbWlzZSwgcHJvbWlzZVJlamVjdGVkV2l0aCwgcHJvbWlzZVJlc29sdmVkV2l0aCwgdHJhbnNmb3JtUHJvbWlzZVdpdGggfSBmcm9tICcuL2hlbHBlcnMvd2ViaWRsJztcbmltcG9ydCB7IENyZWF0ZVJlYWRhYmxlU3RyZWFtLCBSZWFkYWJsZVN0cmVhbSwgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlciB9IGZyb20gJy4vcmVhZGFibGUtc3RyZWFtJztcbmltcG9ydCB7XG4gIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDYW5DbG9zZU9yRW5xdWV1ZSxcbiAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsb3NlLFxuICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRW5xdWV1ZSxcbiAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9yLFxuICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyR2V0RGVzaXJlZFNpemUsXG4gIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJIYXNCYWNrcHJlc3N1cmVcbn0gZnJvbSAnLi9yZWFkYWJsZS1zdHJlYW0vZGVmYXVsdC1jb250cm9sbGVyJztcbmltcG9ydCB7IFF1ZXVpbmdTdHJhdGVneSwgUXVldWluZ1N0cmF0ZWd5U2l6ZUNhbGxiYWNrIH0gZnJvbSAnLi9xdWV1aW5nLXN0cmF0ZWd5JztcbmltcG9ydCB7IENyZWF0ZVdyaXRhYmxlU3RyZWFtLCBXcml0YWJsZVN0cmVhbSwgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9ySWZOZWVkZWQgfSBmcm9tICcuL3dyaXRhYmxlLXN0cmVhbSc7XG5pbXBvcnQgeyB0eXBlSXNPYmplY3QgfSBmcm9tICcuL2hlbHBlcnMvbWlzY2VsbGFuZW91cyc7XG5pbXBvcnQgeyBJc05vbk5lZ2F0aXZlTnVtYmVyIH0gZnJvbSAnLi9hYnN0cmFjdC1vcHMvbWlzY2VsbGFuZW91cyc7XG5pbXBvcnQgeyBjb252ZXJ0UXVldWluZ1N0cmF0ZWd5IH0gZnJvbSAnLi92YWxpZGF0b3JzL3F1ZXVpbmctc3RyYXRlZ3knO1xuaW1wb3J0IHsgRXh0cmFjdEhpZ2hXYXRlck1hcmssIEV4dHJhY3RTaXplQWxnb3JpdGhtIH0gZnJvbSAnLi9hYnN0cmFjdC1vcHMvcXVldWluZy1zdHJhdGVneSc7XG5pbXBvcnQge1xuICBUcmFuc2Zvcm1lcixcbiAgVHJhbnNmb3JtZXJGbHVzaENhbGxiYWNrLFxuICBUcmFuc2Zvcm1lclN0YXJ0Q2FsbGJhY2ssXG4gIFRyYW5zZm9ybWVyVHJhbnNmb3JtQ2FsbGJhY2ssXG4gIFZhbGlkYXRlZFRyYW5zZm9ybWVyXG59IGZyb20gJy4vdHJhbnNmb3JtLXN0cmVhbS90cmFuc2Zvcm1lcic7XG5pbXBvcnQgeyBjb252ZXJ0VHJhbnNmb3JtZXIgfSBmcm9tICcuL3ZhbGlkYXRvcnMvdHJhbnNmb3JtZXInO1xuXG4vLyBDbGFzcyBUcmFuc2Zvcm1TdHJlYW1cblxuLyoqXG4gKiBBIHRyYW5zZm9ybSBzdHJlYW0gY29uc2lzdHMgb2YgYSBwYWlyIG9mIHN0cmVhbXM6IGEge0BsaW5rIFdyaXRhYmxlU3RyZWFtIHwgd3JpdGFibGUgc3RyZWFtfSxcbiAqIGtub3duIGFzIGl0cyB3cml0YWJsZSBzaWRlLCBhbmQgYSB7QGxpbmsgUmVhZGFibGVTdHJlYW0gfCByZWFkYWJsZSBzdHJlYW19LCBrbm93biBhcyBpdHMgcmVhZGFibGUgc2lkZS5cbiAqIEluIGEgbWFubmVyIHNwZWNpZmljIHRvIHRoZSB0cmFuc2Zvcm0gc3RyZWFtIGluIHF1ZXN0aW9uLCB3cml0ZXMgdG8gdGhlIHdyaXRhYmxlIHNpZGUgcmVzdWx0IGluIG5ldyBkYXRhIGJlaW5nXG4gKiBtYWRlIGF2YWlsYWJsZSBmb3IgcmVhZGluZyBmcm9tIHRoZSByZWFkYWJsZSBzaWRlLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNsYXNzIFRyYW5zZm9ybVN0cmVhbTxJID0gYW55LCBPID0gYW55PiB7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3dyaXRhYmxlITogV3JpdGFibGVTdHJlYW08ST47XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3JlYWRhYmxlITogUmVhZGFibGVTdHJlYW08Tz47XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2JhY2twcmVzc3VyZSE6IGJvb2xlYW47XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2JhY2twcmVzc3VyZUNoYW5nZVByb21pc2UhOiBQcm9taXNlPHZvaWQ+O1xuICAvKiogQGludGVybmFsICovXG4gIF9iYWNrcHJlc3N1cmVDaGFuZ2VQcm9taXNlX3Jlc29sdmUhOiAoKSA9PiB2b2lkO1xuICAvKiogQGludGVybmFsICovXG4gIF90cmFuc2Zvcm1TdHJlYW1Db250cm9sbGVyITogVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8Tz47XG5cbiAgY29uc3RydWN0b3IoXG4gICAgdHJhbnNmb3JtZXI/OiBUcmFuc2Zvcm1lcjxJLCBPPixcbiAgICB3cml0YWJsZVN0cmF0ZWd5PzogUXVldWluZ1N0cmF0ZWd5PEk+LFxuICAgIHJlYWRhYmxlU3RyYXRlZ3k/OiBRdWV1aW5nU3RyYXRlZ3k8Tz5cbiAgKTtcbiAgY29uc3RydWN0b3IocmF3VHJhbnNmb3JtZXI6IFRyYW5zZm9ybWVyPEksIE8+IHwgbnVsbCB8IHVuZGVmaW5lZCA9IHt9LFxuICAgICAgICAgICAgICByYXdXcml0YWJsZVN0cmF0ZWd5OiBRdWV1aW5nU3RyYXRlZ3k8ST4gfCBudWxsIHwgdW5kZWZpbmVkID0ge30sXG4gICAgICAgICAgICAgIHJhd1JlYWRhYmxlU3RyYXRlZ3k6IFF1ZXVpbmdTdHJhdGVneTxPPiB8IG51bGwgfCB1bmRlZmluZWQgPSB7fSkge1xuICAgIGlmIChyYXdUcmFuc2Zvcm1lciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByYXdUcmFuc2Zvcm1lciA9IG51bGw7XG4gICAgfVxuXG4gICAgY29uc3Qgd3JpdGFibGVTdHJhdGVneSA9IGNvbnZlcnRRdWV1aW5nU3RyYXRlZ3kocmF3V3JpdGFibGVTdHJhdGVneSwgJ1NlY29uZCBwYXJhbWV0ZXInKTtcbiAgICBjb25zdCByZWFkYWJsZVN0cmF0ZWd5ID0gY29udmVydFF1ZXVpbmdTdHJhdGVneShyYXdSZWFkYWJsZVN0cmF0ZWd5LCAnVGhpcmQgcGFyYW1ldGVyJyk7XG5cbiAgICBjb25zdCB0cmFuc2Zvcm1lciA9IGNvbnZlcnRUcmFuc2Zvcm1lcihyYXdUcmFuc2Zvcm1lciwgJ0ZpcnN0IHBhcmFtZXRlcicpO1xuICAgIGlmICh0cmFuc2Zvcm1lci5yZWFkYWJsZVR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgcmVhZGFibGVUeXBlIHNwZWNpZmllZCcpO1xuICAgIH1cbiAgICBpZiAodHJhbnNmb3JtZXIud3JpdGFibGVUeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHdyaXRhYmxlVHlwZSBzcGVjaWZpZWQnKTtcbiAgICB9XG5cbiAgICBjb25zdCByZWFkYWJsZUhpZ2hXYXRlck1hcmsgPSBFeHRyYWN0SGlnaFdhdGVyTWFyayhyZWFkYWJsZVN0cmF0ZWd5LCAwKTtcbiAgICBjb25zdCByZWFkYWJsZVNpemVBbGdvcml0aG0gPSBFeHRyYWN0U2l6ZUFsZ29yaXRobShyZWFkYWJsZVN0cmF0ZWd5KTtcbiAgICBjb25zdCB3cml0YWJsZUhpZ2hXYXRlck1hcmsgPSBFeHRyYWN0SGlnaFdhdGVyTWFyayh3cml0YWJsZVN0cmF0ZWd5LCAxKTtcbiAgICBjb25zdCB3cml0YWJsZVNpemVBbGdvcml0aG0gPSBFeHRyYWN0U2l6ZUFsZ29yaXRobSh3cml0YWJsZVN0cmF0ZWd5KTtcblxuICAgIGxldCBzdGFydFByb21pc2VfcmVzb2x2ZSE6ICh2YWx1ZTogdm9pZCB8IFByb21pc2VMaWtlPHZvaWQ+KSA9PiB2b2lkO1xuICAgIGNvbnN0IHN0YXJ0UHJvbWlzZSA9IG5ld1Byb21pc2U8dm9pZD4ocmVzb2x2ZSA9PiB7XG4gICAgICBzdGFydFByb21pc2VfcmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgfSk7XG5cbiAgICBJbml0aWFsaXplVHJhbnNmb3JtU3RyZWFtKFxuICAgICAgdGhpcywgc3RhcnRQcm9taXNlLCB3cml0YWJsZUhpZ2hXYXRlck1hcmssIHdyaXRhYmxlU2l6ZUFsZ29yaXRobSwgcmVhZGFibGVIaWdoV2F0ZXJNYXJrLCByZWFkYWJsZVNpemVBbGdvcml0aG1cbiAgICApO1xuICAgIFNldFVwVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJGcm9tVHJhbnNmb3JtZXIodGhpcywgdHJhbnNmb3JtZXIpO1xuXG4gICAgaWYgKHRyYW5zZm9ybWVyLnN0YXJ0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHN0YXJ0UHJvbWlzZV9yZXNvbHZlKHRyYW5zZm9ybWVyLnN0YXJ0KHRoaXMuX3RyYW5zZm9ybVN0cmVhbUNvbnRyb2xsZXIpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhcnRQcm9taXNlX3Jlc29sdmUodW5kZWZpbmVkKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVGhlIHJlYWRhYmxlIHNpZGUgb2YgdGhlIHRyYW5zZm9ybSBzdHJlYW0uXG4gICAqL1xuICBnZXQgcmVhZGFibGUoKTogUmVhZGFibGVTdHJlYW08Tz4ge1xuICAgIGlmICghSXNUcmFuc2Zvcm1TdHJlYW0odGhpcykpIHtcbiAgICAgIHRocm93IHN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24oJ3JlYWRhYmxlJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSB3cml0YWJsZSBzaWRlIG9mIHRoZSB0cmFuc2Zvcm0gc3RyZWFtLlxuICAgKi9cbiAgZ2V0IHdyaXRhYmxlKCk6IFdyaXRhYmxlU3RyZWFtPEk+IHtcbiAgICBpZiAoIUlzVHJhbnNmb3JtU3RyZWFtKHRoaXMpKSB7XG4gICAgICB0aHJvdyBzdHJlYW1CcmFuZENoZWNrRXhjZXB0aW9uKCd3cml0YWJsZScpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl93cml0YWJsZTtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhUcmFuc2Zvcm1TdHJlYW0ucHJvdG90eXBlLCB7XG4gIHJlYWRhYmxlOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgd3JpdGFibGU6IHsgZW51bWVyYWJsZTogdHJ1ZSB9XG59KTtcbmlmICh0eXBlb2YgU3ltYm9sLnRvU3RyaW5nVGFnID09PSAnc3ltYm9sJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVHJhbnNmb3JtU3RyZWFtLnByb3RvdHlwZSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7XG4gICAgdmFsdWU6ICdUcmFuc2Zvcm1TdHJlYW0nLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuZXhwb3J0IHtcbiAgVHJhbnNmb3JtZXIsXG4gIFRyYW5zZm9ybWVyU3RhcnRDYWxsYmFjayxcbiAgVHJhbnNmb3JtZXJGbHVzaENhbGxiYWNrLFxuICBUcmFuc2Zvcm1lclRyYW5zZm9ybUNhbGxiYWNrXG59O1xuXG4vLyBUcmFuc2Zvcm0gU3RyZWFtIEFic3RyYWN0IE9wZXJhdGlvbnNcblxuZXhwb3J0IGZ1bmN0aW9uIENyZWF0ZVRyYW5zZm9ybVN0cmVhbTxJLCBPPihzdGFydEFsZ29yaXRobTogKCkgPT4gdm9pZCB8IFByb21pc2VMaWtlPHZvaWQ+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1BbGdvcml0aG06IChjaHVuazogSSkgPT4gUHJvbWlzZTx2b2lkPixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmx1c2hBbGdvcml0aG06ICgpID0+IFByb21pc2U8dm9pZD4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlSGlnaFdhdGVyTWFyayA9IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlU2l6ZUFsZ29yaXRobTogUXVldWluZ1N0cmF0ZWd5U2l6ZUNhbGxiYWNrPEk+ID0gKCkgPT4gMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZGFibGVIaWdoV2F0ZXJNYXJrID0gMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZGFibGVTaXplQWxnb3JpdGhtOiBRdWV1aW5nU3RyYXRlZ3lTaXplQ2FsbGJhY2s8Tz4gPSAoKSA9PiAxKSB7XG4gIGFzc2VydChJc05vbk5lZ2F0aXZlTnVtYmVyKHdyaXRhYmxlSGlnaFdhdGVyTWFyaykpO1xuICBhc3NlcnQoSXNOb25OZWdhdGl2ZU51bWJlcihyZWFkYWJsZUhpZ2hXYXRlck1hcmspKTtcblxuICBjb25zdCBzdHJlYW06IFRyYW5zZm9ybVN0cmVhbTxJLCBPPiA9IE9iamVjdC5jcmVhdGUoVHJhbnNmb3JtU3RyZWFtLnByb3RvdHlwZSk7XG5cbiAgbGV0IHN0YXJ0UHJvbWlzZV9yZXNvbHZlITogKHZhbHVlOiB2b2lkIHwgUHJvbWlzZUxpa2U8dm9pZD4pID0+IHZvaWQ7XG4gIGNvbnN0IHN0YXJ0UHJvbWlzZSA9IG5ld1Byb21pc2U8dm9pZD4ocmVzb2x2ZSA9PiB7XG4gICAgc3RhcnRQcm9taXNlX3Jlc29sdmUgPSByZXNvbHZlO1xuICB9KTtcblxuICBJbml0aWFsaXplVHJhbnNmb3JtU3RyZWFtKHN0cmVhbSwgc3RhcnRQcm9taXNlLCB3cml0YWJsZUhpZ2hXYXRlck1hcmssIHdyaXRhYmxlU2l6ZUFsZ29yaXRobSwgcmVhZGFibGVIaWdoV2F0ZXJNYXJrLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRhYmxlU2l6ZUFsZ29yaXRobSk7XG5cbiAgY29uc3QgY29udHJvbGxlcjogVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8Tz4gPSBPYmplY3QuY3JlYXRlKFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZSk7XG5cbiAgU2V0VXBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlcihzdHJlYW0sIGNvbnRyb2xsZXIsIHRyYW5zZm9ybUFsZ29yaXRobSwgZmx1c2hBbGdvcml0aG0pO1xuXG4gIGNvbnN0IHN0YXJ0UmVzdWx0ID0gc3RhcnRBbGdvcml0aG0oKTtcbiAgc3RhcnRQcm9taXNlX3Jlc29sdmUoc3RhcnRSZXN1bHQpO1xuICByZXR1cm4gc3RyZWFtO1xufVxuXG5mdW5jdGlvbiBJbml0aWFsaXplVHJhbnNmb3JtU3RyZWFtPEksIE8+KHN0cmVhbTogVHJhbnNmb3JtU3RyZWFtPEksIE8+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydFByb21pc2U6IFByb21pc2U8dm9pZD4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlSGlnaFdhdGVyTWFyazogbnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3cml0YWJsZVNpemVBbGdvcml0aG06IFF1ZXVpbmdTdHJhdGVneVNpemVDYWxsYmFjazxJPixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZGFibGVIaWdoV2F0ZXJNYXJrOiBudW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRhYmxlU2l6ZUFsZ29yaXRobTogUXVldWluZ1N0cmF0ZWd5U2l6ZUNhbGxiYWNrPE8+KSB7XG4gIGZ1bmN0aW9uIHN0YXJ0QWxnb3JpdGhtKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVybiBzdGFydFByb21pc2U7XG4gIH1cblxuICBmdW5jdGlvbiB3cml0ZUFsZ29yaXRobShjaHVuazogSSk6IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVybiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0U2lua1dyaXRlQWxnb3JpdGhtKHN0cmVhbSwgY2h1bmspO1xuICB9XG5cbiAgZnVuY3Rpb24gYWJvcnRBbGdvcml0aG0ocmVhc29uOiBhbnkpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICByZXR1cm4gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdFNpbmtBYm9ydEFsZ29yaXRobShzdHJlYW0sIHJlYXNvbik7XG4gIH1cblxuICBmdW5jdGlvbiBjbG9zZUFsZ29yaXRobSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICByZXR1cm4gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdFNpbmtDbG9zZUFsZ29yaXRobShzdHJlYW0pO1xuICB9XG5cbiAgc3RyZWFtLl93cml0YWJsZSA9IENyZWF0ZVdyaXRhYmxlU3RyZWFtKHN0YXJ0QWxnb3JpdGhtLCB3cml0ZUFsZ29yaXRobSwgY2xvc2VBbGdvcml0aG0sIGFib3J0QWxnb3JpdGhtLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGFibGVIaWdoV2F0ZXJNYXJrLCB3cml0YWJsZVNpemVBbGdvcml0aG0pO1xuXG4gIGZ1bmN0aW9uIHB1bGxBbGdvcml0aG0oKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgcmV0dXJuIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRTb3VyY2VQdWxsQWxnb3JpdGhtKHN0cmVhbSk7XG4gIH1cblxuICBmdW5jdGlvbiBjYW5jZWxBbGdvcml0aG0ocmVhc29uOiBhbnkpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBUcmFuc2Zvcm1TdHJlYW1FcnJvcldyaXRhYmxlQW5kVW5ibG9ja1dyaXRlKHN0cmVhbSwgcmVhc29uKTtcbiAgICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuICB9XG5cbiAgc3RyZWFtLl9yZWFkYWJsZSA9IENyZWF0ZVJlYWRhYmxlU3RyZWFtKHN0YXJ0QWxnb3JpdGhtLCBwdWxsQWxnb3JpdGhtLCBjYW5jZWxBbGdvcml0aG0sIHJlYWRhYmxlSGlnaFdhdGVyTWFyayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRhYmxlU2l6ZUFsZ29yaXRobSk7XG5cbiAgLy8gVGhlIFtbYmFja3ByZXNzdXJlXV0gc2xvdCBpcyBzZXQgdG8gdW5kZWZpbmVkIHNvIHRoYXQgaXQgY2FuIGJlIGluaXRpYWxpc2VkIGJ5IFRyYW5zZm9ybVN0cmVhbVNldEJhY2twcmVzc3VyZS5cbiAgc3RyZWFtLl9iYWNrcHJlc3N1cmUgPSB1bmRlZmluZWQhO1xuICBzdHJlYW0uX2JhY2twcmVzc3VyZUNoYW5nZVByb21pc2UgPSB1bmRlZmluZWQhO1xuICBzdHJlYW0uX2JhY2twcmVzc3VyZUNoYW5nZVByb21pc2VfcmVzb2x2ZSA9IHVuZGVmaW5lZCE7XG4gIFRyYW5zZm9ybVN0cmVhbVNldEJhY2twcmVzc3VyZShzdHJlYW0sIHRydWUpO1xuXG4gIHN0cmVhbS5fdHJhbnNmb3JtU3RyZWFtQ29udHJvbGxlciA9IHVuZGVmaW5lZCE7XG59XG5cbmZ1bmN0aW9uIElzVHJhbnNmb3JtU3RyZWFtKHg6IHVua25vd24pOiB4IGlzIFRyYW5zZm9ybVN0cmVhbSB7XG4gIGlmICghdHlwZUlzT2JqZWN0KHgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ190cmFuc2Zvcm1TdHJlYW1Db250cm9sbGVyJykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4geCBpbnN0YW5jZW9mIFRyYW5zZm9ybVN0cmVhbTtcbn1cblxuLy8gVGhpcyBpcyBhIG5vLW9wIGlmIGJvdGggc2lkZXMgYXJlIGFscmVhZHkgZXJyb3JlZC5cbmZ1bmN0aW9uIFRyYW5zZm9ybVN0cmVhbUVycm9yKHN0cmVhbTogVHJhbnNmb3JtU3RyZWFtLCBlOiBhbnkpIHtcbiAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9yKFxuICAgIHN0cmVhbS5fcmVhZGFibGUuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciBhcyBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyPGFueT4sXG4gICAgZVxuICApO1xuICBUcmFuc2Zvcm1TdHJlYW1FcnJvcldyaXRhYmxlQW5kVW5ibG9ja1dyaXRlKHN0cmVhbSwgZSk7XG59XG5cbmZ1bmN0aW9uIFRyYW5zZm9ybVN0cmVhbUVycm9yV3JpdGFibGVBbmRVbmJsb2NrV3JpdGUoc3RyZWFtOiBUcmFuc2Zvcm1TdHJlYW0sIGU6IGFueSkge1xuICBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyhzdHJlYW0uX3RyYW5zZm9ybVN0cmVhbUNvbnRyb2xsZXIpO1xuICBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3JJZk5lZWRlZChzdHJlYW0uX3dyaXRhYmxlLl93cml0YWJsZVN0cmVhbUNvbnRyb2xsZXIsIGUpO1xuICBpZiAoc3RyZWFtLl9iYWNrcHJlc3N1cmUpIHtcbiAgICAvLyBQcmV0ZW5kIHRoYXQgcHVsbCgpIHdhcyBjYWxsZWQgdG8gcGVybWl0IGFueSBwZW5kaW5nIHdyaXRlKCkgY2FsbHMgdG8gY29tcGxldGUuIFRyYW5zZm9ybVN0cmVhbVNldEJhY2twcmVzc3VyZSgpXG4gICAgLy8gY2Fubm90IGJlIGNhbGxlZCBmcm9tIGVucXVldWUoKSBvciBwdWxsKCkgb25jZSB0aGUgUmVhZGFibGVTdHJlYW0gaXMgZXJyb3JlZCwgc28gdGhpcyB3aWxsIHdpbGwgYmUgdGhlIGZpbmFsIHRpbWVcbiAgICAvLyBfYmFja3ByZXNzdXJlIGlzIHNldC5cbiAgICBUcmFuc2Zvcm1TdHJlYW1TZXRCYWNrcHJlc3N1cmUoc3RyZWFtLCBmYWxzZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gVHJhbnNmb3JtU3RyZWFtU2V0QmFja3ByZXNzdXJlKHN0cmVhbTogVHJhbnNmb3JtU3RyZWFtLCBiYWNrcHJlc3N1cmU6IGJvb2xlYW4pIHtcbiAgLy8gUGFzc2VzIGFsc28gd2hlbiBjYWxsZWQgZHVyaW5nIGNvbnN0cnVjdGlvbi5cbiAgYXNzZXJ0KHN0cmVhbS5fYmFja3ByZXNzdXJlICE9PSBiYWNrcHJlc3N1cmUpO1xuXG4gIGlmIChzdHJlYW0uX2JhY2twcmVzc3VyZUNoYW5nZVByb21pc2UgIT09IHVuZGVmaW5lZCkge1xuICAgIHN0cmVhbS5fYmFja3ByZXNzdXJlQ2hhbmdlUHJvbWlzZV9yZXNvbHZlKCk7XG4gIH1cblxuICBzdHJlYW0uX2JhY2twcmVzc3VyZUNoYW5nZVByb21pc2UgPSBuZXdQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgIHN0cmVhbS5fYmFja3ByZXNzdXJlQ2hhbmdlUHJvbWlzZV9yZXNvbHZlID0gcmVzb2x2ZTtcbiAgfSk7XG5cbiAgc3RyZWFtLl9iYWNrcHJlc3N1cmUgPSBiYWNrcHJlc3N1cmU7XG59XG5cbi8vIENsYXNzIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyXG5cbi8qKlxuICogQWxsb3dzIGNvbnRyb2wgb2YgdGhlIHtAbGluayBSZWFkYWJsZVN0cmVhbX0gYW5kIHtAbGluayBXcml0YWJsZVN0cmVhbX0gb2YgdGhlIGFzc29jaWF0ZWQge0BsaW5rIFRyYW5zZm9ybVN0cmVhbX0uXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8Tz4ge1xuICAvKiogQGludGVybmFsICovXG4gIF9jb250cm9sbGVkVHJhbnNmb3JtU3RyZWFtOiBUcmFuc2Zvcm1TdHJlYW08YW55LCBPPjtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfdHJhbnNmb3JtQWxnb3JpdGhtOiAoY2h1bms6IGFueSkgPT4gUHJvbWlzZTx2b2lkPjtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfZmx1c2hBbGdvcml0aG06ICgpID0+IFByb21pc2U8dm9pZD47XG5cbiAgcHJpdmF0ZSBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbGxlZ2FsIGNvbnN0cnVjdG9yJyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZGVzaXJlZCBzaXplIHRvIGZpbGwgdGhlIHJlYWRhYmxlIHNpZGXigJlzIGludGVybmFsIHF1ZXVlLiBJdCBjYW4gYmUgbmVnYXRpdmUsIGlmIHRoZSBxdWV1ZSBpcyBvdmVyLWZ1bGwuXG4gICAqL1xuICBnZXQgZGVzaXJlZFNpemUoKTogbnVtYmVyIHwgbnVsbCB7XG4gICAgaWYgKCFJc1RyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyKHRoaXMpKSB7XG4gICAgICB0aHJvdyBkZWZhdWx0Q29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ2Rlc2lyZWRTaXplJyk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVhZGFibGVDb250cm9sbGVyID0gdGhpcy5fY29udHJvbGxlZFRyYW5zZm9ybVN0cmVhbS5fcmVhZGFibGUuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcjtcbiAgICByZXR1cm4gUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckdldERlc2lyZWRTaXplKHJlYWRhYmxlQ29udHJvbGxlciBhcyBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyPE8+KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbnF1ZXVlcyB0aGUgZ2l2ZW4gY2h1bmsgYGNodW5rYCBpbiB0aGUgcmVhZGFibGUgc2lkZSBvZiB0aGUgY29udHJvbGxlZCB0cmFuc2Zvcm0gc3RyZWFtLlxuICAgKi9cbiAgZW5xdWV1ZShjaHVuazogTyk6IHZvaWQ7XG4gIGVucXVldWUoY2h1bms6IE8gPSB1bmRlZmluZWQhKTogdm9pZCB7XG4gICAgaWYgKCFJc1RyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyKHRoaXMpKSB7XG4gICAgICB0aHJvdyBkZWZhdWx0Q29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ2VucXVldWUnKTtcbiAgICB9XG5cbiAgICBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlckVucXVldWUodGhpcywgY2h1bmspO1xuICB9XG5cbiAgLyoqXG4gICAqIEVycm9ycyBib3RoIHRoZSByZWFkYWJsZSBzaWRlIGFuZCB0aGUgd3JpdGFibGUgc2lkZSBvZiB0aGUgY29udHJvbGxlZCB0cmFuc2Zvcm0gc3RyZWFtLCBtYWtpbmcgYWxsIGZ1dHVyZVxuICAgKiBpbnRlcmFjdGlvbnMgd2l0aCBpdCBmYWlsIHdpdGggdGhlIGdpdmVuIGVycm9yIGBlYC4gQW55IGNodW5rcyBxdWV1ZWQgZm9yIHRyYW5zZm9ybWF0aW9uIHdpbGwgYmUgZGlzY2FyZGVkLlxuICAgKi9cbiAgZXJyb3IocmVhc29uOiBhbnkgPSB1bmRlZmluZWQpOiB2b2lkIHtcbiAgICBpZiAoIUlzVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIodGhpcykpIHtcbiAgICAgIHRocm93IGRlZmF1bHRDb250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbignZXJyb3InKTtcbiAgICB9XG5cbiAgICBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9yKHRoaXMsIHJlYXNvbik7XG4gIH1cblxuICAvKipcbiAgICogQ2xvc2VzIHRoZSByZWFkYWJsZSBzaWRlIGFuZCBlcnJvcnMgdGhlIHdyaXRhYmxlIHNpZGUgb2YgdGhlIGNvbnRyb2xsZWQgdHJhbnNmb3JtIHN0cmVhbS4gVGhpcyBpcyB1c2VmdWwgd2hlbiB0aGVcbiAgICogdHJhbnNmb3JtZXIgb25seSBuZWVkcyB0byBjb25zdW1lIGEgcG9ydGlvbiBvZiB0aGUgY2h1bmtzIHdyaXR0ZW4gdG8gdGhlIHdyaXRhYmxlIHNpZGUuXG4gICAqL1xuICB0ZXJtaW5hdGUoKTogdm9pZCB7XG4gICAgaWYgKCFJc1RyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyKHRoaXMpKSB7XG4gICAgICB0aHJvdyBkZWZhdWx0Q29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ3Rlcm1pbmF0ZScpO1xuICAgIH1cblxuICAgIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyVGVybWluYXRlKHRoaXMpO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZSwge1xuICBlbnF1ZXVlOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgZXJyb3I6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICB0ZXJtaW5hdGU6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICBkZXNpcmVkU2l6ZTogeyBlbnVtZXJhYmxlOiB0cnVlIH1cbn0pO1xuaWYgKHR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWcgPT09ICdzeW1ib2wnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUsIFN5bWJvbC50b1N0cmluZ1RhZywge1xuICAgIHZhbHVlOiAnVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXInLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuLy8gVHJhbnNmb3JtIFN0cmVhbSBEZWZhdWx0IENvbnRyb2xsZXIgQWJzdHJhY3QgT3BlcmF0aW9uc1xuXG5mdW5jdGlvbiBJc1RyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyPE8gPSBhbnk+KHg6IGFueSk6IHggaXMgVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8Tz4ge1xuICBpZiAoIXR5cGVJc09iamVjdCh4KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdfY29udHJvbGxlZFRyYW5zZm9ybVN0cmVhbScpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHggaW5zdGFuY2VvZiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlcjtcbn1cblxuZnVuY3Rpb24gU2V0VXBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxJLCBPPihzdHJlYW06IFRyYW5zZm9ybVN0cmVhbTxJLCBPPixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlcjogVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8Tz4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybUFsZ29yaXRobTogKGNodW5rOiBJKSA9PiBQcm9taXNlPHZvaWQ+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbHVzaEFsZ29yaXRobTogKCkgPT4gUHJvbWlzZTx2b2lkPikge1xuICBhc3NlcnQoSXNUcmFuc2Zvcm1TdHJlYW0oc3RyZWFtKSk7XG4gIGFzc2VydChzdHJlYW0uX3RyYW5zZm9ybVN0cmVhbUNvbnRyb2xsZXIgPT09IHVuZGVmaW5lZCk7XG5cbiAgY29udHJvbGxlci5fY29udHJvbGxlZFRyYW5zZm9ybVN0cmVhbSA9IHN0cmVhbTtcbiAgc3RyZWFtLl90cmFuc2Zvcm1TdHJlYW1Db250cm9sbGVyID0gY29udHJvbGxlcjtcblxuICBjb250cm9sbGVyLl90cmFuc2Zvcm1BbGdvcml0aG0gPSB0cmFuc2Zvcm1BbGdvcml0aG07XG4gIGNvbnRyb2xsZXIuX2ZsdXNoQWxnb3JpdGhtID0gZmx1c2hBbGdvcml0aG07XG59XG5cbmZ1bmN0aW9uIFNldFVwVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJGcm9tVHJhbnNmb3JtZXI8SSwgTz4oc3RyZWFtOiBUcmFuc2Zvcm1TdHJlYW08SSwgTz4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybWVyOiBWYWxpZGF0ZWRUcmFuc2Zvcm1lcjxJLCBPPikge1xuICBjb25zdCBjb250cm9sbGVyOiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxPPiA9IE9iamVjdC5jcmVhdGUoVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIucHJvdG90eXBlKTtcblxuICBsZXQgdHJhbnNmb3JtQWxnb3JpdGhtID0gKGNodW5rOiBJKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyRW5xdWV1ZShjb250cm9sbGVyLCBjaHVuayBhcyB1bmtub3duIGFzIE8pO1xuICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcbiAgICB9IGNhdGNoICh0cmFuc2Zvcm1SZXN1bHRFKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aCh0cmFuc2Zvcm1SZXN1bHRFKTtcbiAgICB9XG4gIH07XG5cbiAgbGV0IGZsdXNoQWxnb3JpdGhtOiAoKSA9PiBQcm9taXNlPHZvaWQ+ID0gKCkgPT4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuXG4gIGlmICh0cmFuc2Zvcm1lci50cmFuc2Zvcm0gIT09IHVuZGVmaW5lZCkge1xuICAgIHRyYW5zZm9ybUFsZ29yaXRobSA9IGNodW5rID0+IHRyYW5zZm9ybWVyLnRyYW5zZm9ybSEoY2h1bmssIGNvbnRyb2xsZXIpO1xuICB9XG4gIGlmICh0cmFuc2Zvcm1lci5mbHVzaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZmx1c2hBbGdvcml0aG0gPSAoKSA9PiB0cmFuc2Zvcm1lci5mbHVzaCEoY29udHJvbGxlcik7XG4gIH1cblxuICBTZXRVcFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyKHN0cmVhbSwgY29udHJvbGxlciwgdHJhbnNmb3JtQWxnb3JpdGhtLCBmbHVzaEFsZ29yaXRobSk7XG59XG5cbmZ1bmN0aW9uIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKGNvbnRyb2xsZXI6IFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyPGFueT4pIHtcbiAgY29udHJvbGxlci5fdHJhbnNmb3JtQWxnb3JpdGhtID0gdW5kZWZpbmVkITtcbiAgY29udHJvbGxlci5fZmx1c2hBbGdvcml0aG0gPSB1bmRlZmluZWQhO1xufVxuXG5mdW5jdGlvbiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlckVucXVldWU8Tz4oY29udHJvbGxlcjogVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8Tz4sIGNodW5rOiBPKSB7XG4gIGNvbnN0IHN0cmVhbSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRUcmFuc2Zvcm1TdHJlYW07XG4gIGNvbnN0IHJlYWRhYmxlQ29udHJvbGxlciA9IHN0cmVhbS5fcmVhZGFibGUuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciBhcyBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyPE8+O1xuICBpZiAoIVJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDYW5DbG9zZU9yRW5xdWV1ZShyZWFkYWJsZUNvbnRyb2xsZXIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUmVhZGFibGUgc2lkZSBpcyBub3QgaW4gYSBzdGF0ZSB0aGF0IHBlcm1pdHMgZW5xdWV1ZScpO1xuICB9XG5cbiAgLy8gV2UgdGhyb3R0bGUgdHJhbnNmb3JtIGludm9jYXRpb25zIGJhc2VkIG9uIHRoZSBiYWNrcHJlc3N1cmUgb2YgdGhlIFJlYWRhYmxlU3RyZWFtLCBidXQgd2Ugc3RpbGxcbiAgLy8gYWNjZXB0IFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyRW5xdWV1ZSgpIGNhbGxzLlxuXG4gIHRyeSB7XG4gICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVucXVldWUocmVhZGFibGVDb250cm9sbGVyLCBjaHVuayk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBUaGlzIGhhcHBlbnMgd2hlbiByZWFkYWJsZVN0cmF0ZWd5LnNpemUoKSB0aHJvd3MuXG4gICAgVHJhbnNmb3JtU3RyZWFtRXJyb3JXcml0YWJsZUFuZFVuYmxvY2tXcml0ZShzdHJlYW0sIGUpO1xuXG4gICAgdGhyb3cgc3RyZWFtLl9yZWFkYWJsZS5fc3RvcmVkRXJyb3I7XG4gIH1cblxuICBjb25zdCBiYWNrcHJlc3N1cmUgPSBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVySGFzQmFja3ByZXNzdXJlKHJlYWRhYmxlQ29udHJvbGxlcik7XG4gIGlmIChiYWNrcHJlc3N1cmUgIT09IHN0cmVhbS5fYmFja3ByZXNzdXJlKSB7XG4gICAgYXNzZXJ0KGJhY2twcmVzc3VyZSk7XG4gICAgVHJhbnNmb3JtU3RyZWFtU2V0QmFja3ByZXNzdXJlKHN0cmVhbSwgdHJ1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcihjb250cm9sbGVyOiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxhbnk+LCBlOiBhbnkpIHtcbiAgVHJhbnNmb3JtU3RyZWFtRXJyb3IoY29udHJvbGxlci5fY29udHJvbGxlZFRyYW5zZm9ybVN0cmVhbSwgZSk7XG59XG5cbmZ1bmN0aW9uIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyUGVyZm9ybVRyYW5zZm9ybTxJLCBPPihjb250cm9sbGVyOiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxPPixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaHVuazogSSkge1xuICBjb25zdCB0cmFuc2Zvcm1Qcm9taXNlID0gY29udHJvbGxlci5fdHJhbnNmb3JtQWxnb3JpdGhtKGNodW5rKTtcbiAgcmV0dXJuIHRyYW5zZm9ybVByb21pc2VXaXRoKHRyYW5zZm9ybVByb21pc2UsIHVuZGVmaW5lZCwgciA9PiB7XG4gICAgVHJhbnNmb3JtU3RyZWFtRXJyb3IoY29udHJvbGxlci5fY29udHJvbGxlZFRyYW5zZm9ybVN0cmVhbSwgcik7XG4gICAgdGhyb3cgcjtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyVGVybWluYXRlPE8+KGNvbnRyb2xsZXI6IFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyPE8+KSB7XG4gIGNvbnN0IHN0cmVhbSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRUcmFuc2Zvcm1TdHJlYW07XG4gIGNvbnN0IHJlYWRhYmxlQ29udHJvbGxlciA9IHN0cmVhbS5fcmVhZGFibGUuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciBhcyBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyPE8+O1xuXG4gIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbG9zZShyZWFkYWJsZUNvbnRyb2xsZXIpO1xuXG4gIGNvbnN0IGVycm9yID0gbmV3IFR5cGVFcnJvcignVHJhbnNmb3JtU3RyZWFtIHRlcm1pbmF0ZWQnKTtcbiAgVHJhbnNmb3JtU3RyZWFtRXJyb3JXcml0YWJsZUFuZFVuYmxvY2tXcml0ZShzdHJlYW0sIGVycm9yKTtcbn1cblxuLy8gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdFNpbmsgQWxnb3JpdGhtc1xuXG5mdW5jdGlvbiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0U2lua1dyaXRlQWxnb3JpdGhtPEksIE8+KHN0cmVhbTogVHJhbnNmb3JtU3RyZWFtPEksIE8+LCBjaHVuazogSSk6IFByb21pc2U8dm9pZD4ge1xuICBhc3NlcnQoc3RyZWFtLl93cml0YWJsZS5fc3RhdGUgPT09ICd3cml0YWJsZScpO1xuXG4gIGNvbnN0IGNvbnRyb2xsZXIgPSBzdHJlYW0uX3RyYW5zZm9ybVN0cmVhbUNvbnRyb2xsZXI7XG5cbiAgaWYgKHN0cmVhbS5fYmFja3ByZXNzdXJlKSB7XG4gICAgY29uc3QgYmFja3ByZXNzdXJlQ2hhbmdlUHJvbWlzZSA9IHN0cmVhbS5fYmFja3ByZXNzdXJlQ2hhbmdlUHJvbWlzZTtcbiAgICBhc3NlcnQoYmFja3ByZXNzdXJlQ2hhbmdlUHJvbWlzZSAhPT0gdW5kZWZpbmVkKTtcbiAgICByZXR1cm4gdHJhbnNmb3JtUHJvbWlzZVdpdGgoYmFja3ByZXNzdXJlQ2hhbmdlUHJvbWlzZSwgKCkgPT4ge1xuICAgICAgY29uc3Qgd3JpdGFibGUgPSBzdHJlYW0uX3dyaXRhYmxlO1xuICAgICAgY29uc3Qgc3RhdGUgPSB3cml0YWJsZS5fc3RhdGU7XG4gICAgICBpZiAoc3RhdGUgPT09ICdlcnJvcmluZycpIHtcbiAgICAgICAgdGhyb3cgd3JpdGFibGUuX3N0b3JlZEVycm9yO1xuICAgICAgfVxuICAgICAgYXNzZXJ0KHN0YXRlID09PSAnd3JpdGFibGUnKTtcbiAgICAgIHJldHVybiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlclBlcmZvcm1UcmFuc2Zvcm08SSwgTz4oY29udHJvbGxlciwgY2h1bmspO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyUGVyZm9ybVRyYW5zZm9ybTxJLCBPPihjb250cm9sbGVyLCBjaHVuayk7XG59XG5cbmZ1bmN0aW9uIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRTaW5rQWJvcnRBbGdvcml0aG0oc3RyZWFtOiBUcmFuc2Zvcm1TdHJlYW0sIHJlYXNvbjogYW55KTogUHJvbWlzZTx2b2lkPiB7XG4gIC8vIGFib3J0KCkgaXMgbm90IGNhbGxlZCBzeW5jaHJvbm91c2x5LCBzbyBpdCBpcyBwb3NzaWJsZSBmb3IgYWJvcnQoKSB0byBiZSBjYWxsZWQgd2hlbiB0aGUgc3RyZWFtIGlzIGFscmVhZHlcbiAgLy8gZXJyb3JlZC5cbiAgVHJhbnNmb3JtU3RyZWFtRXJyb3Ioc3RyZWFtLCByZWFzb24pO1xuICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xufVxuXG5mdW5jdGlvbiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0U2lua0Nsb3NlQWxnb3JpdGhtPEksIE8+KHN0cmVhbTogVHJhbnNmb3JtU3RyZWFtPEksIE8+KTogUHJvbWlzZTx2b2lkPiB7XG4gIC8vIHN0cmVhbS5fcmVhZGFibGUgY2Fubm90IGNoYW5nZSBhZnRlciBjb25zdHJ1Y3Rpb24sIHNvIGNhY2hpbmcgaXQgYWNyb3NzIGEgY2FsbCB0byB1c2VyIGNvZGUgaXMgc2FmZS5cbiAgY29uc3QgcmVhZGFibGUgPSBzdHJlYW0uX3JlYWRhYmxlO1xuXG4gIGNvbnN0IGNvbnRyb2xsZXIgPSBzdHJlYW0uX3RyYW5zZm9ybVN0cmVhbUNvbnRyb2xsZXI7XG4gIGNvbnN0IGZsdXNoUHJvbWlzZSA9IGNvbnRyb2xsZXIuX2ZsdXNoQWxnb3JpdGhtKCk7XG4gIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKGNvbnRyb2xsZXIpO1xuXG4gIC8vIFJldHVybiBhIHByb21pc2UgdGhhdCBpcyBmdWxmaWxsZWQgd2l0aCB1bmRlZmluZWQgb24gc3VjY2Vzcy5cbiAgcmV0dXJuIHRyYW5zZm9ybVByb21pc2VXaXRoKGZsdXNoUHJvbWlzZSwgKCkgPT4ge1xuICAgIGlmIChyZWFkYWJsZS5fc3RhdGUgPT09ICdlcnJvcmVkJykge1xuICAgICAgdGhyb3cgcmVhZGFibGUuX3N0b3JlZEVycm9yO1xuICAgIH1cbiAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xvc2UocmVhZGFibGUuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciBhcyBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyPE8+KTtcbiAgfSwgciA9PiB7XG4gICAgVHJhbnNmb3JtU3RyZWFtRXJyb3Ioc3RyZWFtLCByKTtcbiAgICB0aHJvdyByZWFkYWJsZS5fc3RvcmVkRXJyb3I7XG4gIH0pO1xufVxuXG4vLyBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0U291cmNlIEFsZ29yaXRobXNcblxuZnVuY3Rpb24gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdFNvdXJjZVB1bGxBbGdvcml0aG0oc3RyZWFtOiBUcmFuc2Zvcm1TdHJlYW0pOiBQcm9taXNlPHZvaWQ+IHtcbiAgLy8gSW52YXJpYW50LiBFbmZvcmNlZCBieSB0aGUgcHJvbWlzZXMgcmV0dXJuZWQgYnkgc3RhcnQoKSBhbmQgcHVsbCgpLlxuICBhc3NlcnQoc3RyZWFtLl9iYWNrcHJlc3N1cmUpO1xuXG4gIGFzc2VydChzdHJlYW0uX2JhY2twcmVzc3VyZUNoYW5nZVByb21pc2UgIT09IHVuZGVmaW5lZCk7XG5cbiAgVHJhbnNmb3JtU3RyZWFtU2V0QmFja3ByZXNzdXJlKHN0cmVhbSwgZmFsc2UpO1xuXG4gIC8vIFByZXZlbnQgdGhlIG5leHQgcHVsbCgpIGNhbGwgdW50aWwgdGhlcmUgaXMgYmFja3ByZXNzdXJlLlxuICByZXR1cm4gc3RyZWFtLl9iYWNrcHJlc3N1cmVDaGFuZ2VQcm9taXNlO1xufVxuXG4vLyBIZWxwZXIgZnVuY3Rpb25zIGZvciB0aGUgVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIuXG5cbmZ1bmN0aW9uIGRlZmF1bHRDb250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbihuYW1lOiBzdHJpbmcpOiBUeXBlRXJyb3Ige1xuICByZXR1cm4gbmV3IFR5cGVFcnJvcihcbiAgICBgVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIucHJvdG90eXBlLiR7bmFtZX0gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyYCk7XG59XG5cbi8vIEhlbHBlciBmdW5jdGlvbnMgZm9yIHRoZSBUcmFuc2Zvcm1TdHJlYW0uXG5cbmZ1bmN0aW9uIHN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24obmFtZTogc3RyaW5nKTogVHlwZUVycm9yIHtcbiAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoXG4gICAgYFRyYW5zZm9ybVN0cmVhbS5wcm90b3R5cGUuJHtuYW1lfSBjYW4gb25seSBiZSB1c2VkIG9uIGEgVHJhbnNmb3JtU3RyZWFtYCk7XG59XG4iLCAidHJ5IHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwic3RyZWFtL3dlYlwiKVxufSBjYXRjaCAoZXJyb3IpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwid2ViLXN0cmVhbXMtcG9seWZpbGwvcG9ueWZpbGxcIilcbn1cbiIsICIvKipcbiAqIEB0eXBlZGVmIHtvYmplY3R9IFByaXZhdGVEYXRhXG4gKiBAcHJvcGVydHkge0V2ZW50VGFyZ2V0fSBldmVudFRhcmdldCBUaGUgZXZlbnQgdGFyZ2V0LlxuICogQHByb3BlcnR5IHt7dHlwZTpzdHJpbmd9fSBldmVudCBUaGUgb3JpZ2luYWwgZXZlbnQgb2JqZWN0LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGV2ZW50UGhhc2UgVGhlIGN1cnJlbnQgZXZlbnQgcGhhc2UuXG4gKiBAcHJvcGVydHkge0V2ZW50VGFyZ2V0fG51bGx9IGN1cnJlbnRUYXJnZXQgVGhlIGN1cnJlbnQgZXZlbnQgdGFyZ2V0LlxuICogQHByb3BlcnR5IHtib29sZWFufSBjYW5jZWxlZCBUaGUgZmxhZyB0byBwcmV2ZW50IGRlZmF1bHQuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHN0b3BwZWQgVGhlIGZsYWcgdG8gc3RvcCBwcm9wYWdhdGlvbi5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaW1tZWRpYXRlU3RvcHBlZCBUaGUgZmxhZyB0byBzdG9wIHByb3BhZ2F0aW9uIGltbWVkaWF0ZWx5LlxuICogQHByb3BlcnR5IHtGdW5jdGlvbnxudWxsfSBwYXNzaXZlTGlzdGVuZXIgVGhlIGxpc3RlbmVyIGlmIHRoZSBjdXJyZW50IGxpc3RlbmVyIGlzIHBhc3NpdmUuIE90aGVyd2lzZSB0aGlzIGlzIG51bGwuXG4gKiBAcHJvcGVydHkge251bWJlcn0gdGltZVN0YW1wIFRoZSB1bml4IHRpbWUuXG4gKiBAcHJpdmF0ZVxuICovXG5cbi8qKlxuICogUHJpdmF0ZSBkYXRhIGZvciBldmVudCB3cmFwcGVycy5cbiAqIEB0eXBlIHtXZWFrTWFwPEV2ZW50LCBQcml2YXRlRGF0YT59XG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBwcml2YXRlRGF0YSA9IG5ldyBXZWFrTWFwKClcblxuLyoqXG4gKiBDYWNoZSBmb3Igd3JhcHBlciBjbGFzc2VzLlxuICogQHR5cGUge1dlYWtNYXA8T2JqZWN0LCBGdW5jdGlvbj59XG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCB3cmFwcGVycyA9IG5ldyBXZWFrTWFwKClcblxuLyoqXG4gKiBHZXQgcHJpdmF0ZSBkYXRhLlxuICogQHBhcmFtIHtFdmVudH0gZXZlbnQgVGhlIGV2ZW50IG9iamVjdCB0byBnZXQgcHJpdmF0ZSBkYXRhLlxuICogQHJldHVybnMge1ByaXZhdGVEYXRhfSBUaGUgcHJpdmF0ZSBkYXRhIG9mIHRoZSBldmVudC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHBkKGV2ZW50KSB7XG4gICAgY29uc3QgcmV0diA9IHByaXZhdGVEYXRhLmdldChldmVudClcbiAgICBjb25zb2xlLmFzc2VydChcbiAgICAgICAgcmV0diAhPSBudWxsLFxuICAgICAgICBcIid0aGlzJyBpcyBleHBlY3RlZCBhbiBFdmVudCBvYmplY3QsIGJ1dCBnb3RcIixcbiAgICAgICAgZXZlbnRcbiAgICApXG4gICAgcmV0dXJuIHJldHZcbn1cblxuLyoqXG4gKiBodHRwczovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI3NldC10aGUtY2FuY2VsZWQtZmxhZ1xuICogQHBhcmFtIGRhdGEge1ByaXZhdGVEYXRhfSBwcml2YXRlIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIHNldENhbmNlbEZsYWcoZGF0YSkge1xuICAgIGlmIChkYXRhLnBhc3NpdmVMaXN0ZW5lciAhPSBudWxsKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHR5cGVvZiBjb25zb2xlICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgICAgICB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBcIlVuYWJsZSB0byBwcmV2ZW50RGVmYXVsdCBpbnNpZGUgcGFzc2l2ZSBldmVudCBsaXN0ZW5lciBpbnZvY2F0aW9uLlwiLFxuICAgICAgICAgICAgICAgIGRhdGEucGFzc2l2ZUxpc3RlbmVyXG4gICAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGlmICghZGF0YS5ldmVudC5jYW5jZWxhYmxlKSB7XG4gICAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGRhdGEuY2FuY2VsZWQgPSB0cnVlXG4gICAgaWYgKHR5cGVvZiBkYXRhLmV2ZW50LnByZXZlbnREZWZhdWx0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgZGF0YS5ldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgfVxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNpbnRlcmZhY2UtZXZlbnRcbiAqIEBwcml2YXRlXG4gKi9cbi8qKlxuICogVGhlIGV2ZW50IHdyYXBwZXIuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IGV2ZW50VGFyZ2V0IFRoZSBldmVudCB0YXJnZXQgb2YgdGhpcyBkaXNwYXRjaGluZy5cbiAqIEBwYXJhbSB7RXZlbnR8e3R5cGU6c3RyaW5nfX0gZXZlbnQgVGhlIG9yaWdpbmFsIGV2ZW50IHRvIHdyYXAuXG4gKi9cbmZ1bmN0aW9uIEV2ZW50KGV2ZW50VGFyZ2V0LCBldmVudCkge1xuICAgIHByaXZhdGVEYXRhLnNldCh0aGlzLCB7XG4gICAgICAgIGV2ZW50VGFyZ2V0LFxuICAgICAgICBldmVudCxcbiAgICAgICAgZXZlbnRQaGFzZTogMixcbiAgICAgICAgY3VycmVudFRhcmdldDogZXZlbnRUYXJnZXQsXG4gICAgICAgIGNhbmNlbGVkOiBmYWxzZSxcbiAgICAgICAgc3RvcHBlZDogZmFsc2UsXG4gICAgICAgIGltbWVkaWF0ZVN0b3BwZWQ6IGZhbHNlLFxuICAgICAgICBwYXNzaXZlTGlzdGVuZXI6IG51bGwsXG4gICAgICAgIHRpbWVTdGFtcDogZXZlbnQudGltZVN0YW1wIHx8IERhdGUubm93KCksXG4gICAgfSlcblxuICAgIC8vIGh0dHBzOi8vaGV5Y2FtLmdpdGh1Yi5pby93ZWJpZGwvI1VuZm9yZ2VhYmxlXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaXNUcnVzdGVkXCIsIHsgdmFsdWU6IGZhbHNlLCBlbnVtZXJhYmxlOiB0cnVlIH0pXG5cbiAgICAvLyBEZWZpbmUgYWNjZXNzb3JzXG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGV2ZW50KVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2ldXG4gICAgICAgIGlmICghKGtleSBpbiB0aGlzKSkge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGtleSwgZGVmaW5lUmVkaXJlY3REZXNjcmlwdG9yKGtleSkpXG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vIFNob3VsZCBiZSBlbnVtZXJhYmxlLCBidXQgY2xhc3MgbWV0aG9kcyBhcmUgbm90IGVudW1lcmFibGUuXG5FdmVudC5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUgb2YgdGhpcyBldmVudC5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldCB0eXBlKCkge1xuICAgICAgICByZXR1cm4gcGQodGhpcykuZXZlbnQudHlwZVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgdGFyZ2V0IG9mIHRoaXMgZXZlbnQuXG4gICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fVxuICAgICAqL1xuICAgIGdldCB0YXJnZXQoKSB7XG4gICAgICAgIHJldHVybiBwZCh0aGlzKS5ldmVudFRhcmdldFxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgdGFyZ2V0IG9mIHRoaXMgZXZlbnQuXG4gICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fVxuICAgICAqL1xuICAgIGdldCBjdXJyZW50VGFyZ2V0KCkge1xuICAgICAgICByZXR1cm4gcGQodGhpcykuY3VycmVudFRhcmdldFxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7RXZlbnRUYXJnZXRbXX0gVGhlIGNvbXBvc2VkIHBhdGggb2YgdGhpcyBldmVudC5cbiAgICAgKi9cbiAgICBjb21wb3NlZFBhdGgoKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRUYXJnZXQgPSBwZCh0aGlzKS5jdXJyZW50VGFyZ2V0XG4gICAgICAgIGlmIChjdXJyZW50VGFyZ2V0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBbXVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbY3VycmVudFRhcmdldF1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RhbnQgb2YgTk9ORS5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBOT05FKCkge1xuICAgICAgICByZXR1cm4gMFxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb25zdGFudCBvZiBDQVBUVVJJTkdfUEhBU0UuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgQ0FQVFVSSU5HX1BIQVNFKCkge1xuICAgICAgICByZXR1cm4gMVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb25zdGFudCBvZiBBVF9UQVJHRVQuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgQVRfVEFSR0VUKCkge1xuICAgICAgICByZXR1cm4gMlxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb25zdGFudCBvZiBCVUJCTElOR19QSEFTRS5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBCVUJCTElOR19QSEFTRSgpIHtcbiAgICAgICAgcmV0dXJuIDNcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIHRhcmdldCBvZiB0aGlzIGV2ZW50LlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IGV2ZW50UGhhc2UoKSB7XG4gICAgICAgIHJldHVybiBwZCh0aGlzKS5ldmVudFBoYXNlXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFN0b3AgZXZlbnQgYnViYmxpbmcuXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgc3RvcFByb3BhZ2F0aW9uKCkge1xuICAgICAgICBjb25zdCBkYXRhID0gcGQodGhpcylcblxuICAgICAgICBkYXRhLnN0b3BwZWQgPSB0cnVlXG4gICAgICAgIGlmICh0eXBlb2YgZGF0YS5ldmVudC5zdG9wUHJvcGFnYXRpb24gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgZGF0YS5ldmVudC5zdG9wUHJvcGFnYXRpb24oKVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFN0b3AgZXZlbnQgYnViYmxpbmcuXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCkge1xuICAgICAgICBjb25zdCBkYXRhID0gcGQodGhpcylcblxuICAgICAgICBkYXRhLnN0b3BwZWQgPSB0cnVlXG4gICAgICAgIGRhdGEuaW1tZWRpYXRlU3RvcHBlZCA9IHRydWVcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhLmV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBkYXRhLmV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpXG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIGZsYWcgdG8gYmUgYnViYmxpbmcuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgZ2V0IGJ1YmJsZXMoKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKHBkKHRoaXMpLmV2ZW50LmJ1YmJsZXMpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBmbGFnIHRvIGJlIGNhbmNlbGFibGUuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgZ2V0IGNhbmNlbGFibGUoKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKHBkKHRoaXMpLmV2ZW50LmNhbmNlbGFibGUpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbmNlbCB0aGlzIGV2ZW50LlxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIHByZXZlbnREZWZhdWx0KCkge1xuICAgICAgICBzZXRDYW5jZWxGbGFnKHBkKHRoaXMpKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZmxhZyB0byBpbmRpY2F0ZSBjYW5jZWxsYXRpb24gc3RhdGUuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgZ2V0IGRlZmF1bHRQcmV2ZW50ZWQoKSB7XG4gICAgICAgIHJldHVybiBwZCh0aGlzKS5jYW5jZWxlZFxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZmxhZyB0byBiZSBjb21wb3NlZC5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBnZXQgY29tcG9zZWQoKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKHBkKHRoaXMpLmV2ZW50LmNvbXBvc2VkKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgdW5peCB0aW1lIG9mIHRoaXMgZXZlbnQuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgdGltZVN0YW1wKCkge1xuICAgICAgICByZXR1cm4gcGQodGhpcykudGltZVN0YW1wXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSB0YXJnZXQgb2YgdGhpcyBldmVudC5cbiAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR9XG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKi9cbiAgICBnZXQgc3JjRWxlbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHBkKHRoaXMpLmV2ZW50VGFyZ2V0XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBmbGFnIHRvIHN0b3AgZXZlbnQgYnViYmxpbmcuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKi9cbiAgICBnZXQgY2FuY2VsQnViYmxlKCkge1xuICAgICAgICByZXR1cm4gcGQodGhpcykuc3RvcHBlZFxuICAgIH0sXG4gICAgc2V0IGNhbmNlbEJ1YmJsZSh2YWx1ZSkge1xuICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRhID0gcGQodGhpcylcblxuICAgICAgICBkYXRhLnN0b3BwZWQgPSB0cnVlXG4gICAgICAgIGlmICh0eXBlb2YgZGF0YS5ldmVudC5jYW5jZWxCdWJibGUgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICBkYXRhLmV2ZW50LmNhbmNlbEJ1YmJsZSA9IHRydWVcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZmxhZyB0byBpbmRpY2F0ZSBjYW5jZWxsYXRpb24gc3RhdGUuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKi9cbiAgICBnZXQgcmV0dXJuVmFsdWUoKSB7XG4gICAgICAgIHJldHVybiAhcGQodGhpcykuY2FuY2VsZWRcbiAgICB9LFxuICAgIHNldCByZXR1cm5WYWx1ZSh2YWx1ZSkge1xuICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICBzZXRDYW5jZWxGbGFnKHBkKHRoaXMpKVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgdGhpcyBldmVudCBvYmplY3QuIEJ1dCBkbyBub3RoaW5nIHVuZGVyIGV2ZW50IGRpc3BhdGNoaW5nLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFRoZSBldmVudCB0eXBlLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2J1YmJsZXM9ZmFsc2VdIFRoZSBmbGFnIHRvIGJlIHBvc3NpYmxlIHRvIGJ1YmJsZSB1cC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtjYW5jZWxhYmxlPWZhbHNlXSBUaGUgZmxhZyB0byBiZSBwb3NzaWJsZSB0byBjYW5jZWwuXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKi9cbiAgICBpbml0RXZlbnQoKSB7XG4gICAgICAgIC8vIERvIG5vdGhpbmcuXG4gICAgfSxcbn1cblxuLy8gYGNvbnN0cnVjdG9yYCBpcyBub3QgZW51bWVyYWJsZS5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudC5wcm90b3R5cGUsIFwiY29uc3RydWN0b3JcIiwge1xuICAgIHZhbHVlOiBFdmVudCxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG59KVxuXG4vLyBFbnN1cmUgYGV2ZW50IGluc3RhbmNlb2Ygd2luZG93LkV2ZW50YCBpcyBgdHJ1ZWAuXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2Ygd2luZG93LkV2ZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKEV2ZW50LnByb3RvdHlwZSwgd2luZG93LkV2ZW50LnByb3RvdHlwZSlcblxuICAgIC8vIE1ha2UgYXNzb2NpYXRpb24gZm9yIHdyYXBwZXJzLlxuICAgIHdyYXBwZXJzLnNldCh3aW5kb3cuRXZlbnQucHJvdG90eXBlLCBFdmVudClcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHByb3BlcnR5IGRlc2NyaXB0b3IgdG8gcmVkaXJlY3QgYSBnaXZlbiBwcm9wZXJ0eS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgUHJvcGVydHkgbmFtZSB0byBkZWZpbmUgcHJvcGVydHkgZGVzY3JpcHRvci5cbiAqIEByZXR1cm5zIHtQcm9wZXJ0eURlc2NyaXB0b3J9IFRoZSBwcm9wZXJ0eSBkZXNjcmlwdG9yIHRvIHJlZGlyZWN0IHRoZSBwcm9wZXJ0eS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGRlZmluZVJlZGlyZWN0RGVzY3JpcHRvcihrZXkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gcGQodGhpcykuZXZlbnRba2V5XVxuICAgICAgICB9LFxuICAgICAgICBzZXQodmFsdWUpIHtcbiAgICAgICAgICAgIHBkKHRoaXMpLmV2ZW50W2tleV0gPSB2YWx1ZVxuICAgICAgICB9LFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgfVxufVxuXG4vKipcbiAqIEdldCB0aGUgcHJvcGVydHkgZGVzY3JpcHRvciB0byBjYWxsIGEgZ2l2ZW4gbWV0aG9kIHByb3BlcnR5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBQcm9wZXJ0eSBuYW1lIHRvIGRlZmluZSBwcm9wZXJ0eSBkZXNjcmlwdG9yLlxuICogQHJldHVybnMge1Byb3BlcnR5RGVzY3JpcHRvcn0gVGhlIHByb3BlcnR5IGRlc2NyaXB0b3IgdG8gY2FsbCB0aGUgbWV0aG9kIHByb3BlcnR5LlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZGVmaW5lQ2FsbERlc2NyaXB0b3Ioa2V5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWUoKSB7XG4gICAgICAgICAgICBjb25zdCBldmVudCA9IHBkKHRoaXMpLmV2ZW50XG4gICAgICAgICAgICByZXR1cm4gZXZlbnRba2V5XS5hcHBseShldmVudCwgYXJndW1lbnRzKVxuICAgICAgICB9LFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgfVxufVxuXG4vKipcbiAqIERlZmluZSBuZXcgd3JhcHBlciBjbGFzcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IEJhc2VFdmVudCBUaGUgYmFzZSB3cmFwcGVyIGNsYXNzLlxuICogQHBhcmFtIHtPYmplY3R9IHByb3RvIFRoZSBwcm90b3R5cGUgb2YgdGhlIG9yaWdpbmFsIGV2ZW50LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBUaGUgZGVmaW5lZCB3cmFwcGVyIGNsYXNzLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZGVmaW5lV3JhcHBlcihCYXNlRXZlbnQsIHByb3RvKSB7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHByb3RvKVxuICAgIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQmFzZUV2ZW50XG4gICAgfVxuXG4gICAgLyoqIEN1c3RvbUV2ZW50ICovXG4gICAgZnVuY3Rpb24gQ3VzdG9tRXZlbnQoZXZlbnRUYXJnZXQsIGV2ZW50KSB7XG4gICAgICAgIEJhc2VFdmVudC5jYWxsKHRoaXMsIGV2ZW50VGFyZ2V0LCBldmVudClcbiAgICB9XG5cbiAgICBDdXN0b21FdmVudC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEJhc2VFdmVudC5wcm90b3R5cGUsIHtcbiAgICAgICAgY29uc3RydWN0b3I6IHsgdmFsdWU6IEN1c3RvbUV2ZW50LCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0sXG4gICAgfSlcblxuICAgIC8vIERlZmluZSBhY2Nlc3NvcnMuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGtleXNbaV1cbiAgICAgICAgaWYgKCEoa2V5IGluIEJhc2VFdmVudC5wcm90b3R5cGUpKSB7XG4gICAgICAgICAgICBjb25zdCBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwcm90bywga2V5KVxuICAgICAgICAgICAgY29uc3QgaXNGdW5jID0gdHlwZW9mIGRlc2NyaXB0b3IudmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFxuICAgICAgICAgICAgICAgIEN1c3RvbUV2ZW50LnByb3RvdHlwZSxcbiAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgaXNGdW5jXG4gICAgICAgICAgICAgICAgICAgID8gZGVmaW5lQ2FsbERlc2NyaXB0b3Ioa2V5KVxuICAgICAgICAgICAgICAgICAgICA6IGRlZmluZVJlZGlyZWN0RGVzY3JpcHRvcihrZXkpXG4gICAgICAgICAgICApXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gQ3VzdG9tRXZlbnRcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHdyYXBwZXIgY2xhc3Mgb2YgYSBnaXZlbiBwcm90b3R5cGUuXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvdG8gVGhlIHByb3RvdHlwZSBvZiB0aGUgb3JpZ2luYWwgZXZlbnQgdG8gZ2V0IGl0cyB3cmFwcGVyLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBUaGUgd3JhcHBlciBjbGFzcy5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGdldFdyYXBwZXIocHJvdG8pIHtcbiAgICBpZiAocHJvdG8gPT0gbnVsbCB8fCBwcm90byA9PT0gT2JqZWN0LnByb3RvdHlwZSkge1xuICAgICAgICByZXR1cm4gRXZlbnRcbiAgICB9XG5cbiAgICBsZXQgd3JhcHBlciA9IHdyYXBwZXJzLmdldChwcm90bylcbiAgICBpZiAod3JhcHBlciA9PSBudWxsKSB7XG4gICAgICAgIHdyYXBwZXIgPSBkZWZpbmVXcmFwcGVyKGdldFdyYXBwZXIoT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKSksIHByb3RvKVxuICAgICAgICB3cmFwcGVycy5zZXQocHJvdG8sIHdyYXBwZXIpXG4gICAgfVxuICAgIHJldHVybiB3cmFwcGVyXG59XG5cbi8qKlxuICogV3JhcCBhIGdpdmVuIGV2ZW50IHRvIG1hbmFnZW1lbnQgYSBkaXNwYXRjaGluZy5cbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IGV2ZW50VGFyZ2V0IFRoZSBldmVudCB0YXJnZXQgb2YgdGhpcyBkaXNwYXRjaGluZy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBUaGUgZXZlbnQgdG8gd3JhcC5cbiAqIEByZXR1cm5zIHtFdmVudH0gVGhlIHdyYXBwZXIgaW5zdGFuY2UuXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gd3JhcEV2ZW50KGV2ZW50VGFyZ2V0LCBldmVudCkge1xuICAgIGNvbnN0IFdyYXBwZXIgPSBnZXRXcmFwcGVyKE9iamVjdC5nZXRQcm90b3R5cGVPZihldmVudCkpXG4gICAgcmV0dXJuIG5ldyBXcmFwcGVyKGV2ZW50VGFyZ2V0LCBldmVudClcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGltbWVkaWF0ZVN0b3BwZWQgZmxhZyBvZiBhIGdpdmVuIGV2ZW50LlxuICogQHBhcmFtIHtFdmVudH0gZXZlbnQgVGhlIGV2ZW50IHRvIGdldC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBUaGUgZmxhZyB0byBzdG9wIHByb3BhZ2F0aW9uIGltbWVkaWF0ZWx5LlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzU3RvcHBlZChldmVudCkge1xuICAgIHJldHVybiBwZChldmVudCkuaW1tZWRpYXRlU3RvcHBlZFxufVxuXG4vKipcbiAqIFNldCB0aGUgY3VycmVudCBldmVudCBwaGFzZSBvZiBhIGdpdmVuIGV2ZW50LlxuICogQHBhcmFtIHtFdmVudH0gZXZlbnQgVGhlIGV2ZW50IHRvIHNldCBjdXJyZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBldmVudFBoYXNlIE5ldyBldmVudCBwaGFzZS5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldEV2ZW50UGhhc2UoZXZlbnQsIGV2ZW50UGhhc2UpIHtcbiAgICBwZChldmVudCkuZXZlbnRQaGFzZSA9IGV2ZW50UGhhc2Vcbn1cblxuLyoqXG4gKiBTZXQgdGhlIGN1cnJlbnQgdGFyZ2V0IG9mIGEgZ2l2ZW4gZXZlbnQuXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudCBUaGUgZXZlbnQgdG8gc2V0IGN1cnJlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtFdmVudFRhcmdldHxudWxsfSBjdXJyZW50VGFyZ2V0IE5ldyBjdXJyZW50IHRhcmdldC5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldEN1cnJlbnRUYXJnZXQoZXZlbnQsIGN1cnJlbnRUYXJnZXQpIHtcbiAgICBwZChldmVudCkuY3VycmVudFRhcmdldCA9IGN1cnJlbnRUYXJnZXRcbn1cblxuLyoqXG4gKiBTZXQgYSBwYXNzaXZlIGxpc3RlbmVyIG9mIGEgZ2l2ZW4gZXZlbnQuXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudCBUaGUgZXZlbnQgdG8gc2V0IGN1cnJlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtGdW5jdGlvbnxudWxsfSBwYXNzaXZlTGlzdGVuZXIgTmV3IHBhc3NpdmUgbGlzdGVuZXIuXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRQYXNzaXZlTGlzdGVuZXIoZXZlbnQsIHBhc3NpdmVMaXN0ZW5lcikge1xuICAgIHBkKGV2ZW50KS5wYXNzaXZlTGlzdGVuZXIgPSBwYXNzaXZlTGlzdGVuZXJcbn1cbiIsICJpbXBvcnQge1xuICAgIGlzU3RvcHBlZCxcbiAgICBzZXRDdXJyZW50VGFyZ2V0LFxuICAgIHNldEV2ZW50UGhhc2UsXG4gICAgc2V0UGFzc2l2ZUxpc3RlbmVyLFxuICAgIHdyYXBFdmVudCxcbn0gZnJvbSBcIi4vZXZlbnQubWpzXCJcblxuLyoqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBMaXN0ZW5lck5vZGVcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGxpc3RlbmVyXG4gKiBAcHJvcGVydHkgezF8MnwzfSBsaXN0ZW5lclR5cGVcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gcGFzc2l2ZVxuICogQHByb3BlcnR5IHtib29sZWFufSBvbmNlXG4gKiBAcHJvcGVydHkge0xpc3RlbmVyTm9kZXxudWxsfSBuZXh0XG4gKiBAcHJpdmF0ZVxuICovXG5cbi8qKlxuICogQHR5cGUge1dlYWtNYXA8b2JqZWN0LCBNYXA8c3RyaW5nLCBMaXN0ZW5lck5vZGU+Pn1cbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IGxpc3RlbmVyc01hcCA9IG5ldyBXZWFrTWFwKClcblxuLy8gTGlzdGVuZXIgdHlwZXNcbmNvbnN0IENBUFRVUkUgPSAxXG5jb25zdCBCVUJCTEUgPSAyXG5jb25zdCBBVFRSSUJVVEUgPSAzXG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciBhIGdpdmVuIHZhbHVlIGlzIGFuIG9iamVjdCBvciBub3QuXG4gKiBAcGFyYW0ge2FueX0geCBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSB2YWx1ZSBpcyBhbiBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHgpIHtcbiAgICByZXR1cm4geCAhPT0gbnVsbCAmJiB0eXBlb2YgeCA9PT0gXCJvYmplY3RcIiAvL2VzbGludC1kaXNhYmxlLWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcbn1cblxuLyoqXG4gKiBHZXQgbGlzdGVuZXJzLlxuICogQHBhcmFtIHtFdmVudFRhcmdldH0gZXZlbnRUYXJnZXQgVGhlIGV2ZW50IHRhcmdldCB0byBnZXQuXG4gKiBAcmV0dXJucyB7TWFwPHN0cmluZywgTGlzdGVuZXJOb2RlPn0gVGhlIGxpc3RlbmVycy5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGdldExpc3RlbmVycyhldmVudFRhcmdldCkge1xuICAgIGNvbnN0IGxpc3RlbmVycyA9IGxpc3RlbmVyc01hcC5nZXQoZXZlbnRUYXJnZXQpXG4gICAgaWYgKGxpc3RlbmVycyA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICBcIid0aGlzJyBpcyBleHBlY3RlZCBhbiBFdmVudFRhcmdldCBvYmplY3QsIGJ1dCBnb3QgYW5vdGhlciB2YWx1ZS5cIlxuICAgICAgICApXG4gICAgfVxuICAgIHJldHVybiBsaXN0ZW5lcnNcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHByb3BlcnR5IGRlc2NyaXB0b3IgZm9yIHRoZSBldmVudCBhdHRyaWJ1dGUgb2YgYSBnaXZlbiBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgVGhlIGV2ZW50IG5hbWUgdG8gZ2V0IHByb3BlcnR5IGRlc2NyaXB0b3IuXG4gKiBAcmV0dXJucyB7UHJvcGVydHlEZXNjcmlwdG9yfSBUaGUgcHJvcGVydHkgZGVzY3JpcHRvci5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGRlZmluZUV2ZW50QXR0cmlidXRlRGVzY3JpcHRvcihldmVudE5hbWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICBjb25zdCBsaXN0ZW5lcnMgPSBnZXRMaXN0ZW5lcnModGhpcylcbiAgICAgICAgICAgIGxldCBub2RlID0gbGlzdGVuZXJzLmdldChldmVudE5hbWUpXG4gICAgICAgICAgICB3aGlsZSAobm9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUubGlzdGVuZXJUeXBlID09PSBBVFRSSUJVVEUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUubGlzdGVuZXJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUubmV4dFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgfSxcblxuICAgICAgICBzZXQobGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09IFwiZnVuY3Rpb25cIiAmJiAhaXNPYmplY3QobGlzdGVuZXIpKSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXIgPSBudWxsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IGdldExpc3RlbmVycyh0aGlzKVxuXG4gICAgICAgICAgICAvLyBUcmF2ZXJzZSB0byB0aGUgdGFpbCB3aGlsZSByZW1vdmluZyBvbGQgdmFsdWUuXG4gICAgICAgICAgICBsZXQgcHJldiA9IG51bGxcbiAgICAgICAgICAgIGxldCBub2RlID0gbGlzdGVuZXJzLmdldChldmVudE5hbWUpXG4gICAgICAgICAgICB3aGlsZSAobm9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUubGlzdGVuZXJUeXBlID09PSBBVFRSSUJVVEUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIG9sZCB2YWx1ZS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZXYgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXYubmV4dCA9IG5vZGUubmV4dFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5vZGUubmV4dCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLnNldChldmVudE5hbWUsIG5vZGUubmV4dClcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy5kZWxldGUoZXZlbnROYW1lKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldiA9IG5vZGVcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5uZXh0XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEFkZCBuZXcgdmFsdWUuXG4gICAgICAgICAgICBpZiAobGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdOb2RlID0ge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcixcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJUeXBlOiBBVFRSSUJVVEUsXG4gICAgICAgICAgICAgICAgICAgIHBhc3NpdmU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBvbmNlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgbmV4dDogbnVsbCxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHByZXYgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLnNldChldmVudE5hbWUsIG5ld05vZGUpXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldi5uZXh0ID0gbmV3Tm9kZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIH1cbn1cblxuLyoqXG4gKiBEZWZpbmUgYW4gZXZlbnQgYXR0cmlidXRlIChlLmcuIGBldmVudFRhcmdldC5vbmNsaWNrYCkuXG4gKiBAcGFyYW0ge09iamVjdH0gZXZlbnRUYXJnZXRQcm90b3R5cGUgVGhlIGV2ZW50IHRhcmdldCBwcm90b3R5cGUgdG8gZGVmaW5lIGFuIGV2ZW50IGF0dHJiaXRlLlxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBUaGUgZXZlbnQgbmFtZSB0byBkZWZpbmUuXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gZGVmaW5lRXZlbnRBdHRyaWJ1dGUoZXZlbnRUYXJnZXRQcm90b3R5cGUsIGV2ZW50TmFtZSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcbiAgICAgICAgZXZlbnRUYXJnZXRQcm90b3R5cGUsXG4gICAgICAgIGBvbiR7ZXZlbnROYW1lfWAsXG4gICAgICAgIGRlZmluZUV2ZW50QXR0cmlidXRlRGVzY3JpcHRvcihldmVudE5hbWUpXG4gICAgKVxufVxuXG4vKipcbiAqIERlZmluZSBhIGN1c3RvbSBFdmVudFRhcmdldCB3aXRoIGV2ZW50IGF0dHJpYnV0ZXMuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBldmVudE5hbWVzIEV2ZW50IG5hbWVzIGZvciBldmVudCBhdHRyaWJ1dGVzLlxuICogQHJldHVybnMge0V2ZW50VGFyZ2V0fSBUaGUgY3VzdG9tIEV2ZW50VGFyZ2V0LlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZGVmaW5lQ3VzdG9tRXZlbnRUYXJnZXQoZXZlbnROYW1lcykge1xuICAgIC8qKiBDdXN0b21FdmVudFRhcmdldCAqL1xuICAgIGZ1bmN0aW9uIEN1c3RvbUV2ZW50VGFyZ2V0KCkge1xuICAgICAgICBFdmVudFRhcmdldC5jYWxsKHRoaXMpXG4gICAgfVxuXG4gICAgQ3VzdG9tRXZlbnRUYXJnZXQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFdmVudFRhcmdldC5wcm90b3R5cGUsIHtcbiAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICAgIHZhbHVlOiBDdXN0b21FdmVudFRhcmdldCxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB9LFxuICAgIH0pXG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV2ZW50TmFtZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgZGVmaW5lRXZlbnRBdHRyaWJ1dGUoQ3VzdG9tRXZlbnRUYXJnZXQucHJvdG90eXBlLCBldmVudE5hbWVzW2ldKVxuICAgIH1cblxuICAgIHJldHVybiBDdXN0b21FdmVudFRhcmdldFxufVxuXG4vKipcbiAqIEV2ZW50VGFyZ2V0LlxuICpcbiAqIC0gVGhpcyBpcyBjb25zdHJ1Y3RvciBpZiBubyBhcmd1bWVudHMuXG4gKiAtIFRoaXMgaXMgYSBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGEgQ3VzdG9tRXZlbnRUYXJnZXQgY29uc3RydWN0b3IgaWYgdGhlcmUgYXJlIGFyZ3VtZW50cy5cbiAqXG4gKiBGb3IgZXhhbXBsZTpcbiAqXG4gKiAgICAgY2xhc3MgQSBleHRlbmRzIEV2ZW50VGFyZ2V0IHt9XG4gKiAgICAgY2xhc3MgQiBleHRlbmRzIEV2ZW50VGFyZ2V0KFwibWVzc2FnZVwiKSB7fVxuICogICAgIGNsYXNzIEMgZXh0ZW5kcyBFdmVudFRhcmdldChcIm1lc3NhZ2VcIiwgXCJlcnJvclwiKSB7fVxuICogICAgIGNsYXNzIEQgZXh0ZW5kcyBFdmVudFRhcmdldChbXCJtZXNzYWdlXCIsIFwiZXJyb3JcIl0pIHt9XG4gKi9cbmZ1bmN0aW9uIEV2ZW50VGFyZ2V0KCkge1xuICAgIC8qZXNsaW50LWRpc2FibGUgY29uc2lzdGVudC1yZXR1cm4gKi9cbiAgICBpZiAodGhpcyBpbnN0YW5jZW9mIEV2ZW50VGFyZ2V0KSB7XG4gICAgICAgIGxpc3RlbmVyc01hcC5zZXQodGhpcywgbmV3IE1hcCgpKVxuICAgICAgICByZXR1cm5cbiAgICB9XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgQXJyYXkuaXNBcnJheShhcmd1bWVudHNbMF0pKSB7XG4gICAgICAgIHJldHVybiBkZWZpbmVDdXN0b21FdmVudFRhcmdldChhcmd1bWVudHNbMF0pXG4gICAgfVxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCB0eXBlcyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdHlwZXNbaV0gPSBhcmd1bWVudHNbaV1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVmaW5lQ3VzdG9tRXZlbnRUYXJnZXQodHlwZXMpXG4gICAgfVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIilcbiAgICAvKmVzbGludC1lbmFibGUgY29uc2lzdGVudC1yZXR1cm4gKi9cbn1cblxuLy8gU2hvdWxkIGJlIGVudW1lcmFibGUsIGJ1dCBjbGFzcyBtZXRob2RzIGFyZSBub3QgZW51bWVyYWJsZS5cbkV2ZW50VGFyZ2V0LnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBBZGQgYSBnaXZlbiBsaXN0ZW5lciB0byB0aGlzIGV2ZW50IHRhcmdldC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIFRoZSBldmVudCBuYW1lIHRvIGFkZC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciBUaGUgbGlzdGVuZXIgdG8gYWRkLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbnx7Y2FwdHVyZT86Ym9vbGVhbixwYXNzaXZlPzpib29sZWFuLG9uY2U/OmJvb2xlYW59fSBbb3B0aW9uc10gVGhlIG9wdGlvbnMgZm9yIHRoaXMgbGlzdGVuZXIuXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChsaXN0ZW5lciA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSBcImZ1bmN0aW9uXCIgJiYgIWlzT2JqZWN0KGxpc3RlbmVyKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIidsaXN0ZW5lcicgc2hvdWxkIGJlIGEgZnVuY3Rpb24gb3IgYW4gb2JqZWN0LlwiKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gZ2V0TGlzdGVuZXJzKHRoaXMpXG4gICAgICAgIGNvbnN0IG9wdGlvbnNJc09iaiA9IGlzT2JqZWN0KG9wdGlvbnMpXG4gICAgICAgIGNvbnN0IGNhcHR1cmUgPSBvcHRpb25zSXNPYmpcbiAgICAgICAgICAgID8gQm9vbGVhbihvcHRpb25zLmNhcHR1cmUpXG4gICAgICAgICAgICA6IEJvb2xlYW4ob3B0aW9ucylcbiAgICAgICAgY29uc3QgbGlzdGVuZXJUeXBlID0gY2FwdHVyZSA/IENBUFRVUkUgOiBCVUJCTEVcbiAgICAgICAgY29uc3QgbmV3Tm9kZSA9IHtcbiAgICAgICAgICAgIGxpc3RlbmVyLFxuICAgICAgICAgICAgbGlzdGVuZXJUeXBlLFxuICAgICAgICAgICAgcGFzc2l2ZTogb3B0aW9uc0lzT2JqICYmIEJvb2xlYW4ob3B0aW9ucy5wYXNzaXZlKSxcbiAgICAgICAgICAgIG9uY2U6IG9wdGlvbnNJc09iaiAmJiBCb29sZWFuKG9wdGlvbnMub25jZSksXG4gICAgICAgICAgICBuZXh0OiBudWxsLFxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2V0IGl0IGFzIHRoZSBmaXJzdCBub2RlIGlmIHRoZSBmaXJzdCBub2RlIGlzIG51bGwuXG4gICAgICAgIGxldCBub2RlID0gbGlzdGVuZXJzLmdldChldmVudE5hbWUpXG4gICAgICAgIGlmIChub2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxpc3RlbmVycy5zZXQoZXZlbnROYW1lLCBuZXdOb2RlKVxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBUcmF2ZXJzZSB0byB0aGUgdGFpbCB3aGlsZSBjaGVja2luZyBkdXBsaWNhdGlvbi4uXG4gICAgICAgIGxldCBwcmV2ID0gbnVsbFxuICAgICAgICB3aGlsZSAobm9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgbm9kZS5saXN0ZW5lciA9PT0gbGlzdGVuZXIgJiZcbiAgICAgICAgICAgICAgICBub2RlLmxpc3RlbmVyVHlwZSA9PT0gbGlzdGVuZXJUeXBlXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAvLyBTaG91bGQgaWdub3JlIGR1cGxpY2F0aW9uLlxuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJldiA9IG5vZGVcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLm5leHRcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCBpdC5cbiAgICAgICAgcHJldi5uZXh0ID0gbmV3Tm9kZVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYSBnaXZlbiBsaXN0ZW5lciBmcm9tIHRoaXMgZXZlbnQgdGFyZ2V0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgVGhlIGV2ZW50IG5hbWUgdG8gcmVtb3ZlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyIFRoZSBsaXN0ZW5lciB0byByZW1vdmUuXG4gICAgICogQHBhcmFtIHtib29sZWFufHtjYXB0dXJlPzpib29sZWFuLHBhc3NpdmU/OmJvb2xlYW4sb25jZT86Ym9vbGVhbn19IFtvcHRpb25zXSBUaGUgb3B0aW9ucyBmb3IgdGhpcyBsaXN0ZW5lci5cbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICByZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGxpc3RlbmVyID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gZ2V0TGlzdGVuZXJzKHRoaXMpXG4gICAgICAgIGNvbnN0IGNhcHR1cmUgPSBpc09iamVjdChvcHRpb25zKVxuICAgICAgICAgICAgPyBCb29sZWFuKG9wdGlvbnMuY2FwdHVyZSlcbiAgICAgICAgICAgIDogQm9vbGVhbihvcHRpb25zKVxuICAgICAgICBjb25zdCBsaXN0ZW5lclR5cGUgPSBjYXB0dXJlID8gQ0FQVFVSRSA6IEJVQkJMRVxuXG4gICAgICAgIGxldCBwcmV2ID0gbnVsbFxuICAgICAgICBsZXQgbm9kZSA9IGxpc3RlbmVycy5nZXQoZXZlbnROYW1lKVxuICAgICAgICB3aGlsZSAobm9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgbm9kZS5saXN0ZW5lciA9PT0gbGlzdGVuZXIgJiZcbiAgICAgICAgICAgICAgICBub2RlLmxpc3RlbmVyVHlwZSA9PT0gbGlzdGVuZXJUeXBlXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBpZiAocHJldiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBwcmV2Lm5leHQgPSBub2RlLm5leHRcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5vZGUubmV4dCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuc2V0KGV2ZW50TmFtZSwgbm9kZS5uZXh0KVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy5kZWxldGUoZXZlbnROYW1lKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcHJldiA9IG5vZGVcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLm5leHRcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEaXNwYXRjaCBhIGdpdmVuIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7RXZlbnR8e3R5cGU6c3RyaW5nfX0gZXZlbnQgVGhlIGV2ZW50IHRvIGRpc3BhdGNoLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBgZmFsc2VgIGlmIGNhbmNlbGVkLlxuICAgICAqL1xuICAgIGRpc3BhdGNoRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50ID09IG51bGwgfHwgdHlwZW9mIGV2ZW50LnR5cGUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZXZlbnQudHlwZVwiIHNob3VsZCBiZSBhIHN0cmluZy4nKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgbGlzdGVuZXJzIGFyZW4ndCByZWdpc3RlcmVkLCB0ZXJtaW5hdGUuXG4gICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IGdldExpc3RlbmVycyh0aGlzKVxuICAgICAgICBjb25zdCBldmVudE5hbWUgPSBldmVudC50eXBlXG4gICAgICAgIGxldCBub2RlID0gbGlzdGVuZXJzLmdldChldmVudE5hbWUpXG4gICAgICAgIGlmIChub2RlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyBTaW5jZSB3ZSBjYW5ub3QgcmV3cml0ZSBzZXZlcmFsIHByb3BlcnRpZXMsIHNvIHdyYXAgb2JqZWN0LlxuICAgICAgICBjb25zdCB3cmFwcGVkRXZlbnQgPSB3cmFwRXZlbnQodGhpcywgZXZlbnQpXG5cbiAgICAgICAgLy8gVGhpcyBkb2Vzbid0IHByb2Nlc3MgY2FwdHVyaW5nIHBoYXNlIGFuZCBidWJibGluZyBwaGFzZS5cbiAgICAgICAgLy8gVGhpcyBpc24ndCBwYXJ0aWNpcGF0aW5nIGluIGEgdHJlZS5cbiAgICAgICAgbGV0IHByZXYgPSBudWxsXG4gICAgICAgIHdoaWxlIChub2RlICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGlzIGxpc3RlbmVyIGlmIGl0J3Mgb25jZVxuICAgICAgICAgICAgaWYgKG5vZGUub25jZSkge1xuICAgICAgICAgICAgICAgIGlmIChwcmV2ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXYubmV4dCA9IG5vZGUubmV4dFxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobm9kZS5uZXh0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy5zZXQoZXZlbnROYW1lLCBub2RlLm5leHQpXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLmRlbGV0ZShldmVudE5hbWUpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcmV2ID0gbm9kZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDYWxsIHRoaXMgbGlzdGVuZXJcbiAgICAgICAgICAgIHNldFBhc3NpdmVMaXN0ZW5lcihcbiAgICAgICAgICAgICAgICB3cmFwcGVkRXZlbnQsXG4gICAgICAgICAgICAgICAgbm9kZS5wYXNzaXZlID8gbm9kZS5saXN0ZW5lciA6IG51bGxcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygbm9kZS5saXN0ZW5lciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5saXN0ZW5lci5jYWxsKHRoaXMsIHdyYXBwZWRFdmVudClcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBjb25zb2xlLmVycm9yID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycilcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgbm9kZS5saXN0ZW5lclR5cGUgIT09IEFUVFJJQlVURSAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBub2RlLmxpc3RlbmVyLmhhbmRsZUV2ZW50ID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIG5vZGUubGlzdGVuZXIuaGFuZGxlRXZlbnQod3JhcHBlZEV2ZW50KVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBCcmVhayBpZiBgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uYCB3YXMgY2FsbGVkLlxuICAgICAgICAgICAgaWYgKGlzU3RvcHBlZCh3cmFwcGVkRXZlbnQpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbm9kZSA9IG5vZGUubmV4dFxuICAgICAgICB9XG4gICAgICAgIHNldFBhc3NpdmVMaXN0ZW5lcih3cmFwcGVkRXZlbnQsIG51bGwpXG4gICAgICAgIHNldEV2ZW50UGhhc2Uod3JhcHBlZEV2ZW50LCAwKVxuICAgICAgICBzZXRDdXJyZW50VGFyZ2V0KHdyYXBwZWRFdmVudCwgbnVsbClcblxuICAgICAgICByZXR1cm4gIXdyYXBwZWRFdmVudC5kZWZhdWx0UHJldmVudGVkXG4gICAgfSxcbn1cblxuLy8gYGNvbnN0cnVjdG9yYCBpcyBub3QgZW51bWVyYWJsZS5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudFRhcmdldC5wcm90b3R5cGUsIFwiY29uc3RydWN0b3JcIiwge1xuICAgIHZhbHVlOiBFdmVudFRhcmdldCxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG59KVxuXG4vLyBFbnN1cmUgYGV2ZW50VGFyZ2V0IGluc3RhbmNlb2Ygd2luZG93LkV2ZW50VGFyZ2V0YCBpcyBgdHJ1ZWAuXG5pZiAoXG4gICAgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgIHR5cGVvZiB3aW5kb3cuRXZlbnRUYXJnZXQgIT09IFwidW5kZWZpbmVkXCJcbikge1xuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihFdmVudFRhcmdldC5wcm90b3R5cGUsIHdpbmRvdy5FdmVudFRhcmdldC5wcm90b3R5cGUpXG59XG5cbmV4cG9ydCB7IGRlZmluZUV2ZW50QXR0cmlidXRlLCBFdmVudFRhcmdldCB9XG5leHBvcnQgZGVmYXVsdCBFdmVudFRhcmdldFxuIiwgImltcG9ydCB7XG4gICAgLy8gRXZlbnQsXG4gICAgRXZlbnRUYXJnZXQsXG4gICAgLy8gVHlwZSxcbiAgICBkZWZpbmVFdmVudEF0dHJpYnV0ZSxcbn0gZnJvbSBcImV2ZW50LXRhcmdldC1zaGltXCJcblxuLy8gS25vd24gTGltaXRhdGlvblxuLy8gICBVc2UgYGFueWAgYmVjYXVzZSB0aGUgdHlwZSBvZiBgQWJvcnRTaWduYWxgIGluIGBsaWIuZG9tLmQudHNgIGlzIHdyb25nIGFuZFxuLy8gICB0byBtYWtlIGFzc2lnbmFibGUgb3VyIGBBYm9ydFNpZ25hbGAgaW50byB0aGF0LlxuLy8gICBodHRwczovL2dpdGh1Yi5jb20vTWljcm9zb2Z0L1RTSlMtbGliLWdlbmVyYXRvci9wdWxsLzYyM1xudHlwZSBFdmVudHMgPSB7XG4gICAgYWJvcnQ6IGFueSAvLyBFdmVudCAmIFR5cGU8XCJhYm9ydFwiPlxufVxudHlwZSBFdmVudEF0dHJpYnV0ZXMgPSB7XG4gICAgb25hYm9ydDogYW55IC8vIEV2ZW50ICYgVHlwZTxcImFib3J0XCI+XG59XG5cbi8qKlxuICogVGhlIHNpZ25hbCBjbGFzcy5cbiAqIEBzZWUgaHR0cHM6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNhYm9ydHNpZ25hbFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBYm9ydFNpZ25hbCBleHRlbmRzIEV2ZW50VGFyZ2V0PEV2ZW50cywgRXZlbnRBdHRyaWJ1dGVzPiB7XG4gICAgLyoqXG4gICAgICogQWJvcnRTaWduYWwgY2Fubm90IGJlIGNvbnN0cnVjdGVkIGRpcmVjdGx5LlxuICAgICAqL1xuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQWJvcnRTaWduYWwgY2Fubm90IGJlIGNvbnN0cnVjdGVkIGRpcmVjdGx5XCIpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhpcyBgQWJvcnRTaWduYWxgJ3MgYEFib3J0Q29udHJvbGxlcmAgaGFzIHNpZ25hbGVkIHRvIGFib3J0LCBhbmQgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgICovXG4gICAgcHVibGljIGdldCBhYm9ydGVkKCk6IGJvb2xlYW4ge1xuICAgICAgICBjb25zdCBhYm9ydGVkID0gYWJvcnRlZEZsYWdzLmdldCh0aGlzKVxuICAgICAgICBpZiAodHlwZW9mIGFib3J0ZWQgIT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICAgIGBFeHBlY3RlZCAndGhpcycgdG8gYmUgYW4gJ0Fib3J0U2lnbmFsJyBvYmplY3QsIGJ1dCBnb3QgJHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcyA9PT0gbnVsbCA/IFwibnVsbFwiIDogdHlwZW9mIHRoaXNcbiAgICAgICAgICAgICAgICB9YCxcbiAgICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWJvcnRlZFxuICAgIH1cbn1cbmRlZmluZUV2ZW50QXR0cmlidXRlKEFib3J0U2lnbmFsLnByb3RvdHlwZSwgXCJhYm9ydFwiKVxuXG4vKipcbiAqIENyZWF0ZSBhbiBBYm9ydFNpZ25hbCBvYmplY3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVBYm9ydFNpZ25hbCgpOiBBYm9ydFNpZ25hbCB7XG4gICAgY29uc3Qgc2lnbmFsID0gT2JqZWN0LmNyZWF0ZShBYm9ydFNpZ25hbC5wcm90b3R5cGUpXG4gICAgRXZlbnRUYXJnZXQuY2FsbChzaWduYWwpXG4gICAgYWJvcnRlZEZsYWdzLnNldChzaWduYWwsIGZhbHNlKVxuICAgIHJldHVybiBzaWduYWxcbn1cblxuLyoqXG4gKiBBYm9ydCBhIGdpdmVuIHNpZ25hbC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFib3J0U2lnbmFsKHNpZ25hbDogQWJvcnRTaWduYWwpOiB2b2lkIHtcbiAgICBpZiAoYWJvcnRlZEZsYWdzLmdldChzaWduYWwpICE9PSBmYWxzZSkge1xuICAgICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBhYm9ydGVkRmxhZ3Muc2V0KHNpZ25hbCwgdHJ1ZSlcbiAgICBzaWduYWwuZGlzcGF0Y2hFdmVudDxcImFib3J0XCI+KHsgdHlwZTogXCJhYm9ydFwiIH0pXG59XG5cbi8qKlxuICogQWJvcnRlZCBmbGFnIGZvciBlYWNoIGluc3RhbmNlcy5cbiAqL1xuY29uc3QgYWJvcnRlZEZsYWdzID0gbmV3IFdlYWtNYXA8QWJvcnRTaWduYWwsIGJvb2xlYW4+KClcblxuLy8gUHJvcGVydGllcyBzaG91bGQgYmUgZW51bWVyYWJsZS5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEFib3J0U2lnbmFsLnByb3RvdHlwZSwge1xuICAgIGFib3J0ZWQ6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxufSlcblxuLy8gYHRvU3RyaW5nKClgIHNob3VsZCByZXR1cm4gYFwiW29iamVjdCBBYm9ydFNpZ25hbF1cImBcbmlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZyA9PT0gXCJzeW1ib2xcIikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYm9ydFNpZ25hbC5wcm90b3R5cGUsIFN5bWJvbC50b1N0cmluZ1RhZywge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBcIkFib3J0U2lnbmFsXCIsXG4gICAgfSlcbn1cbiIsICJpbXBvcnQgQWJvcnRTaWduYWwsIHsgYWJvcnRTaWduYWwsIGNyZWF0ZUFib3J0U2lnbmFsIH0gZnJvbSBcIi4vYWJvcnQtc2lnbmFsXCJcblxuLyoqXG4gKiBUaGUgQWJvcnRDb250cm9sbGVyLlxuICogQHNlZSBodHRwczovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI2Fib3J0Y29udHJvbGxlclxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBYm9ydENvbnRyb2xsZXIge1xuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgdGhpcyBjb250cm9sbGVyLlxuICAgICAqL1xuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc2lnbmFscy5zZXQodGhpcywgY3JlYXRlQWJvcnRTaWduYWwoKSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBgQWJvcnRTaWduYWxgIG9iamVjdCBhc3NvY2lhdGVkIHdpdGggdGhpcyBvYmplY3QuXG4gICAgICovXG4gICAgcHVibGljIGdldCBzaWduYWwoKTogQWJvcnRTaWduYWwge1xuICAgICAgICByZXR1cm4gZ2V0U2lnbmFsKHRoaXMpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWJvcnQgYW5kIHNpZ25hbCB0byBhbnkgb2JzZXJ2ZXJzIHRoYXQgdGhlIGFzc29jaWF0ZWQgYWN0aXZpdHkgaXMgdG8gYmUgYWJvcnRlZC5cbiAgICAgKi9cbiAgICBwdWJsaWMgYWJvcnQoKTogdm9pZCB7XG4gICAgICAgIGFib3J0U2lnbmFsKGdldFNpZ25hbCh0aGlzKSlcbiAgICB9XG59XG5cbi8qKlxuICogQXNzb2NpYXRlZCBzaWduYWxzLlxuICovXG5jb25zdCBzaWduYWxzID0gbmV3IFdlYWtNYXA8QWJvcnRDb250cm9sbGVyLCBBYm9ydFNpZ25hbD4oKVxuXG4vKipcbiAqIEdldCB0aGUgYXNzb2NpYXRlZCBzaWduYWwgb2YgYSBnaXZlbiBjb250cm9sbGVyLlxuICovXG5mdW5jdGlvbiBnZXRTaWduYWwoY29udHJvbGxlcjogQWJvcnRDb250cm9sbGVyKTogQWJvcnRTaWduYWwge1xuICAgIGNvbnN0IHNpZ25hbCA9IHNpZ25hbHMuZ2V0KGNvbnRyb2xsZXIpXG4gICAgaWYgKHNpZ25hbCA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICBgRXhwZWN0ZWQgJ3RoaXMnIHRvIGJlIGFuICdBYm9ydENvbnRyb2xsZXInIG9iamVjdCwgYnV0IGdvdCAke1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIgPT09IG51bGwgPyBcIm51bGxcIiA6IHR5cGVvZiBjb250cm9sbGVyXG4gICAgICAgICAgICB9YCxcbiAgICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gc2lnbmFsXG59XG5cbi8vIFByb3BlcnRpZXMgc2hvdWxkIGJlIGVudW1lcmFibGUuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhBYm9ydENvbnRyb2xsZXIucHJvdG90eXBlLCB7XG4gICAgc2lnbmFsOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgICBhYm9ydDogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG59KVxuXG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWcgPT09IFwic3ltYm9sXCIpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJvcnRDb250cm9sbGVyLnByb3RvdHlwZSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IFwiQWJvcnRDb250cm9sbGVyXCIsXG4gICAgfSlcbn1cblxuZXhwb3J0IHsgQWJvcnRDb250cm9sbGVyLCBBYm9ydFNpZ25hbCB9XG4iLCAiZXhwb3J0ICogZnJvbSAnLi9tZXRhcGxleCc7XG5leHBvcnQgKiBmcm9tICcuL3R5cGVzJztcbiIsICJpbXBvcnQgeyBJbnN0cnVjdGlvbiwgUHVia2V5LCBSZXN1bHQsIFNlY3JldCB9IGZyb20gJ0Bzb2xhbmEtc3VpdGUvc2hhcmVkJztcbmltcG9ydCB7IFNwbFRva2VuIH0gZnJvbSAnQHNvbGFuYS1zdWl0ZS9jb3JlJztcblxuZXhwb3J0IG5hbWVzcGFjZSBNZXRhcGxleCB7XG4gIGNvbnN0IE5GVF9BTU9VTlQgPSAxO1xuICBjb25zdCBORlRfREVDSU1BTFMgPSAwO1xuXG4gIGV4cG9ydCBjb25zdCBidXJuID0gKFxuICAgIG1pbnQ6IFB1YmtleSxcbiAgICBvd25lcjogUHVia2V5LFxuICAgIHNpZ25lcjogU2VjcmV0LFxuICAgIGZlZVBheWVyPzogU2VjcmV0XG4gICk6IFJlc3VsdDxJbnN0cnVjdGlvbiwgRXJyb3I+ID0+IHtcbiAgICByZXR1cm4gU3BsVG9rZW4uYnVybihcbiAgICAgIG1pbnQsXG4gICAgICBvd25lcixcbiAgICAgIFtzaWduZXJdLFxuICAgICAgTkZUX0FNT1VOVCxcbiAgICAgIE5GVF9ERUNJTUFMUyxcbiAgICAgIGZlZVBheWVyXG4gICAgKTtcbiAgfTtcbn1cbiIsICJpbXBvcnQge1xuICBJbmZyYVNpZGVJbnB1dCxcbiAgSW5mcmFTaWRlT3V0cHV0LFxuICBPcHRpb24sXG4gIFVzZXJTaWRlSW5wdXQsXG4gIFVzZXJTaWRlT3V0cHV0LFxufSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBuYW1lc3BhY2UgQ29udmVydCB7XG4gIGV4cG9ydCBuYW1lc3BhY2UgQ29sbGVjdGlvbiB7XG4gICAgZXhwb3J0IGNvbnN0IGludG9JbmZyYVNpZGUgPSAoXG4gICAgICBpbnB1dDogT3B0aW9uPFVzZXJTaWRlSW5wdXQuQ29sbGVjdGlvbj4gfCB1bmRlZmluZWQsXG4gICAgKTogT3B0aW9uPEluZnJhU2lkZUlucHV0LkNvbGxlY3Rpb24+ID0+IHtcbiAgICAgIGlmICghaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGtleTogaW5wdXQudG9QdWJsaWNLZXkoKSxcbiAgICAgICAgdmVyaWZpZWQ6IGZhbHNlLFxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgZXhwb3J0IGNvbnN0IGludG9Vc2VyU2lkZSA9IChcbiAgICAgIG91dHB1dDogT3B0aW9uPEluZnJhU2lkZU91dHB1dC5Db2xsZWN0aW9uPixcbiAgICApOiBVc2VyU2lkZU91dHB1dC5Db2xsZWN0aW9uIHwgdW5kZWZpbmVkID0+IHtcbiAgICAgIGlmICghb3V0cHV0KSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGFkZHJlc3M6IG91dHB1dC5rZXkudG9TdHJpbmcoKSxcbiAgICAgICAgdmVyaWZpZWQ6IG91dHB1dC52ZXJpZmllZCxcbiAgICAgIH07XG4gICAgfTtcbiAgfVxufVxuIiwgImltcG9ydCB7XG4gIEluZnJhU2lkZUlucHV0LFxuICBJbmZyYVNpZGVPdXRwdXQsXG4gIE9wdGlvbixcbiAgVXNlclNpZGVJbnB1dCxcbiAgVXNlclNpZGVPdXRwdXQsXG59IGZyb20gJy4uL3R5cGVzJztcblxuZXhwb3J0IG5hbWVzcGFjZSBDb252ZXJ0IHtcbiAgZXhwb3J0IG5hbWVzcGFjZSBDcmVhdG9ycyB7XG4gICAgZXhwb3J0IGNvbnN0IGludG9JbmZyYVNpZGUgPSAoXG4gICAgICBpbnB1dDogT3B0aW9uPFVzZXJTaWRlSW5wdXQuQ3JlYXRvcnNbXT4gfCB1bmRlZmluZWQsXG4gICAgKTogT3B0aW9uPEluZnJhU2lkZUlucHV0LkNyZWF0b3JzW10+ID0+IHtcbiAgICAgIGlmICghaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gaW5wdXQubWFwKChkYXRhKSA9PiB7XG4gICAgICAgIGxldCBtb2RpZnk6IE9wdGlvbjxJbmZyYVNpZGVJbnB1dC5DcmVhdG9ycz4gPSBudWxsO1xuICAgICAgICBtb2RpZnkgPSB7XG4gICAgICAgICAgYWRkcmVzczogZGF0YS5hZGRyZXNzLnRvUHVibGljS2V5KCksXG4gICAgICAgICAgc2hhcmU6IGRhdGEuc2hhcmUsXG4gICAgICAgICAgdmVyaWZpZWQ6IGRhdGEudmVyaWZpZWQsXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIG1vZGlmeTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBleHBvcnQgY29uc3QgaW50b1VzZXJTaWRlID0gKFxuICAgICAgb3V0cHV0OiBPcHRpb248SW5mcmFTaWRlT3V0cHV0LkNyZWF0b3JbXT4sXG4gICAgKTogVXNlclNpZGVPdXRwdXQuQ3JlYXRvcnNbXSB8IHVuZGVmaW5lZCA9PiB7XG4gICAgICBpZiAoIW91dHB1dCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb3V0cHV0Lm1hcCgoZGF0YSkgPT4ge1xuICAgICAgICBjb25zdCBtb2RpZnkgPSB7XG4gICAgICAgICAgYWRkcmVzczogZGF0YS5hZGRyZXNzLnRvU3RyaW5nKCksXG4gICAgICAgICAgc2hhcmU6IGRhdGEuc2hhcmUsXG4gICAgICAgICAgdmVyaWZpZWQ6IGRhdGEudmVyaWZpZWQsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBtb2RpZnk7XG4gICAgICB9KTtcbiAgICB9O1xuICB9XG59XG4iLCAiaW1wb3J0IHsgSW5mcmFTaWRlT3V0cHV0LCBPcHRpb24sIFVzZXJTaWRlT3V0cHV0IH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgbmFtZXNwYWNlIENvbnZlcnQge1xuICBleHBvcnQgbmFtZXNwYWNlIFVzZXMge1xuICAgIGV4cG9ydCBjb25zdCBpbnRvVXNlclNpZGUgPSAoXG4gICAgICBvdXRwdXQ6IE9wdGlvbjxJbmZyYVNpZGVPdXRwdXQuVXNlcz4sXG4gICAgKTogVXNlclNpZGVPdXRwdXQuVXNlcyB8IHVuZGVmaW5lZCA9PiB7XG4gICAgICBpZiAoIW91dHB1dCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9O1xuICB9XG59XG4iLCAiaW1wb3J0IHsgQ29udmVydCBhcyBfQ3JlYXRvcnMgfSBmcm9tICcuL2NyZWF0b3JzJztcbmltcG9ydCB7IENvbnZlcnQgYXMgX1VzZXMgfSBmcm9tICcuL3VzZXMnO1xuaW1wb3J0IHtcbiAgSW5mcmFTaWRlSW5wdXQsXG4gIEluZnJhU2lkZU91dHB1dCxcbiAgVXNlclNpZGVJbnB1dCxcbiAgVXNlclNpZGVPdXRwdXQsXG59IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHsgY29udmVydFRpbWVzdGFtcFRvRGF0ZVRpbWUgfSBmcm9tICdAc29sYW5hLXN1aXRlL3NoYXJlZCc7XG5leHBvcnQgbmFtZXNwYWNlIENvbnZlcnQge1xuICBleHBvcnQgbmFtZXNwYWNlIFRva2VuTWV0YWRhdGEge1xuICAgIGV4cG9ydCBjb25zdCBpbnRvSW5mcmFTaWRlID0gKFxuICAgICAgaW5wdXQ6IFVzZXJTaWRlSW5wdXQuVG9rZW5NZXRhZGF0YSxcbiAgICAgIHVyaTogc3RyaW5nLFxuICAgICAgc2VsbGVyRmVlQmFzaXNQb2ludHM6IG51bWJlcixcbiAgICApOiBJbmZyYVNpZGVJbnB1dC5NZXRhcGxleERhdGFWMiA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiBpbnB1dC5uYW1lLFxuICAgICAgICBzeW1ib2w6IGlucHV0LnN5bWJvbCxcbiAgICAgICAgdXJpLFxuICAgICAgICBzZWxsZXJGZWVCYXNpc1BvaW50cyxcbiAgICAgICAgY3JlYXRvcnM6IF9DcmVhdG9ycy5DcmVhdG9ycy5pbnRvSW5mcmFTaWRlKGlucHV0LmNyZWF0b3JzKSxcbiAgICAgICAgY29sbGVjdGlvbjogbnVsbCxcbiAgICAgICAgdXNlczogaW5wdXQudXNlcyB8fCBudWxsLFxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgZXhwb3J0IGNvbnN0IGludG9Vc2VyU2lkZSA9IChcbiAgICAgIG91dHB1dDogSW5mcmFTaWRlT3V0cHV0Lk9uY2hhaW5BbmRPZmZjaGFpbixcbiAgICAgIHRva2VuQW1vdW50OiBzdHJpbmcsXG4gICAgKTogVXNlclNpZGVPdXRwdXQuVG9rZW5NZXRhZGF0YSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtaW50OiBvdXRwdXQub25jaGFpbi5taW50LnRvU3RyaW5nKCksXG4gICAgICAgIHJveWFsdHk6IG91dHB1dC5vbmNoYWluLmRhdGEuc2VsbGVyRmVlQmFzaXNQb2ludHMsXG4gICAgICAgIG5hbWU6IGRlbGV0ZU51bGxTdHJpbmdzKG91dHB1dC5vbmNoYWluLmRhdGEubmFtZSksXG4gICAgICAgIHN5bWJvbDogZGVsZXRlTnVsbFN0cmluZ3Mob3V0cHV0Lm9uY2hhaW4uZGF0YS5zeW1ib2wpLFxuICAgICAgICB0b2tlbkFtb3VudDogdG9rZW5BbW91bnQsXG4gICAgICAgIHVyaTogZGVsZXRlTnVsbFN0cmluZ3Mob3V0cHV0Lm9uY2hhaW4uZGF0YS51cmkpLFxuICAgICAgICBjcmVhdG9yczogX0NyZWF0b3JzLkNyZWF0b3JzLmludG9Vc2VyU2lkZShvdXRwdXQub25jaGFpbi5kYXRhLmNyZWF0b3JzKSxcbiAgICAgICAgdXNlczogX1VzZXMuVXNlcy5pbnRvVXNlclNpZGUob3V0cHV0Lm9uY2hhaW4udXNlcyksXG4gICAgICAgIGRhdGVUaW1lOiBjb252ZXJ0VGltZXN0YW1wVG9EYXRlVGltZShvdXRwdXQub2ZmY2hhaW4uY3JlYXRlZF9hdCksXG4gICAgICAgIG9mZmNoYWluOiBvdXRwdXQub2ZmY2hhaW4sXG4gICAgICB9O1xuICAgIH07XG4gICAgLy8gZGVsZXRlIE5VTEwoMHgwMCkgc3RyaW5ncyBmdW5jdGlvblxuICAgIGV4cG9ydCBjb25zdCBkZWxldGVOdWxsU3RyaW5ncyA9IChzdHI6IHN0cmluZyk6IHN0cmluZyA9PiB7XG4gICAgICByZXR1cm4gc3RyLnJlcGxhY2UoL1xcMC9nLCAnJyk7XG4gICAgfTtcbiAgfVxufVxuIiwgImltcG9ydCB7IENvbnZlcnQgYXMgX0NvbGxlY3Rpb24gfSBmcm9tICcuL2NvbGxlY3Rpb24nO1xuaW1wb3J0IHsgQ29udmVydCBhcyBfQ3JlYXRvcnMgfSBmcm9tICcuL2NyZWF0b3JzJztcbmltcG9ydCB7IENvbnZlcnQgYXMgX1VzZXMgfSBmcm9tICcuL3VzZXMnO1xuaW1wb3J0IHsgQ29udmVydCBhcyBfVG9rZW4gfSBmcm9tICcuL3Rva2VuLW1ldGFkYXRhJztcbmltcG9ydCB7XG4gIEluZnJhU2lkZUlucHV0LFxuICBJbmZyYVNpZGVPdXRwdXQsXG4gIFVzZXJTaWRlSW5wdXQsXG4gIFVzZXJTaWRlT3V0cHV0LFxufSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7IGNvbnZlcnRUaW1lc3RhbXBUb0RhdGVUaW1lIH0gZnJvbSAnQHNvbGFuYS1zdWl0ZS9zaGFyZWQnO1xuXG5leHBvcnQgbmFtZXNwYWNlIENvbnZlcnQge1xuICBleHBvcnQgbmFtZXNwYWNlIE5mdE1ldGFkYXRhIHtcbiAgICBleHBvcnQgY29uc3QgaW50b0luZnJhU2lkZSA9IChcbiAgICAgIGlucHV0OiBVc2VyU2lkZUlucHV0Lk5mdE1ldGFkYXRhLFxuICAgICAgdXJpOiBzdHJpbmcsXG4gICAgICBzZWxsZXJGZWVCYXNpc1BvaW50czogbnVtYmVyLFxuICAgICk6IEluZnJhU2lkZUlucHV0Lk1ldGFwbGV4RGF0YVYyID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IGlucHV0Lm5hbWUsXG4gICAgICAgIHN5bWJvbDogaW5wdXQuc3ltYm9sLFxuICAgICAgICB1cmksXG4gICAgICAgIHNlbGxlckZlZUJhc2lzUG9pbnRzLFxuICAgICAgICBjcmVhdG9yczogX0NyZWF0b3JzLkNyZWF0b3JzLmludG9JbmZyYVNpZGUoaW5wdXQuY3JlYXRvcnMpLFxuICAgICAgICBjb2xsZWN0aW9uOiBfQ29sbGVjdGlvbi5Db2xsZWN0aW9uLmludG9JbmZyYVNpZGUoaW5wdXQuY29sbGVjdGlvbiksXG4gICAgICAgIHVzZXM6IGlucHV0LnVzZXMgfHwgbnVsbCxcbiAgICAgIH07XG4gICAgfTtcblxuICAgIGV4cG9ydCBjb25zdCBpbnRvVXNlclNpZGUgPSAoXG4gICAgICBvdXRwdXQ6IEluZnJhU2lkZU91dHB1dC5PbmNoYWluQW5kT2ZmY2hhaW4sXG4gICAgICB0b2tlbkFtb3VudDogc3RyaW5nLFxuICAgICk6IFVzZXJTaWRlT3V0cHV0Lk5mdE1ldGFkYXRhID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1pbnQ6IG91dHB1dC5vbmNoYWluLm1pbnQudG9TdHJpbmcoKSxcbiAgICAgICAgdXBkYXRlQXV0aG9yaXR5OiBvdXRwdXQub25jaGFpbi51cGRhdGVBdXRob3JpdHkudG9TdHJpbmcoKSxcbiAgICAgICAgcm95YWx0eTogb3V0cHV0Lm9uY2hhaW4uZGF0YS5zZWxsZXJGZWVCYXNpc1BvaW50cyxcbiAgICAgICAgbmFtZTogX1Rva2VuLlRva2VuTWV0YWRhdGEuZGVsZXRlTnVsbFN0cmluZ3Mob3V0cHV0Lm9uY2hhaW4uZGF0YS5uYW1lKSxcbiAgICAgICAgc3ltYm9sOiBfVG9rZW4uVG9rZW5NZXRhZGF0YS5kZWxldGVOdWxsU3RyaW5ncyhcbiAgICAgICAgICBvdXRwdXQub25jaGFpbi5kYXRhLnN5bWJvbCxcbiAgICAgICAgKSxcbiAgICAgICAgdG9rZW5BbW91bnQ6IHRva2VuQW1vdW50LFxuICAgICAgICB1cmk6IF9Ub2tlbi5Ub2tlbk1ldGFkYXRhLmRlbGV0ZU51bGxTdHJpbmdzKG91dHB1dC5vbmNoYWluLmRhdGEudXJpKSxcbiAgICAgICAgaXNNdXRhYmxlOiBvdXRwdXQub25jaGFpbi5pc011dGFibGUsXG4gICAgICAgIHByaW1hcnlTYWxlSGFwcGVuZWQ6IG91dHB1dC5vbmNoYWluLnByaW1hcnlTYWxlSGFwcGVuZWQsXG4gICAgICAgIGNyZWF0b3JzOiBfQ3JlYXRvcnMuQ3JlYXRvcnMuaW50b1VzZXJTaWRlKG91dHB1dC5vbmNoYWluLmRhdGEuY3JlYXRvcnMpLFxuICAgICAgICBlZGl0aW9uTm9uY2U6IG91dHB1dC5vbmNoYWluLmVkaXRpb25Ob25jZSxcbiAgICAgICAgY29sbGVjdGlvbjogX0NvbGxlY3Rpb24uQ29sbGVjdGlvbi5pbnRvVXNlclNpZGUoXG4gICAgICAgICAgb3V0cHV0Lm9uY2hhaW4uY29sbGVjdGlvbixcbiAgICAgICAgKSxcbiAgICAgICAgdXNlczogX1VzZXMuVXNlcy5pbnRvVXNlclNpZGUob3V0cHV0Lm9uY2hhaW4udXNlcyksXG4gICAgICAgIGRhdGVUaW1lOiBjb252ZXJ0VGltZXN0YW1wVG9EYXRlVGltZShvdXRwdXQub2ZmY2hhaW4uY3JlYXRlZF9hdCksXG4gICAgICAgIG9mZmNoYWluOiBvdXRwdXQub2ZmY2hhaW4sXG4gICAgICB9O1xuICAgIH07XG4gIH1cbn1cbiIsICJpbXBvcnQgeyBvdmVyd3JpdGVPYmplY3QsIFJlc3VsdCwgU2VjcmV0IH0gZnJvbSAnQHNvbGFuYS1zdWl0ZS9zaGFyZWQnO1xuaW1wb3J0IHtcbiAgRmlsZUNvbnRlbnQsXG4gIEluZnJhU2lkZUlucHV0LFxuICBTdG9yYWdlVHlwZSxcbiAgVXNlclNpZGVJbnB1dCxcbn0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgbmFtZXNwYWNlIENvbnZlcnQge1xuICBleHBvcnQgbmFtZXNwYWNlIFByb3BlcnRpZXMge1xuICAgIGV4cG9ydCBjb25zdCBpbnRvSW5mcmFTaWRlID0gYXN5bmMgKFxuICAgICAgaW5wdXQ6IFVzZXJTaWRlSW5wdXQuUHJvcGVydGllcyB8IHVuZGVmaW5lZCxcbiAgICAgIHN0b3JhZ2VGdW5jOiAoXG4gICAgICAgIGRhdGE6IEZpbGVDb250ZW50LFxuICAgICAgICBzdG9yYWdlVHlwZTogU3RvcmFnZVR5cGUsXG4gICAgICAgIGZlZVBheWVyPzogU2VjcmV0LFxuICAgICAgKSA9PiBQcm9taXNlPFJlc3VsdDxzdHJpbmcsIEVycm9yPj4sXG4gICAgICBzdG9yYWdlVHlwZTogU3RvcmFnZVR5cGUsXG4gICAgICBmZWVQYXllcj86IFNlY3JldCxcbiAgICApOiBQcm9taXNlPEluZnJhU2lkZUlucHV0LlByb3BlcnRpZXM+ID0+IHtcbiAgICAgIGlmICghaW5wdXQgfHwgIWlucHV0LmZpbGVzKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZmlsZXMgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgaW5wdXQuZmlsZXMubWFwKGFzeW5jIChmaWxlKSA9PiB7XG4gICAgICAgICAgaWYgKCFmaWxlLmZpbGVQYXRoKSB7XG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHN0b3JhZ2VGdW5jKGZpbGUuZmlsZVBhdGgsIHN0b3JhZ2VUeXBlLCBmZWVQYXllcik7XG4gICAgICAgICAgaWYgKHJlcy5pc0Vycikge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IocmVzLmVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gb3ZlcndyaXRlT2JqZWN0KGZpbGUsIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgZXhpc3RzS2V5OiAnZmlsZVBhdGgnLFxuICAgICAgICAgICAgICB3aWxsOiB7IGtleTogJ3VyaScsIHZhbHVlOiByZXMudmFsdWUgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgXSk7XG4gICAgICAgIH0pLFxuICAgICAgKTtcbiAgICAgIHJldHVybiB7IC4uLmlucHV0LCBmaWxlcyB9IGFzIEluZnJhU2lkZUlucHV0LlByb3BlcnRpZXM7XG4gICAgfTtcbiAgfVxufVxuIiwgImltcG9ydCB7IENvbnZlcnQgYXMgQ29sbGVjdGlvbiB9IGZyb20gJy4vY29sbGVjdGlvbic7XG5pbXBvcnQgeyBDb252ZXJ0IGFzIENyZWF0b3JzIH0gZnJvbSAnLi9jcmVhdG9ycyc7XG5pbXBvcnQgeyBDb252ZXJ0IGFzIE5mdE1ldGFkYXRhIH0gZnJvbSAnLi9uZnQtbWV0YWRhdGEnO1xuaW1wb3J0IHsgQ29udmVydCBhcyBQcm9wZXJ0aWVzIH0gZnJvbSAnLi9wcm9wZXJ0aWVzJztcbmltcG9ydCB7IENvbnZlcnQgYXMgVG9rZW5NZXRhZGF0YSB9IGZyb20gJy4vdG9rZW4tbWV0YWRhdGEnO1xuaW1wb3J0IHsgQ29udmVydCBhcyBVc2VzIH0gZnJvbSAnLi91c2VzJztcblxuZXhwb3J0IGNvbnN0IENvbnZlcnQgPSB7XG4gIC4uLkNvbGxlY3Rpb24sXG4gIC4uLkNyZWF0b3JzLFxuICAuLi5OZnRNZXRhZGF0YSxcbiAgLi4uUHJvcGVydGllcyxcbiAgLi4uVG9rZW5NZXRhZGF0YSxcbiAgLi4uVXNlcyxcbn07XG4iLCAiaW1wb3J0IHsgU3RvcmFnZVR5cGUgfSBmcm9tICcuLi8uLi90eXBlcyc7XG5pbXBvcnQgeyBfU2hhcmVkLCBiaWdudW0sIEZpbGVDb250ZW50IH0gZnJvbSAnLi4vc2hhcmVkJztcbmltcG9ydCB7IFB1YmtleSB9IGZyb20gJ0Bzb2xhbmEtc3VpdGUvc2hhcmVkJztcblxuZXhwb3J0IG5hbWVzcGFjZSBVc2VyU2lkZUlucHV0IHtcbiAgZXhwb3J0IHR5cGUgQ29sbGVjdGlvbiA9IFB1YmtleTtcblxuICBleHBvcnQgdHlwZSBDcmVhdG9ycyA9IHtcbiAgICBhZGRyZXNzOiBQdWJrZXk7XG4gICAgc2hhcmU6IG51bWJlcjtcbiAgICB2ZXJpZmllZDogYm9vbGVhbjtcbiAgfTtcblxuICBleHBvcnQgdHlwZSBQcm9wZXJ0aWVzID0gX1NoYXJlZC5Qcm9wZXJ0aWVzO1xuXG4gIGV4cG9ydCBlbnVtIFRva2VuU3RhbmRhcmQge1xuICAgIE5vbkZ1bmdpYmxlID0gMCxcbiAgICBGdW5naWJsZUFzc2V0ID0gMSxcbiAgICBGdW5naWJsZSA9IDIsXG4gICAgTm9uRnVuZ2libGVFZGl0aW9uID0gMyxcbiAgICBQcm9ncmFtbWFibGVOb25GdW5naWJsZSA9IDQsXG4gIH1cblxuICBleHBvcnQgdHlwZSBOZnRNZXRhZGF0YSA9IHtcbiAgICBuYW1lOiBzdHJpbmc7XG4gICAgc3ltYm9sOiBzdHJpbmc7XG4gICAgcm95YWx0eTogbnVtYmVyO1xuICAgIHN0b3JhZ2VUeXBlPzogU3RvcmFnZVR5cGU7XG4gICAgZmlsZVBhdGg/OiBGaWxlQ29udGVudDtcbiAgICB1cmk/OiBzdHJpbmc7XG4gICAgaXNNdXRhYmxlPzogYm9vbGVhbjtcbiAgICBkZXNjcmlwdGlvbj86IHN0cmluZztcbiAgICBleHRlcm5hbF91cmw/OiBzdHJpbmc7XG4gICAgYXR0cmlidXRlcz86IF9TaGFyZWQuQXR0cmlidXRlW107XG4gICAgcHJvcGVydGllcz86IFByb3BlcnRpZXM7XG4gICAgbWF4U3VwcGx5PzogYmlnbnVtO1xuICAgIGNyZWF0b3JzPzogQ3JlYXRvcnNbXTtcbiAgICB1c2VzPzogX1NoYXJlZC5Vc2VzO1xuICAgIGNvbGxlY3Rpb24/OiBDb2xsZWN0aW9uO1xuICAgIG9wdGlvbnM/OiBfU2hhcmVkLk9wdGlvbnM7XG4gIH07XG5cbiAgZXhwb3J0IHR5cGUgVG9rZW5NZXRhZGF0YSA9IHtcbiAgICBuYW1lOiBzdHJpbmc7XG4gICAgc3ltYm9sOiBzdHJpbmc7XG4gICAgZmlsZVBhdGg/OiBGaWxlQ29udGVudDtcbiAgICB1cmk/OiBzdHJpbmc7XG4gICAgc3RvcmFnZVR5cGU/OiBTdG9yYWdlVHlwZTtcbiAgICBkZXNjcmlwdGlvbj86IHN0cmluZztcbiAgICByb3lhbHR5PzogbnVtYmVyO1xuICAgIHVzZXM/OiBfU2hhcmVkLlVzZXM7XG4gICAgY3JlYXRvcnM/OiBDcmVhdG9yc1tdO1xuICAgIGF0dHJpYnV0ZXM/OiBfU2hhcmVkLkF0dHJpYnV0ZVtdO1xuICAgIG9wdGlvbnM/OiBfU2hhcmVkLk9wdGlvbnM7XG4gIH07XG59XG4iLCAiaW1wb3J0IEJOIGZyb20gJ2JuLmpzJztcblxuZXhwb3J0IHR5cGUgT3B0aW9uPFQ+ID0gVCB8IG51bGw7XG5leHBvcnQgdHlwZSBiaWdudW0gPSBudW1iZXIgfCBCTjtcbmV4cG9ydCB0eXBlIEZpbGVDb250ZW50ID0gc3RyaW5nIHwgQnVmZmVyIHwgVWludDhBcnJheSB8IEFycmF5QnVmZmVyO1xuXG5leHBvcnQgbmFtZXNwYWNlIF9TaGFyZWQge1xuICBleHBvcnQgdHlwZSBQcm9wZXJ0aWVzID0ge1xuICAgIGNyZWF0b3JzPzoge1xuICAgICAgYWRkcmVzcz86IHN0cmluZztcbiAgICAgIHNoYXJlPzogbnVtYmVyO1xuICAgICAgW2tleTogc3RyaW5nXTogdW5rbm93bjtcbiAgICB9W107XG4gICAgZmlsZXM/OiB7XG4gICAgICB0eXBlPzogc3RyaW5nO1xuICAgICAgZmlsZVBhdGg/OiBGaWxlQ29udGVudDtcbiAgICAgIFtrZXk6IHN0cmluZ106IHVua25vd247XG4gICAgfVtdO1xuICAgIFtrZXk6IHN0cmluZ106IHVua25vd247XG4gIH07XG5cbiAgZXhwb3J0IHR5cGUgQXR0cmlidXRlID0ge1xuICAgIHRyYWl0X3R5cGU/OiBzdHJpbmc7XG4gICAgdmFsdWU/OiBzdHJpbmc7XG4gICAgW2tleTogc3RyaW5nXTogdW5rbm93bjtcbiAgfTtcblxuICBleHBvcnQgZW51bSBVc2VNZXRob2Qge1xuICAgIEJ1cm4gPSAwLFxuICAgIE11bHRpcGxlID0gMSxcbiAgICBTaW5nbGUgPSAyLFxuICB9XG5cbiAgZXhwb3J0IHR5cGUgVXNlcyA9IHtcbiAgICB1c2VNZXRob2Q6IFVzZU1ldGhvZDtcbiAgICByZW1haW5pbmc6IGJpZ251bTtcbiAgICB0b3RhbDogYmlnbnVtO1xuICB9O1xuXG4gIGV4cG9ydCB0eXBlIE9wdGlvbnMgPSB7IFtrZXk6IHN0cmluZ106IHVua25vd24gfTtcbn1cbiIsICJpbXBvcnQgeyBQdWJsaWNLZXkgfSBmcm9tICdAc29sYW5hL3dlYjMuanMnO1xuaW1wb3J0IHsgUFJPR1JBTV9JRCB9IGZyb20gJ0BtZXRhcGxleC1mb3VuZGF0aW9uL21wbC10b2tlbi1tZXRhZGF0YSc7XG5pbXBvcnQgeyBQdWJrZXkgfSBmcm9tICdAc29sYW5hLXN1aXRlL3NoYXJlZCc7XG5cbmV4cG9ydCBuYW1lc3BhY2UgUGRhIHtcbiAgZXhwb3J0IGNvbnN0IGdldE1ldGFkYXRhID0gKG1pbnQ6IFB1YmtleSk6IFB1YmxpY0tleSA9PiB7XG4gICAgY29uc3QgW3B1YmxpY0tleV0gPSBQdWJsaWNLZXkuZmluZFByb2dyYW1BZGRyZXNzU3luYyhcbiAgICAgIFtCdWZmZXIuZnJvbSgnbWV0YWRhdGEnKSwgUFJPR1JBTV9JRC50b0J1ZmZlcigpLCBtaW50LnRvUHVibGljS2V5KCkudG9CdWZmZXIoKV0sXG4gICAgICBQUk9HUkFNX0lELFxuICAgICk7XG4gICAgcmV0dXJuIHB1YmxpY0tleTtcbiAgfTtcblxuICBleHBvcnQgY29uc3QgZ2V0TWFzdGVyRWRpdGlvbiA9IChtaW50OiBQdWJrZXkpOiBQdWJsaWNLZXkgPT4ge1xuICAgIGNvbnN0IFtwdWJsaWNLZXldID0gUHVibGljS2V5LmZpbmRQcm9ncmFtQWRkcmVzc1N5bmMoXG4gICAgICBbXG4gICAgICAgIEJ1ZmZlci5mcm9tKCdtZXRhZGF0YScpLFxuICAgICAgICBQUk9HUkFNX0lELnRvQnVmZmVyKCksXG4gICAgICAgIG1pbnQudG9QdWJsaWNLZXkoKS50b0J1ZmZlcigpLFxuICAgICAgICBCdWZmZXIuZnJvbSgnZWRpdGlvbicpLFxuICAgICAgXSxcbiAgICAgIFBST0dSQU1fSUQsXG4gICAgKTtcbiAgICByZXR1cm4gcHVibGljS2V5O1xuICB9O1xufVxuIiwgImltcG9ydCB7IFJlc3VsdCwgVHJ5IH0gZnJvbSAnQHNvbGFuYS1zdWl0ZS9zaGFyZWQnO1xuaW1wb3J0IHsgUm95YWx0eSB9IGZyb20gJy4vcm95YWx0eSc7XG5pbXBvcnQgeyBJbmZyYVNpZGVJbnB1dCwgVXNlclNpZGVJbnB1dCB9IGZyb20gJy4vdHlwZXMvJztcbmltcG9ydCB7IERldGFpbHMsIExpbWl0IH0gZnJvbSAnLi90eXBlcy92YWxpZGF0b3InO1xuXG5leHBvcnQgbmFtZXNwYWNlIFZhbGlkYXRvciB7XG4gIGV4cG9ydCBuYW1lc3BhY2UgTWVzc2FnZSB7XG4gICAgZXhwb3J0IGNvbnN0IFNVQ0NFU1MgPSAnc3VjY2Vzcyc7XG4gICAgZXhwb3J0IGNvbnN0IFNNQUxMX05VTUJFUiA9ICd0b28gc21hbGwnO1xuICAgIGV4cG9ydCBjb25zdCBCSUdfTlVNQkVSID0gJ3RvbyBiaWcnO1xuICAgIGV4cG9ydCBjb25zdCBMT05HX0xFTkdUSCA9ICd0b28gbG9uZyc7XG4gICAgZXhwb3J0IGNvbnN0IEVNUFRZID0gJ2ludmFsaWQgZW1wdHkgdmFsdWUnO1xuICAgIGV4cG9ydCBjb25zdCBJTlZBTElEX1VSTCA9ICdpbnZhbGlkIHVybCc7XG4gICAgZXhwb3J0IGNvbnN0IE9OTFlfTk9ERV9KUyA9ICdgc3RyaW5nYCB0eXBlIGlzIG9ubHkgTm9kZS5qcyc7XG4gIH1cblxuICBleHBvcnQgY29uc3QgTkFNRV9MRU5HVEggPSAzMjtcbiAgZXhwb3J0IGNvbnN0IFNZTUJPTF9MRU5HVEggPSAxMDtcbiAgZXhwb3J0IGNvbnN0IFVSTF9MRU5HVEggPSAyMDA7XG4gIGV4cG9ydCBjb25zdCBST1lBTFRZX01BWCA9IDEwMDtcbiAgZXhwb3J0IGNvbnN0IFNFTExFUl9GRUVfQkFTSVNfUE9JTlRTX01BWCA9IDEwMDAwO1xuICBleHBvcnQgY29uc3QgUk9ZQUxUWV9NSU4gPSAtMTtcblxuICBleHBvcnQgY29uc3QgaXNSb3lhbHR5ID0gKFxuICAgIHJveWFsdHk6IG51bWJlclxuICApOiBSZXN1bHQ8c3RyaW5nLCBWYWxpZGF0b3JFcnJvcj4gPT4ge1xuICAgIHJldHVybiBUcnkoKCkgPT4ge1xuICAgICAgY29uc3Qga2V5ID0gJ3JveWFsdHknO1xuICAgICAgaWYgKHJveWFsdHkgIT09IDAgJiYgIXJveWFsdHkpIHtcbiAgICAgICAgdGhyb3cgY3JlYXRlRXJyb3Ioa2V5LCBNZXNzYWdlLkVNUFRZLCByb3lhbHR5KTtcbiAgICAgIH1cbiAgICAgIGlmIChyb3lhbHR5IDwgUk9ZQUxUWV9NSU4pIHtcbiAgICAgICAgdGhyb3cgY3JlYXRlRXJyb3Ioa2V5LCBNZXNzYWdlLlNNQUxMX05VTUJFUiwgcm95YWx0eSwge1xuICAgICAgICAgIHRocmVzaG9sZDogUk9ZQUxUWV9NSU4sXG4gICAgICAgICAgY29uZGl0aW9uOiAndW5kZXJNaW4nLFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAocm95YWx0eSA+IFJPWUFMVFlfTUFYKSB7XG4gICAgICAgIHRocm93IGNyZWF0ZUVycm9yKGtleSwgTWVzc2FnZS5CSUdfTlVNQkVSLCByb3lhbHR5LCB7XG4gICAgICAgICAgdGhyZXNob2xkOiBST1lBTFRZX01BWCxcbiAgICAgICAgICBjb25kaXRpb246ICdvdmVyTWF4JyxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gTWVzc2FnZS5TVUNDRVNTO1xuICAgIH0pO1xuICB9O1xuXG4gIGV4cG9ydCBjb25zdCBpc1NlbGxlckZlZUJhc2lzUG9pbnRzID0gKFxuICAgIHJveWFsdHk6IG51bWJlclxuICApOiBSZXN1bHQ8c3RyaW5nLCBWYWxpZGF0b3JFcnJvcj4gPT4ge1xuICAgIHJldHVybiBUcnkoKCkgPT4ge1xuICAgICAgY29uc3Qga2V5ID0gJ3NlbGxlckZlZUJhc2lzUG9pbnRzL3NlbGxlcl9mZWVfYmFzaXNfcG9pbnRzJztcbiAgICAgIGlmIChyb3lhbHR5ICE9PSAwICYmICFyb3lhbHR5KSB7XG4gICAgICAgIHRocm93IGNyZWF0ZUVycm9yKGtleSwgTWVzc2FnZS5FTVBUWSwgcm95YWx0eSk7XG4gICAgICB9XG4gICAgICBpZiAocm95YWx0eSA8IFJPWUFMVFlfTUlOKSB7XG4gICAgICAgIHRocm93IGNyZWF0ZUVycm9yKGtleSwgTWVzc2FnZS5TTUFMTF9OVU1CRVIsIHJveWFsdHksIHtcbiAgICAgICAgICB0aHJlc2hvbGQ6IFJPWUFMVFlfTUlOLFxuICAgICAgICAgIGNvbmRpdGlvbjogJ3VuZGVyTWluJyxcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKHJveWFsdHkgPiBST1lBTFRZX01BWCAqIFJveWFsdHkuVEhSRVNIT0xEKSB7XG4gICAgICAgIHRocm93IGNyZWF0ZUVycm9yKGtleSwgTWVzc2FnZS5CSUdfTlVNQkVSLCByb3lhbHR5LCB7XG4gICAgICAgICAgdGhyZXNob2xkOiBTRUxMRVJfRkVFX0JBU0lTX1BPSU5UU19NQVgsXG4gICAgICAgICAgY29uZGl0aW9uOiAnb3Zlck1heCcsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE1lc3NhZ2UuU1VDQ0VTUztcbiAgICB9KTtcbiAgfTtcblxuICBleHBvcnQgY29uc3QgaXNOYW1lID0gKG5hbWU6IHN0cmluZyk6IFJlc3VsdDxzdHJpbmcsIFZhbGlkYXRvckVycm9yPiA9PiB7XG4gICAgcmV0dXJuIFRyeSgoKSA9PiB7XG4gICAgICBjb25zdCBrZXkgPSAnbmFtZSc7XG4gICAgICBpZiAoIW5hbWUpIHtcbiAgICAgICAgdGhyb3cgY3JlYXRlRXJyb3Ioa2V5LCBNZXNzYWdlLkVNUFRZLCBuYW1lKTtcbiAgICAgIH1cbiAgICAgIGlmIChieXRlTGVuZ3RoKG5hbWUpID4gTkFNRV9MRU5HVEgpIHtcbiAgICAgICAgdGhyb3cgY3JlYXRlRXJyb3Ioa2V5LCBNZXNzYWdlLkxPTkdfTEVOR1RILCBuYW1lLCB7XG4gICAgICAgICAgdGhyZXNob2xkOiBOQU1FX0xFTkdUSCxcbiAgICAgICAgICBjb25kaXRpb246ICdvdmVyTWF4JyxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gTWVzc2FnZS5TVUNDRVNTO1xuICAgIH0pO1xuICB9O1xuXG4gIGV4cG9ydCBjb25zdCBpc1N5bWJvbCA9IChzeW1ib2w6IHN0cmluZyk6IFJlc3VsdDxzdHJpbmcsIFZhbGlkYXRvckVycm9yPiA9PiB7XG4gICAgcmV0dXJuIFRyeSgoKSA9PiB7XG4gICAgICBjb25zdCBrZXkgPSAnc3ltYm9sJztcbiAgICAgIGlmICghc3ltYm9sKSB7XG4gICAgICAgIHRocm93IGNyZWF0ZUVycm9yKGtleSwgTWVzc2FnZS5FTVBUWSwgc3ltYm9sKTtcbiAgICAgIH1cbiAgICAgIGlmIChieXRlTGVuZ3RoKHN5bWJvbCkgPiBTWU1CT0xfTEVOR1RIKSB7XG4gICAgICAgIHRocm93IGNyZWF0ZUVycm9yKGtleSwgTWVzc2FnZS5MT05HX0xFTkdUSCwgc3ltYm9sLCB7XG4gICAgICAgICAgdGhyZXNob2xkOiBTWU1CT0xfTEVOR1RILFxuICAgICAgICAgIGNvbmRpdGlvbjogJ292ZXJNYXgnLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBNZXNzYWdlLlNVQ0NFU1M7XG4gICAgfSk7XG4gIH07XG5cbiAgZXhwb3J0IGNvbnN0IGlzSW1hZ2VVcmwgPSAoaW1hZ2U6IHN0cmluZyk6IFJlc3VsdDxzdHJpbmcsIFZhbGlkYXRvckVycm9yPiA9PlxuICAgIGlzVXJpT3JJbWFnZShpbWFnZSwgJ2ltYWdlJyk7XG5cbiAgZXhwb3J0IGNvbnN0IGNoZWNrQWxsID0gPFxuICAgIFQgZXh0ZW5kcyBQaWNrTmZ0U3RvcmFnZSB8IFBpY2tOZnRTdG9yYWdlTWV0YXBsZXggfCBQaWNrTWV0YXBsZXhcbiAgPihcbiAgICBtZXRhZGF0YTogVFxuICApOiBSZXN1bHQ8c3RyaW5nLCBWYWxpZGF0b3JFcnJvcj4gPT4ge1xuICAgIHJldHVybiBUcnkoKCkgPT4ge1xuICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG1ldGFkYXRhKTtcbiAgICAgIGNvbnN0IHJlc3VsdHM6IERldGFpbHNbXSA9IFtdO1xuICAgICAga2V5cy5tYXAoKGtleSkgPT4ge1xuICAgICAgICBsZXQgcmVzITogUmVzdWx0PHN0cmluZywgVmFsaWRhdG9yRXJyb3I+O1xuICAgICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICAgIGNhc2UgJ2ltYWdlJzpcbiAgICAgICAgICAgIGlmIChrZXkgaW4gbWV0YWRhdGEgJiYgbWV0YWRhdGEuaW1hZ2UpIHtcbiAgICAgICAgICAgICAgcmVzID0gaXNJbWFnZVVybChtZXRhZGF0YS5pbWFnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdyb3lhbHR5JzpcbiAgICAgICAgICAgIGlmIChrZXkgaW4gbWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgcmVzID0gaXNSb3lhbHR5KG1ldGFkYXRhLnJveWFsdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnc2VsbGVyX2ZlZV9iYXNpc19wb2ludHMnOlxuICAgICAgICAgICAgaWYgKGtleSBpbiBtZXRhZGF0YSAmJiBtZXRhZGF0YS5zZWxsZXJfZmVlX2Jhc2lzX3BvaW50cykge1xuICAgICAgICAgICAgICByZXMgPSBpc1NlbGxlckZlZUJhc2lzUG9pbnRzKG1ldGFkYXRhLnNlbGxlcl9mZWVfYmFzaXNfcG9pbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3NlbGxlckZlZUJhc2lzUG9pbnRzJzpcbiAgICAgICAgICAgIGlmIChrZXkgaW4gbWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgcmVzID0gaXNTZWxsZXJGZWVCYXNpc1BvaW50cyhtZXRhZGF0YS5zZWxsZXJGZWVCYXNpc1BvaW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICduYW1lJzpcbiAgICAgICAgICAgIGlmIChtZXRhZGF0YS5uYW1lKSB7XG4gICAgICAgICAgICAgIHJlcyA9IGlzTmFtZShtZXRhZGF0YS5uYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3N5bWJvbCc6XG4gICAgICAgICAgICBpZiAobWV0YWRhdGEuc3ltYm9sKSB7XG4gICAgICAgICAgICAgIHJlcyA9IGlzU3ltYm9sKG1ldGFkYXRhLnN5bWJvbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzICYmIHJlcy5pc0Vycikge1xuICAgICAgICAgIHJlc3VsdHMucHVzaCguLi5yZXMuZXJyb3IuZGV0YWlscyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKHJlc3VsdHMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID1cbiAgICAgICAgICAnQ2F1Z2h0IGluIHRoZSB2YWxpZGF0aW9uIGVycm9ycy4gc2VlIGluZm9ybWF0aW9uIGUuZzogZXJyPFZhbGlkYXRvckVycm9yPi5kZXRhaWxzJztcbiAgICAgICAgdGhyb3cgbmV3IFZhbGlkYXRvckVycm9yKG1lc3NhZ2UsIHJlc3VsdHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE1lc3NhZ2UuU1VDQ0VTUztcbiAgICB9KTtcbiAgfTtcblxuICB0eXBlIFBpY2tOZnRTdG9yYWdlID0gUGljazxcbiAgICBJbmZyYVNpZGVJbnB1dC5PZmZjaGFpbixcbiAgICAnbmFtZScgfCAnc3ltYm9sJyB8ICdpbWFnZScgfCAnc2VsbGVyX2ZlZV9iYXNpc19wb2ludHMnXG4gID47XG4gIHR5cGUgUGlja05mdFN0b3JhZ2VNZXRhcGxleCA9IFBpY2s8XG4gICAgVXNlclNpZGVJbnB1dC5OZnRNZXRhZGF0YSxcbiAgICAnbmFtZScgfCAnc3ltYm9sJyB8ICdyb3lhbHR5JyB8ICdmaWxlUGF0aCdcbiAgPjtcbiAgdHlwZSBQaWNrTWV0YXBsZXggPSBQaWNrPFxuICAgIEluZnJhU2lkZUlucHV0Lk1ldGFwbGV4RGF0YVYyLFxuICAgICduYW1lJyB8ICdzeW1ib2wnIHwgJ3VyaScgfCAnc2VsbGVyRmVlQmFzaXNQb2ludHMnXG4gID47XG5cbiAgY29uc3QgYnl0ZUxlbmd0aCA9ICh2YWx1ZTogc3RyaW5nKTogbnVtYmVyID0+IHtcbiAgICBjb25zdCB0ZXh0ID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgcmV0dXJuIHRleHQuZW5jb2RlKHZhbHVlKS5sZW5ndGg7XG4gIH07XG5cbiAgY29uc3QgY3JlYXRlRXJyb3IgPSAoXG4gICAga2V5OiBzdHJpbmcsXG4gICAgbWVzc2FnZTogc3RyaW5nLFxuICAgIGFjdHVhbDogc3RyaW5nIHwgbnVtYmVyLFxuICAgIGxpbWl0PzogTGltaXRcbiAgKTogVmFsaWRhdG9yRXJyb3IgPT4ge1xuICAgIGxldCBlcnJvcjogVmFsaWRhdG9yRXJyb3I7XG4gICAgaWYgKGxpbWl0KSB7XG4gICAgICBlcnJvciA9IG5ldyBWYWxpZGF0b3JFcnJvcihtZXNzYWdlLCBbeyBrZXksIG1lc3NhZ2UsIGFjdHVhbCwgbGltaXQgfV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlcnJvciA9IG5ldyBWYWxpZGF0b3JFcnJvcihtZXNzYWdlLCBbeyBrZXksIG1lc3NhZ2UsIGFjdHVhbCB9XSk7XG4gICAgfVxuICAgIHJldHVybiBlcnJvcjtcbiAgfTtcblxuICBjb25zdCBpc1VyaU9ySW1hZ2UgPSAoXG4gICAgaW1hZ2VPclVyaTogc3RyaW5nLFxuICAgIGtleTogc3RyaW5nXG4gICk6IFJlc3VsdDxzdHJpbmcsIFZhbGlkYXRvckVycm9yPiA9PiB7XG4gICAgcmV0dXJuIFRyeSgoKSA9PiB7XG4gICAgICBpZiAoIWltYWdlT3JVcmkpIHtcbiAgICAgICAgdGhyb3cgY3JlYXRlRXJyb3Ioa2V5LCBNZXNzYWdlLkVNUFRZLCBpbWFnZU9yVXJpKTtcbiAgICAgIH1cbiAgICAgIGlmIChieXRlTGVuZ3RoKGltYWdlT3JVcmkpID4gVVJMX0xFTkdUSCkge1xuICAgICAgICB0aHJvdyBjcmVhdGVFcnJvcihrZXksIE1lc3NhZ2UuTE9OR19MRU5HVEgsIGltYWdlT3JVcmksIHtcbiAgICAgICAgICB0aHJlc2hvbGQ6IFVSTF9MRU5HVEgsXG4gICAgICAgICAgY29uZGl0aW9uOiAnb3Zlck1heCcsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKCEvaHR0cHM/OlxcL1xcL1stXy4hfipcXFxcKClhLXpBLVowLTk7PzomPSssJSNdKy9nLnRlc3QoaW1hZ2VPclVyaSkpIHtcbiAgICAgICAgdGhyb3cgY3JlYXRlRXJyb3Ioa2V5LCBNZXNzYWdlLklOVkFMSURfVVJMLCBpbWFnZU9yVXJpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBNZXNzYWdlLlNVQ0NFU1M7XG4gICAgfSk7XG4gIH07XG59XG5cbmV4cG9ydCBjbGFzcyBWYWxpZGF0b3JFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgZGV0YWlsczogRGV0YWlsc1tdO1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcsIGRldGFpbHM6IERldGFpbHNbXSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMuZGV0YWlscyA9IGRldGFpbHM7XG4gIH1cbn1cbiIsICJleHBvcnQgbmFtZXNwYWNlIFJveWFsdHkge1xuICBleHBvcnQgY29uc3QgVEhSRVNIT0xEID0gMTAwO1xuICBleHBvcnQgY29uc3QgY29udmVydCA9IChwZXJjZW50YWdlOiBudW1iZXIpID0+IHtcbiAgICByZXR1cm4gcGVyY2VudGFnZSAqIFRIUkVTSE9MRDtcbiAgfVxufVxuIiwgImltcG9ydCB7IFB1YmtleSwgUmVzdWx0IH0gZnJvbSAnQHNvbGFuYS1zdWl0ZS9zaGFyZWQnO1xuaW1wb3J0IHsgVXNlclNpZGVJbnB1dCB9IGZyb20gJ2ludGVybmFsL3NoYXJlZC1tZXRhcGxleCc7XG5pbXBvcnQgeyBGaW5kLCBPbkVyciwgT25PaywgU29ydGFibGUsIFNwbFRva2VuIH0gZnJvbSAnQHNvbGFuYS1zdWl0ZS9jb3JlJztcbmltcG9ydCB7IE5mdE1ldGFkYXRhIH0gZnJvbSAnLi4vdHlwZXMvJztcblxuZXhwb3J0IG5hbWVzcGFjZSBNZXRhcGxleCB7XG4gIC8qKlxuICAgKiBGZXRjaCBtaW50ZWQgbWV0YWRhdGEgYnkgb3duZXIgUHVia2V5XG4gICAqXG4gICAqIEBwYXJhbSB7UHVia2V5fSBvd25lclxuICAgKiBAcGFyYW0ge09uT2t9IG9uT2sgY2FsbGJhY2sgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtPbkVycn0gb25FcnIgY2FsbGJhY2sgZnVuY3Rpb25cbiAgICogQHBhcmFtIHt7c29ydGFibGU/OiBTb3J0YWJsZSwgaXNIb2xkZXI/OiBib29sZWFufX0gb3B0aW9ucz9cbiAgICogQHJldHVybiBQcm9taXNlPHZvaWQ+XG4gICAqL1xuICBleHBvcnQgY29uc3QgZmluZEJ5T3duZXIgPSBhc3luYyAoXG4gICAgb3duZXI6IFB1YmtleSxcbiAgICBvbk9rOiBPbk9rPEZpbmQ+LFxuICAgIG9uRXJyOiBPbkVycixcbiAgICBvcHRpb25zPzogeyBzb3J0YWJsZT86IFNvcnRhYmxlOyBpc0hvbGRlcj86IGJvb2xlYW4gfVxuICApOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgICBjb25zdCBzb3J0YWJsZSA9ICFvcHRpb25zPy5zb3J0YWJsZSA/IFNvcnRhYmxlLkRlc2MgOiBvcHRpb25zPy5zb3J0YWJsZTtcbiAgICBjb25zdCBpc0hvbGRlciA9ICFvcHRpb25zPy5pc0hvbGRlciA/IHRydWUgOiBmYWxzZTtcbiAgICBhd2FpdCBTcGxUb2tlbi5nZW5lcmljRmluZEJ5T3duZXI8TmZ0TWV0YWRhdGE+KFxuICAgICAgb3duZXIsXG4gICAgICAocmVzdWx0KSA9PiByZXN1bHQubWF0Y2gob25Paywgb25FcnIpLFxuICAgICAgVXNlclNpZGVJbnB1dC5Ub2tlblN0YW5kYXJkLk5vbkZ1bmdpYmxlLFxuICAgICAgc29ydGFibGUsXG4gICAgICBpc0hvbGRlclxuICAgICk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEZldGNoIG1pbnRlZCBtZXRhZGF0YSBieSBtaW50IGFkZHJlc3NcbiAgICpcbiAgICogQHBhcmFtIHtQdWJrZXl9IG1pbnRcbiAgICogQHJldHVybiBQcm9taXNlPFJlc3VsdDxOZnRNZXRhZGF0YSwgRXJyb3I+PlxuICAgKi9cbiAgZXhwb3J0IGNvbnN0IGZpbmRCeU1pbnQgPSBhc3luYyAoXG4gICAgbWludDogUHVia2V5XG4gICk6IFByb21pc2U8UmVzdWx0PE5mdE1ldGFkYXRhLCBFcnJvcj4+ID0+IHtcbiAgICByZXR1cm4gYXdhaXQgU3BsVG9rZW4uZ2VuZXJpY0ZpbmRCeU1pbnQ8TmZ0TWV0YWRhdGE+KFxuICAgICAgbWludCxcbiAgICAgIFVzZXJTaWRlSW5wdXQuVG9rZW5TdGFuZGFyZC5Ob25GdW5naWJsZVxuICAgICk7XG4gIH07XG59XG4iLCAiaW1wb3J0IHtcbiAgSW5zdHJ1Y3Rpb24sXG4gIEtleXBhaXJBY2NvdW50LFxuICBQdWJrZXksXG4gIFJlc3VsdCxcbiAgU2VjcmV0LFxuICBUcnksXG59IGZyb20gJ0Bzb2xhbmEtc3VpdGUvc2hhcmVkJztcbmltcG9ydCB7IFBkYSB9IGZyb20gJ2ludGVybmFsL3NoYXJlZC1tZXRhcGxleCc7XG5pbXBvcnQgeyBnZXRBc3NvY2lhdGVkVG9rZW5BZGRyZXNzU3luYyB9IGZyb20gJ0Bzb2xhbmEvc3BsLXRva2VuJztcbmltcG9ydCB7IGNyZWF0ZUZyZWV6ZURlbGVnYXRlZEFjY291bnRJbnN0cnVjdGlvbiB9IGZyb20gJ0BtZXRhcGxleC1mb3VuZGF0aW9uL21wbC10b2tlbi1tZXRhZGF0YSc7XG5cbmV4cG9ydCBuYW1lc3BhY2UgTWV0YXBsZXgge1xuICAvKipcbiAgICogRnJlZXppbmcgYSB0YXJnZXQgbmZ0XG4gICAqIGl0IHNob3VsZCBzZXQgdG8gZnJlZXplQXV0aG9yaXR5IHdoZW4gbWludCgpXG4gICAqIEBwYXJhbSB7UHVia2V5fSBtaW50ICAgICAgICAgICAgIC8vIG1pbnQgYWRkcmVzc1xuICAgKiBAcGFyYW0ge1B1YmtleX0gb3duZXIgICAgICAgICAgICAvLyBjdXJyZW50IG93bmVyXG4gICAqIEBwYXJhbSB7U2VjcmV0fSBmcmVlemVBdXRob3JpdHkgIC8vIHNldHRlZCBmcmVlemUgYXV0aG9yaXR5IG9mIG5mdFxuICAgKiBAcGFyYW0ge1NlY3JldH0gZmVlUGF5ZXI/ICAgICAgIC8vIGZlZSBwYXllclxuICAgKi9cbiAgZXhwb3J0IGNvbnN0IGZyZWV6ZSA9IChcbiAgICBtaW50OiBQdWJrZXksXG4gICAgb3duZXI6IFB1YmtleSxcbiAgICBmcmVlemVBdXRob3JpdHk6IFNlY3JldCxcbiAgICBmZWVQYXllcj86IFNlY3JldFxuICApOiBSZXN1bHQ8SW5zdHJ1Y3Rpb24sIEVycm9yPiA9PiB7XG4gICAgY29uc3QgcGF5ZXIgPSBmZWVQYXllciA/IGZlZVBheWVyIDogZnJlZXplQXV0aG9yaXR5O1xuICAgIHJldHVybiBUcnkoKCkgPT4ge1xuICAgICAgY29uc3QgdG9rZW5BY2NvdW50ID0gZ2V0QXNzb2NpYXRlZFRva2VuQWRkcmVzc1N5bmMoXG4gICAgICAgIG1pbnQudG9QdWJsaWNLZXkoKSxcbiAgICAgICAgb3duZXIudG9QdWJsaWNLZXkoKVxuICAgICAgKTtcbiAgICAgIGNvbnN0IGVkaXRpb25BZGRyZXNzID0gUGRhLmdldE1hc3RlckVkaXRpb24obWludCk7XG5cbiAgICAgIGNvbnN0IGluc3QgPSBjcmVhdGVGcmVlemVEZWxlZ2F0ZWRBY2NvdW50SW5zdHJ1Y3Rpb24oe1xuICAgICAgICBkZWxlZ2F0ZTogbmV3IEtleXBhaXJBY2NvdW50KHsgc2VjcmV0OiBmcmVlemVBdXRob3JpdHkgfSkudG9QdWJsaWNLZXkoKSxcbiAgICAgICAgdG9rZW5BY2NvdW50OiB0b2tlbkFjY291bnQsXG4gICAgICAgIGVkaXRpb246IGVkaXRpb25BZGRyZXNzLFxuICAgICAgICBtaW50OiBtaW50LnRvUHVibGljS2V5KCksXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBuZXcgSW5zdHJ1Y3Rpb24oXG4gICAgICAgIFtpbnN0XSxcbiAgICAgICAgW2ZyZWV6ZUF1dGhvcml0eS50b0tleXBhaXIoKV0sXG4gICAgICAgIHBheWVyLnRvS2V5cGFpcigpXG4gICAgICApO1xuICAgIH0pO1xuICB9O1xufVxuIiwgImltcG9ydCB7XG4gIGRlYnVnTG9nLFxuICBLZXlwYWlyQWNjb3VudCxcbiAgTm9kZSxcbiAgUGFydGlhbFNpZ25JbnN0cnVjdGlvbixcbiAgUHVia2V5LFxuICBSZXN1bHQsXG4gIFNlY3JldCxcbiAgVHJ5LFxufSBmcm9tICdAc29sYW5hLXN1aXRlL3NoYXJlZCc7XG5cbmltcG9ydCB7IFRyYW5zYWN0aW9uIH0gZnJvbSAnQHNvbGFuYS93ZWIzLmpzJztcblxuaW1wb3J0IHsgU3RvcmFnZSB9IGZyb20gJ2ludGVybmFsL3N0b3JhZ2UnO1xuXG5pbXBvcnQge1xuICBDb252ZXJ0LFxuICBSb3lhbHR5LFxuICBVc2VyU2lkZUlucHV0LFxuICBWYWxpZGF0b3IsXG59IGZyb20gJ2ludGVybmFsL3NoYXJlZC1tZXRhcGxleCc7XG5cbmltcG9ydCB7IE1ldGFwbGV4IGFzIF9NaW50IH0gZnJvbSAnLi9taW50JztcblxuZXhwb3J0IG5hbWVzcGFjZSBNZXRhcGxleCB7XG4gIC8qKlxuICAgKiBVcGxvYWQgY29udGVudCBhbmQgTkZUIG1pbnQgd2l0aCBQYXJ0aWFsIFNpZ25cbiAgICpcbiAgICogQHBhcmFtIHtQdWJrZXl9IG93bmVyICAgICAgICAgIC8vIGZpcnN0IG1pbnRlZCBvd25lclxuICAgKiBAcGFyYW0ge1NlY3JldH0gc2lnbmVyICAgICAgICAgLy8gb3duZXIncyBTZWNyZXRcbiAgICogQHBhcmFtIHtVc2VyU2lkZUlucHV0Lk5mdE1ldGFkYXRhfSBpbnB1dFxuICAgKiB7XG4gICAqICAgbmFtZTogc3RyaW5nICAgICAgICAgICAgICAgLy8gbmZ0IGNvbnRlbnQgbmFtZVxuICAgKiAgIHN5bWJvbDogc3RyaW5nICAgICAgICAgICAgIC8vIG5mdCB0aWNrZXIgc3ltYm9sXG4gICAqICAgZmlsZVBhdGg6IHN0cmluZyB8IEZpbGUgICAgLy8gbmZ0IHRpY2tlciBzeW1ib2xcbiAgICogICByb3lhbHR5OiBudW1iZXIgICAgICAgICAgICAvLyByb3lhbHR5IHBlcmNlbnRhZ2VcbiAgICogICBzdG9yYWdlVHlwZTogJ2Fyd2VhdmUnfCduZnRTdG9yYWdlJyAvLyByb3lhbHR5IHBlcmNlbnRhZ2VcbiAgICogICBkZXNjcmlwdGlvbj86IHN0cmluZyAgICAgICAvLyBuZnQgY29udGVudCBkZXNjcmlwdGlvblxuICAgKiAgIGV4dGVybmFsX3VybD86IHN0cmluZyAgICAgIC8vIGxhbmRpbmcgcGFnZSwgaG9tZSBwYWdlIHVyaSwgcmVsYXRlZCB1cmxcbiAgICogICBhdHRyaWJ1dGVzPzogTWV0YWRhdGFBdHRyaWJ1dGVbXSAgICAgLy8gZ2FtZSBjaGFyYWN0ZXIgcGFyYW1ldGVyLCBwZXJzb25hbGl0eSwgY2hhcmFjdGVyaXN0aWNzXG4gICAqICAgcHJvcGVydGllcz86IE1ldGFkYXRhUHJvcGVydGllczxVcmk+IC8vIGluY2x1ZGUgZmlsZSBuYW1lLCB1cmksIHN1cHBvcnRlZCBmaWxlIHR5cGVcbiAgICogICBjb2xsZWN0aW9uPzogUHVia2V5ICAgICAgICAgICAvLyBjb2xsZWN0aW9ucyBvZiBkaWZmZXJlbnQgY29sb3JzLCBzaGFwZXMsIGV0Yy5cbiAgICogICBba2V5OiBzdHJpbmddPzogdW5rbm93biAgICAgICAvLyBvcHRpb25hbCBwYXJhbSwgVXN1YWxseSBub3QgdXNlZC5cbiAgICogICBjcmVhdG9ycz86IElucHV0Q3JlYXRvcnNbXSAgICAgICAgICAvLyBvdGhlciBjcmVhdG9ycyB0aGFuIG93bmVyXG4gICAqICAgdXNlcz86IFVzZXMgICAgICAgICAgICAgICAgICAgLy8gdXNhZ2UgZmVhdHVyZTogYnVybiwgc2luZ2xlLCBtdWx0aXBsZVxuICAgKiAgIGlzTXV0YWJsZT86IGJvb2xlYW4gICAgICAgICAgIC8vIGVuYWJsZSB1cGRhdGUoKVxuICAgKiB9XG4gICAqIEBwYXJhbSB7U2VjcmV0fSBmZWVQYXllcj8gICAgICAgICAvLyBmZWUgcGF5ZXJcbiAgICogQHBhcmFtIHtQdWJrZXl9IGZyZWV6ZUF1dGhvcml0eT8gIC8vIGZyZWV6ZSBhdXRob3JpdHlcbiAgICogQHJldHVybiBQcm9taXNlPFJlc3VsdDxQYXJ0aWFsU2lnbkluc3RydWN0aW9uLCBFcnJvcj4+XG4gICAqL1xuICBleHBvcnQgY29uc3QgZmVlUGF5ZXJQYXJ0aWFsU2lnbk1pbnQgPSBhc3luYyAoXG4gICAgb3duZXI6IFB1YmtleSxcbiAgICBzaWduZXI6IFNlY3JldCxcbiAgICBpbnB1dDogVXNlclNpZGVJbnB1dC5OZnRNZXRhZGF0YSxcbiAgICBmZWVQYXllcjogUHVia2V5LFxuICAgIGZyZWV6ZUF1dGhvcml0eT86IFNlY3JldFxuICApOiBQcm9taXNlPFJlc3VsdDxQYXJ0aWFsU2lnbkluc3RydWN0aW9uLCBFcnJvcj4+ID0+IHtcbiAgICByZXR1cm4gVHJ5KGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHZhbGlkID0gVmFsaWRhdG9yLmNoZWNrQWxsPFVzZXJTaWRlSW5wdXQuTmZ0TWV0YWRhdGE+KGlucHV0KTtcbiAgICAgIGlmICh2YWxpZC5pc0Vycikge1xuICAgICAgICB0aHJvdyB2YWxpZC5lcnJvcjtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgc2VsbGVyRmVlQmFzaXNQb2ludHMgPSBSb3lhbHR5LmNvbnZlcnQoaW5wdXQucm95YWx0eSk7XG5cbiAgICAgIC8vLS0tIHBvcnBlcnRpZXMsIFVwbG9hZCBjb250ZW50IC0tLVxuICAgICAgbGV0IHVyaSA9ICcnO1xuICAgICAgaWYgKGlucHV0LmZpbGVQYXRoICYmIGlucHV0LnN0b3JhZ2VUeXBlID09PSAnbmZ0U3RvcmFnZScpIHtcbiAgICAgICAgY29uc3QgcHJvcGVydGllcyA9IGF3YWl0IENvbnZlcnQuUHJvcGVydGllcy5pbnRvSW5mcmFTaWRlKFxuICAgICAgICAgIGlucHV0LnByb3BlcnRpZXMsXG4gICAgICAgICAgU3RvcmFnZS51cGxvYWRDb250ZW50LFxuICAgICAgICAgIGlucHV0LnN0b3JhZ2VUeXBlXG4gICAgICAgICk7XG5cbiAgICAgICAgY29uc3QgbmZ0U3RvcmFnZU1ldGFkYXRhID0gU3RvcmFnZS50b0NvbnZlcnRPZmZjaGFpbmRhdGEoXG4gICAgICAgICAgeyAuLi5pbnB1dCwgcHJvcGVydGllcyB9LFxuICAgICAgICAgIHNlbGxlckZlZUJhc2lzUG9pbnRzXG4gICAgICAgICk7XG5cbiAgICAgICAgY29uc3QgdXBsb2FkZWQgPSBhd2FpdCBTdG9yYWdlLnVwbG9hZE1ldGFBbmRDb250ZW50KFxuICAgICAgICAgIG5mdFN0b3JhZ2VNZXRhZGF0YSxcbiAgICAgICAgICBpbnB1dC5maWxlUGF0aCxcbiAgICAgICAgICBpbnB1dC5zdG9yYWdlVHlwZVxuICAgICAgICApO1xuICAgICAgICBpZiAodXBsb2FkZWQuaXNFcnIpIHtcbiAgICAgICAgICB0aHJvdyB1cGxvYWRlZDtcbiAgICAgICAgfVxuICAgICAgICB1cmkgPSB1cGxvYWRlZC52YWx1ZTtcbiAgICAgICAgZGVidWdMb2coJyMgdXBsb2FkIGNvbnRlbnQgdXJsOiAnLCB1cGxvYWRlZCk7XG4gICAgICB9IGVsc2UgaWYgKGlucHV0LnVyaSkge1xuICAgICAgICB1cmkgPSBpbnB1dC51cmk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBFcnJvcihgTXVzdCBzZXQgJ3N0b3JhZ2VUeXBlPW5mdFN0b3JhZ2UgKyBmaWxlUGF0aCcgb3IgJ3VyaSdgKTtcbiAgICAgIH1cbiAgICAgIC8vLS0tIHBvcnBlcnRpZXMsIFVwbG9hZCBjb250ZW50IC0tLVxuXG4gICAgICBsZXQgZGF0YXYyID0gQ29udmVydC5OZnRNZXRhZGF0YS5pbnRvSW5mcmFTaWRlKFxuICAgICAgICBpbnB1dCxcbiAgICAgICAgdXJpLFxuICAgICAgICBzZWxsZXJGZWVCYXNpc1BvaW50c1xuICAgICAgKTtcblxuICAgICAgLy8tLS0gY29sbGVjdGlvbiAtLS1cbiAgICAgIGxldCBjb2xsZWN0aW9uO1xuICAgICAgaWYgKGlucHV0LmNvbGxlY3Rpb24gJiYgaW5wdXQuY29sbGVjdGlvbikge1xuICAgICAgICBjb2xsZWN0aW9uID0gQ29udmVydC5Db2xsZWN0aW9uLmludG9JbmZyYVNpZGUoaW5wdXQuY29sbGVjdGlvbik7XG4gICAgICAgIGRhdGF2MiA9IHsgLi4uZGF0YXYyLCBjb2xsZWN0aW9uIH07XG4gICAgICB9XG4gICAgICAvLy0tLSBjb2xsZWN0aW9uIC0tLVxuXG4gICAgICBjb25zdCBpc011dGFibGUgPSBpbnB1dC5pc011dGFibGUgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBpbnB1dC5pc011dGFibGU7XG5cbiAgICAgIGRlYnVnTG9nKCcjIGlucHV0OiAnLCBpbnB1dCk7XG4gICAgICBkZWJ1Z0xvZygnIyBzZWxsZXJGZWVCYXNpc1BvaW50czogJywgc2VsbGVyRmVlQmFzaXNQb2ludHMpO1xuICAgICAgZGVidWdMb2coJyMgZGF0YXYyOiAnLCBkYXRhdjIpO1xuXG4gICAgICBjb25zdCBtaW50ID0gS2V5cGFpckFjY291bnQuY3JlYXRlKCk7XG4gICAgICBjb25zdCBpbnN0cyA9IGF3YWl0IF9NaW50LmNyZWF0ZU1pbnRJbnN0cnVjdGlvbnMoXG4gICAgICAgIG1pbnQudG9QdWJsaWNLZXkoKSxcbiAgICAgICAgb3duZXIudG9QdWJsaWNLZXkoKSxcbiAgICAgICAgZGF0YXYyLFxuICAgICAgICBmZWVQYXllci50b1B1YmxpY0tleSgpLFxuICAgICAgICBpc011dGFibGVcbiAgICAgICk7XG5cbiAgICAgIC8vIGZyZWV6ZUF1dGhvcml0eVxuICAgICAgaWYgKGZyZWV6ZUF1dGhvcml0eSkge1xuICAgICAgICBpbnN0cy5wdXNoKFxuICAgICAgICAgIF9NaW50LmNyZWF0ZURlbGVhZ2F0ZUluc3RydWN0aW9uKFxuICAgICAgICAgICAgbWludC50b1B1YmxpY0tleSgpLFxuICAgICAgICAgICAgb3duZXIudG9QdWJsaWNLZXkoKSxcbiAgICAgICAgICAgIGZyZWV6ZUF1dGhvcml0eS50b1B1YmxpY0tleSgpXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBibG9ja2hhc2hPYmogPSBhd2FpdCBOb2RlLmdldENvbm5lY3Rpb24oKS5nZXRMYXRlc3RCbG9ja2hhc2goKTtcbiAgICAgIGNvbnN0IHR4ID0gbmV3IFRyYW5zYWN0aW9uKHtcbiAgICAgICAgbGFzdFZhbGlkQmxvY2tIZWlnaHQ6IGJsb2NraGFzaE9iai5sYXN0VmFsaWRCbG9ja0hlaWdodCxcbiAgICAgICAgYmxvY2toYXNoOiBibG9ja2hhc2hPYmouYmxvY2toYXNoLFxuICAgICAgICBmZWVQYXllcjogZmVlUGF5ZXIudG9QdWJsaWNLZXkoKSxcbiAgICAgIH0pO1xuXG4gICAgICBpbnN0cy5mb3JFYWNoKChpbnN0KSA9PiB0eC5hZGQoaW5zdCkpO1xuICAgICAgdHgucmVjZW50QmxvY2toYXNoID0gYmxvY2toYXNoT2JqLmJsb2NraGFzaDtcbiAgICAgIFtzaWduZXIsIG1pbnRdLmZvckVhY2goKHNpZ25lcikgPT4gdHgucGFydGlhbFNpZ24oc2lnbmVyLnRvS2V5cGFpcigpKSk7XG5cbiAgICAgIGNvbnN0IHNlcmlhbGl6ZWRUeCA9IHR4LnNlcmlhbGl6ZSh7XG4gICAgICAgIHJlcXVpcmVBbGxTaWduYXR1cmVzOiBmYWxzZSxcbiAgICAgIH0pO1xuICAgICAgY29uc3QgaGV4ID0gc2VyaWFsaXplZFR4LnRvU3RyaW5nKCdoZXgnKTtcbiAgICAgIHJldHVybiBuZXcgUGFydGlhbFNpZ25JbnN0cnVjdGlvbihoZXgsIG1pbnQucHVia2V5KTtcbiAgICB9KTtcbiAgfTtcbn1cbiIsICJpbXBvcnQge1xuICBDdXJyZW5jeSxcbiAgTWV0YXBsZXhGaWxlLFxuICB0b01ldGFwbGV4RmlsZSxcbn0gZnJvbSAnQG1ldGFwbGV4LWZvdW5kYXRpb24vanMnO1xuXG5pbXBvcnQge1xuICBkZWJ1Z0xvZyxcbiAgaXNCcm93c2VyLFxuICBpc05vZGUsXG4gIFJlc3VsdCxcbiAgU2VjcmV0LFxuICBUcnksXG59IGZyb20gJ0Bzb2xhbmEtc3VpdGUvc2hhcmVkJztcbmltcG9ydCB7IEZpbGVDb250ZW50LCBJbmZyYVNpZGVJbnB1dCB9IGZyb20gJ2ludGVybmFsL3NoYXJlZC1tZXRhcGxleC8nO1xuaW1wb3J0IHsgQnVuZGxyIH0gZnJvbSAnLi9idW5kbHInO1xuXG5leHBvcnQgaW50ZXJmYWNlIE1ldGFwbGV4RmlsZU9wdGlvbnMge1xuICByZWFkb25seSBkaXNwbGF5TmFtZTogc3RyaW5nO1xuICByZWFkb25seSB1bmlxdWVOYW1lOiBzdHJpbmc7XG4gIHJlYWRvbmx5IGNvbnRlbnRUeXBlOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gIHJlYWRvbmx5IGV4dGVuc2lvbjogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICByZWFkb25seSB0YWdzOiB7IG5hbWU6IHN0cmluZzsgdmFsdWU6IHN0cmluZyB9W107XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgQXJ3ZWF2ZSB7XG4gIGV4cG9ydCBjb25zdCBnZXRVcGxvYWRQcmljZSA9IGFzeW5jIChcbiAgICBmaWxlUGF0aDogRmlsZUNvbnRlbnQsXG4gICAgZmVlUGF5ZXI6IFNlY3JldCxcbiAgKTogUHJvbWlzZTxSZXN1bHQ8eyBwcmljZTogbnVtYmVyOyBjdXJyZW5jeTogQ3VycmVuY3kgfSwgRXJyb3I+PiA9PiB7XG4gICAgcmV0dXJuIFRyeShhc3luYyAoKSA9PiB7XG4gICAgICBsZXQgYnVmZmVyITogQnVmZmVyO1xuICAgICAgaWYgKGlzTm9kZSgpKSB7XG4gICAgICAgIGNvbnN0IGZpbGVwYXRoID0gZmlsZVBhdGggYXMgc3RyaW5nO1xuICAgICAgICBidWZmZXIgPSAoYXdhaXQgaW1wb3J0KCdmcycpKS5yZWFkRmlsZVN5bmMoZmlsZXBhdGgpO1xuICAgICAgfSBlbHNlIGlmIChpc0Jyb3dzZXIoKSkge1xuICAgICAgICBjb25zdCBmaWxlcGF0aCA9IGZpbGVQYXRoO1xuICAgICAgICBidWZmZXIgPSB0b01ldGFwbGV4RmlsZShmaWxlcGF0aCwgJycpLmJ1ZmZlcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IEVycm9yKCdTdXBwb3J0ZWQgZW52aXJvbm1lbnQ6IG9ubHkgTm9kZS5qcyBhbmQgQnJvd3NlciBqcycpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCByZXMgPSBhd2FpdCBCdW5kbHIudXNlU3RvcmFnZShmZWVQYXllci50b0tleXBhaXIoKSkuZ2V0VXBsb2FkUHJpY2UoXG4gICAgICAgIGJ1ZmZlci5sZW5ndGgsXG4gICAgICApO1xuXG4gICAgICBjb25zdCBiYXNpc1BvaW50czogc3RyaW5nID0gcmVzLmJhc2lzUG9pbnRzLnRvU3RyaW5nKCk7XG4gICAgICBkZWJ1Z0xvZyhcbiAgICAgICAgJyMgYnVmZmVyIGxlbmd0aCwgcHJpY2UnLFxuICAgICAgICBidWZmZXIubGVuZ3RoLFxuICAgICAgICBwYXJzZUludChiYXNpc1BvaW50cykudG9Tb2woKSxcbiAgICAgICk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwcmljZTogcGFyc2VJbnQoYmFzaXNQb2ludHMpLnRvU29sKCksXG4gICAgICAgIGN1cnJlbmN5OiByZXMuY3VycmVuY3ksXG4gICAgICB9O1xuICAgIH0pO1xuICB9O1xuXG4gIGV4cG9ydCBjb25zdCB1cGxvYWRDb250ZW50ID0gYXN5bmMgKFxuICAgIGZpbGVQYXRoOiBGaWxlQ29udGVudCxcbiAgICBmZWVQYXllcjogU2VjcmV0LFxuICAgIGZpbGVPcHRpb25zPzogTWV0YXBsZXhGaWxlT3B0aW9ucywgLy8gb25seSBhcndlYXZlLCBub3QgbmZ0LXN0b3JhZ2VcbiAgKTogUHJvbWlzZTxSZXN1bHQ8c3RyaW5nLCBFcnJvcj4+ID0+IHtcbiAgICByZXR1cm4gVHJ5KGFzeW5jICgpID0+IHtcbiAgICAgIGRlYnVnTG9nKCcjIHVwbG9hZCBjb250ZW50OiAnLCBmaWxlUGF0aCk7XG4gICAgICBsZXQgZmlsZSE6IE1ldGFwbGV4RmlsZTtcbiAgICAgIGlmIChpc05vZGUoKSkge1xuICAgICAgICBjb25zdCBmaWxlcGF0aCA9IGZpbGVQYXRoIGFzIHN0cmluZztcbiAgICAgICAgY29uc3QgYnVmZmVyID0gKGF3YWl0IGltcG9ydCgnZnMnKSkucmVhZEZpbGVTeW5jKGZpbGVwYXRoKTtcbiAgICAgICAgaWYgKGZpbGVPcHRpb25zKSB7XG4gICAgICAgICAgZmlsZSA9IHRvTWV0YXBsZXhGaWxlKGJ1ZmZlciwgZmlsZXBhdGgsIGZpbGVPcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmaWxlID0gdG9NZXRhcGxleEZpbGUoYnVmZmVyLCBmaWxlcGF0aCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNCcm93c2VyKCkpIHtcbiAgICAgICAgY29uc3QgZmlsZXBhdGggPSBmaWxlUGF0aDtcbiAgICAgICAgaWYgKGZpbGVPcHRpb25zKSB7XG4gICAgICAgICAgZmlsZSA9IHRvTWV0YXBsZXhGaWxlKGZpbGVwYXRoLCAnJywgZmlsZU9wdGlvbnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZpbGUgPSB0b01ldGFwbGV4RmlsZShmaWxlcGF0aCwgJycpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBFcnJvcignU3VwcG9ydGVkIGVudmlyb25tZW50OiBvbmx5IE5vZGUuanMgYW5kIEJyb3dzZXIganMnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIEJ1bmRsci51c2VTdG9yYWdlKGZlZVBheWVyLnRvS2V5cGFpcigpKS51cGxvYWQoZmlsZSk7XG4gICAgfSk7XG4gIH07XG5cbiAgZXhwb3J0IGNvbnN0IHVwbG9hZE1ldGFkYXRhID0gYXN5bmMgKFxuICAgIG1ldGFkYXRhOiBJbmZyYVNpZGVJbnB1dC5PZmZjaGFpbixcbiAgICBmZWVQYXllcjogU2VjcmV0LFxuICApOiBQcm9taXNlPFJlc3VsdDxzdHJpbmcsIEVycm9yPj4gPT4ge1xuICAgIHJldHVybiBUcnkoYXN5bmMgKCkgPT4ge1xuICAgICAgZGVidWdMb2coJyMgdXBsb2FkIG1ldGEgZGF0YTogJywgbWV0YWRhdGEpO1xuXG4gICAgICBjb25zdCB1cGxvYWRlZCA9IGF3YWl0IEJ1bmRsci5tYWtlKGZlZVBheWVyLnRvS2V5cGFpcigpKVxuICAgICAgICAubmZ0cygpXG4gICAgICAgIC51cGxvYWRNZXRhZGF0YShtZXRhZGF0YSk7XG5cbiAgICAgIHJldHVybiB1cGxvYWRlZC51cmk7XG4gICAgfSk7XG4gIH07XG59XG4iLCAiaW1wb3J0IHtcbiAgTWV0YXBsZXggYXMgTWV0YXBsZXhGb3VuZGF0aW9uLFxuICBrZXlwYWlySWRlbnRpdHksXG4gIGJ1bmRsclN0b3JhZ2UsXG4gIEJ1bmRsclN0b3JhZ2VEcml2ZXIsXG4gIHdhbGxldEFkYXB0ZXJJZGVudGl0eSxcbn0gZnJvbSAnQG1ldGFwbGV4LWZvdW5kYXRpb24vanMnO1xuXG5pbXBvcnQgeyBLZXlwYWlyIH0gZnJvbSAnQHNvbGFuYS93ZWIzLmpzJztcbmltcG9ydCB7IE5vZGUsIENvbnN0YW50cyB9IGZyb20gJ0Bzb2xhbmEtc3VpdGUvc2hhcmVkJztcbmltcG9ydCB7IEJ1bmRsclNpZ25lciwgUGhhbnRvbSB9IGZyb20gJy4vdHlwZXMvYnVuZGxyJztcblxuZXhwb3J0IG5hbWVzcGFjZSBCdW5kbHIge1xuICBjb25zdCBCVU5ETFJfQ09OTkVDVF9USU1FT1VUID0gNjAwMDA7XG5cbiAgZXhwb3J0IGNvbnN0IG1ha2UgPSAoZmVlUGF5ZXI/OiBCdW5kbHJTaWduZXIpOiBNZXRhcGxleEZvdW5kYXRpb24gPT4ge1xuICAgIGNvbnN0IG9iamVjdCA9IE1ldGFwbGV4Rm91bmRhdGlvbi5tYWtlKE5vZGUuZ2V0Q29ubmVjdGlvbigpKS51c2UoXG4gICAgICBidW5kbHJTdG9yYWdlKHtcbiAgICAgICAgYWRkcmVzczogQ29uc3RhbnRzLkJVTkRMUl9ORVRXT1JLX1VSTCxcbiAgICAgICAgcHJvdmlkZXJVcmw6IENvbnN0YW50cy5zd2l0Y2hDbHVzdGVyKHtcbiAgICAgICAgICBjbHVzdGVyOiBDb25zdGFudHMuY3VycmVudENsdXN0ZXIsXG4gICAgICAgIH0pLFxuICAgICAgICB0aW1lb3V0OiBCVU5ETFJfQ09OTkVDVF9USU1FT1VULFxuICAgICAgfSlcbiAgICApO1xuICAgIGlmIChpc0tleXBhaXIoZmVlUGF5ZXIpKSB7XG4gICAgICBvYmplY3QudXNlKGtleXBhaXJJZGVudGl0eShmZWVQYXllcikpO1xuICAgIH0gZWxzZSBpZiAoaXNQaGFudG9tKGZlZVBheWVyKSkge1xuICAgICAgb2JqZWN0LnVzZSh3YWxsZXRBZGFwdGVySWRlbnRpdHkoZmVlUGF5ZXIpKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfTtcblxuICBleHBvcnQgY29uc3QgdXNlU3RvcmFnZSA9IChmZWVQYXllcjogQnVuZGxyU2lnbmVyKTogQnVuZGxyU3RvcmFnZURyaXZlciA9PiB7XG4gICAgcmV0dXJuIG1ha2UoZmVlUGF5ZXIpLnN0b3JhZ2UoKS5kcml2ZXIoKSBhcyBCdW5kbHJTdG9yYWdlRHJpdmVyO1xuICB9O1xuXG4gIGNvbnN0IGlzS2V5cGFpciA9IChwYXllcjogQnVuZGxyU2lnbmVyKTogcGF5ZXIgaXMgS2V5cGFpciA9PiB7XG4gICAgaWYgKCFwYXllcikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gJ3NlY3JldEtleScgaW4gcGF5ZXI7XG4gIH07XG5cbiAgY29uc3QgaXNQaGFudG9tID0gKHBheWVyOiBCdW5kbHJTaWduZXIpOiBwYXllciBpcyBQaGFudG9tID0+IHtcbiAgICBpZiAoIXBheWVyKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiAnY29ubmVjdCcgaW4gcGF5ZXI7XG4gIH07XG59XG4iLCAiaW1wb3J0IHsgTkZUU3RvcmFnZSwgQmxvYiB9IGZyb20gJ25mdC5zdG9yYWdlJztcbmltcG9ydCB7XG4gIENvbnN0YW50cyxcbiAgUmVzdWx0LFxuICBpc05vZGUsXG4gIGlzQnJvd3NlcixcbiAgZGVidWdMb2csXG4gIFRyeSxcbn0gZnJvbSAnQHNvbGFuYS1zdWl0ZS9zaGFyZWQnO1xuXG5pbXBvcnQgeyB0b01ldGFwbGV4RmlsZSB9IGZyb20gJ0BtZXRhcGxleC1mb3VuZGF0aW9uL2pzJztcbmltcG9ydCB7IEluZnJhU2lkZUlucHV0LCBGaWxlQ29udGVudCB9IGZyb20gJ2ludGVybmFsL3NoYXJlZC1tZXRhcGxleCc7XG5cbmV4cG9ydCBuYW1lc3BhY2UgTmZ0U3RvcmFnZSB7XG4gIGxldCBpc0Rpc3BsYXlXYXJuaW5nID0gZmFsc2U7XG4gIGNvbnN0IGdldE5mdFN0b3JhZ2VBcGlLZXkgPSAoKTogc3RyaW5nID0+IHtcbiAgICBpZiAoIUNvbnN0YW50cy5uZnRTdG9yYWdlQXBpS2V5KSB7XG4gICAgICBpZiAoIWlzRGlzcGxheVdhcm5pbmcpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIGBcbiAgICAgICAgW1dhcm5pbmddXG4gICAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIElmIHdpbGwgdXNlIEBzb2xhbmEtc3VpdGUvbmZ0IHBhY2thZ2VcbiAgICAgICAgeW91ciBuZWVkIHRvIHVwZGF0ZSBuZnRTdG9yYWdlLmFwaUtleSBkZWZpbmUgcGFyYW1ldGVyIGluIHNvbGFuYS1zdWl0ZS5qc29uLlxuICAgICAgICBjYW4gZ2V0IGFwaUtleSBmcm9tIGh0dHBzOi8vbmZ0LnN0b3JhZ2UvXG4gICAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIGBcbiAgICAgICAgKTtcbiAgICAgICAgaXNEaXNwbGF5V2FybmluZyA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gQ29uc3RhbnRzLk5GVF9TVE9SQUdFX0FQSV9LRVk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBDb25zdGFudHMubmZ0U3RvcmFnZUFwaUtleTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgY3JlYXRlR2F0ZXdheVVybCA9IChjaWQ6IHN0cmluZyk6IHN0cmluZyA9PlxuICAgIGAke0NvbnN0YW50cy5ORlRfU1RPUkFHRV9HQVRFV0FZX1VSTH0vJHtjaWR9YDtcblxuICBjb25zdCBjb25uZWN0ID0gKCkgPT4gbmV3IE5GVFN0b3JhZ2UoeyB0b2tlbjogZ2V0TmZ0U3RvcmFnZUFwaUtleSgpIH0pO1xuXG4gIGV4cG9ydCBjb25zdCB1cGxvYWRDb250ZW50ID0gYXN5bmMgKFxuICAgIGZpbGVQYXRoOiBGaWxlQ29udGVudFxuICApOiBQcm9taXNlPFJlc3VsdDxzdHJpbmcsIEVycm9yPj4gPT4ge1xuICAgIHJldHVybiBUcnkoYXN5bmMgKCkgPT4ge1xuICAgICAgZGVidWdMb2coJyMgdXBsb2FkIGNvbnRlbnQ6ICcsIGZpbGVQYXRoKTtcbiAgICAgIGxldCBmaWxlITogQnVmZmVyO1xuICAgICAgaWYgKGlzTm9kZSgpKSB7XG4gICAgICAgIGNvbnN0IGZpbGVwYXRoID0gZmlsZVBhdGggYXMgc3RyaW5nO1xuICAgICAgICBmaWxlID0gKGF3YWl0IGltcG9ydCgnZnMnKSkucmVhZEZpbGVTeW5jKGZpbGVwYXRoKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNCcm93c2VyKCkpIHtcbiAgICAgICAgY29uc3QgZmlsZXBhdGggPSBmaWxlUGF0aDtcbiAgICAgICAgZmlsZSA9IHRvTWV0YXBsZXhGaWxlKGZpbGVwYXRoLCAnJykuYnVmZmVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ1N1cHBvcnRlZCBlbnZpcm9ubWVudDogb25seSBOb2RlLmpzIGFuZCBCcm93c2VyIGpzJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGJsb2JJbWFnZSA9IG5ldyBCbG9iKFtmaWxlXSk7XG4gICAgICBjb25zdCByZXMgPSBhd2FpdCBjb25uZWN0KCkuc3RvcmVCbG9iKGJsb2JJbWFnZSk7XG4gICAgICByZXR1cm4gY3JlYXRlR2F0ZXdheVVybChyZXMpO1xuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVcGxvYWQgY29udGVudFxuICAgKlxuICAgKiBAcGFyYW0ge1N0b3JhZ2VNZXRhZGF0YX0gbWV0YWRhdGFcbiAgICoge1xuICAgKiAgIG5hbWU/OiB7c3RyaW5nfSAgICAgICAgICAgICAgICAgICAgICAvLyBuZnQgY29udGVudCBuYW1lXG4gICAqICAgc3ltYm9sPzoge3N0cmluZ30gICAgICAgICAgICAgICAgICAgIC8vIG5mdCB0aWNrZXIgc3ltYm9sXG4gICAqICAgZGVzY3JpcHRpb24/OiB7c3RyaW5nfSAgICAgICAgICAgICAgIC8vIG5mdCBjb250ZW50IGRlc2NyaXB0aW9uXG4gICAqICAgc2VsbGVyRmVlQmFzaXNQb2ludHM/OiBudW1iZXIgICAgICAgIC8vIHJveWFsdHkgcGVyY2VudGFnZVxuICAgKiAgIGltYWdlPzoge3N0cmluZ30gICAgICAgICAgICAgICAgICAgICAvLyB1cGxvYWRlZCB1cmkgb2Ygb3JpZ2luYWwgY29udGVudFxuICAgKiAgIGV4dGVybmFsX3VybD86IHtzdHJpbmd9ICAgICAgICAgICAgICAvLyBsYW5kaW5nIHBhZ2UsIGhvbWUgcGFnZSB1cmksIHJlbGF0ZWQgdXJsXG4gICAqICAgYXR0cmlidXRlcz86IHtKc29uTWV0YWRhdGFBdHRyaWJ1dGVbXX0gICAgIC8vIGdhbWUgY2hhcmFjdGVyIHBhcmFtZXRlciwgcGVyc29uYWxpdHksIGNoYXJhY3RlcmlzdGljc1xuICAgKiAgIHByb3BlcnRpZXM/OiB7SnNvbk1ldGFkYXRhUHJvcGVydGllczxVcmk+fSAvLyBpbmNsdWRlZCBmaWxlIG5hbWUsIHVyaSwgc3VwcG9ydGVkIGZpbGUgdHlwZVxuICAgKiAgIGNvbGxlY3Rpb24/OiBDb2xsZWN0aW9uICAgICAgICAgICAgICAvLyBjb2xsZWN0aW9ucyBvZiBkaWZmZXJlbnQgY29sb3JzLCBzaGFwZXMsIGV0Yy5cbiAgICogICBba2V5OiBzdHJpbmddOiB7dW5rbm93bn0gICAgICAgICAgICAgLy8gb3B0aW9uYWwgcGFyYW0sIFVzdWFsbHkgbm90IHVzZWQuXG4gICAqIH1cbiAgICogQHJldHVybiBQcm9taXNlPFJlc3VsdDxzdHJpbmcsIEVycm9yPj5cbiAgICovXG4gIGV4cG9ydCBjb25zdCB1cGxvYWRNZXRhZGF0YSA9IGFzeW5jIChcbiAgICBtZXRhZGF0YTogSW5mcmFTaWRlSW5wdXQuT2ZmY2hhaW5cbiAgKTogUHJvbWlzZTxSZXN1bHQ8c3RyaW5nLCBFcnJvcj4+ID0+IHtcbiAgICByZXR1cm4gVHJ5KGFzeW5jICgpID0+IHtcbiAgICAgIGRlYnVnTG9nKCcjIHVwbG9hZCBtZXRhZGF0YTogJywgbWV0YWRhdGEpO1xuXG4gICAgICBjb25zdCBibG9iSnNvbiA9IG5ldyBCbG9iKFtKU09OLnN0cmluZ2lmeShtZXRhZGF0YSldKTtcbiAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IGNvbm5lY3QoKS5zdG9yZUJsb2IoYmxvYkpzb24pO1xuICAgICAgcmV0dXJuIGNyZWF0ZUdhdGV3YXlVcmwocmVzKTtcbiAgICB9KTtcbiAgfTtcbn1cbiIsICJpbXBvcnQgeyBSZXN1bHQsIFNlY3JldCB9IGZyb20gJ0Bzb2xhbmEtc3VpdGUvc2hhcmVkJztcbmltcG9ydCB7XG4gIEZpbGVDb250ZW50LFxuICBJbmZyYVNpZGVJbnB1dCxcbiAgU3RvcmFnZVR5cGUsXG4gIFVzZXJTaWRlSW5wdXQsXG59IGZyb20gJ2ludGVybmFsL3NoYXJlZC1tZXRhcGxleCc7XG5cbmltcG9ydCB7IEFyd2VhdmUgfSBmcm9tICcuL2Fyd2VhdmUnO1xuaW1wb3J0IHsgTmZ0U3RvcmFnZSB9IGZyb20gJy4vbmZ0LXN0b3JhZ2UnO1xuXG5leHBvcnQgbmFtZXNwYWNlIFN0b3JhZ2Uge1xuICBleHBvcnQgY29uc3QgdG9Db252ZXJ0T2ZmY2hhaW5kYXRhID0gKFxuICAgIGlucHV0OiBVc2VyU2lkZUlucHV0Lk5mdE1ldGFkYXRhLFxuICAgIHNlbGxlckZlZUJhc2lzUG9pbnRzOiBudW1iZXJcbiAgKTogSW5mcmFTaWRlSW5wdXQuT2ZmY2hhaW4gPT4ge1xuICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICBuYW1lOiBpbnB1dC5uYW1lLFxuICAgICAgc3ltYm9sOiBpbnB1dC5zeW1ib2wsXG4gICAgICBkZXNjcmlwdGlvbjogaW5wdXQuZGVzY3JpcHRpb24sXG4gICAgICBzZWxsZXJfZmVlX2Jhc2lzX3BvaW50czogc2VsbGVyRmVlQmFzaXNQb2ludHMsXG4gICAgICBleHRlcm5hbF91cmw6IGlucHV0LmV4dGVybmFsX3VybCxcbiAgICAgIGF0dHJpYnV0ZXM6IGlucHV0LmF0dHJpYnV0ZXMsXG4gICAgICBwcm9wZXJ0aWVzOiBpbnB1dC5wcm9wZXJ0aWVzLFxuICAgICAgaW1hZ2U6ICcnLFxuICAgICAgb3B0aW9uczogaW5wdXQub3B0aW9ucyxcbiAgICB9O1xuICAgIHJldHVybiBkYXRhO1xuICB9O1xuXG4gIGV4cG9ydCBjb25zdCB1cGxvYWRDb250ZW50ID0gYXN5bmMgKFxuICAgIGZpbGVQYXRoOiBGaWxlQ29udGVudCxcbiAgICBzdG9yYWdlVHlwZTogU3RvcmFnZVR5cGUsXG4gICAgZmVlUGF5ZXI/OiBTZWNyZXRcbiAgKTogUHJvbWlzZTxSZXN1bHQ8c3RyaW5nLCBFcnJvcj4+ID0+IHtcbiAgICBpZiAoc3RvcmFnZVR5cGUgPT09ICdhcndlYXZlJykge1xuICAgICAgaWYgKCFmZWVQYXllcikge1xuICAgICAgICB0aHJvdyBFcnJvcignQXJ3ZWF2ZSBuZWVkcyB0byBoYXZlIGZlZXBheWVyJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXdhaXQgQXJ3ZWF2ZS51cGxvYWRDb250ZW50KGZpbGVQYXRoLCBmZWVQYXllcik7XG4gICAgfSBlbHNlIGlmIChzdG9yYWdlVHlwZSA9PT0gJ25mdFN0b3JhZ2UnKSB7XG4gICAgICByZXR1cm4gYXdhaXQgTmZ0U3RvcmFnZS51cGxvYWRDb250ZW50KGZpbGVQYXRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgRXJyb3IoJ05vdCBmb3VuZCBzdG9yYWdlVHlwZScpO1xuICAgIH1cbiAgfTtcblxuICBleHBvcnQgY29uc3QgdXBsb2FkTWV0YUFuZENvbnRlbnQgPSBhc3luYyAoXG4gICAgaW5wdXQ6IEluZnJhU2lkZUlucHV0Lk9mZmNoYWluLFxuICAgIGZpbGVQYXRoOiBGaWxlQ29udGVudCxcbiAgICBzdG9yYWdlVHlwZTogU3RvcmFnZVR5cGUsXG4gICAgZmVlUGF5ZXI/OiBTZWNyZXRcbiAgKTogUHJvbWlzZTxSZXN1bHQ8c3RyaW5nLCBFcnJvcj4+ID0+IHtcbiAgICBsZXQgc3RvcmFnZTtcbiAgICBpZiAoc3RvcmFnZVR5cGUgPT09ICdhcndlYXZlJykge1xuICAgICAgaWYgKCFmZWVQYXllcikge1xuICAgICAgICB0aHJvdyBFcnJvcignQXJ3ZWF2ZSBuZWVkcyB0byBoYXZlIGZlZXBheWVyJyk7XG4gICAgICB9XG4gICAgICBzdG9yYWdlID0gYXdhaXQgKFxuICAgICAgICBhd2FpdCBBcndlYXZlLnVwbG9hZENvbnRlbnQoZmlsZVBhdGgsIGZlZVBheWVyKVxuICAgICAgKS51bndyYXAoXG4gICAgICAgIGFzeW5jIChvazogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgaW5wdXQuaW1hZ2UgPSBvaztcbiAgICAgICAgICByZXR1cm4gYXdhaXQgQXJ3ZWF2ZS51cGxvYWRNZXRhZGF0YShpbnB1dCwgZmVlUGF5ZXIpO1xuICAgICAgICB9LFxuICAgICAgICAoZXJyOiBFcnJvcikgPT4ge1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKHN0b3JhZ2VUeXBlID09PSAnbmZ0U3RvcmFnZScpIHtcbiAgICAgIHN0b3JhZ2UgPSBhd2FpdCAoXG4gICAgICAgIGF3YWl0IE5mdFN0b3JhZ2UudXBsb2FkQ29udGVudChmaWxlUGF0aClcbiAgICAgICkudW53cmFwKFxuICAgICAgICBhc3luYyAob2s6IHN0cmluZykgPT4ge1xuICAgICAgICAgIGlucHV0LmltYWdlID0gb2s7XG4gICAgICAgICAgcmV0dXJuIGF3YWl0IE5mdFN0b3JhZ2UudXBsb2FkTWV0YWRhdGEoaW5wdXQpO1xuICAgICAgICB9LFxuICAgICAgICAoZXJyOiBFcnJvcikgPT4ge1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgRXJyb3IoJ05vIG1hdGNoIHN0b3JhZ2VUeXBlJyk7XG4gICAgfVxuXG4gICAgaWYgKCFzdG9yYWdlKSB7XG4gICAgICB0aHJvdyBFcnJvcignRW1wdHkgc3RvcmFnZSBvYmplY3QnKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0b3JhZ2U7XG4gIH07XG59XG4iLCAiYXN5bmMgZnVuY3Rpb24qIF9iYXRjaChzaXplLCBpdGVyYWJsZSkge1xuICAgIGxldCBkYXRhQmF0Y2ggPSBbXTtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IGRhdGEgb2YgaXRlcmFibGUpIHtcbiAgICAgICAgZGF0YUJhdGNoLnB1c2goZGF0YSk7XG4gICAgICAgIGlmIChkYXRhQmF0Y2gubGVuZ3RoID09PSBzaXplKSB7XG4gICAgICAgICAgICB5aWVsZCBkYXRhQmF0Y2g7XG4gICAgICAgICAgICBkYXRhQmF0Y2ggPSBbXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZGF0YUJhdGNoLmxlbmd0aCA+IDApIHtcbiAgICAgICAgeWllbGQgZGF0YUJhdGNoO1xuICAgIH1cbn1cbmZ1bmN0aW9uKiBfc3luY0JhdGNoKHNpemUsIGl0ZXJhYmxlKSB7XG4gICAgbGV0IGRhdGFCYXRjaCA9IFtdO1xuICAgIGZvciAoY29uc3QgZGF0YSBvZiBpdGVyYWJsZSkge1xuICAgICAgICBkYXRhQmF0Y2gucHVzaChkYXRhKTtcbiAgICAgICAgaWYgKGRhdGFCYXRjaC5sZW5ndGggPT09IHNpemUpIHtcbiAgICAgICAgICAgIHlpZWxkIGRhdGFCYXRjaDtcbiAgICAgICAgICAgIGRhdGFCYXRjaCA9IFtdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChkYXRhQmF0Y2gubGVuZ3RoID4gMCkge1xuICAgICAgICB5aWVsZCBkYXRhQmF0Y2g7XG4gICAgfVxufVxuZnVuY3Rpb24gYmF0Y2goc2l6ZSwgaXRlcmFibGUpIHtcbiAgICBpZiAoaXRlcmFibGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gY3VycmllZEl0ZXJhYmxlID0+IGJhdGNoKHNpemUsIGN1cnJpZWRJdGVyYWJsZSk7XG4gICAgfVxuICAgIGlmIChpdGVyYWJsZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0pIHtcbiAgICAgICAgcmV0dXJuIF9iYXRjaChzaXplLCBpdGVyYWJsZSk7XG4gICAgfVxuICAgIHJldHVybiBfc3luY0JhdGNoKHNpemUsIGl0ZXJhYmxlKTtcbn1cblxuY29uc3QgVElNRU9VVCA9IFN5bWJvbCgnVElNRU9VVCcpO1xuY29uc3QgY3JlYXRlVGltZXIgPSAoZHVyYXRpb24pID0+IHtcbiAgICBsZXQgdGltZW91dElkO1xuICAgIHJldHVybiBbXG4gICAgICAgIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAgICAgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiByZXNvbHZlKFRJTUVPVVQpLCBkdXJhdGlvbik7XG4gICAgICAgIH0pLFxuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgfSxcbiAgICBdO1xufTtcbi8vIExpa2UgYGJhdGNoYCBidXQgZmx1c2hlcyBlYXJseSBpZiB0aGUgYHRpbWVvdXRgIGlzIHJlYWNoZWRcbi8vIE5PVEU6IFRoZSBzdHJhdGVneSBpcyB0byBvbmx5IGhvbGQgb250byBhIHNpbmdsZSBpdGVtIGZvciBhIG1heGltdW0gb2YgYHRpbWVvdXRgIG1zLlxuYXN5bmMgZnVuY3Rpb24qIF9iYXRjaFdpdGhUaW1lb3V0KHNpemUsIHRpbWVvdXQsIGl0ZXJhYmxlKSB7XG4gICAgY29uc3QgaXRlcmF0b3IgPSBpdGVyYWJsZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKTtcbiAgICBsZXQgcGVuZGluZ0RhdGE7XG4gICAgbGV0IGJhdGNoRGF0YSA9IFtdO1xuICAgIGxldCB0aW1lcjtcbiAgICBsZXQgY2xlYXJUaW1lcjtcbiAgICBjb25zdCBzdGFydFRpbWVyID0gKCkgPT4ge1xuICAgICAgICBkZWxldGVUaW1lcigpO1xuICAgICAgICBbdGltZXIsIGNsZWFyVGltZXJdID0gY3JlYXRlVGltZXIodGltZW91dCk7XG4gICAgfTtcbiAgICBjb25zdCBkZWxldGVUaW1lciA9ICgpID0+IHtcbiAgICAgICAgaWYgKGNsZWFyVGltZXIpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZXIoKTtcbiAgICAgICAgfVxuICAgICAgICB0aW1lciA9IHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIHBlbmRpbmdEYXRhID0gaXRlcmF0b3IubmV4dCgpO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0ICh0aW1lciA/IFByb21pc2UucmFjZShbcGVuZGluZ0RhdGEsIHRpbWVyXSkgOiBwZW5kaW5nRGF0YSk7XG4gICAgICAgIGlmIChyZXMgPT09IFRJTUVPVVQgfHwgcmVzLmRvbmUpIHtcbiAgICAgICAgICAgIC8vIEZsdXNoIGVhcmx5IChiZWZvcmUgd2UgcmVhY2ggdGhlIGJhdGNoIHNpemUpXG4gICAgICAgICAgICBpZiAoYmF0Y2hEYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHlpZWxkIGJhdGNoRGF0YTtcbiAgICAgICAgICAgICAgICBiYXRjaERhdGEgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlbGV0ZVRpbWVyKCk7XG4gICAgICAgICAgICAvLyBBbmQgZXhpdCBhcHByb3ByaWF0ZWx5XG4gICAgICAgICAgICBpZiAocmVzICE9PSBUSU1FT1VUKSB7XG4gICAgICAgICAgICAgICAgLy8gZG9uZVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmV0Y2ggbmV4dCBpdGVtIGVhcmx5IGRvb3JzIChiZWZvcmUgd2UgcG90ZW50aWFsbHkgeWllbGQpXG4gICAgICAgIHBlbmRpbmdEYXRhID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAvLyBUaGVuIGhhbmRsZSB0aGUgdmFsdWVcbiAgICAgICAgYmF0Y2hEYXRhLnB1c2gocmVzLnZhbHVlKTtcbiAgICAgICAgaWYgKGJhdGNoRGF0YS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIC8vIFN0YXJ0IHRpbWVyIG9uY2Ugd2UgaGF2ZSBhdCBsZWFzdCAxIGl0ZW0gcmVhZHkgdG8gZ29cbiAgICAgICAgICAgIHN0YXJ0VGltZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYmF0Y2hEYXRhLmxlbmd0aCA9PT0gc2l6ZSkge1xuICAgICAgICAgICAgeWllbGQgYmF0Y2hEYXRhO1xuICAgICAgICAgICAgYmF0Y2hEYXRhID0gW107XG4gICAgICAgICAgICBkZWxldGVUaW1lcigpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBiYXRjaFdpdGhUaW1lb3V0KHNpemUsIHRpbWVvdXQsIGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGN1cnJpZWRJdGVyYWJsZSA9PiBiYXRjaFdpdGhUaW1lb3V0KHNpemUsIHRpbWVvdXQsIGN1cnJpZWRJdGVyYWJsZSk7XG4gICAgfVxuICAgIGlmIChpdGVyYWJsZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gJiYgdGltZW91dCAhPT0gSW5maW5pdHkpIHtcbiAgICAgICAgcmV0dXJuIF9iYXRjaFdpdGhUaW1lb3V0KHNpemUsIHRpbWVvdXQsIGl0ZXJhYmxlKTtcbiAgICB9XG4gICAgLy8gRm9yIHN5bmMgaXRlcmFibGVzIG9yIGFuIGluZmluaXRlIHRpbWVvdXQsIHRoZSB0aW1lb3V0IGlzIGlycmVsZXZhbnQgc28ganVzdCBmYWxsYmFjayB0byByZWd1bGFyIGBiYXRjaGAuXG4gICAgcmV0dXJuIGJhdGNoKHNpemUsIGl0ZXJhYmxlKTtcbn1cblxuZnVuY3Rpb24gZ2V0SXRlcmF0b3IoaXRlcmFibGUpIHtcbiAgICBpZiAodHlwZW9mIGl0ZXJhYmxlLm5leHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhYmxlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGl0ZXJhYmxlW1N5bWJvbC5pdGVyYXRvcl0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhYmxlW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBpdGVyYWJsZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhYmxlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInZhbHVlc1wiIGRvZXMgbm90IHRvIGNvbmZvcm0gdG8gYW55IG9mIHRoZSBpdGVyYXRvciBvciBpdGVyYWJsZSBwcm90b2NvbHMnKTtcbn1cblxuZnVuY3Rpb24gZGVmZXIoKSB7XG4gICAgbGV0IHJlamVjdDtcbiAgICBsZXQgcmVzb2x2ZTtcbiAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmVGdW5jLCByZWplY3RGdW5jKSA9PiB7XG4gICAgICAgIHJlc29sdmUgPSByZXNvbHZlRnVuYztcbiAgICAgICAgcmVqZWN0ID0gcmVqZWN0RnVuYztcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBwcm9taXNlLFxuICAgICAgICByZWplY3QsXG4gICAgICAgIHJlc29sdmUsXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gX2J1ZmZlcihzaXplLCBpdGVyYWJsZSkge1xuICAgIGNvbnN0IGl0ZXJhdG9yID0gZ2V0SXRlcmF0b3IoaXRlcmFibGUpO1xuICAgIGNvbnN0IHJlc3VsdFF1ZXVlID0gW107XG4gICAgY29uc3QgcmVhZFF1ZXVlID0gW107XG4gICAgbGV0IHJlYWRpbmcgPSBmYWxzZTtcbiAgICBsZXQgZW5kZWQgPSBmYWxzZTtcbiAgICBmdW5jdGlvbiBmdWxmaWxsUmVhZFF1ZXVlKCkge1xuICAgICAgICB3aGlsZSAocmVhZFF1ZXVlLmxlbmd0aCA+IDAgJiYgcmVzdWx0UXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgcmVhZERlZmVycmVkID0gcmVhZFF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICBjb25zdCB7IGVycm9yLCB2YWx1ZSB9ID0gcmVzdWx0UXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJlYWREZWZlcnJlZC5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVhZERlZmVycmVkLnJlc29sdmUoeyBkb25lOiBmYWxzZSwgdmFsdWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHJlYWRRdWV1ZS5sZW5ndGggPiAwICYmIGVuZGVkKSB7XG4gICAgICAgICAgICBjb25zdCB7IHJlc29sdmUgfSA9IHJlYWRRdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgcmVzb2x2ZSh7IGRvbmU6IHRydWUsIHZhbHVlOiB1bmRlZmluZWQgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZnVuY3Rpb24gZmlsbFF1ZXVlKCkge1xuICAgICAgICBpZiAoZW5kZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVhZGluZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHRRdWV1ZS5sZW5ndGggPj0gc2l6ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJlYWRpbmcgPSB0cnVlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICBlbmRlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHRRdWV1ZS5wdXNoKHsgdmFsdWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBlbmRlZCA9IHRydWU7XG4gICAgICAgICAgICByZXN1bHRRdWV1ZS5wdXNoKHsgZXJyb3IgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVsZmlsbFJlYWRRdWV1ZSgpO1xuICAgICAgICByZWFkaW5nID0gZmFsc2U7XG4gICAgICAgIGZpbGxRdWV1ZSgpO1xuICAgIH1cbiAgICBhc3luYyBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICBpZiAocmVzdWx0UXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgeyBlcnJvciwgdmFsdWUgfSA9IHJlc3VsdFF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbGxRdWV1ZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZGVkKSB7XG4gICAgICAgICAgICByZXR1cm4geyBkb25lOiB0cnVlLCB2YWx1ZTogdW5kZWZpbmVkIH07IC8vIHN0dXBpZCB0c1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICAgICAgcmVhZFF1ZXVlLnB1c2goZGVmZXJyZWQpO1xuICAgICAgICBmaWxsUXVldWUoKTtcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgfVxuICAgIGNvbnN0IGFzeW5jSXRlcmFibGVJdGVyYXRvciA9IHtcbiAgICAgICAgbmV4dCxcbiAgICAgICAgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXTogKCkgPT4gYXN5bmNJdGVyYWJsZUl0ZXJhdG9yLFxuICAgIH07XG4gICAgcmV0dXJuIGFzeW5jSXRlcmFibGVJdGVyYXRvcjtcbn1cbmZ1bmN0aW9uKiBzeW5jQnVmZmVyKHNpemUsIGl0ZXJhYmxlKSB7XG4gICAgY29uc3QgdmFsdWVRdWV1ZSA9IFtdO1xuICAgIGxldCBlO1xuICAgIHRyeSB7XG4gICAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgaXRlcmFibGUpIHtcbiAgICAgICAgICAgIHZhbHVlUXVldWUucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAodmFsdWVRdWV1ZS5sZW5ndGggPD0gc2l6ZSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeWllbGQgdmFsdWVRdWV1ZS5zaGlmdCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBlID0gZXJyb3I7XG4gICAgfVxuICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdmFsdWVRdWV1ZSkge1xuICAgICAgICB5aWVsZCB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKGUpIHtcbiAgICAgICAgdGhyb3cgZTtcbiAgICB9XG59XG5mdW5jdGlvbiBidWZmZXIoc2l6ZSwgaXRlcmFibGUpIHtcbiAgICBpZiAoaXRlcmFibGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gY3VycmllZEl0ZXJhYmxlID0+IGJ1ZmZlcihzaXplLCBjdXJyaWVkSXRlcmFibGUpO1xuICAgIH1cbiAgICBpZiAoc2l6ZSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gaXRlcmFibGU7XG4gICAgfVxuICAgIGlmIChpdGVyYWJsZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0pIHtcbiAgICAgICAgcmV0dXJuIF9idWZmZXIoc2l6ZSwgaXRlcmFibGUpO1xuICAgIH1cbiAgICByZXR1cm4gc3luY0J1ZmZlcihzaXplLCBpdGVyYWJsZSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIF9jb2xsZWN0KGl0ZXJhYmxlKSB7XG4gICAgY29uc3QgdmFsdWVzID0gW107XG4gICAgZm9yIGF3YWl0IChjb25zdCB2YWx1ZSBvZiBpdGVyYWJsZSkge1xuICAgICAgICB2YWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZXM7XG59XG5mdW5jdGlvbiBjb2xsZWN0KGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSkge1xuICAgICAgICByZXR1cm4gX2NvbGxlY3QoaXRlcmFibGUpO1xuICAgIH1cbiAgICByZXR1cm4gQXJyYXkuZnJvbShpdGVyYWJsZSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uKiBfY29uY2F0KGl0ZXJhYmxlcykge1xuICAgIGZvciBhd2FpdCAoY29uc3QgaXRlcmFibGUgb2YgaXRlcmFibGVzKSB7XG4gICAgICAgIHlpZWxkKiBpdGVyYWJsZTtcbiAgICB9XG59XG5mdW5jdGlvbiogX3N5bmNDb25jYXQoaXRlcmFibGVzKSB7XG4gICAgZm9yIChjb25zdCBpdGVyYWJsZSBvZiBpdGVyYWJsZXMpIHtcbiAgICAgICAgeWllbGQqIGl0ZXJhYmxlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbmNhdCguLi5pdGVyYWJsZXMpIHtcbiAgICBjb25zdCBoYXNBbnlBc3luYyA9IGl0ZXJhYmxlcy5maW5kKGl0ciA9PiBpdHJbU3ltYm9sLmFzeW5jSXRlcmF0b3JdICE9PSB1bmRlZmluZWQpO1xuICAgIGlmIChoYXNBbnlBc3luYykge1xuICAgICAgICByZXR1cm4gX2NvbmNhdChpdGVyYWJsZXMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIF9zeW5jQ29uY2F0KGl0ZXJhYmxlcyk7XG4gICAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBfY29uc3VtZShpdGVyYWJsZSkge1xuICAgIGZvciBhd2FpdCAoY29uc3QgdmFsIG9mIGl0ZXJhYmxlKSB7XG4gICAgICAgIC8vIGRvIG5vdGhpbmdcbiAgICB9XG59XG5mdW5jdGlvbiBjb25zdW1lKGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSkge1xuICAgICAgICByZXR1cm4gX2NvbnN1bWUoaXRlcmFibGUpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHZhbCBvZiBpdGVyYWJsZSkge1xuICAgICAgICAvLyBkbyBub3RoaW5nXG4gICAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiogX2ZpbHRlcihmaWx0ZXJGdW5jLCBpdGVyYWJsZSkge1xuICAgIGZvciBhd2FpdCAoY29uc3QgZGF0YSBvZiBpdGVyYWJsZSkge1xuICAgICAgICBpZiAoYXdhaXQgZmlsdGVyRnVuYyhkYXRhKSkge1xuICAgICAgICAgICAgeWllbGQgZGF0YTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGZpbHRlcihmaWx0ZXJGdW5jLCBpdGVyYWJsZSkge1xuICAgIGlmIChpdGVyYWJsZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAoY3VycmllZEl0ZXJhYmxlKSA9PiBfZmlsdGVyKGZpbHRlckZ1bmMsIGN1cnJpZWRJdGVyYWJsZSk7XG4gICAgfVxuICAgIHJldHVybiBfZmlsdGVyKGZpbHRlckZ1bmMsIGl0ZXJhYmxlKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24qIGZsYXR0ZW4oaXRlcmFibGUpIHtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IG1heWJlSXRyIG9mIGl0ZXJhYmxlKSB7XG4gICAgICAgIGlmIChtYXliZUl0ciAmJiB0eXBlb2YgbWF5YmVJdHIgIT09ICdzdHJpbmcnICYmIChtYXliZUl0cltTeW1ib2wuaXRlcmF0b3JdIHx8IG1heWJlSXRyW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSkpIHtcbiAgICAgICAgICAgIHlpZWxkKiBmbGF0dGVuKG1heWJlSXRyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHlpZWxkIG1heWJlSXRyO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiogX21hcChmdW5jLCBpdGVyYWJsZSkge1xuICAgIGZvciBhd2FpdCAoY29uc3QgdmFsIG9mIGl0ZXJhYmxlKSB7XG4gICAgICAgIHlpZWxkIGF3YWl0IGZ1bmModmFsKTtcbiAgICB9XG59XG5mdW5jdGlvbiBtYXAoZnVuYywgaXRlcmFibGUpIHtcbiAgICBpZiAoaXRlcmFibGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gY3VycmllZEl0ZXJhYmxlID0+IF9tYXAoZnVuYywgY3VycmllZEl0ZXJhYmxlKTtcbiAgICB9XG4gICAgcmV0dXJuIF9tYXAoZnVuYywgaXRlcmFibGUpO1xufVxuXG5mdW5jdGlvbiBmbGF0TWFwKGZ1bmMsIGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGN1cnJpZWRJdGVyYWJsZSA9PiBmbGF0TWFwKGZ1bmMsIGN1cnJpZWRJdGVyYWJsZSk7XG4gICAgfVxuICAgIHJldHVybiBmaWx0ZXIoaSA9PiBpICE9PSB1bmRlZmluZWQgJiYgaSAhPT0gbnVsbCwgZmxhdHRlbihtYXAoZnVuYywgaXRlcmFibGUpKSk7XG59XG5cbmZ1bmN0aW9uIF9mbGF0VHJhbnNmb3JtKGNvbmN1cnJlbmN5LCBmdW5jLCBpdGVyYWJsZSkge1xuICAgIGNvbnN0IGl0ZXJhdG9yID0gZ2V0SXRlcmF0b3IoaXRlcmFibGUpO1xuICAgIGNvbnN0IHJlc3VsdFF1ZXVlID0gW107XG4gICAgY29uc3QgcmVhZFF1ZXVlID0gW107XG4gICAgbGV0IGVuZGVkID0gZmFsc2U7XG4gICAgbGV0IHJlYWRpbmcgPSBmYWxzZTtcbiAgICBsZXQgaW5mbGlnaHRDb3VudCA9IDA7XG4gICAgbGV0IGxhc3RFcnJvciA9IG51bGw7XG4gICAgZnVuY3Rpb24gZnVsZmlsbFJlYWRRdWV1ZSgpIHtcbiAgICAgICAgd2hpbGUgKHJlYWRRdWV1ZS5sZW5ndGggPiAwICYmIHJlc3VsdFF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcmVzb2x2ZSB9ID0gcmVhZFF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHJlc3VsdFF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICByZXNvbHZlKHsgZG9uZTogZmFsc2UsIHZhbHVlIH0pO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChyZWFkUXVldWUubGVuZ3RoID4gMCAmJiBpbmZsaWdodENvdW50ID09PSAwICYmIGVuZGVkKSB7XG4gICAgICAgICAgICBjb25zdCB7IHJlc29sdmUsIHJlamVjdCB9ID0gcmVhZFF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICBpZiAobGFzdEVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGxhc3RFcnJvcik7XG4gICAgICAgICAgICAgICAgbGFzdEVycm9yID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoeyBkb25lOiB0cnVlLCB2YWx1ZTogdW5kZWZpbmVkIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGZ1bmN0aW9uIGZpbGxRdWV1ZSgpIHtcbiAgICAgICAgaWYgKGVuZGVkKSB7XG4gICAgICAgICAgICBmdWxmaWxsUmVhZFF1ZXVlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlYWRpbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5mbGlnaHRDb3VudCArIHJlc3VsdFF1ZXVlLmxlbmd0aCA+PSBjb25jdXJyZW5jeSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJlYWRpbmcgPSB0cnVlO1xuICAgICAgICBpbmZsaWdodENvdW50Kys7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgIGVuZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpbmZsaWdodENvdW50LS07XG4gICAgICAgICAgICAgICAgZnVsZmlsbFJlYWRRdWV1ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbWFwQW5kUXVldWUodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgZW5kZWQgPSB0cnVlO1xuICAgICAgICAgICAgaW5mbGlnaHRDb3VudC0tO1xuICAgICAgICAgICAgbGFzdEVycm9yID0gZXJyb3I7XG4gICAgICAgICAgICBmdWxmaWxsUmVhZFF1ZXVlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVhZGluZyA9IGZhbHNlO1xuICAgICAgICBmaWxsUXVldWUoKTtcbiAgICB9XG4gICAgYXN5bmMgZnVuY3Rpb24gbWFwQW5kUXVldWUoaXRyVmFsdWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgZnVuYyhpdHJWYWx1ZSk7XG4gICAgICAgICAgICBpZiAodmFsdWUgJiYgdmFsdWVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKSB7XG4gICAgICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBhc3luY1ZhbCBvZiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRRdWV1ZS5wdXNoKGFzeW5jVmFsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHRRdWV1ZS5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGVuZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGxhc3RFcnJvciA9IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGluZmxpZ2h0Q291bnQtLTtcbiAgICAgICAgZnVsZmlsbFJlYWRRdWV1ZSgpO1xuICAgICAgICBmaWxsUXVldWUoKTtcbiAgICB9XG4gICAgYXN5bmMgZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgaWYgKHJlc3VsdFF1ZXVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgY29uc3QgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgICAgICAgICAgcmVhZFF1ZXVlLnB1c2goZGVmZXJyZWQpO1xuICAgICAgICAgICAgZmlsbFF1ZXVlKCk7XG4gICAgICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWx1ZSA9IHJlc3VsdFF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgIGZpbGxRdWV1ZSgpO1xuICAgICAgICByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWUgfTtcbiAgICB9XG4gICAgY29uc3QgYXN5bmNJdGVyYWJsZUl0ZXJhdG9yID0ge1xuICAgICAgICBuZXh0LFxuICAgICAgICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdOiAoKSA9PiBhc3luY0l0ZXJhYmxlSXRlcmF0b3IsXG4gICAgfTtcbiAgICByZXR1cm4gYXN5bmNJdGVyYWJsZUl0ZXJhdG9yO1xufVxuZnVuY3Rpb24gZmxhdFRyYW5zZm9ybShjb25jdXJyZW5jeSwgZnVuYywgaXRlcmFibGUpIHtcbiAgICBpZiAoZnVuYyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAoY3VycmllZEZ1bmMsIGN1cnJpZWRJdGVyYWJsZSkgPT4gY3VycmllZEl0ZXJhYmxlXG4gICAgICAgICAgICA/IGZsYXRUcmFuc2Zvcm0oY29uY3VycmVuY3ksIGN1cnJpZWRGdW5jLCBjdXJyaWVkSXRlcmFibGUpXG4gICAgICAgICAgICA6IGZsYXRUcmFuc2Zvcm0oY29uY3VycmVuY3ksIGN1cnJpZWRGdW5jKTtcbiAgICB9XG4gICAgaWYgKGl0ZXJhYmxlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIChjdXJyaWVkSXRlcmFibGUpID0+IGZsYXRUcmFuc2Zvcm0oY29uY3VycmVuY3ksIGZ1bmMsIGN1cnJpZWRJdGVyYWJsZSk7XG4gICAgfVxuICAgIHJldHVybiBmaWx0ZXIoaSA9PiBpICE9PSB1bmRlZmluZWQgJiYgaSAhPT0gbnVsbCwgZmxhdHRlbihfZmxhdFRyYW5zZm9ybShjb25jdXJyZW5jeSwgZnVuYywgaXRlcmFibGUpKSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIG9uY2VSZWFkYWJsZShzdHJlYW0pIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgIHN0cmVhbS5vbmNlKCdyZWFkYWJsZScsICgpID0+IHtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5hc3luYyBmdW5jdGlvbiogX2Zyb21TdHJlYW0oc3RyZWFtKSB7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IHN0cmVhbS5yZWFkKCk7XG4gICAgICAgIGlmIChkYXRhICE9PSBudWxsKSB7XG4gICAgICAgICAgICB5aWVsZCBkYXRhO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0cmVhbS5fcmVhZGFibGVTdGF0ZS5lbmRlZCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgb25jZVJlYWRhYmxlKHN0cmVhbSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZnJvbVN0cmVhbShzdHJlYW0pIHtcbiAgICBpZiAodHlwZW9mIHN0cmVhbVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHN0cmVhbTtcbiAgICB9XG4gICAgcmV0dXJuIF9mcm9tU3RyZWFtKHN0cmVhbSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uKiBtZXJnZSguLi5pdGVyYWJsZXMpIHtcbiAgICBjb25zdCBzb3VyY2VzID0gbmV3IFNldChpdGVyYWJsZXMubWFwKGdldEl0ZXJhdG9yKSk7XG4gICAgd2hpbGUgKHNvdXJjZXMuc2l6ZSA+IDApIHtcbiAgICAgICAgZm9yIChjb25zdCBpdGVyYXRvciBvZiBzb3VyY2VzKSB7XG4gICAgICAgICAgICBjb25zdCBuZXh0VmFsID0gYXdhaXQgaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgICAgaWYgKG5leHRWYWwuZG9uZSkge1xuICAgICAgICAgICAgICAgIHNvdXJjZXMuZGVsZXRlKGl0ZXJhdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHlpZWxkIG5leHRWYWwudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIHBpcGVsaW5lKGZpcnN0Rm4sIC4uLmZucykge1xuICAgIGxldCBwcmV2aW91c0ZuID0gZmlyc3RGbigpO1xuICAgIGZvciAoY29uc3QgZnVuYyBvZiBmbnMpIHtcbiAgICAgICAgcHJldmlvdXNGbiA9IGZ1bmMocHJldmlvdXNGbik7XG4gICAgfVxuICAgIHJldHVybiBwcmV2aW91c0ZuO1xufVxuXG5hc3luYyBmdW5jdGlvbiogX3BhcmFsbGVsTWFwKGNvbmN1cnJlbmN5LCBmdW5jLCBpdGVyYWJsZSkge1xuICAgIGxldCB0cmFuc2Zvcm1FcnJvciA9IG51bGw7XG4gICAgY29uc3Qgd3JhcEZ1bmMgPSB2YWx1ZSA9PiAoe1xuICAgICAgICB2YWx1ZTogZnVuYyh2YWx1ZSksXG4gICAgfSk7XG4gICAgY29uc3Qgc3RvcE9uRXJyb3IgPSBhc3luYyBmdW5jdGlvbiogKHNvdXJjZSkge1xuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IHZhbHVlIG9mIHNvdXJjZSkge1xuICAgICAgICAgICAgaWYgKHRyYW5zZm9ybUVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeWllbGQgdmFsdWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IG91dHB1dCA9IHBpcGVsaW5lKCgpID0+IGl0ZXJhYmxlLCBidWZmZXIoMSksIHN0b3BPbkVycm9yLCBtYXAod3JhcEZ1bmMpLCBidWZmZXIoY29uY3VycmVuY3kgLSAxKSk7XG4gICAgY29uc3QgaXRyID0gZ2V0SXRlcmF0b3Iob3V0cHV0KTtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBjb25zdCB7IHZhbHVlLCBkb25lIH0gPSBhd2FpdCBpdHIubmV4dCgpO1xuICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHZhbCA9IGF3YWl0IHZhbHVlLnZhbHVlO1xuICAgICAgICAgICAgaWYgKCF0cmFuc2Zvcm1FcnJvcikge1xuICAgICAgICAgICAgICAgIHlpZWxkIHZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybUVycm9yID0gZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRyYW5zZm9ybUVycm9yKSB7XG4gICAgICAgIHRocm93IHRyYW5zZm9ybUVycm9yO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHBhcmFsbGVsTWFwKGNvbmN1cnJlbmN5LCBmdW5jLCBpdGVyYWJsZSkge1xuICAgIGlmIChmdW5jID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIChjdXJyaWVkRnVuYywgY3VycmllZEl0ZXJhYmxlKSA9PiBwYXJhbGxlbE1hcChjb25jdXJyZW5jeSwgY3VycmllZEZ1bmMsIGN1cnJpZWRJdGVyYWJsZSk7XG4gICAgfVxuICAgIGlmIChpdGVyYWJsZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBjdXJyaWVkSXRlcmFibGUgPT4gcGFyYWxsZWxNYXAoY29uY3VycmVuY3ksIGZ1bmMsIGN1cnJpZWRJdGVyYWJsZSk7XG4gICAgfVxuICAgIGlmIChjb25jdXJyZW5jeSA9PT0gMSkge1xuICAgICAgICByZXR1cm4gbWFwKGZ1bmMsIGl0ZXJhYmxlKTtcbiAgICB9XG4gICAgcmV0dXJuIF9wYXJhbGxlbE1hcChjb25jdXJyZW5jeSwgZnVuYywgaXRlcmFibGUpO1xufVxuXG5mdW5jdGlvbiBwYXJhbGxlbEZsYXRNYXAoY29uY3VycmVuY3ksIGZ1bmMsIGl0ZXJhYmxlKSB7XG4gICAgaWYgKGZ1bmMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gKGN1cnJpZWRGdW5jLCBjdXJyaWVkSXRlcmFibGUpID0+IGN1cnJpZWRJdGVyYWJsZVxuICAgICAgICAgICAgPyBwYXJhbGxlbEZsYXRNYXAoY29uY3VycmVuY3ksIGN1cnJpZWRGdW5jLCBjdXJyaWVkSXRlcmFibGUpXG4gICAgICAgICAgICA6IHBhcmFsbGVsRmxhdE1hcChjb25jdXJyZW5jeSwgY3VycmllZEZ1bmMpO1xuICAgIH1cbiAgICBpZiAoaXRlcmFibGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gKGN1cnJpZWRJdGVyYWJsZSkgPT4gcGFyYWxsZWxGbGF0TWFwKGNvbmN1cnJlbmN5LCBmdW5jLCBjdXJyaWVkSXRlcmFibGUpO1xuICAgIH1cbiAgICByZXR1cm4gZmlsdGVyKGkgPT4gaSAhPT0gdW5kZWZpbmVkICYmIGkgIT09IG51bGwsIGZsYXR0ZW4ocGFyYWxsZWxNYXAoY29uY3VycmVuY3ksIGZ1bmMsIGl0ZXJhYmxlKSkpO1xufVxuXG5hc3luYyBmdW5jdGlvbiogcGFyYWxsZWxNZXJnZSguLi5pdGVyYWJsZXMpIHtcbiAgICBjb25zdCBpbnB1dHMgPSBpdGVyYWJsZXMubWFwKGdldEl0ZXJhdG9yKTtcbiAgICBjb25zdCBjb25jdXJyZW50V29yayA9IG5ldyBTZXQoKTtcbiAgICBjb25zdCB2YWx1ZXMgPSBuZXcgTWFwKCk7XG4gICAgbGV0IGxhc3RFcnJvciA9IG51bGw7XG4gICAgbGV0IGVyckNiID0gbnVsbDtcbiAgICBsZXQgdmFsdWVDYiA9IG51bGw7XG4gICAgY29uc3Qgbm90aWZ5RXJyb3IgPSBlcnIgPT4ge1xuICAgICAgICBsYXN0RXJyb3IgPSBlcnI7XG4gICAgICAgIGlmIChlcnJDYikge1xuICAgICAgICAgICAgZXJyQ2IoZXJyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgbm90aWZ5RG9uZSA9IHZhbHVlID0+IHtcbiAgICAgICAgaWYgKHZhbHVlQ2IpIHtcbiAgICAgICAgICAgIHZhbHVlQ2IodmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCB3YWl0Rm9yUXVldWUgPSAoKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGlmIChsYXN0RXJyb3IpIHtcbiAgICAgICAgICAgIHJlamVjdChsYXN0RXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZXMuc2l6ZSA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWVDYiA9IHJlc29sdmU7XG4gICAgICAgIGVyckNiID0gcmVqZWN0O1xuICAgIH0pO1xuICAgIGNvbnN0IHF1ZXVlTmV4dCA9IGlucHV0ID0+IHtcbiAgICAgICAgY29uc3QgbmV4dFZhbCA9IFByb21pc2UucmVzb2x2ZShpbnB1dC5uZXh0KCkpLnRoZW4oYXN5bmMgKHsgZG9uZSwgdmFsdWUgfSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFkb25lKSB7XG4gICAgICAgICAgICAgICAgdmFsdWVzLnNldChpbnB1dCwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uY3VycmVudFdvcmsuZGVsZXRlKG5leHRWYWwpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uY3VycmVudFdvcmsuYWRkKG5leHRWYWwpO1xuICAgICAgICBuZXh0VmFsLnRoZW4obm90aWZ5RG9uZSwgbm90aWZ5RXJyb3IpO1xuICAgIH07XG4gICAgZm9yIChjb25zdCBpbnB1dCBvZiBpbnB1dHMpIHtcbiAgICAgICAgcXVldWVOZXh0KGlucHV0KTtcbiAgICB9XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgLy8gV2UgdGVjaG5pY2FsbHkgZG9uJ3QgaGF2ZSB0byBjaGVjayBgdmFsdWVzLnNpemVgIGFzIHRoZSBmb3IgbG9vcCBzaG91bGQgaGF2ZSBlbXB0aWVkIGl0XG4gICAgICAgIC8vIEhvd2V2ZXIgSSBoYXZlbid0IHlldCBmb3VuZCBzcGVjcyB2ZXJpZnlpbmcgdGhhdCBiZWhhdmlvciwgb25seSB0ZXN0c1xuICAgICAgICAvLyB0aGUgZ3VhcmQgaW4gd2FpdEZvclF1ZXVlKCkgY2hlY2tpbmcgZm9yIHZhbHVlcyBpcyBpbiBwbGFjZSBmb3IgdGhlIHNhbWUgcmVhc29uXG4gICAgICAgIGlmIChjb25jdXJyZW50V29yay5zaXplID09PSAwICYmIHZhbHVlcy5zaXplID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgd2FpdEZvclF1ZXVlKCk7XG4gICAgICAgIGZvciAoY29uc3QgW2lucHV0LCB2YWx1ZV0gb2YgdmFsdWVzKSB7XG4gICAgICAgICAgICB2YWx1ZXMuZGVsZXRlKGlucHV0KTtcbiAgICAgICAgICAgIHlpZWxkIHZhbHVlO1xuICAgICAgICAgICAgcXVldWVOZXh0KGlucHV0KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gX3JlZHVjZShmdW5jLCBzdGFydCwgaXRlcmFibGUpIHtcbiAgICBsZXQgdmFsdWUgPSBzdGFydDtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IG5leHRJdGVtIG9mIGl0ZXJhYmxlKSB7XG4gICAgICAgIHZhbHVlID0gYXdhaXQgZnVuYyh2YWx1ZSwgbmV4dEl0ZW0pO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiByZWR1Y2UoZnVuYywgc3RhcnQsIGl0ZXJhYmxlKSB7XG4gICAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIChjdXJyaWVkU3RhcnQsIGN1cnJpZWRJdGVyYWJsZSkgPT4gY3VycmllZEl0ZXJhYmxlID8gX3JlZHVjZShmdW5jLCBjdXJyaWVkU3RhcnQsIGN1cnJpZWRJdGVyYWJsZSkgOiByZWR1Y2UoZnVuYywgY3VycmllZFN0YXJ0KTtcbiAgICB9XG4gICAgaWYgKGl0ZXJhYmxlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIChjdXJyaWVkSXRlcmFibGUpID0+IHJlZHVjZShmdW5jLCBzdGFydCwgY3VycmllZEl0ZXJhYmxlKTtcbiAgICB9XG4gICAgcmV0dXJuIF9yZWR1Y2UoZnVuYywgc3RhcnQsIGl0ZXJhYmxlKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24qIF90YWtlKGNvdW50LCBpdGVyYWJsZSkge1xuICAgIGxldCB0YWtlbiA9IDA7XG4gICAgZm9yIGF3YWl0IChjb25zdCB2YWwgb2YgaXRlcmFibGUpIHtcbiAgICAgICAgeWllbGQgYXdhaXQgdmFsO1xuICAgICAgICB0YWtlbisrO1xuICAgICAgICBpZiAodGFrZW4gPj0gY291bnQpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24qIF9zeW5jVGFrZShjb3VudCwgaXRlcmFibGUpIHtcbiAgICBsZXQgdGFrZW4gPSAwO1xuICAgIGZvciAoY29uc3QgdmFsIG9mIGl0ZXJhYmxlKSB7XG4gICAgICAgIHlpZWxkIHZhbDtcbiAgICAgICAgdGFrZW4rKztcbiAgICAgICAgaWYgKHRha2VuID49IGNvdW50KSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHRha2UoY291bnQsIGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGN1cnJpZWRJdGVyYWJsZSA9PiB0YWtlKGNvdW50LCBjdXJyaWVkSXRlcmFibGUpO1xuICAgIH1cbiAgICBpZiAoaXRlcmFibGVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKSB7XG4gICAgICAgIHJldHVybiBfdGFrZShjb3VudCwgaXRlcmFibGUpO1xuICAgIH1cbiAgICByZXR1cm4gX3N5bmNUYWtlKGNvdW50LCBpdGVyYWJsZSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uKiBfYXN5bmNUYXAoZnVuYywgaXRlcmFibGUpIHtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IHZhbCBvZiBpdGVyYWJsZSkge1xuICAgICAgICBhd2FpdCBmdW5jKHZhbCk7XG4gICAgICAgIHlpZWxkIHZhbDtcbiAgICB9XG59XG5mdW5jdGlvbiB0YXAoZnVuYywgaXRlcmFibGUpIHtcbiAgICBpZiAoaXRlcmFibGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gKGN1cnJpZWRJdGVyYWJsZSkgPT4gX2FzeW5jVGFwKGZ1bmMsIGN1cnJpZWRJdGVyYWJsZSk7XG4gICAgfVxuICAgIHJldHVybiBfYXN5bmNUYXAoZnVuYywgaXRlcmFibGUpO1xufVxuXG5jb25zdCBzbGVlcCA9IChtcykgPT4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIG1zKSk7XG5mdW5jdGlvbiBfdGhyb3R0bGUobGltaXQsIGludGVydmFsLCBpdGVyYWJsZSkge1xuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKGxpbWl0KSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBgbGltaXRgIHRvIGJlIGEgZmluaXRlIG51bWJlcicpO1xuICAgIH1cbiAgICBpZiAobGltaXQgPD0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBgbGltaXRgIHRvIGJlIGdyZWF0ZXIgdGhhbiAwJyk7XG4gICAgfVxuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKGludGVydmFsKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBgaW50ZXJ2YWxgIHRvIGJlIGEgZmluaXRlIG51bWJlcicpO1xuICAgIH1cbiAgICByZXR1cm4gKGFzeW5jIGZ1bmN0aW9uKiBfX3Rocm90dGxlKCkge1xuICAgICAgICBsZXQgc2VudCA9IDA7XG4gICAgICAgIGxldCB0aW1lO1xuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IHZhbCBvZiBpdGVyYWJsZSkge1xuICAgICAgICAgICAgaWYgKHNlbnQgPCBsaW1pdCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGltZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGltZSA9IERhdGUubm93KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNlbnQrKztcbiAgICAgICAgICAgICAgICB5aWVsZCB2YWw7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBPbmx5IHdhaXQgaWYgdGhlIGludGVydmFsIGhhc24ndCBhbHJlYWR5IHBhc3NlZCB3aGlsZSB3ZSB3ZXJlXG4gICAgICAgICAgICAvLyB5aWVsZGluZyB0aGUgcHJldmlvdXMgdmFsdWVzLlxuICAgICAgICAgICAgY29uc3QgZWxhcHNlZE1zID0gRGF0ZS5ub3coKSAtIHRpbWU7XG4gICAgICAgICAgICBjb25zdCB3YWl0Rm9yID0gaW50ZXJ2YWwgLSBlbGFwc2VkTXM7XG4gICAgICAgICAgICBpZiAod2FpdEZvciA+IDApIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBzbGVlcCh3YWl0Rm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgc2VudCA9IDE7XG4gICAgICAgICAgICB5aWVsZCB2YWw7XG4gICAgICAgIH1cbiAgICB9KSgpO1xufVxuZnVuY3Rpb24gdGhyb3R0bGUobGltaXQsIGludGVydmFsLCBpdGVyYWJsZSkge1xuICAgIGlmIChpdGVyYWJsZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAoY3VycmllZEl0ZXJhYmxlKSA9PiBfdGhyb3R0bGUobGltaXQsIGludGVydmFsLCBjdXJyaWVkSXRlcmFibGUpO1xuICAgIH1cbiAgICByZXR1cm4gX3Rocm90dGxlKGxpbWl0LCBpbnRlcnZhbCwgaXRlcmFibGUpO1xufVxuXG5mdW5jdGlvbiBhZGRUaW1lKGEsIGIpIHtcbiAgICBsZXQgc2Vjb25kcyA9IGFbMF0gKyBiWzBdO1xuICAgIGxldCBuYW5vc2Vjb25kcyA9IGFbMV0gKyBiWzFdO1xuICAgIGlmIChuYW5vc2Vjb25kcyA+PSAxMDAwMDAwMDAwKSB7XG4gICAgICAgIGNvbnN0IHJlbWFpbmRlciA9IG5hbm9zZWNvbmRzICUgMTAwMDAwMDAwMDtcbiAgICAgICAgc2Vjb25kcyArPSAobmFub3NlY29uZHMgLSByZW1haW5kZXIpIC8gMTAwMDAwMDAwMDtcbiAgICAgICAgbmFub3NlY29uZHMgPSByZW1haW5kZXI7XG4gICAgfVxuICAgIHJldHVybiBbc2Vjb25kcywgbmFub3NlY29uZHNdO1xufVxuYXN5bmMgZnVuY3Rpb24qIF9hc3luY1RpbWUoY29uZmlnLCBpdGVyYWJsZSkge1xuICAgIGNvbnN0IGl0ciA9IGl0ZXJhYmxlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpO1xuICAgIGxldCB0b3RhbCA9IFswLCAwXTtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBjb25zdCBzdGFydCA9IHByb2Nlc3MuaHJ0aW1lKCk7XG4gICAgICAgIGNvbnN0IHsgdmFsdWUsIGRvbmUgfSA9IGF3YWl0IGl0ci5uZXh0KCk7XG4gICAgICAgIGNvbnN0IGRlbHRhID0gcHJvY2Vzcy5ocnRpbWUoc3RhcnQpO1xuICAgICAgICB0b3RhbCA9IGFkZFRpbWUodG90YWwsIGRlbHRhKTtcbiAgICAgICAgaWYgKGNvbmZpZy5wcm9ncmVzcykge1xuICAgICAgICAgICAgY29uZmlnLnByb2dyZXNzKGRlbHRhLCB0b3RhbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgIGlmIChjb25maWcudG90YWwpIHtcbiAgICAgICAgICAgICAgICBjb25maWcudG90YWwodG90YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHlpZWxkIHZhbHVlO1xuICAgIH1cbn1cbmZ1bmN0aW9uKiBfc3luY1RpbWUoY29uZmlnLCBpdGVyYWJsZSkge1xuICAgIGNvbnN0IGl0ciA9IGl0ZXJhYmxlW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICBsZXQgdG90YWwgPSBbMCwgMF07XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBwcm9jZXNzLmhydGltZSgpO1xuICAgICAgICBjb25zdCB7IHZhbHVlLCBkb25lIH0gPSBpdHIubmV4dCgpO1xuICAgICAgICBjb25zdCBkZWx0YSA9IHByb2Nlc3MuaHJ0aW1lKHN0YXJ0KTtcbiAgICAgICAgdG90YWwgPSBhZGRUaW1lKHRvdGFsLCBkZWx0YSk7XG4gICAgICAgIGlmIChjb25maWcucHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgIGNvbmZpZy5wcm9ncmVzcyhkZWx0YSwgdG90YWwpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICBpZiAoY29uZmlnLnRvdGFsKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLnRvdGFsKHRvdGFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB5aWVsZCB2YWx1ZTtcbiAgICB9XG59XG5mdW5jdGlvbiB0aW1lKGNvbmZpZyA9IHt9LCBpdGVyYWJsZSkge1xuICAgIGlmIChpdGVyYWJsZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBjdXJyaWVkSXRlcmFibGUgPT4gdGltZShjb25maWcsIGN1cnJpZWRJdGVyYWJsZSk7XG4gICAgfVxuICAgIGlmIChpdGVyYWJsZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gX2FzeW5jVGltZShjb25maWcsIGl0ZXJhYmxlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBfc3luY1RpbWUoY29uZmlnLCBpdGVyYWJsZSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBfdHJhbnNmb3JtKGNvbmN1cnJlbmN5LCBmdW5jLCBpdGVyYWJsZSkge1xuICAgIGNvbnN0IGl0ZXJhdG9yID0gZ2V0SXRlcmF0b3IoaXRlcmFibGUpO1xuICAgIGNvbnN0IHJlc3VsdFF1ZXVlID0gW107XG4gICAgY29uc3QgcmVhZFF1ZXVlID0gW107XG4gICAgbGV0IGVuZGVkID0gZmFsc2U7XG4gICAgbGV0IHJlYWRpbmcgPSBmYWxzZTtcbiAgICBsZXQgaW5mbGlnaHRDb3VudCA9IDA7XG4gICAgbGV0IGxhc3RFcnJvciA9IG51bGw7XG4gICAgZnVuY3Rpb24gZnVsZmlsbFJlYWRRdWV1ZSgpIHtcbiAgICAgICAgd2hpbGUgKHJlYWRRdWV1ZS5sZW5ndGggPiAwICYmIHJlc3VsdFF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcmVzb2x2ZSB9ID0gcmVhZFF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHJlc3VsdFF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICByZXNvbHZlKHsgZG9uZTogZmFsc2UsIHZhbHVlIH0pO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChyZWFkUXVldWUubGVuZ3RoID4gMCAmJiBpbmZsaWdodENvdW50ID09PSAwICYmIGVuZGVkKSB7XG4gICAgICAgICAgICBjb25zdCB7IHJlc29sdmUsIHJlamVjdCB9ID0gcmVhZFF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICBpZiAobGFzdEVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGxhc3RFcnJvcik7XG4gICAgICAgICAgICAgICAgbGFzdEVycm9yID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoeyBkb25lOiB0cnVlLCB2YWx1ZTogdW5kZWZpbmVkIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGZ1bmN0aW9uIGZpbGxRdWV1ZSgpIHtcbiAgICAgICAgaWYgKGVuZGVkKSB7XG4gICAgICAgICAgICBmdWxmaWxsUmVhZFF1ZXVlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlYWRpbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5mbGlnaHRDb3VudCArIHJlc3VsdFF1ZXVlLmxlbmd0aCA+PSBjb25jdXJyZW5jeSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJlYWRpbmcgPSB0cnVlO1xuICAgICAgICBpbmZsaWdodENvdW50Kys7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgIGVuZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpbmZsaWdodENvdW50LS07XG4gICAgICAgICAgICAgICAgZnVsZmlsbFJlYWRRdWV1ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbWFwQW5kUXVldWUodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgZW5kZWQgPSB0cnVlO1xuICAgICAgICAgICAgaW5mbGlnaHRDb3VudC0tO1xuICAgICAgICAgICAgbGFzdEVycm9yID0gZXJyb3I7XG4gICAgICAgICAgICBmdWxmaWxsUmVhZFF1ZXVlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVhZGluZyA9IGZhbHNlO1xuICAgICAgICBmaWxsUXVldWUoKTtcbiAgICB9XG4gICAgYXN5bmMgZnVuY3Rpb24gbWFwQW5kUXVldWUoaXRyVmFsdWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgZnVuYyhpdHJWYWx1ZSk7XG4gICAgICAgICAgICByZXN1bHRRdWV1ZS5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGVuZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGxhc3RFcnJvciA9IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGluZmxpZ2h0Q291bnQtLTtcbiAgICAgICAgZnVsZmlsbFJlYWRRdWV1ZSgpO1xuICAgICAgICBmaWxsUXVldWUoKTtcbiAgICB9XG4gICAgYXN5bmMgZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgaWYgKHJlc3VsdFF1ZXVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgY29uc3QgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgICAgICAgICAgcmVhZFF1ZXVlLnB1c2goZGVmZXJyZWQpO1xuICAgICAgICAgICAgZmlsbFF1ZXVlKCk7XG4gICAgICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWx1ZSA9IHJlc3VsdFF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgIGZpbGxRdWV1ZSgpO1xuICAgICAgICByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWUgfTtcbiAgICB9XG4gICAgY29uc3QgYXN5bmNJdGVyYWJsZUl0ZXJhdG9yID0ge1xuICAgICAgICBuZXh0LFxuICAgICAgICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdOiAoKSA9PiBhc3luY0l0ZXJhYmxlSXRlcmF0b3IsXG4gICAgfTtcbiAgICByZXR1cm4gYXN5bmNJdGVyYWJsZUl0ZXJhdG9yO1xufVxuZnVuY3Rpb24gdHJhbnNmb3JtKGNvbmN1cnJlbmN5LCBmdW5jLCBpdGVyYWJsZSkge1xuICAgIGlmIChmdW5jID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIChjdXJyaWVkRnVuYywgY3VycmllZEl0ZXJhYmxlKSA9PiBjdXJyaWVkSXRlcmFibGVcbiAgICAgICAgICAgID8gdHJhbnNmb3JtKGNvbmN1cnJlbmN5LCBjdXJyaWVkRnVuYywgY3VycmllZEl0ZXJhYmxlKVxuICAgICAgICAgICAgOiB0cmFuc2Zvcm0oY29uY3VycmVuY3ksIGN1cnJpZWRGdW5jKTtcbiAgICB9XG4gICAgaWYgKGl0ZXJhYmxlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIChjdXJyaWVkSXRlcmFibGUpID0+IHRyYW5zZm9ybShjb25jdXJyZW5jeSwgZnVuYywgY3VycmllZEl0ZXJhYmxlKTtcbiAgICB9XG4gICAgcmV0dXJuIF90cmFuc2Zvcm0oY29uY3VycmVuY3ksIGZ1bmMsIGl0ZXJhYmxlKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gX3dyaXRlVG9TdHJlYW0oc3RyZWFtLCBpdGVyYWJsZSkge1xuICAgIGxldCBsYXN0RXJyb3IgPSBudWxsO1xuICAgIGxldCBlcnJDYiA9IG51bGw7XG4gICAgbGV0IGRyYWluQ2IgPSBudWxsO1xuICAgIGNvbnN0IG5vdGlmeUVycm9yID0gZXJyID0+IHtcbiAgICAgICAgbGFzdEVycm9yID0gZXJyO1xuICAgICAgICBpZiAoZXJyQ2IpIHtcbiAgICAgICAgICAgIGVyckNiKGVycik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IG5vdGlmeURyYWluID0gKCkgPT4ge1xuICAgICAgICBpZiAoZHJhaW5DYikge1xuICAgICAgICAgICAgZHJhaW5DYigpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBjbGVhbnVwID0gKCkgPT4ge1xuICAgICAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgbm90aWZ5RXJyb3IpO1xuICAgICAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgbm90aWZ5RHJhaW4pO1xuICAgIH07XG4gICAgc3RyZWFtLm9uY2UoJ2Vycm9yJywgbm90aWZ5RXJyb3IpO1xuICAgIGNvbnN0IHdhaXRGb3JEcmFpbiA9ICgpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgaWYgKGxhc3RFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIHJlamVjdChsYXN0RXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHN0cmVhbS5vbmNlKCdkcmFpbicsIG5vdGlmeURyYWluKTtcbiAgICAgICAgZHJhaW5DYiA9IHJlc29sdmU7XG4gICAgICAgIGVyckNiID0gcmVqZWN0O1xuICAgIH0pO1xuICAgIGZvciBhd2FpdCAoY29uc3QgdmFsdWUgb2YgaXRlcmFibGUpIHtcbiAgICAgICAgaWYgKHN0cmVhbS53cml0ZSh2YWx1ZSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBhd2FpdCB3YWl0Rm9yRHJhaW4oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGFzdEVycm9yKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBjbGVhbnVwKCk7XG4gICAgaWYgKGxhc3RFcnJvcikge1xuICAgICAgICB0aHJvdyBsYXN0RXJyb3I7XG4gICAgfVxufVxuZnVuY3Rpb24gd3JpdGVUb1N0cmVhbShzdHJlYW0sIGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIChjdXJyaWVkSXRlcmFibGUpID0+IF93cml0ZVRvU3RyZWFtKHN0cmVhbSwgY3VycmllZEl0ZXJhYmxlKTtcbiAgICB9XG4gICAgcmV0dXJuIF93cml0ZVRvU3RyZWFtKHN0cmVhbSwgaXRlcmFibGUpO1xufVxuXG5leHBvcnQgeyBiYXRjaCwgYmF0Y2hXaXRoVGltZW91dCwgYnVmZmVyLCBjb2xsZWN0LCBjb25jYXQsIGNvbnN1bWUsIGZpbHRlciwgZmxhdE1hcCwgZmxhdFRyYW5zZm9ybSwgZmxhdHRlbiwgZnJvbVN0cmVhbSwgZ2V0SXRlcmF0b3IsIG1hcCwgbWVyZ2UsIHBhcmFsbGVsRmxhdE1hcCwgcGFyYWxsZWxNYXAsIHBhcmFsbGVsTWVyZ2UsIHBpcGVsaW5lLCByZWR1Y2UsIHRha2UsIHRhcCwgdGhyb3R0bGUsIHRpbWUsIHRyYW5zZm9ybSwgd3JpdGVUb1N0cmVhbSB9O1xuIiwgIi8qKlxuICogQSBjbGllbnQgbGlicmFyeSBmb3IgdGhlIGh0dHBzOi8vbmZ0LnN0b3JhZ2UvIHNlcnZpY2UuIEl0IHByb3ZpZGVzIGEgY29udmVuaWVudFxuICogaW50ZXJmYWNlIGZvciB3b3JraW5nIHdpdGggdGhlIFtSYXcgSFRUUCBBUEldKGh0dHBzOi8vbmZ0LnN0b3JhZ2UvI2FwaS1kb2NzKVxuICogZnJvbSBhIHdlYiBicm93c2VyIG9yIFtOb2RlLmpzXShodHRwczovL25vZGVqcy5vcmcvKSBhbmQgY29tZXMgYnVuZGxlZCB3aXRoXG4gKiBUUyBmb3Igb3V0LW9mLXRoZSBib3ggdHlwZSBpbmZlcmVuY2UgYW5kIGJldHRlciBJbnRlbGxpU2Vuc2UuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiBpbXBvcnQgeyBORlRTdG9yYWdlLCBGaWxlLCBCbG9iIH0gZnJvbSBcIm5mdC5zdG9yYWdlXCJcbiAqIGNvbnN0IGNsaWVudCA9IG5ldyBORlRTdG9yYWdlKHsgdG9rZW46IEFQSV9UT0tFTiB9KVxuICpcbiAqIGNvbnN0IGNpZCA9IGF3YWl0IGNsaWVudC5zdG9yZUJsb2IobmV3IEJsb2IoWydoZWxsbyB3b3JsZCddKSlcbiAqIGBgYFxuICogQG1vZHVsZVxuICovXG5cbmltcG9ydCB7IHRyYW5zZm9ybSB9IGZyb20gJ3N0cmVhbWluZy1pdGVyYWJsZXMnXG5pbXBvcnQgcFJldHJ5LCB7IEFib3J0RXJyb3IgfSBmcm9tICdwLXJldHJ5J1xuaW1wb3J0IHsgVHJlZXdhbGtDYXJTcGxpdHRlciB9IGZyb20gJ2NhcmJpdGVzL3RyZWV3YWxrJ1xuaW1wb3J0IHsgcGFjayB9IGZyb20gJ2lwZnMtY2FyL3BhY2snXG5pbXBvcnQgeyBDSUQgfSBmcm9tICdtdWx0aWZvcm1hdHMvY2lkJ1xuaW1wb3J0IHRocm90dGxlZFF1ZXVlIGZyb20gJ3Rocm90dGxlZC1xdWV1ZSdcbmltcG9ydCAqIGFzIFRva2VuIGZyb20gJy4vdG9rZW4uanMnXG5pbXBvcnQgeyBmZXRjaCwgRmlsZSwgQmxvYiwgRm9ybURhdGEsIEJsb2Nrc3RvcmUgfSBmcm9tICcuL3BsYXRmb3JtLmpzJ1xuaW1wb3J0IHsgdG9HYXRld2F5VVJMIH0gZnJvbSAnLi9nYXRld2F5LmpzJ1xuaW1wb3J0IHsgQmxvY2tzdG9yZUNhclJlYWRlciB9IGZyb20gJy4vYnMtY2FyLXJlYWRlci5qcydcbmltcG9ydCBwaXBlIGZyb20gJ2l0LXBpcGUnXG5cbmNvbnN0IE1BWF9TVE9SRV9SRVRSSUVTID0gNVxuY29uc3QgTUFYX0NPTkNVUlJFTlRfVVBMT0FEUyA9IDNcbmNvbnN0IE1BWF9DSFVOS19TSVpFID0gMTAyNCAqIDEwMjQgKiA1MCAvLyBjaHVuayB0byB+NTBNQiBDQVJzXG5jb25zdCBSQVRFX0xJTUlUX1JFUVVFU1RTID0gMzBcbmNvbnN0IFJBVEVfTElNSVRfUEVSSU9EID0gMTAgKiAxMDAwXG5cbi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnLi9saWIvaW50ZXJmYWNlLmpzJykuU2VydmljZX0gU2VydmljZVxuICogQHR5cGVkZWYge2ltcG9ydCgnLi9saWIvaW50ZXJmYWNlLmpzJykuQ0lEU3RyaW5nfSBDSURTdHJpbmdcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4vbGliL2ludGVyZmFjZS5qcycpLkRlYWx9IERlYWxcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4vbGliL2ludGVyZmFjZS5qcycpLkZpbGVPYmplY3R9IEZpbGVPYmplY3RcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4vbGliL2ludGVyZmFjZS5qcycpLkZpbGVzU291cmNlfSBGaWxlc1NvdXJjZVxuICogQHR5cGVkZWYge2ltcG9ydCgnLi9saWIvaW50ZXJmYWNlLmpzJykuUGlufSBQaW5cbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4vbGliL2ludGVyZmFjZS5qcycpLkNhclJlYWRlcn0gQ2FyUmVhZGVyXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdpcGZzLWNhci9ibG9ja3N0b3JlJykuQmxvY2tzdG9yZX0gQmxvY2tzdG9yZUlcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4vbGliL2ludGVyZmFjZS5qcycpLlJhdGVMaW1pdGVyfSBSYXRlTGltaXRlclxuICogQHR5cGVkZWYge2ltcG9ydCgnLi9saWIvaW50ZXJmYWNlLmpzJykuUmVxdWVzdE9wdGlvbnN9IFJlcXVlc3RPcHRpb25zXG4gKi9cblxuLyoqXG4gKiBAcmV0dXJucyB7UmF0ZUxpbWl0ZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVSYXRlTGltaXRlcigpIHtcbiAgY29uc3QgdGhyb3R0bGUgPSB0aHJvdHRsZWRRdWV1ZShSQVRFX0xJTUlUX1JFUVVFU1RTLCBSQVRFX0xJTUlUX1BFUklPRClcbiAgcmV0dXJuICgpID0+IHRocm90dGxlKCgpID0+IHt9KVxufVxuXG4vKipcbiAqIFJhdGUgbGltaXRlciB1c2VkIGJ5IHN0YXRpYyBBUEkgaWYgbm8gcmF0ZSBsaW1pdGVyIGlzIHBhc3NlZC4gTm90ZSB0aGF0IGVhY2hcbiAqIGluc3RhbmNlIG9mIHRoZSBORlRTdG9yYWdlIGNsYXNzIGdldHMgaXQncyBvd24gbGltaXRlciBpZiBub25lIGlzIHBhc3NlZC5cbiAqIFRoaXMgaXMgYmVjYXVzZSByYXRlIGxpbWl0cyBhcmUgZW5mb3JjZWQgcGVyIEFQSSB0b2tlbi5cbiAqL1xuY29uc3QgZ2xvYmFsUmF0ZUxpbWl0ZXIgPSBjcmVhdGVSYXRlTGltaXRlcigpXG5cbi8qKlxuICogQHRlbXBsYXRlIHtpbXBvcnQoJy4vbGliL2ludGVyZmFjZS5qcycpLlRva2VuSW5wdXR9IFRcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4vbGliL2ludGVyZmFjZS5qcycpLlRva2VuPFQ+fSBUb2tlblR5cGVcbiAqL1xuXG4vKipcbiAqIEBpbXBsZW1lbnRzIHtTZXJ2aWNlfVxuICovXG5jbGFzcyBORlRTdG9yYWdlIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBjbGllbnQgYm91bmQgdG8gdGhlIGdpdmVuIGBvcHRpb25zLnRva2VuYCBhbmRcbiAgICogYG9wdGlvbnMuZW5kcG9pbnRgLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiBpbXBvcnQgeyBORlRTdG9yYWdlLCBGaWxlLCBCbG9iIH0gZnJvbSBcIm5mdC5zdG9yYWdlXCJcbiAgICogY29uc3QgY2xpZW50ID0gbmV3IE5GVFN0b3JhZ2UoeyB0b2tlbjogQVBJX1RPS0VOIH0pXG4gICAqXG4gICAqIGNvbnN0IGNpZCA9IGF3YWl0IGNsaWVudC5zdG9yZUJsb2IobmV3IEJsb2IoWydoZWxsbyB3b3JsZCddKSlcbiAgICogYGBgXG4gICAqIE9wdGlvbmFsbHkgeW91IGNvdWxkIHBhc3MgYW4gYWx0ZXJuYXRpdmUgQVBJIGVuZHBvaW50IChlLmcuIGZvciB0ZXN0aW5nKVxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiBpbXBvcnQgeyBORlRTdG9yYWdlIH0gZnJvbSBcIm5mdC5zdG9yYWdlXCJcbiAgICogY29uc3QgY2xpZW50ID0gbmV3IE5GVFN0b3JhZ2Uoe1xuICAgKiAgIHRva2VuOiBBUElfVE9LRU5cbiAgICogICBlbmRwb2ludDogbmV3IFVSTCgnaHR0cDovL2xvY2FsaG9zdDo4MDgwLycpXG4gICAqIH0pXG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0ge3t0b2tlbjogc3RyaW5nLCBlbmRwb2ludD86IFVSTCwgcmF0ZUxpbWl0ZXI/OiBSYXRlTGltaXRlciwgZGlkPzogc3RyaW5nfX0gb3B0aW9uc1xuICAgKi9cbiAgY29uc3RydWN0b3Ioe1xuICAgIHRva2VuLFxuICAgIGRpZCxcbiAgICBlbmRwb2ludCA9IG5ldyBVUkwoJ2h0dHBzOi8vYXBpLm5mdC5zdG9yYWdlJyksXG4gICAgcmF0ZUxpbWl0ZXIsXG4gIH0pIHtcbiAgICAvKipcbiAgICAgKiBBdXRob3JpemF0aW9uIHRva2VuLlxuICAgICAqXG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG4gICAgdGhpcy50b2tlbiA9IHRva2VuXG4gICAgLyoqXG4gICAgICogU2VydmljZSBBUEkgZW5kcG9pbnQgYFVSTGAuXG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG4gICAgdGhpcy5lbmRwb2ludCA9IGVuZHBvaW50XG4gICAgLyoqXG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG4gICAgdGhpcy5yYXRlTGltaXRlciA9IHJhdGVMaW1pdGVyIHx8IGNyZWF0ZVJhdGVMaW1pdGVyKClcblxuICAgIC8qKlxuICAgICAqIEByZWFkb25seVxuICAgICAqL1xuICAgIHRoaXMuZGlkID0gZGlkXG4gIH1cblxuICAvKipcbiAgICogQGhpZGRlblxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy50b2tlblxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZGlkXVxuICAgKi9cbiAgc3RhdGljIGF1dGgoeyB0b2tlbiwgZGlkIH0pIHtcbiAgICBpZiAoIXRva2VuKSB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgdG9rZW4nKVxuICAgIHJldHVybiB7XG4gICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dG9rZW59YCxcbiAgICAgICdYLUNsaWVudCc6ICduZnQuc3RvcmFnZS9qcycsXG4gICAgICAuLi4oZGlkID8geyAneC1hZ2VudC1kaWQnOiBkaWQgfSA6IHt9KSxcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3RvcmVzIGEgc2luZ2xlIGZpbGUgYW5kIHJldHVybnMgaXRzIENJRC5cbiAgICpcbiAgICogQHBhcmFtIHtTZXJ2aWNlfSBzZXJ2aWNlXG4gICAqIEBwYXJhbSB7QmxvYn0gYmxvYlxuICAgKiBAcGFyYW0ge1JlcXVlc3RPcHRpb25zfSBbb3B0aW9uc11cbiAgICogQHJldHVybnMge1Byb21pc2U8Q0lEU3RyaW5nPn1cbiAgICovXG4gIHN0YXRpYyBhc3luYyBzdG9yZUJsb2Ioc2VydmljZSwgYmxvYiwgb3B0aW9ucykge1xuICAgIGNvbnN0IGJsb2Nrc3RvcmUgPSBuZXcgQmxvY2tzdG9yZSgpXG4gICAgbGV0IGNpZFN0cmluZ1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgY2lkLCBjYXIgfSA9IGF3YWl0IE5GVFN0b3JhZ2UuZW5jb2RlQmxvYihibG9iLCB7IGJsb2Nrc3RvcmUgfSlcbiAgICAgIGF3YWl0IE5GVFN0b3JhZ2Uuc3RvcmVDYXIoc2VydmljZSwgY2FyLCBvcHRpb25zKVxuICAgICAgY2lkU3RyaW5nID0gY2lkLnRvU3RyaW5nKClcbiAgICB9IGZpbmFsbHkge1xuICAgICAgYXdhaXQgYmxvY2tzdG9yZS5jbG9zZSgpXG4gICAgfVxuXG4gICAgcmV0dXJuIGNpZFN0cmluZ1xuICB9XG5cbiAgLyoqXG4gICAqIFN0b3JlcyBhIENBUiBmaWxlIGFuZCByZXR1cm5zIGl0cyByb290IENJRC5cbiAgICpcbiAgICogQHBhcmFtIHtTZXJ2aWNlfSBzZXJ2aWNlXG4gICAqIEBwYXJhbSB7QmxvYnxDYXJSZWFkZXJ9IGNhclxuICAgKiBAcGFyYW0ge2ltcG9ydCgnLi9saWIvaW50ZXJmYWNlLmpzJykuQ2FyU3RvcmVyT3B0aW9uc30gW29wdGlvbnNdXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPENJRFN0cmluZz59XG4gICAqL1xuICBzdGF0aWMgYXN5bmMgc3RvcmVDYXIoXG4gICAgeyBlbmRwb2ludCwgcmF0ZUxpbWl0ZXIgPSBnbG9iYWxSYXRlTGltaXRlciwgLi4udG9rZW4gfSxcbiAgICBjYXIsXG4gICAgeyBvblN0b3JlZENodW5rLCBtYXhSZXRyaWVzLCBtYXhDaHVua1NpemUsIGRlY29kZXJzLCBzaWduYWwgfSA9IHt9XG4gICkge1xuICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoJ3VwbG9hZC8nLCBlbmRwb2ludClcbiAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgLi4uTkZUU3RvcmFnZS5hdXRoKHRva2VuKSxcbiAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vY2FyJyxcbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0U2l6ZSA9IG1heENodW5rU2l6ZSB8fCBNQVhfQ0hVTktfU0laRVxuICAgIGNvbnN0IHNwbGl0dGVyID1cbiAgICAgIGNhciBpbnN0YW5jZW9mIEJsb2JcbiAgICAgICAgPyBhd2FpdCBUcmVld2Fsa0NhclNwbGl0dGVyLmZyb21CbG9iKGNhciwgdGFyZ2V0U2l6ZSwgeyBkZWNvZGVycyB9KVxuICAgICAgICA6IG5ldyBUcmVld2Fsa0NhclNwbGl0dGVyKGNhciwgdGFyZ2V0U2l6ZSwgeyBkZWNvZGVycyB9KVxuXG4gICAgY29uc3QgdXBsb2FkID0gdHJhbnNmb3JtKFxuICAgICAgTUFYX0NPTkNVUlJFTlRfVVBMT0FEUyxcbiAgICAgIGFzeW5jIGZ1bmN0aW9uICgvKiogQHR5cGUge0FzeW5jSXRlcmFibGU8VWludDhBcnJheT59ICovIGNhcikge1xuICAgICAgICBjb25zdCBjYXJQYXJ0cyA9IFtdXG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgcGFydCBvZiBjYXIpIHtcbiAgICAgICAgICBjYXJQYXJ0cy5wdXNoKHBhcnQpXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2FyRmlsZSA9IG5ldyBCbG9iKGNhclBhcnRzLCB7IHR5cGU6ICdhcHBsaWNhdGlvbi9jYXInIH0pXG4gICAgICAgIC8qKiBAdHlwZSB7QmxvYnxBcnJheUJ1ZmZlcn0gKi9cbiAgICAgICAgbGV0IGJvZHkgPSBjYXJGaWxlXG4gICAgICAgIC8vIEZJWE1FOiBzaG91bGQgbm90IGJlIG5lY2Vzc2FyeSB0byBhd2FpdCBhcnJheUJ1ZmZlcigpIVxuICAgICAgICAvLyBOb2RlLmpzIDIwIGhhbmdzIHJlYWRpbmcgdGhlIHN0cmVhbSAoaXQgbmV2ZXIgZW5kcykgYnV0IGluXG4gICAgICAgIC8vIG9sZGVyIG5vZGUgdmVyc2lvbnMgYW5kIHRoZSBicm93c2VyIGl0IGlzIGZpbmUgdG8gcGFzcyBhIGJsb2IuXG4gICAgICAgIC8qIGM4IGlnbm9yZSBuZXh0IDMgKi9cbiAgICAgICAgaWYgKHBhcnNlSW50KGdsb2JhbFRoaXMucHJvY2Vzcz8udmVyc2lvbnM/Lm5vZGUpID4gMTgpIHtcbiAgICAgICAgICBib2R5ID0gYXdhaXQgYm9keS5hcnJheUJ1ZmZlcigpXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2lkID0gYXdhaXQgcFJldHJ5KFxuICAgICAgICAgIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGF3YWl0IHJhdGVMaW1pdGVyKClcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7UmVzcG9uc2V9ICovXG4gICAgICAgICAgICBsZXQgcmVzcG9uc2VcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLnRvU3RyaW5nKCksIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICAgICAgc2lnbmFsLFxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSBjYXRjaCAoLyoqIEB0eXBlIHthbnl9ICovIGVycikge1xuICAgICAgICAgICAgICAvLyBUT0RPOiByZW1vdmUgbWUgYW5kIHRlc3Qgd2hlbiBjbGllbnQgYWNjZXB0cyBjdXN0b20gZmV0Y2ggaW1wbFxuICAgICAgICAgICAgICAvKiBjOCBpZ25vcmUgbmV4dCAxICovXG4gICAgICAgICAgICAgIHRocm93IHNpZ25hbCAmJiBzaWduYWwuYWJvcnRlZCA/IG5ldyBBYm9ydEVycm9yKGVycikgOiBlcnJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBuZXh0IDMgKi9cbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQyOSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JhdGUgbGltaXRlZCcpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKClcbiAgICAgICAgICAgIGlmICghcmVzdWx0Lm9rKSB7XG4gICAgICAgICAgICAgIC8vIGRvIG5vdCByZXRyeSBpZiB1bmF1dGhvcml6ZWQgLSB3aWxsIG5vdCBzdWNjZWVkXG4gICAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwMSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBYm9ydEVycm9yKHJlc3VsdC5lcnJvci5tZXNzYWdlKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihyZXN1bHQuZXJyb3IubWVzc2FnZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQudmFsdWUuY2lkXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICByZXRyaWVzOiBtYXhSZXRyaWVzID09IG51bGwgPyBNQVhfU1RPUkVfUkVUUklFUyA6IG1heFJldHJpZXMsXG4gICAgICAgICAgfVxuICAgICAgICApXG4gICAgICAgIG9uU3RvcmVkQ2h1bmsgJiYgb25TdG9yZWRDaHVuayhjYXJGaWxlLnNpemUpXG4gICAgICAgIHJldHVybiBjaWRcbiAgICAgIH1cbiAgICApXG5cbiAgICBsZXQgcm9vdFxuICAgIGZvciBhd2FpdCAoY29uc3QgY2lkIG9mIHVwbG9hZChzcGxpdHRlci5jYXJzKCkpKSB7XG4gICAgICByb290ID0gY2lkXG4gICAgfVxuXG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7Q0lEU3RyaW5nfSAqLyAocm9vdClcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9yZXMgYSBkaXJlY3Rvcnkgb2YgZmlsZXMgYW5kIHJldHVybnMgYSBDSUQuIFByb3ZpZGVkIGZpbGVzICoqTVVTVCoqXG4gICAqIGJlIHdpdGhpbiB0aGUgc2FtZSBkaXJlY3RvcnksIG90aGVyd2lzZSBlcnJvciBpcyByYWlzZWQgZS5nLiBgZm9vL2Jhci5wbmdgLFxuICAgKiBgZm9vL2JsYS9iYXouanNvbmAgaXMgb2sgYnV0IGBmb28vYmFyLnBuZ2AsIGBibGEvYmF6Lmpzb25gIGlzIG5vdC5cbiAgICpcbiAgICogQHBhcmFtIHtTZXJ2aWNlfSBzZXJ2aWNlXG4gICAqIEBwYXJhbSB7RmlsZXNTb3VyY2V9IGZpbGVzU291cmNlXG4gICAqIEBwYXJhbSB7UmVxdWVzdE9wdGlvbnN9IFtvcHRpb25zXVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDSURTdHJpbmc+fVxuICAgKi9cbiAgc3RhdGljIGFzeW5jIHN0b3JlRGlyZWN0b3J5KHNlcnZpY2UsIGZpbGVzU291cmNlLCBvcHRpb25zKSB7XG4gICAgY29uc3QgYmxvY2tzdG9yZSA9IG5ldyBCbG9ja3N0b3JlKClcbiAgICBsZXQgY2lkU3RyaW5nXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgY2lkLCBjYXIgfSA9IGF3YWl0IE5GVFN0b3JhZ2UuZW5jb2RlRGlyZWN0b3J5KGZpbGVzU291cmNlLCB7XG4gICAgICAgIGJsb2Nrc3RvcmUsXG4gICAgICB9KVxuICAgICAgYXdhaXQgTkZUU3RvcmFnZS5zdG9yZUNhcihzZXJ2aWNlLCBjYXIsIG9wdGlvbnMpXG4gICAgICBjaWRTdHJpbmcgPSBjaWQudG9TdHJpbmcoKVxuICAgIH0gZmluYWxseSB7XG4gICAgICBhd2FpdCBibG9ja3N0b3JlLmNsb3NlKClcbiAgICB9XG5cbiAgICByZXR1cm4gY2lkU3RyaW5nXG4gIH1cblxuICAvKipcbiAgICogU3RvcmVzIHRoZSBnaXZlbiB0b2tlbiBhbmQgYWxsIHJlc291cmNlcyBpdCByZWZlcmVuY2VzIChpbiB0aGUgZm9ybSBvZiBhXG4gICAqIEZpbGUgb3IgYSBCbG9iKSBhbG9uZyB3aXRoIGEgbWV0YWRhdGEgSlNPTiBhcyBzcGVjaWZpY2VkIGluIEVSQy0xMTU1LiBUaGVcbiAgICogYHRva2VuLmltYWdlYCBtdXN0IGJlIGVpdGhlciBhIGBGaWxlYCBvciBhIGBCbG9iYCBpbnN0YW5jZSwgd2hpY2ggd2lsbCBiZVxuICAgKiBzdG9yZWQgYW5kIHRoZSBjb3JyZXNwb25kaW5nIGNvbnRlbnQgYWRkcmVzcyBVUkwgd2lsbCBiZSBzYXZlZCBpbiB0aGVcbiAgICogbWV0YWRhdGEgSlNPTiBmaWxlIHVuZGVyIGBpbWFnZWAgZmllbGQuXG4gICAqXG4gICAqIElmIGB0b2tlbi5wcm9wZXJ0aWVzYCBjb250YWlucyBwcm9wZXJ0aWVzIHdpdGggYEZpbGVgIG9yIGBCbG9iYCB2YWx1ZXMsXG4gICAqIHRob3NlIGFsc28gZ2V0IHN0b3JlZCBhbmQgdGhlaXIgVVJMcyB3aWxsIGJlIHNhdmVkIGluIHRoZSBtZXRhZGF0YSBKU09OXG4gICAqIGZpbGUgaW4gdGhlaXIgcGxhY2UuXG4gICAqXG4gICAqIE5vdGU6IFVSTHMgZm9yIGBGaWxlYCBvYmplY3RzIHdpbGwgcmV0YWluIGZpbGUgbmFtZXMgZS5nLiBpbiBjYXNlIG9mXG4gICAqIGBuZXcgRmlsZShbYnl0ZXNdLCAnY2F0LnBuZycsIHsgdHlwZTogJ2ltYWdlL3BuZycgfSlgIHdpbGwgYmUgdHJhbnNmb3JtZWRcbiAgICogaW50byBhIFVSTCB0aGF0IGxvb2tzIGxpa2UgYGlwZnM6Ly9iYWZ5Li4uaGFzaC9pbWFnZS9jYXQucG5nYC4gRm9yIGBCbG9iYFxuICAgKiBvYmplY3RzLCB0aGUgVVJMIHdpbGwgbm90IGhhdmUgYSBmaWxlIG5hbWUgbmFtZSBvciBtaW1lIHR5cGUsIGluc3RlYWQgaXRcbiAgICogd2lsbCBiZSB0cmFuc2Zvcm1lZCBpbnRvIGEgVVJMIHRoYXQgbG9va3MgbGlrZVxuICAgKiBgaXBmczovL2JhZnkuLi5oYXNoL2ltYWdlL2Jsb2JgLlxuICAgKlxuICAgKiBAdGVtcGxhdGUge2ltcG9ydCgnLi9saWIvaW50ZXJmYWNlLmpzJykuVG9rZW5JbnB1dH0gVFxuICAgKiBAcGFyYW0ge1NlcnZpY2V9IHNlcnZpY2VcbiAgICogQHBhcmFtIHtUfSBtZXRhZGF0YVxuICAgKiBAcGFyYW0ge1JlcXVlc3RPcHRpb25zfSBbb3B0aW9uc11cbiAgICogQHJldHVybnMge1Byb21pc2U8VG9rZW5UeXBlPFQ+Pn1cbiAgICovXG4gIHN0YXRpYyBhc3luYyBzdG9yZShzZXJ2aWNlLCBtZXRhZGF0YSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgdG9rZW4sIGNhciB9ID0gYXdhaXQgTkZUU3RvcmFnZS5lbmNvZGVORlQobWV0YWRhdGEpXG4gICAgYXdhaXQgTkZUU3RvcmFnZS5zdG9yZUNhcihzZXJ2aWNlLCBjYXIsIG9wdGlvbnMpXG4gICAgcmV0dXJuIHRva2VuXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBjdXJyZW50IHN0YXR1cyBvZiB0aGUgc3RvcmVkIE5GVCBieSBpdHMgQ0lELiBOb3RlIHRoZSBORlQgbXVzdFxuICAgKiBoYXZlIHByZXZpb3VzbHkgYmVlbiBzdG9yZWQgYnkgdGhpcyBhY2NvdW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1NlcnZpY2V9IHNlcnZpY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNpZFxuICAgKiBAcGFyYW0ge1JlcXVlc3RPcHRpb25zfSBbb3B0aW9uc11cbiAgICogQHJldHVybnMge1Byb21pc2U8aW1wb3J0KCcuL2xpYi9pbnRlcmZhY2UuanMnKS5TdGF0dXNSZXN1bHQ+fVxuICAgKi9cbiAgc3RhdGljIGFzeW5jIHN0YXR1cyhcbiAgICB7IGVuZHBvaW50LCByYXRlTGltaXRlciA9IGdsb2JhbFJhdGVMaW1pdGVyLCAuLi50b2tlbiB9LFxuICAgIGNpZCxcbiAgICBvcHRpb25zXG4gICkge1xuICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoYCR7Y2lkfS9gLCBlbmRwb2ludClcbiAgICBhd2FpdCByYXRlTGltaXRlcigpXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwudG9TdHJpbmcoKSwge1xuICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgIGhlYWRlcnM6IE5GVFN0b3JhZ2UuYXV0aCh0b2tlbiksXG4gICAgICBzaWduYWw6IG9wdGlvbnMgJiYgb3B0aW9ucy5zaWduYWwsXG4gICAgfSlcbiAgICAvKiBjOCBpZ25vcmUgbmV4dCAzICovXG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDI5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JhdGUgbGltaXRlZCcpXG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKVxuXG4gICAgaWYgKHJlc3VsdC5vaykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY2lkOiByZXN1bHQudmFsdWUuY2lkLFxuICAgICAgICBkZWFsczogZGVjb2RlRGVhbHMocmVzdWx0LnZhbHVlLmRlYWxzKSxcbiAgICAgICAgc2l6ZTogcmVzdWx0LnZhbHVlLnNpemUsXG4gICAgICAgIHBpbjogZGVjb2RlUGluKHJlc3VsdC52YWx1ZS5waW4pLFxuICAgICAgICBjcmVhdGVkOiBuZXcgRGF0ZShyZXN1bHQudmFsdWUuY3JlYXRlZCksXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihyZXN1bHQuZXJyb3IubWVzc2FnZSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSBDSUQgb2YgYW4gTkZUIGlzIGJlaW5nIHN0b3JlZCBieSBORlQuU3RvcmFnZS5cbiAgICpcbiAgICogQHBhcmFtIHtpbXBvcnQoJy4vbGliL2ludGVyZmFjZS5qcycpLlB1YmxpY1NlcnZpY2V9IHNlcnZpY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNpZFxuICAgKiBAcGFyYW0ge1JlcXVlc3RPcHRpb25zfSBbb3B0aW9uc11cbiAgICogQHJldHVybnMge1Byb21pc2U8aW1wb3J0KCcuL2xpYi9pbnRlcmZhY2UuanMnKS5DaGVja1Jlc3VsdD59XG4gICAqL1xuICBzdGF0aWMgYXN5bmMgY2hlY2soXG4gICAgeyBlbmRwb2ludCwgcmF0ZUxpbWl0ZXIgPSBnbG9iYWxSYXRlTGltaXRlciB9LFxuICAgIGNpZCxcbiAgICBvcHRpb25zXG4gICkge1xuICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoYGNoZWNrLyR7Y2lkfS9gLCBlbmRwb2ludClcbiAgICBhd2FpdCByYXRlTGltaXRlcigpXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwudG9TdHJpbmcoKSwge1xuICAgICAgc2lnbmFsOiBvcHRpb25zICYmIG9wdGlvbnMuc2lnbmFsLFxuICAgIH0pXG4gICAgLyogYzggaWdub3JlIG5leHQgMyAqL1xuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQyOSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdyYXRlIGxpbWl0ZWQnKVxuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKClcblxuICAgIGlmIChyZXN1bHQub2spIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNpZDogcmVzdWx0LnZhbHVlLmNpZCxcbiAgICAgICAgZGVhbHM6IGRlY29kZURlYWxzKHJlc3VsdC52YWx1ZS5kZWFscyksXG4gICAgICAgIHBpbjogcmVzdWx0LnZhbHVlLnBpbixcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHJlc3VsdC5lcnJvci5tZXNzYWdlKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIHN0b3JlZCBjb250ZW50IGJ5IGl0cyBDSUQgZnJvbSB0aGlzIGFjY291bnQuIFBsZWFzZSBub3RlIHRoYXRcbiAgICogZXZlbiBpZiBjb250ZW50IGlzIHJlbW92ZWQgZnJvbSB0aGUgc2VydmljZSBvdGhlciBub2RlcyB0aGF0IGhhdmVcbiAgICogcmVwbGljYXRlZCBpdCBtaWdodCBzdGlsbCBjb250aW51ZSBwcm92aWRpbmcgaXQuXG4gICAqXG4gICAqIEBwYXJhbSB7U2VydmljZX0gc2VydmljZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2lkXG4gICAqIEBwYXJhbSB7UmVxdWVzdE9wdGlvbnN9IFtvcHRpb25zXVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICovXG4gIHN0YXRpYyBhc3luYyBkZWxldGUoXG4gICAgeyBlbmRwb2ludCwgcmF0ZUxpbWl0ZXIgPSBnbG9iYWxSYXRlTGltaXRlciwgLi4udG9rZW4gfSxcbiAgICBjaWQsXG4gICAgb3B0aW9uc1xuICApIHtcbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKGAke2NpZH0vYCwgZW5kcG9pbnQpXG4gICAgYXdhaXQgcmF0ZUxpbWl0ZXIoKVxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLnRvU3RyaW5nKCksIHtcbiAgICAgIG1ldGhvZDogJ0RFTEVURScsXG4gICAgICBoZWFkZXJzOiBORlRTdG9yYWdlLmF1dGgodG9rZW4pLFxuICAgICAgc2lnbmFsOiBvcHRpb25zICYmIG9wdGlvbnMuc2lnbmFsLFxuICAgIH0pXG4gICAgLyogYzggaWdub3JlIG5leHQgMyAqL1xuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQyOSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdyYXRlIGxpbWl0ZWQnKVxuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKClcbiAgICBpZiAoIXJlc3VsdC5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHJlc3VsdC5lcnJvci5tZXNzYWdlKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBFbmNvZGVzIHRoZSBnaXZlbiB0b2tlbiBhbmQgYWxsIHJlc291cmNlcyBpdCByZWZlcmVuY2VzIChpbiB0aGUgZm9ybSBvZiBhXG4gICAqIEZpbGUgb3IgYSBCbG9iKSBhbG9uZyB3aXRoIGEgbWV0YWRhdGEgSlNPTiBhcyBzcGVjaWZpY2VkIGluIEVSQy0xMTU1IHRvIGFcbiAgICogQ0FSIGZpbGUuIFRoZSBgdG9rZW4uaW1hZ2VgIG11c3QgYmUgZWl0aGVyIGEgYEZpbGVgIG9yIGEgYEJsb2JgIGluc3RhbmNlLFxuICAgKiB3aGljaCB3aWxsIGJlIHN0b3JlZCBhbmQgdGhlIGNvcnJlc3BvbmRpbmcgY29udGVudCBhZGRyZXNzIFVSTCB3aWxsIGJlXG4gICAqIHNhdmVkIGluIHRoZSBtZXRhZGF0YSBKU09OIGZpbGUgdW5kZXIgYGltYWdlYCBmaWVsZC5cbiAgICpcbiAgICogSWYgYHRva2VuLnByb3BlcnRpZXNgIGNvbnRhaW5zIHByb3BlcnRpZXMgd2l0aCBgRmlsZWAgb3IgYEJsb2JgIHZhbHVlcyxcbiAgICogdGhvc2UgYWxzbyBnZXQgc3RvcmVkIGFuZCB0aGVpciBVUkxzIHdpbGwgYmUgc2F2ZWQgaW4gdGhlIG1ldGFkYXRhIEpTT05cbiAgICogZmlsZSBpbiB0aGVpciBwbGFjZS5cbiAgICpcbiAgICogTm90ZTogVVJMcyBmb3IgYEZpbGVgIG9iamVjdHMgd2lsbCByZXRhaW4gZmlsZSBuYW1lcyBlLmcuIGluIGNhc2Ugb2ZcbiAgICogYG5ldyBGaWxlKFtieXRlc10sICdjYXQucG5nJywgeyB0eXBlOiAnaW1hZ2UvcG5nJyB9KWAgd2lsbCBiZSB0cmFuc2Zvcm1lZFxuICAgKiBpbnRvIGEgVVJMIHRoYXQgbG9va3MgbGlrZSBgaXBmczovL2JhZnkuLi5oYXNoL2ltYWdlL2NhdC5wbmdgLiBGb3IgYEJsb2JgXG4gICAqIG9iamVjdHMsIHRoZSBVUkwgd2lsbCBub3QgaGF2ZSBhIGZpbGUgbmFtZSBuYW1lIG9yIG1pbWUgdHlwZSwgaW5zdGVhZCBpdFxuICAgKiB3aWxsIGJlIHRyYW5zZm9ybWVkIGludG8gYSBVUkwgdGhhdCBsb29rcyBsaWtlXG4gICAqIGBpcGZzOi8vYmFmeS4uLmhhc2gvaW1hZ2UvYmxvYmAuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IHsgdG9rZW4sIGNhciB9ID0gYXdhaXQgTkZUU3RvcmFnZS5lbmNvZGVORlQoe1xuICAgKiAgIG5hbWU6ICduZnQuc3RvcmFnZSBzdG9yZSB0ZXN0JyxcbiAgICogICBkZXNjcmlwdGlvbjogJ1Rlc3QgRVJDLTExNTUgY29tcGF0aWJsZSBtZXRhZGF0YS4nLFxuICAgKiAgIGltYWdlOiBuZXcgRmlsZShbJzxEQVRBPiddLCAncGlucGllLmpwZycsIHsgdHlwZTogJ2ltYWdlL2pwZycgfSksXG4gICAqICAgcHJvcGVydGllczoge1xuICAgKiAgICAgY3VzdG9tOiAnQ3VzdG9tIGRhdGEgY2FuIGFwcGVhciBoZXJlLCBmaWxlcyBhcmUgYXV0byB1cGxvYWRlZC4nLFxuICAgKiAgICAgZmlsZTogbmV3IEZpbGUoWyc8REFUQT4nXSwgJ1JFQURNRS5tZCcsIHsgdHlwZTogJ3RleHQvcGxhaW4nIH0pLFxuICAgKiAgIH1cbiAgICogfSlcbiAgICpcbiAgICogY29uc29sZS5sb2coJ0lQRlMgVVJMIGZvciB0aGUgbWV0YWRhdGE6JywgdG9rZW4udXJsKVxuICAgKiBjb25zb2xlLmxvZygnbWV0YWRhdGEuanNvbiBjb250ZW50czpcXG4nLCB0b2tlbi5kYXRhKVxuICAgKiBjb25zb2xlLmxvZygnbWV0YWRhdGEuanNvbiB3aXRoIElQRlMgZ2F0ZXdheSBVUkxzOlxcbicsIHRva2VuLmVtYmVkKCkpXG4gICAqXG4gICAqIC8vIE5vdyBzdG9yZSB0aGUgQ0FSIGZpbGUgb24gTkZULlN0b3JhZ2VcbiAgICogYXdhaXQgY2xpZW50LnN0b3JlQ2FyKGNhcilcbiAgICogYGBgXG4gICAqXG4gICAqIEB0ZW1wbGF0ZSB7aW1wb3J0KCcuL2xpYi9pbnRlcmZhY2UuanMnKS5Ub2tlbklucHV0fSBUXG4gICAqIEBwYXJhbSB7VH0gaW5wdXRcbiAgICogQHJldHVybnMge1Byb21pc2U8eyBjaWQ6IENJRCwgdG9rZW46IFRva2VuVHlwZTxUPiwgY2FyOiBDYXJSZWFkZXIgfT59XG4gICAqL1xuICBzdGF0aWMgYXN5bmMgZW5jb2RlTkZUKGlucHV0KSB7XG4gICAgdmFsaWRhdGVFUkMxMTU1KGlucHV0KVxuICAgIHJldHVybiBUb2tlbi5Ub2tlbi5lbmNvZGUoaW5wdXQpXG4gIH1cblxuICAvKipcbiAgICogRW5jb2RlcyBhIHNpbmdsZSBmaWxlIHRvIGEgQ0FSIGZpbGUgYW5kIGFsc28gcmV0dXJucyBpdHMgcm9vdCBDSUQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IGNvbnRlbnQgPSBuZXcgQmxvYihbJ2hlbGxvIHdvcmxkJ10pXG4gICAqIGNvbnN0IHsgY2lkLCBjYXIgfSA9IGF3YWl0IE5GVFN0b3JhZ2UuZW5jb2RlQmxvYihjb250ZW50KVxuICAgKlxuICAgKiAvLyBSb290IENJRCBvZiB0aGUgZmlsZVxuICAgKiBjb25zb2xlLmxvZyhjaWQudG9TdHJpbmcoKSlcbiAgICpcbiAgICogLy8gTm93IHN0b3JlIHRoZSBDQVIgZmlsZSBvbiBORlQuU3RvcmFnZVxuICAgKiBhd2FpdCBjbGllbnQuc3RvcmVDYXIoY2FyKVxuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIHtCbG9ifSBibG9iXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAgICogQHBhcmFtIHtCbG9ja3N0b3JlSX0gW29wdGlvbnMuYmxvY2tzdG9yZV1cbiAgICogQHJldHVybnMge1Byb21pc2U8eyBjaWQ6IENJRCwgY2FyOiBDYXJSZWFkZXIgfT59XG4gICAqL1xuICBzdGF0aWMgYXN5bmMgZW5jb2RlQmxvYihibG9iLCB7IGJsb2Nrc3RvcmUgfSA9IHt9KSB7XG4gICAgaWYgKGJsb2Iuc2l6ZSA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb250ZW50IHNpemUgaXMgMCwgbWFrZSBzdXJlIHRvIHByb3ZpZGUgc29tZSBjb250ZW50JylcbiAgICB9XG4gICAgcmV0dXJuIHBhY2tDYXIoW3RvSW1wb3J0Q2FuZGlkYXRlKCdibG9iJywgYmxvYildLCB7XG4gICAgICBibG9ja3N0b3JlLFxuICAgICAgd3JhcFdpdGhEaXJlY3Rvcnk6IGZhbHNlLFxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogRW5jb2RlcyBhIGRpcmVjdG9yeSBvZiBmaWxlcyB0byBhIENBUiBmaWxlIGFuZCBhbHNvIHJldHVybnMgdGhlIHJvb3QgQ0lELlxuICAgKiBQcm92aWRlZCBmaWxlcyAqKk1VU1QqKiBiZSB3aXRoaW4gdGhlIHNhbWUgZGlyZWN0b3J5LCBvdGhlcndpc2UgZXJyb3IgaXNcbiAgICogcmFpc2VkIGUuZy4gYGZvby9iYXIucG5nYCwgYGZvby9ibGEvYmF6Lmpzb25gIGlzIG9rIGJ1dCBgZm9vL2Jhci5wbmdgLFxuICAgKiBgYmxhL2Jhei5qc29uYCBpcyBub3QuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IHsgY2lkLCBjYXIgfSA9IGF3YWl0IE5GVFN0b3JhZ2UuZW5jb2RlRGlyZWN0b3J5KFtcbiAgICogICBuZXcgRmlsZShbJ2hlbGxvIHdvcmxkJ10sICdoZWxsby50eHQnKSxcbiAgICogICBuZXcgRmlsZShbSlNPTi5zdHJpbmdpZnkoeydmcm9tJzogJ2luY29nbml0byd9LCBudWxsLCAyKV0sICdtZXRhZGF0YS5qc29uJylcbiAgICogXSlcbiAgICpcbiAgICogLy8gUm9vdCBDSUQgb2YgdGhlIGRpcmVjdG9yeVxuICAgKiBjb25zb2xlLmxvZyhjaWQudG9TdHJpbmcoKSlcbiAgICpcbiAgICogLy8gTm93IHN0b3JlIHRoZSBDQVIgZmlsZSBvbiBORlQuU3RvcmFnZVxuICAgKiBhd2FpdCBjbGllbnQuc3RvcmVDYXIoY2FyKVxuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIHtGaWxlc1NvdXJjZX0gZmlsZXNcbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICAgKiBAcGFyYW0ge0Jsb2Nrc3RvcmVJfSBbb3B0aW9ucy5ibG9ja3N0b3JlXVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx7IGNpZDogQ0lELCBjYXI6IENhclJlYWRlciB9Pn1cbiAgICovXG4gIHN0YXRpYyBhc3luYyBlbmNvZGVEaXJlY3RvcnkoZmlsZXMsIHsgYmxvY2tzdG9yZSB9ID0ge30pIHtcbiAgICBsZXQgc2l6ZSA9IDBcbiAgICBjb25zdCBpbnB1dCA9IHBpcGUoZmlsZXMsIGFzeW5jIGZ1bmN0aW9uKiAoZmlsZXMpIHtcbiAgICAgIGZvciBhd2FpdCAoY29uc3QgZmlsZSBvZiBmaWxlcykge1xuICAgICAgICB5aWVsZCB0b0ltcG9ydENhbmRpZGF0ZShmaWxlLm5hbWUsIGZpbGUpXG4gICAgICAgIHNpemUgKz0gZmlsZS5zaXplXG4gICAgICB9XG4gICAgfSlcbiAgICBjb25zdCBwYWNrZWQgPSBhd2FpdCBwYWNrQ2FyKGlucHV0LCB7XG4gICAgICBibG9ja3N0b3JlLFxuICAgICAgd3JhcFdpdGhEaXJlY3Rvcnk6IHRydWUsXG4gICAgfSlcbiAgICBpZiAoc2l6ZSA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnVG90YWwgc2l6ZSBvZiBmaWxlcyBzaG91bGQgZXhjZWVkIDAsIG1ha2Ugc3VyZSB0byBwcm92aWRlIHNvbWUgY29udGVudCdcbiAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIHBhY2tlZFxuICB9XG5cbiAgLy8gSnVzdCBhIHN1Z2FyIHNvIHlvdSBkb24ndCBoYXZlIHRvIHBhc3MgYXJvdW5kIGVuZHBvaW50IGFuZCB0b2tlbiBhcm91bmQuXG5cbiAgLyoqXG4gICAqIFN0b3JlcyBhIHNpbmdsZSBmaWxlIGFuZCByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIENvbnRlbnQgSWRlbnRpZmllciAoQ0lEKS5cbiAgICogVGFrZXMgYSBbQmxvYl0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0Jsb2IvQmxvYilcbiAgICogb3IgYSBbRmlsZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0ZpbGUpLiBOb3RlXG4gICAqIHRoYXQgbm8gZmlsZSBuYW1lIG9yIGZpbGUgbWV0YWRhdGEgaXMgcmV0YWluZWQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IGNvbnRlbnQgPSBuZXcgQmxvYihbJ2hlbGxvIHdvcmxkJ10pXG4gICAqIGNvbnN0IGNpZCA9IGF3YWl0IGNsaWVudC5zdG9yZUJsb2IoY29udGVudClcbiAgICogY2lkIC8vPiAnemRqN1duOUZRQVVSQ1A2TWJ3Y1d1emk3dTY1a0FzWENkak5Ua2hiSmNvYVhCdXNxOSdcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSB7QmxvYn0gYmxvYlxuICAgKiBAcGFyYW0ge1JlcXVlc3RPcHRpb25zfSBbb3B0aW9uc11cbiAgICovXG4gIHN0b3JlQmxvYihibG9iLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIE5GVFN0b3JhZ2Uuc3RvcmVCbG9iKHRoaXMsIGJsb2IsIG9wdGlvbnMpXG4gIH1cblxuICAvKipcbiAgICogU3RvcmVzIGZpbGVzIGVuY29kZWQgYXMgYSBzaW5nbGUgW0NvbnRlbnQgQWRkcmVzc2VkIEFyY2hpdmVcbiAgICogKENBUildKGh0dHBzOi8vZ2l0aHViLmNvbS9pcGxkL3NwZWNzL2Jsb2IvbWFzdGVyL2Jsb2NrLWxheWVyL2NvbnRlbnQtYWRkcmVzc2FibGUtYXJjaGl2ZXMubWQpLlxuICAgKlxuICAgKiBUYWtlcyBhIFtCbG9iXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQmxvYi9CbG9iKVxuICAgKiBvciBhIFtGaWxlXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRmlsZSkuXG4gICAqXG4gICAqIFJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgQ29udGVudCBJZGVudGlmaWVyIChDSUQpLlxuICAgKlxuICAgKiBTZWUgdGhlIFtgaXBmcy1jYXJgIGRvY3NdKGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL2lwZnMtY2FyKSBmb3IgbW9yZVxuICAgKiBkZXRhaWxzIG9uIHBhY2tpbmcgYSBDQVIgZmlsZS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICogaW1wb3J0IHsgcGFjayB9IGZyb20gJ2lwZnMtY2FyL3BhY2snXG4gICAqIGltcG9ydCB7IENhclJlYWRlciB9IGZyb20gJ0BpcGxkL2NhcidcbiAgICogY29uc3QgeyBvdXQsIHJvb3QgfSA9IGF3YWl0IHBhY2soe1xuICAgKiAgaW5wdXQ6IGZzLmNyZWF0ZVJlYWRTdHJlYW0oJ3BpbnBpZS5wZGYnKVxuICAgKiB9KVxuICAgKiBjb25zdCBleHBlY3RlZENpZCA9IHJvb3QudG9TdHJpbmcoKVxuICAgKiBjb25zdCBjYXJSZWFkZXIgPSBhd2FpdCBDYXJSZWFkZXIuZnJvbUl0ZXJhYmxlKG91dClcbiAgICogY29uc3QgY2lkID0gYXdhaXQgc3RvcmFnZS5zdG9yZUNhcihjYXJSZWFkZXIpXG4gICAqIGNvbnNvbGUuYXNzZXJ0KGNpZCA9PT0gZXhwZWN0ZWRDaWQpXG4gICAqIGBgYFxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBcbiAgICogaW1wb3J0IHsgcGFja1RvQmxvYiB9IGZyb20gJ2lwZnMtY2FyL3BhY2svYmxvYidcbiAgICogY29uc3QgZGF0YSA9ICdIZWxsbyB3b3JsZCdcbiAgICogY29uc3QgeyByb290LCBjYXIgfSA9IGF3YWl0IHBhY2tUb0Jsb2IoeyBpbnB1dDogW25ldyBUZXh0RW5jb2RlcigpLmVuY29kZShkYXRhKV0gfSlcbiAgICogY29uc3QgZXhwZWN0ZWRDaWQgPSByb290LnRvU3RyaW5nKClcbiAgICogY29uc3QgY2lkID0gYXdhaXQgY2xpZW50LnN0b3JlQ2FyKGNhcilcbiAgICogY29uc29sZS5hc3NlcnQoY2lkID09PSBleHBlY3RlZENpZClcbiAgICogYGBgXG4gICAqIEBwYXJhbSB7QmxvYnxDYXJSZWFkZXJ9IGNhclxuICAgKiBAcGFyYW0ge2ltcG9ydCgnLi9saWIvaW50ZXJmYWNlLmpzJykuQ2FyU3RvcmVyT3B0aW9uc30gW29wdGlvbnNdXG4gICAqL1xuICBzdG9yZUNhcihjYXIsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gTkZUU3RvcmFnZS5zdG9yZUNhcih0aGlzLCBjYXIsIG9wdGlvbnMpXG4gIH1cblxuICAvKipcbiAgICogU3RvcmVzIGEgZGlyZWN0b3J5IG9mIGZpbGVzIGFuZCByZXR1cm5zIGEgQ0lEIGZvciB0aGUgZGlyZWN0b3J5LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiBjb25zdCBjaWQgPSBhd2FpdCBjbGllbnQuc3RvcmVEaXJlY3RvcnkoW1xuICAgKiAgIG5ldyBGaWxlKFsnaGVsbG8gd29ybGQnXSwgJ2hlbGxvLnR4dCcpLFxuICAgKiAgIG5ldyBGaWxlKFtKU09OLnN0cmluZ2lmeSh7J2Zyb20nOiAnaW5jb2duaXRvJ30sIG51bGwsIDIpXSwgJ21ldGFkYXRhLmpzb24nKVxuICAgKiBdKVxuICAgKiBjaWQgLy8+XG4gICAqIGBgYFxuICAgKlxuICAgKiBBcmd1bWVudCBjYW4gYmUgYSBbRmlsZUxpc3RdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9GaWxlTGlzdClcbiAgICogaW5zdGFuY2UgYXMgd2VsbCwgaW4gd2hpY2ggY2FzZSBkaXJlY3Rvcnkgc3RydWN0dXJlIHdpbGwgYmUgcmV0YWluZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7RmlsZXNTb3VyY2V9IGZpbGVzXG4gICAqIEBwYXJhbSB7UmVxdWVzdE9wdGlvbnN9IFtvcHRpb25zXVxuICAgKi9cbiAgc3RvcmVEaXJlY3RvcnkoZmlsZXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gTkZUU3RvcmFnZS5zdG9yZURpcmVjdG9yeSh0aGlzLCBmaWxlcywgb3B0aW9ucylcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGN1cnJlbnQgc3RhdHVzIG9mIHRoZSBzdG9yZWQgTkZUIGJ5IGl0cyBDSUQuIE5vdGUgdGhlIE5GVCBtdXN0XG4gICAqIGhhdmUgcHJldmlvdXNseSBiZWVuIHN0b3JlZCBieSB0aGlzIGFjY291bnQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IHN0YXR1cyA9IGF3YWl0IGNsaWVudC5zdGF0dXMoJ3pkajdXbjlGUUFVUkNQNk1id2NXdXppN3U2NWtBc1hDZGpOVGtoYkpjb2FYQnVzcTknKVxuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNpZFxuICAgKiBAcGFyYW0ge1JlcXVlc3RPcHRpb25zfSBbb3B0aW9uc11cbiAgICovXG4gIHN0YXR1cyhjaWQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gTkZUU3RvcmFnZS5zdGF0dXModGhpcywgY2lkLCBvcHRpb25zKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgc3RvcmVkIGNvbnRlbnQgYnkgaXRzIENJRCBmcm9tIHRoZSBzZXJ2aWNlLlxuICAgKlxuICAgKiA+IFBsZWFzZSBub3RlIHRoYXQgZXZlbiBpZiBjb250ZW50IGlzIHJlbW92ZWQgZnJvbSB0aGUgc2VydmljZSBvdGhlciBub2Rlc1xuICAgKiB0aGF0IGhhdmUgcmVwbGljYXRlZCBpdCBtaWdodCBzdGlsbCBjb250aW51ZSBwcm92aWRpbmcgaXQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIGF3YWl0IGNsaWVudC5kZWxldGUoJ3pkajdXbjlGUUFVUkNQNk1id2NXdXppN3U2NWtBc1hDZGpOVGtoYkpjb2FYQnVzcTknKVxuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNpZFxuICAgKiBAcGFyYW0ge1JlcXVlc3RPcHRpb25zfSBbb3B0aW9uc11cbiAgICovXG4gIGRlbGV0ZShjaWQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gTkZUU3RvcmFnZS5kZWxldGUodGhpcywgY2lkLCBvcHRpb25zKVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgQ0lEIG9mIGFuIE5GVCBpcyBiZWluZyBzdG9yZWQgYnkgbmZ0LnN0b3JhZ2UuIFRocm93cyBpZiB0aGUgTkZUXG4gICAqIHdhcyBub3QgZm91bmQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IHN0YXR1cyA9IGF3YWl0IGNsaWVudC5jaGVjaygnemRqN1duOUZRQVVSQ1A2TWJ3Y1d1emk3dTY1a0FzWENkak5Ua2hiSmNvYVhCdXNxOScpXG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2lkXG4gICAqIEBwYXJhbSB7UmVxdWVzdE9wdGlvbnN9IFtvcHRpb25zXVxuICAgKi9cbiAgY2hlY2soY2lkLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIE5GVFN0b3JhZ2UuY2hlY2sodGhpcywgY2lkLCBvcHRpb25zKVxuICB9XG5cbiAgLyoqXG4gICAqIFN0b3JlcyB0aGUgZ2l2ZW4gdG9rZW4gYW5kIGFsbCByZXNvdXJjZXMgaXQgcmVmZXJlbmNlcyAoaW4gdGhlIGZvcm0gb2YgYVxuICAgKiBGaWxlIG9yIGEgQmxvYikgYWxvbmcgd2l0aCBhIG1ldGFkYXRhIEpTT04gYXMgc3BlY2lmaWNlZCBpblxuICAgKiBbRVJDLTExNTVdKGh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtMTE1NSNtZXRhZGF0YSkuIFRoZVxuICAgKiBgdG9rZW4uaW1hZ2VgIG11c3QgYmUgZWl0aGVyIGEgYEZpbGVgIG9yIGEgYEJsb2JgIGluc3RhbmNlLCB3aGljaCB3aWxsIGJlXG4gICAqIHN0b3JlZCBhbmQgdGhlIGNvcnJlc3BvbmRpbmcgY29udGVudCBhZGRyZXNzIFVSTCB3aWxsIGJlIHNhdmVkIGluIHRoZVxuICAgKiBtZXRhZGF0YSBKU09OIGZpbGUgdW5kZXIgYGltYWdlYCBmaWVsZC5cbiAgICpcbiAgICogSWYgYHRva2VuLnByb3BlcnRpZXNgIGNvbnRhaW5zIHByb3BlcnRpZXMgd2l0aCBgRmlsZWAgb3IgYEJsb2JgIHZhbHVlcyxcbiAgICogdGhvc2UgYWxzbyBnZXQgc3RvcmVkIGFuZCB0aGVpciBVUkxzIHdpbGwgYmUgc2F2ZWQgaW4gdGhlIG1ldGFkYXRhIEpTT05cbiAgICogZmlsZSBpbiB0aGVpciBwbGFjZS5cbiAgICpcbiAgICogTm90ZTogVVJMcyBmb3IgYEZpbGVgIG9iamVjdHMgd2lsbCByZXRhaW4gZmlsZSBuYW1lcyBlLmcuIGluIGNhc2Ugb2ZcbiAgICogYG5ldyBGaWxlKFtieXRlc10sICdjYXQucG5nJywgeyB0eXBlOiAnaW1hZ2UvcG5nJyB9KWAgd2lsbCBiZSB0cmFuc2Zvcm1lZFxuICAgKiBpbnRvIGEgVVJMIHRoYXQgbG9va3MgbGlrZSBgaXBmczovL2JhZnkuLi5oYXNoL2ltYWdlL2NhdC5wbmdgLiBGb3IgYEJsb2JgXG4gICAqIG9iamVjdHMsIHRoZSBVUkwgd2lsbCBub3QgaGF2ZSBhIGZpbGUgbmFtZSBuYW1lIG9yIG1pbWUgdHlwZSwgaW5zdGVhZCBpdFxuICAgKiB3aWxsIGJlIHRyYW5zZm9ybWVkIGludG8gYSBVUkwgdGhhdCBsb29rcyBsaWtlXG4gICAqIGBpcGZzOi8vYmFmeS4uLmhhc2gvaW1hZ2UvYmxvYmAuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IG1ldGFkYXRhID0gYXdhaXQgY2xpZW50LnN0b3JlKHtcbiAgICogICBuYW1lOiAnbmZ0LnN0b3JhZ2Ugc3RvcmUgdGVzdCcsXG4gICAqICAgZGVzY3JpcHRpb246ICdUZXN0IEVSQy0xMTU1IGNvbXBhdGlibGUgbWV0YWRhdGEuJyxcbiAgICogICBpbWFnZTogbmV3IEZpbGUoWyc8REFUQT4nXSwgJ3BpbnBpZS5qcGcnLCB7IHR5cGU6ICdpbWFnZS9qcGcnIH0pLFxuICAgKiAgIHByb3BlcnRpZXM6IHtcbiAgICogICAgIGN1c3RvbTogJ0N1c3RvbSBkYXRhIGNhbiBhcHBlYXIgaGVyZSwgZmlsZXMgYXJlIGF1dG8gdXBsb2FkZWQuJyxcbiAgICogICAgIGZpbGU6IG5ldyBGaWxlKFsnPERBVEE+J10sICdSRUFETUUubWQnLCB7IHR5cGU6ICd0ZXh0L3BsYWluJyB9KSxcbiAgICogICB9XG4gICAqIH0pXG4gICAqXG4gICAqIGNvbnNvbGUubG9nKCdJUEZTIFVSTCBmb3IgdGhlIG1ldGFkYXRhOicsIG1ldGFkYXRhLnVybClcbiAgICogY29uc29sZS5sb2coJ21ldGFkYXRhLmpzb24gY29udGVudHM6XFxuJywgbWV0YWRhdGEuZGF0YSlcbiAgICogY29uc29sZS5sb2coJ21ldGFkYXRhLmpzb24gd2l0aCBJUEZTIGdhdGV3YXkgVVJMczpcXG4nLCBtZXRhZGF0YS5lbWJlZCgpKVxuICAgKiBgYGBcbiAgICpcbiAgICogQHRlbXBsYXRlIHtpbXBvcnQoJy4vbGliL2ludGVyZmFjZS5qcycpLlRva2VuSW5wdXR9IFRcbiAgICogQHBhcmFtIHtUfSB0b2tlblxuICAgKiBAcGFyYW0ge1JlcXVlc3RPcHRpb25zfSBbb3B0aW9uc11cbiAgICovXG4gIHN0b3JlKHRva2VuLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIE5GVFN0b3JhZ2Uuc3RvcmUodGhpcywgdG9rZW4sIG9wdGlvbnMpXG4gIH1cbn1cblxuLyoqXG4gKiBDYXN0IGFuIGl0ZXJhYmxlIHRvIGFuIGFzeW5jSXRlcmFibGVcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge0l0ZXJhYmxlPFQ+fSBpdGVyYWJsZVxuICogQHJldHVybnMge0FzeW5jSXRlcmFibGU8VD59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0FzeW5jSXRlcmFibGUoaXRlcmFibGUpIHtcbiAgcmV0dXJuIChhc3luYyBmdW5jdGlvbiogKCkge1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBpdGVyYWJsZSkge1xuICAgICAgeWllbGQgaXRlbVxuICAgIH1cbiAgfSkoKVxufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSB7aW1wb3J0KCcuL2xpYi9pbnRlcmZhY2UuanMnKS5Ub2tlbklucHV0fSBUXG4gKiBAcGFyYW0ge1R9IG1ldGFkYXRhXG4gKi9cbmNvbnN0IHZhbGlkYXRlRVJDMTE1NSA9ICh7IG5hbWUsIGRlc2NyaXB0aW9uLCBpbWFnZSwgZGVjaW1hbHMgfSkgPT4ge1xuICAvLyBKdXN0IHZhbGlkYXRlIHRoYXQgZXhwZWN0ZWQgZmllbGRzIGFyZSBwcmVzZW50XG4gIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ3N0cmluZyBwcm9wZXJ0eSBgbmFtZWAgaWRlbnRpZnlpbmcgdGhlIGFzc2V0IGlzIHJlcXVpcmVkJ1xuICAgIClcbiAgfVxuICBpZiAodHlwZW9mIGRlc2NyaXB0aW9uICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnc3RyaW5nIHByb3BlcnR5IGBkZXNjcmlwdGlvbmAgZGVzY3JpYmluZyBhc3NldCBpcyByZXF1aXJlZCdcbiAgICApXG4gIH1cbiAgaWYgKCEoaW1hZ2UgaW5zdGFuY2VvZiBCbG9iKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3Byb3BlcnR5IGBpbWFnZWAgbXVzdCBiZSBhIEJsb2Igb3IgRmlsZSBvYmplY3QnKVxuICB9IGVsc2UgaWYgKCFpbWFnZS50eXBlLnN0YXJ0c1dpdGgoJ2ltYWdlLycpKSB7XG4gICAgY29uc29sZS53YXJuKGBBY2NvcmRpbmcgdG8gRVJDNzIxIE1ldGFkYXRhIEpTT04gU2NoZW1hICdpbWFnZScgbXVzdCBoYXZlICdpbWFnZS8qJyBtaW1lIHR5cGUuXG5cbkZvciBiZXR0ZXIgaW50ZXJvcGVyYWJpbGl0eSB3ZSB3b3VsZCBoaWdobHkgcmVjb21tZW5kIHN0b3JpbmcgY29udGVudCB3aXRoIGRpZmZlcmVudCBtaW1lIHR5cGUgdW5kZXIgJ3Byb3BlcnRpZXMnIG5hbWVzcGFjZSBlLmcuIFxcYHByb3BlcnRpZXM6IHsgdmlkZW86IGZpbGUgfVxcYCBhbmQgdXNpbmcgJ2ltYWdlJyBmaWVsZCBmb3Igc3RvcmluZyBhIHByZXZpZXcgaW1hZ2UgZm9yIGl0IGluc3RlYWQuXG5cbkZvciBtb3JlIGNvbnRleHQgcGxlYXNlIHNlZSBFUkMtNzIxIHNwZWNpZmljYXRpb24gaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC03MjFgKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBkZWNpbWFscyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRlY2ltYWxzICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3Byb3BlcnR5IGBkZWNpbWFsc2AgbXVzdCBiZSBhbiBpbnRlZ2VyIHZhbHVlJylcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCdpcGZzLWNhci9wYWNrJykuSW1wb3J0Q2FuZGlkYXRlU3RyZWFtfEFycmF5PHsgcGF0aDogc3RyaW5nLCBjb250ZW50OiBpbXBvcnQoJy4vcGxhdGZvcm0uanMnKS5SZWFkYWJsZVN0cmVhbSB9Pn0gaW5wdXRcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7QmxvY2tzdG9yZUl9IFtvcHRpb25zLmJsb2Nrc3RvcmVdXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLndyYXBXaXRoRGlyZWN0b3J5XVxuICovXG5jb25zdCBwYWNrQ2FyID0gYXN5bmMgKGlucHV0LCB7IGJsb2Nrc3RvcmUsIHdyYXBXaXRoRGlyZWN0b3J5IH0gPSB7fSkgPT4ge1xuICAvKiBjOCBpZ25vcmUgbmV4dCAxICovXG4gIGJsb2Nrc3RvcmUgPSBibG9ja3N0b3JlIHx8IG5ldyBCbG9ja3N0b3JlKClcbiAgY29uc3QgeyByb290OiBjaWQgfSA9IGF3YWl0IHBhY2soeyBpbnB1dCwgYmxvY2tzdG9yZSwgd3JhcFdpdGhEaXJlY3RvcnkgfSlcbiAgY29uc3QgY2FyID0gbmV3IEJsb2Nrc3RvcmVDYXJSZWFkZXIoMSwgW2NpZF0sIGJsb2Nrc3RvcmUpXG4gIHJldHVybiB7IGNpZCwgY2FyIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0RlYWxbXX0gZGVhbHNcbiAqIEByZXR1cm5zIHtEZWFsW119XG4gKi9cbmNvbnN0IGRlY29kZURlYWxzID0gKGRlYWxzKSA9PlxuICBkZWFscy5tYXAoKGRlYWwpID0+IHtcbiAgICBjb25zdCB7IGRlYWxBY3RpdmF0aW9uLCBkZWFsRXhwaXJhdGlvbiwgbGFzdENoYW5nZWQgfSA9IHtcbiAgICAgIGRlYWxFeHBpcmF0aW9uOiBudWxsLFxuICAgICAgZGVhbEFjdGl2YXRpb246IG51bGwsXG4gICAgICAuLi5kZWFsLFxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAuLi5kZWFsLFxuICAgICAgbGFzdENoYW5nZWQ6IG5ldyBEYXRlKGxhc3RDaGFuZ2VkKSxcbiAgICAgIC4uLihkZWFsQWN0aXZhdGlvbiAmJiB7IGRlYWxBY3RpdmF0aW9uOiBuZXcgRGF0ZShkZWFsQWN0aXZhdGlvbikgfSksXG4gICAgICAuLi4oZGVhbEV4cGlyYXRpb24gJiYgeyBkZWFsRXhwaXJhdGlvbjogbmV3IERhdGUoZGVhbEV4cGlyYXRpb24pIH0pLFxuICAgIH1cbiAgfSlcblxuLyoqXG4gKiBAcGFyYW0ge1Bpbn0gcGluXG4gKiBAcmV0dXJucyB7UGlufVxuICovXG5jb25zdCBkZWNvZGVQaW4gPSAocGluKSA9PiAoeyAuLi5waW4sIGNyZWF0ZWQ6IG5ldyBEYXRlKHBpbi5jcmVhdGVkKSB9KVxuXG4vKipcbiAqIENvbnZlcnQgdGhlIHBhc3NlZCBibG9iIHRvIGFuIFwiaW1wb3J0IGNhbmRpZGF0ZVwiIC0gYW4gb2JqZWN0IHN1aXRhYmxlIGZvclxuICogcGFzc2luZyB0byB0aGUgaXBmcy11bml4ZnMtaW1wb3J0ZXIuIE5vdGU6IGNvbnRlbnQgaXMgYW4gYWNjZXNzb3Igc28gdGhhdFxuICogdGhlIHN0cmVhbSBpcyBjcmVhdGVkIG9ubHkgd2hlbiBuZWVkZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGhcbiAqIEBwYXJhbSB7UGljazxCbG9iLCAnc3RyZWFtJz58eyBzdHJlYW06ICgpID0+IEFzeW5jSXRlcmFibGU8VWludDhBcnJheT4gfX0gYmxvYlxuICogQHJldHVybnMge2ltcG9ydCgnaXBmcy1jb3JlLXR5cGVzL3NyYy91dGlscy5qcycpLkltcG9ydENhbmRpZGF0ZX1cbiAqL1xuZnVuY3Rpb24gdG9JbXBvcnRDYW5kaWRhdGUocGF0aCwgYmxvYikge1xuICAvKiogQHR5cGUge0FzeW5jSXRlcmFibGU8VWludDhBcnJheT59ICovXG4gIGxldCBzdHJlYW1cbiAgcmV0dXJuIHtcbiAgICBwYXRoLFxuICAgIGdldCBjb250ZW50KCkge1xuICAgICAgc3RyZWFtID0gc3RyZWFtIHx8IGJsb2Iuc3RyZWFtKClcbiAgICAgIHJldHVybiBzdHJlYW1cbiAgICB9LFxuICB9XG59XG5cbmV4cG9ydCB7IE5GVFN0b3JhZ2UsIEZpbGUsIEJsb2IsIEZvcm1EYXRhLCB0b0dhdGV3YXlVUkwsIFRva2VuIH1cbiIsICJpbXBvcnQgZnMgZnJvbSAnZnMnO1xuaW1wb3J0IHsgcHJvbWlzaWZ5IH0gZnJvbSAndXRpbCc7XG5pbXBvcnQgeyBDYXJSZWFkZXIgYXMgQnJvd3NlckNhclJlYWRlciB9IGZyb20gJy4vcmVhZGVyLWJyb3dzZXIuanMnO1xuY29uc3QgZnNyZWFkID0gcHJvbWlzaWZ5KGZzLnJlYWQpO1xuZXhwb3J0IGNsYXNzIENhclJlYWRlciBleHRlbmRzIEJyb3dzZXJDYXJSZWFkZXIge1xuICBzdGF0aWMgYXN5bmMgcmVhZFJhdyhmZCwgYmxvY2tJbmRleCkge1xuICAgIGNvbnN0IHtjaWQsIGJsb2NrTGVuZ3RoLCBibG9ja09mZnNldH0gPSBibG9ja0luZGV4O1xuICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYmxvY2tMZW5ndGgpO1xuICAgIGxldCByZWFkO1xuICAgIGlmICh0eXBlb2YgZmQgPT09ICdudW1iZXInKSB7XG4gICAgICByZWFkID0gKGF3YWl0IGZzcmVhZChmZCwgYnl0ZXMsIDAsIGJsb2NrTGVuZ3RoLCBibG9ja09mZnNldCkpLmJ5dGVzUmVhZDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBmZCA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGZkLnJlYWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJlYWQgPSAoYXdhaXQgZmQucmVhZChieXRlcywgMCwgYmxvY2tMZW5ndGgsIGJsb2NrT2Zmc2V0KSkuYnl0ZXNSZWFkO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCYWQgZmQnKTtcbiAgICB9XG4gICAgaWYgKHJlYWQgIT09IGJsb2NrTGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byByZWFkIGVudGlyZSBibG9jayAoJHsgcmVhZCB9IGluc3RlYWQgb2YgJHsgYmxvY2tMZW5ndGggfSlgKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGNpZCxcbiAgICAgIGJ5dGVzXG4gICAgfTtcbiAgfVxufVxuZXhwb3J0IGNvbnN0IF9fYnJvd3NlciA9IGZhbHNlOyIsICJpbXBvcnQgdmFyaW50IGZyb20gJ3ZhcmludCc7XG5pbXBvcnQgeyBDSUQgfSBmcm9tICdtdWx0aWZvcm1hdHMvY2lkJztcbmltcG9ydCAqIGFzIERpZ2VzdCBmcm9tICdtdWx0aWZvcm1hdHMvaGFzaGVzL2RpZ2VzdCc7XG5pbXBvcnQgeyBkZWNvZGUgYXMgZGVjb2RlRGFnQ2JvciB9IGZyb20gJ0BpcGxkL2RhZy1jYm9yJztcbmNvbnN0IENJRFYwX0JZVEVTID0ge1xuICBTSEEyXzI1NjogMTgsXG4gIExFTkdUSDogMzIsXG4gIERBR19QQjogMTEyXG59O1xuYXN5bmMgZnVuY3Rpb24gcmVhZFZhcmludChyZWFkZXIpIHtcbiAgY29uc3QgYnl0ZXMgPSBhd2FpdCByZWFkZXIudXBUbyg4KTtcbiAgY29uc3QgaSA9IHZhcmludC5kZWNvZGUoYnl0ZXMpO1xuICByZWFkZXIuc2Vlayh2YXJpbnQuZGVjb2RlLmJ5dGVzKTtcbiAgcmV0dXJuIGk7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVhZEhlYWRlcihyZWFkZXIpIHtcbiAgY29uc3QgbGVuZ3RoID0gYXdhaXQgcmVhZFZhcmludChyZWFkZXIpO1xuICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIENBUiBoZWFkZXIgKHplcm8gbGVuZ3RoKScpO1xuICB9XG4gIGNvbnN0IGhlYWRlciA9IGF3YWl0IHJlYWRlci5leGFjdGx5KGxlbmd0aCk7XG4gIHJlYWRlci5zZWVrKGxlbmd0aCk7XG4gIGNvbnN0IGJsb2NrID0gZGVjb2RlRGFnQ2JvcihoZWFkZXIpO1xuICBpZiAoYmxvY2sgPT0gbnVsbCB8fCBBcnJheS5pc0FycmF5KGJsb2NrKSB8fCB0eXBlb2YgYmxvY2sgIT09ICdvYmplY3QnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIENBUiBoZWFkZXIgZm9ybWF0Jyk7XG4gIH1cbiAgaWYgKGJsb2NrLnZlcnNpb24gIT09IDEpIHtcbiAgICBpZiAodHlwZW9mIGJsb2NrLnZlcnNpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgQ0FSIHZlcnNpb246IFwiJHsgYmxvY2sudmVyc2lvbiB9XCJgKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIENBUiB2ZXJzaW9uOiAkeyBibG9jay52ZXJzaW9uIH1gKTtcbiAgfVxuICBpZiAoIUFycmF5LmlzQXJyYXkoYmxvY2sucm9vdHMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIENBUiBoZWFkZXIgZm9ybWF0Jyk7XG4gIH1cbiAgaWYgKE9iamVjdC5rZXlzKGJsb2NrKS5maWx0ZXIocCA9PiBwICE9PSAncm9vdHMnICYmIHAgIT09ICd2ZXJzaW9uJykubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIENBUiBoZWFkZXIgZm9ybWF0Jyk7XG4gIH1cbiAgcmV0dXJuIGJsb2NrO1xufVxuYXN5bmMgZnVuY3Rpb24gcmVhZE11bHRpaGFzaChyZWFkZXIpIHtcbiAgY29uc3QgYnl0ZXMgPSBhd2FpdCByZWFkZXIudXBUbyg4KTtcbiAgdmFyaW50LmRlY29kZShieXRlcyk7XG4gIGNvbnN0IGNvZGVMZW5ndGggPSB2YXJpbnQuZGVjb2RlLmJ5dGVzO1xuICBjb25zdCBsZW5ndGggPSB2YXJpbnQuZGVjb2RlKGJ5dGVzLnN1YmFycmF5KHZhcmludC5kZWNvZGUuYnl0ZXMpKTtcbiAgY29uc3QgbGVuZ3RoTGVuZ3RoID0gdmFyaW50LmRlY29kZS5ieXRlcztcbiAgY29uc3QgbWhMZW5ndGggPSBjb2RlTGVuZ3RoICsgbGVuZ3RoTGVuZ3RoICsgbGVuZ3RoO1xuICBjb25zdCBtdWx0aWhhc2ggPSBhd2FpdCByZWFkZXIuZXhhY3RseShtaExlbmd0aCk7XG4gIHJlYWRlci5zZWVrKG1oTGVuZ3RoKTtcbiAgcmV0dXJuIG11bHRpaGFzaDtcbn1cbmFzeW5jIGZ1bmN0aW9uIHJlYWRDaWQocmVhZGVyKSB7XG4gIGNvbnN0IGZpcnN0ID0gYXdhaXQgcmVhZGVyLmV4YWN0bHkoMik7XG4gIGlmIChmaXJzdFswXSA9PT0gQ0lEVjBfQllURVMuU0hBMl8yNTYgJiYgZmlyc3RbMV0gPT09IENJRFYwX0JZVEVTLkxFTkdUSCkge1xuICAgIGNvbnN0IGJ5dGVzID0gYXdhaXQgcmVhZGVyLmV4YWN0bHkoMzQpO1xuICAgIHJlYWRlci5zZWVrKDM0KTtcbiAgICBjb25zdCBtdWx0aWhhc2ggPSBEaWdlc3QuZGVjb2RlKGJ5dGVzKTtcbiAgICByZXR1cm4gQ0lELmNyZWF0ZSgwLCBDSURWMF9CWVRFUy5EQUdfUEIsIG11bHRpaGFzaCk7XG4gIH1cbiAgY29uc3QgdmVyc2lvbiA9IGF3YWl0IHJlYWRWYXJpbnQocmVhZGVyKTtcbiAgaWYgKHZlcnNpb24gIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgQ0lEIHZlcnNpb24gKCR7IHZlcnNpb24gfSlgKTtcbiAgfVxuICBjb25zdCBjb2RlYyA9IGF3YWl0IHJlYWRWYXJpbnQocmVhZGVyKTtcbiAgY29uc3QgYnl0ZXMgPSBhd2FpdCByZWFkTXVsdGloYXNoKHJlYWRlcik7XG4gIGNvbnN0IG11bHRpaGFzaCA9IERpZ2VzdC5kZWNvZGUoYnl0ZXMpO1xuICByZXR1cm4gQ0lELmNyZWF0ZSh2ZXJzaW9uLCBjb2RlYywgbXVsdGloYXNoKTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZWFkQmxvY2tIZWFkKHJlYWRlcikge1xuICBjb25zdCBzdGFydCA9IHJlYWRlci5wb3M7XG4gIGxldCBsZW5ndGggPSBhd2FpdCByZWFkVmFyaW50KHJlYWRlcik7XG4gIGlmIChsZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgQ0FSIHNlY3Rpb24gKHplcm8gbGVuZ3RoKScpO1xuICB9XG4gIGxlbmd0aCArPSByZWFkZXIucG9zIC0gc3RhcnQ7XG4gIGNvbnN0IGNpZCA9IGF3YWl0IHJlYWRDaWQocmVhZGVyKTtcbiAgY29uc3QgYmxvY2tMZW5ndGggPSBsZW5ndGggLSAocmVhZGVyLnBvcyAtIHN0YXJ0KTtcbiAgcmV0dXJuIHtcbiAgICBjaWQsXG4gICAgbGVuZ3RoLFxuICAgIGJsb2NrTGVuZ3RoXG4gIH07XG59XG5hc3luYyBmdW5jdGlvbiByZWFkQmxvY2socmVhZGVyKSB7XG4gIGNvbnN0IHtjaWQsIGJsb2NrTGVuZ3RofSA9IGF3YWl0IHJlYWRCbG9ja0hlYWQocmVhZGVyKTtcbiAgY29uc3QgYnl0ZXMgPSBhd2FpdCByZWFkZXIuZXhhY3RseShibG9ja0xlbmd0aCk7XG4gIHJlYWRlci5zZWVrKGJsb2NrTGVuZ3RoKTtcbiAgcmV0dXJuIHtcbiAgICBieXRlcyxcbiAgICBjaWRcbiAgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHJlYWRCbG9ja0luZGV4KHJlYWRlcikge1xuICBjb25zdCBvZmZzZXQgPSByZWFkZXIucG9zO1xuICBjb25zdCB7Y2lkLCBsZW5ndGgsIGJsb2NrTGVuZ3RofSA9IGF3YWl0IHJlYWRCbG9ja0hlYWQocmVhZGVyKTtcbiAgY29uc3QgaW5kZXggPSB7XG4gICAgY2lkLFxuICAgIGxlbmd0aCxcbiAgICBibG9ja0xlbmd0aCxcbiAgICBvZmZzZXQsXG4gICAgYmxvY2tPZmZzZXQ6IHJlYWRlci5wb3NcbiAgfTtcbiAgcmVhZGVyLnNlZWsoaW5kZXguYmxvY2tMZW5ndGgpO1xuICByZXR1cm4gaW5kZXg7XG59XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRGVjb2RlcihyZWFkZXIpIHtcbiAgY29uc3QgaGVhZGVyUHJvbWlzZSA9IHJlYWRIZWFkZXIocmVhZGVyKTtcbiAgcmV0dXJuIHtcbiAgICBoZWFkZXI6ICgpID0+IGhlYWRlclByb21pc2UsXG4gICAgYXN5bmMgKmJsb2NrcygpIHtcbiAgICAgIGF3YWl0IGhlYWRlclByb21pc2U7XG4gICAgICB3aGlsZSAoKGF3YWl0IHJlYWRlci51cFRvKDgpKS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHlpZWxkIGF3YWl0IHJlYWRCbG9jayhyZWFkZXIpO1xuICAgICAgfVxuICAgIH0sXG4gICAgYXN5bmMgKmJsb2Nrc0luZGV4KCkge1xuICAgICAgYXdhaXQgaGVhZGVyUHJvbWlzZTtcbiAgICAgIHdoaWxlICgoYXdhaXQgcmVhZGVyLnVwVG8oOCkpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgeWllbGQgYXdhaXQgcmVhZEJsb2NrSW5kZXgocmVhZGVyKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5leHBvcnQgZnVuY3Rpb24gYnl0ZXNSZWFkZXIoYnl0ZXMpIHtcbiAgbGV0IHBvcyA9IDA7XG4gIHJldHVybiB7XG4gICAgYXN5bmMgdXBUbyhsZW5ndGgpIHtcbiAgICAgIHJldHVybiBieXRlcy5zdWJhcnJheShwb3MsIHBvcyArIE1hdGgubWluKGxlbmd0aCwgYnl0ZXMubGVuZ3RoIC0gcG9zKSk7XG4gICAgfSxcbiAgICBhc3luYyBleGFjdGx5KGxlbmd0aCkge1xuICAgICAgaWYgKGxlbmd0aCA+IGJ5dGVzLmxlbmd0aCAtIHBvcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgZW5kIG9mIGRhdGEnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBieXRlcy5zdWJhcnJheShwb3MsIHBvcyArIGxlbmd0aCk7XG4gICAgfSxcbiAgICBzZWVrKGxlbmd0aCkge1xuICAgICAgcG9zICs9IGxlbmd0aDtcbiAgICB9LFxuICAgIGdldCBwb3MoKSB7XG4gICAgICByZXR1cm4gcG9zO1xuICAgIH1cbiAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjaHVua1JlYWRlcihyZWFkQ2h1bmspIHtcbiAgbGV0IHBvcyA9IDA7XG4gIGxldCBoYXZlID0gMDtcbiAgbGV0IG9mZnNldCA9IDA7XG4gIGxldCBjdXJyZW50Q2h1bmsgPSBuZXcgVWludDhBcnJheSgwKTtcbiAgY29uc3QgcmVhZCA9IGFzeW5jIGxlbmd0aCA9PiB7XG4gICAgaGF2ZSA9IGN1cnJlbnRDaHVuay5sZW5ndGggLSBvZmZzZXQ7XG4gICAgY29uc3QgYnVmYSA9IFtjdXJyZW50Q2h1bmsuc3ViYXJyYXkob2Zmc2V0KV07XG4gICAgd2hpbGUgKGhhdmUgPCBsZW5ndGgpIHtcbiAgICAgIGNvbnN0IGNodW5rID0gYXdhaXQgcmVhZENodW5rKCk7XG4gICAgICBpZiAoY2h1bmsgPT0gbnVsbCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChoYXZlIDwgMCkge1xuICAgICAgICBpZiAoY2h1bmsubGVuZ3RoID4gaGF2ZSkge1xuICAgICAgICAgIGJ1ZmEucHVzaChjaHVuay5zdWJhcnJheSgtaGF2ZSkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBidWZhLnB1c2goY2h1bmspO1xuICAgICAgfVxuICAgICAgaGF2ZSArPSBjaHVuay5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRDaHVuayA9IG5ldyBVaW50OEFycmF5KGJ1ZmEucmVkdWNlKChwLCBjKSA9PiBwICsgYy5sZW5ndGgsIDApKTtcbiAgICBsZXQgb2ZmID0gMDtcbiAgICBmb3IgKGNvbnN0IGIgb2YgYnVmYSkge1xuICAgICAgY3VycmVudENodW5rLnNldChiLCBvZmYpO1xuICAgICAgb2ZmICs9IGIubGVuZ3RoO1xuICAgIH1cbiAgICBvZmZzZXQgPSAwO1xuICB9O1xuICByZXR1cm4ge1xuICAgIGFzeW5jIHVwVG8obGVuZ3RoKSB7XG4gICAgICBpZiAoY3VycmVudENodW5rLmxlbmd0aCAtIG9mZnNldCA8IGxlbmd0aCkge1xuICAgICAgICBhd2FpdCByZWFkKGxlbmd0aCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY3VycmVudENodW5rLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgTWF0aC5taW4oY3VycmVudENodW5rLmxlbmd0aCAtIG9mZnNldCwgbGVuZ3RoKSk7XG4gICAgfSxcbiAgICBhc3luYyBleGFjdGx5KGxlbmd0aCkge1xuICAgICAgaWYgKGN1cnJlbnRDaHVuay5sZW5ndGggLSBvZmZzZXQgPCBsZW5ndGgpIHtcbiAgICAgICAgYXdhaXQgcmVhZChsZW5ndGgpO1xuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnRDaHVuay5sZW5ndGggLSBvZmZzZXQgPCBsZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIGVuZCBvZiBkYXRhJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY3VycmVudENodW5rLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgbGVuZ3RoKTtcbiAgICB9LFxuICAgIHNlZWsobGVuZ3RoKSB7XG4gICAgICBwb3MgKz0gbGVuZ3RoO1xuICAgICAgb2Zmc2V0ICs9IGxlbmd0aDtcbiAgICB9LFxuICAgIGdldCBwb3MoKSB7XG4gICAgICByZXR1cm4gcG9zO1xuICAgIH1cbiAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBhc3luY0l0ZXJhYmxlUmVhZGVyKGFzeW5jSXRlcmFibGUpIHtcbiAgY29uc3QgaXRlcmF0b3IgPSBhc3luY0l0ZXJhYmxlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpO1xuICBhc3luYyBmdW5jdGlvbiByZWFkQ2h1bmsoKSB7XG4gICAgY29uc3QgbmV4dCA9IGF3YWl0IGl0ZXJhdG9yLm5leHQoKTtcbiAgICBpZiAobmV4dC5kb25lKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIG5leHQudmFsdWU7XG4gIH1cbiAgcmV0dXJuIGNodW5rUmVhZGVyKHJlYWRDaHVuayk7XG59IiwgInZhciBlbmNvZGVfMSA9IGVuY29kZTtcbnZhciBNU0IgPSAxMjgsIFJFU1QgPSAxMjcsIE1TQkFMTCA9IH5SRVNULCBJTlQgPSBNYXRoLnBvdygyLCAzMSk7XG5mdW5jdGlvbiBlbmNvZGUobnVtLCBvdXQsIG9mZnNldCkge1xuICBvdXQgPSBvdXQgfHwgW107XG4gIG9mZnNldCA9IG9mZnNldCB8fCAwO1xuICB2YXIgb2xkT2Zmc2V0ID0gb2Zmc2V0O1xuICB3aGlsZSAobnVtID49IElOVCkge1xuICAgIG91dFtvZmZzZXQrK10gPSBudW0gJiAyNTUgfCBNU0I7XG4gICAgbnVtIC89IDEyODtcbiAgfVxuICB3aGlsZSAobnVtICYgTVNCQUxMKSB7XG4gICAgb3V0W29mZnNldCsrXSA9IG51bSAmIDI1NSB8IE1TQjtcbiAgICBudW0gPj4+PSA3O1xuICB9XG4gIG91dFtvZmZzZXRdID0gbnVtIHwgMDtcbiAgZW5jb2RlLmJ5dGVzID0gb2Zmc2V0IC0gb2xkT2Zmc2V0ICsgMTtcbiAgcmV0dXJuIG91dDtcbn1cbnZhciBkZWNvZGUgPSByZWFkO1xudmFyIE1TQiQxID0gMTI4LCBSRVNUJDEgPSAxMjc7XG5mdW5jdGlvbiByZWFkKGJ1Ziwgb2Zmc2V0KSB7XG4gIHZhciByZXMgPSAwLCBvZmZzZXQgPSBvZmZzZXQgfHwgMCwgc2hpZnQgPSAwLCBjb3VudGVyID0gb2Zmc2V0LCBiLCBsID0gYnVmLmxlbmd0aDtcbiAgZG8ge1xuICAgIGlmIChjb3VudGVyID49IGwpIHtcbiAgICAgIHJlYWQuYnl0ZXMgPSAwO1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0NvdWxkIG5vdCBkZWNvZGUgdmFyaW50Jyk7XG4gICAgfVxuICAgIGIgPSBidWZbY291bnRlcisrXTtcbiAgICByZXMgKz0gc2hpZnQgPCAyOCA/IChiICYgUkVTVCQxKSA8PCBzaGlmdCA6IChiICYgUkVTVCQxKSAqIE1hdGgucG93KDIsIHNoaWZ0KTtcbiAgICBzaGlmdCArPSA3O1xuICB9IHdoaWxlIChiID49IE1TQiQxKTtcbiAgcmVhZC5ieXRlcyA9IGNvdW50ZXIgLSBvZmZzZXQ7XG4gIHJldHVybiByZXM7XG59XG52YXIgTjEgPSBNYXRoLnBvdygyLCA3KTtcbnZhciBOMiA9IE1hdGgucG93KDIsIDE0KTtcbnZhciBOMyA9IE1hdGgucG93KDIsIDIxKTtcbnZhciBONCA9IE1hdGgucG93KDIsIDI4KTtcbnZhciBONSA9IE1hdGgucG93KDIsIDM1KTtcbnZhciBONiA9IE1hdGgucG93KDIsIDQyKTtcbnZhciBONyA9IE1hdGgucG93KDIsIDQ5KTtcbnZhciBOOCA9IE1hdGgucG93KDIsIDU2KTtcbnZhciBOOSA9IE1hdGgucG93KDIsIDYzKTtcbnZhciBsZW5ndGggPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlIDwgTjEgPyAxIDogdmFsdWUgPCBOMiA/IDIgOiB2YWx1ZSA8IE4zID8gMyA6IHZhbHVlIDwgTjQgPyA0IDogdmFsdWUgPCBONSA/IDUgOiB2YWx1ZSA8IE42ID8gNiA6IHZhbHVlIDwgTjcgPyA3IDogdmFsdWUgPCBOOCA/IDggOiB2YWx1ZSA8IE45ID8gOSA6IDEwO1xufTtcbnZhciB2YXJpbnQgPSB7XG4gIGVuY29kZTogZW5jb2RlXzEsXG4gIGRlY29kZTogZGVjb2RlLFxuICBlbmNvZGluZ0xlbmd0aDogbGVuZ3RoXG59O1xudmFyIF9icnJwX3ZhcmludCA9IHZhcmludDtcbmV4cG9ydCBkZWZhdWx0IF9icnJwX3ZhcmludDsiLCAiaW1wb3J0IHZhcmludCBmcm9tICcuLi92ZW5kb3IvdmFyaW50LmpzJztcbmV4cG9ydCBjb25zdCBkZWNvZGUgPSAoZGF0YSwgb2Zmc2V0ID0gMCkgPT4ge1xuICBjb25zdCBjb2RlID0gdmFyaW50LmRlY29kZShkYXRhLCBvZmZzZXQpO1xuICByZXR1cm4gW1xuICAgIGNvZGUsXG4gICAgdmFyaW50LmRlY29kZS5ieXRlc1xuICBdO1xufTtcbmV4cG9ydCBjb25zdCBlbmNvZGVUbyA9IChpbnQsIHRhcmdldCwgb2Zmc2V0ID0gMCkgPT4ge1xuICB2YXJpbnQuZW5jb2RlKGludCwgdGFyZ2V0LCBvZmZzZXQpO1xuICByZXR1cm4gdGFyZ2V0O1xufTtcbmV4cG9ydCBjb25zdCBlbmNvZGluZ0xlbmd0aCA9IGludCA9PiB7XG4gIHJldHVybiB2YXJpbnQuZW5jb2RpbmdMZW5ndGgoaW50KTtcbn07IiwgImNvbnN0IGVtcHR5ID0gbmV3IFVpbnQ4QXJyYXkoMCk7XG5jb25zdCB0b0hleCA9IGQgPT4gZC5yZWR1Y2UoKGhleCwgYnl0ZSkgPT4gaGV4ICsgYnl0ZS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSwgJycpO1xuY29uc3QgZnJvbUhleCA9IGhleCA9PiB7XG4gIGNvbnN0IGhleGVzID0gaGV4Lm1hdGNoKC8uLi9nKTtcbiAgcmV0dXJuIGhleGVzID8gbmV3IFVpbnQ4QXJyYXkoaGV4ZXMubWFwKGIgPT4gcGFyc2VJbnQoYiwgMTYpKSkgOiBlbXB0eTtcbn07XG5jb25zdCBlcXVhbHMgPSAoYWEsIGJiKSA9PiB7XG4gIGlmIChhYSA9PT0gYmIpXG4gICAgcmV0dXJuIHRydWU7XG4gIGlmIChhYS5ieXRlTGVuZ3RoICE9PSBiYi5ieXRlTGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAobGV0IGlpID0gMDsgaWkgPCBhYS5ieXRlTGVuZ3RoOyBpaSsrKSB7XG4gICAgaWYgKGFhW2lpXSAhPT0gYmJbaWldKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufTtcbmNvbnN0IGNvZXJjZSA9IG8gPT4ge1xuICBpZiAobyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgJiYgby5jb25zdHJ1Y3Rvci5uYW1lID09PSAnVWludDhBcnJheScpXG4gICAgcmV0dXJuIG87XG4gIGlmIChvIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpXG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG8pO1xuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KG8pKSB7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG8uYnVmZmVyLCBvLmJ5dGVPZmZzZXQsIG8uYnl0ZUxlbmd0aCk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHR5cGUsIG11c3QgYmUgYmluYXJ5IHR5cGUnKTtcbn07XG5jb25zdCBpc0JpbmFyeSA9IG8gPT4gbyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8IEFycmF5QnVmZmVyLmlzVmlldyhvKTtcbmNvbnN0IGZyb21TdHJpbmcgPSBzdHIgPT4gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHN0cik7XG5jb25zdCB0b1N0cmluZyA9IGIgPT4gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGIpO1xuZXhwb3J0IHtcbiAgZXF1YWxzLFxuICBjb2VyY2UsXG4gIGlzQmluYXJ5LFxuICBmcm9tSGV4LFxuICB0b0hleCxcbiAgZnJvbVN0cmluZyxcbiAgdG9TdHJpbmcsXG4gIGVtcHR5XG59OyIsICJpbXBvcnQge1xuICBjb2VyY2UsXG4gIGVxdWFscyBhcyBlcXVhbEJ5dGVzXG59IGZyb20gJy4uL2J5dGVzLmpzJztcbmltcG9ydCAqIGFzIHZhcmludCBmcm9tICcuLi92YXJpbnQuanMnO1xuZXhwb3J0IGNvbnN0IGNyZWF0ZSA9IChjb2RlLCBkaWdlc3QpID0+IHtcbiAgY29uc3Qgc2l6ZSA9IGRpZ2VzdC5ieXRlTGVuZ3RoO1xuICBjb25zdCBzaXplT2Zmc2V0ID0gdmFyaW50LmVuY29kaW5nTGVuZ3RoKGNvZGUpO1xuICBjb25zdCBkaWdlc3RPZmZzZXQgPSBzaXplT2Zmc2V0ICsgdmFyaW50LmVuY29kaW5nTGVuZ3RoKHNpemUpO1xuICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGRpZ2VzdE9mZnNldCArIHNpemUpO1xuICB2YXJpbnQuZW5jb2RlVG8oY29kZSwgYnl0ZXMsIDApO1xuICB2YXJpbnQuZW5jb2RlVG8oc2l6ZSwgYnl0ZXMsIHNpemVPZmZzZXQpO1xuICBieXRlcy5zZXQoZGlnZXN0LCBkaWdlc3RPZmZzZXQpO1xuICByZXR1cm4gbmV3IERpZ2VzdChjb2RlLCBzaXplLCBkaWdlc3QsIGJ5dGVzKTtcbn07XG5leHBvcnQgY29uc3QgZGVjb2RlID0gbXVsdGloYXNoID0+IHtcbiAgY29uc3QgYnl0ZXMgPSBjb2VyY2UobXVsdGloYXNoKTtcbiAgY29uc3QgW2NvZGUsIHNpemVPZmZzZXRdID0gdmFyaW50LmRlY29kZShieXRlcyk7XG4gIGNvbnN0IFtzaXplLCBkaWdlc3RPZmZzZXRdID0gdmFyaW50LmRlY29kZShieXRlcy5zdWJhcnJheShzaXplT2Zmc2V0KSk7XG4gIGNvbnN0IGRpZ2VzdCA9IGJ5dGVzLnN1YmFycmF5KHNpemVPZmZzZXQgKyBkaWdlc3RPZmZzZXQpO1xuICBpZiAoZGlnZXN0LmJ5dGVMZW5ndGggIT09IHNpemUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0luY29ycmVjdCBsZW5ndGgnKTtcbiAgfVxuICByZXR1cm4gbmV3IERpZ2VzdChjb2RlLCBzaXplLCBkaWdlc3QsIGJ5dGVzKTtcbn07XG5leHBvcnQgY29uc3QgZXF1YWxzID0gKGEsIGIpID0+IHtcbiAgaWYgKGEgPT09IGIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYS5jb2RlID09PSBiLmNvZGUgJiYgYS5zaXplID09PSBiLnNpemUgJiYgZXF1YWxCeXRlcyhhLmJ5dGVzLCBiLmJ5dGVzKTtcbiAgfVxufTtcbmV4cG9ydCBjbGFzcyBEaWdlc3Qge1xuICBjb25zdHJ1Y3Rvcihjb2RlLCBzaXplLCBkaWdlc3QsIGJ5dGVzKSB7XG4gICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICB0aGlzLnNpemUgPSBzaXplO1xuICAgIHRoaXMuZGlnZXN0ID0gZGlnZXN0O1xuICAgIHRoaXMuYnl0ZXMgPSBieXRlcztcbiAgfVxufSIsICJpbXBvcnQgeyBiYXNlWCB9IGZyb20gJy4vYmFzZS5qcyc7XG5leHBvcnQgY29uc3QgYmFzZTU4YnRjID0gYmFzZVgoe1xuICBuYW1lOiAnYmFzZTU4YnRjJyxcbiAgcHJlZml4OiAneicsXG4gIGFscGhhYmV0OiAnMTIzNDU2Nzg5QUJDREVGR0hKS0xNTlBRUlNUVVZXWFlaYWJjZGVmZ2hpamttbm9wcXJzdHV2d3h5eidcbn0pO1xuZXhwb3J0IGNvbnN0IGJhc2U1OGZsaWNrciA9IGJhc2VYKHtcbiAgbmFtZTogJ2Jhc2U1OGZsaWNrcicsXG4gIHByZWZpeDogJ1onLFxuICBhbHBoYWJldDogJzEyMzQ1Njc4OWFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXpBQkNERUZHSEpLTE1OUFFSU1RVVldYWVonXG59KTsiLCAiZnVuY3Rpb24gYmFzZShBTFBIQUJFVCwgbmFtZSkge1xuICBpZiAoQUxQSEFCRVQubGVuZ3RoID49IDI1NSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FscGhhYmV0IHRvbyBsb25nJyk7XG4gIH1cbiAgdmFyIEJBU0VfTUFQID0gbmV3IFVpbnQ4QXJyYXkoMjU2KTtcbiAgZm9yICh2YXIgaiA9IDA7IGogPCBCQVNFX01BUC5sZW5ndGg7IGorKykge1xuICAgIEJBU0VfTUFQW2pdID0gMjU1O1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgQUxQSEFCRVQubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgeCA9IEFMUEhBQkVULmNoYXJBdChpKTtcbiAgICB2YXIgeGMgPSB4LmNoYXJDb2RlQXQoMCk7XG4gICAgaWYgKEJBU0VfTUFQW3hjXSAhPT0gMjU1KSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHggKyAnIGlzIGFtYmlndW91cycpO1xuICAgIH1cbiAgICBCQVNFX01BUFt4Y10gPSBpO1xuICB9XG4gIHZhciBCQVNFID0gQUxQSEFCRVQubGVuZ3RoO1xuICB2YXIgTEVBREVSID0gQUxQSEFCRVQuY2hhckF0KDApO1xuICB2YXIgRkFDVE9SID0gTWF0aC5sb2coQkFTRSkgLyBNYXRoLmxvZygyNTYpO1xuICB2YXIgaUZBQ1RPUiA9IE1hdGgubG9nKDI1NikgLyBNYXRoLmxvZyhCQVNFKTtcbiAgZnVuY3Rpb24gZW5jb2RlKHNvdXJjZSkge1xuICAgIGlmIChzb3VyY2UgaW5zdGFuY2VvZiBVaW50OEFycmF5KTtcbiAgICBlbHNlIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoc291cmNlKSkge1xuICAgICAgc291cmNlID0gbmV3IFVpbnQ4QXJyYXkoc291cmNlLmJ1ZmZlciwgc291cmNlLmJ5dGVPZmZzZXQsIHNvdXJjZS5ieXRlTGVuZ3RoKTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoc291cmNlKSkge1xuICAgICAgc291cmNlID0gVWludDhBcnJheS5mcm9tKHNvdXJjZSk7XG4gICAgfVxuICAgIGlmICghKHNvdXJjZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBVaW50OEFycmF5Jyk7XG4gICAgfVxuICAgIGlmIChzb3VyY2UubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHZhciB6ZXJvZXMgPSAwO1xuICAgIHZhciBsZW5ndGggPSAwO1xuICAgIHZhciBwYmVnaW4gPSAwO1xuICAgIHZhciBwZW5kID0gc291cmNlLmxlbmd0aDtcbiAgICB3aGlsZSAocGJlZ2luICE9PSBwZW5kICYmIHNvdXJjZVtwYmVnaW5dID09PSAwKSB7XG4gICAgICBwYmVnaW4rKztcbiAgICAgIHplcm9lcysrO1xuICAgIH1cbiAgICB2YXIgc2l6ZSA9IChwZW5kIC0gcGJlZ2luKSAqIGlGQUNUT1IgKyAxID4+PiAwO1xuICAgIHZhciBiNTggPSBuZXcgVWludDhBcnJheShzaXplKTtcbiAgICB3aGlsZSAocGJlZ2luICE9PSBwZW5kKSB7XG4gICAgICB2YXIgY2FycnkgPSBzb3VyY2VbcGJlZ2luXTtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIGZvciAodmFyIGl0MSA9IHNpemUgLSAxOyAoY2FycnkgIT09IDAgfHwgaSA8IGxlbmd0aCkgJiYgaXQxICE9PSAtMTsgaXQxLS0sIGkrKykge1xuICAgICAgICBjYXJyeSArPSAyNTYgKiBiNThbaXQxXSA+Pj4gMDtcbiAgICAgICAgYjU4W2l0MV0gPSBjYXJyeSAlIEJBU0UgPj4+IDA7XG4gICAgICAgIGNhcnJ5ID0gY2FycnkgLyBCQVNFID4+PiAwO1xuICAgICAgfVxuICAgICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm9uLXplcm8gY2FycnknKTtcbiAgICAgIH1cbiAgICAgIGxlbmd0aCA9IGk7XG4gICAgICBwYmVnaW4rKztcbiAgICB9XG4gICAgdmFyIGl0MiA9IHNpemUgLSBsZW5ndGg7XG4gICAgd2hpbGUgKGl0MiAhPT0gc2l6ZSAmJiBiNThbaXQyXSA9PT0gMCkge1xuICAgICAgaXQyKys7XG4gICAgfVxuICAgIHZhciBzdHIgPSBMRUFERVIucmVwZWF0KHplcm9lcyk7XG4gICAgZm9yICg7IGl0MiA8IHNpemU7ICsraXQyKSB7XG4gICAgICBzdHIgKz0gQUxQSEFCRVQuY2hhckF0KGI1OFtpdDJdKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuICBmdW5jdGlvbiBkZWNvZGVVbnNhZmUoc291cmNlKSB7XG4gICAgaWYgKHR5cGVvZiBzb3VyY2UgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBTdHJpbmcnKTtcbiAgICB9XG4gICAgaWYgKHNvdXJjZS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBuZXcgVWludDhBcnJheSgpO1xuICAgIH1cbiAgICB2YXIgcHN6ID0gMDtcbiAgICBpZiAoc291cmNlW3Bzel0gPT09ICcgJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgemVyb2VzID0gMDtcbiAgICB2YXIgbGVuZ3RoID0gMDtcbiAgICB3aGlsZSAoc291cmNlW3Bzel0gPT09IExFQURFUikge1xuICAgICAgemVyb2VzKys7XG4gICAgICBwc3orKztcbiAgICB9XG4gICAgdmFyIHNpemUgPSAoc291cmNlLmxlbmd0aCAtIHBzeikgKiBGQUNUT1IgKyAxID4+PiAwO1xuICAgIHZhciBiMjU2ID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSk7XG4gICAgd2hpbGUgKHNvdXJjZVtwc3pdKSB7XG4gICAgICB2YXIgY2FycnkgPSBCQVNFX01BUFtzb3VyY2UuY2hhckNvZGVBdChwc3opXTtcbiAgICAgIGlmIChjYXJyeSA9PT0gMjU1KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBpID0gMDtcbiAgICAgIGZvciAodmFyIGl0MyA9IHNpemUgLSAxOyAoY2FycnkgIT09IDAgfHwgaSA8IGxlbmd0aCkgJiYgaXQzICE9PSAtMTsgaXQzLS0sIGkrKykge1xuICAgICAgICBjYXJyeSArPSBCQVNFICogYjI1NltpdDNdID4+PiAwO1xuICAgICAgICBiMjU2W2l0M10gPSBjYXJyeSAlIDI1NiA+Pj4gMDtcbiAgICAgICAgY2FycnkgPSBjYXJyeSAvIDI1NiA+Pj4gMDtcbiAgICAgIH1cbiAgICAgIGlmIChjYXJyeSAhPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vbi16ZXJvIGNhcnJ5Jyk7XG4gICAgICB9XG4gICAgICBsZW5ndGggPSBpO1xuICAgICAgcHN6Kys7XG4gICAgfVxuICAgIGlmIChzb3VyY2VbcHN6XSA9PT0gJyAnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBpdDQgPSBzaXplIC0gbGVuZ3RoO1xuICAgIHdoaWxlIChpdDQgIT09IHNpemUgJiYgYjI1NltpdDRdID09PSAwKSB7XG4gICAgICBpdDQrKztcbiAgICB9XG4gICAgdmFyIHZjaCA9IG5ldyBVaW50OEFycmF5KHplcm9lcyArIChzaXplIC0gaXQ0KSk7XG4gICAgdmFyIGogPSB6ZXJvZXM7XG4gICAgd2hpbGUgKGl0NCAhPT0gc2l6ZSkge1xuICAgICAgdmNoW2orK10gPSBiMjU2W2l0NCsrXTtcbiAgICB9XG4gICAgcmV0dXJuIHZjaDtcbiAgfVxuICBmdW5jdGlvbiBkZWNvZGUoc3RyaW5nKSB7XG4gICAgdmFyIGJ1ZmZlciA9IGRlY29kZVVuc2FmZShzdHJpbmcpO1xuICAgIGlmIChidWZmZXIpIHtcbiAgICAgIHJldHVybiBidWZmZXI7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgTm9uLSR7IG5hbWUgfSBjaGFyYWN0ZXJgKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGVuY29kZTogZW5jb2RlLFxuICAgIGRlY29kZVVuc2FmZTogZGVjb2RlVW5zYWZlLFxuICAgIGRlY29kZTogZGVjb2RlXG4gIH07XG59XG52YXIgc3JjID0gYmFzZTtcbnZhciBfYnJycF9fbXVsdGlmb3JtYXRzX3Njb3BlX2Jhc2VYID0gc3JjO1xuZXhwb3J0IGRlZmF1bHQgX2JycnBfX211bHRpZm9ybWF0c19zY29wZV9iYXNlWDsiLCAiaW1wb3J0IGJhc2V4IGZyb20gJy4uLy4uL3ZlbmRvci9iYXNlLXguanMnO1xuaW1wb3J0IHsgY29lcmNlIH0gZnJvbSAnLi4vYnl0ZXMuanMnO1xuY2xhc3MgRW5jb2RlciB7XG4gIGNvbnN0cnVjdG9yKG5hbWUsIHByZWZpeCwgYmFzZUVuY29kZSkge1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5wcmVmaXggPSBwcmVmaXg7XG4gICAgdGhpcy5iYXNlRW5jb2RlID0gYmFzZUVuY29kZTtcbiAgfVxuICBlbmNvZGUoYnl0ZXMpIHtcbiAgICBpZiAoYnl0ZXMgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICByZXR1cm4gYCR7IHRoaXMucHJlZml4IH0keyB0aGlzLmJhc2VFbmNvZGUoYnl0ZXMpIH1gO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBFcnJvcignVW5rbm93biB0eXBlLCBtdXN0IGJlIGJpbmFyeSB0eXBlJyk7XG4gICAgfVxuICB9XG59XG5jbGFzcyBEZWNvZGVyIHtcbiAgY29uc3RydWN0b3IobmFtZSwgcHJlZml4LCBiYXNlRGVjb2RlKSB7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLnByZWZpeCA9IHByZWZpeDtcbiAgICBpZiAocHJlZml4LmNvZGVQb2ludEF0KDApID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwcmVmaXggY2hhcmFjdGVyJyk7XG4gICAgfVxuICAgIHRoaXMucHJlZml4Q29kZVBvaW50ID0gcHJlZml4LmNvZGVQb2ludEF0KDApO1xuICAgIHRoaXMuYmFzZURlY29kZSA9IGJhc2VEZWNvZGU7XG4gIH1cbiAgZGVjb2RlKHRleHQpIHtcbiAgICBpZiAodHlwZW9mIHRleHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAodGV4dC5jb2RlUG9pbnRBdCgwKSAhPT0gdGhpcy5wcmVmaXhDb2RlUG9pbnQpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYFVuYWJsZSB0byBkZWNvZGUgbXVsdGliYXNlIHN0cmluZyAkeyBKU09OLnN0cmluZ2lmeSh0ZXh0KSB9LCAkeyB0aGlzLm5hbWUgfSBkZWNvZGVyIG9ubHkgc3VwcG9ydHMgaW5wdXRzIHByZWZpeGVkIHdpdGggJHsgdGhpcy5wcmVmaXggfWApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuYmFzZURlY29kZSh0ZXh0LnNsaWNlKHRoaXMucHJlZml4Lmxlbmd0aCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBFcnJvcignQ2FuIG9ubHkgbXVsdGliYXNlIGRlY29kZSBzdHJpbmdzJyk7XG4gICAgfVxuICB9XG4gIG9yKGRlY29kZXIpIHtcbiAgICByZXR1cm4gb3IodGhpcywgZGVjb2Rlcik7XG4gIH1cbn1cbmNsYXNzIENvbXBvc2VkRGVjb2RlciB7XG4gIGNvbnN0cnVjdG9yKGRlY29kZXJzKSB7XG4gICAgdGhpcy5kZWNvZGVycyA9IGRlY29kZXJzO1xuICB9XG4gIG9yKGRlY29kZXIpIHtcbiAgICByZXR1cm4gb3IodGhpcywgZGVjb2Rlcik7XG4gIH1cbiAgZGVjb2RlKGlucHV0KSB7XG4gICAgY29uc3QgcHJlZml4ID0gaW5wdXRbMF07XG4gICAgY29uc3QgZGVjb2RlciA9IHRoaXMuZGVjb2RlcnNbcHJlZml4XTtcbiAgICBpZiAoZGVjb2Rlcikge1xuICAgICAgcmV0dXJuIGRlY29kZXIuZGVjb2RlKGlucHV0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgUmFuZ2VFcnJvcihgVW5hYmxlIHRvIGRlY29kZSBtdWx0aWJhc2Ugc3RyaW5nICR7IEpTT04uc3RyaW5naWZ5KGlucHV0KSB9LCBvbmx5IGlucHV0cyBwcmVmaXhlZCB3aXRoICR7IE9iamVjdC5rZXlzKHRoaXMuZGVjb2RlcnMpIH0gYXJlIHN1cHBvcnRlZGApO1xuICAgIH1cbiAgfVxufVxuZXhwb3J0IGNvbnN0IG9yID0gKGxlZnQsIHJpZ2h0KSA9PiBuZXcgQ29tcG9zZWREZWNvZGVyKHtcbiAgLi4ubGVmdC5kZWNvZGVycyB8fCB7IFtsZWZ0LnByZWZpeF06IGxlZnQgfSxcbiAgLi4ucmlnaHQuZGVjb2RlcnMgfHwgeyBbcmlnaHQucHJlZml4XTogcmlnaHQgfVxufSk7XG5leHBvcnQgY2xhc3MgQ29kZWMge1xuICBjb25zdHJ1Y3RvcihuYW1lLCBwcmVmaXgsIGJhc2VFbmNvZGUsIGJhc2VEZWNvZGUpIHtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMucHJlZml4ID0gcHJlZml4O1xuICAgIHRoaXMuYmFzZUVuY29kZSA9IGJhc2VFbmNvZGU7XG4gICAgdGhpcy5iYXNlRGVjb2RlID0gYmFzZURlY29kZTtcbiAgICB0aGlzLmVuY29kZXIgPSBuZXcgRW5jb2RlcihuYW1lLCBwcmVmaXgsIGJhc2VFbmNvZGUpO1xuICAgIHRoaXMuZGVjb2RlciA9IG5ldyBEZWNvZGVyKG5hbWUsIHByZWZpeCwgYmFzZURlY29kZSk7XG4gIH1cbiAgZW5jb2RlKGlucHV0KSB7XG4gICAgcmV0dXJuIHRoaXMuZW5jb2Rlci5lbmNvZGUoaW5wdXQpO1xuICB9XG4gIGRlY29kZShpbnB1dCkge1xuICAgIHJldHVybiB0aGlzLmRlY29kZXIuZGVjb2RlKGlucHV0KTtcbiAgfVxufVxuZXhwb3J0IGNvbnN0IGZyb20gPSAoe25hbWUsIHByZWZpeCwgZW5jb2RlLCBkZWNvZGV9KSA9PiBuZXcgQ29kZWMobmFtZSwgcHJlZml4LCBlbmNvZGUsIGRlY29kZSk7XG5leHBvcnQgY29uc3QgYmFzZVggPSAoe3ByZWZpeCwgbmFtZSwgYWxwaGFiZXR9KSA9PiB7XG4gIGNvbnN0IHtlbmNvZGUsIGRlY29kZX0gPSBiYXNleChhbHBoYWJldCwgbmFtZSk7XG4gIHJldHVybiBmcm9tKHtcbiAgICBwcmVmaXgsXG4gICAgbmFtZSxcbiAgICBlbmNvZGUsXG4gICAgZGVjb2RlOiB0ZXh0ID0+IGNvZXJjZShkZWNvZGUodGV4dCkpXG4gIH0pO1xufTtcbmNvbnN0IGRlY29kZSA9IChzdHJpbmcsIGFscGhhYmV0LCBiaXRzUGVyQ2hhciwgbmFtZSkgPT4ge1xuICBjb25zdCBjb2RlcyA9IHt9O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFscGhhYmV0Lmxlbmd0aDsgKytpKSB7XG4gICAgY29kZXNbYWxwaGFiZXRbaV1dID0gaTtcbiAgfVxuICBsZXQgZW5kID0gc3RyaW5nLmxlbmd0aDtcbiAgd2hpbGUgKHN0cmluZ1tlbmQgLSAxXSA9PT0gJz0nKSB7XG4gICAgLS1lbmQ7XG4gIH1cbiAgY29uc3Qgb3V0ID0gbmV3IFVpbnQ4QXJyYXkoZW5kICogYml0c1BlckNoYXIgLyA4IHwgMCk7XG4gIGxldCBiaXRzID0gMDtcbiAgbGV0IGJ1ZmZlciA9IDA7XG4gIGxldCB3cml0dGVuID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbmQ7ICsraSkge1xuICAgIGNvbnN0IHZhbHVlID0gY29kZXNbc3RyaW5nW2ldXTtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBOb24tJHsgbmFtZSB9IGNoYXJhY3RlcmApO1xuICAgIH1cbiAgICBidWZmZXIgPSBidWZmZXIgPDwgYml0c1BlckNoYXIgfCB2YWx1ZTtcbiAgICBiaXRzICs9IGJpdHNQZXJDaGFyO1xuICAgIGlmIChiaXRzID49IDgpIHtcbiAgICAgIGJpdHMgLT0gODtcbiAgICAgIG91dFt3cml0dGVuKytdID0gMjU1ICYgYnVmZmVyID4+IGJpdHM7XG4gICAgfVxuICB9XG4gIGlmIChiaXRzID49IGJpdHNQZXJDaGFyIHx8IDI1NSAmIGJ1ZmZlciA8PCA4IC0gYml0cykge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignVW5leHBlY3RlZCBlbmQgb2YgZGF0YScpO1xuICB9XG4gIHJldHVybiBvdXQ7XG59O1xuY29uc3QgZW5jb2RlID0gKGRhdGEsIGFscGhhYmV0LCBiaXRzUGVyQ2hhcikgPT4ge1xuICBjb25zdCBwYWQgPSBhbHBoYWJldFthbHBoYWJldC5sZW5ndGggLSAxXSA9PT0gJz0nO1xuICBjb25zdCBtYXNrID0gKDEgPDwgYml0c1BlckNoYXIpIC0gMTtcbiAgbGV0IG91dCA9ICcnO1xuICBsZXQgYml0cyA9IDA7XG4gIGxldCBidWZmZXIgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICBidWZmZXIgPSBidWZmZXIgPDwgOCB8IGRhdGFbaV07XG4gICAgYml0cyArPSA4O1xuICAgIHdoaWxlIChiaXRzID4gYml0c1BlckNoYXIpIHtcbiAgICAgIGJpdHMgLT0gYml0c1BlckNoYXI7XG4gICAgICBvdXQgKz0gYWxwaGFiZXRbbWFzayAmIGJ1ZmZlciA+PiBiaXRzXTtcbiAgICB9XG4gIH1cbiAgaWYgKGJpdHMpIHtcbiAgICBvdXQgKz0gYWxwaGFiZXRbbWFzayAmIGJ1ZmZlciA8PCBiaXRzUGVyQ2hhciAtIGJpdHNdO1xuICB9XG4gIGlmIChwYWQpIHtcbiAgICB3aGlsZSAob3V0Lmxlbmd0aCAqIGJpdHNQZXJDaGFyICYgNykge1xuICAgICAgb3V0ICs9ICc9JztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG91dDtcbn07XG5leHBvcnQgY29uc3QgcmZjNDY0OCA9ICh7bmFtZSwgcHJlZml4LCBiaXRzUGVyQ2hhciwgYWxwaGFiZXR9KSA9PiB7XG4gIHJldHVybiBmcm9tKHtcbiAgICBwcmVmaXgsXG4gICAgbmFtZSxcbiAgICBlbmNvZGUoaW5wdXQpIHtcbiAgICAgIHJldHVybiBlbmNvZGUoaW5wdXQsIGFscGhhYmV0LCBiaXRzUGVyQ2hhcik7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQpIHtcbiAgICAgIHJldHVybiBkZWNvZGUoaW5wdXQsIGFscGhhYmV0LCBiaXRzUGVyQ2hhciwgbmFtZSk7XG4gICAgfVxuICB9KTtcbn07IiwgImltcG9ydCB7IHJmYzQ2NDggfSBmcm9tICcuL2Jhc2UuanMnO1xuZXhwb3J0IGNvbnN0IGJhc2UzMiA9IHJmYzQ2NDgoe1xuICBwcmVmaXg6ICdiJyxcbiAgbmFtZTogJ2Jhc2UzMicsXG4gIGFscGhhYmV0OiAnYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoyMzQ1NjcnLFxuICBiaXRzUGVyQ2hhcjogNVxufSk7XG5leHBvcnQgY29uc3QgYmFzZTMydXBwZXIgPSByZmM0NjQ4KHtcbiAgcHJlZml4OiAnQicsXG4gIG5hbWU6ICdiYXNlMzJ1cHBlcicsXG4gIGFscGhhYmV0OiAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVoyMzQ1NjcnLFxuICBiaXRzUGVyQ2hhcjogNVxufSk7XG5leHBvcnQgY29uc3QgYmFzZTMycGFkID0gcmZjNDY0OCh7XG4gIHByZWZpeDogJ2MnLFxuICBuYW1lOiAnYmFzZTMycGFkJyxcbiAgYWxwaGFiZXQ6ICdhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejIzNDU2Nz0nLFxuICBiaXRzUGVyQ2hhcjogNVxufSk7XG5leHBvcnQgY29uc3QgYmFzZTMycGFkdXBwZXIgPSByZmM0NjQ4KHtcbiAgcHJlZml4OiAnQycsXG4gIG5hbWU6ICdiYXNlMzJwYWR1cHBlcicsXG4gIGFscGhhYmV0OiAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVoyMzQ1Njc9JyxcbiAgYml0c1BlckNoYXI6IDVcbn0pO1xuZXhwb3J0IGNvbnN0IGJhc2UzMmhleCA9IHJmYzQ2NDgoe1xuICBwcmVmaXg6ICd2JyxcbiAgbmFtZTogJ2Jhc2UzMmhleCcsXG4gIGFscGhhYmV0OiAnMDEyMzQ1Njc4OWFiY2RlZmdoaWprbG1ub3BxcnN0dXYnLFxuICBiaXRzUGVyQ2hhcjogNVxufSk7XG5leHBvcnQgY29uc3QgYmFzZTMyaGV4dXBwZXIgPSByZmM0NjQ4KHtcbiAgcHJlZml4OiAnVicsXG4gIG5hbWU6ICdiYXNlMzJoZXh1cHBlcicsXG4gIGFscGhhYmV0OiAnMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVYnLFxuICBiaXRzUGVyQ2hhcjogNVxufSk7XG5leHBvcnQgY29uc3QgYmFzZTMyaGV4cGFkID0gcmZjNDY0OCh7XG4gIHByZWZpeDogJ3QnLFxuICBuYW1lOiAnYmFzZTMyaGV4cGFkJyxcbiAgYWxwaGFiZXQ6ICcwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dj0nLFxuICBiaXRzUGVyQ2hhcjogNVxufSk7XG5leHBvcnQgY29uc3QgYmFzZTMyaGV4cGFkdXBwZXIgPSByZmM0NjQ4KHtcbiAgcHJlZml4OiAnVCcsXG4gIG5hbWU6ICdiYXNlMzJoZXhwYWR1cHBlcicsXG4gIGFscGhhYmV0OiAnMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVY9JyxcbiAgYml0c1BlckNoYXI6IDVcbn0pO1xuZXhwb3J0IGNvbnN0IGJhc2UzMnogPSByZmM0NjQ4KHtcbiAgcHJlZml4OiAnaCcsXG4gIG5hbWU6ICdiYXNlMzJ6JyxcbiAgYWxwaGFiZXQ6ICd5Ym5kcmZnOGVqa21jcHF4b3QxdXdpc3phMzQ1aDc2OScsXG4gIGJpdHNQZXJDaGFyOiA1XG59KTsiLCAiaW1wb3J0ICogYXMgdmFyaW50IGZyb20gJy4vdmFyaW50LmpzJztcbmltcG9ydCAqIGFzIERpZ2VzdCBmcm9tICcuL2hhc2hlcy9kaWdlc3QuanMnO1xuaW1wb3J0IHsgYmFzZTU4YnRjIH0gZnJvbSAnLi9iYXNlcy9iYXNlNTguanMnO1xuaW1wb3J0IHsgYmFzZTMyIH0gZnJvbSAnLi9iYXNlcy9iYXNlMzIuanMnO1xuaW1wb3J0IHsgY29lcmNlIH0gZnJvbSAnLi9ieXRlcy5qcyc7XG5leHBvcnQgY2xhc3MgQ0lEIHtcbiAgY29uc3RydWN0b3IodmVyc2lvbiwgY29kZSwgbXVsdGloYXNoLCBieXRlcykge1xuICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgdGhpcy52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICB0aGlzLm11bHRpaGFzaCA9IG11bHRpaGFzaDtcbiAgICB0aGlzLmJ5dGVzID0gYnl0ZXM7XG4gICAgdGhpcy5ieXRlT2Zmc2V0ID0gYnl0ZXMuYnl0ZU9mZnNldDtcbiAgICB0aGlzLmJ5dGVMZW5ndGggPSBieXRlcy5ieXRlTGVuZ3RoO1xuICAgIHRoaXMuYXNDSUQgPSB0aGlzO1xuICAgIHRoaXMuX2Jhc2VDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICBieXRlT2Zmc2V0OiBoaWRkZW4sXG4gICAgICBieXRlTGVuZ3RoOiBoaWRkZW4sXG4gICAgICBjb2RlOiByZWFkb25seSxcbiAgICAgIHZlcnNpb246IHJlYWRvbmx5LFxuICAgICAgbXVsdGloYXNoOiByZWFkb25seSxcbiAgICAgIGJ5dGVzOiByZWFkb25seSxcbiAgICAgIF9iYXNlQ2FjaGU6IGhpZGRlbixcbiAgICAgIGFzQ0lEOiBoaWRkZW5cbiAgICB9KTtcbiAgfVxuICB0b1YwKCkge1xuICAgIHN3aXRjaCAodGhpcy52ZXJzaW9uKSB7XG4gICAgY2FzZSAwOiB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgY29uc3Qge2NvZGUsIG11bHRpaGFzaH0gPSB0aGlzO1xuICAgICAgICBpZiAoY29kZSAhPT0gREFHX1BCX0NPREUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IGEgbm9uIGRhZy1wYiBDSUQgdG8gQ0lEdjAnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobXVsdGloYXNoLmNvZGUgIT09IFNIQV8yNTZfQ09ERSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNvbnZlcnQgbm9uIHNoYTItMjU2IG11bHRpaGFzaCBDSUQgdG8gQ0lEdjAnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQ0lELmNyZWF0ZVYwKG11bHRpaGFzaCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHRvVjEoKSB7XG4gICAgc3dpdGNoICh0aGlzLnZlcnNpb24pIHtcbiAgICBjYXNlIDA6IHtcbiAgICAgICAgY29uc3Qge2NvZGUsIGRpZ2VzdH0gPSB0aGlzLm11bHRpaGFzaDtcbiAgICAgICAgY29uc3QgbXVsdGloYXNoID0gRGlnZXN0LmNyZWF0ZShjb2RlLCBkaWdlc3QpO1xuICAgICAgICByZXR1cm4gQ0lELmNyZWF0ZVYxKHRoaXMuY29kZSwgbXVsdGloYXNoKTtcbiAgICAgIH1cbiAgICBjYXNlIDE6IHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgICB0aHJvdyBFcnJvcihgQ2FuIG5vdCBjb252ZXJ0IENJRCB2ZXJzaW9uICR7IHRoaXMudmVyc2lvbiB9IHRvIHZlcnNpb24gMC4gVGhpcyBpcyBhIGJ1ZyBwbGVhc2UgcmVwb3J0YCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGVxdWFscyhvdGhlcikge1xuICAgIHJldHVybiBvdGhlciAmJiB0aGlzLmNvZGUgPT09IG90aGVyLmNvZGUgJiYgdGhpcy52ZXJzaW9uID09PSBvdGhlci52ZXJzaW9uICYmIERpZ2VzdC5lcXVhbHModGhpcy5tdWx0aWhhc2gsIG90aGVyLm11bHRpaGFzaCk7XG4gIH1cbiAgdG9TdHJpbmcoYmFzZSkge1xuICAgIGNvbnN0IHtieXRlcywgdmVyc2lvbiwgX2Jhc2VDYWNoZX0gPSB0aGlzO1xuICAgIHN3aXRjaCAodmVyc2lvbikge1xuICAgIGNhc2UgMDpcbiAgICAgIHJldHVybiB0b1N0cmluZ1YwKGJ5dGVzLCBfYmFzZUNhY2hlLCBiYXNlIHx8IGJhc2U1OGJ0Yy5lbmNvZGVyKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHRvU3RyaW5nVjEoYnl0ZXMsIF9iYXNlQ2FjaGUsIGJhc2UgfHwgYmFzZTMyLmVuY29kZXIpO1xuICAgIH1cbiAgfVxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvZGU6IHRoaXMuY29kZSxcbiAgICAgIHZlcnNpb246IHRoaXMudmVyc2lvbixcbiAgICAgIGhhc2g6IHRoaXMubXVsdGloYXNoLmJ5dGVzXG4gICAgfTtcbiAgfVxuICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG4gICAgcmV0dXJuICdDSUQnO1xuICB9XG4gIFtTeW1ib2wuZm9yKCdub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbScpXSgpIHtcbiAgICByZXR1cm4gJ0NJRCgnICsgdGhpcy50b1N0cmluZygpICsgJyknO1xuICB9XG4gIHN0YXRpYyBpc0NJRCh2YWx1ZSkge1xuICAgIGRlcHJlY2F0ZSgvXjBcXC4wLywgSVNfQ0lEX0RFUFJFQ0FUSU9OKTtcbiAgICByZXR1cm4gISEodmFsdWUgJiYgKHZhbHVlW2NpZFN5bWJvbF0gfHwgdmFsdWUuYXNDSUQgPT09IHZhbHVlKSk7XG4gIH1cbiAgZ2V0IHRvQmFzZUVuY29kZWRTdHJpbmcoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdEZXByZWNhdGVkLCB1c2UgLnRvU3RyaW5nKCknKTtcbiAgfVxuICBnZXQgY29kZWMoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdcImNvZGVjXCIgcHJvcGVydHkgaXMgZGVwcmVjYXRlZCwgdXNlIGludGVnZXIgXCJjb2RlXCIgcHJvcGVydHkgaW5zdGVhZCcpO1xuICB9XG4gIGdldCBidWZmZXIoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdEZXByZWNhdGVkIC5idWZmZXIgcHJvcGVydHksIHVzZSAuYnl0ZXMgdG8gZ2V0IFVpbnQ4QXJyYXkgaW5zdGVhZCcpO1xuICB9XG4gIGdldCBtdWx0aWJhc2VOYW1lKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignXCJtdWx0aWJhc2VOYW1lXCIgcHJvcGVydHkgaXMgZGVwcmVjYXRlZCcpO1xuICB9XG4gIGdldCBwcmVmaXgoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdcInByZWZpeFwiIHByb3BlcnR5IGlzIGRlcHJlY2F0ZWQnKTtcbiAgfVxuICBzdGF0aWMgYXNDSUQodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBDSUQpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlICE9IG51bGwgJiYgdmFsdWUuYXNDSUQgPT09IHZhbHVlKSB7XG4gICAgICBjb25zdCB7dmVyc2lvbiwgY29kZSwgbXVsdGloYXNoLCBieXRlc30gPSB2YWx1ZTtcbiAgICAgIHJldHVybiBuZXcgQ0lEKHZlcnNpb24sIGNvZGUsIG11bHRpaGFzaCwgYnl0ZXMgfHwgZW5jb2RlQ0lEKHZlcnNpb24sIGNvZGUsIG11bHRpaGFzaC5ieXRlcykpO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgIT0gbnVsbCAmJiB2YWx1ZVtjaWRTeW1ib2xdID09PSB0cnVlKSB7XG4gICAgICBjb25zdCB7dmVyc2lvbiwgbXVsdGloYXNoLCBjb2RlfSA9IHZhbHVlO1xuICAgICAgY29uc3QgZGlnZXN0ID0gRGlnZXN0LmRlY29kZShtdWx0aWhhc2gpO1xuICAgICAgcmV0dXJuIENJRC5jcmVhdGUodmVyc2lvbiwgY29kZSwgZGlnZXN0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBjcmVhdGUodmVyc2lvbiwgY29kZSwgZGlnZXN0KSB7XG4gICAgaWYgKHR5cGVvZiBjb2RlICE9PSAnbnVtYmVyJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdHJpbmcgY29kZWNzIGFyZSBubyBsb25nZXIgc3VwcG9ydGVkJyk7XG4gICAgfVxuICAgIHN3aXRjaCAodmVyc2lvbikge1xuICAgIGNhc2UgMDoge1xuICAgICAgICBpZiAoY29kZSAhPT0gREFHX1BCX0NPREUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFZlcnNpb24gMCBDSUQgbXVzdCB1c2UgZGFnLXBiIChjb2RlOiAkeyBEQUdfUEJfQ09ERSB9KSBibG9jayBlbmNvZGluZ2ApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBuZXcgQ0lEKHZlcnNpb24sIGNvZGUsIGRpZ2VzdCwgZGlnZXN0LmJ5dGVzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIGNhc2UgMToge1xuICAgICAgICBjb25zdCBieXRlcyA9IGVuY29kZUNJRCh2ZXJzaW9uLCBjb2RlLCBkaWdlc3QuYnl0ZXMpO1xuICAgICAgICByZXR1cm4gbmV3IENJRCh2ZXJzaW9uLCBjb2RlLCBkaWdlc3QsIGJ5dGVzKTtcbiAgICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB2ZXJzaW9uJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHN0YXRpYyBjcmVhdGVWMChkaWdlc3QpIHtcbiAgICByZXR1cm4gQ0lELmNyZWF0ZSgwLCBEQUdfUEJfQ09ERSwgZGlnZXN0KTtcbiAgfVxuICBzdGF0aWMgY3JlYXRlVjEoY29kZSwgZGlnZXN0KSB7XG4gICAgcmV0dXJuIENJRC5jcmVhdGUoMSwgY29kZSwgZGlnZXN0KTtcbiAgfVxuICBzdGF0aWMgZGVjb2RlKGJ5dGVzKSB7XG4gICAgY29uc3QgW2NpZCwgcmVtYWluZGVyXSA9IENJRC5kZWNvZGVGaXJzdChieXRlcyk7XG4gICAgaWYgKHJlbWFpbmRlci5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5jb3JyZWN0IGxlbmd0aCcpO1xuICAgIH1cbiAgICByZXR1cm4gY2lkO1xuICB9XG4gIHN0YXRpYyBkZWNvZGVGaXJzdChieXRlcykge1xuICAgIGNvbnN0IHNwZWNzID0gQ0lELmluc3BlY3RCeXRlcyhieXRlcyk7XG4gICAgY29uc3QgcHJlZml4U2l6ZSA9IHNwZWNzLnNpemUgLSBzcGVjcy5tdWx0aWhhc2hTaXplO1xuICAgIGNvbnN0IG11bHRpaGFzaEJ5dGVzID0gY29lcmNlKGJ5dGVzLnN1YmFycmF5KHByZWZpeFNpemUsIHByZWZpeFNpemUgKyBzcGVjcy5tdWx0aWhhc2hTaXplKSk7XG4gICAgaWYgKG11bHRpaGFzaEJ5dGVzLmJ5dGVMZW5ndGggIT09IHNwZWNzLm11bHRpaGFzaFNpemUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5jb3JyZWN0IGxlbmd0aCcpO1xuICAgIH1cbiAgICBjb25zdCBkaWdlc3RCeXRlcyA9IG11bHRpaGFzaEJ5dGVzLnN1YmFycmF5KHNwZWNzLm11bHRpaGFzaFNpemUgLSBzcGVjcy5kaWdlc3RTaXplKTtcbiAgICBjb25zdCBkaWdlc3QgPSBuZXcgRGlnZXN0LkRpZ2VzdChzcGVjcy5tdWx0aWhhc2hDb2RlLCBzcGVjcy5kaWdlc3RTaXplLCBkaWdlc3RCeXRlcywgbXVsdGloYXNoQnl0ZXMpO1xuICAgIGNvbnN0IGNpZCA9IHNwZWNzLnZlcnNpb24gPT09IDAgPyBDSUQuY3JlYXRlVjAoZGlnZXN0KSA6IENJRC5jcmVhdGVWMShzcGVjcy5jb2RlYywgZGlnZXN0KTtcbiAgICByZXR1cm4gW1xuICAgICAgY2lkLFxuICAgICAgYnl0ZXMuc3ViYXJyYXkoc3BlY3Muc2l6ZSlcbiAgICBdO1xuICB9XG4gIHN0YXRpYyBpbnNwZWN0Qnl0ZXMoaW5pdGlhbEJ5dGVzKSB7XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgY29uc3QgbmV4dCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IFtpLCBsZW5ndGhdID0gdmFyaW50LmRlY29kZShpbml0aWFsQnl0ZXMuc3ViYXJyYXkob2Zmc2V0KSk7XG4gICAgICBvZmZzZXQgKz0gbGVuZ3RoO1xuICAgICAgcmV0dXJuIGk7XG4gICAgfTtcbiAgICBsZXQgdmVyc2lvbiA9IG5leHQoKTtcbiAgICBsZXQgY29kZWMgPSBEQUdfUEJfQ09ERTtcbiAgICBpZiAodmVyc2lvbiA9PT0gMTgpIHtcbiAgICAgIHZlcnNpb24gPSAwO1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9IGVsc2UgaWYgKHZlcnNpb24gPT09IDEpIHtcbiAgICAgIGNvZGVjID0gbmV4dCgpO1xuICAgIH1cbiAgICBpZiAodmVyc2lvbiAhPT0gMCAmJiB2ZXJzaW9uICE9PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgSW52YWxpZCBDSUQgdmVyc2lvbiAkeyB2ZXJzaW9uIH1gKTtcbiAgICB9XG4gICAgY29uc3QgcHJlZml4U2l6ZSA9IG9mZnNldDtcbiAgICBjb25zdCBtdWx0aWhhc2hDb2RlID0gbmV4dCgpO1xuICAgIGNvbnN0IGRpZ2VzdFNpemUgPSBuZXh0KCk7XG4gICAgY29uc3Qgc2l6ZSA9IG9mZnNldCArIGRpZ2VzdFNpemU7XG4gICAgY29uc3QgbXVsdGloYXNoU2l6ZSA9IHNpemUgLSBwcmVmaXhTaXplO1xuICAgIHJldHVybiB7XG4gICAgICB2ZXJzaW9uLFxuICAgICAgY29kZWMsXG4gICAgICBtdWx0aWhhc2hDb2RlLFxuICAgICAgZGlnZXN0U2l6ZSxcbiAgICAgIG11bHRpaGFzaFNpemUsXG4gICAgICBzaXplXG4gICAgfTtcbiAgfVxuICBzdGF0aWMgcGFyc2Uoc291cmNlLCBiYXNlKSB7XG4gICAgY29uc3QgW3ByZWZpeCwgYnl0ZXNdID0gcGFyc2VDSUR0b0J5dGVzKHNvdXJjZSwgYmFzZSk7XG4gICAgY29uc3QgY2lkID0gQ0lELmRlY29kZShieXRlcyk7XG4gICAgY2lkLl9iYXNlQ2FjaGUuc2V0KHByZWZpeCwgc291cmNlKTtcbiAgICByZXR1cm4gY2lkO1xuICB9XG59XG5jb25zdCBwYXJzZUNJRHRvQnl0ZXMgPSAoc291cmNlLCBiYXNlKSA9PiB7XG4gIHN3aXRjaCAoc291cmNlWzBdKSB7XG4gIGNhc2UgJ1EnOiB7XG4gICAgICBjb25zdCBkZWNvZGVyID0gYmFzZSB8fCBiYXNlNThidGM7XG4gICAgICByZXR1cm4gW1xuICAgICAgICBiYXNlNThidGMucHJlZml4LFxuICAgICAgICBkZWNvZGVyLmRlY29kZShgJHsgYmFzZTU4YnRjLnByZWZpeCB9JHsgc291cmNlIH1gKVxuICAgICAgXTtcbiAgICB9XG4gIGNhc2UgYmFzZTU4YnRjLnByZWZpeDoge1xuICAgICAgY29uc3QgZGVjb2RlciA9IGJhc2UgfHwgYmFzZTU4YnRjO1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgYmFzZTU4YnRjLnByZWZpeCxcbiAgICAgICAgZGVjb2Rlci5kZWNvZGUoc291cmNlKVxuICAgICAgXTtcbiAgICB9XG4gIGNhc2UgYmFzZTMyLnByZWZpeDoge1xuICAgICAgY29uc3QgZGVjb2RlciA9IGJhc2UgfHwgYmFzZTMyO1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgYmFzZTMyLnByZWZpeCxcbiAgICAgICAgZGVjb2Rlci5kZWNvZGUoc291cmNlKVxuICAgICAgXTtcbiAgICB9XG4gIGRlZmF1bHQ6IHtcbiAgICAgIGlmIChiYXNlID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ1RvIHBhcnNlIG5vbiBiYXNlMzIgb3IgYmFzZTU4YnRjIGVuY29kZWQgQ0lEIG11bHRpYmFzZSBkZWNvZGVyIG11c3QgYmUgcHJvdmlkZWQnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbXG4gICAgICAgIHNvdXJjZVswXSxcbiAgICAgICAgYmFzZS5kZWNvZGUoc291cmNlKVxuICAgICAgXTtcbiAgICB9XG4gIH1cbn07XG5jb25zdCB0b1N0cmluZ1YwID0gKGJ5dGVzLCBjYWNoZSwgYmFzZSkgPT4ge1xuICBjb25zdCB7cHJlZml4fSA9IGJhc2U7XG4gIGlmIChwcmVmaXggIT09IGJhc2U1OGJ0Yy5wcmVmaXgpIHtcbiAgICB0aHJvdyBFcnJvcihgQ2Fubm90IHN0cmluZyBlbmNvZGUgVjAgaW4gJHsgYmFzZS5uYW1lIH0gZW5jb2RpbmdgKTtcbiAgfVxuICBjb25zdCBjaWQgPSBjYWNoZS5nZXQocHJlZml4KTtcbiAgaWYgKGNpZCA9PSBudWxsKSB7XG4gICAgY29uc3QgY2lkID0gYmFzZS5lbmNvZGUoYnl0ZXMpLnNsaWNlKDEpO1xuICAgIGNhY2hlLnNldChwcmVmaXgsIGNpZCk7XG4gICAgcmV0dXJuIGNpZDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY2lkO1xuICB9XG59O1xuY29uc3QgdG9TdHJpbmdWMSA9IChieXRlcywgY2FjaGUsIGJhc2UpID0+IHtcbiAgY29uc3Qge3ByZWZpeH0gPSBiYXNlO1xuICBjb25zdCBjaWQgPSBjYWNoZS5nZXQocHJlZml4KTtcbiAgaWYgKGNpZCA9PSBudWxsKSB7XG4gICAgY29uc3QgY2lkID0gYmFzZS5lbmNvZGUoYnl0ZXMpO1xuICAgIGNhY2hlLnNldChwcmVmaXgsIGNpZCk7XG4gICAgcmV0dXJuIGNpZDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY2lkO1xuICB9XG59O1xuY29uc3QgREFHX1BCX0NPREUgPSAxMTI7XG5jb25zdCBTSEFfMjU2X0NPREUgPSAxODtcbmNvbnN0IGVuY29kZUNJRCA9ICh2ZXJzaW9uLCBjb2RlLCBtdWx0aWhhc2gpID0+IHtcbiAgY29uc3QgY29kZU9mZnNldCA9IHZhcmludC5lbmNvZGluZ0xlbmd0aCh2ZXJzaW9uKTtcbiAgY29uc3QgaGFzaE9mZnNldCA9IGNvZGVPZmZzZXQgKyB2YXJpbnQuZW5jb2RpbmdMZW5ndGgoY29kZSk7XG4gIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoaGFzaE9mZnNldCArIG11bHRpaGFzaC5ieXRlTGVuZ3RoKTtcbiAgdmFyaW50LmVuY29kZVRvKHZlcnNpb24sIGJ5dGVzLCAwKTtcbiAgdmFyaW50LmVuY29kZVRvKGNvZGUsIGJ5dGVzLCBjb2RlT2Zmc2V0KTtcbiAgYnl0ZXMuc2V0KG11bHRpaGFzaCwgaGFzaE9mZnNldCk7XG4gIHJldHVybiBieXRlcztcbn07XG5jb25zdCBjaWRTeW1ib2wgPSBTeW1ib2wuZm9yKCdAaXBsZC9qcy1jaWQvQ0lEJyk7XG5jb25zdCByZWFkb25seSA9IHtcbiAgd3JpdGFibGU6IGZhbHNlLFxuICBjb25maWd1cmFibGU6IGZhbHNlLFxuICBlbnVtZXJhYmxlOiB0cnVlXG59O1xuY29uc3QgaGlkZGVuID0ge1xuICB3cml0YWJsZTogZmFsc2UsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBjb25maWd1cmFibGU6IGZhbHNlXG59O1xuY29uc3QgdmVyc2lvbiA9ICcwLjAuMC1kZXYnO1xuY29uc3QgZGVwcmVjYXRlID0gKHJhbmdlLCBtZXNzYWdlKSA9PiB7XG4gIGlmIChyYW5nZS50ZXN0KHZlcnNpb24pKSB7XG4gICAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgfVxufTtcbmNvbnN0IElTX0NJRF9ERVBSRUNBVElPTiA9IGBDSUQuaXNDSUQodikgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2UuXG5Gb2xsb3dpbmcgY29kZSBwYXR0ZXJuOlxuXG5pZiAoQ0lELmlzQ0lEKHZhbHVlKSkge1xuICBkb1NvbWV0aGluZ1dpdGhDSUQodmFsdWUpXG59XG5cbklzIHJlcGxhY2VkIHdpdGg6XG5cbmNvbnN0IGNpZCA9IENJRC5hc0NJRCh2YWx1ZSlcbmlmIChjaWQpIHtcbiAgLy8gTWFrZSBzdXJlIHRvIHVzZSBjaWQgaW5zdGVhZCBvZiB2YWx1ZVxuICBkb1NvbWV0aGluZ1dpdGhDSUQoY2lkKVxufVxuYDsiLCAiY29uc3QgdHlwZW9mcyA9IFtcbiAgJ3N0cmluZycsXG4gICdudW1iZXInLFxuICAnYmlnaW50JyxcbiAgJ3N5bWJvbCdcbl07XG5jb25zdCBvYmplY3RUeXBlTmFtZXMgPSBbXG4gICdGdW5jdGlvbicsXG4gICdHZW5lcmF0b3InLFxuICAnQXN5bmNHZW5lcmF0b3InLFxuICAnR2VuZXJhdG9yRnVuY3Rpb24nLFxuICAnQXN5bmNHZW5lcmF0b3JGdW5jdGlvbicsXG4gICdBc3luY0Z1bmN0aW9uJyxcbiAgJ09ic2VydmFibGUnLFxuICAnQXJyYXknLFxuICAnQnVmZmVyJyxcbiAgJ09iamVjdCcsXG4gICdSZWdFeHAnLFxuICAnRGF0ZScsXG4gICdFcnJvcicsXG4gICdNYXAnLFxuICAnU2V0JyxcbiAgJ1dlYWtNYXAnLFxuICAnV2Vha1NldCcsXG4gICdBcnJheUJ1ZmZlcicsXG4gICdTaGFyZWRBcnJheUJ1ZmZlcicsXG4gICdEYXRhVmlldycsXG4gICdQcm9taXNlJyxcbiAgJ1VSTCcsXG4gICdIVE1MRWxlbWVudCcsXG4gICdJbnQ4QXJyYXknLFxuICAnVWludDhBcnJheScsXG4gICdVaW50OENsYW1wZWRBcnJheScsXG4gICdJbnQxNkFycmF5JyxcbiAgJ1VpbnQxNkFycmF5JyxcbiAgJ0ludDMyQXJyYXknLFxuICAnVWludDMyQXJyYXknLFxuICAnRmxvYXQzMkFycmF5JyxcbiAgJ0Zsb2F0NjRBcnJheScsXG4gICdCaWdJbnQ2NEFycmF5JyxcbiAgJ0JpZ1VpbnQ2NEFycmF5J1xuXTtcbmV4cG9ydCBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gJ251bGwnO1xuICB9XG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuICd1bmRlZmluZWQnO1xuICB9XG4gIGlmICh2YWx1ZSA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gJ2Jvb2xlYW4nO1xuICB9XG4gIGNvbnN0IHR5cGVPZiA9IHR5cGVvZiB2YWx1ZTtcbiAgaWYgKHR5cGVvZnMuaW5jbHVkZXModHlwZU9mKSkge1xuICAgIHJldHVybiB0eXBlT2Y7XG4gIH1cbiAgaWYgKHR5cGVPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiAnRnVuY3Rpb24nO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiAnQXJyYXknO1xuICB9XG4gIGlmIChpc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICByZXR1cm4gJ0J1ZmZlcic7XG4gIH1cbiAgY29uc3Qgb2JqZWN0VHlwZSA9IGdldE9iamVjdFR5cGUodmFsdWUpO1xuICBpZiAob2JqZWN0VHlwZSkge1xuICAgIHJldHVybiBvYmplY3RUeXBlO1xuICB9XG4gIHJldHVybiAnT2JqZWN0Jztcbn1cbmZ1bmN0aW9uIGlzQnVmZmVyKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5pc0J1ZmZlciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5pc0J1ZmZlci5jYWxsKG51bGwsIHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGdldE9iamVjdFR5cGUodmFsdWUpIHtcbiAgY29uc3Qgb2JqZWN0VHlwZU5hbWUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLnNsaWNlKDgsIC0xKTtcbiAgaWYgKG9iamVjdFR5cGVOYW1lcy5pbmNsdWRlcyhvYmplY3RUeXBlTmFtZSkpIHtcbiAgICByZXR1cm4gb2JqZWN0VHlwZU5hbWU7XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn0iLCAiY2xhc3MgVHlwZSB7XG4gIGNvbnN0cnVjdG9yKG1ham9yLCBuYW1lLCB0ZXJtaW5hbCkge1xuICAgIHRoaXMubWFqb3IgPSBtYWpvcjtcbiAgICB0aGlzLm1ham9yRW5jb2RlZCA9IG1ham9yIDw8IDU7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLnRlcm1pbmFsID0gdGVybWluYWw7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIGBUeXBlWyR7IHRoaXMubWFqb3IgfV0uJHsgdGhpcy5uYW1lIH1gO1xuICB9XG4gIGNvbXBhcmUodHlwKSB7XG4gICAgcmV0dXJuIHRoaXMubWFqb3IgPCB0eXAubWFqb3IgPyAtMSA6IHRoaXMubWFqb3IgPiB0eXAubWFqb3IgPyAxIDogMDtcbiAgfVxufVxuVHlwZS51aW50ID0gbmV3IFR5cGUoMCwgJ3VpbnQnLCB0cnVlKTtcblR5cGUubmVnaW50ID0gbmV3IFR5cGUoMSwgJ25lZ2ludCcsIHRydWUpO1xuVHlwZS5ieXRlcyA9IG5ldyBUeXBlKDIsICdieXRlcycsIHRydWUpO1xuVHlwZS5zdHJpbmcgPSBuZXcgVHlwZSgzLCAnc3RyaW5nJywgdHJ1ZSk7XG5UeXBlLmFycmF5ID0gbmV3IFR5cGUoNCwgJ2FycmF5JywgZmFsc2UpO1xuVHlwZS5tYXAgPSBuZXcgVHlwZSg1LCAnbWFwJywgZmFsc2UpO1xuVHlwZS50YWcgPSBuZXcgVHlwZSg2LCAndGFnJywgZmFsc2UpO1xuVHlwZS5mbG9hdCA9IG5ldyBUeXBlKDcsICdmbG9hdCcsIHRydWUpO1xuVHlwZS5mYWxzZSA9IG5ldyBUeXBlKDcsICdmYWxzZScsIHRydWUpO1xuVHlwZS50cnVlID0gbmV3IFR5cGUoNywgJ3RydWUnLCB0cnVlKTtcblR5cGUubnVsbCA9IG5ldyBUeXBlKDcsICdudWxsJywgdHJ1ZSk7XG5UeXBlLnVuZGVmaW5lZCA9IG5ldyBUeXBlKDcsICd1bmRlZmluZWQnLCB0cnVlKTtcblR5cGUuYnJlYWsgPSBuZXcgVHlwZSg3LCAnYnJlYWsnLCB0cnVlKTtcbmNsYXNzIFRva2VuIHtcbiAgY29uc3RydWN0b3IodHlwZSwgdmFsdWUsIGVuY29kZWRMZW5ndGgpIHtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLmVuY29kZWRMZW5ndGggPSBlbmNvZGVkTGVuZ3RoO1xuICAgIHRoaXMuZW5jb2RlZEJ5dGVzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYnl0ZVZhbHVlID0gdW5kZWZpbmVkO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBgVG9rZW5bJHsgdGhpcy50eXBlIH1dLiR7IHRoaXMudmFsdWUgfWA7XG4gIH1cbn1cbmV4cG9ydCB7XG4gIFR5cGUsXG4gIFRva2VuXG59OyIsICJleHBvcnQgY29uc3QgdXNlQnVmZmVyID0gZ2xvYmFsVGhpcy5wcm9jZXNzICYmICFnbG9iYWxUaGlzLnByb2Nlc3MuYnJvd3NlciAmJiBnbG9iYWxUaGlzLkJ1ZmZlciAmJiB0eXBlb2YgZ2xvYmFsVGhpcy5CdWZmZXIuaXNCdWZmZXIgPT09ICdmdW5jdGlvbic7XG5jb25zdCB0ZXh0RGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xuY29uc3QgdGV4dEVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbmZ1bmN0aW9uIGlzQnVmZmVyKGJ1Zikge1xuICByZXR1cm4gdXNlQnVmZmVyICYmIGdsb2JhbFRoaXMuQnVmZmVyLmlzQnVmZmVyKGJ1Zik7XG59XG5leHBvcnQgZnVuY3Rpb24gYXNVOEEoYnVmKSB7XG4gIGlmICghKGJ1ZiBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XG4gICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShidWYpO1xuICB9XG4gIHJldHVybiBpc0J1ZmZlcihidWYpID8gbmV3IFVpbnQ4QXJyYXkoYnVmLmJ1ZmZlciwgYnVmLmJ5dGVPZmZzZXQsIGJ1Zi5ieXRlTGVuZ3RoKSA6IGJ1Zjtcbn1cbmV4cG9ydCBjb25zdCB0b1N0cmluZyA9IHVzZUJ1ZmZlciA/IChieXRlcywgc3RhcnQsIGVuZCkgPT4ge1xuICByZXR1cm4gZW5kIC0gc3RhcnQgPiA2NCA/IGdsb2JhbFRoaXMuQnVmZmVyLmZyb20oYnl0ZXMuc3ViYXJyYXkoc3RhcnQsIGVuZCkpLnRvU3RyaW5nKCd1dGY4JykgOiB1dGY4U2xpY2UoYnl0ZXMsIHN0YXJ0LCBlbmQpO1xufSA6IChieXRlcywgc3RhcnQsIGVuZCkgPT4ge1xuICByZXR1cm4gZW5kIC0gc3RhcnQgPiA2NCA/IHRleHREZWNvZGVyLmRlY29kZShieXRlcy5zdWJhcnJheShzdGFydCwgZW5kKSkgOiB1dGY4U2xpY2UoYnl0ZXMsIHN0YXJ0LCBlbmQpO1xufTtcbmV4cG9ydCBjb25zdCBmcm9tU3RyaW5nID0gdXNlQnVmZmVyID8gc3RyaW5nID0+IHtcbiAgcmV0dXJuIHN0cmluZy5sZW5ndGggPiA2NCA/IGdsb2JhbFRoaXMuQnVmZmVyLmZyb20oc3RyaW5nKSA6IHV0ZjhUb0J5dGVzKHN0cmluZyk7XG59IDogc3RyaW5nID0+IHtcbiAgcmV0dXJuIHN0cmluZy5sZW5ndGggPiA2NCA/IHRleHRFbmNvZGVyLmVuY29kZShzdHJpbmcpIDogdXRmOFRvQnl0ZXMoc3RyaW5nKTtcbn07XG5leHBvcnQgY29uc3QgZnJvbUFycmF5ID0gYXJyID0+IHtcbiAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShhcnIpO1xufTtcbmV4cG9ydCBjb25zdCBzbGljZSA9IHVzZUJ1ZmZlciA/IChieXRlcywgc3RhcnQsIGVuZCkgPT4ge1xuICBpZiAoaXNCdWZmZXIoYnl0ZXMpKSB7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ5dGVzLnN1YmFycmF5KHN0YXJ0LCBlbmQpKTtcbiAgfVxuICByZXR1cm4gYnl0ZXMuc2xpY2Uoc3RhcnQsIGVuZCk7XG59IDogKGJ5dGVzLCBzdGFydCwgZW5kKSA9PiB7XG4gIHJldHVybiBieXRlcy5zbGljZShzdGFydCwgZW5kKTtcbn07XG5leHBvcnQgY29uc3QgY29uY2F0ID0gdXNlQnVmZmVyID8gKGNodW5rcywgbGVuZ3RoKSA9PiB7XG4gIGNodW5rcyA9IGNodW5rcy5tYXAoYyA9PiBjIGluc3RhbmNlb2YgVWludDhBcnJheSA/IGMgOiBnbG9iYWxUaGlzLkJ1ZmZlci5mcm9tKGMpKTtcbiAgcmV0dXJuIGFzVThBKGdsb2JhbFRoaXMuQnVmZmVyLmNvbmNhdChjaHVua3MsIGxlbmd0aCkpO1xufSA6IChjaHVua3MsIGxlbmd0aCkgPT4ge1xuICBjb25zdCBvdXQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuICBsZXQgb2ZmID0gMDtcbiAgZm9yIChsZXQgYiBvZiBjaHVua3MpIHtcbiAgICBpZiAob2ZmICsgYi5sZW5ndGggPiBvdXQubGVuZ3RoKSB7XG4gICAgICBiID0gYi5zdWJhcnJheSgwLCBvdXQubGVuZ3RoIC0gb2ZmKTtcbiAgICB9XG4gICAgb3V0LnNldChiLCBvZmYpO1xuICAgIG9mZiArPSBiLmxlbmd0aDtcbiAgfVxuICByZXR1cm4gb3V0O1xufTtcbmV4cG9ydCBjb25zdCBhbGxvYyA9IHVzZUJ1ZmZlciA/IHNpemUgPT4ge1xuICByZXR1cm4gZ2xvYmFsVGhpcy5CdWZmZXIuYWxsb2NVbnNhZmUoc2l6ZSk7XG59IDogc2l6ZSA9PiB7XG4gIHJldHVybiBuZXcgVWludDhBcnJheShzaXplKTtcbn07XG5leHBvcnQgY29uc3QgdG9IZXggPSB1c2VCdWZmZXIgPyBkID0+IHtcbiAgaWYgKHR5cGVvZiBkID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBkO1xuICB9XG4gIHJldHVybiBnbG9iYWxUaGlzLkJ1ZmZlci5mcm9tKHRvQnl0ZXMoZCkpLnRvU3RyaW5nKCdoZXgnKTtcbn0gOiBkID0+IHtcbiAgaWYgKHR5cGVvZiBkID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBkO1xuICB9XG4gIHJldHVybiBBcnJheS5wcm90b3R5cGUucmVkdWNlLmNhbGwodG9CeXRlcyhkKSwgKHAsIGMpID0+IGAkeyBwIH0keyBjLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpIH1gLCAnJyk7XG59O1xuZXhwb3J0IGNvbnN0IGZyb21IZXggPSB1c2VCdWZmZXIgPyBoZXggPT4ge1xuICBpZiAoaGV4IGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgIHJldHVybiBoZXg7XG4gIH1cbiAgcmV0dXJuIGdsb2JhbFRoaXMuQnVmZmVyLmZyb20oaGV4LCAnaGV4Jyk7XG59IDogaGV4ID0+IHtcbiAgaWYgKGhleCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICByZXR1cm4gaGV4O1xuICB9XG4gIGlmICghaGV4Lmxlbmd0aCkge1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheSgwKTtcbiAgfVxuICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoaGV4LnNwbGl0KCcnKS5tYXAoKGMsIGksIGQpID0+IGkgJSAyID09PSAwID8gYDB4JHsgYyB9JHsgZFtpICsgMV0gfWAgOiAnJykuZmlsdGVyKEJvb2xlYW4pLm1hcChlID0+IHBhcnNlSW50KGUsIDE2KSkpO1xufTtcbmZ1bmN0aW9uIHRvQnl0ZXMob2JqKSB7XG4gIGlmIChvYmogaW5zdGFuY2VvZiBVaW50OEFycmF5ICYmIG9iai5jb25zdHJ1Y3Rvci5uYW1lID09PSAnVWludDhBcnJheScpIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG4gIGlmIChvYmogaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShvYmopO1xuICB9XG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcob2JqKSkge1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShvYmouYnVmZmVyLCBvYmouYnl0ZU9mZnNldCwgb2JqLmJ5dGVMZW5ndGgpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcignVW5rbm93biB0eXBlLCBtdXN0IGJlIGJpbmFyeSB0eXBlJyk7XG59XG5leHBvcnQgZnVuY3Rpb24gY29tcGFyZShiMSwgYjIpIHtcbiAgaWYgKGlzQnVmZmVyKGIxKSAmJiBpc0J1ZmZlcihiMikpIHtcbiAgICByZXR1cm4gYjEuY29tcGFyZShiMik7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBiMS5sZW5ndGg7IGkrKykge1xuICAgIGlmIChiMVtpXSA9PT0gYjJbaV0pIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICByZXR1cm4gYjFbaV0gPCBiMltpXSA/IC0xIDogMTtcbiAgfVxuICByZXR1cm4gMDtcbn1cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzKHN0cmluZywgdW5pdHMgPSBJbmZpbml0eSkge1xuICBsZXQgY29kZVBvaW50O1xuICBjb25zdCBsZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuICBsZXQgbGVhZFN1cnJvZ2F0ZSA9IG51bGw7XG4gIGNvbnN0IGJ5dGVzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcbiAgICBpZiAoY29kZVBvaW50ID4gNTUyOTUgJiYgY29kZVBvaW50IDwgNTczNDQpIHtcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICBpZiAoY29kZVBvaW50ID4gNTYzMTkpIHtcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpXG4gICAgICAgICAgICBieXRlcy5wdXNoKDIzOSwgMTkxLCAxODkpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpXG4gICAgICAgICAgICBieXRlcy5wdXNoKDIzOSwgMTkxLCAxODkpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKGNvZGVQb2ludCA8IDU2MzIwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSlcbiAgICAgICAgICBieXRlcy5wdXNoKDIzOSwgMTkxLCAxODkpO1xuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50O1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gNTUyOTYgPDwgMTAgfCBjb2RlUG9pbnQgLSA1NjMyMCkgKyA2NTUzNjtcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSlcbiAgICAgICAgYnl0ZXMucHVzaCgyMzksIDE5MSwgMTg5KTtcbiAgICB9XG4gICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGw7XG4gICAgaWYgKGNvZGVQb2ludCA8IDEyOCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApXG4gICAgICAgIGJyZWFrO1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpO1xuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMjA0OCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApXG4gICAgICAgIGJyZWFrO1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQgPj4gNiB8IDE5MiwgY29kZVBvaW50ICYgNjMgfCAxMjgpO1xuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgNjU1MzYpIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKVxuICAgICAgICBicmVhaztcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50ID4+IDEyIHwgMjI0LCBjb2RlUG9pbnQgPj4gNiAmIDYzIHwgMTI4LCBjb2RlUG9pbnQgJiA2MyB8IDEyOCk7XG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAxMTE0MTEyKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMClcbiAgICAgICAgYnJlYWs7XG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludCA+PiAxOCB8IDI0MCwgY29kZVBvaW50ID4+IDEyICYgNjMgfCAxMjgsIGNvZGVQb2ludCA+PiA2ICYgNjMgfCAxMjgsIGNvZGVQb2ludCAmIDYzIHwgMTI4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJ5dGVzO1xufVxuZnVuY3Rpb24gdXRmOFNsaWNlKGJ1Ziwgb2Zmc2V0LCBlbmQpIHtcbiAgY29uc3QgcmVzID0gW107XG4gIHdoaWxlIChvZmZzZXQgPCBlbmQpIHtcbiAgICBjb25zdCBmaXJzdEJ5dGUgPSBidWZbb2Zmc2V0XTtcbiAgICBsZXQgY29kZVBvaW50ID0gbnVsbDtcbiAgICBsZXQgYnl0ZXNQZXJTZXF1ZW5jZSA9IGZpcnN0Qnl0ZSA+IDIzOSA/IDQgOiBmaXJzdEJ5dGUgPiAyMjMgPyAzIDogZmlyc3RCeXRlID4gMTkxID8gMiA6IDE7XG4gICAgaWYgKG9mZnNldCArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICBsZXQgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50O1xuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIGlmIChmaXJzdEJ5dGUgPCAxMjgpIHtcbiAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGU7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHNlY29uZEJ5dGUgPSBidWZbb2Zmc2V0ICsgMV07XG4gICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDE5MikgPT09IDEyOCkge1xuICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMzEpIDw8IDYgfCBzZWNvbmRCeXRlICYgNjM7XG4gICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAxMjcpIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBzZWNvbmRCeXRlID0gYnVmW29mZnNldCArIDFdO1xuICAgICAgICB0aGlyZEJ5dGUgPSBidWZbb2Zmc2V0ICsgMl07XG4gICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDE5MikgPT09IDEyOCAmJiAodGhpcmRCeXRlICYgMTkyKSA9PT0gMTI4KSB7XG4gICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAxNSkgPDwgMTIgfCAoc2Vjb25kQnl0ZSAmIDYzKSA8PCA2IHwgdGhpcmRCeXRlICYgNjM7XG4gICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAyMDQ3ICYmICh0ZW1wQ29kZVBvaW50IDwgNTUyOTYgfHwgdGVtcENvZGVQb2ludCA+IDU3MzQzKSkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDQ6XG4gICAgICAgIHNlY29uZEJ5dGUgPSBidWZbb2Zmc2V0ICsgMV07XG4gICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltvZmZzZXQgKyAyXTtcbiAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltvZmZzZXQgKyAzXTtcbiAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMTkyKSA9PT0gMTI4ICYmICh0aGlyZEJ5dGUgJiAxOTIpID09PSAxMjggJiYgKGZvdXJ0aEJ5dGUgJiAxOTIpID09PSAxMjgpIHtcbiAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDE1KSA8PCAxOCB8IChzZWNvbmRCeXRlICYgNjMpIDw8IDEyIHwgKHRoaXJkQnl0ZSAmIDYzKSA8PCA2IHwgZm91cnRoQnl0ZSAmIDYzO1xuICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gNjU1MzUgJiYgdGVtcENvZGVQb2ludCA8IDExMTQxMTIpIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgIGNvZGVQb2ludCA9IDY1NTMzO1xuICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDE7XG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiA2NTUzNSkge1xuICAgICAgY29kZVBvaW50IC09IDY1NTM2O1xuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDEwMjMgfCA1NTI5Nik7XG4gICAgICBjb2RlUG9pbnQgPSA1NjMyMCB8IGNvZGVQb2ludCAmIDEwMjM7XG4gICAgfVxuICAgIHJlcy5wdXNoKGNvZGVQb2ludCk7XG4gICAgb2Zmc2V0ICs9IGJ5dGVzUGVyU2VxdWVuY2U7XG4gIH1cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpO1xufVxuY29uc3QgTUFYX0FSR1VNRU5UU19MRU5HVEggPSA0MDk2O1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheShjb2RlUG9pbnRzKSB7XG4gIGNvbnN0IGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoO1xuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKTtcbiAgfVxuICBsZXQgcmVzID0gJyc7XG4gIGxldCBpID0gMDtcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkpO1xuICB9XG4gIHJldHVybiByZXM7XG59IiwgImltcG9ydCB7XG4gIGFsbG9jLFxuICBjb25jYXQsXG4gIHNsaWNlXG59IGZyb20gJy4vYnl0ZS11dGlscy5qcyc7XG5jb25zdCBkZWZhdWx0Q2h1bmtTaXplID0gMjU2O1xuZXhwb3J0IGNsYXNzIEJsIHtcbiAgY29uc3RydWN0b3IoY2h1bmtTaXplID0gZGVmYXVsdENodW5rU2l6ZSkge1xuICAgIHRoaXMuY2h1bmtTaXplID0gY2h1bmtTaXplO1xuICAgIHRoaXMuY3Vyc29yID0gMDtcbiAgICB0aGlzLm1heEN1cnNvciA9IC0xO1xuICAgIHRoaXMuY2h1bmtzID0gW107XG4gICAgdGhpcy5faW5pdFJldXNlQ2h1bmsgPSBudWxsO1xuICB9XG4gIHJlc2V0KCkge1xuICAgIHRoaXMuY3Vyc29yID0gMDtcbiAgICB0aGlzLm1heEN1cnNvciA9IC0xO1xuICAgIGlmICh0aGlzLmNodW5rcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuY2h1bmtzID0gW107XG4gICAgfVxuICAgIGlmICh0aGlzLl9pbml0UmV1c2VDaHVuayAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5jaHVua3MucHVzaCh0aGlzLl9pbml0UmV1c2VDaHVuayk7XG4gICAgICB0aGlzLm1heEN1cnNvciA9IHRoaXMuX2luaXRSZXVzZUNodW5rLmxlbmd0aCAtIDE7XG4gICAgfVxuICB9XG4gIHB1c2goYnl0ZXMpIHtcbiAgICBsZXQgdG9wQ2h1bmsgPSB0aGlzLmNodW5rc1t0aGlzLmNodW5rcy5sZW5ndGggLSAxXTtcbiAgICBjb25zdCBuZXdNYXggPSB0aGlzLmN1cnNvciArIGJ5dGVzLmxlbmd0aDtcbiAgICBpZiAobmV3TWF4IDw9IHRoaXMubWF4Q3Vyc29yICsgMSkge1xuICAgICAgY29uc3QgY2h1bmtQb3MgPSB0b3BDaHVuay5sZW5ndGggLSAodGhpcy5tYXhDdXJzb3IgLSB0aGlzLmN1cnNvcikgLSAxO1xuICAgICAgdG9wQ2h1bmsuc2V0KGJ5dGVzLCBjaHVua1Bvcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0b3BDaHVuaykge1xuICAgICAgICBjb25zdCBjaHVua1BvcyA9IHRvcENodW5rLmxlbmd0aCAtICh0aGlzLm1heEN1cnNvciAtIHRoaXMuY3Vyc29yKSAtIDE7XG4gICAgICAgIGlmIChjaHVua1BvcyA8IHRvcENodW5rLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMuY2h1bmtzW3RoaXMuY2h1bmtzLmxlbmd0aCAtIDFdID0gdG9wQ2h1bmsuc3ViYXJyYXkoMCwgY2h1bmtQb3MpO1xuICAgICAgICAgIHRoaXMubWF4Q3Vyc29yID0gdGhpcy5jdXJzb3IgLSAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoYnl0ZXMubGVuZ3RoIDwgNjQgJiYgYnl0ZXMubGVuZ3RoIDwgdGhpcy5jaHVua1NpemUpIHtcbiAgICAgICAgdG9wQ2h1bmsgPSBhbGxvYyh0aGlzLmNodW5rU2l6ZSk7XG4gICAgICAgIHRoaXMuY2h1bmtzLnB1c2godG9wQ2h1bmspO1xuICAgICAgICB0aGlzLm1heEN1cnNvciArPSB0b3BDaHVuay5sZW5ndGg7XG4gICAgICAgIGlmICh0aGlzLl9pbml0UmV1c2VDaHVuayA9PT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMuX2luaXRSZXVzZUNodW5rID0gdG9wQ2h1bms7XG4gICAgICAgIH1cbiAgICAgICAgdG9wQ2h1bmsuc2V0KGJ5dGVzLCAwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2h1bmtzLnB1c2goYnl0ZXMpO1xuICAgICAgICB0aGlzLm1heEN1cnNvciArPSBieXRlcy5sZW5ndGg7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuY3Vyc29yICs9IGJ5dGVzLmxlbmd0aDtcbiAgfVxuICB0b0J5dGVzKHJlc2V0ID0gZmFsc2UpIHtcbiAgICBsZXQgYnl0cztcbiAgICBpZiAodGhpcy5jaHVua3MubGVuZ3RoID09PSAxKSB7XG4gICAgICBjb25zdCBjaHVuayA9IHRoaXMuY2h1bmtzWzBdO1xuICAgICAgaWYgKHJlc2V0ICYmIHRoaXMuY3Vyc29yID4gY2h1bmsubGVuZ3RoIC8gMikge1xuICAgICAgICBieXRzID0gdGhpcy5jdXJzb3IgPT09IGNodW5rLmxlbmd0aCA/IGNodW5rIDogY2h1bmsuc3ViYXJyYXkoMCwgdGhpcy5jdXJzb3IpO1xuICAgICAgICB0aGlzLl9pbml0UmV1c2VDaHVuayA9IG51bGw7XG4gICAgICAgIHRoaXMuY2h1bmtzID0gW107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBieXRzID0gc2xpY2UoY2h1bmssIDAsIHRoaXMuY3Vyc29yKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYnl0cyA9IGNvbmNhdCh0aGlzLmNodW5rcywgdGhpcy5jdXJzb3IpO1xuICAgIH1cbiAgICBpZiAocmVzZXQpIHtcbiAgICAgIHRoaXMucmVzZXQoKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ5dHM7XG4gIH1cbn0iLCAiY29uc3QgZGVjb2RlRXJyUHJlZml4ID0gJ0NCT1IgZGVjb2RlIGVycm9yOic7XG5jb25zdCBlbmNvZGVFcnJQcmVmaXggPSAnQ0JPUiBlbmNvZGUgZXJyb3I6JztcbmNvbnN0IHVpbnRNaW5vclByZWZpeEJ5dGVzID0gW107XG51aW50TWlub3JQcmVmaXhCeXRlc1syM10gPSAxO1xudWludE1pbm9yUHJlZml4Qnl0ZXNbMjRdID0gMjtcbnVpbnRNaW5vclByZWZpeEJ5dGVzWzI1XSA9IDM7XG51aW50TWlub3JQcmVmaXhCeXRlc1syNl0gPSA1O1xudWludE1pbm9yUHJlZml4Qnl0ZXNbMjddID0gOTtcbmZ1bmN0aW9uIGFzc2VydEVub3VnaERhdGEoZGF0YSwgcG9zLCBuZWVkKSB7XG4gIGlmIChkYXRhLmxlbmd0aCAtIHBvcyA8IG5lZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7IGRlY29kZUVyclByZWZpeCB9IG5vdCBlbm91Z2ggZGF0YSBmb3IgdHlwZWApO1xuICB9XG59XG5leHBvcnQge1xuICBkZWNvZGVFcnJQcmVmaXgsXG4gIGVuY29kZUVyclByZWZpeCxcbiAgdWludE1pbm9yUHJlZml4Qnl0ZXMsXG4gIGFzc2VydEVub3VnaERhdGFcbn07IiwgImltcG9ydCB7XG4gIFRva2VuLFxuICBUeXBlXG59IGZyb20gJy4vdG9rZW4uanMnO1xuaW1wb3J0IHtcbiAgZGVjb2RlRXJyUHJlZml4LFxuICBhc3NlcnRFbm91Z2hEYXRhXG59IGZyb20gJy4vY29tbW9uLmpzJztcbmV4cG9ydCBjb25zdCB1aW50Qm91bmRhcmllcyA9IFtcbiAgMjQsXG4gIDI1NixcbiAgNjU1MzYsXG4gIDQyOTQ5NjcyOTYsXG4gIEJpZ0ludCgnMTg0NDY3NDQwNzM3MDk1NTE2MTYnKVxuXTtcbmV4cG9ydCBmdW5jdGlvbiByZWFkVWludDgoZGF0YSwgb2Zmc2V0LCBvcHRpb25zKSB7XG4gIGFzc2VydEVub3VnaERhdGEoZGF0YSwgb2Zmc2V0LCAxKTtcbiAgY29uc3QgdmFsdWUgPSBkYXRhW29mZnNldF07XG4gIGlmIChvcHRpb25zLnN0cmljdCA9PT0gdHJ1ZSAmJiB2YWx1ZSA8IHVpbnRCb3VuZGFyaWVzWzBdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGAkeyBkZWNvZGVFcnJQcmVmaXggfSBpbnRlZ2VyIGVuY29kZWQgaW4gbW9yZSBieXRlcyB0aGFuIG5lY2Vzc2FyeSAoc3RyaWN0IGRlY29kZSlgKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5leHBvcnQgZnVuY3Rpb24gcmVhZFVpbnQxNihkYXRhLCBvZmZzZXQsIG9wdGlvbnMpIHtcbiAgYXNzZXJ0RW5vdWdoRGF0YShkYXRhLCBvZmZzZXQsIDIpO1xuICBjb25zdCB2YWx1ZSA9IGRhdGFbb2Zmc2V0XSA8PCA4IHwgZGF0YVtvZmZzZXQgKyAxXTtcbiAgaWYgKG9wdGlvbnMuc3RyaWN0ID09PSB0cnVlICYmIHZhbHVlIDwgdWludEJvdW5kYXJpZXNbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7IGRlY29kZUVyclByZWZpeCB9IGludGVnZXIgZW5jb2RlZCBpbiBtb3JlIGJ5dGVzIHRoYW4gbmVjZXNzYXJ5IChzdHJpY3QgZGVjb2RlKWApO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiByZWFkVWludDMyKGRhdGEsIG9mZnNldCwgb3B0aW9ucykge1xuICBhc3NlcnRFbm91Z2hEYXRhKGRhdGEsIG9mZnNldCwgNCk7XG4gIGNvbnN0IHZhbHVlID0gZGF0YVtvZmZzZXRdICogMTY3NzcyMTYgKyAoZGF0YVtvZmZzZXQgKyAxXSA8PCAxNikgKyAoZGF0YVtvZmZzZXQgKyAyXSA8PCA4KSArIGRhdGFbb2Zmc2V0ICsgM107XG4gIGlmIChvcHRpb25zLnN0cmljdCA9PT0gdHJ1ZSAmJiB2YWx1ZSA8IHVpbnRCb3VuZGFyaWVzWzJdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGAkeyBkZWNvZGVFcnJQcmVmaXggfSBpbnRlZ2VyIGVuY29kZWQgaW4gbW9yZSBieXRlcyB0aGFuIG5lY2Vzc2FyeSAoc3RyaWN0IGRlY29kZSlgKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5leHBvcnQgZnVuY3Rpb24gcmVhZFVpbnQ2NChkYXRhLCBvZmZzZXQsIG9wdGlvbnMpIHtcbiAgYXNzZXJ0RW5vdWdoRGF0YShkYXRhLCBvZmZzZXQsIDgpO1xuICBjb25zdCBoaSA9IGRhdGFbb2Zmc2V0XSAqIDE2Nzc3MjE2ICsgKGRhdGFbb2Zmc2V0ICsgMV0gPDwgMTYpICsgKGRhdGFbb2Zmc2V0ICsgMl0gPDwgOCkgKyBkYXRhW29mZnNldCArIDNdO1xuICBjb25zdCBsbyA9IGRhdGFbb2Zmc2V0ICsgNF0gKiAxNjc3NzIxNiArIChkYXRhW29mZnNldCArIDVdIDw8IDE2KSArIChkYXRhW29mZnNldCArIDZdIDw8IDgpICsgZGF0YVtvZmZzZXQgKyA3XTtcbiAgY29uc3QgdmFsdWUgPSAoQmlnSW50KGhpKSA8PCBCaWdJbnQoMzIpKSArIEJpZ0ludChsbyk7XG4gIGlmIChvcHRpb25zLnN0cmljdCA9PT0gdHJ1ZSAmJiB2YWx1ZSA8IHVpbnRCb3VuZGFyaWVzWzNdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGAkeyBkZWNvZGVFcnJQcmVmaXggfSBpbnRlZ2VyIGVuY29kZWQgaW4gbW9yZSBieXRlcyB0aGFuIG5lY2Vzc2FyeSAoc3RyaWN0IGRlY29kZSlgKTtcbiAgfVxuICBpZiAodmFsdWUgPD0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICByZXR1cm4gTnVtYmVyKHZhbHVlKTtcbiAgfVxuICBpZiAob3B0aW9ucy5hbGxvd0JpZ0ludCA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoYCR7IGRlY29kZUVyclByZWZpeCB9IGludGVnZXJzIG91dHNpZGUgb2YgdGhlIHNhZmUgaW50ZWdlciByYW5nZSBhcmUgbm90IHN1cHBvcnRlZGApO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZVVpbnQ4KGRhdGEsIHBvcywgX21pbm9yLCBvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgVG9rZW4oVHlwZS51aW50LCByZWFkVWludDgoZGF0YSwgcG9zICsgMSwgb3B0aW9ucyksIDIpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZVVpbnQxNihkYXRhLCBwb3MsIF9taW5vciwgb3B0aW9ucykge1xuICByZXR1cm4gbmV3IFRva2VuKFR5cGUudWludCwgcmVhZFVpbnQxNihkYXRhLCBwb3MgKyAxLCBvcHRpb25zKSwgMyk7XG59XG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlVWludDMyKGRhdGEsIHBvcywgX21pbm9yLCBvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgVG9rZW4oVHlwZS51aW50LCByZWFkVWludDMyKGRhdGEsIHBvcyArIDEsIG9wdGlvbnMpLCA1KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVVaW50NjQoZGF0YSwgcG9zLCBfbWlub3IsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBUb2tlbihUeXBlLnVpbnQsIHJlYWRVaW50NjQoZGF0YSwgcG9zICsgMSwgb3B0aW9ucyksIDkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZVVpbnQoYnVmLCB0b2tlbikge1xuICByZXR1cm4gZW5jb2RlVWludFZhbHVlKGJ1ZiwgMCwgdG9rZW4udmFsdWUpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZVVpbnRWYWx1ZShidWYsIG1ham9yLCB1aW50KSB7XG4gIGlmICh1aW50IDwgdWludEJvdW5kYXJpZXNbMF0pIHtcbiAgICBjb25zdCBudWludCA9IE51bWJlcih1aW50KTtcbiAgICBidWYucHVzaChbbWFqb3IgfCBudWludF0pO1xuICB9IGVsc2UgaWYgKHVpbnQgPCB1aW50Qm91bmRhcmllc1sxXSkge1xuICAgIGNvbnN0IG51aW50ID0gTnVtYmVyKHVpbnQpO1xuICAgIGJ1Zi5wdXNoKFtcbiAgICAgIG1ham9yIHwgMjQsXG4gICAgICBudWludFxuICAgIF0pO1xuICB9IGVsc2UgaWYgKHVpbnQgPCB1aW50Qm91bmRhcmllc1syXSkge1xuICAgIGNvbnN0IG51aW50ID0gTnVtYmVyKHVpbnQpO1xuICAgIGJ1Zi5wdXNoKFtcbiAgICAgIG1ham9yIHwgMjUsXG4gICAgICBudWludCA+Pj4gOCxcbiAgICAgIG51aW50ICYgMjU1XG4gICAgXSk7XG4gIH0gZWxzZSBpZiAodWludCA8IHVpbnRCb3VuZGFyaWVzWzNdKSB7XG4gICAgY29uc3QgbnVpbnQgPSBOdW1iZXIodWludCk7XG4gICAgYnVmLnB1c2goW1xuICAgICAgbWFqb3IgfCAyNixcbiAgICAgIG51aW50ID4+PiAyNCAmIDI1NSxcbiAgICAgIG51aW50ID4+PiAxNiAmIDI1NSxcbiAgICAgIG51aW50ID4+PiA4ICYgMjU1LFxuICAgICAgbnVpbnQgJiAyNTVcbiAgICBdKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBidWludCA9IEJpZ0ludCh1aW50KTtcbiAgICBpZiAoYnVpbnQgPCB1aW50Qm91bmRhcmllc1s0XSkge1xuICAgICAgY29uc3Qgc2V0ID0gW1xuICAgICAgICBtYWpvciB8IDI3LFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwXG4gICAgICBdO1xuICAgICAgbGV0IGxvID0gTnVtYmVyKGJ1aW50ICYgQmlnSW50KDQyOTQ5NjcyOTUpKTtcbiAgICAgIGxldCBoaSA9IE51bWJlcihidWludCA+PiBCaWdJbnQoMzIpICYgQmlnSW50KDQyOTQ5NjcyOTUpKTtcbiAgICAgIHNldFs4XSA9IGxvICYgMjU1O1xuICAgICAgbG8gPSBsbyA+PiA4O1xuICAgICAgc2V0WzddID0gbG8gJiAyNTU7XG4gICAgICBsbyA9IGxvID4+IDg7XG4gICAgICBzZXRbNl0gPSBsbyAmIDI1NTtcbiAgICAgIGxvID0gbG8gPj4gODtcbiAgICAgIHNldFs1XSA9IGxvICYgMjU1O1xuICAgICAgc2V0WzRdID0gaGkgJiAyNTU7XG4gICAgICBoaSA9IGhpID4+IDg7XG4gICAgICBzZXRbM10gPSBoaSAmIDI1NTtcbiAgICAgIGhpID0gaGkgPj4gODtcbiAgICAgIHNldFsyXSA9IGhpICYgMjU1O1xuICAgICAgaGkgPSBoaSA+PiA4O1xuICAgICAgc2V0WzFdID0gaGkgJiAyNTU7XG4gICAgICBidWYucHVzaChzZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7IGRlY29kZUVyclByZWZpeCB9IGVuY291bnRlcmVkIEJpZ0ludCBsYXJnZXIgdGhhbiBhbGxvd2FibGUgcmFuZ2VgKTtcbiAgICB9XG4gIH1cbn1cbmVuY29kZVVpbnQuZW5jb2RlZFNpemUgPSBmdW5jdGlvbiBlbmNvZGVkU2l6ZSh0b2tlbikge1xuICByZXR1cm4gZW5jb2RlVWludFZhbHVlLmVuY29kZWRTaXplKHRva2VuLnZhbHVlKTtcbn07XG5lbmNvZGVVaW50VmFsdWUuZW5jb2RlZFNpemUgPSBmdW5jdGlvbiBlbmNvZGVkU2l6ZSh1aW50KSB7XG4gIGlmICh1aW50IDwgdWludEJvdW5kYXJpZXNbMF0pIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICBpZiAodWludCA8IHVpbnRCb3VuZGFyaWVzWzFdKSB7XG4gICAgcmV0dXJuIDI7XG4gIH1cbiAgaWYgKHVpbnQgPCB1aW50Qm91bmRhcmllc1syXSkge1xuICAgIHJldHVybiAzO1xuICB9XG4gIGlmICh1aW50IDwgdWludEJvdW5kYXJpZXNbM10pIHtcbiAgICByZXR1cm4gNTtcbiAgfVxuICByZXR1cm4gOTtcbn07XG5lbmNvZGVVaW50LmNvbXBhcmVUb2tlbnMgPSBmdW5jdGlvbiBjb21wYXJlVG9rZW5zKHRvazEsIHRvazIpIHtcbiAgcmV0dXJuIHRvazEudmFsdWUgPCB0b2syLnZhbHVlID8gLTEgOiB0b2sxLnZhbHVlID4gdG9rMi52YWx1ZSA/IDEgOiAwO1xufTsiLCAiaW1wb3J0IHtcbiAgVG9rZW4sXG4gIFR5cGVcbn0gZnJvbSAnLi90b2tlbi5qcyc7XG5pbXBvcnQgKiBhcyB1aW50IGZyb20gJy4vMHVpbnQuanMnO1xuaW1wb3J0IHsgZGVjb2RlRXJyUHJlZml4IH0gZnJvbSAnLi9jb21tb24uanMnO1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZU5lZ2ludDgoZGF0YSwgcG9zLCBfbWlub3IsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBUb2tlbihUeXBlLm5lZ2ludCwgLTEgLSB1aW50LnJlYWRVaW50OChkYXRhLCBwb3MgKyAxLCBvcHRpb25zKSwgMik7XG59XG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlTmVnaW50MTYoZGF0YSwgcG9zLCBfbWlub3IsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBUb2tlbihUeXBlLm5lZ2ludCwgLTEgLSB1aW50LnJlYWRVaW50MTYoZGF0YSwgcG9zICsgMSwgb3B0aW9ucyksIDMpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZU5lZ2ludDMyKGRhdGEsIHBvcywgX21pbm9yLCBvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgVG9rZW4oVHlwZS5uZWdpbnQsIC0xIC0gdWludC5yZWFkVWludDMyKGRhdGEsIHBvcyArIDEsIG9wdGlvbnMpLCA1KTtcbn1cbmNvbnN0IG5lZzFiID0gQmlnSW50KC0xKTtcbmNvbnN0IHBvczFiID0gQmlnSW50KDEpO1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZU5lZ2ludDY0KGRhdGEsIHBvcywgX21pbm9yLCBvcHRpb25zKSB7XG4gIGNvbnN0IGludCA9IHVpbnQucmVhZFVpbnQ2NChkYXRhLCBwb3MgKyAxLCBvcHRpb25zKTtcbiAgaWYgKHR5cGVvZiBpbnQgIT09ICdiaWdpbnQnKSB7XG4gICAgY29uc3QgdmFsdWUgPSAtMSAtIGludDtcbiAgICBpZiAodmFsdWUgPj0gTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIpIHtcbiAgICAgIHJldHVybiBuZXcgVG9rZW4oVHlwZS5uZWdpbnQsIHZhbHVlLCA5KTtcbiAgICB9XG4gIH1cbiAgaWYgKG9wdGlvbnMuYWxsb3dCaWdJbnQgIT09IHRydWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7IGRlY29kZUVyclByZWZpeCB9IGludGVnZXJzIG91dHNpZGUgb2YgdGhlIHNhZmUgaW50ZWdlciByYW5nZSBhcmUgbm90IHN1cHBvcnRlZGApO1xuICB9XG4gIHJldHVybiBuZXcgVG9rZW4oVHlwZS5uZWdpbnQsIG5lZzFiIC0gQmlnSW50KGludCksIDkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZU5lZ2ludChidWYsIHRva2VuKSB7XG4gIGNvbnN0IG5lZ2ludCA9IHRva2VuLnZhbHVlO1xuICBjb25zdCB1bnNpZ25lZCA9IHR5cGVvZiBuZWdpbnQgPT09ICdiaWdpbnQnID8gbmVnaW50ICogbmVnMWIgLSBwb3MxYiA6IG5lZ2ludCAqIC0xIC0gMTtcbiAgdWludC5lbmNvZGVVaW50VmFsdWUoYnVmLCB0b2tlbi50eXBlLm1ham9yRW5jb2RlZCwgdW5zaWduZWQpO1xufVxuZW5jb2RlTmVnaW50LmVuY29kZWRTaXplID0gZnVuY3Rpb24gZW5jb2RlZFNpemUodG9rZW4pIHtcbiAgY29uc3QgbmVnaW50ID0gdG9rZW4udmFsdWU7XG4gIGNvbnN0IHVuc2lnbmVkID0gdHlwZW9mIG5lZ2ludCA9PT0gJ2JpZ2ludCcgPyBuZWdpbnQgKiBuZWcxYiAtIHBvczFiIDogbmVnaW50ICogLTEgLSAxO1xuICBpZiAodW5zaWduZWQgPCB1aW50LnVpbnRCb3VuZGFyaWVzWzBdKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgaWYgKHVuc2lnbmVkIDwgdWludC51aW50Qm91bmRhcmllc1sxXSkge1xuICAgIHJldHVybiAyO1xuICB9XG4gIGlmICh1bnNpZ25lZCA8IHVpbnQudWludEJvdW5kYXJpZXNbMl0pIHtcbiAgICByZXR1cm4gMztcbiAgfVxuICBpZiAodW5zaWduZWQgPCB1aW50LnVpbnRCb3VuZGFyaWVzWzNdKSB7XG4gICAgcmV0dXJuIDU7XG4gIH1cbiAgcmV0dXJuIDk7XG59O1xuZW5jb2RlTmVnaW50LmNvbXBhcmVUb2tlbnMgPSBmdW5jdGlvbiBjb21wYXJlVG9rZW5zKHRvazEsIHRvazIpIHtcbiAgcmV0dXJuIHRvazEudmFsdWUgPCB0b2syLnZhbHVlID8gMSA6IHRvazEudmFsdWUgPiB0b2syLnZhbHVlID8gLTEgOiAwO1xufTsiLCAiaW1wb3J0IHtcbiAgVG9rZW4sXG4gIFR5cGVcbn0gZnJvbSAnLi90b2tlbi5qcyc7XG5pbXBvcnQge1xuICBhc3NlcnRFbm91Z2hEYXRhLFxuICBkZWNvZGVFcnJQcmVmaXhcbn0gZnJvbSAnLi9jb21tb24uanMnO1xuaW1wb3J0ICogYXMgdWludCBmcm9tICcuLzB1aW50LmpzJztcbmltcG9ydCB7XG4gIGNvbXBhcmUsXG4gIGZyb21TdHJpbmcsXG4gIHNsaWNlXG59IGZyb20gJy4vYnl0ZS11dGlscy5qcyc7XG5mdW5jdGlvbiB0b1Rva2VuKGRhdGEsIHBvcywgcHJlZml4LCBsZW5ndGgpIHtcbiAgYXNzZXJ0RW5vdWdoRGF0YShkYXRhLCBwb3MsIHByZWZpeCArIGxlbmd0aCk7XG4gIGNvbnN0IGJ1ZiA9IHNsaWNlKGRhdGEsIHBvcyArIHByZWZpeCwgcG9zICsgcHJlZml4ICsgbGVuZ3RoKTtcbiAgcmV0dXJuIG5ldyBUb2tlbihUeXBlLmJ5dGVzLCBidWYsIHByZWZpeCArIGxlbmd0aCk7XG59XG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlQnl0ZXNDb21wYWN0KGRhdGEsIHBvcywgbWlub3IsIF9vcHRpb25zKSB7XG4gIHJldHVybiB0b1Rva2VuKGRhdGEsIHBvcywgMSwgbWlub3IpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZUJ5dGVzOChkYXRhLCBwb3MsIF9taW5vciwgb3B0aW9ucykge1xuICByZXR1cm4gdG9Ub2tlbihkYXRhLCBwb3MsIDIsIHVpbnQucmVhZFVpbnQ4KGRhdGEsIHBvcyArIDEsIG9wdGlvbnMpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVCeXRlczE2KGRhdGEsIHBvcywgX21pbm9yLCBvcHRpb25zKSB7XG4gIHJldHVybiB0b1Rva2VuKGRhdGEsIHBvcywgMywgdWludC5yZWFkVWludDE2KGRhdGEsIHBvcyArIDEsIG9wdGlvbnMpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVCeXRlczMyKGRhdGEsIHBvcywgX21pbm9yLCBvcHRpb25zKSB7XG4gIHJldHVybiB0b1Rva2VuKGRhdGEsIHBvcywgNSwgdWludC5yZWFkVWludDMyKGRhdGEsIHBvcyArIDEsIG9wdGlvbnMpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVCeXRlczY0KGRhdGEsIHBvcywgX21pbm9yLCBvcHRpb25zKSB7XG4gIGNvbnN0IGwgPSB1aW50LnJlYWRVaW50NjQoZGF0YSwgcG9zICsgMSwgb3B0aW9ucyk7XG4gIGlmICh0eXBlb2YgbCA9PT0gJ2JpZ2ludCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7IGRlY29kZUVyclByZWZpeCB9IDY0LWJpdCBpbnRlZ2VyIGJ5dGVzIGxlbmd0aHMgbm90IHN1cHBvcnRlZGApO1xuICB9XG4gIHJldHVybiB0b1Rva2VuKGRhdGEsIHBvcywgOSwgbCk7XG59XG5mdW5jdGlvbiB0b2tlbkJ5dGVzKHRva2VuKSB7XG4gIGlmICh0b2tlbi5lbmNvZGVkQnl0ZXMgPT09IHVuZGVmaW5lZCkge1xuICAgIHRva2VuLmVuY29kZWRCeXRlcyA9IHRva2VuLnR5cGUgPT09IFR5cGUuc3RyaW5nID8gZnJvbVN0cmluZyh0b2tlbi52YWx1ZSkgOiB0b2tlbi52YWx1ZTtcbiAgfVxuICByZXR1cm4gdG9rZW4uZW5jb2RlZEJ5dGVzO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZUJ5dGVzKGJ1ZiwgdG9rZW4pIHtcbiAgY29uc3QgYnl0ZXMgPSB0b2tlbkJ5dGVzKHRva2VuKTtcbiAgdWludC5lbmNvZGVVaW50VmFsdWUoYnVmLCB0b2tlbi50eXBlLm1ham9yRW5jb2RlZCwgYnl0ZXMubGVuZ3RoKTtcbiAgYnVmLnB1c2goYnl0ZXMpO1xufVxuZW5jb2RlQnl0ZXMuZW5jb2RlZFNpemUgPSBmdW5jdGlvbiBlbmNvZGVkU2l6ZSh0b2tlbikge1xuICBjb25zdCBieXRlcyA9IHRva2VuQnl0ZXModG9rZW4pO1xuICByZXR1cm4gdWludC5lbmNvZGVVaW50VmFsdWUuZW5jb2RlZFNpemUoYnl0ZXMubGVuZ3RoKSArIGJ5dGVzLmxlbmd0aDtcbn07XG5lbmNvZGVCeXRlcy5jb21wYXJlVG9rZW5zID0gZnVuY3Rpb24gY29tcGFyZVRva2Vucyh0b2sxLCB0b2syKSB7XG4gIHJldHVybiBjb21wYXJlQnl0ZXModG9rZW5CeXRlcyh0b2sxKSwgdG9rZW5CeXRlcyh0b2syKSk7XG59O1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXBhcmVCeXRlcyhiMSwgYjIpIHtcbiAgcmV0dXJuIGIxLmxlbmd0aCA8IGIyLmxlbmd0aCA/IC0xIDogYjEubGVuZ3RoID4gYjIubGVuZ3RoID8gMSA6IGNvbXBhcmUoYjEsIGIyKTtcbn0iLCAiaW1wb3J0IHtcbiAgVG9rZW4sXG4gIFR5cGVcbn0gZnJvbSAnLi90b2tlbi5qcyc7XG5pbXBvcnQge1xuICBhc3NlcnRFbm91Z2hEYXRhLFxuICBkZWNvZGVFcnJQcmVmaXhcbn0gZnJvbSAnLi9jb21tb24uanMnO1xuaW1wb3J0ICogYXMgdWludCBmcm9tICcuLzB1aW50LmpzJztcbmltcG9ydCB7IGVuY29kZUJ5dGVzIH0gZnJvbSAnLi8yYnl0ZXMuanMnO1xuaW1wb3J0IHtcbiAgdG9TdHJpbmcsXG4gIHNsaWNlXG59IGZyb20gJy4vYnl0ZS11dGlscy5qcyc7XG5mdW5jdGlvbiB0b1Rva2VuKGRhdGEsIHBvcywgcHJlZml4LCBsZW5ndGgsIG9wdGlvbnMpIHtcbiAgY29uc3QgdG90TGVuZ3RoID0gcHJlZml4ICsgbGVuZ3RoO1xuICBhc3NlcnRFbm91Z2hEYXRhKGRhdGEsIHBvcywgdG90TGVuZ3RoKTtcbiAgY29uc3QgdG9rID0gbmV3IFRva2VuKFR5cGUuc3RyaW5nLCB0b1N0cmluZyhkYXRhLCBwb3MgKyBwcmVmaXgsIHBvcyArIHRvdExlbmd0aCksIHRvdExlbmd0aCk7XG4gIGlmIChvcHRpb25zLnJldGFpblN0cmluZ0J5dGVzID09PSB0cnVlKSB7XG4gICAgdG9rLmJ5dGVWYWx1ZSA9IHNsaWNlKGRhdGEsIHBvcyArIHByZWZpeCwgcG9zICsgdG90TGVuZ3RoKTtcbiAgfVxuICByZXR1cm4gdG9rO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZVN0cmluZ0NvbXBhY3QoZGF0YSwgcG9zLCBtaW5vciwgb3B0aW9ucykge1xuICByZXR1cm4gdG9Ub2tlbihkYXRhLCBwb3MsIDEsIG1pbm9yLCBvcHRpb25zKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVTdHJpbmc4KGRhdGEsIHBvcywgX21pbm9yLCBvcHRpb25zKSB7XG4gIHJldHVybiB0b1Rva2VuKGRhdGEsIHBvcywgMiwgdWludC5yZWFkVWludDgoZGF0YSwgcG9zICsgMSwgb3B0aW9ucyksIG9wdGlvbnMpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZVN0cmluZzE2KGRhdGEsIHBvcywgX21pbm9yLCBvcHRpb25zKSB7XG4gIHJldHVybiB0b1Rva2VuKGRhdGEsIHBvcywgMywgdWludC5yZWFkVWludDE2KGRhdGEsIHBvcyArIDEsIG9wdGlvbnMpLCBvcHRpb25zKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVTdHJpbmczMihkYXRhLCBwb3MsIF9taW5vciwgb3B0aW9ucykge1xuICByZXR1cm4gdG9Ub2tlbihkYXRhLCBwb3MsIDUsIHVpbnQucmVhZFVpbnQzMihkYXRhLCBwb3MgKyAxLCBvcHRpb25zKSwgb3B0aW9ucyk7XG59XG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlU3RyaW5nNjQoZGF0YSwgcG9zLCBfbWlub3IsIG9wdGlvbnMpIHtcbiAgY29uc3QgbCA9IHVpbnQucmVhZFVpbnQ2NChkYXRhLCBwb3MgKyAxLCBvcHRpb25zKTtcbiAgaWYgKHR5cGVvZiBsID09PSAnYmlnaW50Jykge1xuICAgIHRocm93IG5ldyBFcnJvcihgJHsgZGVjb2RlRXJyUHJlZml4IH0gNjQtYml0IGludGVnZXIgc3RyaW5nIGxlbmd0aHMgbm90IHN1cHBvcnRlZGApO1xuICB9XG4gIHJldHVybiB0b1Rva2VuKGRhdGEsIHBvcywgOSwgbCwgb3B0aW9ucyk7XG59XG5leHBvcnQgY29uc3QgZW5jb2RlU3RyaW5nID0gZW5jb2RlQnl0ZXM7IiwgImltcG9ydCB7XG4gIFRva2VuLFxuICBUeXBlXG59IGZyb20gJy4vdG9rZW4uanMnO1xuaW1wb3J0ICogYXMgdWludCBmcm9tICcuLzB1aW50LmpzJztcbmltcG9ydCB7IGRlY29kZUVyclByZWZpeCB9IGZyb20gJy4vY29tbW9uLmpzJztcbmZ1bmN0aW9uIHRvVG9rZW4oX2RhdGEsIF9wb3MsIHByZWZpeCwgbGVuZ3RoKSB7XG4gIHJldHVybiBuZXcgVG9rZW4oVHlwZS5hcnJheSwgbGVuZ3RoLCBwcmVmaXgpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZUFycmF5Q29tcGFjdChkYXRhLCBwb3MsIG1pbm9yLCBfb3B0aW9ucykge1xuICByZXR1cm4gdG9Ub2tlbihkYXRhLCBwb3MsIDEsIG1pbm9yKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVBcnJheTgoZGF0YSwgcG9zLCBfbWlub3IsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHRvVG9rZW4oZGF0YSwgcG9zLCAyLCB1aW50LnJlYWRVaW50OChkYXRhLCBwb3MgKyAxLCBvcHRpb25zKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlQXJyYXkxNihkYXRhLCBwb3MsIF9taW5vciwgb3B0aW9ucykge1xuICByZXR1cm4gdG9Ub2tlbihkYXRhLCBwb3MsIDMsIHVpbnQucmVhZFVpbnQxNihkYXRhLCBwb3MgKyAxLCBvcHRpb25zKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlQXJyYXkzMihkYXRhLCBwb3MsIF9taW5vciwgb3B0aW9ucykge1xuICByZXR1cm4gdG9Ub2tlbihkYXRhLCBwb3MsIDUsIHVpbnQucmVhZFVpbnQzMihkYXRhLCBwb3MgKyAxLCBvcHRpb25zKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlQXJyYXk2NChkYXRhLCBwb3MsIF9taW5vciwgb3B0aW9ucykge1xuICBjb25zdCBsID0gdWludC5yZWFkVWludDY0KGRhdGEsIHBvcyArIDEsIG9wdGlvbnMpO1xuICBpZiAodHlwZW9mIGwgPT09ICdiaWdpbnQnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGAkeyBkZWNvZGVFcnJQcmVmaXggfSA2NC1iaXQgaW50ZWdlciBhcnJheSBsZW5ndGhzIG5vdCBzdXBwb3J0ZWRgKTtcbiAgfVxuICByZXR1cm4gdG9Ub2tlbihkYXRhLCBwb3MsIDksIGwpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZUFycmF5SW5kZWZpbml0ZShkYXRhLCBwb3MsIF9taW5vciwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucy5hbGxvd0luZGVmaW5pdGUgPT09IGZhbHNlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGAkeyBkZWNvZGVFcnJQcmVmaXggfSBpbmRlZmluaXRlIGxlbmd0aCBpdGVtcyBub3QgYWxsb3dlZGApO1xuICB9XG4gIHJldHVybiB0b1Rva2VuKGRhdGEsIHBvcywgMSwgSW5maW5pdHkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZUFycmF5KGJ1ZiwgdG9rZW4pIHtcbiAgdWludC5lbmNvZGVVaW50VmFsdWUoYnVmLCBUeXBlLmFycmF5Lm1ham9yRW5jb2RlZCwgdG9rZW4udmFsdWUpO1xufVxuZW5jb2RlQXJyYXkuY29tcGFyZVRva2VucyA9IHVpbnQuZW5jb2RlVWludC5jb21wYXJlVG9rZW5zO1xuZW5jb2RlQXJyYXkuZW5jb2RlZFNpemUgPSBmdW5jdGlvbiBlbmNvZGVkU2l6ZSh0b2tlbikge1xuICByZXR1cm4gdWludC5lbmNvZGVVaW50VmFsdWUuZW5jb2RlZFNpemUodG9rZW4udmFsdWUpO1xufTsiLCAiaW1wb3J0IHtcbiAgVG9rZW4sXG4gIFR5cGVcbn0gZnJvbSAnLi90b2tlbi5qcyc7XG5pbXBvcnQgKiBhcyB1aW50IGZyb20gJy4vMHVpbnQuanMnO1xuaW1wb3J0IHsgZGVjb2RlRXJyUHJlZml4IH0gZnJvbSAnLi9jb21tb24uanMnO1xuZnVuY3Rpb24gdG9Ub2tlbihfZGF0YSwgX3BvcywgcHJlZml4LCBsZW5ndGgpIHtcbiAgcmV0dXJuIG5ldyBUb2tlbihUeXBlLm1hcCwgbGVuZ3RoLCBwcmVmaXgpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZU1hcENvbXBhY3QoZGF0YSwgcG9zLCBtaW5vciwgX29wdGlvbnMpIHtcbiAgcmV0dXJuIHRvVG9rZW4oZGF0YSwgcG9zLCAxLCBtaW5vcik7XG59XG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlTWFwOChkYXRhLCBwb3MsIF9taW5vciwgb3B0aW9ucykge1xuICByZXR1cm4gdG9Ub2tlbihkYXRhLCBwb3MsIDIsIHVpbnQucmVhZFVpbnQ4KGRhdGEsIHBvcyArIDEsIG9wdGlvbnMpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVNYXAxNihkYXRhLCBwb3MsIF9taW5vciwgb3B0aW9ucykge1xuICByZXR1cm4gdG9Ub2tlbihkYXRhLCBwb3MsIDMsIHVpbnQucmVhZFVpbnQxNihkYXRhLCBwb3MgKyAxLCBvcHRpb25zKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlTWFwMzIoZGF0YSwgcG9zLCBfbWlub3IsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHRvVG9rZW4oZGF0YSwgcG9zLCA1LCB1aW50LnJlYWRVaW50MzIoZGF0YSwgcG9zICsgMSwgb3B0aW9ucykpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZU1hcDY0KGRhdGEsIHBvcywgX21pbm9yLCBvcHRpb25zKSB7XG4gIGNvbnN0IGwgPSB1aW50LnJlYWRVaW50NjQoZGF0YSwgcG9zICsgMSwgb3B0aW9ucyk7XG4gIGlmICh0eXBlb2YgbCA9PT0gJ2JpZ2ludCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7IGRlY29kZUVyclByZWZpeCB9IDY0LWJpdCBpbnRlZ2VyIG1hcCBsZW5ndGhzIG5vdCBzdXBwb3J0ZWRgKTtcbiAgfVxuICByZXR1cm4gdG9Ub2tlbihkYXRhLCBwb3MsIDksIGwpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZU1hcEluZGVmaW5pdGUoZGF0YSwgcG9zLCBfbWlub3IsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMuYWxsb3dJbmRlZmluaXRlID09PSBmYWxzZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgJHsgZGVjb2RlRXJyUHJlZml4IH0gaW5kZWZpbml0ZSBsZW5ndGggaXRlbXMgbm90IGFsbG93ZWRgKTtcbiAgfVxuICByZXR1cm4gdG9Ub2tlbihkYXRhLCBwb3MsIDEsIEluZmluaXR5KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGVNYXAoYnVmLCB0b2tlbikge1xuICB1aW50LmVuY29kZVVpbnRWYWx1ZShidWYsIFR5cGUubWFwLm1ham9yRW5jb2RlZCwgdG9rZW4udmFsdWUpO1xufVxuZW5jb2RlTWFwLmNvbXBhcmVUb2tlbnMgPSB1aW50LmVuY29kZVVpbnQuY29tcGFyZVRva2VucztcbmVuY29kZU1hcC5lbmNvZGVkU2l6ZSA9IGZ1bmN0aW9uIGVuY29kZWRTaXplKHRva2VuKSB7XG4gIHJldHVybiB1aW50LmVuY29kZVVpbnRWYWx1ZS5lbmNvZGVkU2l6ZSh0b2tlbi52YWx1ZSk7XG59OyIsICJpbXBvcnQge1xuICBUb2tlbixcbiAgVHlwZVxufSBmcm9tICcuL3Rva2VuLmpzJztcbmltcG9ydCAqIGFzIHVpbnQgZnJvbSAnLi8wdWludC5qcyc7XG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlVGFnQ29tcGFjdChfZGF0YSwgX3BvcywgbWlub3IsIF9vcHRpb25zKSB7XG4gIHJldHVybiBuZXcgVG9rZW4oVHlwZS50YWcsIG1pbm9yLCAxKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVUYWc4KGRhdGEsIHBvcywgX21pbm9yLCBvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgVG9rZW4oVHlwZS50YWcsIHVpbnQucmVhZFVpbnQ4KGRhdGEsIHBvcyArIDEsIG9wdGlvbnMpLCAyKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVUYWcxNihkYXRhLCBwb3MsIF9taW5vciwgb3B0aW9ucykge1xuICByZXR1cm4gbmV3IFRva2VuKFR5cGUudGFnLCB1aW50LnJlYWRVaW50MTYoZGF0YSwgcG9zICsgMSwgb3B0aW9ucyksIDMpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZVRhZzMyKGRhdGEsIHBvcywgX21pbm9yLCBvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgVG9rZW4oVHlwZS50YWcsIHVpbnQucmVhZFVpbnQzMihkYXRhLCBwb3MgKyAxLCBvcHRpb25zKSwgNSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlVGFnNjQoZGF0YSwgcG9zLCBfbWlub3IsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBUb2tlbihUeXBlLnRhZywgdWludC5yZWFkVWludDY0KGRhdGEsIHBvcyArIDEsIG9wdGlvbnMpLCA5KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGVUYWcoYnVmLCB0b2tlbikge1xuICB1aW50LmVuY29kZVVpbnRWYWx1ZShidWYsIFR5cGUudGFnLm1ham9yRW5jb2RlZCwgdG9rZW4udmFsdWUpO1xufVxuZW5jb2RlVGFnLmNvbXBhcmVUb2tlbnMgPSB1aW50LmVuY29kZVVpbnQuY29tcGFyZVRva2VucztcbmVuY29kZVRhZy5lbmNvZGVkU2l6ZSA9IGZ1bmN0aW9uIGVuY29kZWRTaXplKHRva2VuKSB7XG4gIHJldHVybiB1aW50LmVuY29kZVVpbnRWYWx1ZS5lbmNvZGVkU2l6ZSh0b2tlbi52YWx1ZSk7XG59OyIsICJpbXBvcnQge1xuICBUb2tlbixcbiAgVHlwZVxufSBmcm9tICcuL3Rva2VuLmpzJztcbmltcG9ydCB7IGRlY29kZUVyclByZWZpeCB9IGZyb20gJy4vY29tbW9uLmpzJztcbmltcG9ydCB7IGVuY29kZVVpbnQgfSBmcm9tICcuLzB1aW50LmpzJztcbmNvbnN0IE1JTk9SX0ZBTFNFID0gMjA7XG5jb25zdCBNSU5PUl9UUlVFID0gMjE7XG5jb25zdCBNSU5PUl9OVUxMID0gMjI7XG5jb25zdCBNSU5PUl9VTkRFRklORUQgPSAyMztcbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVVbmRlZmluZWQoX2RhdGEsIF9wb3MsIF9taW5vciwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucy5hbGxvd1VuZGVmaW5lZCA9PT0gZmFsc2UpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7IGRlY29kZUVyclByZWZpeCB9IHVuZGVmaW5lZCB2YWx1ZXMgYXJlIG5vdCBzdXBwb3J0ZWRgKTtcbiAgfSBlbHNlIGlmIChvcHRpb25zLmNvZXJjZVVuZGVmaW5lZFRvTnVsbCA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBuZXcgVG9rZW4oVHlwZS5udWxsLCBudWxsLCAxKTtcbiAgfVxuICByZXR1cm4gbmV3IFRva2VuKFR5cGUudW5kZWZpbmVkLCB1bmRlZmluZWQsIDEpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZUJyZWFrKF9kYXRhLCBfcG9zLCBfbWlub3IsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMuYWxsb3dJbmRlZmluaXRlID09PSBmYWxzZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgJHsgZGVjb2RlRXJyUHJlZml4IH0gaW5kZWZpbml0ZSBsZW5ndGggaXRlbXMgbm90IGFsbG93ZWRgKTtcbiAgfVxuICByZXR1cm4gbmV3IFRva2VuKFR5cGUuYnJlYWssIHVuZGVmaW5lZCwgMSk7XG59XG5mdW5jdGlvbiBjcmVhdGVUb2tlbih2YWx1ZSwgYnl0ZXMsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5hbGxvd05hTiA9PT0gZmFsc2UgJiYgTnVtYmVyLmlzTmFOKHZhbHVlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAkeyBkZWNvZGVFcnJQcmVmaXggfSBOYU4gdmFsdWVzIGFyZSBub3Qgc3VwcG9ydGVkYCk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmFsbG93SW5maW5pdHkgPT09IGZhbHNlICYmICh2YWx1ZSA9PT0gSW5maW5pdHkgfHwgdmFsdWUgPT09IC1JbmZpbml0eSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHsgZGVjb2RlRXJyUHJlZml4IH0gSW5maW5pdHkgdmFsdWVzIGFyZSBub3Qgc3VwcG9ydGVkYCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXcgVG9rZW4oVHlwZS5mbG9hdCwgdmFsdWUsIGJ5dGVzKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVGbG9hdDE2KGRhdGEsIHBvcywgX21pbm9yLCBvcHRpb25zKSB7XG4gIHJldHVybiBjcmVhdGVUb2tlbihyZWFkRmxvYXQxNihkYXRhLCBwb3MgKyAxKSwgMywgb3B0aW9ucyk7XG59XG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlRmxvYXQzMihkYXRhLCBwb3MsIF9taW5vciwgb3B0aW9ucykge1xuICByZXR1cm4gY3JlYXRlVG9rZW4ocmVhZEZsb2F0MzIoZGF0YSwgcG9zICsgMSksIDUsIG9wdGlvbnMpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZUZsb2F0NjQoZGF0YSwgcG9zLCBfbWlub3IsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGNyZWF0ZVRva2VuKHJlYWRGbG9hdDY0KGRhdGEsIHBvcyArIDEpLCA5LCBvcHRpb25zKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGVGbG9hdChidWYsIHRva2VuLCBvcHRpb25zKSB7XG4gIGNvbnN0IGZsb2F0ID0gdG9rZW4udmFsdWU7XG4gIGlmIChmbG9hdCA9PT0gZmFsc2UpIHtcbiAgICBidWYucHVzaChbVHlwZS5mbG9hdC5tYWpvckVuY29kZWQgfCBNSU5PUl9GQUxTRV0pO1xuICB9IGVsc2UgaWYgKGZsb2F0ID09PSB0cnVlKSB7XG4gICAgYnVmLnB1c2goW1R5cGUuZmxvYXQubWFqb3JFbmNvZGVkIHwgTUlOT1JfVFJVRV0pO1xuICB9IGVsc2UgaWYgKGZsb2F0ID09PSBudWxsKSB7XG4gICAgYnVmLnB1c2goW1R5cGUuZmxvYXQubWFqb3JFbmNvZGVkIHwgTUlOT1JfTlVMTF0pO1xuICB9IGVsc2UgaWYgKGZsb2F0ID09PSB1bmRlZmluZWQpIHtcbiAgICBidWYucHVzaChbVHlwZS5mbG9hdC5tYWpvckVuY29kZWQgfCBNSU5PUl9VTkRFRklORURdKTtcbiAgfSBlbHNlIHtcbiAgICBsZXQgZGVjb2RlZDtcbiAgICBsZXQgc3VjY2VzcyA9IGZhbHNlO1xuICAgIGlmICghb3B0aW9ucyB8fCBvcHRpb25zLmZsb2F0NjQgIT09IHRydWUpIHtcbiAgICAgIGVuY29kZUZsb2F0MTYoZmxvYXQpO1xuICAgICAgZGVjb2RlZCA9IHJlYWRGbG9hdDE2KHVpOGEsIDEpO1xuICAgICAgaWYgKGZsb2F0ID09PSBkZWNvZGVkIHx8IE51bWJlci5pc05hTihmbG9hdCkpIHtcbiAgICAgICAgdWk4YVswXSA9IDI0OTtcbiAgICAgICAgYnVmLnB1c2godWk4YS5zbGljZSgwLCAzKSk7XG4gICAgICAgIHN1Y2Nlc3MgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW5jb2RlRmxvYXQzMihmbG9hdCk7XG4gICAgICAgIGRlY29kZWQgPSByZWFkRmxvYXQzMih1aThhLCAxKTtcbiAgICAgICAgaWYgKGZsb2F0ID09PSBkZWNvZGVkKSB7XG4gICAgICAgICAgdWk4YVswXSA9IDI1MDtcbiAgICAgICAgICBidWYucHVzaCh1aThhLnNsaWNlKDAsIDUpKTtcbiAgICAgICAgICBzdWNjZXNzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXN1Y2Nlc3MpIHtcbiAgICAgIGVuY29kZUZsb2F0NjQoZmxvYXQpO1xuICAgICAgZGVjb2RlZCA9IHJlYWRGbG9hdDY0KHVpOGEsIDEpO1xuICAgICAgdWk4YVswXSA9IDI1MTtcbiAgICAgIGJ1Zi5wdXNoKHVpOGEuc2xpY2UoMCwgOSkpO1xuICAgIH1cbiAgfVxufVxuZW5jb2RlRmxvYXQuZW5jb2RlZFNpemUgPSBmdW5jdGlvbiBlbmNvZGVkU2l6ZSh0b2tlbiwgb3B0aW9ucykge1xuICBjb25zdCBmbG9hdCA9IHRva2VuLnZhbHVlO1xuICBpZiAoZmxvYXQgPT09IGZhbHNlIHx8IGZsb2F0ID09PSB0cnVlIHx8IGZsb2F0ID09PSBudWxsIHx8IGZsb2F0ID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICBpZiAoIW9wdGlvbnMgfHwgb3B0aW9ucy5mbG9hdDY0ICE9PSB0cnVlKSB7XG4gICAgZW5jb2RlRmxvYXQxNihmbG9hdCk7XG4gICAgbGV0IGRlY29kZWQgPSByZWFkRmxvYXQxNih1aThhLCAxKTtcbiAgICBpZiAoZmxvYXQgPT09IGRlY29kZWQgfHwgTnVtYmVyLmlzTmFOKGZsb2F0KSkge1xuICAgICAgcmV0dXJuIDM7XG4gICAgfVxuICAgIGVuY29kZUZsb2F0MzIoZmxvYXQpO1xuICAgIGRlY29kZWQgPSByZWFkRmxvYXQzMih1aThhLCAxKTtcbiAgICBpZiAoZmxvYXQgPT09IGRlY29kZWQpIHtcbiAgICAgIHJldHVybiA1O1xuICAgIH1cbiAgfVxuICByZXR1cm4gOTtcbn07XG5jb25zdCBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoOSk7XG5jb25zdCBkYXRhVmlldyA9IG5ldyBEYXRhVmlldyhidWZmZXIsIDEpO1xuY29uc3QgdWk4YSA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlciwgMCk7XG5mdW5jdGlvbiBlbmNvZGVGbG9hdDE2KGlucCkge1xuICBpZiAoaW5wID09PSBJbmZpbml0eSkge1xuICAgIGRhdGFWaWV3LnNldFVpbnQxNigwLCAzMTc0NCwgZmFsc2UpO1xuICB9IGVsc2UgaWYgKGlucCA9PT0gLUluZmluaXR5KSB7XG4gICAgZGF0YVZpZXcuc2V0VWludDE2KDAsIDY0NTEyLCBmYWxzZSk7XG4gIH0gZWxzZSBpZiAoTnVtYmVyLmlzTmFOKGlucCkpIHtcbiAgICBkYXRhVmlldy5zZXRVaW50MTYoMCwgMzIyNTYsIGZhbHNlKTtcbiAgfSBlbHNlIHtcbiAgICBkYXRhVmlldy5zZXRGbG9hdDMyKDAsIGlucCk7XG4gICAgY29uc3QgdmFsdTMyID0gZGF0YVZpZXcuZ2V0VWludDMyKDApO1xuICAgIGNvbnN0IGV4cG9uZW50ID0gKHZhbHUzMiAmIDIxMzkwOTUwNDApID4+IDIzO1xuICAgIGNvbnN0IG1hbnRpc3NhID0gdmFsdTMyICYgODM4ODYwNztcbiAgICBpZiAoZXhwb25lbnQgPT09IDI1NSkge1xuICAgICAgZGF0YVZpZXcuc2V0VWludDE2KDAsIDMxNzQ0LCBmYWxzZSk7XG4gICAgfSBlbHNlIGlmIChleHBvbmVudCA9PT0gMCkge1xuICAgICAgZGF0YVZpZXcuc2V0VWludDE2KDAsIChpbnAgJiAyMTQ3NDgzNjQ4KSA+PiAxNiB8IG1hbnRpc3NhID4+IDEzLCBmYWxzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGxvZ2ljYWxFeHBvbmVudCA9IGV4cG9uZW50IC0gMTI3O1xuICAgICAgaWYgKGxvZ2ljYWxFeHBvbmVudCA8IC0yNCkge1xuICAgICAgICBkYXRhVmlldy5zZXRVaW50MTYoMCwgMCk7XG4gICAgICB9IGVsc2UgaWYgKGxvZ2ljYWxFeHBvbmVudCA8IC0xNCkge1xuICAgICAgICBkYXRhVmlldy5zZXRVaW50MTYoMCwgKHZhbHUzMiAmIDIxNDc0ODM2NDgpID4+IDE2IHwgMSA8PCAyNCArIGxvZ2ljYWxFeHBvbmVudCwgZmFsc2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YVZpZXcuc2V0VWludDE2KDAsICh2YWx1MzIgJiAyMTQ3NDgzNjQ4KSA+PiAxNiB8IGxvZ2ljYWxFeHBvbmVudCArIDE1IDw8IDEwIHwgbWFudGlzc2EgPj4gMTMsIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHJlYWRGbG9hdDE2KHVpOGEsIHBvcykge1xuICBpZiAodWk4YS5sZW5ndGggLSBwb3MgPCAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGAkeyBkZWNvZGVFcnJQcmVmaXggfSBub3QgZW5vdWdoIGRhdGEgZm9yIGZsb2F0MTZgKTtcbiAgfVxuICBjb25zdCBoYWxmID0gKHVpOGFbcG9zXSA8PCA4KSArIHVpOGFbcG9zICsgMV07XG4gIGlmIChoYWxmID09PSAzMTc0NCkge1xuICAgIHJldHVybiBJbmZpbml0eTtcbiAgfVxuICBpZiAoaGFsZiA9PT0gNjQ1MTIpIHtcbiAgICByZXR1cm4gLUluZmluaXR5O1xuICB9XG4gIGlmIChoYWxmID09PSAzMjI1Nikge1xuICAgIHJldHVybiBOYU47XG4gIH1cbiAgY29uc3QgZXhwID0gaGFsZiA+PiAxMCAmIDMxO1xuICBjb25zdCBtYW50ID0gaGFsZiAmIDEwMjM7XG4gIGxldCB2YWw7XG4gIGlmIChleHAgPT09IDApIHtcbiAgICB2YWwgPSBtYW50ICogMiAqKiAtMjQ7XG4gIH0gZWxzZSBpZiAoZXhwICE9PSAzMSkge1xuICAgIHZhbCA9IChtYW50ICsgMTAyNCkgKiAyICoqIChleHAgLSAyNSk7XG4gIH0gZWxzZSB7XG4gICAgdmFsID0gbWFudCA9PT0gMCA/IEluZmluaXR5IDogTmFOO1xuICB9XG4gIHJldHVybiBoYWxmICYgMzI3NjggPyAtdmFsIDogdmFsO1xufVxuZnVuY3Rpb24gZW5jb2RlRmxvYXQzMihpbnApIHtcbiAgZGF0YVZpZXcuc2V0RmxvYXQzMigwLCBpbnAsIGZhbHNlKTtcbn1cbmZ1bmN0aW9uIHJlYWRGbG9hdDMyKHVpOGEsIHBvcykge1xuICBpZiAodWk4YS5sZW5ndGggLSBwb3MgPCA0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGAkeyBkZWNvZGVFcnJQcmVmaXggfSBub3QgZW5vdWdoIGRhdGEgZm9yIGZsb2F0MzJgKTtcbiAgfVxuICBjb25zdCBvZmZzZXQgPSAodWk4YS5ieXRlT2Zmc2V0IHx8IDApICsgcG9zO1xuICByZXR1cm4gbmV3IERhdGFWaWV3KHVpOGEuYnVmZmVyLCBvZmZzZXQsIDQpLmdldEZsb2F0MzIoMCwgZmFsc2UpO1xufVxuZnVuY3Rpb24gZW5jb2RlRmxvYXQ2NChpbnApIHtcbiAgZGF0YVZpZXcuc2V0RmxvYXQ2NCgwLCBpbnAsIGZhbHNlKTtcbn1cbmZ1bmN0aW9uIHJlYWRGbG9hdDY0KHVpOGEsIHBvcykge1xuICBpZiAodWk4YS5sZW5ndGggLSBwb3MgPCA4KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGAkeyBkZWNvZGVFcnJQcmVmaXggfSBub3QgZW5vdWdoIGRhdGEgZm9yIGZsb2F0NjRgKTtcbiAgfVxuICBjb25zdCBvZmZzZXQgPSAodWk4YS5ieXRlT2Zmc2V0IHx8IDApICsgcG9zO1xuICByZXR1cm4gbmV3IERhdGFWaWV3KHVpOGEuYnVmZmVyLCBvZmZzZXQsIDgpLmdldEZsb2F0NjQoMCwgZmFsc2UpO1xufVxuZW5jb2RlRmxvYXQuY29tcGFyZVRva2VucyA9IGVuY29kZVVpbnQuY29tcGFyZVRva2VuczsiLCAiaW1wb3J0IHtcbiAgVG9rZW4sXG4gIFR5cGVcbn0gZnJvbSAnLi90b2tlbi5qcyc7XG5pbXBvcnQgKiBhcyB1aW50IGZyb20gJy4vMHVpbnQuanMnO1xuaW1wb3J0ICogYXMgbmVnaW50IGZyb20gJy4vMW5lZ2ludC5qcyc7XG5pbXBvcnQgKiBhcyBieXRlcyBmcm9tICcuLzJieXRlcy5qcyc7XG5pbXBvcnQgKiBhcyBzdHJpbmcgZnJvbSAnLi8zc3RyaW5nLmpzJztcbmltcG9ydCAqIGFzIGFycmF5IGZyb20gJy4vNGFycmF5LmpzJztcbmltcG9ydCAqIGFzIG1hcCBmcm9tICcuLzVtYXAuanMnO1xuaW1wb3J0ICogYXMgdGFnIGZyb20gJy4vNnRhZy5qcyc7XG5pbXBvcnQgKiBhcyBmbG9hdCBmcm9tICcuLzdmbG9hdC5qcyc7XG5pbXBvcnQgeyBkZWNvZGVFcnJQcmVmaXggfSBmcm9tICcuL2NvbW1vbi5qcyc7XG5pbXBvcnQgeyBmcm9tQXJyYXkgfSBmcm9tICcuL2J5dGUtdXRpbHMuanMnO1xuZnVuY3Rpb24gaW52YWxpZE1pbm9yKGRhdGEsIHBvcywgbWlub3IpIHtcbiAgdGhyb3cgbmV3IEVycm9yKGAkeyBkZWNvZGVFcnJQcmVmaXggfSBlbmNvdW50ZXJlZCBpbnZhbGlkIG1pbm9yICgkeyBtaW5vciB9KSBmb3IgbWFqb3IgJHsgZGF0YVtwb3NdID4+PiA1IH1gKTtcbn1cbmZ1bmN0aW9uIGVycm9yZXIobXNnKSB7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGAkeyBkZWNvZGVFcnJQcmVmaXggfSAkeyBtc2cgfWApO1xuICB9O1xufVxuZXhwb3J0IGNvbnN0IGp1bXAgPSBbXTtcbmZvciAobGV0IGkgPSAwOyBpIDw9IDIzOyBpKyspIHtcbiAganVtcFtpXSA9IGludmFsaWRNaW5vcjtcbn1cbmp1bXBbMjRdID0gdWludC5kZWNvZGVVaW50ODtcbmp1bXBbMjVdID0gdWludC5kZWNvZGVVaW50MTY7XG5qdW1wWzI2XSA9IHVpbnQuZGVjb2RlVWludDMyO1xuanVtcFsyN10gPSB1aW50LmRlY29kZVVpbnQ2NDtcbmp1bXBbMjhdID0gaW52YWxpZE1pbm9yO1xuanVtcFsyOV0gPSBpbnZhbGlkTWlub3I7XG5qdW1wWzMwXSA9IGludmFsaWRNaW5vcjtcbmp1bXBbMzFdID0gaW52YWxpZE1pbm9yO1xuZm9yIChsZXQgaSA9IDMyOyBpIDw9IDU1OyBpKyspIHtcbiAganVtcFtpXSA9IGludmFsaWRNaW5vcjtcbn1cbmp1bXBbNTZdID0gbmVnaW50LmRlY29kZU5lZ2ludDg7XG5qdW1wWzU3XSA9IG5lZ2ludC5kZWNvZGVOZWdpbnQxNjtcbmp1bXBbNThdID0gbmVnaW50LmRlY29kZU5lZ2ludDMyO1xuanVtcFs1OV0gPSBuZWdpbnQuZGVjb2RlTmVnaW50NjQ7XG5qdW1wWzYwXSA9IGludmFsaWRNaW5vcjtcbmp1bXBbNjFdID0gaW52YWxpZE1pbm9yO1xuanVtcFs2Ml0gPSBpbnZhbGlkTWlub3I7XG5qdW1wWzYzXSA9IGludmFsaWRNaW5vcjtcbmZvciAobGV0IGkgPSA2NDsgaSA8PSA4NzsgaSsrKSB7XG4gIGp1bXBbaV0gPSBieXRlcy5kZWNvZGVCeXRlc0NvbXBhY3Q7XG59XG5qdW1wWzg4XSA9IGJ5dGVzLmRlY29kZUJ5dGVzODtcbmp1bXBbODldID0gYnl0ZXMuZGVjb2RlQnl0ZXMxNjtcbmp1bXBbOTBdID0gYnl0ZXMuZGVjb2RlQnl0ZXMzMjtcbmp1bXBbOTFdID0gYnl0ZXMuZGVjb2RlQnl0ZXM2NDtcbmp1bXBbOTJdID0gaW52YWxpZE1pbm9yO1xuanVtcFs5M10gPSBpbnZhbGlkTWlub3I7XG5qdW1wWzk0XSA9IGludmFsaWRNaW5vcjtcbmp1bXBbOTVdID0gZXJyb3JlcignaW5kZWZpbml0ZSBsZW5ndGggYnl0ZXMvc3RyaW5ncyBhcmUgbm90IHN1cHBvcnRlZCcpO1xuZm9yIChsZXQgaSA9IDk2OyBpIDw9IDExOTsgaSsrKSB7XG4gIGp1bXBbaV0gPSBzdHJpbmcuZGVjb2RlU3RyaW5nQ29tcGFjdDtcbn1cbmp1bXBbMTIwXSA9IHN0cmluZy5kZWNvZGVTdHJpbmc4O1xuanVtcFsxMjFdID0gc3RyaW5nLmRlY29kZVN0cmluZzE2O1xuanVtcFsxMjJdID0gc3RyaW5nLmRlY29kZVN0cmluZzMyO1xuanVtcFsxMjNdID0gc3RyaW5nLmRlY29kZVN0cmluZzY0O1xuanVtcFsxMjRdID0gaW52YWxpZE1pbm9yO1xuanVtcFsxMjVdID0gaW52YWxpZE1pbm9yO1xuanVtcFsxMjZdID0gaW52YWxpZE1pbm9yO1xuanVtcFsxMjddID0gZXJyb3JlcignaW5kZWZpbml0ZSBsZW5ndGggYnl0ZXMvc3RyaW5ncyBhcmUgbm90IHN1cHBvcnRlZCcpO1xuZm9yIChsZXQgaSA9IDEyODsgaSA8PSAxNTE7IGkrKykge1xuICBqdW1wW2ldID0gYXJyYXkuZGVjb2RlQXJyYXlDb21wYWN0O1xufVxuanVtcFsxNTJdID0gYXJyYXkuZGVjb2RlQXJyYXk4O1xuanVtcFsxNTNdID0gYXJyYXkuZGVjb2RlQXJyYXkxNjtcbmp1bXBbMTU0XSA9IGFycmF5LmRlY29kZUFycmF5MzI7XG5qdW1wWzE1NV0gPSBhcnJheS5kZWNvZGVBcnJheTY0O1xuanVtcFsxNTZdID0gaW52YWxpZE1pbm9yO1xuanVtcFsxNTddID0gaW52YWxpZE1pbm9yO1xuanVtcFsxNThdID0gaW52YWxpZE1pbm9yO1xuanVtcFsxNTldID0gYXJyYXkuZGVjb2RlQXJyYXlJbmRlZmluaXRlO1xuZm9yIChsZXQgaSA9IDE2MDsgaSA8PSAxODM7IGkrKykge1xuICBqdW1wW2ldID0gbWFwLmRlY29kZU1hcENvbXBhY3Q7XG59XG5qdW1wWzE4NF0gPSBtYXAuZGVjb2RlTWFwODtcbmp1bXBbMTg1XSA9IG1hcC5kZWNvZGVNYXAxNjtcbmp1bXBbMTg2XSA9IG1hcC5kZWNvZGVNYXAzMjtcbmp1bXBbMTg3XSA9IG1hcC5kZWNvZGVNYXA2NDtcbmp1bXBbMTg4XSA9IGludmFsaWRNaW5vcjtcbmp1bXBbMTg5XSA9IGludmFsaWRNaW5vcjtcbmp1bXBbMTkwXSA9IGludmFsaWRNaW5vcjtcbmp1bXBbMTkxXSA9IG1hcC5kZWNvZGVNYXBJbmRlZmluaXRlO1xuZm9yIChsZXQgaSA9IDE5MjsgaSA8PSAyMTU7IGkrKykge1xuICBqdW1wW2ldID0gdGFnLmRlY29kZVRhZ0NvbXBhY3Q7XG59XG5qdW1wWzIxNl0gPSB0YWcuZGVjb2RlVGFnODtcbmp1bXBbMjE3XSA9IHRhZy5kZWNvZGVUYWcxNjtcbmp1bXBbMjE4XSA9IHRhZy5kZWNvZGVUYWczMjtcbmp1bXBbMjE5XSA9IHRhZy5kZWNvZGVUYWc2NDtcbmp1bXBbMjIwXSA9IGludmFsaWRNaW5vcjtcbmp1bXBbMjIxXSA9IGludmFsaWRNaW5vcjtcbmp1bXBbMjIyXSA9IGludmFsaWRNaW5vcjtcbmp1bXBbMjIzXSA9IGludmFsaWRNaW5vcjtcbmZvciAobGV0IGkgPSAyMjQ7IGkgPD0gMjQzOyBpKyspIHtcbiAganVtcFtpXSA9IGVycm9yZXIoJ3NpbXBsZSB2YWx1ZXMgYXJlIG5vdCBzdXBwb3J0ZWQnKTtcbn1cbmp1bXBbMjQ0XSA9IGludmFsaWRNaW5vcjtcbmp1bXBbMjQ1XSA9IGludmFsaWRNaW5vcjtcbmp1bXBbMjQ2XSA9IGludmFsaWRNaW5vcjtcbmp1bXBbMjQ3XSA9IGZsb2F0LmRlY29kZVVuZGVmaW5lZDtcbmp1bXBbMjQ4XSA9IGVycm9yZXIoJ3NpbXBsZSB2YWx1ZXMgYXJlIG5vdCBzdXBwb3J0ZWQnKTtcbmp1bXBbMjQ5XSA9IGZsb2F0LmRlY29kZUZsb2F0MTY7XG5qdW1wWzI1MF0gPSBmbG9hdC5kZWNvZGVGbG9hdDMyO1xuanVtcFsyNTFdID0gZmxvYXQuZGVjb2RlRmxvYXQ2NDtcbmp1bXBbMjUyXSA9IGludmFsaWRNaW5vcjtcbmp1bXBbMjUzXSA9IGludmFsaWRNaW5vcjtcbmp1bXBbMjU0XSA9IGludmFsaWRNaW5vcjtcbmp1bXBbMjU1XSA9IGZsb2F0LmRlY29kZUJyZWFrO1xuZXhwb3J0IGNvbnN0IHF1aWNrID0gW107XG5mb3IgKGxldCBpID0gMDsgaSA8IDI0OyBpKyspIHtcbiAgcXVpY2tbaV0gPSBuZXcgVG9rZW4oVHlwZS51aW50LCBpLCAxKTtcbn1cbmZvciAobGV0IGkgPSAtMTsgaSA+PSAtMjQ7IGktLSkge1xuICBxdWlja1szMSAtIGldID0gbmV3IFRva2VuKFR5cGUubmVnaW50LCBpLCAxKTtcbn1cbnF1aWNrWzY0XSA9IG5ldyBUb2tlbihUeXBlLmJ5dGVzLCBuZXcgVWludDhBcnJheSgwKSwgMSk7XG5xdWlja1s5Nl0gPSBuZXcgVG9rZW4oVHlwZS5zdHJpbmcsICcnLCAxKTtcbnF1aWNrWzEyOF0gPSBuZXcgVG9rZW4oVHlwZS5hcnJheSwgMCwgMSk7XG5xdWlja1sxNjBdID0gbmV3IFRva2VuKFR5cGUubWFwLCAwLCAxKTtcbnF1aWNrWzI0NF0gPSBuZXcgVG9rZW4oVHlwZS5mYWxzZSwgZmFsc2UsIDEpO1xucXVpY2tbMjQ1XSA9IG5ldyBUb2tlbihUeXBlLnRydWUsIHRydWUsIDEpO1xucXVpY2tbMjQ2XSA9IG5ldyBUb2tlbihUeXBlLm51bGwsIG51bGwsIDEpO1xuZXhwb3J0IGZ1bmN0aW9uIHF1aWNrRW5jb2RlVG9rZW4odG9rZW4pIHtcbiAgc3dpdGNoICh0b2tlbi50eXBlKSB7XG4gIGNhc2UgVHlwZS5mYWxzZTpcbiAgICByZXR1cm4gZnJvbUFycmF5KFsyNDRdKTtcbiAgY2FzZSBUeXBlLnRydWU6XG4gICAgcmV0dXJuIGZyb21BcnJheShbMjQ1XSk7XG4gIGNhc2UgVHlwZS5udWxsOlxuICAgIHJldHVybiBmcm9tQXJyYXkoWzI0Nl0pO1xuICBjYXNlIFR5cGUuYnl0ZXM6XG4gICAgaWYgKCF0b2tlbi52YWx1ZS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmcm9tQXJyYXkoWzY0XSk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgY2FzZSBUeXBlLnN0cmluZzpcbiAgICBpZiAodG9rZW4udmFsdWUgPT09ICcnKSB7XG4gICAgICByZXR1cm4gZnJvbUFycmF5KFs5Nl0pO1xuICAgIH1cbiAgICByZXR1cm47XG4gIGNhc2UgVHlwZS5hcnJheTpcbiAgICBpZiAodG9rZW4udmFsdWUgPT09IDApIHtcbiAgICAgIHJldHVybiBmcm9tQXJyYXkoWzEyOF0pO1xuICAgIH1cbiAgICByZXR1cm47XG4gIGNhc2UgVHlwZS5tYXA6XG4gICAgaWYgKHRva2VuLnZhbHVlID09PSAwKSB7XG4gICAgICByZXR1cm4gZnJvbUFycmF5KFsxNjBdKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICBjYXNlIFR5cGUudWludDpcbiAgICBpZiAodG9rZW4udmFsdWUgPCAyNCkge1xuICAgICAgcmV0dXJuIGZyb21BcnJheShbTnVtYmVyKHRva2VuLnZhbHVlKV0pO1xuICAgIH1cbiAgICByZXR1cm47XG4gIGNhc2UgVHlwZS5uZWdpbnQ6XG4gICAgaWYgKHRva2VuLnZhbHVlID49IC0yNCkge1xuICAgICAgcmV0dXJuIGZyb21BcnJheShbMzEgLSBOdW1iZXIodG9rZW4udmFsdWUpXSk7XG4gICAgfVxuICB9XG59IiwgImltcG9ydCB7IGlzIH0gZnJvbSAnLi9pcy5qcyc7XG5pbXBvcnQge1xuICBUb2tlbixcbiAgVHlwZVxufSBmcm9tICcuL3Rva2VuLmpzJztcbmltcG9ydCB7IEJsIH0gZnJvbSAnLi9ibC5qcyc7XG5pbXBvcnQgeyBlbmNvZGVFcnJQcmVmaXggfSBmcm9tICcuL2NvbW1vbi5qcyc7XG5pbXBvcnQgeyBxdWlja0VuY29kZVRva2VuIH0gZnJvbSAnLi9qdW1wLmpzJztcbmltcG9ydCB7IGFzVThBIH0gZnJvbSAnLi9ieXRlLXV0aWxzLmpzJztcbmltcG9ydCB7IGVuY29kZVVpbnQgfSBmcm9tICcuLzB1aW50LmpzJztcbmltcG9ydCB7IGVuY29kZU5lZ2ludCB9IGZyb20gJy4vMW5lZ2ludC5qcyc7XG5pbXBvcnQgeyBlbmNvZGVCeXRlcyB9IGZyb20gJy4vMmJ5dGVzLmpzJztcbmltcG9ydCB7IGVuY29kZVN0cmluZyB9IGZyb20gJy4vM3N0cmluZy5qcyc7XG5pbXBvcnQgeyBlbmNvZGVBcnJheSB9IGZyb20gJy4vNGFycmF5LmpzJztcbmltcG9ydCB7IGVuY29kZU1hcCB9IGZyb20gJy4vNW1hcC5qcyc7XG5pbXBvcnQgeyBlbmNvZGVUYWcgfSBmcm9tICcuLzZ0YWcuanMnO1xuaW1wb3J0IHsgZW5jb2RlRmxvYXQgfSBmcm9tICcuLzdmbG9hdC5qcyc7XG5jb25zdCBkZWZhdWx0RW5jb2RlT3B0aW9ucyA9IHtcbiAgZmxvYXQ2NDogZmFsc2UsXG4gIG1hcFNvcnRlcixcbiAgcXVpY2tFbmNvZGVUb2tlblxufTtcbmV4cG9ydCBmdW5jdGlvbiBtYWtlQ2JvckVuY29kZXJzKCkge1xuICBjb25zdCBlbmNvZGVycyA9IFtdO1xuICBlbmNvZGVyc1tUeXBlLnVpbnQubWFqb3JdID0gZW5jb2RlVWludDtcbiAgZW5jb2RlcnNbVHlwZS5uZWdpbnQubWFqb3JdID0gZW5jb2RlTmVnaW50O1xuICBlbmNvZGVyc1tUeXBlLmJ5dGVzLm1ham9yXSA9IGVuY29kZUJ5dGVzO1xuICBlbmNvZGVyc1tUeXBlLnN0cmluZy5tYWpvcl0gPSBlbmNvZGVTdHJpbmc7XG4gIGVuY29kZXJzW1R5cGUuYXJyYXkubWFqb3JdID0gZW5jb2RlQXJyYXk7XG4gIGVuY29kZXJzW1R5cGUubWFwLm1ham9yXSA9IGVuY29kZU1hcDtcbiAgZW5jb2RlcnNbVHlwZS50YWcubWFqb3JdID0gZW5jb2RlVGFnO1xuICBlbmNvZGVyc1tUeXBlLmZsb2F0Lm1ham9yXSA9IGVuY29kZUZsb2F0O1xuICByZXR1cm4gZW5jb2RlcnM7XG59XG5jb25zdCBjYm9yRW5jb2RlcnMgPSBtYWtlQ2JvckVuY29kZXJzKCk7XG5jb25zdCBidWYgPSBuZXcgQmwoKTtcbmNsYXNzIFJlZiB7XG4gIGNvbnN0cnVjdG9yKG9iaiwgcGFyZW50KSB7XG4gICAgdGhpcy5vYmogPSBvYmo7XG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gIH1cbiAgaW5jbHVkZXMob2JqKSB7XG4gICAgbGV0IHAgPSB0aGlzO1xuICAgIGRvIHtcbiAgICAgIGlmIChwLm9iaiA9PT0gb2JqKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0gd2hpbGUgKHAgPSBwLnBhcmVudCk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHN0YXRpYyBjcmVhdGVDaGVjayhzdGFjaywgb2JqKSB7XG4gICAgaWYgKHN0YWNrICYmIHN0YWNrLmluY2x1ZGVzKG9iaikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHsgZW5jb2RlRXJyUHJlZml4IH0gb2JqZWN0IGNvbnRhaW5zIGNpcmN1bGFyIHJlZmVyZW5jZXNgKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBSZWYob2JqLCBzdGFjayk7XG4gIH1cbn1cbmNvbnN0IHNpbXBsZVRva2VucyA9IHtcbiAgbnVsbDogbmV3IFRva2VuKFR5cGUubnVsbCwgbnVsbCksXG4gIHVuZGVmaW5lZDogbmV3IFRva2VuKFR5cGUudW5kZWZpbmVkLCB1bmRlZmluZWQpLFxuICB0cnVlOiBuZXcgVG9rZW4oVHlwZS50cnVlLCB0cnVlKSxcbiAgZmFsc2U6IG5ldyBUb2tlbihUeXBlLmZhbHNlLCBmYWxzZSksXG4gIGVtcHR5QXJyYXk6IG5ldyBUb2tlbihUeXBlLmFycmF5LCAwKSxcbiAgZW1wdHlNYXA6IG5ldyBUb2tlbihUeXBlLm1hcCwgMClcbn07XG5jb25zdCB0eXBlRW5jb2RlcnMgPSB7XG4gIG51bWJlcihvYmosIF90eXAsIF9vcHRpb25zLCBfcmVmU3RhY2spIHtcbiAgICBpZiAoIU51bWJlci5pc0ludGVnZXIob2JqKSB8fCAhTnVtYmVyLmlzU2FmZUludGVnZXIob2JqKSkge1xuICAgICAgcmV0dXJuIG5ldyBUb2tlbihUeXBlLmZsb2F0LCBvYmopO1xuICAgIH0gZWxzZSBpZiAob2JqID49IDApIHtcbiAgICAgIHJldHVybiBuZXcgVG9rZW4oVHlwZS51aW50LCBvYmopO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IFRva2VuKFR5cGUubmVnaW50LCBvYmopO1xuICAgIH1cbiAgfSxcbiAgYmlnaW50KG9iaiwgX3R5cCwgX29wdGlvbnMsIF9yZWZTdGFjaykge1xuICAgIGlmIChvYmogPj0gQmlnSW50KDApKSB7XG4gICAgICByZXR1cm4gbmV3IFRva2VuKFR5cGUudWludCwgb2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBUb2tlbihUeXBlLm5lZ2ludCwgb2JqKTtcbiAgICB9XG4gIH0sXG4gIFVpbnQ4QXJyYXkob2JqLCBfdHlwLCBfb3B0aW9ucywgX3JlZlN0YWNrKSB7XG4gICAgcmV0dXJuIG5ldyBUb2tlbihUeXBlLmJ5dGVzLCBvYmopO1xuICB9LFxuICBzdHJpbmcob2JqLCBfdHlwLCBfb3B0aW9ucywgX3JlZlN0YWNrKSB7XG4gICAgcmV0dXJuIG5ldyBUb2tlbihUeXBlLnN0cmluZywgb2JqKTtcbiAgfSxcbiAgYm9vbGVhbihvYmosIF90eXAsIF9vcHRpb25zLCBfcmVmU3RhY2spIHtcbiAgICByZXR1cm4gb2JqID8gc2ltcGxlVG9rZW5zLnRydWUgOiBzaW1wbGVUb2tlbnMuZmFsc2U7XG4gIH0sXG4gIG51bGwoX29iaiwgX3R5cCwgX29wdGlvbnMsIF9yZWZTdGFjaykge1xuICAgIHJldHVybiBzaW1wbGVUb2tlbnMubnVsbDtcbiAgfSxcbiAgdW5kZWZpbmVkKF9vYmosIF90eXAsIF9vcHRpb25zLCBfcmVmU3RhY2spIHtcbiAgICByZXR1cm4gc2ltcGxlVG9rZW5zLnVuZGVmaW5lZDtcbiAgfSxcbiAgQXJyYXlCdWZmZXIob2JqLCBfdHlwLCBfb3B0aW9ucywgX3JlZlN0YWNrKSB7XG4gICAgcmV0dXJuIG5ldyBUb2tlbihUeXBlLmJ5dGVzLCBuZXcgVWludDhBcnJheShvYmopKTtcbiAgfSxcbiAgRGF0YVZpZXcob2JqLCBfdHlwLCBfb3B0aW9ucywgX3JlZlN0YWNrKSB7XG4gICAgcmV0dXJuIG5ldyBUb2tlbihUeXBlLmJ5dGVzLCBuZXcgVWludDhBcnJheShvYmouYnVmZmVyLCBvYmouYnl0ZU9mZnNldCwgb2JqLmJ5dGVMZW5ndGgpKTtcbiAgfSxcbiAgQXJyYXkob2JqLCBfdHlwLCBvcHRpb25zLCByZWZTdGFjaykge1xuICAgIGlmICghb2JqLmxlbmd0aCkge1xuICAgICAgaWYgKG9wdGlvbnMuYWRkQnJlYWtUb2tlbnMgPT09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICBzaW1wbGVUb2tlbnMuZW1wdHlBcnJheSxcbiAgICAgICAgICBuZXcgVG9rZW4oVHlwZS5icmVhaylcbiAgICAgICAgXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzaW1wbGVUb2tlbnMuZW1wdHlBcnJheTtcbiAgICB9XG4gICAgcmVmU3RhY2sgPSBSZWYuY3JlYXRlQ2hlY2socmVmU3RhY2ssIG9iaik7XG4gICAgY29uc3QgZW50cmllcyA9IFtdO1xuICAgIGxldCBpID0gMDtcbiAgICBmb3IgKGNvbnN0IGUgb2Ygb2JqKSB7XG4gICAgICBlbnRyaWVzW2krK10gPSBvYmplY3RUb1Rva2VucyhlLCBvcHRpb25zLCByZWZTdGFjayk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmFkZEJyZWFrVG9rZW5zKSB7XG4gICAgICByZXR1cm4gW1xuICAgICAgICBuZXcgVG9rZW4oVHlwZS5hcnJheSwgb2JqLmxlbmd0aCksXG4gICAgICAgIGVudHJpZXMsXG4gICAgICAgIG5ldyBUb2tlbihUeXBlLmJyZWFrKVxuICAgICAgXTtcbiAgICB9XG4gICAgcmV0dXJuIFtcbiAgICAgIG5ldyBUb2tlbihUeXBlLmFycmF5LCBvYmoubGVuZ3RoKSxcbiAgICAgIGVudHJpZXNcbiAgICBdO1xuICB9LFxuICBPYmplY3Qob2JqLCB0eXAsIG9wdGlvbnMsIHJlZlN0YWNrKSB7XG4gICAgY29uc3QgaXNNYXAgPSB0eXAgIT09ICdPYmplY3QnO1xuICAgIGNvbnN0IGtleXMgPSBpc01hcCA/IG9iai5rZXlzKCkgOiBPYmplY3Qua2V5cyhvYmopO1xuICAgIGNvbnN0IGxlbmd0aCA9IGlzTWFwID8gb2JqLnNpemUgOiBrZXlzLmxlbmd0aDtcbiAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgaWYgKG9wdGlvbnMuYWRkQnJlYWtUb2tlbnMgPT09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICBzaW1wbGVUb2tlbnMuZW1wdHlNYXAsXG4gICAgICAgICAgbmV3IFRva2VuKFR5cGUuYnJlYWspXG4gICAgICAgIF07XG4gICAgICB9XG4gICAgICByZXR1cm4gc2ltcGxlVG9rZW5zLmVtcHR5TWFwO1xuICAgIH1cbiAgICByZWZTdGFjayA9IFJlZi5jcmVhdGVDaGVjayhyZWZTdGFjaywgb2JqKTtcbiAgICBjb25zdCBlbnRyaWVzID0gW107XG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgIGVudHJpZXNbaSsrXSA9IFtcbiAgICAgICAgb2JqZWN0VG9Ub2tlbnMoa2V5LCBvcHRpb25zLCByZWZTdGFjayksXG4gICAgICAgIG9iamVjdFRvVG9rZW5zKGlzTWFwID8gb2JqLmdldChrZXkpIDogb2JqW2tleV0sIG9wdGlvbnMsIHJlZlN0YWNrKVxuICAgICAgXTtcbiAgICB9XG4gICAgc29ydE1hcEVudHJpZXMoZW50cmllcywgb3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMuYWRkQnJlYWtUb2tlbnMpIHtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIG5ldyBUb2tlbihUeXBlLm1hcCwgbGVuZ3RoKSxcbiAgICAgICAgZW50cmllcyxcbiAgICAgICAgbmV3IFRva2VuKFR5cGUuYnJlYWspXG4gICAgICBdO1xuICAgIH1cbiAgICByZXR1cm4gW1xuICAgICAgbmV3IFRva2VuKFR5cGUubWFwLCBsZW5ndGgpLFxuICAgICAgZW50cmllc1xuICAgIF07XG4gIH1cbn07XG50eXBlRW5jb2RlcnMuTWFwID0gdHlwZUVuY29kZXJzLk9iamVjdDtcbnR5cGVFbmNvZGVycy5CdWZmZXIgPSB0eXBlRW5jb2RlcnMuVWludDhBcnJheTtcbmZvciAoY29uc3QgdHlwIG9mICdVaW50OENsYW1wZWQgVWludDE2IFVpbnQzMiBJbnQ4IEludDE2IEludDMyIEJpZ1VpbnQ2NCBCaWdJbnQ2NCBGbG9hdDMyIEZsb2F0NjQnLnNwbGl0KCcgJykpIHtcbiAgdHlwZUVuY29kZXJzW2AkeyB0eXAgfUFycmF5YF0gPSB0eXBlRW5jb2RlcnMuRGF0YVZpZXc7XG59XG5mdW5jdGlvbiBvYmplY3RUb1Rva2VucyhvYmosIG9wdGlvbnMgPSB7fSwgcmVmU3RhY2spIHtcbiAgY29uc3QgdHlwID0gaXMob2JqKTtcbiAgY29uc3QgY3VzdG9tVHlwZUVuY29kZXIgPSBvcHRpb25zICYmIG9wdGlvbnMudHlwZUVuY29kZXJzICYmIG9wdGlvbnMudHlwZUVuY29kZXJzW3R5cF0gfHwgdHlwZUVuY29kZXJzW3R5cF07XG4gIGlmICh0eXBlb2YgY3VzdG9tVHlwZUVuY29kZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjb25zdCB0b2tlbnMgPSBjdXN0b21UeXBlRW5jb2RlcihvYmosIHR5cCwgb3B0aW9ucywgcmVmU3RhY2spO1xuICAgIGlmICh0b2tlbnMgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRva2VucztcbiAgICB9XG4gIH1cbiAgY29uc3QgdHlwZUVuY29kZXIgPSB0eXBlRW5jb2RlcnNbdHlwXTtcbiAgaWYgKCF0eXBlRW5jb2Rlcikge1xuICAgIHRocm93IG5ldyBFcnJvcihgJHsgZW5jb2RlRXJyUHJlZml4IH0gdW5zdXBwb3J0ZWQgdHlwZTogJHsgdHlwIH1gKTtcbiAgfVxuICByZXR1cm4gdHlwZUVuY29kZXIob2JqLCB0eXAsIG9wdGlvbnMsIHJlZlN0YWNrKTtcbn1cbmZ1bmN0aW9uIHNvcnRNYXBFbnRyaWVzKGVudHJpZXMsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMubWFwU29ydGVyKSB7XG4gICAgZW50cmllcy5zb3J0KG9wdGlvbnMubWFwU29ydGVyKTtcbiAgfVxufVxuZnVuY3Rpb24gbWFwU29ydGVyKGUxLCBlMikge1xuICBjb25zdCBrZXlUb2tlbjEgPSBBcnJheS5pc0FycmF5KGUxWzBdKSA/IGUxWzBdWzBdIDogZTFbMF07XG4gIGNvbnN0IGtleVRva2VuMiA9IEFycmF5LmlzQXJyYXkoZTJbMF0pID8gZTJbMF1bMF0gOiBlMlswXTtcbiAgaWYgKGtleVRva2VuMS50eXBlICE9PSBrZXlUb2tlbjIudHlwZSkge1xuICAgIHJldHVybiBrZXlUb2tlbjEudHlwZS5jb21wYXJlKGtleVRva2VuMi50eXBlKTtcbiAgfVxuICBjb25zdCBtYWpvciA9IGtleVRva2VuMS50eXBlLm1ham9yO1xuICBjb25zdCB0Y21wID0gY2JvckVuY29kZXJzW21ham9yXS5jb21wYXJlVG9rZW5zKGtleVRva2VuMSwga2V5VG9rZW4yKTtcbiAgaWYgKHRjbXAgPT09IDApIHtcbiAgICBjb25zb2xlLndhcm4oJ1dBUk5JTkc6IGNvbXBsZXgga2V5IHR5cGVzIHVzZWQsIENCT1Iga2V5IHNvcnRpbmcgZ3VhcmFudGVlcyBhcmUgZ29uZScpO1xuICB9XG4gIHJldHVybiB0Y21wO1xufVxuZnVuY3Rpb24gdG9rZW5zVG9FbmNvZGVkKGJ1ZiwgdG9rZW5zLCBlbmNvZGVycywgb3B0aW9ucykge1xuICBpZiAoQXJyYXkuaXNBcnJheSh0b2tlbnMpKSB7XG4gICAgZm9yIChjb25zdCB0b2tlbiBvZiB0b2tlbnMpIHtcbiAgICAgIHRva2Vuc1RvRW5jb2RlZChidWYsIHRva2VuLCBlbmNvZGVycywgb3B0aW9ucyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGVuY29kZXJzW3Rva2Vucy50eXBlLm1ham9yXShidWYsIHRva2Vucywgb3B0aW9ucyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGVuY29kZUN1c3RvbShkYXRhLCBlbmNvZGVycywgb3B0aW9ucykge1xuICBjb25zdCB0b2tlbnMgPSBvYmplY3RUb1Rva2VucyhkYXRhLCBvcHRpb25zKTtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHRva2VucykgJiYgb3B0aW9ucy5xdWlja0VuY29kZVRva2VuKSB7XG4gICAgY29uc3QgcXVpY2tCeXRlcyA9IG9wdGlvbnMucXVpY2tFbmNvZGVUb2tlbih0b2tlbnMpO1xuICAgIGlmIChxdWlja0J5dGVzKSB7XG4gICAgICByZXR1cm4gcXVpY2tCeXRlcztcbiAgICB9XG4gICAgY29uc3QgZW5jb2RlciA9IGVuY29kZXJzW3Rva2Vucy50eXBlLm1ham9yXTtcbiAgICBpZiAoZW5jb2Rlci5lbmNvZGVkU2l6ZSkge1xuICAgICAgY29uc3Qgc2l6ZSA9IGVuY29kZXIuZW5jb2RlZFNpemUodG9rZW5zLCBvcHRpb25zKTtcbiAgICAgIGNvbnN0IGJ1ZiA9IG5ldyBCbChzaXplKTtcbiAgICAgIGVuY29kZXIoYnVmLCB0b2tlbnMsIG9wdGlvbnMpO1xuICAgICAgaWYgKGJ1Zi5jaHVua3MubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBlcnJvcjogcHJlLWNhbGN1bGF0ZWQgbGVuZ3RoIGZvciAkeyB0b2tlbnMgfSB3YXMgd3JvbmdgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhc1U4QShidWYuY2h1bmtzWzBdKTtcbiAgICB9XG4gIH1cbiAgYnVmLnJlc2V0KCk7XG4gIHRva2Vuc1RvRW5jb2RlZChidWYsIHRva2VucywgZW5jb2RlcnMsIG9wdGlvbnMpO1xuICByZXR1cm4gYnVmLnRvQnl0ZXModHJ1ZSk7XG59XG5mdW5jdGlvbiBlbmNvZGUoZGF0YSwgb3B0aW9ucykge1xuICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdEVuY29kZU9wdGlvbnMsIG9wdGlvbnMpO1xuICByZXR1cm4gZW5jb2RlQ3VzdG9tKGRhdGEsIGNib3JFbmNvZGVycywgb3B0aW9ucyk7XG59XG5leHBvcnQge1xuICBvYmplY3RUb1Rva2VucyxcbiAgZW5jb2RlLFxuICBlbmNvZGVDdXN0b20sXG4gIFJlZlxufTsiLCAiaW1wb3J0IHsgZGVjb2RlRXJyUHJlZml4IH0gZnJvbSAnLi9jb21tb24uanMnO1xuaW1wb3J0IHsgVHlwZSB9IGZyb20gJy4vdG9rZW4uanMnO1xuaW1wb3J0IHtcbiAganVtcCxcbiAgcXVpY2tcbn0gZnJvbSAnLi9qdW1wLmpzJztcbmNvbnN0IGRlZmF1bHREZWNvZGVPcHRpb25zID0ge1xuICBzdHJpY3Q6IGZhbHNlLFxuICBhbGxvd0luZGVmaW5pdGU6IHRydWUsXG4gIGFsbG93VW5kZWZpbmVkOiB0cnVlLFxuICBhbGxvd0JpZ0ludDogdHJ1ZVxufTtcbmNsYXNzIFRva2VuaXNlciB7XG4gIGNvbnN0cnVjdG9yKGRhdGEsIG9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMucG9zID0gMDtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH1cbiAgZG9uZSgpIHtcbiAgICByZXR1cm4gdGhpcy5wb3MgPj0gdGhpcy5kYXRhLmxlbmd0aDtcbiAgfVxuICBuZXh0KCkge1xuICAgIGNvbnN0IGJ5dCA9IHRoaXMuZGF0YVt0aGlzLnBvc107XG4gICAgbGV0IHRva2VuID0gcXVpY2tbYnl0XTtcbiAgICBpZiAodG9rZW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgZGVjb2RlciA9IGp1bXBbYnl0XTtcbiAgICAgIGlmICghZGVjb2Rlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7IGRlY29kZUVyclByZWZpeCB9IG5vIGRlY29kZXIgZm9yIG1ham9yIHR5cGUgJHsgYnl0ID4+PiA1IH0gKGJ5dGUgMHgkeyBieXQudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykgfSlgKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1pbm9yID0gYnl0ICYgMzE7XG4gICAgICB0b2tlbiA9IGRlY29kZXIodGhpcy5kYXRhLCB0aGlzLnBvcywgbWlub3IsIHRoaXMub3B0aW9ucyk7XG4gICAgfVxuICAgIHRoaXMucG9zICs9IHRva2VuLmVuY29kZWRMZW5ndGg7XG4gICAgcmV0dXJuIHRva2VuO1xuICB9XG59XG5jb25zdCBET05FID0gU3ltYm9sLmZvcignRE9ORScpO1xuY29uc3QgQlJFQUsgPSBTeW1ib2wuZm9yKCdCUkVBSycpO1xuZnVuY3Rpb24gdG9rZW5Ub0FycmF5KHRva2VuLCB0b2tlbmlzZXIsIG9wdGlvbnMpIHtcbiAgY29uc3QgYXJyID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdG9rZW4udmFsdWU7IGkrKykge1xuICAgIGNvbnN0IHZhbHVlID0gdG9rZW5zVG9PYmplY3QodG9rZW5pc2VyLCBvcHRpb25zKTtcbiAgICBpZiAodmFsdWUgPT09IEJSRUFLKSB7XG4gICAgICBpZiAodG9rZW4udmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGAkeyBkZWNvZGVFcnJQcmVmaXggfSBnb3QgdW5leHBlY3RlZCBicmVhayB0byBsZW5ndGhlZCBhcnJheWApO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPT09IERPTkUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHsgZGVjb2RlRXJyUHJlZml4IH0gZm91bmQgYXJyYXkgYnV0IG5vdCBlbm91Z2ggZW50cmllcyAoZ290ICR7IGkgfSwgZXhwZWN0ZWQgJHsgdG9rZW4udmFsdWUgfSlgKTtcbiAgICB9XG4gICAgYXJyW2ldID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIGFycjtcbn1cbmZ1bmN0aW9uIHRva2VuVG9NYXAodG9rZW4sIHRva2VuaXNlciwgb3B0aW9ucykge1xuICBjb25zdCB1c2VNYXBzID0gb3B0aW9ucy51c2VNYXBzID09PSB0cnVlO1xuICBjb25zdCBvYmogPSB1c2VNYXBzID8gdW5kZWZpbmVkIDoge307XG4gIGNvbnN0IG0gPSB1c2VNYXBzID8gbmV3IE1hcCgpIDogdW5kZWZpbmVkO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHRva2VuLnZhbHVlOyBpKyspIHtcbiAgICBjb25zdCBrZXkgPSB0b2tlbnNUb09iamVjdCh0b2tlbmlzZXIsIG9wdGlvbnMpO1xuICAgIGlmIChrZXkgPT09IEJSRUFLKSB7XG4gICAgICBpZiAodG9rZW4udmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGAkeyBkZWNvZGVFcnJQcmVmaXggfSBnb3QgdW5leHBlY3RlZCBicmVhayB0byBsZW5ndGhlZCBtYXBgKTtcbiAgICB9XG4gICAgaWYgKGtleSA9PT0gRE9ORSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAkeyBkZWNvZGVFcnJQcmVmaXggfSBmb3VuZCBtYXAgYnV0IG5vdCBlbm91Z2ggZW50cmllcyAoZ290ICR7IGkgfSBbbm8ga2V5XSwgZXhwZWN0ZWQgJHsgdG9rZW4udmFsdWUgfSlgKTtcbiAgICB9XG4gICAgaWYgKHVzZU1hcHMgIT09IHRydWUgJiYgdHlwZW9mIGtleSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHsgZGVjb2RlRXJyUHJlZml4IH0gbm9uLXN0cmluZyBrZXlzIG5vdCBzdXBwb3J0ZWQgKGdvdCAkeyB0eXBlb2Yga2V5IH0pYCk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnJlamVjdER1cGxpY2F0ZU1hcEtleXMgPT09IHRydWUpIHtcbiAgICAgIGlmICh1c2VNYXBzICYmIG0uaGFzKGtleSkgfHwgIXVzZU1hcHMgJiYga2V5IGluIG9iaikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7IGRlY29kZUVyclByZWZpeCB9IGZvdW5kIHJlcGVhdCBtYXAga2V5IFwiJHsga2V5IH1cImApO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB2YWx1ZSA9IHRva2Vuc1RvT2JqZWN0KHRva2VuaXNlciwgb3B0aW9ucyk7XG4gICAgaWYgKHZhbHVlID09PSBET05FKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7IGRlY29kZUVyclByZWZpeCB9IGZvdW5kIG1hcCBidXQgbm90IGVub3VnaCBlbnRyaWVzIChnb3QgJHsgaSB9IFtubyB2YWx1ZV0sIGV4cGVjdGVkICR7IHRva2VuLnZhbHVlIH0pYCk7XG4gICAgfVxuICAgIGlmICh1c2VNYXBzKSB7XG4gICAgICBtLnNldChrZXksIHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHVzZU1hcHMgPyBtIDogb2JqO1xufVxuZnVuY3Rpb24gdG9rZW5zVG9PYmplY3QodG9rZW5pc2VyLCBvcHRpb25zKSB7XG4gIGlmICh0b2tlbmlzZXIuZG9uZSgpKSB7XG4gICAgcmV0dXJuIERPTkU7XG4gIH1cbiAgY29uc3QgdG9rZW4gPSB0b2tlbmlzZXIubmV4dCgpO1xuICBpZiAodG9rZW4udHlwZSA9PT0gVHlwZS5icmVhaykge1xuICAgIHJldHVybiBCUkVBSztcbiAgfVxuICBpZiAodG9rZW4udHlwZS50ZXJtaW5hbCkge1xuICAgIHJldHVybiB0b2tlbi52YWx1ZTtcbiAgfVxuICBpZiAodG9rZW4udHlwZSA9PT0gVHlwZS5hcnJheSkge1xuICAgIHJldHVybiB0b2tlblRvQXJyYXkodG9rZW4sIHRva2VuaXNlciwgb3B0aW9ucyk7XG4gIH1cbiAgaWYgKHRva2VuLnR5cGUgPT09IFR5cGUubWFwKSB7XG4gICAgcmV0dXJuIHRva2VuVG9NYXAodG9rZW4sIHRva2VuaXNlciwgb3B0aW9ucyk7XG4gIH1cbiAgaWYgKHRva2VuLnR5cGUgPT09IFR5cGUudGFnKSB7XG4gICAgaWYgKG9wdGlvbnMudGFncyAmJiB0eXBlb2Ygb3B0aW9ucy50YWdzW3Rva2VuLnZhbHVlXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29uc3QgdGFnZ2VkID0gdG9rZW5zVG9PYmplY3QodG9rZW5pc2VyLCBvcHRpb25zKTtcbiAgICAgIHJldHVybiBvcHRpb25zLnRhZ3NbdG9rZW4udmFsdWVdKHRhZ2dlZCk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgJHsgZGVjb2RlRXJyUHJlZml4IH0gdGFnIG5vdCBzdXBwb3J0ZWQgKCR7IHRva2VuLnZhbHVlIH0pYCk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKCd1bnN1cHBvcnRlZCcpO1xufVxuZnVuY3Rpb24gZGVjb2RlKGRhdGEsIG9wdGlvbnMpIHtcbiAgaWYgKCEoZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGAkeyBkZWNvZGVFcnJQcmVmaXggfSBkYXRhIHRvIGRlY29kZSBtdXN0IGJlIGEgVWludDhBcnJheWApO1xuICB9XG4gIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0RGVjb2RlT3B0aW9ucywgb3B0aW9ucyk7XG4gIGNvbnN0IHRva2VuaXNlciA9IG9wdGlvbnMudG9rZW5pemVyIHx8IG5ldyBUb2tlbmlzZXIoZGF0YSwgb3B0aW9ucyk7XG4gIGNvbnN0IGRlY29kZWQgPSB0b2tlbnNUb09iamVjdCh0b2tlbmlzZXIsIG9wdGlvbnMpO1xuICBpZiAoZGVjb2RlZCA9PT0gRE9ORSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgJHsgZGVjb2RlRXJyUHJlZml4IH0gZGlkIG5vdCBmaW5kIGFueSBjb250ZW50IHRvIGRlY29kZWApO1xuICB9XG4gIGlmIChkZWNvZGVkID09PSBCUkVBSykge1xuICAgIHRocm93IG5ldyBFcnJvcihgJHsgZGVjb2RlRXJyUHJlZml4IH0gZ290IHVuZXhwZWN0ZWQgYnJlYWtgKTtcbiAgfVxuICBpZiAoIXRva2VuaXNlci5kb25lKCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7IGRlY29kZUVyclByZWZpeCB9IHRvbyBtYW55IHRlcm1pbmFscywgZGF0YSBtYWtlcyBubyBzZW5zZWApO1xuICB9XG4gIHJldHVybiBkZWNvZGVkO1xufVxuZXhwb3J0IHtcbiAgVG9rZW5pc2VyLFxuICB0b2tlbnNUb09iamVjdCxcbiAgZGVjb2RlXG59OyIsICJpbXBvcnQgKiBhcyBjYm9yZyBmcm9tICdjYm9yZyc7XG5pbXBvcnQgeyBDSUQgfSBmcm9tICdtdWx0aWZvcm1hdHMvY2lkJztcbmNvbnN0IENJRF9DQk9SX1RBRyA9IDQyO1xuZnVuY3Rpb24gY2lkRW5jb2RlcihvYmopIHtcbiAgaWYgKG9iai5hc0NJRCAhPT0gb2JqKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgY2lkID0gQ0lELmFzQ0lEKG9iaik7XG4gIGlmICghY2lkKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShjaWQuYnl0ZXMuYnl0ZUxlbmd0aCArIDEpO1xuICBieXRlcy5zZXQoY2lkLmJ5dGVzLCAxKTtcbiAgcmV0dXJuIFtcbiAgICBuZXcgY2JvcmcuVG9rZW4oY2JvcmcuVHlwZS50YWcsIENJRF9DQk9SX1RBRyksXG4gICAgbmV3IGNib3JnLlRva2VuKGNib3JnLlR5cGUuYnl0ZXMsIGJ5dGVzKVxuICBdO1xufVxuZnVuY3Rpb24gdW5kZWZpbmVkRW5jb2RlcigpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdgdW5kZWZpbmVkYCBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBJUExEIERhdGEgTW9kZWwgYW5kIGNhbm5vdCBiZSBlbmNvZGVkJyk7XG59XG5mdW5jdGlvbiBudW1iZXJFbmNvZGVyKG51bSkge1xuICBpZiAoTnVtYmVyLmlzTmFOKG51bSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2BOYU5gIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIElQTEQgRGF0YSBNb2RlbCBhbmQgY2Fubm90IGJlIGVuY29kZWQnKTtcbiAgfVxuICBpZiAobnVtID09PSBJbmZpbml0eSB8fCBudW0gPT09IC1JbmZpbml0eSkge1xuICAgIHRocm93IG5ldyBFcnJvcignYEluZmluaXR5YCBhbmQgYC1JbmZpbml0eWAgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgSVBMRCBEYXRhIE1vZGVsIGFuZCBjYW5ub3QgYmUgZW5jb2RlZCcpO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuY29uc3QgZW5jb2RlT3B0aW9ucyA9IHtcbiAgZmxvYXQ2NDogdHJ1ZSxcbiAgdHlwZUVuY29kZXJzOiB7XG4gICAgT2JqZWN0OiBjaWRFbmNvZGVyLFxuICAgIHVuZGVmaW5lZDogdW5kZWZpbmVkRW5jb2RlcixcbiAgICBudW1iZXI6IG51bWJlckVuY29kZXJcbiAgfVxufTtcbmZ1bmN0aW9uIGNpZERlY29kZXIoYnl0ZXMpIHtcbiAgaWYgKGJ5dGVzWzBdICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIENJRCBmb3IgQ0JPUiB0YWcgNDI7IGV4cGVjdGVkIGxlYWRpbmcgMHgwMCcpO1xuICB9XG4gIHJldHVybiBDSUQuZGVjb2RlKGJ5dGVzLnN1YmFycmF5KDEpKTtcbn1cbmNvbnN0IGRlY29kZU9wdGlvbnMgPSB7XG4gIGFsbG93SW5kZWZpbml0ZTogZmFsc2UsXG4gIGNvZXJjZVVuZGVmaW5lZFRvTnVsbDogdHJ1ZSxcbiAgYWxsb3dOYU46IGZhbHNlLFxuICBhbGxvd0luZmluaXR5OiBmYWxzZSxcbiAgYWxsb3dCaWdJbnQ6IHRydWUsXG4gIHN0cmljdDogdHJ1ZSxcbiAgdXNlTWFwczogZmFsc2UsXG4gIHRhZ3M6IFtdXG59O1xuZGVjb2RlT3B0aW9ucy50YWdzW0NJRF9DQk9SX1RBR10gPSBjaWREZWNvZGVyO1xuZXhwb3J0IGNvbnN0IG5hbWUgPSAnZGFnLWNib3InO1xuZXhwb3J0IGNvbnN0IGNvZGUgPSAxMTM7XG5leHBvcnQgY29uc3QgZW5jb2RlID0gbm9kZSA9PiBjYm9yZy5lbmNvZGUobm9kZSwgZW5jb2RlT3B0aW9ucyk7XG5leHBvcnQgY29uc3QgZGVjb2RlID0gZGF0YSA9PiBjYm9yZy5kZWNvZGUoZGF0YSwgZGVjb2RlT3B0aW9ucyk7IiwgImltcG9ydCB7XG4gIGFzeW5jSXRlcmFibGVSZWFkZXIsXG4gIGJ5dGVzUmVhZGVyLFxuICBjcmVhdGVEZWNvZGVyXG59IGZyb20gJy4vZGVjb2Rlci5qcyc7XG5leHBvcnQgY2xhc3MgQ2FyUmVhZGVyIHtcbiAgY29uc3RydWN0b3IodmVyc2lvbiwgcm9vdHMsIGJsb2Nrcykge1xuICAgIHRoaXMuX3ZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIHRoaXMuX3Jvb3RzID0gcm9vdHM7XG4gICAgdGhpcy5fYmxvY2tzID0gYmxvY2tzO1xuICAgIHRoaXMuX2tleXMgPSBibG9ja3MubWFwKGIgPT4gYi5jaWQudG9TdHJpbmcoKSk7XG4gIH1cbiAgZ2V0IHZlcnNpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZlcnNpb247XG4gIH1cbiAgYXN5bmMgZ2V0Um9vdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jvb3RzO1xuICB9XG4gIGFzeW5jIGhhcyhrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5fa2V5cy5pbmRleE9mKGtleS50b1N0cmluZygpKSA+IC0xO1xuICB9XG4gIGFzeW5jIGdldChrZXkpIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuX2tleXMuaW5kZXhPZihrZXkudG9TdHJpbmcoKSk7XG4gICAgcmV0dXJuIGluZGV4ID4gLTEgPyB0aGlzLl9ibG9ja3NbaW5kZXhdIDogdW5kZWZpbmVkO1xuICB9XG4gIGFzeW5jICpibG9ja3MoKSB7XG4gICAgZm9yIChjb25zdCBibG9jayBvZiB0aGlzLl9ibG9ja3MpIHtcbiAgICAgIHlpZWxkIGJsb2NrO1xuICAgIH1cbiAgfVxuICBhc3luYyAqY2lkcygpIHtcbiAgICBmb3IgKGNvbnN0IGJsb2NrIG9mIHRoaXMuX2Jsb2Nrcykge1xuICAgICAgeWllbGQgYmxvY2suY2lkO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgYXN5bmMgZnJvbUJ5dGVzKGJ5dGVzKSB7XG4gICAgaWYgKCEoYnl0ZXMgaW5zdGFuY2VvZiBVaW50OEFycmF5KSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZnJvbUJ5dGVzKCkgcmVxdWlyZXMgYSBVaW50OEFycmF5Jyk7XG4gICAgfVxuICAgIHJldHVybiBkZWNvZGVSZWFkZXJDb21wbGV0ZShieXRlc1JlYWRlcihieXRlcykpO1xuICB9XG4gIHN0YXRpYyBhc3luYyBmcm9tSXRlcmFibGUoYXN5bmNJdGVyYWJsZSkge1xuICAgIGlmICghYXN5bmNJdGVyYWJsZSB8fCAhKHR5cGVvZiBhc3luY0l0ZXJhYmxlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2Zyb21JdGVyYWJsZSgpIHJlcXVpcmVzIGFuIGFzeW5jIGl0ZXJhYmxlJyk7XG4gICAgfVxuICAgIHJldHVybiBkZWNvZGVSZWFkZXJDb21wbGV0ZShhc3luY0l0ZXJhYmxlUmVhZGVyKGFzeW5jSXRlcmFibGUpKTtcbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gZGVjb2RlUmVhZGVyQ29tcGxldGUocmVhZGVyKSB7XG4gIGNvbnN0IGRlY29kZXIgPSBjcmVhdGVEZWNvZGVyKHJlYWRlcik7XG4gIGNvbnN0IHt2ZXJzaW9uLCByb290c30gPSBhd2FpdCBkZWNvZGVyLmhlYWRlcigpO1xuICBjb25zdCBibG9ja3MgPSBbXTtcbiAgZm9yIGF3YWl0IChjb25zdCBibG9jayBvZiBkZWNvZGVyLmJsb2NrcygpKSB7XG4gICAgYmxvY2tzLnB1c2goYmxvY2spO1xuICB9XG4gIHJldHVybiBuZXcgQ2FyUmVhZGVyKHZlcnNpb24sIHJvb3RzLCBibG9ja3MpO1xufVxuZXhwb3J0IGNvbnN0IF9fYnJvd3NlciA9IHRydWU7IiwgImltcG9ydCB7XG4gIGFzeW5jSXRlcmFibGVSZWFkZXIsXG4gIGJ5dGVzUmVhZGVyLFxuICBjcmVhdGVEZWNvZGVyXG59IGZyb20gJy4vZGVjb2Rlci5qcyc7XG5leHBvcnQgY2xhc3MgQ2FySW5kZXhlciB7XG4gIGNvbnN0cnVjdG9yKHZlcnNpb24sIHJvb3RzLCBpdGVyYXRvcikge1xuICAgIHRoaXMuX3ZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIHRoaXMuX3Jvb3RzID0gcm9vdHM7XG4gICAgdGhpcy5faXRlcmF0b3IgPSBpdGVyYXRvcjtcbiAgfVxuICBnZXQgdmVyc2lvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fdmVyc2lvbjtcbiAgfVxuICBhc3luYyBnZXRSb290cygpIHtcbiAgICByZXR1cm4gdGhpcy5fcm9vdHM7XG4gIH1cbiAgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcbiAgICByZXR1cm4gdGhpcy5faXRlcmF0b3I7XG4gIH1cbiAgc3RhdGljIGFzeW5jIGZyb21CeXRlcyhieXRlcykge1xuICAgIGlmICghKGJ5dGVzIGluc3RhbmNlb2YgVWludDhBcnJheSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2Zyb21CeXRlcygpIHJlcXVpcmVzIGEgVWludDhBcnJheScpO1xuICAgIH1cbiAgICByZXR1cm4gZGVjb2RlSW5kZXhlckNvbXBsZXRlKGJ5dGVzUmVhZGVyKGJ5dGVzKSk7XG4gIH1cbiAgc3RhdGljIGFzeW5jIGZyb21JdGVyYWJsZShhc3luY0l0ZXJhYmxlKSB7XG4gICAgaWYgKCFhc3luY0l0ZXJhYmxlIHx8ICEodHlwZW9mIGFzeW5jSXRlcmFibGVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID09PSAnZnVuY3Rpb24nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZnJvbUl0ZXJhYmxlKCkgcmVxdWlyZXMgYW4gYXN5bmMgaXRlcmFibGUnKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlY29kZUluZGV4ZXJDb21wbGV0ZShhc3luY0l0ZXJhYmxlUmVhZGVyKGFzeW5jSXRlcmFibGUpKTtcbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gZGVjb2RlSW5kZXhlckNvbXBsZXRlKHJlYWRlcikge1xuICBjb25zdCBkZWNvZGVyID0gY3JlYXRlRGVjb2RlcihyZWFkZXIpO1xuICBjb25zdCB7dmVyc2lvbiwgcm9vdHN9ID0gYXdhaXQgZGVjb2Rlci5oZWFkZXIoKTtcbiAgcmV0dXJuIG5ldyBDYXJJbmRleGVyKHZlcnNpb24sIHJvb3RzLCBkZWNvZGVyLmJsb2Nrc0luZGV4KCkpO1xufSIsICJpbXBvcnQge1xuICBhc3luY0l0ZXJhYmxlUmVhZGVyLFxuICBieXRlc1JlYWRlcixcbiAgY3JlYXRlRGVjb2RlclxufSBmcm9tICcuL2RlY29kZXIuanMnO1xuZXhwb3J0IGNsYXNzIENhckl0ZXJhdG9yQmFzZSB7XG4gIGNvbnN0cnVjdG9yKHZlcnNpb24sIHJvb3RzLCBpdGVyYWJsZSkge1xuICAgIHRoaXMuX3ZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIHRoaXMuX3Jvb3RzID0gcm9vdHM7XG4gICAgdGhpcy5faXRlcmFibGUgPSBpdGVyYWJsZTtcbiAgICB0aGlzLl9kZWNvZGVkID0gZmFsc2U7XG4gIH1cbiAgZ2V0IHZlcnNpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZlcnNpb247XG4gIH1cbiAgYXN5bmMgZ2V0Um9vdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jvb3RzO1xuICB9XG59XG5leHBvcnQgY2xhc3MgQ2FyQmxvY2tJdGVyYXRvciBleHRlbmRzIENhckl0ZXJhdG9yQmFzZSB7XG4gIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG4gICAgaWYgKHRoaXMuX2RlY29kZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGRlY29kZSBtb3JlIHRoYW4gb25jZScpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX2l0ZXJhYmxlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Jsb2NrIGl0ZXJhYmxlIG5vdCBmb3VuZCcpO1xuICAgIH1cbiAgICB0aGlzLl9kZWNvZGVkID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcy5faXRlcmFibGVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCk7XG4gIH1cbiAgc3RhdGljIGFzeW5jIGZyb21CeXRlcyhieXRlcykge1xuICAgIGNvbnN0IHt2ZXJzaW9uLCByb290cywgaXRlcmF0b3J9ID0gYXdhaXQgZnJvbUJ5dGVzKGJ5dGVzKTtcbiAgICByZXR1cm4gbmV3IENhckJsb2NrSXRlcmF0b3IodmVyc2lvbiwgcm9vdHMsIGl0ZXJhdG9yKTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgZnJvbUl0ZXJhYmxlKGFzeW5jSXRlcmFibGUpIHtcbiAgICBjb25zdCB7dmVyc2lvbiwgcm9vdHMsIGl0ZXJhdG9yfSA9IGF3YWl0IGZyb21JdGVyYWJsZShhc3luY0l0ZXJhYmxlKTtcbiAgICByZXR1cm4gbmV3IENhckJsb2NrSXRlcmF0b3IodmVyc2lvbiwgcm9vdHMsIGl0ZXJhdG9yKTtcbiAgfVxufVxuZXhwb3J0IGNsYXNzIENhckNJREl0ZXJhdG9yIGV4dGVuZHMgQ2FySXRlcmF0b3JCYXNlIHtcbiAgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcbiAgICBpZiAodGhpcy5fZGVjb2RlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZGVjb2RlIG1vcmUgdGhhbiBvbmNlJyk7XG4gICAgfVxuICAgIGlmICghdGhpcy5faXRlcmFibGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQmxvY2sgaXRlcmFibGUgbm90IGZvdW5kJyk7XG4gICAgfVxuICAgIHRoaXMuX2RlY29kZWQgPSB0cnVlO1xuICAgIGNvbnN0IGl0ZXJhYmxlID0gdGhpcy5faXRlcmFibGVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFzeW5jIG5leHQoKSB7XG4gICAgICAgIGNvbnN0IG5leHQgPSBhd2FpdCBpdGVyYWJsZS5uZXh0KCk7XG4gICAgICAgIGlmIChuZXh0LmRvbmUpIHtcbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICAgIHZhbHVlOiBuZXh0LnZhbHVlLmNpZFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgc3RhdGljIGFzeW5jIGZyb21CeXRlcyhieXRlcykge1xuICAgIGNvbnN0IHt2ZXJzaW9uLCByb290cywgaXRlcmF0b3J9ID0gYXdhaXQgZnJvbUJ5dGVzKGJ5dGVzKTtcbiAgICByZXR1cm4gbmV3IENhckNJREl0ZXJhdG9yKHZlcnNpb24sIHJvb3RzLCBpdGVyYXRvcik7XG4gIH1cbiAgc3RhdGljIGFzeW5jIGZyb21JdGVyYWJsZShhc3luY0l0ZXJhYmxlKSB7XG4gICAgY29uc3Qge3ZlcnNpb24sIHJvb3RzLCBpdGVyYXRvcn0gPSBhd2FpdCBmcm9tSXRlcmFibGUoYXN5bmNJdGVyYWJsZSk7XG4gICAgcmV0dXJuIG5ldyBDYXJDSURJdGVyYXRvcih2ZXJzaW9uLCByb290cywgaXRlcmF0b3IpO1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiBmcm9tQnl0ZXMoYnl0ZXMpIHtcbiAgaWYgKCEoYnl0ZXMgaW5zdGFuY2VvZiBVaW50OEFycmF5KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2Zyb21CeXRlcygpIHJlcXVpcmVzIGEgVWludDhBcnJheScpO1xuICB9XG4gIHJldHVybiBkZWNvZGVJdGVyYXRvcihieXRlc1JlYWRlcihieXRlcykpO1xufVxuYXN5bmMgZnVuY3Rpb24gZnJvbUl0ZXJhYmxlKGFzeW5jSXRlcmFibGUpIHtcbiAgaWYgKCFhc3luY0l0ZXJhYmxlIHx8ICEodHlwZW9mIGFzeW5jSXRlcmFibGVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID09PSAnZnVuY3Rpb24nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2Zyb21JdGVyYWJsZSgpIHJlcXVpcmVzIGFuIGFzeW5jIGl0ZXJhYmxlJyk7XG4gIH1cbiAgcmV0dXJuIGRlY29kZUl0ZXJhdG9yKGFzeW5jSXRlcmFibGVSZWFkZXIoYXN5bmNJdGVyYWJsZSkpO1xufVxuYXN5bmMgZnVuY3Rpb24gZGVjb2RlSXRlcmF0b3IocmVhZGVyKSB7XG4gIGNvbnN0IGRlY29kZXIgPSBjcmVhdGVEZWNvZGVyKHJlYWRlcik7XG4gIGNvbnN0IHt2ZXJzaW9uLCByb290c30gPSBhd2FpdCBkZWNvZGVyLmhlYWRlcigpO1xuICByZXR1cm4ge1xuICAgIHZlcnNpb24sXG4gICAgcm9vdHMsXG4gICAgaXRlcmF0b3I6IGRlY29kZXIuYmxvY2tzKClcbiAgfTtcbn0iLCAiaW1wb3J0IGZzIGZyb20gJ2ZzJztcbmltcG9ydCB7IHByb21pc2lmeSB9IGZyb20gJ3V0aWwnO1xuaW1wb3J0IHsgQ2FyV3JpdGVyIGFzIEJyb3dzZXJDYXJXcml0ZXIgfSBmcm9tICcuL3dyaXRlci1icm93c2VyLmpzJztcbmltcG9ydCB7XG4gIHJlYWRIZWFkZXIsXG4gIGNodW5rUmVhZGVyXG59IGZyb20gJy4vZGVjb2Rlci5qcyc7XG5pbXBvcnQgeyBjcmVhdGVIZWFkZXIgfSBmcm9tICcuL2VuY29kZXIuanMnO1xuY29uc3QgZnNyZWFkID0gcHJvbWlzaWZ5KGZzLnJlYWQpO1xuY29uc3QgZnN3cml0ZSA9IHByb21pc2lmeShmcy53cml0ZSk7XG5leHBvcnQgY2xhc3MgQ2FyV3JpdGVyIGV4dGVuZHMgQnJvd3NlckNhcldyaXRlciB7XG4gIHN0YXRpYyBhc3luYyB1cGRhdGVSb290c0luRmlsZShmZCwgcm9vdHMpIHtcbiAgICBjb25zdCBjaHVua1NpemUgPSAyNTY7XG4gICAgbGV0IGJ5dGVzO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGxldCByZWFkQ2h1bms7XG4gICAgaWYgKHR5cGVvZiBmZCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJlYWRDaHVuayA9IGFzeW5jICgpID0+IChhd2FpdCBmc3JlYWQoZmQsIGJ5dGVzLCAwLCBjaHVua1NpemUsIG9mZnNldCkpLmJ5dGVzUmVhZDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBmZCA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGZkLnJlYWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJlYWRDaHVuayA9IGFzeW5jICgpID0+IChhd2FpdCBmZC5yZWFkKGJ5dGVzLCAwLCBjaHVua1NpemUsIG9mZnNldCkpLmJ5dGVzUmVhZDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQmFkIGZkJyk7XG4gICAgfVxuICAgIGNvbnN0IGZkUmVhZGVyID0gY2h1bmtSZWFkZXIoYXN5bmMgKCkgPT4ge1xuICAgICAgYnl0ZXMgPSBuZXcgVWludDhBcnJheShjaHVua1NpemUpO1xuICAgICAgY29uc3QgcmVhZCA9IGF3YWl0IHJlYWRDaHVuaygpO1xuICAgICAgb2Zmc2V0ICs9IHJlYWQ7XG4gICAgICByZXR1cm4gcmVhZCA8IGNodW5rU2l6ZSA/IGJ5dGVzLnN1YmFycmF5KDAsIHJlYWQpIDogYnl0ZXM7XG4gICAgfSk7XG4gICAgYXdhaXQgcmVhZEhlYWRlcihmZFJlYWRlcik7XG4gICAgY29uc3QgbmV3SGVhZGVyID0gY3JlYXRlSGVhZGVyKHJvb3RzKTtcbiAgICBpZiAoZmRSZWFkZXIucG9zICE9PSBuZXdIZWFkZXIubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVwZGF0ZVJvb3RzKCkgY2FuIG9ubHkgb3ZlcndyaXRlIGEgaGVhZGVyIG9mIHRoZSBzYW1lIGxlbmd0aCAob2xkIGhlYWRlciBpcyAkeyBmZFJlYWRlci5wb3MgfSBieXRlcywgbmV3IGhlYWRlciBpcyAkeyBuZXdIZWFkZXIubGVuZ3RoIH0gYnl0ZXMpYCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZmQgPT09ICdudW1iZXInKSB7XG4gICAgICBhd2FpdCBmc3dyaXRlKGZkLCBuZXdIZWFkZXIsIDAsIG5ld0hlYWRlci5sZW5ndGgsIDApO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGZkID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgZmQucmVhZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgYXdhaXQgZmQud3JpdGUobmV3SGVhZGVyLCAwLCBuZXdIZWFkZXIubGVuZ3RoLCAwKTtcbiAgICB9XG4gIH1cbn1cbmV4cG9ydCBjb25zdCBfX2Jyb3dzZXIgPSBmYWxzZTsiLCAiaW1wb3J0IHZhcmludCBmcm9tICd2YXJpbnQnO1xuaW1wb3J0IHsgZW5jb2RlIGFzIGRhZ0Nib3JFbmNvZGUgfSBmcm9tICdAaXBsZC9kYWctY2Jvcic7XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlSGVhZGVyKHJvb3RzKSB7XG4gIGNvbnN0IGhlYWRlckJ5dGVzID0gZGFnQ2JvckVuY29kZSh7XG4gICAgdmVyc2lvbjogMSxcbiAgICByb290c1xuICB9KTtcbiAgY29uc3QgdmFyaW50Qnl0ZXMgPSB2YXJpbnQuZW5jb2RlKGhlYWRlckJ5dGVzLmxlbmd0aCk7XG4gIGNvbnN0IGhlYWRlciA9IG5ldyBVaW50OEFycmF5KHZhcmludEJ5dGVzLmxlbmd0aCArIGhlYWRlckJ5dGVzLmxlbmd0aCk7XG4gIGhlYWRlci5zZXQodmFyaW50Qnl0ZXMsIDApO1xuICBoZWFkZXIuc2V0KGhlYWRlckJ5dGVzLCB2YXJpbnRCeXRlcy5sZW5ndGgpO1xuICByZXR1cm4gaGVhZGVyO1xufVxuZnVuY3Rpb24gY3JlYXRlRW5jb2Rlcih3cml0ZXIpIHtcbiAgcmV0dXJuIHtcbiAgICBhc3luYyBzZXRSb290cyhyb290cykge1xuICAgICAgY29uc3QgYnl0ZXMgPSBjcmVhdGVIZWFkZXIocm9vdHMpO1xuICAgICAgYXdhaXQgd3JpdGVyLndyaXRlKGJ5dGVzKTtcbiAgICB9LFxuICAgIGFzeW5jIHdyaXRlQmxvY2soYmxvY2spIHtcbiAgICAgIGNvbnN0IHtjaWQsIGJ5dGVzfSA9IGJsb2NrO1xuICAgICAgYXdhaXQgd3JpdGVyLndyaXRlKG5ldyBVaW50OEFycmF5KHZhcmludC5lbmNvZGUoY2lkLmJ5dGVzLmxlbmd0aCArIGJ5dGVzLmxlbmd0aCkpKTtcbiAgICAgIGF3YWl0IHdyaXRlci53cml0ZShjaWQuYnl0ZXMpO1xuICAgICAgaWYgKGJ5dGVzLmxlbmd0aCkge1xuICAgICAgICBhd2FpdCB3cml0ZXIud3JpdGUoYnl0ZXMpO1xuICAgICAgfVxuICAgIH0sXG4gICAgYXN5bmMgY2xvc2UoKSB7XG4gICAgICByZXR1cm4gd3JpdGVyLmVuZCgpO1xuICAgIH1cbiAgfTtcbn1cbmV4cG9ydCB7XG4gIGNyZWF0ZUVuY29kZXJcbn07IiwgImZ1bmN0aW9uIG5vb3AoKSB7XG59XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlKCkge1xuICBjb25zdCBjaHVua1F1ZXVlID0gW107XG4gIGxldCBkcmFpbmVyID0gbnVsbDtcbiAgbGV0IGRyYWluZXJSZXNvbHZlciA9IG5vb3A7XG4gIGxldCBlbmRlZCA9IGZhbHNlO1xuICBsZXQgb3V0V2FpdCA9IG51bGw7XG4gIGxldCBvdXRXYWl0UmVzb2x2ZXIgPSBub29wO1xuICBjb25zdCBtYWtlRHJhaW5lciA9ICgpID0+IHtcbiAgICBpZiAoIWRyYWluZXIpIHtcbiAgICAgIGRyYWluZXIgPSBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgZHJhaW5lclJlc29sdmVyID0gKCkgPT4ge1xuICAgICAgICAgIGRyYWluZXIgPSBudWxsO1xuICAgICAgICAgIGRyYWluZXJSZXNvbHZlciA9IG5vb3A7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBkcmFpbmVyO1xuICB9O1xuICBjb25zdCB3cml0ZXIgPSB7XG4gICAgd3JpdGUoY2h1bmspIHtcbiAgICAgIGNodW5rUXVldWUucHVzaChjaHVuayk7XG4gICAgICBjb25zdCBkcmFpbmVyID0gbWFrZURyYWluZXIoKTtcbiAgICAgIG91dFdhaXRSZXNvbHZlcigpO1xuICAgICAgcmV0dXJuIGRyYWluZXI7XG4gICAgfSxcbiAgICBhc3luYyBlbmQoKSB7XG4gICAgICBlbmRlZCA9IHRydWU7XG4gICAgICBjb25zdCBkcmFpbmVyID0gbWFrZURyYWluZXIoKTtcbiAgICAgIG91dFdhaXRSZXNvbHZlcigpO1xuICAgICAgcmV0dXJuIGRyYWluZXI7XG4gICAgfVxuICB9O1xuICBjb25zdCBpdGVyYXRvciA9IHtcbiAgICBhc3luYyBuZXh0KCkge1xuICAgICAgY29uc3QgY2h1bmsgPSBjaHVua1F1ZXVlLnNoaWZ0KCk7XG4gICAgICBpZiAoY2h1bmspIHtcbiAgICAgICAgaWYgKGNodW5rUXVldWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgZHJhaW5lclJlc29sdmVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkb25lOiBmYWxzZSxcbiAgICAgICAgICB2YWx1ZTogY2h1bmtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmIChlbmRlZCkge1xuICAgICAgICBkcmFpbmVyUmVzb2x2ZXIoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkb25lOiB0cnVlLFxuICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWRcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmICghb3V0V2FpdCkge1xuICAgICAgICBvdXRXYWl0ID0gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgb3V0V2FpdFJlc29sdmVyID0gKCkgPT4ge1xuICAgICAgICAgICAgb3V0V2FpdCA9IG51bGw7XG4gICAgICAgICAgICBvdXRXYWl0UmVzb2x2ZXIgPSBub29wO1xuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoaXRlcmF0b3IubmV4dCgpKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvdXRXYWl0O1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHtcbiAgICB3cml0ZXIsXG4gICAgaXRlcmF0b3JcbiAgfTtcbn0iLCAiaW1wb3J0IHsgQ0lEIH0gZnJvbSAnbXVsdGlmb3JtYXRzL2NpZCc7XG5pbXBvcnQge1xuICBjcmVhdGVFbmNvZGVyLFxuICBjcmVhdGVIZWFkZXJcbn0gZnJvbSAnLi9lbmNvZGVyLmpzJztcbmltcG9ydCB7IGNyZWF0ZSBhcyBpdGVyYXRvckNoYW5uZWwgfSBmcm9tICcuL2l0ZXJhdG9yLWNoYW5uZWwuanMnO1xuaW1wb3J0IHtcbiAgYnl0ZXNSZWFkZXIsXG4gIHJlYWRIZWFkZXJcbn0gZnJvbSAnLi9kZWNvZGVyLmpzJztcbmV4cG9ydCBjbGFzcyBDYXJXcml0ZXIge1xuICBjb25zdHJ1Y3Rvcihyb290cywgZW5jb2Rlcikge1xuICAgIHRoaXMuX2VuY29kZXIgPSBlbmNvZGVyO1xuICAgIHRoaXMuX211dGV4ID0gZW5jb2Rlci5zZXRSb290cyhyb290cyk7XG4gICAgdGhpcy5fZW5kZWQgPSBmYWxzZTtcbiAgfVxuICBhc3luYyBwdXQoYmxvY2spIHtcbiAgICBpZiAoIShibG9jay5ieXRlcyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHx8ICFibG9jay5jaWQpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NhbiBvbmx5IHdyaXRlIHtjaWQsIGJ5dGVzfSBvYmplY3RzJyk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9lbmRlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBbHJlYWR5IGNsb3NlZCcpO1xuICAgIH1cbiAgICBjb25zdCBjaWQgPSBDSUQuYXNDSUQoYmxvY2suY2lkKTtcbiAgICBpZiAoIWNpZCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2FuIG9ubHkgd3JpdGUge2NpZCwgYnl0ZXN9IG9iamVjdHMnKTtcbiAgICB9XG4gICAgdGhpcy5fbXV0ZXggPSB0aGlzLl9tdXRleC50aGVuKCgpID0+IHRoaXMuX2VuY29kZXIud3JpdGVCbG9jayh7XG4gICAgICBjaWQsXG4gICAgICBieXRlczogYmxvY2suYnl0ZXNcbiAgICB9KSk7XG4gICAgcmV0dXJuIHRoaXMuX211dGV4O1xuICB9XG4gIGFzeW5jIGNsb3NlKCkge1xuICAgIGlmICh0aGlzLl9lbmRlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBbHJlYWR5IGNsb3NlZCcpO1xuICAgIH1cbiAgICBhd2FpdCB0aGlzLl9tdXRleDtcbiAgICB0aGlzLl9lbmRlZCA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXMuX2VuY29kZXIuY2xvc2UoKTtcbiAgfVxuICBzdGF0aWMgY3JlYXRlKHJvb3RzKSB7XG4gICAgcm9vdHMgPSB0b1Jvb3RzKHJvb3RzKTtcbiAgICBjb25zdCB7ZW5jb2RlciwgaXRlcmF0b3J9ID0gZW5jb2RlV3JpdGVyKCk7XG4gICAgY29uc3Qgd3JpdGVyID0gbmV3IENhcldyaXRlcihyb290cywgZW5jb2Rlcik7XG4gICAgY29uc3Qgb3V0ID0gbmV3IENhcldyaXRlck91dChpdGVyYXRvcik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdyaXRlcixcbiAgICAgIG91dFxuICAgIH07XG4gIH1cbiAgc3RhdGljIGNyZWF0ZUFwcGVuZGVyKCkge1xuICAgIGNvbnN0IHtlbmNvZGVyLCBpdGVyYXRvcn0gPSBlbmNvZGVXcml0ZXIoKTtcbiAgICBlbmNvZGVyLnNldFJvb3RzID0gKCkgPT4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgY29uc3Qgd3JpdGVyID0gbmV3IENhcldyaXRlcihbXSwgZW5jb2Rlcik7XG4gICAgY29uc3Qgb3V0ID0gbmV3IENhcldyaXRlck91dChpdGVyYXRvcik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdyaXRlcixcbiAgICAgIG91dFxuICAgIH07XG4gIH1cbiAgc3RhdGljIGFzeW5jIHVwZGF0ZVJvb3RzSW5CeXRlcyhieXRlcywgcm9vdHMpIHtcbiAgICBjb25zdCByZWFkZXIgPSBieXRlc1JlYWRlcihieXRlcyk7XG4gICAgYXdhaXQgcmVhZEhlYWRlcihyZWFkZXIpO1xuICAgIGNvbnN0IG5ld0hlYWRlciA9IGNyZWF0ZUhlYWRlcihyb290cyk7XG4gICAgaWYgKHJlYWRlci5wb3MgIT09IG5ld0hlYWRlci5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdXBkYXRlUm9vdHMoKSBjYW4gb25seSBvdmVyd3JpdGUgYSBoZWFkZXIgb2YgdGhlIHNhbWUgbGVuZ3RoIChvbGQgaGVhZGVyIGlzICR7IHJlYWRlci5wb3MgfSBieXRlcywgbmV3IGhlYWRlciBpcyAkeyBuZXdIZWFkZXIubGVuZ3RoIH0gYnl0ZXMpYCk7XG4gICAgfVxuICAgIGJ5dGVzLnNldChuZXdIZWFkZXIsIDApO1xuICAgIHJldHVybiBieXRlcztcbiAgfVxufVxuZXhwb3J0IGNsYXNzIENhcldyaXRlck91dCB7XG4gIGNvbnN0cnVjdG9yKGl0ZXJhdG9yKSB7XG4gICAgdGhpcy5faXRlcmF0b3IgPSBpdGVyYXRvcjtcbiAgfVxuICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgIGlmICh0aGlzLl9pdGVyYXRpbmcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTXVsdGlwbGUgaXRlcmF0b3Igbm90IHN1cHBvcnRlZCcpO1xuICAgIH1cbiAgICB0aGlzLl9pdGVyYXRpbmcgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzLl9pdGVyYXRvcjtcbiAgfVxufVxuZnVuY3Rpb24gZW5jb2RlV3JpdGVyKCkge1xuICBjb25zdCBpdyA9IGl0ZXJhdG9yQ2hhbm5lbCgpO1xuICBjb25zdCB7d3JpdGVyLCBpdGVyYXRvcn0gPSBpdztcbiAgY29uc3QgZW5jb2RlciA9IGNyZWF0ZUVuY29kZXIod3JpdGVyKTtcbiAgcmV0dXJuIHtcbiAgICBlbmNvZGVyLFxuICAgIGl0ZXJhdG9yXG4gIH07XG59XG5mdW5jdGlvbiB0b1Jvb3RzKHJvb3RzKSB7XG4gIGlmIChyb290cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGlmICghQXJyYXkuaXNBcnJheShyb290cykpIHtcbiAgICBjb25zdCBjaWQgPSBDSUQuYXNDSUQocm9vdHMpO1xuICAgIGlmICghY2lkKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdyb290cyBtdXN0IGJlIGEgc2luZ2xlIENJRCBvciBhbiBhcnJheSBvZiBDSURzJyk7XG4gICAgfVxuICAgIHJldHVybiBbY2lkXTtcbiAgfVxuICBjb25zdCBfcm9vdHMgPSBbXTtcbiAgZm9yIChjb25zdCByb290IG9mIHJvb3RzKSB7XG4gICAgY29uc3QgX3Jvb3QgPSBDSUQuYXNDSUQocm9vdCk7XG4gICAgaWYgKCFfcm9vdCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncm9vdHMgbXVzdCBiZSBhIHNpbmdsZSBDSUQgb3IgYW4gYXJyYXkgb2YgQ0lEcycpO1xuICAgIH1cbiAgICBfcm9vdHMucHVzaChfcm9vdCk7XG4gIH1cbiAgcmV0dXJuIF9yb290cztcbn1cbmV4cG9ydCBjb25zdCBfX2Jyb3dzZXIgPSB0cnVlOyIsICJpbXBvcnQgKiBhcyBEaWdlc3QgZnJvbSAnLi9kaWdlc3QuanMnO1xuZXhwb3J0IGNvbnN0IGZyb20gPSAoe25hbWUsIGNvZGUsIGVuY29kZX0pID0+IG5ldyBIYXNoZXIobmFtZSwgY29kZSwgZW5jb2RlKTtcbmV4cG9ydCBjbGFzcyBIYXNoZXIge1xuICBjb25zdHJ1Y3RvcihuYW1lLCBjb2RlLCBlbmNvZGUpIHtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgdGhpcy5lbmNvZGUgPSBlbmNvZGU7XG4gIH1cbiAgZGlnZXN0KGlucHV0KSB7XG4gICAgaWYgKGlucHV0IGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5lbmNvZGUoaW5wdXQpO1xuICAgICAgcmV0dXJuIHJlc3VsdCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgPyBEaWdlc3QuY3JlYXRlKHRoaXMuY29kZSwgcmVzdWx0KSA6IHJlc3VsdC50aGVuKGRpZ2VzdCA9PiBEaWdlc3QuY3JlYXRlKHRoaXMuY29kZSwgZGlnZXN0KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IEVycm9yKCdVbmtub3duIHR5cGUsIG11c3QgYmUgYmluYXJ5IHR5cGUnKTtcbiAgICB9XG4gIH1cbn0iLCAiaW1wb3J0IHtcbiAgYnl0ZXMgYXMgYmluYXJ5LFxuICBDSURcbn0gZnJvbSAnLi9pbmRleC5qcyc7XG5jb25zdCByZWFkb25seSA9ICh7ZW51bWVyYWJsZSA9IHRydWUsIGNvbmZpZ3VyYWJsZSA9IGZhbHNlfSA9IHt9KSA9PiAoe1xuICBlbnVtZXJhYmxlLFxuICBjb25maWd1cmFibGUsXG4gIHdyaXRhYmxlOiBmYWxzZVxufSk7XG5jb25zdCBsaW5rcyA9IGZ1bmN0aW9uKiAoc291cmNlLCBiYXNlKSB7XG4gIGlmIChzb3VyY2UgPT0gbnVsbClcbiAgICByZXR1cm47XG4gIGlmIChzb3VyY2UgaW5zdGFuY2VvZiBVaW50OEFycmF5KVxuICAgIHJldHVybjtcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoc291cmNlKSkge1xuICAgIGNvbnN0IHBhdGggPSBbXG4gICAgICAuLi5iYXNlLFxuICAgICAga2V5XG4gICAgXTtcbiAgICBpZiAodmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgZm9yIChjb25zdCBbaW5kZXgsIGVsZW1lbnRdIG9mIHZhbHVlLmVudHJpZXMoKSkge1xuICAgICAgICAgIGNvbnN0IGVsZW1lbnRQYXRoID0gW1xuICAgICAgICAgICAgLi4ucGF0aCxcbiAgICAgICAgICAgIGluZGV4XG4gICAgICAgICAgXTtcbiAgICAgICAgICBjb25zdCBjaWQgPSBDSUQuYXNDSUQoZWxlbWVudCk7XG4gICAgICAgICAgaWYgKGNpZCkge1xuICAgICAgICAgICAgeWllbGQgW1xuICAgICAgICAgICAgICBlbGVtZW50UGF0aC5qb2luKCcvJyksXG4gICAgICAgICAgICAgIGNpZFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbGVtZW50ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgeWllbGQqIGxpbmtzKGVsZW1lbnQsIGVsZW1lbnRQYXRoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGNpZCA9IENJRC5hc0NJRCh2YWx1ZSk7XG4gICAgICAgIGlmIChjaWQpIHtcbiAgICAgICAgICB5aWVsZCBbXG4gICAgICAgICAgICBwYXRoLmpvaW4oJy8nKSxcbiAgICAgICAgICAgIGNpZFxuICAgICAgICAgIF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgeWllbGQqIGxpbmtzKHZhbHVlLCBwYXRoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcbmNvbnN0IHRyZWUgPSBmdW5jdGlvbiogKHNvdXJjZSwgYmFzZSkge1xuICBpZiAoc291cmNlID09IG51bGwpXG4gICAgcmV0dXJuO1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhzb3VyY2UpKSB7XG4gICAgY29uc3QgcGF0aCA9IFtcbiAgICAgIC4uLmJhc2UsXG4gICAgICBrZXlcbiAgICBdO1xuICAgIHlpZWxkIHBhdGguam9pbignLycpO1xuICAgIGlmICh2YWx1ZSAhPSBudWxsICYmICEodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmICFDSUQuYXNDSUQodmFsdWUpKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgZm9yIChjb25zdCBbaW5kZXgsIGVsZW1lbnRdIG9mIHZhbHVlLmVudHJpZXMoKSkge1xuICAgICAgICAgIGNvbnN0IGVsZW1lbnRQYXRoID0gW1xuICAgICAgICAgICAgLi4ucGF0aCxcbiAgICAgICAgICAgIGluZGV4XG4gICAgICAgICAgXTtcbiAgICAgICAgICB5aWVsZCBlbGVtZW50UGF0aC5qb2luKCcvJyk7XG4gICAgICAgICAgaWYgKHR5cGVvZiBlbGVtZW50ID09PSAnb2JqZWN0JyAmJiAhQ0lELmFzQ0lEKGVsZW1lbnQpKSB7XG4gICAgICAgICAgICB5aWVsZCogdHJlZShlbGVtZW50LCBlbGVtZW50UGF0aCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB5aWVsZCogdHJlZSh2YWx1ZSwgcGF0aCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuY29uc3QgZ2V0ID0gKHNvdXJjZSwgcGF0aCkgPT4ge1xuICBsZXQgbm9kZSA9IHNvdXJjZTtcbiAgZm9yIChjb25zdCBbaW5kZXgsIGtleV0gb2YgcGF0aC5lbnRyaWVzKCkpIHtcbiAgICBub2RlID0gbm9kZVtrZXldO1xuICAgIGlmIChub2RlID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgT2JqZWN0IGhhcyBubyBwcm9wZXJ0eSBhdCAkeyBwYXRoLnNsaWNlKDAsIGluZGV4ICsgMSkubWFwKHBhcnQgPT4gYFskeyBKU09OLnN0cmluZ2lmeShwYXJ0KSB9XWApLmpvaW4oJycpIH1gKTtcbiAgICB9XG4gICAgY29uc3QgY2lkID0gQ0lELmFzQ0lEKG5vZGUpO1xuICAgIGlmIChjaWQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiBjaWQsXG4gICAgICAgIHJlbWFpbmluZzogcGF0aC5zbGljZShpbmRleCArIDEpLmpvaW4oJy8nKVxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHsgdmFsdWU6IG5vZGUgfTtcbn07XG5jbGFzcyBCbG9jayB7XG4gIGNvbnN0cnVjdG9yKHtjaWQsIGJ5dGVzLCB2YWx1ZX0pIHtcbiAgICBpZiAoIWNpZCB8fCAhYnl0ZXMgfHwgdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJylcbiAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyByZXF1aXJlZCBhcmd1bWVudCcpO1xuICAgIHRoaXMuY2lkID0gY2lkO1xuICAgIHRoaXMuYnl0ZXMgPSBieXRlcztcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy5hc0Jsb2NrID0gdGhpcztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICBjaWQ6IHJlYWRvbmx5KCksXG4gICAgICBieXRlczogcmVhZG9ubHkoKSxcbiAgICAgIHZhbHVlOiByZWFkb25seSgpLFxuICAgICAgYXNCbG9jazogcmVhZG9ubHkoKVxuICAgIH0pO1xuICB9XG4gIGxpbmtzKCkge1xuICAgIHJldHVybiBsaW5rcyh0aGlzLnZhbHVlLCBbXSk7XG4gIH1cbiAgdHJlZSgpIHtcbiAgICByZXR1cm4gdHJlZSh0aGlzLnZhbHVlLCBbXSk7XG4gIH1cbiAgZ2V0KHBhdGggPSAnLycpIHtcbiAgICByZXR1cm4gZ2V0KHRoaXMudmFsdWUsIHBhdGguc3BsaXQoJy8nKS5maWx0ZXIoQm9vbGVhbikpO1xuICB9XG59XG5jb25zdCBlbmNvZGUgPSBhc3luYyAoe3ZhbHVlLCBjb2RlYywgaGFzaGVyfSkgPT4ge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJylcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgcmVxdWlyZWQgYXJndW1lbnQgXCJ2YWx1ZVwiJyk7XG4gIGlmICghY29kZWMgfHwgIWhhc2hlcilcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgcmVxdWlyZWQgYXJndW1lbnQ6IGNvZGVjIG9yIGhhc2hlcicpO1xuICBjb25zdCBieXRlcyA9IGNvZGVjLmVuY29kZSh2YWx1ZSk7XG4gIGNvbnN0IGhhc2ggPSBhd2FpdCBoYXNoZXIuZGlnZXN0KGJ5dGVzKTtcbiAgY29uc3QgY2lkID0gQ0lELmNyZWF0ZSgxLCBjb2RlYy5jb2RlLCBoYXNoKTtcbiAgcmV0dXJuIG5ldyBCbG9jayh7XG4gICAgdmFsdWUsXG4gICAgYnl0ZXMsXG4gICAgY2lkXG4gIH0pO1xufTtcbmNvbnN0IGRlY29kZSA9IGFzeW5jICh7Ynl0ZXMsIGNvZGVjLCBoYXNoZXJ9KSA9PiB7XG4gIGlmICghYnl0ZXMpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHJlcXVpcmVkIGFyZ3VtZW50IFwiYnl0ZXNcIicpO1xuICBpZiAoIWNvZGVjIHx8ICFoYXNoZXIpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHJlcXVpcmVkIGFyZ3VtZW50OiBjb2RlYyBvciBoYXNoZXInKTtcbiAgY29uc3QgdmFsdWUgPSBjb2RlYy5kZWNvZGUoYnl0ZXMpO1xuICBjb25zdCBoYXNoID0gYXdhaXQgaGFzaGVyLmRpZ2VzdChieXRlcyk7XG4gIGNvbnN0IGNpZCA9IENJRC5jcmVhdGUoMSwgY29kZWMuY29kZSwgaGFzaCk7XG4gIHJldHVybiBuZXcgQmxvY2soe1xuICAgIHZhbHVlLFxuICAgIGJ5dGVzLFxuICAgIGNpZFxuICB9KTtcbn07XG5jb25zdCBjcmVhdGVVbnNhZmUgPSAoe1xuICBieXRlcyxcbiAgY2lkLFxuICB2YWx1ZTogbWF5YmVWYWx1ZSxcbiAgY29kZWNcbn0pID0+IHtcbiAgY29uc3QgdmFsdWUgPSBtYXliZVZhbHVlICE9PSB1bmRlZmluZWQgPyBtYXliZVZhbHVlIDogY29kZWMgJiYgY29kZWMuZGVjb2RlKGJ5dGVzKTtcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHJlcXVpcmVkIGFyZ3VtZW50LCBtdXN0IGVpdGhlciBwcm92aWRlIFwidmFsdWVcIiBvciBcImNvZGVjXCInKTtcbiAgcmV0dXJuIG5ldyBCbG9jayh7XG4gICAgY2lkLFxuICAgIGJ5dGVzLFxuICAgIHZhbHVlXG4gIH0pO1xufTtcbmNvbnN0IGNyZWF0ZSA9IGFzeW5jICh7Ynl0ZXMsIGNpZCwgaGFzaGVyLCBjb2RlY30pID0+IHtcbiAgaWYgKCFieXRlcylcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgcmVxdWlyZWQgYXJndW1lbnQgXCJieXRlc1wiJyk7XG4gIGlmICghaGFzaGVyKVxuICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyByZXF1aXJlZCBhcmd1bWVudCBcImhhc2hlclwiJyk7XG4gIGNvbnN0IHZhbHVlID0gY29kZWMuZGVjb2RlKGJ5dGVzKTtcbiAgY29uc3QgaGFzaCA9IGF3YWl0IGhhc2hlci5kaWdlc3QoYnl0ZXMpO1xuICBpZiAoIWJpbmFyeS5lcXVhbHMoY2lkLm11bHRpaGFzaC5ieXRlcywgaGFzaC5ieXRlcykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NJRCBoYXNoIGRvZXMgbm90IG1hdGNoIGJ5dGVzJyk7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZVVuc2FmZSh7XG4gICAgYnl0ZXMsXG4gICAgY2lkLFxuICAgIHZhbHVlLFxuICAgIGNvZGVjXG4gIH0pO1xufTtcbmV4cG9ydCB7XG4gIGVuY29kZSxcbiAgZGVjb2RlLFxuICBjcmVhdGUsXG4gIGNyZWF0ZVVuc2FmZSxcbiAgQmxvY2tcbn07IiwgImltcG9ydCB7IGNvZXJjZSB9IGZyb20gJy4uL2J5dGVzLmpzJztcbmV4cG9ydCBjb25zdCBuYW1lID0gJ3Jhdyc7XG5leHBvcnQgY29uc3QgY29kZSA9IDg1O1xuZXhwb3J0IGNvbnN0IGVuY29kZSA9IG5vZGUgPT4gY29lcmNlKG5vZGUpO1xuZXhwb3J0IGNvbnN0IGRlY29kZSA9IGRhdGEgPT4gY29lcmNlKGRhdGEpOyIsICJpbXBvcnQgKiBhcyBjYm9yZyBmcm9tICdjYm9yZyc7XG5pbXBvcnQgeyBDSUQgfSBmcm9tICdtdWx0aWZvcm1hdHMvY2lkJztcbmNvbnN0IENJRF9DQk9SX1RBRyA9IDQyO1xuZnVuY3Rpb24gY2lkRW5jb2RlcihvYmopIHtcbiAgaWYgKG9iai5hc0NJRCAhPT0gb2JqKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgY2lkID0gQ0lELmFzQ0lEKG9iaik7XG4gIGlmICghY2lkKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShjaWQuYnl0ZXMuYnl0ZUxlbmd0aCArIDEpO1xuICBieXRlcy5zZXQoY2lkLmJ5dGVzLCAxKTtcbiAgcmV0dXJuIFtcbiAgICBuZXcgY2JvcmcuVG9rZW4oY2JvcmcuVHlwZS50YWcsIENJRF9DQk9SX1RBRyksXG4gICAgbmV3IGNib3JnLlRva2VuKGNib3JnLlR5cGUuYnl0ZXMsIGJ5dGVzKVxuICBdO1xufVxuZnVuY3Rpb24gdW5kZWZpbmVkRW5jb2RlcigpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdgdW5kZWZpbmVkYCBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBJUExEIERhdGEgTW9kZWwgYW5kIGNhbm5vdCBiZSBlbmNvZGVkJyk7XG59XG5mdW5jdGlvbiBudW1iZXJFbmNvZGVyKG51bSkge1xuICBpZiAoTnVtYmVyLmlzTmFOKG51bSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2BOYU5gIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIElQTEQgRGF0YSBNb2RlbCBhbmQgY2Fubm90IGJlIGVuY29kZWQnKTtcbiAgfVxuICBpZiAobnVtID09PSBJbmZpbml0eSB8fCBudW0gPT09IC1JbmZpbml0eSkge1xuICAgIHRocm93IG5ldyBFcnJvcignYEluZmluaXR5YCBhbmQgYC1JbmZpbml0eWAgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgSVBMRCBEYXRhIE1vZGVsIGFuZCBjYW5ub3QgYmUgZW5jb2RlZCcpO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuY29uc3QgZW5jb2RlT3B0aW9ucyA9IHtcbiAgZmxvYXQ2NDogdHJ1ZSxcbiAgdHlwZUVuY29kZXJzOiB7XG4gICAgT2JqZWN0OiBjaWRFbmNvZGVyLFxuICAgIHVuZGVmaW5lZDogdW5kZWZpbmVkRW5jb2RlcixcbiAgICBudW1iZXI6IG51bWJlckVuY29kZXJcbiAgfVxufTtcbmZ1bmN0aW9uIGNpZERlY29kZXIoYnl0ZXMpIHtcbiAgaWYgKGJ5dGVzWzBdICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIENJRCBmb3IgQ0JPUiB0YWcgNDI7IGV4cGVjdGVkIGxlYWRpbmcgMHgwMCcpO1xuICB9XG4gIHJldHVybiBDSUQuZGVjb2RlKGJ5dGVzLnN1YmFycmF5KDEpKTtcbn1cbmNvbnN0IGRlY29kZU9wdGlvbnMgPSB7XG4gIGFsbG93SW5kZWZpbml0ZTogZmFsc2UsXG4gIGFsbG93VW5kZWZpbmVkOiBmYWxzZSxcbiAgYWxsb3dOYU46IGZhbHNlLFxuICBhbGxvd0luZmluaXR5OiBmYWxzZSxcbiAgYWxsb3dCaWdJbnQ6IHRydWUsXG4gIHN0cmljdDogdHJ1ZSxcbiAgdXNlTWFwczogZmFsc2UsXG4gIHRhZ3M6IFtdXG59O1xuZGVjb2RlT3B0aW9ucy50YWdzW0NJRF9DQk9SX1RBR10gPSBjaWREZWNvZGVyO1xuZXhwb3J0IGNvbnN0IG5hbWUgPSAnZGFnLWNib3InO1xuZXhwb3J0IGNvbnN0IGNvZGUgPSAxMTM7XG5leHBvcnQgY29uc3QgZW5jb2RlID0gbm9kZSA9PiBjYm9yZy5lbmNvZGUobm9kZSwgZW5jb2RlT3B0aW9ucyk7XG5leHBvcnQgY29uc3QgZGVjb2RlID0gZGF0YSA9PiBjYm9yZy5kZWNvZGUoZGF0YSwgZGVjb2RlT3B0aW9ucyk7IiwgImltcG9ydCB7IENJRCB9IGZyb20gJ211bHRpZm9ybWF0cy9jaWQnO1xuaW1wb3J0IHsgZGVjb2RlTm9kZSB9IGZyb20gJy4vcGItZGVjb2RlLmpzJztcbmltcG9ydCB7IGVuY29kZU5vZGUgfSBmcm9tICcuL3BiLWVuY29kZS5qcyc7XG5pbXBvcnQge1xuICBwcmVwYXJlLFxuICB2YWxpZGF0ZSxcbiAgY3JlYXRlTm9kZSxcbiAgY3JlYXRlTGlua1xufSBmcm9tICcuL3V0aWwuanMnO1xuZXhwb3J0IGNvbnN0IG5hbWUgPSAnZGFnLXBiJztcbmV4cG9ydCBjb25zdCBjb2RlID0gMTEyO1xuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZShub2RlKSB7XG4gIHZhbGlkYXRlKG5vZGUpO1xuICBjb25zdCBwYm4gPSB7fTtcbiAgaWYgKG5vZGUuTGlua3MpIHtcbiAgICBwYm4uTGlua3MgPSBub2RlLkxpbmtzLm1hcChsID0+IHtcbiAgICAgIGNvbnN0IGxpbmsgPSB7fTtcbiAgICAgIGlmIChsLkhhc2gpIHtcbiAgICAgICAgbGluay5IYXNoID0gbC5IYXNoLmJ5dGVzO1xuICAgICAgfVxuICAgICAgaWYgKGwuTmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxpbmsuTmFtZSA9IGwuTmFtZTtcbiAgICAgIH1cbiAgICAgIGlmIChsLlRzaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGluay5Uc2l6ZSA9IGwuVHNpemU7XG4gICAgICB9XG4gICAgICByZXR1cm4gbGluaztcbiAgICB9KTtcbiAgfVxuICBpZiAobm9kZS5EYXRhKSB7XG4gICAgcGJuLkRhdGEgPSBub2RlLkRhdGE7XG4gIH1cbiAgcmV0dXJuIGVuY29kZU5vZGUocGJuKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGUoYnl0ZXMpIHtcbiAgY29uc3QgcGJuID0gZGVjb2RlTm9kZShieXRlcyk7XG4gIGNvbnN0IG5vZGUgPSB7fTtcbiAgaWYgKHBibi5EYXRhKSB7XG4gICAgbm9kZS5EYXRhID0gcGJuLkRhdGE7XG4gIH1cbiAgaWYgKHBibi5MaW5rcykge1xuICAgIG5vZGUuTGlua3MgPSBwYm4uTGlua3MubWFwKGwgPT4ge1xuICAgICAgY29uc3QgbGluayA9IHt9O1xuICAgICAgdHJ5IHtcbiAgICAgICAgbGluay5IYXNoID0gQ0lELmRlY29kZShsLkhhc2gpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgfVxuICAgICAgaWYgKCFsaW5rLkhhc2gpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIEhhc2ggZmllbGQgZm91bmQgaW4gbGluaywgZXhwZWN0ZWQgQ0lEJyk7XG4gICAgICB9XG4gICAgICBpZiAobC5OYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGluay5OYW1lID0gbC5OYW1lO1xuICAgICAgfVxuICAgICAgaWYgKGwuVHNpemUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsaW5rLlRzaXplID0gbC5Uc2l6ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsaW5rO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBub2RlO1xufVxuZXhwb3J0IHtcbiAgcHJlcGFyZSxcbiAgdmFsaWRhdGUsXG4gIGNyZWF0ZU5vZGUsXG4gIGNyZWF0ZUxpbmtcbn07IiwgImNvbnN0IHRleHREZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG5mdW5jdGlvbiBkZWNvZGVWYXJpbnQoYnl0ZXMsIG9mZnNldCkge1xuICBsZXQgdiA9IDA7XG4gIGZvciAobGV0IHNoaWZ0ID0gMDs7IHNoaWZ0ICs9IDcpIHtcbiAgICBpZiAoc2hpZnQgPj0gNjQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncHJvdG9idWY6IHZhcmludCBvdmVyZmxvdycpO1xuICAgIH1cbiAgICBpZiAob2Zmc2V0ID49IGJ5dGVzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdwcm90b2J1ZjogdW5leHBlY3RlZCBlbmQgb2YgZGF0YScpO1xuICAgIH1cbiAgICBjb25zdCBiID0gYnl0ZXNbb2Zmc2V0KytdO1xuICAgIHYgKz0gc2hpZnQgPCAyOCA/IChiICYgMTI3KSA8PCBzaGlmdCA6IChiICYgMTI3KSAqIDIgKiogc2hpZnQ7XG4gICAgaWYgKGIgPCAxMjgpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gW1xuICAgIHYsXG4gICAgb2Zmc2V0XG4gIF07XG59XG5mdW5jdGlvbiBkZWNvZGVCeXRlcyhieXRlcywgb2Zmc2V0KSB7XG4gIGxldCBieXRlTGVuO1xuICBbYnl0ZUxlbiwgb2Zmc2V0XSA9IGRlY29kZVZhcmludChieXRlcywgb2Zmc2V0KTtcbiAgY29uc3QgcG9zdE9mZnNldCA9IG9mZnNldCArIGJ5dGVMZW47XG4gIGlmIChieXRlTGVuIDwgMCB8fCBwb3N0T2Zmc2V0IDwgMCkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvdG9idWY6IGludmFsaWQgbGVuZ3RoJyk7XG4gIH1cbiAgaWYgKHBvc3RPZmZzZXQgPiBieXRlcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb3RvYnVmOiB1bmV4cGVjdGVkIGVuZCBvZiBkYXRhJyk7XG4gIH1cbiAgcmV0dXJuIFtcbiAgICBieXRlcy5zdWJhcnJheShvZmZzZXQsIHBvc3RPZmZzZXQpLFxuICAgIHBvc3RPZmZzZXRcbiAgXTtcbn1cbmZ1bmN0aW9uIGRlY29kZUtleShieXRlcywgaW5kZXgpIHtcbiAgbGV0IHdpcmU7XG4gIFt3aXJlLCBpbmRleF0gPSBkZWNvZGVWYXJpbnQoYnl0ZXMsIGluZGV4KTtcbiAgcmV0dXJuIFtcbiAgICB3aXJlICYgNyxcbiAgICB3aXJlID4+IDMsXG4gICAgaW5kZXhcbiAgXTtcbn1cbmZ1bmN0aW9uIGRlY29kZUxpbmsoYnl0ZXMpIHtcbiAgY29uc3QgbGluayA9IHt9O1xuICBjb25zdCBsID0gYnl0ZXMubGVuZ3RoO1xuICBsZXQgaW5kZXggPSAwO1xuICB3aGlsZSAoaW5kZXggPCBsKSB7XG4gICAgbGV0IHdpcmVUeXBlLCBmaWVsZE51bTtcbiAgICBbd2lyZVR5cGUsIGZpZWxkTnVtLCBpbmRleF0gPSBkZWNvZGVLZXkoYnl0ZXMsIGluZGV4KTtcbiAgICBpZiAoZmllbGROdW0gPT09IDEpIHtcbiAgICAgIGlmIChsaW5rLkhhc2gpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwcm90b2J1ZjogKFBCTGluaykgZHVwbGljYXRlIEhhc2ggc2VjdGlvbicpO1xuICAgICAgfVxuICAgICAgaWYgKHdpcmVUeXBlICE9PSAyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgcHJvdG9idWY6IChQQkxpbmspIHdyb25nIHdpcmVUeXBlICgkeyB3aXJlVHlwZSB9KSBmb3IgSGFzaGApO1xuICAgICAgfVxuICAgICAgaWYgKGxpbmsuTmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncHJvdG9idWY6IChQQkxpbmspIGludmFsaWQgb3JkZXIsIGZvdW5kIE5hbWUgYmVmb3JlIEhhc2gnKTtcbiAgICAgIH1cbiAgICAgIGlmIChsaW5rLlRzaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwcm90b2J1ZjogKFBCTGluaykgaW52YWxpZCBvcmRlciwgZm91bmQgVHNpemUgYmVmb3JlIEhhc2gnKTtcbiAgICAgIH1cbiAgICAgIDtcbiAgICAgIFtsaW5rLkhhc2gsIGluZGV4XSA9IGRlY29kZUJ5dGVzKGJ5dGVzLCBpbmRleCk7XG4gICAgfSBlbHNlIGlmIChmaWVsZE51bSA9PT0gMikge1xuICAgICAgaWYgKGxpbmsuTmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncHJvdG9idWY6IChQQkxpbmspIGR1cGxpY2F0ZSBOYW1lIHNlY3Rpb24nKTtcbiAgICAgIH1cbiAgICAgIGlmICh3aXJlVHlwZSAhPT0gMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHByb3RvYnVmOiAoUEJMaW5rKSB3cm9uZyB3aXJlVHlwZSAoJHsgd2lyZVR5cGUgfSkgZm9yIE5hbWVgKTtcbiAgICAgIH1cbiAgICAgIGlmIChsaW5rLlRzaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwcm90b2J1ZjogKFBCTGluaykgaW52YWxpZCBvcmRlciwgZm91bmQgVHNpemUgYmVmb3JlIE5hbWUnKTtcbiAgICAgIH1cbiAgICAgIGxldCBieXRzO1xuICAgICAgW2J5dHMsIGluZGV4XSA9IGRlY29kZUJ5dGVzKGJ5dGVzLCBpbmRleCk7XG4gICAgICBsaW5rLk5hbWUgPSB0ZXh0RGVjb2Rlci5kZWNvZGUoYnl0cyk7XG4gICAgfSBlbHNlIGlmIChmaWVsZE51bSA9PT0gMykge1xuICAgICAgaWYgKGxpbmsuVHNpemUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb3RvYnVmOiAoUEJMaW5rKSBkdXBsaWNhdGUgVHNpemUgc2VjdGlvbicpO1xuICAgICAgfVxuICAgICAgaWYgKHdpcmVUeXBlICE9PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgcHJvdG9idWY6IChQQkxpbmspIHdyb25nIHdpcmVUeXBlICgkeyB3aXJlVHlwZSB9KSBmb3IgVHNpemVgKTtcbiAgICAgIH1cbiAgICAgIDtcbiAgICAgIFtsaW5rLlRzaXplLCBpbmRleF0gPSBkZWNvZGVWYXJpbnQoYnl0ZXMsIGluZGV4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBwcm90b2J1ZjogKFBCTGluaykgaW52YWxpZCBmaWVsZE51bWJlciwgZXhwZWN0ZWQgMSwgMiBvciAzLCBnb3QgJHsgZmllbGROdW0gfWApO1xuICAgIH1cbiAgfVxuICBpZiAoaW5kZXggPiBsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm90b2J1ZjogKFBCTGluaykgdW5leHBlY3RlZCBlbmQgb2YgZGF0YScpO1xuICB9XG4gIHJldHVybiBsaW5rO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZU5vZGUoYnl0ZXMpIHtcbiAgY29uc3QgbCA9IGJ5dGVzLmxlbmd0aDtcbiAgbGV0IGluZGV4ID0gMDtcbiAgbGV0IGxpbmtzO1xuICBsZXQgbGlua3NCZWZvcmVEYXRhID0gZmFsc2U7XG4gIGxldCBkYXRhO1xuICB3aGlsZSAoaW5kZXggPCBsKSB7XG4gICAgbGV0IHdpcmVUeXBlLCBmaWVsZE51bTtcbiAgICBbd2lyZVR5cGUsIGZpZWxkTnVtLCBpbmRleF0gPSBkZWNvZGVLZXkoYnl0ZXMsIGluZGV4KTtcbiAgICBpZiAod2lyZVR5cGUgIT09IDIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgcHJvdG9idWY6IChQQk5vZGUpIGludmFsaWQgd2lyZVR5cGUsIGV4cGVjdGVkIDIsIGdvdCAkeyB3aXJlVHlwZSB9YCk7XG4gICAgfVxuICAgIGlmIChmaWVsZE51bSA9PT0gMSkge1xuICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwcm90b2J1ZjogKFBCTm9kZSkgZHVwbGljYXRlIERhdGEgc2VjdGlvbicpO1xuICAgICAgfVxuICAgICAgO1xuICAgICAgW2RhdGEsIGluZGV4XSA9IGRlY29kZUJ5dGVzKGJ5dGVzLCBpbmRleCk7XG4gICAgICBpZiAobGlua3MpIHtcbiAgICAgICAgbGlua3NCZWZvcmVEYXRhID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGZpZWxkTnVtID09PSAyKSB7XG4gICAgICBpZiAobGlua3NCZWZvcmVEYXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncHJvdG9idWY6IChQQk5vZGUpIGR1cGxpY2F0ZSBMaW5rcyBzZWN0aW9uJyk7XG4gICAgICB9IGVsc2UgaWYgKCFsaW5rcykge1xuICAgICAgICBsaW5rcyA9IFtdO1xuICAgICAgfVxuICAgICAgbGV0IGJ5dHM7XG4gICAgICBbYnl0cywgaW5kZXhdID0gZGVjb2RlQnl0ZXMoYnl0ZXMsIGluZGV4KTtcbiAgICAgIGxpbmtzLnB1c2goZGVjb2RlTGluayhieXRzKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgcHJvdG9idWY6IChQQk5vZGUpIGludmFsaWQgZmllbGROdW1iZXIsIGV4cGVjdGVkIDEgb3IgMiwgZ290ICR7IGZpZWxkTnVtIH1gKTtcbiAgICB9XG4gIH1cbiAgaWYgKGluZGV4ID4gbCkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvdG9idWY6IChQQk5vZGUpIHVuZXhwZWN0ZWQgZW5kIG9mIGRhdGEnKTtcbiAgfVxuICBjb25zdCBub2RlID0ge307XG4gIGlmIChkYXRhKSB7XG4gICAgbm9kZS5EYXRhID0gZGF0YTtcbiAgfVxuICBub2RlLkxpbmtzID0gbGlua3MgfHwgW107XG4gIHJldHVybiBub2RlO1xufSIsICJjb25zdCB0ZXh0RW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuY29uc3QgbWF4SW50MzIgPSAyICoqIDMyO1xuY29uc3QgbWF4VUludDMyID0gMiAqKiAzMTtcbmZ1bmN0aW9uIGVuY29kZUxpbmsobGluaywgYnl0ZXMpIHtcbiAgbGV0IGkgPSBieXRlcy5sZW5ndGg7XG4gIGlmICh0eXBlb2YgbGluay5Uc2l6ZSA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAobGluay5Uc2l6ZSA8IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVHNpemUgY2Fubm90IGJlIG5lZ2F0aXZlJyk7XG4gICAgfVxuICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIobGluay5Uc2l6ZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVHNpemUgdG9vIGxhcmdlIGZvciBlbmNvZGluZycpO1xuICAgIH1cbiAgICBpID0gZW5jb2RlVmFyaW50KGJ5dGVzLCBpLCBsaW5rLlRzaXplKSAtIDE7XG4gICAgYnl0ZXNbaV0gPSAyNDtcbiAgfVxuICBpZiAodHlwZW9mIGxpbmsuTmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICBjb25zdCBuYW1lQnl0ZXMgPSB0ZXh0RW5jb2Rlci5lbmNvZGUobGluay5OYW1lKTtcbiAgICBpIC09IG5hbWVCeXRlcy5sZW5ndGg7XG4gICAgYnl0ZXMuc2V0KG5hbWVCeXRlcywgaSk7XG4gICAgaSA9IGVuY29kZVZhcmludChieXRlcywgaSwgbmFtZUJ5dGVzLmxlbmd0aCkgLSAxO1xuICAgIGJ5dGVzW2ldID0gMTg7XG4gIH1cbiAgaWYgKGxpbmsuSGFzaCkge1xuICAgIGkgLT0gbGluay5IYXNoLmxlbmd0aDtcbiAgICBieXRlcy5zZXQobGluay5IYXNoLCBpKTtcbiAgICBpID0gZW5jb2RlVmFyaW50KGJ5dGVzLCBpLCBsaW5rLkhhc2gubGVuZ3RoKSAtIDE7XG4gICAgYnl0ZXNbaV0gPSAxMDtcbiAgfVxuICByZXR1cm4gYnl0ZXMubGVuZ3RoIC0gaTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGVOb2RlKG5vZGUpIHtcbiAgY29uc3Qgc2l6ZSA9IHNpemVOb2RlKG5vZGUpO1xuICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KHNpemUpO1xuICBsZXQgaSA9IHNpemU7XG4gIGlmIChub2RlLkRhdGEpIHtcbiAgICBpIC09IG5vZGUuRGF0YS5sZW5ndGg7XG4gICAgYnl0ZXMuc2V0KG5vZGUuRGF0YSwgaSk7XG4gICAgaSA9IGVuY29kZVZhcmludChieXRlcywgaSwgbm9kZS5EYXRhLmxlbmd0aCkgLSAxO1xuICAgIGJ5dGVzW2ldID0gMTA7XG4gIH1cbiAgaWYgKG5vZGUuTGlua3MpIHtcbiAgICBmb3IgKGxldCBpbmRleCA9IG5vZGUuTGlua3MubGVuZ3RoIC0gMTsgaW5kZXggPj0gMDsgaW5kZXgtLSkge1xuICAgICAgY29uc3Qgc2l6ZSA9IGVuY29kZUxpbmsobm9kZS5MaW5rc1tpbmRleF0sIGJ5dGVzLnN1YmFycmF5KDAsIGkpKTtcbiAgICAgIGkgLT0gc2l6ZTtcbiAgICAgIGkgPSBlbmNvZGVWYXJpbnQoYnl0ZXMsIGksIHNpemUpIC0gMTtcbiAgICAgIGJ5dGVzW2ldID0gMTg7XG4gICAgfVxuICB9XG4gIHJldHVybiBieXRlcztcbn1cbmZ1bmN0aW9uIHNpemVMaW5rKGxpbmspIHtcbiAgbGV0IG4gPSAwO1xuICBpZiAobGluay5IYXNoKSB7XG4gICAgY29uc3QgbCA9IGxpbmsuSGFzaC5sZW5ndGg7XG4gICAgbiArPSAxICsgbCArIHNvdihsKTtcbiAgfVxuICBpZiAodHlwZW9mIGxpbmsuTmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICBjb25zdCBsID0gdGV4dEVuY29kZXIuZW5jb2RlKGxpbmsuTmFtZSkubGVuZ3RoO1xuICAgIG4gKz0gMSArIGwgKyBzb3YobCk7XG4gIH1cbiAgaWYgKHR5cGVvZiBsaW5rLlRzaXplID09PSAnbnVtYmVyJykge1xuICAgIG4gKz0gMSArIHNvdihsaW5rLlRzaXplKTtcbiAgfVxuICByZXR1cm4gbjtcbn1cbmZ1bmN0aW9uIHNpemVOb2RlKG5vZGUpIHtcbiAgbGV0IG4gPSAwO1xuICBpZiAobm9kZS5EYXRhKSB7XG4gICAgY29uc3QgbCA9IG5vZGUuRGF0YS5sZW5ndGg7XG4gICAgbiArPSAxICsgbCArIHNvdihsKTtcbiAgfVxuICBpZiAobm9kZS5MaW5rcykge1xuICAgIGZvciAoY29uc3QgbGluayBvZiBub2RlLkxpbmtzKSB7XG4gICAgICBjb25zdCBsID0gc2l6ZUxpbmsobGluayk7XG4gICAgICBuICs9IDEgKyBsICsgc292KGwpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbjtcbn1cbmZ1bmN0aW9uIGVuY29kZVZhcmludChieXRlcywgb2Zmc2V0LCB2KSB7XG4gIG9mZnNldCAtPSBzb3Yodik7XG4gIGNvbnN0IGJhc2UgPSBvZmZzZXQ7XG4gIHdoaWxlICh2ID49IG1heFVJbnQzMikge1xuICAgIGJ5dGVzW29mZnNldCsrXSA9IHYgJiAxMjcgfCAxMjg7XG4gICAgdiAvPSAxMjg7XG4gIH1cbiAgd2hpbGUgKHYgPj0gMTI4KSB7XG4gICAgYnl0ZXNbb2Zmc2V0KytdID0gdiAmIDEyNyB8IDEyODtcbiAgICB2ID4+Pj0gNztcbiAgfVxuICBieXRlc1tvZmZzZXRdID0gdjtcbiAgcmV0dXJuIGJhc2U7XG59XG5mdW5jdGlvbiBzb3YoeCkge1xuICBpZiAoeCAlIDIgPT09IDApIHtcbiAgICB4Kys7XG4gIH1cbiAgcmV0dXJuIE1hdGguZmxvb3IoKGxlbjY0KHgpICsgNikgLyA3KTtcbn1cbmZ1bmN0aW9uIGxlbjY0KHgpIHtcbiAgbGV0IG4gPSAwO1xuICBpZiAoeCA+PSBtYXhJbnQzMikge1xuICAgIHggPSBNYXRoLmZsb29yKHggLyBtYXhJbnQzMik7XG4gICAgbiA9IDMyO1xuICB9XG4gIGlmICh4ID49IDEgPDwgMTYpIHtcbiAgICB4ID4+Pj0gMTY7XG4gICAgbiArPSAxNjtcbiAgfVxuICBpZiAoeCA+PSAxIDw8IDgpIHtcbiAgICB4ID4+Pj0gODtcbiAgICBuICs9IDg7XG4gIH1cbiAgcmV0dXJuIG4gKyBsZW44dGFiW3hdO1xufVxuY29uc3QgbGVuOHRhYiA9IFtcbiAgMCxcbiAgMSxcbiAgMixcbiAgMixcbiAgMyxcbiAgMyxcbiAgMyxcbiAgMyxcbiAgNCxcbiAgNCxcbiAgNCxcbiAgNCxcbiAgNCxcbiAgNCxcbiAgNCxcbiAgNCxcbiAgNSxcbiAgNSxcbiAgNSxcbiAgNSxcbiAgNSxcbiAgNSxcbiAgNSxcbiAgNSxcbiAgNSxcbiAgNSxcbiAgNSxcbiAgNSxcbiAgNSxcbiAgNSxcbiAgNSxcbiAgNSxcbiAgNixcbiAgNixcbiAgNixcbiAgNixcbiAgNixcbiAgNixcbiAgNixcbiAgNixcbiAgNixcbiAgNixcbiAgNixcbiAgNixcbiAgNixcbiAgNixcbiAgNixcbiAgNixcbiAgNixcbiAgNixcbiAgNixcbiAgNixcbiAgNixcbiAgNixcbiAgNixcbiAgNixcbiAgNixcbiAgNixcbiAgNixcbiAgNixcbiAgNixcbiAgNixcbiAgNixcbiAgNixcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOFxuXTsiLCAiaW1wb3J0IHsgQ0lEIH0gZnJvbSAnbXVsdGlmb3JtYXRzL2NpZCc7XG5jb25zdCBwYk5vZGVQcm9wZXJ0aWVzID0gW1xuICAnRGF0YScsXG4gICdMaW5rcydcbl07XG5jb25zdCBwYkxpbmtQcm9wZXJ0aWVzID0gW1xuICAnSGFzaCcsXG4gICdOYW1lJyxcbiAgJ1RzaXplJ1xuXTtcbmNvbnN0IHRleHRFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG5mdW5jdGlvbiBsaW5rQ29tcGFyYXRvcihhLCBiKSB7XG4gIGlmIChhID09PSBiKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgY29uc3QgYWJ1ZiA9IGEuTmFtZSA/IHRleHRFbmNvZGVyLmVuY29kZShhLk5hbWUpIDogW107XG4gIGNvbnN0IGJidWYgPSBiLk5hbWUgPyB0ZXh0RW5jb2Rlci5lbmNvZGUoYi5OYW1lKSA6IFtdO1xuICBsZXQgeCA9IGFidWYubGVuZ3RoO1xuICBsZXQgeSA9IGJidWYubGVuZ3RoO1xuICBmb3IgKGxldCBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhYnVmW2ldICE9PSBiYnVmW2ldKSB7XG4gICAgICB4ID0gYWJ1ZltpXTtcbiAgICAgIHkgPSBiYnVmW2ldO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiB4IDwgeSA/IC0xIDogeSA8IHggPyAxIDogMDtcbn1cbmZ1bmN0aW9uIGhhc09ubHlQcm9wZXJ0aWVzKG5vZGUsIHByb3BlcnRpZXMpIHtcbiAgcmV0dXJuICFPYmplY3Qua2V5cyhub2RlKS5zb21lKHAgPT4gIXByb3BlcnRpZXMuaW5jbHVkZXMocCkpO1xufVxuZnVuY3Rpb24gYXNMaW5rKGxpbmspIHtcbiAgaWYgKHR5cGVvZiBsaW5rLmFzQ0lEID09PSAnb2JqZWN0Jykge1xuICAgIGNvbnN0IEhhc2ggPSBDSUQuYXNDSUQobGluayk7XG4gICAgaWYgKCFIYXNoKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIERBRy1QQiBmb3JtJyk7XG4gICAgfVxuICAgIHJldHVybiB7IEhhc2ggfTtcbiAgfVxuICBpZiAodHlwZW9mIGxpbmsgIT09ICdvYmplY3QnIHx8IEFycmF5LmlzQXJyYXkobGluaykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIERBRy1QQiBmb3JtJyk7XG4gIH1cbiAgY29uc3QgcGJsID0ge307XG4gIGlmIChsaW5rLkhhc2gpIHtcbiAgICBsZXQgY2lkID0gQ0lELmFzQ0lEKGxpbmsuSGFzaCk7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghY2lkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbGluay5IYXNoID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGNpZCA9IENJRC5wYXJzZShsaW5rLkhhc2gpO1xuICAgICAgICB9IGVsc2UgaWYgKGxpbmsuSGFzaCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgICBjaWQgPSBDSUQuZGVjb2RlKGxpbmsuSGFzaCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIERBRy1QQiBmb3JtOiAkeyBlLm1lc3NhZ2UgfWApO1xuICAgIH1cbiAgICBpZiAoY2lkKSB7XG4gICAgICBwYmwuSGFzaCA9IGNpZDtcbiAgICB9XG4gIH1cbiAgaWYgKCFwYmwuSGFzaCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgREFHLVBCIGZvcm0nKTtcbiAgfVxuICBpZiAodHlwZW9mIGxpbmsuTmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICBwYmwuTmFtZSA9IGxpbmsuTmFtZTtcbiAgfVxuICBpZiAodHlwZW9mIGxpbmsuVHNpemUgPT09ICdudW1iZXInKSB7XG4gICAgcGJsLlRzaXplID0gbGluay5Uc2l6ZTtcbiAgfVxuICByZXR1cm4gcGJsO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHByZXBhcmUobm9kZSkge1xuICBpZiAobm9kZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHwgdHlwZW9mIG5vZGUgPT09ICdzdHJpbmcnKSB7XG4gICAgbm9kZSA9IHsgRGF0YTogbm9kZSB9O1xuICB9XG4gIGlmICh0eXBlb2Ygbm9kZSAhPT0gJ29iamVjdCcgfHwgQXJyYXkuaXNBcnJheShub2RlKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgREFHLVBCIGZvcm0nKTtcbiAgfVxuICBjb25zdCBwYm4gPSB7fTtcbiAgaWYgKG5vZGUuRGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiBub2RlLkRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICBwYm4uRGF0YSA9IHRleHRFbmNvZGVyLmVuY29kZShub2RlLkRhdGEpO1xuICAgIH0gZWxzZSBpZiAobm9kZS5EYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgcGJuLkRhdGEgPSBub2RlLkRhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgREFHLVBCIGZvcm0nKTtcbiAgICB9XG4gIH1cbiAgaWYgKG5vZGUuTGlua3MgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG5vZGUuTGlua3MpKSB7XG4gICAgICBwYm4uTGlua3MgPSBub2RlLkxpbmtzLm1hcChhc0xpbmspO1xuICAgICAgcGJuLkxpbmtzLnNvcnQobGlua0NvbXBhcmF0b3IpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIERBRy1QQiBmb3JtJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHBibi5MaW5rcyA9IFtdO1xuICB9XG4gIHJldHVybiBwYm47XG59XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGUobm9kZSkge1xuICBpZiAoIW5vZGUgfHwgdHlwZW9mIG5vZGUgIT09ICdvYmplY3QnIHx8IEFycmF5LmlzQXJyYXkobm9kZSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIERBRy1QQiBmb3JtJyk7XG4gIH1cbiAgaWYgKCFoYXNPbmx5UHJvcGVydGllcyhub2RlLCBwYk5vZGVQcm9wZXJ0aWVzKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgREFHLVBCIGZvcm0gKGV4dHJhbmVvdXMgcHJvcGVydGllcyknKTtcbiAgfVxuICBpZiAobm9kZS5EYXRhICE9PSB1bmRlZmluZWQgJiYgIShub2RlLkRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgREFHLVBCIGZvcm0gKERhdGEgbXVzdCBiZSBhIFVpbnQ4QXJyYXkpJyk7XG4gIH1cbiAgaWYgKCFBcnJheS5pc0FycmF5KG5vZGUuTGlua3MpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBEQUctUEIgZm9ybSAoTGlua3MgbXVzdCBiZSBhbiBhcnJheSknKTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUuTGlua3MubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBsaW5rID0gbm9kZS5MaW5rc1tpXTtcbiAgICBpZiAoIWxpbmsgfHwgdHlwZW9mIGxpbmsgIT09ICdvYmplY3QnIHx8IEFycmF5LmlzQXJyYXkobGluaykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgREFHLVBCIGZvcm0gKGJhZCBsaW5rIG9iamVjdCknKTtcbiAgICB9XG4gICAgaWYgKCFoYXNPbmx5UHJvcGVydGllcyhsaW5rLCBwYkxpbmtQcm9wZXJ0aWVzKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBEQUctUEIgZm9ybSAoZXh0cmFuZW91cyBwcm9wZXJ0aWVzIG9uIGxpbmsgb2JqZWN0KScpO1xuICAgIH1cbiAgICBpZiAoIWxpbmsuSGFzaCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBEQUctUEIgZm9ybSAobGluayBtdXN0IGhhdmUgYSBIYXNoKScpO1xuICAgIH1cbiAgICBpZiAobGluay5IYXNoLmFzQ0lEICE9PSBsaW5rLkhhc2gpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgREFHLVBCIGZvcm0gKGxpbmsgSGFzaCBtdXN0IGJlIGEgQ0lEKScpO1xuICAgIH1cbiAgICBpZiAobGluay5OYW1lICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGxpbmsuTmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgREFHLVBCIGZvcm0gKGxpbmsgTmFtZSBtdXN0IGJlIGEgc3RyaW5nKScpO1xuICAgIH1cbiAgICBpZiAobGluay5Uc2l6ZSAhPT0gdW5kZWZpbmVkICYmICh0eXBlb2YgbGluay5Uc2l6ZSAhPT0gJ251bWJlcicgfHwgbGluay5Uc2l6ZSAlIDEgIT09IDApKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIERBRy1QQiBmb3JtIChsaW5rIFRzaXplIG11c3QgYmUgYW4gaW50ZWdlciknKTtcbiAgICB9XG4gICAgaWYgKGkgPiAwICYmIGxpbmtDb21wYXJhdG9yKGxpbmssIG5vZGUuTGlua3NbaSAtIDFdKSA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgREFHLVBCIGZvcm0gKGxpbmtzIG11c3QgYmUgc29ydGVkIGJ5IE5hbWUgYnl0ZXMpJyk7XG4gICAgfVxuICB9XG59XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTm9kZShkYXRhLCBsaW5rcyA9IFtdKSB7XG4gIHJldHVybiBwcmVwYXJlKHtcbiAgICBEYXRhOiBkYXRhLFxuICAgIExpbmtzOiBsaW5rc1xuICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVMaW5rKG5hbWUsIHNpemUsIGNpZCkge1xuICByZXR1cm4gYXNMaW5rKHtcbiAgICBIYXNoOiBjaWQsXG4gICAgTmFtZTogbmFtZSxcbiAgICBUc2l6ZTogc2l6ZVxuICB9KTtcbn0iLCAiaW1wb3J0IHtcbiAgQ2FyUmVhZGVyLFxuICBDYXJXcml0ZXJcbn0gZnJvbSAnQGlwbGQvY2FyJztcbmltcG9ydCB7IEJsb2NrIH0gZnJvbSAnbXVsdGlmb3JtYXRzL2Jsb2NrJztcbmltcG9ydCAqIGFzIHJhdyBmcm9tICdtdWx0aWZvcm1hdHMvY29kZWNzL3Jhdyc7XG5pbXBvcnQgKiBhcyBjYm9yIGZyb20gJ0BpcGxkL2RhZy1jYm9yJztcbmltcG9ydCAqIGFzIHBiIGZyb20gJ0BpcGxkL2RhZy1wYic7XG5leHBvcnQgY2xhc3MgVHJlZXdhbGtDYXJTcGxpdHRlciB7XG4gIGNvbnN0cnVjdG9yKHJlYWRlciwgdGFyZ2V0U2l6ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKHR5cGVvZiB0YXJnZXRTaXplICE9PSAnbnVtYmVyJyB8fCB0YXJnZXRTaXplIDw9IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCB0YXJnZXQgY2h1bmsgc2l6ZScpO1xuICAgIH1cbiAgICB0aGlzLl9yZWFkZXIgPSByZWFkZXI7XG4gICAgdGhpcy5fdGFyZ2V0U2l6ZSA9IHRhcmdldFNpemU7XG4gICAgdGhpcy5fZGVjb2RlcnMgPSBbXG4gICAgICBwYixcbiAgICAgIHJhdyxcbiAgICAgIGNib3IsXG4gICAgICAuLi5vcHRpb25zLmRlY29kZXJzIHx8IFtdXG4gICAgXTtcbiAgfVxuICBhc3luYyAqY2FycygpIHtcbiAgICBjb25zdCByb290cyA9IGF3YWl0IHRoaXMuX3JlYWRlci5nZXRSb290cygpO1xuICAgIGlmIChyb290cy5sZW5ndGggIT09IDEpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuZXhwZWN0ZWQgbnVtYmVyIG9mIHJvb3RzOiAkeyByb290cy5sZW5ndGggfWApO1xuICAgIGxldCBjaGFubmVsO1xuICAgIGZvciBhd2FpdCAoY29uc3QgdmFsIG9mIHRoaXMuX2NhcnMocm9vdHNbMF0pKSB7XG4gICAgICBjaGFubmVsID0gdmFsLmNoYW5uZWw7XG4gICAgICBpZiAodmFsLm91dClcbiAgICAgICAgeWllbGQgdmFsLm91dDtcbiAgICB9XG4gICAgaWYgKCFjaGFubmVsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgQ0FSIHdyaXRlciBjaGFubmVsJyk7XG4gICAgfVxuICAgIGNoYW5uZWwud3JpdGVyLmNsb3NlKCk7XG4gICAgeWllbGQgY2hhbm5lbC5vdXQ7XG4gIH1cbiAgYXN5bmMgX2dldChjaWQpIHtcbiAgICBjb25zdCByYXdCbG9jayA9IGF3YWl0IHRoaXMuX3JlYWRlci5nZXQoY2lkKTtcbiAgICBpZiAoIXJhd0Jsb2NrKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBtaXNzaW5nIGJsb2NrIGZvciAkeyBjaWQgfWApO1xuICAgIGNvbnN0IHtieXRlc30gPSByYXdCbG9jaztcbiAgICBjb25zdCBkZWNvZGVyID0gdGhpcy5fZGVjb2RlcnMuZmluZChkID0+IGQuY29kZSA9PT0gY2lkLmNvZGUpO1xuICAgIGlmICghZGVjb2RlcilcbiAgICAgIHRocm93IG5ldyBFcnJvcihgbWlzc2luZyBkZWNvZGVyIGZvciAkeyBjaWQuY29kZSB9YCk7XG4gICAgcmV0dXJuIG5ldyBCbG9jayh7XG4gICAgICBjaWQsXG4gICAgICBieXRlcyxcbiAgICAgIHZhbHVlOiBkZWNvZGVyLmRlY29kZShieXRlcylcbiAgICB9KTtcbiAgfVxuICBhc3luYyAqX2NhcnMoY2lkLCBwYXJlbnRzID0gW10sIGNoYW5uZWwgPSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCBibG9jayA9IGF3YWl0IHRoaXMuX2dldChjaWQpO1xuICAgIGNoYW5uZWwgPSBjaGFubmVsIHx8IE9iamVjdC5hc3NpZ24oQ2FyV3JpdGVyLmNyZWF0ZShjaWQpLCB7IHNpemU6IDAgfSk7XG4gICAgaWYgKGNoYW5uZWwuc2l6ZSA+IDAgJiYgY2hhbm5lbC5zaXplICsgYmxvY2suYnl0ZXMuYnl0ZUxlbmd0aCA+PSB0aGlzLl90YXJnZXRTaXplKSB7XG4gICAgICBjaGFubmVsLndyaXRlci5jbG9zZSgpO1xuICAgICAgY29uc3Qge291dH0gPSBjaGFubmVsO1xuICAgICAgY2hhbm5lbCA9IG5ld0NhcihwYXJlbnRzKTtcbiAgICAgIHlpZWxkIHtcbiAgICAgICAgY2hhbm5lbCxcbiAgICAgICAgb3V0XG4gICAgICB9O1xuICAgIH1cbiAgICBwYXJlbnRzID0gcGFyZW50cy5jb25jYXQoYmxvY2spO1xuICAgIGNoYW5uZWwuc2l6ZSArPSBibG9jay5ieXRlcy5ieXRlTGVuZ3RoO1xuICAgIGNoYW5uZWwud3JpdGVyLnB1dChibG9jayk7XG4gICAgZm9yIChjb25zdCBbLCBjaWRdIG9mIGJsb2NrLmxpbmtzKCkpIHtcbiAgICAgIGZvciBhd2FpdCAoY29uc3QgdmFsIG9mIHRoaXMuX2NhcnMoY2lkLCBwYXJlbnRzLCBjaGFubmVsKSkge1xuICAgICAgICBjaGFubmVsID0gdmFsLmNoYW5uZWw7XG4gICAgICAgIHlpZWxkIHZhbDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFjaGFubmVsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgQ0FSIHdyaXRlciBjaGFubmVsJyk7XG4gICAgfVxuICAgIHlpZWxkIHsgY2hhbm5lbCB9O1xuICB9XG4gIHN0YXRpYyBhc3luYyBmcm9tSXRlcmFibGUoaXRlcmFibGUsIHRhcmdldFNpemUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCByZWFkZXIgPSBhd2FpdCBDYXJSZWFkZXIuZnJvbUl0ZXJhYmxlKGl0ZXJhYmxlKTtcbiAgICByZXR1cm4gbmV3IFRyZWV3YWxrQ2FyU3BsaXR0ZXIocmVhZGVyLCB0YXJnZXRTaXplLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgZnJvbUJsb2IoYmxvYiwgdGFyZ2V0U2l6ZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IGJ1ZmZlciA9IGF3YWl0IGJsb2IuYXJyYXlCdWZmZXIoKTtcbiAgICBjb25zdCByZWFkZXIgPSBhd2FpdCBDYXJSZWFkZXIuZnJvbUJ5dGVzKG5ldyBVaW50OEFycmF5KGJ1ZmZlcikpO1xuICAgIHJldHVybiBuZXcgVHJlZXdhbGtDYXJTcGxpdHRlcihyZWFkZXIsIHRhcmdldFNpemUsIG9wdGlvbnMpO1xuICB9XG59XG5mdW5jdGlvbiBuZXdDYXIocGFyZW50cykge1xuICBjb25zdCBjaCA9IE9iamVjdC5hc3NpZ24oQ2FyV3JpdGVyLmNyZWF0ZShwYXJlbnRzWzBdLmNpZCksIHsgc2l6ZTogcGFyZW50cy5yZWR1Y2UoKHNpemUsIGIpID0+IHNpemUgKyBiLmJ5dGVzLmJ5dGVMZW5ndGgsIDApIH0pO1xuICBmb3IgKGNvbnN0IGIgb2YgcGFyZW50cykge1xuICAgIGNoLndyaXRlci5wdXQoYik7XG4gIH1cbiAgcmV0dXJuIGNoO1xufSIsICJpbXBvcnQgbGFzdCBmcm9tICdpdC1sYXN0JztcbmltcG9ydCBwaXBlIGZyb20gJ2l0LXBpcGUnO1xuaW1wb3J0IHsgQ2FyV3JpdGVyIH0gZnJvbSAnQGlwbGQvY2FyJztcbmltcG9ydCB7IGltcG9ydGVyIH0gZnJvbSAnaXBmcy11bml4ZnMtaW1wb3J0ZXInO1xuaW1wb3J0IHsgZ2V0Tm9ybWFsaXNlciB9IGZyb20gXCIuL3V0aWxzL25vcm1hbGlzZS1pbnB1dC5qc1wiO1xuaW1wb3J0IHsgTWVtb3J5QmxvY2tTdG9yZSB9IGZyb20gXCIuLi9ibG9ja3N0b3JlL21lbW9yeS5qc1wiO1xuaW1wb3J0IHsgdW5peGZzSW1wb3J0ZXJPcHRpb25zRGVmYXVsdCB9IGZyb20gXCIuL2NvbnN0YW50cy5qc1wiO1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHBhY2soeyBpbnB1dCwgYmxvY2tzdG9yZTogdXNlckJsb2Nrc3RvcmUsIGhhc2hlciwgbWF4Q2h1bmtTaXplLCBtYXhDaGlsZHJlblBlck5vZGUsIHdyYXBXaXRoRGlyZWN0b3J5LCByYXdMZWF2ZXMgfSkge1xuICAgIGlmICghaW5wdXQgfHwgKEFycmF5LmlzQXJyYXkoaW5wdXQpICYmICFpbnB1dC5sZW5ndGgpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyBpbnB1dCBmaWxlKHMpJyk7XG4gICAgfVxuICAgIGNvbnN0IGJsb2Nrc3RvcmUgPSB1c2VyQmxvY2tzdG9yZSA/IHVzZXJCbG9ja3N0b3JlIDogbmV3IE1lbW9yeUJsb2NrU3RvcmUoKTtcbiAgICAvLyBDb25zdW1lIHRoZSBzb3VyY2VcbiAgICBjb25zdCByb290RW50cnkgPSBhd2FpdCBsYXN0KHBpcGUoZ2V0Tm9ybWFsaXNlcihpbnB1dCksIChzb3VyY2UpID0+IGltcG9ydGVyKHNvdXJjZSwgYmxvY2tzdG9yZSwge1xuICAgICAgICAuLi51bml4ZnNJbXBvcnRlck9wdGlvbnNEZWZhdWx0LFxuICAgICAgICBoYXNoZXI6IGhhc2hlciB8fCB1bml4ZnNJbXBvcnRlck9wdGlvbnNEZWZhdWx0Lmhhc2hlcixcbiAgICAgICAgbWF4Q2h1bmtTaXplOiBtYXhDaHVua1NpemUgfHwgdW5peGZzSW1wb3J0ZXJPcHRpb25zRGVmYXVsdC5tYXhDaHVua1NpemUsXG4gICAgICAgIG1heENoaWxkcmVuUGVyTm9kZTogbWF4Q2hpbGRyZW5QZXJOb2RlIHx8IHVuaXhmc0ltcG9ydGVyT3B0aW9uc0RlZmF1bHQubWF4Q2hpbGRyZW5QZXJOb2RlLFxuICAgICAgICB3cmFwV2l0aERpcmVjdG9yeTogd3JhcFdpdGhEaXJlY3RvcnkgPT09IGZhbHNlID8gZmFsc2UgOiB1bml4ZnNJbXBvcnRlck9wdGlvbnNEZWZhdWx0LndyYXBXaXRoRGlyZWN0b3J5LFxuICAgICAgICByYXdMZWF2ZXM6IHJhd0xlYXZlcyA9PSBudWxsID8gdW5peGZzSW1wb3J0ZXJPcHRpb25zRGVmYXVsdC5yYXdMZWF2ZXMgOiByYXdMZWF2ZXNcbiAgICB9KSkpO1xuICAgIGlmICghcm9vdEVudHJ5IHx8ICFyb290RW50cnkuY2lkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZ2l2ZW4gaW5wdXQgY291bGQgbm90IGJlIHBhcnNlZCBjb3JyZWN0bHknKTtcbiAgICB9XG4gICAgY29uc3Qgcm9vdCA9IHJvb3RFbnRyeS5jaWQ7XG4gICAgY29uc3QgeyB3cml0ZXIsIG91dDogY2FyT3V0IH0gPSBhd2FpdCBDYXJXcml0ZXIuY3JlYXRlKFtyb290XSk7XG4gICAgY29uc3QgY2FyT3V0SXRlciA9IGNhck91dFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKTtcbiAgICBsZXQgd3JpdGluZ1Byb21pc2U7XG4gICAgY29uc3Qgd3JpdGVBbGwgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgYmxvY2sgb2YgYmxvY2tzdG9yZS5ibG9ja3MoKSkge1xuICAgICAgICAgICAgLy8gYGF3YWl0YCB3aWxsIGJsb2NrIHVudGlsIGFsbCBieXRlcyBpbiBgY2FyT3V0YCBhcmUgY29uc3VtZWQgYnkgdGhlIHVzZXJcbiAgICAgICAgICAgIC8vIHNvIHdlIGhhdmUgYmFja3ByZXNzdXJlIGhlcmVcbiAgICAgICAgICAgIGF3YWl0IHdyaXRlci5wdXQoYmxvY2spO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHdyaXRlci5jbG9zZSgpO1xuICAgICAgICBpZiAoIXVzZXJCbG9ja3N0b3JlKSB7XG4gICAgICAgICAgICBhd2FpdCBibG9ja3N0b3JlLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IG91dCA9IHtcbiAgICAgICAgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcbiAgICAgICAgICAgIGlmICh3cml0aW5nUHJvbWlzZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdWx0aXBsZSBpdGVyYXRvciBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBkb24ndCBzdGFydCB3cml0aW5nIHVudGlsIHRoZSB1c2VyIHN0YXJ0cyBjb25zdW1pbmcgdGhlIGl0ZXJhdG9yXG4gICAgICAgICAgICB3cml0aW5nUHJvbWlzZSA9IHdyaXRlQWxsKCk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGFzeW5jIG5leHQoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNhck91dEl0ZXIubmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHdyaXRpbmdQcm9taXNlOyAvLyBhbnkgZXJyb3JzIHdpbGwgcHJvcGFnYXRlIGZyb20gaGVyZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHsgcm9vdCwgb3V0IH07XG59XG4iLCAiaW1wb3J0IHBhcmFsbGVsQmF0Y2ggZnJvbSAnaXQtcGFyYWxsZWwtYmF0Y2gnO1xuaW1wb3J0IGRlZmF1bHRPcHRpb25zIGZyb20gJy4vb3B0aW9ucy5qcyc7XG5pbXBvcnQgZGFnQnVpbGRlckZuIGZyb20gJy4vZGFnLWJ1aWxkZXIvaW5kZXguanMnO1xuaW1wb3J0IHRyZWVCdWlsZGVyRm4gZnJvbSAnLi90cmVlLWJ1aWxkZXIuanMnO1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uKiBpbXBvcnRlcihzb3VyY2UsIGJsb2Nrc3RvcmUsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCBvcHRzID0gZGVmYXVsdE9wdGlvbnMob3B0aW9ucyk7XG4gIGxldCBkYWdCdWlsZGVyO1xuICBpZiAodHlwZW9mIG9wdGlvbnMuZGFnQnVpbGRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGRhZ0J1aWxkZXIgPSBvcHRpb25zLmRhZ0J1aWxkZXI7XG4gIH0gZWxzZSB7XG4gICAgZGFnQnVpbGRlciA9IGRhZ0J1aWxkZXJGbjtcbiAgfVxuICBsZXQgdHJlZUJ1aWxkZXI7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucy50cmVlQnVpbGRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRyZWVCdWlsZGVyID0gb3B0aW9ucy50cmVlQnVpbGRlcjtcbiAgfSBlbHNlIHtcbiAgICB0cmVlQnVpbGRlciA9IHRyZWVCdWlsZGVyRm47XG4gIH1cbiAgbGV0IGNhbmRpZGF0ZXM7XG4gIGlmIChTeW1ib2wuYXN5bmNJdGVyYXRvciBpbiBzb3VyY2UgfHwgU3ltYm9sLml0ZXJhdG9yIGluIHNvdXJjZSkge1xuICAgIGNhbmRpZGF0ZXMgPSBzb3VyY2U7XG4gIH0gZWxzZSB7XG4gICAgY2FuZGlkYXRlcyA9IFtzb3VyY2VdO1xuICB9XG4gIGZvciBhd2FpdCAoY29uc3QgZW50cnkgb2YgdHJlZUJ1aWxkZXIocGFyYWxsZWxCYXRjaChkYWdCdWlsZGVyKGNhbmRpZGF0ZXMsIGJsb2Nrc3RvcmUsIG9wdHMpLCBvcHRzLmZpbGVJbXBvcnRDb25jdXJyZW5jeSksIGJsb2Nrc3RvcmUsIG9wdHMpKSB7XG4gICAgeWllbGQge1xuICAgICAgY2lkOiBlbnRyeS5jaWQsXG4gICAgICBwYXRoOiBlbnRyeS5wYXRoLFxuICAgICAgdW5peGZzOiBlbnRyeS51bml4ZnMsXG4gICAgICBzaXplOiBlbnRyeS5zaXplXG4gICAgfTtcbiAgfVxufSIsICIvKipcbiAqIFRoaW4gRVNNIHdyYXBwZXIgZm9yIENKUyBuYW1lZCBleHBvcnRzLlxuICpcbiAqIFJlZjogaHR0cHM6Ly9yZWRmaW4uZW5naW5lZXJpbmcvbm9kZS1tb2R1bGVzLWF0LXdhci13aHktY29tbW9uanMtYW5kLWVzLW1vZHVsZXMtY2FudC1nZXQtYWxvbmctOTYxNzEzNWVlY2ExXG4gKi9cblxuaW1wb3J0IG1lcmdlT3B0aW9ucyBmcm9tICcuL2luZGV4LmpzJztcbmV4cG9ydCBkZWZhdWx0IG1lcmdlT3B0aW9ucztcbiIsICJpbXBvcnQgY3J5cHRvIGZyb20gJ2NyeXB0byc7XG5pbXBvcnQgeyBmcm9tIH0gZnJvbSAnLi9oYXNoZXIuanMnO1xuaW1wb3J0IHsgY29lcmNlIH0gZnJvbSAnLi4vYnl0ZXMuanMnO1xuZXhwb3J0IGNvbnN0IHNoYTI1NiA9IGZyb20oe1xuICBuYW1lOiAnc2hhMi0yNTYnLFxuICBjb2RlOiAxOCxcbiAgZW5jb2RlOiBpbnB1dCA9PiBjb2VyY2UoY3J5cHRvLmNyZWF0ZUhhc2goJ3NoYTI1NicpLnVwZGF0ZShpbnB1dCkuZGlnZXN0KCkpXG59KTtcbmV4cG9ydCBjb25zdCBzaGE1MTIgPSBmcm9tKHtcbiAgbmFtZTogJ3NoYTItNTEyJyxcbiAgY29kZTogMTksXG4gIGVuY29kZTogaW5wdXQgPT4gY29lcmNlKGNyeXB0by5jcmVhdGVIYXNoKCdzaGE1MTInKS51cGRhdGUoaW5wdXQpLmRpZ2VzdCgpKVxufSk7IiwgImltcG9ydCB7IGZyb20gfSBmcm9tICdtdWx0aWZvcm1hdHMvaGFzaGVzL2hhc2hlcic7XG5pbXBvcnQgeyBieXRlcyB9IGZyb20gJ211bHRpZm9ybWF0cyc7XG5pbXBvcnQgbXVyIGZyb20gJ211cm11cmhhc2gzanMtcmV2aXNpdGVkJztcbmZ1bmN0aW9uIGZyb21OdW1iZXJUbzMyQml0QnVmKG51bWJlcikge1xuICBjb25zdCBieXRlcyA9IG5ldyBBcnJheSg0KTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICBieXRlc1tpXSA9IG51bWJlciAmIDI1NTtcbiAgICBudW1iZXIgPSBudW1iZXIgPj4gODtcbiAgfVxuICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnl0ZXMpO1xufVxuZXhwb3J0IGNvbnN0IG11cm11cjMzMiA9IGZyb20oe1xuICBuYW1lOiAnbXVybXVyMy0zMicsXG4gIGNvZGU6IDM1LFxuICBlbmNvZGU6IGlucHV0ID0+IGZyb21OdW1iZXJUbzMyQml0QnVmKG11ci54ODYuaGFzaDMyKGlucHV0KSlcbn0pO1xuZXhwb3J0IGNvbnN0IG11cm11cjMxMjggPSBmcm9tKHtcbiAgbmFtZTogJ211cm11cjMtMTI4JyxcbiAgY29kZTogMzQsXG4gIGVuY29kZTogaW5wdXQgPT4gYnl0ZXMuZnJvbUhleChtdXIueDY0Lmhhc2gxMjgoaW5wdXQpKVxufSk7IiwgImltcG9ydCBtZXJnZU9wdGlvbnMgZnJvbSAnbWVyZ2Utb3B0aW9ucyc7XG5pbXBvcnQgeyBzaGEyNTYgfSBmcm9tICdtdWx0aWZvcm1hdHMvaGFzaGVzL3NoYTInO1xuaW1wb3J0IHsgbXVybXVyMzEyOCB9IGZyb20gJ0BtdWx0aWZvcm1hdHMvbXVybXVyMyc7XG5hc3luYyBmdW5jdGlvbiBoYW10SGFzaEZuKGJ1Zikge1xuICByZXR1cm4gKGF3YWl0IG11cm11cjMxMjguZW5jb2RlKGJ1ZikpLnNsaWNlKDAsIDgpLnJldmVyc2UoKTtcbn1cbmNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICBjaHVua2VyOiAnZml4ZWQnLFxuICBzdHJhdGVneTogJ2JhbGFuY2VkJyxcbiAgcmF3TGVhdmVzOiBmYWxzZSxcbiAgb25seUhhc2g6IGZhbHNlLFxuICByZWR1Y2VTaW5nbGVMZWFmVG9TZWxmOiB0cnVlLFxuICBoYXNoZXI6IHNoYTI1NixcbiAgbGVhZlR5cGU6ICdmaWxlJyxcbiAgY2lkVmVyc2lvbjogMCxcbiAgcHJvZ3Jlc3M6ICgpID0+ICgpID0+IHtcbiAgfSxcbiAgc2hhcmRTcGxpdFRocmVzaG9sZDogMTAwMCxcbiAgZmlsZUltcG9ydENvbmN1cnJlbmN5OiA1MCxcbiAgYmxvY2tXcml0ZUNvbmN1cnJlbmN5OiAxMCxcbiAgbWluQ2h1bmtTaXplOiAyNjIxNDQsXG4gIG1heENodW5rU2l6ZTogMjYyMTQ0LFxuICBhdmdDaHVua1NpemU6IDI2MjE0NCxcbiAgd2luZG93OiAxNixcbiAgcG9seW5vbWlhbDogMTc0MzcxODAxMzI3NjM2NTIsXG4gIG1heENoaWxkcmVuUGVyTm9kZTogMTc0LFxuICBsYXllclJlcGVhdDogNCxcbiAgd3JhcFdpdGhEaXJlY3Rvcnk6IGZhbHNlLFxuICByZWN1cnNpdmU6IGZhbHNlLFxuICBoaWRkZW46IGZhbHNlLFxuICB0aW1lb3V0OiB1bmRlZmluZWQsXG4gIGhhbXRIYXNoRm4sXG4gIGhhbXRIYXNoQ29kZTogMzQsXG4gIGhhbXRCdWNrZXRCaXRzOiA4XG59O1xuZXhwb3J0IGRlZmF1bHQgKG9wdGlvbnMgPSB7fSkgPT4ge1xuICBjb25zdCBkZWZhdWx0cyA9IG1lcmdlT3B0aW9ucy5iaW5kKHsgaWdub3JlVW5kZWZpbmVkOiB0cnVlIH0pO1xuICByZXR1cm4gZGVmYXVsdHMoZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMpO1xufTsiLCAiaW1wb3J0IGVycmNvZGUgZnJvbSAnZXJyLWNvZGUnO1xuaW1wb3J0ICogYXMgUGIgZnJvbSAnLi91bml4ZnMuanMnO1xuY29uc3QgUEJEYXRhID0gUGIuRGF0YTtcbmNvbnN0IHR5cGVzID0gW1xuICAncmF3JyxcbiAgJ2RpcmVjdG9yeScsXG4gICdmaWxlJyxcbiAgJ21ldGFkYXRhJyxcbiAgJ3N5bWxpbmsnLFxuICAnaGFtdC1zaGFyZGVkLWRpcmVjdG9yeSdcbl07XG5jb25zdCBkaXJUeXBlcyA9IFtcbiAgJ2RpcmVjdG9yeScsXG4gICdoYW10LXNoYXJkZWQtZGlyZWN0b3J5J1xuXTtcbmNvbnN0IERFRkFVTFRfRklMRV9NT0RFID0gcGFyc2VJbnQoJzA2NDQnLCA4KTtcbmNvbnN0IERFRkFVTFRfRElSRUNUT1JZX01PREUgPSBwYXJzZUludCgnMDc1NScsIDgpO1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlTW9kZShtb2RlKSB7XG4gIGlmIChtb2RlID09IG51bGwpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGlmICh0eXBlb2YgbW9kZSA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gbW9kZSAmIDQwOTU7XG4gIH1cbiAgbW9kZSA9IG1vZGUudG9TdHJpbmcoKTtcbiAgaWYgKG1vZGUuc3Vic3RyaW5nKDAsIDEpID09PSAnMCcpIHtcbiAgICByZXR1cm4gcGFyc2VJbnQobW9kZSwgOCkgJiA0MDk1O1xuICB9XG4gIHJldHVybiBwYXJzZUludChtb2RlLCAxMCkgJiA0MDk1O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlTXRpbWUoaW5wdXQpIHtcbiAgaWYgKGlucHV0ID09IG51bGwpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGxldCBtdGltZTtcbiAgaWYgKGlucHV0LnNlY3MgIT0gbnVsbCkge1xuICAgIG10aW1lID0ge1xuICAgICAgc2VjczogaW5wdXQuc2VjcyxcbiAgICAgIG5zZWNzOiBpbnB1dC5uc2Vjc1xuICAgIH07XG4gIH1cbiAgaWYgKGlucHV0LlNlY29uZHMgIT0gbnVsbCkge1xuICAgIG10aW1lID0ge1xuICAgICAgc2VjczogaW5wdXQuU2Vjb25kcyxcbiAgICAgIG5zZWNzOiBpbnB1dC5GcmFjdGlvbmFsTmFub3NlY29uZHNcbiAgICB9O1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgIG10aW1lID0ge1xuICAgICAgc2VjczogaW5wdXRbMF0sXG4gICAgICBuc2VjczogaW5wdXRbMV1cbiAgICB9O1xuICB9XG4gIGlmIChpbnB1dCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICBjb25zdCBtcyA9IGlucHV0LmdldFRpbWUoKTtcbiAgICBjb25zdCBzZWNzID0gTWF0aC5mbG9vcihtcyAvIDEwMDApO1xuICAgIG10aW1lID0ge1xuICAgICAgc2Vjczogc2VjcyxcbiAgICAgIG5zZWNzOiAobXMgLSBzZWNzICogMTAwMCkgKiAxMDAwXG4gICAgfTtcbiAgfVxuICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtdGltZSwgJ3NlY3MnKSkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKG10aW1lICE9IG51bGwgJiYgbXRpbWUubnNlY3MgIT0gbnVsbCAmJiAobXRpbWUubnNlY3MgPCAwIHx8IG10aW1lLm5zZWNzID4gOTk5OTk5OTk5KSkge1xuICAgIHRocm93IGVycmNvZGUobmV3IEVycm9yKCdtdGltZS1uc2VjcyBtdXN0IGJlIHdpdGhpbiB0aGUgcmFuZ2UgWzAsOTk5OTk5OTk5XScpLCAnRVJSX0lOVkFMSURfTVRJTUVfTlNFQ1MnKTtcbiAgfVxuICByZXR1cm4gbXRpbWU7XG59XG5jbGFzcyBVbml4RlMge1xuICBzdGF0aWMgdW5tYXJzaGFsKG1hcnNoYWxlZCkge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBQQkRhdGEuZGVjb2RlKG1hcnNoYWxlZCk7XG4gICAgY29uc3QgZGVjb2RlZCA9IFBCRGF0YS50b09iamVjdChtZXNzYWdlLCB7XG4gICAgICBkZWZhdWx0czogZmFsc2UsXG4gICAgICBhcnJheXM6IHRydWUsXG4gICAgICBsb25nczogTnVtYmVyLFxuICAgICAgb2JqZWN0czogZmFsc2VcbiAgICB9KTtcbiAgICBjb25zdCBkYXRhID0gbmV3IFVuaXhGUyh7XG4gICAgICB0eXBlOiB0eXBlc1tkZWNvZGVkLlR5cGVdLFxuICAgICAgZGF0YTogZGVjb2RlZC5EYXRhLFxuICAgICAgYmxvY2tTaXplczogZGVjb2RlZC5ibG9ja3NpemVzLFxuICAgICAgbW9kZTogZGVjb2RlZC5tb2RlLFxuICAgICAgbXRpbWU6IGRlY29kZWQubXRpbWUgPyB7XG4gICAgICAgIHNlY3M6IGRlY29kZWQubXRpbWUuU2Vjb25kcyxcbiAgICAgICAgbnNlY3M6IGRlY29kZWQubXRpbWUuRnJhY3Rpb25hbE5hbm9zZWNvbmRzXG4gICAgICB9IDogdW5kZWZpbmVkXG4gICAgfSk7XG4gICAgZGF0YS5fb3JpZ2luYWxNb2RlID0gZGVjb2RlZC5tb2RlIHx8IDA7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHsgdHlwZTogJ2ZpbGUnIH0pIHtcbiAgICBjb25zdCB7dHlwZSwgZGF0YSwgYmxvY2tTaXplcywgaGFzaFR5cGUsIGZhbm91dCwgbXRpbWUsIG1vZGV9ID0gb3B0aW9ucztcbiAgICBpZiAodHlwZSAmJiAhdHlwZXMuaW5jbHVkZXModHlwZSkpIHtcbiAgICAgIHRocm93IGVycmNvZGUobmV3IEVycm9yKCdUeXBlOiAnICsgdHlwZSArICcgaXMgbm90IHZhbGlkJyksICdFUlJfSU5WQUxJRF9UWVBFJyk7XG4gICAgfVxuICAgIHRoaXMudHlwZSA9IHR5cGUgfHwgJ2ZpbGUnO1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgdGhpcy5oYXNoVHlwZSA9IGhhc2hUeXBlO1xuICAgIHRoaXMuZmFub3V0ID0gZmFub3V0O1xuICAgIHRoaXMuYmxvY2tTaXplcyA9IGJsb2NrU2l6ZXMgfHwgW107XG4gICAgdGhpcy5fb3JpZ2luYWxNb2RlID0gMDtcbiAgICB0aGlzLm1vZGUgPSBwYXJzZU1vZGUobW9kZSk7XG4gICAgaWYgKG10aW1lKSB7XG4gICAgICB0aGlzLm10aW1lID0gcGFyc2VNdGltZShtdGltZSk7XG4gICAgICBpZiAodGhpcy5tdGltZSAmJiAhdGhpcy5tdGltZS5uc2Vjcykge1xuICAgICAgICB0aGlzLm10aW1lLm5zZWNzID0gMDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgc2V0IG1vZGUobW9kZSkge1xuICAgIHRoaXMuX21vZGUgPSB0aGlzLmlzRGlyZWN0b3J5KCkgPyBERUZBVUxUX0RJUkVDVE9SWV9NT0RFIDogREVGQVVMVF9GSUxFX01PREU7XG4gICAgY29uc3QgcGFyc2VkTW9kZSA9IHBhcnNlTW9kZShtb2RlKTtcbiAgICBpZiAocGFyc2VkTW9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLl9tb2RlID0gcGFyc2VkTW9kZTtcbiAgICB9XG4gIH1cbiAgZ2V0IG1vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21vZGU7XG4gIH1cbiAgaXNEaXJlY3RvcnkoKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4odGhpcy50eXBlICYmIGRpclR5cGVzLmluY2x1ZGVzKHRoaXMudHlwZSkpO1xuICB9XG4gIGFkZEJsb2NrU2l6ZShzaXplKSB7XG4gICAgdGhpcy5ibG9ja1NpemVzLnB1c2goc2l6ZSk7XG4gIH1cbiAgcmVtb3ZlQmxvY2tTaXplKGluZGV4KSB7XG4gICAgdGhpcy5ibG9ja1NpemVzLnNwbGljZShpbmRleCwgMSk7XG4gIH1cbiAgZmlsZVNpemUoKSB7XG4gICAgaWYgKHRoaXMuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGxldCBzdW0gPSAwO1xuICAgIHRoaXMuYmxvY2tTaXplcy5mb3JFYWNoKHNpemUgPT4ge1xuICAgICAgc3VtICs9IHNpemU7XG4gICAgfSk7XG4gICAgaWYgKHRoaXMuZGF0YSkge1xuICAgICAgc3VtICs9IHRoaXMuZGF0YS5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiBzdW07XG4gIH1cbiAgbWFyc2hhbCgpIHtcbiAgICBsZXQgdHlwZTtcbiAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgIGNhc2UgJ3Jhdyc6XG4gICAgICB0eXBlID0gUEJEYXRhLkRhdGFUeXBlLlJhdztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2RpcmVjdG9yeSc6XG4gICAgICB0eXBlID0gUEJEYXRhLkRhdGFUeXBlLkRpcmVjdG9yeTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2ZpbGUnOlxuICAgICAgdHlwZSA9IFBCRGF0YS5EYXRhVHlwZS5GaWxlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnbWV0YWRhdGEnOlxuICAgICAgdHlwZSA9IFBCRGF0YS5EYXRhVHlwZS5NZXRhZGF0YTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3N5bWxpbmsnOlxuICAgICAgdHlwZSA9IFBCRGF0YS5EYXRhVHlwZS5TeW1saW5rO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnaGFtdC1zaGFyZGVkLWRpcmVjdG9yeSc6XG4gICAgICB0eXBlID0gUEJEYXRhLkRhdGFUeXBlLkhBTVRTaGFyZDtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBlcnJjb2RlKG5ldyBFcnJvcignVHlwZTogJyArIHR5cGUgKyAnIGlzIG5vdCB2YWxpZCcpLCAnRVJSX0lOVkFMSURfVFlQRScpO1xuICAgIH1cbiAgICBsZXQgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICBpZiAoIXRoaXMuZGF0YSB8fCAhdGhpcy5kYXRhLmxlbmd0aCkge1xuICAgICAgZGF0YSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgbGV0IG1vZGU7XG4gICAgaWYgKHRoaXMubW9kZSAhPSBudWxsKSB7XG4gICAgICBtb2RlID0gdGhpcy5fb3JpZ2luYWxNb2RlICYgNDI5NDk2MzIwMCB8IChwYXJzZU1vZGUodGhpcy5tb2RlKSB8fCAwKTtcbiAgICAgIGlmIChtb2RlID09PSBERUZBVUxUX0ZJTEVfTU9ERSAmJiAhdGhpcy5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICAgIG1vZGUgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBpZiAobW9kZSA9PT0gREVGQVVMVF9ESVJFQ1RPUllfTU9ERSAmJiB0aGlzLmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgICAgbW9kZSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IG10aW1lO1xuICAgIGlmICh0aGlzLm10aW1lICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlTXRpbWUodGhpcy5tdGltZSk7XG4gICAgICBpZiAocGFyc2VkKSB7XG4gICAgICAgIG10aW1lID0ge1xuICAgICAgICAgIFNlY29uZHM6IHBhcnNlZC5zZWNzLFxuICAgICAgICAgIEZyYWN0aW9uYWxOYW5vc2Vjb25kczogcGFyc2VkLm5zZWNzXG4gICAgICAgIH07XG4gICAgICAgIGlmIChtdGltZS5GcmFjdGlvbmFsTmFub3NlY29uZHMgPT09IDApIHtcbiAgICAgICAgICBkZWxldGUgbXRpbWUuRnJhY3Rpb25hbE5hbm9zZWNvbmRzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHBiRGF0YSA9IHtcbiAgICAgIFR5cGU6IHR5cGUsXG4gICAgICBEYXRhOiBkYXRhLFxuICAgICAgZmlsZXNpemU6IHRoaXMuaXNEaXJlY3RvcnkoKSA/IHVuZGVmaW5lZCA6IHRoaXMuZmlsZVNpemUoKSxcbiAgICAgIGJsb2Nrc2l6ZXM6IHRoaXMuYmxvY2tTaXplcyxcbiAgICAgIGhhc2hUeXBlOiB0aGlzLmhhc2hUeXBlLFxuICAgICAgZmFub3V0OiB0aGlzLmZhbm91dCxcbiAgICAgIG1vZGUsXG4gICAgICBtdGltZVxuICAgIH07XG4gICAgcmV0dXJuIFBCRGF0YS5lbmNvZGUocGJEYXRhKS5maW5pc2goKTtcbiAgfVxufVxuZXhwb3J0IHtcbiAgVW5peEZTXG59OyIsICJpbXBvcnQgJHByb3RvYnVmIGZyb20gJ3Byb3RvYnVmanMvbWluaW1hbC5qcyc7XG5jb25zdCAkUmVhZGVyID0gJHByb3RvYnVmLlJlYWRlciwgJFdyaXRlciA9ICRwcm90b2J1Zi5Xcml0ZXIsICR1dGlsID0gJHByb3RvYnVmLnV0aWw7XG5jb25zdCAkcm9vdCA9ICRwcm90b2J1Zi5yb290c1snaXBmcy11bml4ZnMnXSB8fCAoJHByb3RvYnVmLnJvb3RzWydpcGZzLXVuaXhmcyddID0ge30pO1xuZXhwb3J0IGNvbnN0IERhdGEgPSAkcm9vdC5EYXRhID0gKCgpID0+IHtcbiAgZnVuY3Rpb24gRGF0YShwKSB7XG4gICAgdGhpcy5ibG9ja3NpemVzID0gW107XG4gICAgaWYgKHApXG4gICAgICBmb3IgKHZhciBrcyA9IE9iamVjdC5rZXlzKHApLCBpID0gMDsgaSA8IGtzLmxlbmd0aDsgKytpKVxuICAgICAgICBpZiAocFtrc1tpXV0gIT0gbnVsbClcbiAgICAgICAgICB0aGlzW2tzW2ldXSA9IHBba3NbaV1dO1xuICB9XG4gIERhdGEucHJvdG90eXBlLlR5cGUgPSAwO1xuICBEYXRhLnByb3RvdHlwZS5EYXRhID0gJHV0aWwubmV3QnVmZmVyKFtdKTtcbiAgRGF0YS5wcm90b3R5cGUuZmlsZXNpemUgPSAkdXRpbC5Mb25nID8gJHV0aWwuTG9uZy5mcm9tQml0cygwLCAwLCB0cnVlKSA6IDA7XG4gIERhdGEucHJvdG90eXBlLmJsb2Nrc2l6ZXMgPSAkdXRpbC5lbXB0eUFycmF5O1xuICBEYXRhLnByb3RvdHlwZS5oYXNoVHlwZSA9ICR1dGlsLkxvbmcgPyAkdXRpbC5Mb25nLmZyb21CaXRzKDAsIDAsIHRydWUpIDogMDtcbiAgRGF0YS5wcm90b3R5cGUuZmFub3V0ID0gJHV0aWwuTG9uZyA/ICR1dGlsLkxvbmcuZnJvbUJpdHMoMCwgMCwgdHJ1ZSkgOiAwO1xuICBEYXRhLnByb3RvdHlwZS5tb2RlID0gMDtcbiAgRGF0YS5wcm90b3R5cGUubXRpbWUgPSBudWxsO1xuICBEYXRhLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShtLCB3KSB7XG4gICAgaWYgKCF3KVxuICAgICAgdyA9ICRXcml0ZXIuY3JlYXRlKCk7XG4gICAgdy51aW50MzIoOCkuaW50MzIobS5UeXBlKTtcbiAgICBpZiAobS5EYXRhICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobSwgJ0RhdGEnKSlcbiAgICAgIHcudWludDMyKDE4KS5ieXRlcyhtLkRhdGEpO1xuICAgIGlmIChtLmZpbGVzaXplICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobSwgJ2ZpbGVzaXplJykpXG4gICAgICB3LnVpbnQzMigyNCkudWludDY0KG0uZmlsZXNpemUpO1xuICAgIGlmIChtLmJsb2Nrc2l6ZXMgIT0gbnVsbCAmJiBtLmJsb2Nrc2l6ZXMubGVuZ3RoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG0uYmxvY2tzaXplcy5sZW5ndGg7ICsraSlcbiAgICAgICAgdy51aW50MzIoMzIpLnVpbnQ2NChtLmJsb2Nrc2l6ZXNbaV0pO1xuICAgIH1cbiAgICBpZiAobS5oYXNoVHlwZSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG0sICdoYXNoVHlwZScpKVxuICAgICAgdy51aW50MzIoNDApLnVpbnQ2NChtLmhhc2hUeXBlKTtcbiAgICBpZiAobS5mYW5vdXQgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtLCAnZmFub3V0JykpXG4gICAgICB3LnVpbnQzMig0OCkudWludDY0KG0uZmFub3V0KTtcbiAgICBpZiAobS5tb2RlICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobSwgJ21vZGUnKSlcbiAgICAgIHcudWludDMyKDU2KS51aW50MzIobS5tb2RlKTtcbiAgICBpZiAobS5tdGltZSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG0sICdtdGltZScpKVxuICAgICAgJHJvb3QuVW5peFRpbWUuZW5jb2RlKG0ubXRpbWUsIHcudWludDMyKDY2KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgIHJldHVybiB3O1xuICB9O1xuICBEYXRhLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyLCBsKSB7XG4gICAgaWYgKCEociBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgciA9ICRSZWFkZXIuY3JlYXRlKHIpO1xuICAgIHZhciBjID0gbCA9PT0gdW5kZWZpbmVkID8gci5sZW4gOiByLnBvcyArIGwsIG0gPSBuZXcgJHJvb3QuRGF0YSgpO1xuICAgIHdoaWxlIChyLnBvcyA8IGMpIHtcbiAgICAgIHZhciB0ID0gci51aW50MzIoKTtcbiAgICAgIHN3aXRjaCAodCA+Pj4gMykge1xuICAgICAgY2FzZSAxOlxuICAgICAgICBtLlR5cGUgPSByLmludDMyKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICBtLkRhdGEgPSByLmJ5dGVzKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBtLmZpbGVzaXplID0gci51aW50NjQoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDQ6XG4gICAgICAgIGlmICghKG0uYmxvY2tzaXplcyAmJiBtLmJsb2Nrc2l6ZXMubGVuZ3RoKSlcbiAgICAgICAgICBtLmJsb2Nrc2l6ZXMgPSBbXTtcbiAgICAgICAgaWYgKCh0ICYgNykgPT09IDIpIHtcbiAgICAgICAgICB2YXIgYzIgPSByLnVpbnQzMigpICsgci5wb3M7XG4gICAgICAgICAgd2hpbGUgKHIucG9zIDwgYzIpXG4gICAgICAgICAgICBtLmJsb2Nrc2l6ZXMucHVzaChyLnVpbnQ2NCgpKTtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgbS5ibG9ja3NpemVzLnB1c2goci51aW50NjQoKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA1OlxuICAgICAgICBtLmhhc2hUeXBlID0gci51aW50NjQoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDY6XG4gICAgICAgIG0uZmFub3V0ID0gci51aW50NjQoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDc6XG4gICAgICAgIG0ubW9kZSA9IHIudWludDMyKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA4OlxuICAgICAgICBtLm10aW1lID0gJHJvb3QuVW5peFRpbWUuZGVjb2RlKHIsIHIudWludDMyKCkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHIuc2tpcFR5cGUodCAmIDcpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFtLmhhc093blByb3BlcnR5KCdUeXBlJykpXG4gICAgICB0aHJvdyAkdXRpbC5Qcm90b2NvbEVycm9yKCdtaXNzaW5nIHJlcXVpcmVkIFxcJ1R5cGVcXCcnLCB7IGluc3RhbmNlOiBtIH0pO1xuICAgIHJldHVybiBtO1xuICB9O1xuICBEYXRhLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KGQpIHtcbiAgICBpZiAoZCBpbnN0YW5jZW9mICRyb290LkRhdGEpXG4gICAgICByZXR1cm4gZDtcbiAgICB2YXIgbSA9IG5ldyAkcm9vdC5EYXRhKCk7XG4gICAgc3dpdGNoIChkLlR5cGUpIHtcbiAgICBjYXNlICdSYXcnOlxuICAgIGNhc2UgMDpcbiAgICAgIG0uVHlwZSA9IDA7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdEaXJlY3RvcnknOlxuICAgIGNhc2UgMTpcbiAgICAgIG0uVHlwZSA9IDE7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdGaWxlJzpcbiAgICBjYXNlIDI6XG4gICAgICBtLlR5cGUgPSAyO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnTWV0YWRhdGEnOlxuICAgIGNhc2UgMzpcbiAgICAgIG0uVHlwZSA9IDM7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdTeW1saW5rJzpcbiAgICBjYXNlIDQ6XG4gICAgICBtLlR5cGUgPSA0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnSEFNVFNoYXJkJzpcbiAgICBjYXNlIDU6XG4gICAgICBtLlR5cGUgPSA1O1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChkLkRhdGEgIT0gbnVsbCkge1xuICAgICAgaWYgKHR5cGVvZiBkLkRhdGEgPT09ICdzdHJpbmcnKVxuICAgICAgICAkdXRpbC5iYXNlNjQuZGVjb2RlKGQuRGF0YSwgbS5EYXRhID0gJHV0aWwubmV3QnVmZmVyKCR1dGlsLmJhc2U2NC5sZW5ndGgoZC5EYXRhKSksIDApO1xuICAgICAgZWxzZSBpZiAoZC5EYXRhLmxlbmd0aClcbiAgICAgICAgbS5EYXRhID0gZC5EYXRhO1xuICAgIH1cbiAgICBpZiAoZC5maWxlc2l6ZSAhPSBudWxsKSB7XG4gICAgICBpZiAoJHV0aWwuTG9uZylcbiAgICAgICAgKG0uZmlsZXNpemUgPSAkdXRpbC5Mb25nLmZyb21WYWx1ZShkLmZpbGVzaXplKSkudW5zaWduZWQgPSB0cnVlO1xuICAgICAgZWxzZSBpZiAodHlwZW9mIGQuZmlsZXNpemUgPT09ICdzdHJpbmcnKVxuICAgICAgICBtLmZpbGVzaXplID0gcGFyc2VJbnQoZC5maWxlc2l6ZSwgMTApO1xuICAgICAgZWxzZSBpZiAodHlwZW9mIGQuZmlsZXNpemUgPT09ICdudW1iZXInKVxuICAgICAgICBtLmZpbGVzaXplID0gZC5maWxlc2l6ZTtcbiAgICAgIGVsc2UgaWYgKHR5cGVvZiBkLmZpbGVzaXplID09PSAnb2JqZWN0JylcbiAgICAgICAgbS5maWxlc2l6ZSA9IG5ldyAkdXRpbC5Mb25nQml0cyhkLmZpbGVzaXplLmxvdyA+Pj4gMCwgZC5maWxlc2l6ZS5oaWdoID4+PiAwKS50b051bWJlcih0cnVlKTtcbiAgICB9XG4gICAgaWYgKGQuYmxvY2tzaXplcykge1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGQuYmxvY2tzaXplcykpXG4gICAgICAgIHRocm93IFR5cGVFcnJvcignLkRhdGEuYmxvY2tzaXplczogYXJyYXkgZXhwZWN0ZWQnKTtcbiAgICAgIG0uYmxvY2tzaXplcyA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkLmJsb2Nrc2l6ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKCR1dGlsLkxvbmcpXG4gICAgICAgICAgKG0uYmxvY2tzaXplc1tpXSA9ICR1dGlsLkxvbmcuZnJvbVZhbHVlKGQuYmxvY2tzaXplc1tpXSkpLnVuc2lnbmVkID0gdHJ1ZTtcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGQuYmxvY2tzaXplc1tpXSA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgbS5ibG9ja3NpemVzW2ldID0gcGFyc2VJbnQoZC5ibG9ja3NpemVzW2ldLCAxMCk7XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBkLmJsb2Nrc2l6ZXNbaV0gPT09ICdudW1iZXInKVxuICAgICAgICAgIG0uYmxvY2tzaXplc1tpXSA9IGQuYmxvY2tzaXplc1tpXTtcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGQuYmxvY2tzaXplc1tpXSA9PT0gJ29iamVjdCcpXG4gICAgICAgICAgbS5ibG9ja3NpemVzW2ldID0gbmV3ICR1dGlsLkxvbmdCaXRzKGQuYmxvY2tzaXplc1tpXS5sb3cgPj4+IDAsIGQuYmxvY2tzaXplc1tpXS5oaWdoID4+PiAwKS50b051bWJlcih0cnVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGQuaGFzaFR5cGUgIT0gbnVsbCkge1xuICAgICAgaWYgKCR1dGlsLkxvbmcpXG4gICAgICAgIChtLmhhc2hUeXBlID0gJHV0aWwuTG9uZy5mcm9tVmFsdWUoZC5oYXNoVHlwZSkpLnVuc2lnbmVkID0gdHJ1ZTtcbiAgICAgIGVsc2UgaWYgKHR5cGVvZiBkLmhhc2hUeXBlID09PSAnc3RyaW5nJylcbiAgICAgICAgbS5oYXNoVHlwZSA9IHBhcnNlSW50KGQuaGFzaFR5cGUsIDEwKTtcbiAgICAgIGVsc2UgaWYgKHR5cGVvZiBkLmhhc2hUeXBlID09PSAnbnVtYmVyJylcbiAgICAgICAgbS5oYXNoVHlwZSA9IGQuaGFzaFR5cGU7XG4gICAgICBlbHNlIGlmICh0eXBlb2YgZC5oYXNoVHlwZSA9PT0gJ29iamVjdCcpXG4gICAgICAgIG0uaGFzaFR5cGUgPSBuZXcgJHV0aWwuTG9uZ0JpdHMoZC5oYXNoVHlwZS5sb3cgPj4+IDAsIGQuaGFzaFR5cGUuaGlnaCA+Pj4gMCkudG9OdW1iZXIodHJ1ZSk7XG4gICAgfVxuICAgIGlmIChkLmZhbm91dCAhPSBudWxsKSB7XG4gICAgICBpZiAoJHV0aWwuTG9uZylcbiAgICAgICAgKG0uZmFub3V0ID0gJHV0aWwuTG9uZy5mcm9tVmFsdWUoZC5mYW5vdXQpKS51bnNpZ25lZCA9IHRydWU7XG4gICAgICBlbHNlIGlmICh0eXBlb2YgZC5mYW5vdXQgPT09ICdzdHJpbmcnKVxuICAgICAgICBtLmZhbm91dCA9IHBhcnNlSW50KGQuZmFub3V0LCAxMCk7XG4gICAgICBlbHNlIGlmICh0eXBlb2YgZC5mYW5vdXQgPT09ICdudW1iZXInKVxuICAgICAgICBtLmZhbm91dCA9IGQuZmFub3V0O1xuICAgICAgZWxzZSBpZiAodHlwZW9mIGQuZmFub3V0ID09PSAnb2JqZWN0JylcbiAgICAgICAgbS5mYW5vdXQgPSBuZXcgJHV0aWwuTG9uZ0JpdHMoZC5mYW5vdXQubG93ID4+PiAwLCBkLmZhbm91dC5oaWdoID4+PiAwKS50b051bWJlcih0cnVlKTtcbiAgICB9XG4gICAgaWYgKGQubW9kZSAhPSBudWxsKSB7XG4gICAgICBtLm1vZGUgPSBkLm1vZGUgPj4+IDA7XG4gICAgfVxuICAgIGlmIChkLm10aW1lICE9IG51bGwpIHtcbiAgICAgIGlmICh0eXBlb2YgZC5tdGltZSAhPT0gJ29iamVjdCcpXG4gICAgICAgIHRocm93IFR5cGVFcnJvcignLkRhdGEubXRpbWU6IG9iamVjdCBleHBlY3RlZCcpO1xuICAgICAgbS5tdGltZSA9ICRyb290LlVuaXhUaW1lLmZyb21PYmplY3QoZC5tdGltZSk7XG4gICAgfVxuICAgIHJldHVybiBtO1xuICB9O1xuICBEYXRhLnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobSwgbykge1xuICAgIGlmICghbylcbiAgICAgIG8gPSB7fTtcbiAgICB2YXIgZCA9IHt9O1xuICAgIGlmIChvLmFycmF5cyB8fCBvLmRlZmF1bHRzKSB7XG4gICAgICBkLmJsb2Nrc2l6ZXMgPSBbXTtcbiAgICB9XG4gICAgaWYgKG8uZGVmYXVsdHMpIHtcbiAgICAgIGQuVHlwZSA9IG8uZW51bXMgPT09IFN0cmluZyA/ICdSYXcnIDogMDtcbiAgICAgIGlmIChvLmJ5dGVzID09PSBTdHJpbmcpXG4gICAgICAgIGQuRGF0YSA9ICcnO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGQuRGF0YSA9IFtdO1xuICAgICAgICBpZiAoby5ieXRlcyAhPT0gQXJyYXkpXG4gICAgICAgICAgZC5EYXRhID0gJHV0aWwubmV3QnVmZmVyKGQuRGF0YSk7XG4gICAgICB9XG4gICAgICBpZiAoJHV0aWwuTG9uZykge1xuICAgICAgICB2YXIgbiA9IG5ldyAkdXRpbC5Mb25nKDAsIDAsIHRydWUpO1xuICAgICAgICBkLmZpbGVzaXplID0gby5sb25ncyA9PT0gU3RyaW5nID8gbi50b1N0cmluZygpIDogby5sb25ncyA9PT0gTnVtYmVyID8gbi50b051bWJlcigpIDogbjtcbiAgICAgIH0gZWxzZVxuICAgICAgICBkLmZpbGVzaXplID0gby5sb25ncyA9PT0gU3RyaW5nID8gJzAnIDogMDtcbiAgICAgIGlmICgkdXRpbC5Mb25nKSB7XG4gICAgICAgIHZhciBuID0gbmV3ICR1dGlsLkxvbmcoMCwgMCwgdHJ1ZSk7XG4gICAgICAgIGQuaGFzaFR5cGUgPSBvLmxvbmdzID09PSBTdHJpbmcgPyBuLnRvU3RyaW5nKCkgOiBvLmxvbmdzID09PSBOdW1iZXIgPyBuLnRvTnVtYmVyKCkgOiBuO1xuICAgICAgfSBlbHNlXG4gICAgICAgIGQuaGFzaFR5cGUgPSBvLmxvbmdzID09PSBTdHJpbmcgPyAnMCcgOiAwO1xuICAgICAgaWYgKCR1dGlsLkxvbmcpIHtcbiAgICAgICAgdmFyIG4gPSBuZXcgJHV0aWwuTG9uZygwLCAwLCB0cnVlKTtcbiAgICAgICAgZC5mYW5vdXQgPSBvLmxvbmdzID09PSBTdHJpbmcgPyBuLnRvU3RyaW5nKCkgOiBvLmxvbmdzID09PSBOdW1iZXIgPyBuLnRvTnVtYmVyKCkgOiBuO1xuICAgICAgfSBlbHNlXG4gICAgICAgIGQuZmFub3V0ID0gby5sb25ncyA9PT0gU3RyaW5nID8gJzAnIDogMDtcbiAgICAgIGQubW9kZSA9IDA7XG4gICAgICBkLm10aW1lID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKG0uVHlwZSAhPSBudWxsICYmIG0uaGFzT3duUHJvcGVydHkoJ1R5cGUnKSkge1xuICAgICAgZC5UeXBlID0gby5lbnVtcyA9PT0gU3RyaW5nID8gJHJvb3QuRGF0YS5EYXRhVHlwZVttLlR5cGVdIDogbS5UeXBlO1xuICAgIH1cbiAgICBpZiAobS5EYXRhICE9IG51bGwgJiYgbS5oYXNPd25Qcm9wZXJ0eSgnRGF0YScpKSB7XG4gICAgICBkLkRhdGEgPSBvLmJ5dGVzID09PSBTdHJpbmcgPyAkdXRpbC5iYXNlNjQuZW5jb2RlKG0uRGF0YSwgMCwgbS5EYXRhLmxlbmd0aCkgOiBvLmJ5dGVzID09PSBBcnJheSA/IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG0uRGF0YSkgOiBtLkRhdGE7XG4gICAgfVxuICAgIGlmIChtLmZpbGVzaXplICE9IG51bGwgJiYgbS5oYXNPd25Qcm9wZXJ0eSgnZmlsZXNpemUnKSkge1xuICAgICAgaWYgKHR5cGVvZiBtLmZpbGVzaXplID09PSAnbnVtYmVyJylcbiAgICAgICAgZC5maWxlc2l6ZSA9IG8ubG9uZ3MgPT09IFN0cmluZyA/IFN0cmluZyhtLmZpbGVzaXplKSA6IG0uZmlsZXNpemU7XG4gICAgICBlbHNlXG4gICAgICAgIGQuZmlsZXNpemUgPSBvLmxvbmdzID09PSBTdHJpbmcgPyAkdXRpbC5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG0uZmlsZXNpemUpIDogby5sb25ncyA9PT0gTnVtYmVyID8gbmV3ICR1dGlsLkxvbmdCaXRzKG0uZmlsZXNpemUubG93ID4+PiAwLCBtLmZpbGVzaXplLmhpZ2ggPj4+IDApLnRvTnVtYmVyKHRydWUpIDogbS5maWxlc2l6ZTtcbiAgICB9XG4gICAgaWYgKG0uYmxvY2tzaXplcyAmJiBtLmJsb2Nrc2l6ZXMubGVuZ3RoKSB7XG4gICAgICBkLmJsb2Nrc2l6ZXMgPSBbXTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbS5ibG9ja3NpemVzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbS5ibG9ja3NpemVzW2pdID09PSAnbnVtYmVyJylcbiAgICAgICAgICBkLmJsb2Nrc2l6ZXNbal0gPSBvLmxvbmdzID09PSBTdHJpbmcgPyBTdHJpbmcobS5ibG9ja3NpemVzW2pdKSA6IG0uYmxvY2tzaXplc1tqXTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGQuYmxvY2tzaXplc1tqXSA9IG8ubG9uZ3MgPT09IFN0cmluZyA/ICR1dGlsLkxvbmcucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobS5ibG9ja3NpemVzW2pdKSA6IG8ubG9uZ3MgPT09IE51bWJlciA/IG5ldyAkdXRpbC5Mb25nQml0cyhtLmJsb2Nrc2l6ZXNbal0ubG93ID4+PiAwLCBtLmJsb2Nrc2l6ZXNbal0uaGlnaCA+Pj4gMCkudG9OdW1iZXIodHJ1ZSkgOiBtLmJsb2Nrc2l6ZXNbal07XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChtLmhhc2hUeXBlICE9IG51bGwgJiYgbS5oYXNPd25Qcm9wZXJ0eSgnaGFzaFR5cGUnKSkge1xuICAgICAgaWYgKHR5cGVvZiBtLmhhc2hUeXBlID09PSAnbnVtYmVyJylcbiAgICAgICAgZC5oYXNoVHlwZSA9IG8ubG9uZ3MgPT09IFN0cmluZyA/IFN0cmluZyhtLmhhc2hUeXBlKSA6IG0uaGFzaFR5cGU7XG4gICAgICBlbHNlXG4gICAgICAgIGQuaGFzaFR5cGUgPSBvLmxvbmdzID09PSBTdHJpbmcgPyAkdXRpbC5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG0uaGFzaFR5cGUpIDogby5sb25ncyA9PT0gTnVtYmVyID8gbmV3ICR1dGlsLkxvbmdCaXRzKG0uaGFzaFR5cGUubG93ID4+PiAwLCBtLmhhc2hUeXBlLmhpZ2ggPj4+IDApLnRvTnVtYmVyKHRydWUpIDogbS5oYXNoVHlwZTtcbiAgICB9XG4gICAgaWYgKG0uZmFub3V0ICE9IG51bGwgJiYgbS5oYXNPd25Qcm9wZXJ0eSgnZmFub3V0JykpIHtcbiAgICAgIGlmICh0eXBlb2YgbS5mYW5vdXQgPT09ICdudW1iZXInKVxuICAgICAgICBkLmZhbm91dCA9IG8ubG9uZ3MgPT09IFN0cmluZyA/IFN0cmluZyhtLmZhbm91dCkgOiBtLmZhbm91dDtcbiAgICAgIGVsc2VcbiAgICAgICAgZC5mYW5vdXQgPSBvLmxvbmdzID09PSBTdHJpbmcgPyAkdXRpbC5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG0uZmFub3V0KSA6IG8ubG9uZ3MgPT09IE51bWJlciA/IG5ldyAkdXRpbC5Mb25nQml0cyhtLmZhbm91dC5sb3cgPj4+IDAsIG0uZmFub3V0LmhpZ2ggPj4+IDApLnRvTnVtYmVyKHRydWUpIDogbS5mYW5vdXQ7XG4gICAgfVxuICAgIGlmIChtLm1vZGUgIT0gbnVsbCAmJiBtLmhhc093blByb3BlcnR5KCdtb2RlJykpIHtcbiAgICAgIGQubW9kZSA9IG0ubW9kZTtcbiAgICB9XG4gICAgaWYgKG0ubXRpbWUgIT0gbnVsbCAmJiBtLmhhc093blByb3BlcnR5KCdtdGltZScpKSB7XG4gICAgICBkLm10aW1lID0gJHJvb3QuVW5peFRpbWUudG9PYmplY3QobS5tdGltZSwgbyk7XG4gICAgfVxuICAgIHJldHVybiBkO1xuICB9O1xuICBEYXRhLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcywgJHByb3RvYnVmLnV0aWwudG9KU09OT3B0aW9ucyk7XG4gIH07XG4gIERhdGEuRGF0YVR5cGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3QgdmFsdWVzQnlJZCA9IHt9LCB2YWx1ZXMgPSBPYmplY3QuY3JlYXRlKHZhbHVlc0J5SWQpO1xuICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzBdID0gJ1JhdyddID0gMDtcbiAgICB2YWx1ZXNbdmFsdWVzQnlJZFsxXSA9ICdEaXJlY3RvcnknXSA9IDE7XG4gICAgdmFsdWVzW3ZhbHVlc0J5SWRbMl0gPSAnRmlsZSddID0gMjtcbiAgICB2YWx1ZXNbdmFsdWVzQnlJZFszXSA9ICdNZXRhZGF0YSddID0gMztcbiAgICB2YWx1ZXNbdmFsdWVzQnlJZFs0XSA9ICdTeW1saW5rJ10gPSA0O1xuICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzVdID0gJ0hBTVRTaGFyZCddID0gNTtcbiAgICByZXR1cm4gdmFsdWVzO1xuICB9KCk7XG4gIHJldHVybiBEYXRhO1xufSkoKTtcbmV4cG9ydCBjb25zdCBVbml4VGltZSA9ICRyb290LlVuaXhUaW1lID0gKCgpID0+IHtcbiAgZnVuY3Rpb24gVW5peFRpbWUocCkge1xuICAgIGlmIChwKVxuICAgICAgZm9yICh2YXIga3MgPSBPYmplY3Qua2V5cyhwKSwgaSA9IDA7IGkgPCBrcy5sZW5ndGg7ICsraSlcbiAgICAgICAgaWYgKHBba3NbaV1dICE9IG51bGwpXG4gICAgICAgICAgdGhpc1trc1tpXV0gPSBwW2tzW2ldXTtcbiAgfVxuICBVbml4VGltZS5wcm90b3R5cGUuU2Vjb25kcyA9ICR1dGlsLkxvbmcgPyAkdXRpbC5Mb25nLmZyb21CaXRzKDAsIDAsIGZhbHNlKSA6IDA7XG4gIFVuaXhUaW1lLnByb3RvdHlwZS5GcmFjdGlvbmFsTmFub3NlY29uZHMgPSAwO1xuICBVbml4VGltZS5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUobSwgdykge1xuICAgIGlmICghdylcbiAgICAgIHcgPSAkV3JpdGVyLmNyZWF0ZSgpO1xuICAgIHcudWludDMyKDgpLmludDY0KG0uU2Vjb25kcyk7XG4gICAgaWYgKG0uRnJhY3Rpb25hbE5hbm9zZWNvbmRzICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobSwgJ0ZyYWN0aW9uYWxOYW5vc2Vjb25kcycpKVxuICAgICAgdy51aW50MzIoMjEpLmZpeGVkMzIobS5GcmFjdGlvbmFsTmFub3NlY29uZHMpO1xuICAgIHJldHVybiB3O1xuICB9O1xuICBVbml4VGltZS5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUociwgbCkge1xuICAgIGlmICghKHIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgIHIgPSAkUmVhZGVyLmNyZWF0ZShyKTtcbiAgICB2YXIgYyA9IGwgPT09IHVuZGVmaW5lZCA/IHIubGVuIDogci5wb3MgKyBsLCBtID0gbmV3ICRyb290LlVuaXhUaW1lKCk7XG4gICAgd2hpbGUgKHIucG9zIDwgYykge1xuICAgICAgdmFyIHQgPSByLnVpbnQzMigpO1xuICAgICAgc3dpdGNoICh0ID4+PiAzKSB7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIG0uU2Vjb25kcyA9IHIuaW50NjQoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIG0uRnJhY3Rpb25hbE5hbm9zZWNvbmRzID0gci5maXhlZDMyKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgci5za2lwVHlwZSh0ICYgNyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIW0uaGFzT3duUHJvcGVydHkoJ1NlY29uZHMnKSlcbiAgICAgIHRocm93ICR1dGlsLlByb3RvY29sRXJyb3IoJ21pc3NpbmcgcmVxdWlyZWQgXFwnU2Vjb25kc1xcJycsIHsgaW5zdGFuY2U6IG0gfSk7XG4gICAgcmV0dXJuIG07XG4gIH07XG4gIFVuaXhUaW1lLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KGQpIHtcbiAgICBpZiAoZCBpbnN0YW5jZW9mICRyb290LlVuaXhUaW1lKVxuICAgICAgcmV0dXJuIGQ7XG4gICAgdmFyIG0gPSBuZXcgJHJvb3QuVW5peFRpbWUoKTtcbiAgICBpZiAoZC5TZWNvbmRzICE9IG51bGwpIHtcbiAgICAgIGlmICgkdXRpbC5Mb25nKVxuICAgICAgICAobS5TZWNvbmRzID0gJHV0aWwuTG9uZy5mcm9tVmFsdWUoZC5TZWNvbmRzKSkudW5zaWduZWQgPSBmYWxzZTtcbiAgICAgIGVsc2UgaWYgKHR5cGVvZiBkLlNlY29uZHMgPT09ICdzdHJpbmcnKVxuICAgICAgICBtLlNlY29uZHMgPSBwYXJzZUludChkLlNlY29uZHMsIDEwKTtcbiAgICAgIGVsc2UgaWYgKHR5cGVvZiBkLlNlY29uZHMgPT09ICdudW1iZXInKVxuICAgICAgICBtLlNlY29uZHMgPSBkLlNlY29uZHM7XG4gICAgICBlbHNlIGlmICh0eXBlb2YgZC5TZWNvbmRzID09PSAnb2JqZWN0JylcbiAgICAgICAgbS5TZWNvbmRzID0gbmV3ICR1dGlsLkxvbmdCaXRzKGQuU2Vjb25kcy5sb3cgPj4+IDAsIGQuU2Vjb25kcy5oaWdoID4+PiAwKS50b051bWJlcigpO1xuICAgIH1cbiAgICBpZiAoZC5GcmFjdGlvbmFsTmFub3NlY29uZHMgIT0gbnVsbCkge1xuICAgICAgbS5GcmFjdGlvbmFsTmFub3NlY29uZHMgPSBkLkZyYWN0aW9uYWxOYW5vc2Vjb25kcyA+Pj4gMDtcbiAgICB9XG4gICAgcmV0dXJuIG07XG4gIH07XG4gIFVuaXhUaW1lLnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobSwgbykge1xuICAgIGlmICghbylcbiAgICAgIG8gPSB7fTtcbiAgICB2YXIgZCA9IHt9O1xuICAgIGlmIChvLmRlZmF1bHRzKSB7XG4gICAgICBpZiAoJHV0aWwuTG9uZykge1xuICAgICAgICB2YXIgbiA9IG5ldyAkdXRpbC5Mb25nKDAsIDAsIGZhbHNlKTtcbiAgICAgICAgZC5TZWNvbmRzID0gby5sb25ncyA9PT0gU3RyaW5nID8gbi50b1N0cmluZygpIDogby5sb25ncyA9PT0gTnVtYmVyID8gbi50b051bWJlcigpIDogbjtcbiAgICAgIH0gZWxzZVxuICAgICAgICBkLlNlY29uZHMgPSBvLmxvbmdzID09PSBTdHJpbmcgPyAnMCcgOiAwO1xuICAgICAgZC5GcmFjdGlvbmFsTmFub3NlY29uZHMgPSAwO1xuICAgIH1cbiAgICBpZiAobS5TZWNvbmRzICE9IG51bGwgJiYgbS5oYXNPd25Qcm9wZXJ0eSgnU2Vjb25kcycpKSB7XG4gICAgICBpZiAodHlwZW9mIG0uU2Vjb25kcyA9PT0gJ251bWJlcicpXG4gICAgICAgIGQuU2Vjb25kcyA9IG8ubG9uZ3MgPT09IFN0cmluZyA/IFN0cmluZyhtLlNlY29uZHMpIDogbS5TZWNvbmRzO1xuICAgICAgZWxzZVxuICAgICAgICBkLlNlY29uZHMgPSBvLmxvbmdzID09PSBTdHJpbmcgPyAkdXRpbC5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG0uU2Vjb25kcykgOiBvLmxvbmdzID09PSBOdW1iZXIgPyBuZXcgJHV0aWwuTG9uZ0JpdHMobS5TZWNvbmRzLmxvdyA+Pj4gMCwgbS5TZWNvbmRzLmhpZ2ggPj4+IDApLnRvTnVtYmVyKCkgOiBtLlNlY29uZHM7XG4gICAgfVxuICAgIGlmIChtLkZyYWN0aW9uYWxOYW5vc2Vjb25kcyAhPSBudWxsICYmIG0uaGFzT3duUHJvcGVydHkoJ0ZyYWN0aW9uYWxOYW5vc2Vjb25kcycpKSB7XG4gICAgICBkLkZyYWN0aW9uYWxOYW5vc2Vjb25kcyA9IG0uRnJhY3Rpb25hbE5hbm9zZWNvbmRzO1xuICAgIH1cbiAgICByZXR1cm4gZDtcbiAgfTtcbiAgVW5peFRpbWUucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLCAkcHJvdG9idWYudXRpbC50b0pTT05PcHRpb25zKTtcbiAgfTtcbiAgcmV0dXJuIFVuaXhUaW1lO1xufSkoKTtcbmV4cG9ydCBjb25zdCBNZXRhZGF0YSA9ICRyb290Lk1ldGFkYXRhID0gKCgpID0+IHtcbiAgZnVuY3Rpb24gTWV0YWRhdGEocCkge1xuICAgIGlmIChwKVxuICAgICAgZm9yICh2YXIga3MgPSBPYmplY3Qua2V5cyhwKSwgaSA9IDA7IGkgPCBrcy5sZW5ndGg7ICsraSlcbiAgICAgICAgaWYgKHBba3NbaV1dICE9IG51bGwpXG4gICAgICAgICAgdGhpc1trc1tpXV0gPSBwW2tzW2ldXTtcbiAgfVxuICBNZXRhZGF0YS5wcm90b3R5cGUuTWltZVR5cGUgPSAnJztcbiAgTWV0YWRhdGEuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKG0sIHcpIHtcbiAgICBpZiAoIXcpXG4gICAgICB3ID0gJFdyaXRlci5jcmVhdGUoKTtcbiAgICBpZiAobS5NaW1lVHlwZSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG0sICdNaW1lVHlwZScpKVxuICAgICAgdy51aW50MzIoMTApLnN0cmluZyhtLk1pbWVUeXBlKTtcbiAgICByZXR1cm4gdztcbiAgfTtcbiAgTWV0YWRhdGEuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHIsIGwpIHtcbiAgICBpZiAoIShyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICByID0gJFJlYWRlci5jcmVhdGUocik7XG4gICAgdmFyIGMgPSBsID09PSB1bmRlZmluZWQgPyByLmxlbiA6IHIucG9zICsgbCwgbSA9IG5ldyAkcm9vdC5NZXRhZGF0YSgpO1xuICAgIHdoaWxlIChyLnBvcyA8IGMpIHtcbiAgICAgIHZhciB0ID0gci51aW50MzIoKTtcbiAgICAgIHN3aXRjaCAodCA+Pj4gMykge1xuICAgICAgY2FzZSAxOlxuICAgICAgICBtLk1pbWVUeXBlID0gci5zdHJpbmcoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByLnNraXBUeXBlKHQgJiA3KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtO1xuICB9O1xuICBNZXRhZGF0YS5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChkKSB7XG4gICAgaWYgKGQgaW5zdGFuY2VvZiAkcm9vdC5NZXRhZGF0YSlcbiAgICAgIHJldHVybiBkO1xuICAgIHZhciBtID0gbmV3ICRyb290Lk1ldGFkYXRhKCk7XG4gICAgaWYgKGQuTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgbS5NaW1lVHlwZSA9IFN0cmluZyhkLk1pbWVUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIG07XG4gIH07XG4gIE1ldGFkYXRhLnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobSwgbykge1xuICAgIGlmICghbylcbiAgICAgIG8gPSB7fTtcbiAgICB2YXIgZCA9IHt9O1xuICAgIGlmIChvLmRlZmF1bHRzKSB7XG4gICAgICBkLk1pbWVUeXBlID0gJyc7XG4gICAgfVxuICAgIGlmIChtLk1pbWVUeXBlICE9IG51bGwgJiYgbS5oYXNPd25Qcm9wZXJ0eSgnTWltZVR5cGUnKSkge1xuICAgICAgZC5NaW1lVHlwZSA9IG0uTWltZVR5cGU7XG4gICAgfVxuICAgIHJldHVybiBkO1xuICB9O1xuICBNZXRhZGF0YS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsICRwcm90b2J1Zi51dGlsLnRvSlNPTk9wdGlvbnMpO1xuICB9O1xuICByZXR1cm4gTWV0YWRhdGE7XG59KSgpO1xuZXhwb3J0IHtcbiAgJHJvb3QgYXMgZGVmYXVsdFxufTsiLCAiaW1wb3J0IHsgQ0lEIH0gZnJvbSAnbXVsdGlmb3JtYXRzL2NpZCc7XG5pbXBvcnQgKiBhcyBkYWdQYiBmcm9tICdAaXBsZC9kYWctcGInO1xuaW1wb3J0IHsgc2hhMjU2IH0gZnJvbSAnbXVsdGlmb3JtYXRzL2hhc2hlcy9zaGEyJztcbmNvbnN0IHBlcnNpc3QgPSBhc3luYyAoYnVmZmVyLCBibG9ja3N0b3JlLCBvcHRpb25zKSA9PiB7XG4gIGlmICghb3B0aW9ucy5jb2RlYykge1xuICAgIG9wdGlvbnMuY29kZWMgPSBkYWdQYjtcbiAgfVxuICBpZiAoIW9wdGlvbnMuaGFzaGVyKSB7XG4gICAgb3B0aW9ucy5oYXNoZXIgPSBzaGEyNTY7XG4gIH1cbiAgaWYgKG9wdGlvbnMuY2lkVmVyc2lvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgb3B0aW9ucy5jaWRWZXJzaW9uID0gMTtcbiAgfVxuICBpZiAob3B0aW9ucy5jb2RlYyA9PT0gZGFnUGIgJiYgb3B0aW9ucy5oYXNoZXIgIT09IHNoYTI1Nikge1xuICAgIG9wdGlvbnMuY2lkVmVyc2lvbiA9IDE7XG4gIH1cbiAgY29uc3QgbXVsdGloYXNoID0gYXdhaXQgb3B0aW9ucy5oYXNoZXIuZGlnZXN0KGJ1ZmZlcik7XG4gIGNvbnN0IGNpZCA9IENJRC5jcmVhdGUob3B0aW9ucy5jaWRWZXJzaW9uLCBvcHRpb25zLmNvZGVjLmNvZGUsIG11bHRpaGFzaCk7XG4gIGlmICghb3B0aW9ucy5vbmx5SGFzaCkge1xuICAgIGF3YWl0IGJsb2Nrc3RvcmUucHV0KGNpZCwgYnVmZmVyLCB7IHNpZ25hbDogb3B0aW9ucy5zaWduYWwgfSk7XG4gIH1cbiAgcmV0dXJuIGNpZDtcbn07XG5leHBvcnQgZGVmYXVsdCBwZXJzaXN0OyIsICJpbXBvcnQgeyBVbml4RlMgfSBmcm9tICdpcGZzLXVuaXhmcyc7XG5pbXBvcnQgcGVyc2lzdCBmcm9tICcuLi91dGlscy9wZXJzaXN0LmpzJztcbmltcG9ydCB7XG4gIGVuY29kZSxcbiAgcHJlcGFyZVxufSBmcm9tICdAaXBsZC9kYWctcGInO1xuY29uc3QgZGlyQnVpbGRlciA9IGFzeW5jIChpdGVtLCBibG9ja3N0b3JlLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHVuaXhmcyA9IG5ldyBVbml4RlMoe1xuICAgIHR5cGU6ICdkaXJlY3RvcnknLFxuICAgIG10aW1lOiBpdGVtLm10aW1lLFxuICAgIG1vZGU6IGl0ZW0ubW9kZVxuICB9KTtcbiAgY29uc3QgYnVmZmVyID0gZW5jb2RlKHByZXBhcmUoeyBEYXRhOiB1bml4ZnMubWFyc2hhbCgpIH0pKTtcbiAgY29uc3QgY2lkID0gYXdhaXQgcGVyc2lzdChidWZmZXIsIGJsb2Nrc3RvcmUsIG9wdGlvbnMpO1xuICBjb25zdCBwYXRoID0gaXRlbS5wYXRoO1xuICByZXR1cm4ge1xuICAgIGNpZCxcbiAgICBwYXRoLFxuICAgIHVuaXhmcyxcbiAgICBzaXplOiBidWZmZXIubGVuZ3RoXG4gIH07XG59O1xuZXhwb3J0IGRlZmF1bHQgZGlyQnVpbGRlcjsiLCAiaW1wb3J0IGVyckNvZGUgZnJvbSAnZXJyLWNvZGUnO1xuaW1wb3J0IHsgVW5peEZTIH0gZnJvbSAnaXBmcy11bml4ZnMnO1xuaW1wb3J0IHBlcnNpc3QgZnJvbSAnLi4vLi4vdXRpbHMvcGVyc2lzdC5qcyc7XG5pbXBvcnQge1xuICBlbmNvZGUsXG4gIHByZXBhcmVcbn0gZnJvbSAnQGlwbGQvZGFnLXBiJztcbmltcG9ydCBwYXJhbGxlbEJhdGNoIGZyb20gJ2l0LXBhcmFsbGVsLWJhdGNoJztcbmltcG9ydCAqIGFzIHJhd0NvZGVjIGZyb20gJ211bHRpZm9ybWF0cy9jb2RlY3MvcmF3JztcbmltcG9ydCAqIGFzIGRhZ1BiIGZyb20gJ0BpcGxkL2RhZy1wYic7XG5pbXBvcnQgZGFnRmxhdCBmcm9tICcuL2ZsYXQuanMnO1xuaW1wb3J0IGRhZ0JhbGFuY2VkIGZyb20gJy4vYmFsYW5jZWQuanMnO1xuaW1wb3J0IGRhZ1RyaWNrbGUgZnJvbSAnLi90cmlja2xlLmpzJztcbmltcG9ydCBidWZmZXJJbXBvcnRlckZuIGZyb20gJy4vYnVmZmVyLWltcG9ydGVyLmpzJztcbmNvbnN0IGRhZ0J1aWxkZXJzID0ge1xuICBmbGF0OiBkYWdGbGF0LFxuICBiYWxhbmNlZDogZGFnQmFsYW5jZWQsXG4gIHRyaWNrbGU6IGRhZ1RyaWNrbGVcbn07XG5hc3luYyBmdW5jdGlvbiogYnVpbGRGaWxlQmF0Y2goZmlsZSwgYmxvY2tzdG9yZSwgb3B0aW9ucykge1xuICBsZXQgY291bnQgPSAtMTtcbiAgbGV0IHByZXZpb3VzO1xuICBsZXQgYnVmZmVySW1wb3J0ZXI7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5idWZmZXJJbXBvcnRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGJ1ZmZlckltcG9ydGVyID0gb3B0aW9ucy5idWZmZXJJbXBvcnRlcjtcbiAgfSBlbHNlIHtcbiAgICBidWZmZXJJbXBvcnRlciA9IGJ1ZmZlckltcG9ydGVyRm47XG4gIH1cbiAgZm9yIGF3YWl0IChjb25zdCBlbnRyeSBvZiBwYXJhbGxlbEJhdGNoKGJ1ZmZlckltcG9ydGVyKGZpbGUsIGJsb2Nrc3RvcmUsIG9wdGlvbnMpLCBvcHRpb25zLmJsb2NrV3JpdGVDb25jdXJyZW5jeSkpIHtcbiAgICBjb3VudCsrO1xuICAgIGlmIChjb3VudCA9PT0gMCkge1xuICAgICAgcHJldmlvdXMgPSBlbnRyeTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gZWxzZSBpZiAoY291bnQgPT09IDEgJiYgcHJldmlvdXMpIHtcbiAgICAgIHlpZWxkIHByZXZpb3VzO1xuICAgICAgcHJldmlvdXMgPSBudWxsO1xuICAgIH1cbiAgICB5aWVsZCBlbnRyeTtcbiAgfVxuICBpZiAocHJldmlvdXMpIHtcbiAgICBwcmV2aW91cy5zaW5nbGUgPSB0cnVlO1xuICAgIHlpZWxkIHByZXZpb3VzO1xuICB9XG59XG5jb25zdCByZWR1Y2UgPSAoZmlsZSwgYmxvY2tzdG9yZSwgb3B0aW9ucykgPT4ge1xuICBhc3luYyBmdW5jdGlvbiByZWR1Y2VyKGxlYXZlcykge1xuICAgIGlmIChsZWF2ZXMubGVuZ3RoID09PSAxICYmIGxlYXZlc1swXS5zaW5nbGUgJiYgb3B0aW9ucy5yZWR1Y2VTaW5nbGVMZWFmVG9TZWxmKSB7XG4gICAgICBjb25zdCBsZWFmID0gbGVhdmVzWzBdO1xuICAgICAgaWYgKGZpbGUubXRpbWUgIT09IHVuZGVmaW5lZCB8fCBmaWxlLm1vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgYnVmZmVyID0gYXdhaXQgYmxvY2tzdG9yZS5nZXQobGVhZi5jaWQpO1xuICAgICAgICBsZWFmLnVuaXhmcyA9IG5ldyBVbml4RlMoe1xuICAgICAgICAgIHR5cGU6ICdmaWxlJyxcbiAgICAgICAgICBtdGltZTogZmlsZS5tdGltZSxcbiAgICAgICAgICBtb2RlOiBmaWxlLm1vZGUsXG4gICAgICAgICAgZGF0YTogYnVmZmVyXG4gICAgICAgIH0pO1xuICAgICAgICBidWZmZXIgPSBlbmNvZGUocHJlcGFyZSh7IERhdGE6IGxlYWYudW5peGZzLm1hcnNoYWwoKSB9KSk7XG4gICAgICAgIGxlYWYuY2lkID0gYXdhaXQgcGVyc2lzdChidWZmZXIsIGJsb2Nrc3RvcmUsIHtcbiAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgIGNvZGVjOiBkYWdQYixcbiAgICAgICAgICBoYXNoZXI6IG9wdGlvbnMuaGFzaGVyLFxuICAgICAgICAgIGNpZFZlcnNpb246IG9wdGlvbnMuY2lkVmVyc2lvblxuICAgICAgICB9KTtcbiAgICAgICAgbGVhZi5zaXplID0gYnVmZmVyLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNpZDogbGVhZi5jaWQsXG4gICAgICAgIHBhdGg6IGZpbGUucGF0aCxcbiAgICAgICAgdW5peGZzOiBsZWFmLnVuaXhmcyxcbiAgICAgICAgc2l6ZTogbGVhZi5zaXplXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBmID0gbmV3IFVuaXhGUyh7XG4gICAgICB0eXBlOiAnZmlsZScsXG4gICAgICBtdGltZTogZmlsZS5tdGltZSxcbiAgICAgIG1vZGU6IGZpbGUubW9kZVxuICAgIH0pO1xuICAgIGNvbnN0IGxpbmtzID0gbGVhdmVzLmZpbHRlcihsZWFmID0+IHtcbiAgICAgIGlmIChsZWFmLmNpZC5jb2RlID09PSByYXdDb2RlYy5jb2RlICYmIGxlYWYuc2l6ZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChsZWFmLnVuaXhmcyAmJiAhbGVhZi51bml4ZnMuZGF0YSAmJiBsZWFmLnVuaXhmcy5maWxlU2l6ZSgpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEJvb2xlYW4obGVhZi51bml4ZnMgJiYgbGVhZi51bml4ZnMuZGF0YSAmJiBsZWFmLnVuaXhmcy5kYXRhLmxlbmd0aCk7XG4gICAgfSkubWFwKGxlYWYgPT4ge1xuICAgICAgaWYgKGxlYWYuY2lkLmNvZGUgPT09IHJhd0NvZGVjLmNvZGUpIHtcbiAgICAgICAgZi5hZGRCbG9ja1NpemUobGVhZi5zaXplKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBOYW1lOiAnJyxcbiAgICAgICAgICBUc2l6ZTogbGVhZi5zaXplLFxuICAgICAgICAgIEhhc2g6IGxlYWYuY2lkXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAoIWxlYWYudW5peGZzIHx8ICFsZWFmLnVuaXhmcy5kYXRhKSB7XG4gICAgICAgIGYuYWRkQmxvY2tTaXplKGxlYWYudW5peGZzICYmIGxlYWYudW5peGZzLmZpbGVTaXplKCkgfHwgMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmLmFkZEJsb2NrU2l6ZShsZWFmLnVuaXhmcy5kYXRhLmxlbmd0aCk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBOYW1lOiAnJyxcbiAgICAgICAgVHNpemU6IGxlYWYuc2l6ZSxcbiAgICAgICAgSGFzaDogbGVhZi5jaWRcbiAgICAgIH07XG4gICAgfSk7XG4gICAgY29uc3Qgbm9kZSA9IHtcbiAgICAgIERhdGE6IGYubWFyc2hhbCgpLFxuICAgICAgTGlua3M6IGxpbmtzXG4gICAgfTtcbiAgICBjb25zdCBidWZmZXIgPSBlbmNvZGUocHJlcGFyZShub2RlKSk7XG4gICAgY29uc3QgY2lkID0gYXdhaXQgcGVyc2lzdChidWZmZXIsIGJsb2Nrc3RvcmUsIG9wdGlvbnMpO1xuICAgIHJldHVybiB7XG4gICAgICBjaWQsXG4gICAgICBwYXRoOiBmaWxlLnBhdGgsXG4gICAgICB1bml4ZnM6IGYsXG4gICAgICBzaXplOiBidWZmZXIubGVuZ3RoICsgbm9kZS5MaW5rcy5yZWR1Y2UoKGFjYywgY3VycikgPT4gYWNjICsgY3Vyci5Uc2l6ZSwgMClcbiAgICB9O1xuICB9XG4gIHJldHVybiByZWR1Y2VyO1xufTtcbmZ1bmN0aW9uIGZpbGVCdWlsZGVyKGZpbGUsIGJsb2NrLCBvcHRpb25zKSB7XG4gIGNvbnN0IGRhZ0J1aWxkZXIgPSBkYWdCdWlsZGVyc1tvcHRpb25zLnN0cmF0ZWd5XTtcbiAgaWYgKCFkYWdCdWlsZGVyKSB7XG4gICAgdGhyb3cgZXJyQ29kZShuZXcgRXJyb3IoYFVua25vd24gaW1wb3J0ZXIgYnVpbGQgc3RyYXRlZ3kgbmFtZTogJHsgb3B0aW9ucy5zdHJhdGVneSB9YCksICdFUlJfQkFEX1NUUkFURUdZJyk7XG4gIH1cbiAgcmV0dXJuIGRhZ0J1aWxkZXIoYnVpbGRGaWxlQmF0Y2goZmlsZSwgYmxvY2ssIG9wdGlvbnMpLCByZWR1Y2UoZmlsZSwgYmxvY2ssIG9wdGlvbnMpLCBvcHRpb25zKTtcbn1cbmV4cG9ydCBkZWZhdWx0IGZpbGVCdWlsZGVyOyIsICJpbXBvcnQgYWxsIGZyb20gJ2l0LWFsbCc7XG5hc3luYyBmdW5jdGlvbiBmbGF0KHNvdXJjZSwgcmVkdWNlKSB7XG4gIHJldHVybiByZWR1Y2UoYXdhaXQgYWxsKHNvdXJjZSkpO1xufVxuZXhwb3J0IGRlZmF1bHQgZmxhdDsiLCAiaW1wb3J0IGJhdGNoIGZyb20gJ2l0LWJhdGNoJztcbmZ1bmN0aW9uIGJhbGFuY2VkKHNvdXJjZSwgcmVkdWNlLCBvcHRpb25zKSB7XG4gIHJldHVybiByZWR1Y2VUb1BhcmVudHMoc291cmNlLCByZWR1Y2UsIG9wdGlvbnMpO1xufVxuYXN5bmMgZnVuY3Rpb24gcmVkdWNlVG9QYXJlbnRzKHNvdXJjZSwgcmVkdWNlLCBvcHRpb25zKSB7XG4gIGNvbnN0IHJvb3RzID0gW107XG4gIGZvciBhd2FpdCAoY29uc3QgY2h1bmtlZCBvZiBiYXRjaChzb3VyY2UsIG9wdGlvbnMubWF4Q2hpbGRyZW5QZXJOb2RlKSkge1xuICAgIHJvb3RzLnB1c2goYXdhaXQgcmVkdWNlKGNodW5rZWQpKTtcbiAgfVxuICBpZiAocm9vdHMubGVuZ3RoID4gMSkge1xuICAgIHJldHVybiByZWR1Y2VUb1BhcmVudHMocm9vdHMsIHJlZHVjZSwgb3B0aW9ucyk7XG4gIH1cbiAgcmV0dXJuIHJvb3RzWzBdO1xufVxuZXhwb3J0IGRlZmF1bHQgYmFsYW5jZWQ7IiwgImltcG9ydCBiYXRjaCBmcm9tICdpdC1iYXRjaCc7XG5hc3luYyBmdW5jdGlvbiB0cmlja2xlU3RyZWFtKHNvdXJjZSwgcmVkdWNlLCBvcHRpb25zKSB7XG4gIGNvbnN0IHJvb3QgPSBuZXcgUm9vdChvcHRpb25zLmxheWVyUmVwZWF0KTtcbiAgbGV0IGl0ZXJhdGlvbiA9IDA7XG4gIGxldCBtYXhEZXB0aCA9IDE7XG4gIGxldCBzdWJUcmVlID0gcm9vdDtcbiAgZm9yIGF3YWl0IChjb25zdCBsYXllciBvZiBiYXRjaChzb3VyY2UsIG9wdGlvbnMubWF4Q2hpbGRyZW5QZXJOb2RlKSkge1xuICAgIGlmIChzdWJUcmVlLmlzRnVsbCgpKSB7XG4gICAgICBpZiAoc3ViVHJlZSAhPT0gcm9vdCkge1xuICAgICAgICByb290LmFkZENoaWxkKGF3YWl0IHN1YlRyZWUucmVkdWNlKHJlZHVjZSkpO1xuICAgICAgfVxuICAgICAgaWYgKGl0ZXJhdGlvbiAmJiBpdGVyYXRpb24gJSBvcHRpb25zLmxheWVyUmVwZWF0ID09PSAwKSB7XG4gICAgICAgIG1heERlcHRoKys7XG4gICAgICB9XG4gICAgICBzdWJUcmVlID0gbmV3IFN1YlRyZWUobWF4RGVwdGgsIG9wdGlvbnMubGF5ZXJSZXBlYXQsIGl0ZXJhdGlvbik7XG4gICAgICBpdGVyYXRpb24rKztcbiAgICB9XG4gICAgc3ViVHJlZS5hcHBlbmQobGF5ZXIpO1xuICB9XG4gIGlmIChzdWJUcmVlICYmIHN1YlRyZWUgIT09IHJvb3QpIHtcbiAgICByb290LmFkZENoaWxkKGF3YWl0IHN1YlRyZWUucmVkdWNlKHJlZHVjZSkpO1xuICB9XG4gIHJldHVybiByb290LnJlZHVjZShyZWR1Y2UpO1xufVxuZXhwb3J0IGRlZmF1bHQgdHJpY2tsZVN0cmVhbTtcbmNsYXNzIFN1YlRyZWUge1xuICBjb25zdHJ1Y3RvcihtYXhEZXB0aCwgbGF5ZXJSZXBlYXQsIGl0ZXJhdGlvbiA9IDApIHtcbiAgICB0aGlzLm1heERlcHRoID0gbWF4RGVwdGg7XG4gICAgdGhpcy5sYXllclJlcGVhdCA9IGxheWVyUmVwZWF0O1xuICAgIHRoaXMuY3VycmVudERlcHRoID0gMTtcbiAgICB0aGlzLml0ZXJhdGlvbiA9IGl0ZXJhdGlvbjtcbiAgICB0aGlzLnJvb3QgPSB0aGlzLm5vZGUgPSB0aGlzLnBhcmVudCA9IHtcbiAgICAgIGNoaWxkcmVuOiBbXSxcbiAgICAgIGRlcHRoOiB0aGlzLmN1cnJlbnREZXB0aCxcbiAgICAgIG1heERlcHRoLFxuICAgICAgbWF4Q2hpbGRyZW46ICh0aGlzLm1heERlcHRoIC0gdGhpcy5jdXJyZW50RGVwdGgpICogdGhpcy5sYXllclJlcGVhdFxuICAgIH07XG4gIH1cbiAgaXNGdWxsKCkge1xuICAgIGlmICghdGhpcy5yb290LmRhdGEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuY3VycmVudERlcHRoIDwgdGhpcy5tYXhEZXB0aCAmJiB0aGlzLm5vZGUubWF4Q2hpbGRyZW4pIHtcbiAgICAgIHRoaXMuX2FkZE5leHROb2RlVG9QYXJlbnQodGhpcy5ub2RlKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgZGlzdGFudFJlbGF0aXZlID0gdGhpcy5fZmluZFBhcmVudCh0aGlzLm5vZGUsIHRoaXMuY3VycmVudERlcHRoKTtcbiAgICBpZiAoZGlzdGFudFJlbGF0aXZlKSB7XG4gICAgICB0aGlzLl9hZGROZXh0Tm9kZVRvUGFyZW50KGRpc3RhbnRSZWxhdGl2ZSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIF9hZGROZXh0Tm9kZVRvUGFyZW50KHBhcmVudCkge1xuICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgIGNvbnN0IG5leHROb2RlID0ge1xuICAgICAgY2hpbGRyZW46IFtdLFxuICAgICAgZGVwdGg6IHBhcmVudC5kZXB0aCArIDEsXG4gICAgICBwYXJlbnQsXG4gICAgICBtYXhEZXB0aDogdGhpcy5tYXhEZXB0aCxcbiAgICAgIG1heENoaWxkcmVuOiBNYXRoLmZsb29yKHBhcmVudC5jaGlsZHJlbi5sZW5ndGggLyB0aGlzLmxheWVyUmVwZWF0KSAqIHRoaXMubGF5ZXJSZXBlYXRcbiAgICB9O1xuICAgIHBhcmVudC5jaGlsZHJlbi5wdXNoKG5leHROb2RlKTtcbiAgICB0aGlzLmN1cnJlbnREZXB0aCA9IG5leHROb2RlLmRlcHRoO1xuICAgIHRoaXMubm9kZSA9IG5leHROb2RlO1xuICB9XG4gIGFwcGVuZChsYXllcikge1xuICAgIHRoaXMubm9kZS5kYXRhID0gbGF5ZXI7XG4gIH1cbiAgcmVkdWNlKHJlZHVjZSkge1xuICAgIHJldHVybiB0aGlzLl9yZWR1Y2UodGhpcy5yb290LCByZWR1Y2UpO1xuICB9XG4gIGFzeW5jIF9yZWR1Y2Uobm9kZSwgcmVkdWNlKSB7XG4gICAgbGV0IGNoaWxkcmVuID0gW107XG4gICAgaWYgKG5vZGUuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICBjaGlsZHJlbiA9IGF3YWl0IFByb21pc2UuYWxsKG5vZGUuY2hpbGRyZW4uZmlsdGVyKGNoaWxkID0+IGNoaWxkLmRhdGEpLm1hcChjaGlsZCA9PiB0aGlzLl9yZWR1Y2UoY2hpbGQsIHJlZHVjZSkpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlZHVjZSgobm9kZS5kYXRhIHx8IFtdKS5jb25jYXQoY2hpbGRyZW4pKTtcbiAgfVxuICBfZmluZFBhcmVudChub2RlLCBkZXB0aCkge1xuICAgIGNvbnN0IHBhcmVudCA9IG5vZGUucGFyZW50O1xuICAgIGlmICghcGFyZW50IHx8IHBhcmVudC5kZXB0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAocGFyZW50LmNoaWxkcmVuLmxlbmd0aCA9PT0gcGFyZW50Lm1heENoaWxkcmVuIHx8ICFwYXJlbnQubWF4Q2hpbGRyZW4pIHtcbiAgICAgIHJldHVybiB0aGlzLl9maW5kUGFyZW50KHBhcmVudCwgZGVwdGgpO1xuICAgIH1cbiAgICByZXR1cm4gcGFyZW50O1xuICB9XG59XG5jbGFzcyBSb290IGV4dGVuZHMgU3ViVHJlZSB7XG4gIGNvbnN0cnVjdG9yKGxheWVyUmVwZWF0KSB7XG4gICAgc3VwZXIoMCwgbGF5ZXJSZXBlYXQpO1xuICAgIHRoaXMucm9vdC5kZXB0aCA9IDA7XG4gICAgdGhpcy5jdXJyZW50RGVwdGggPSAxO1xuICB9XG4gIGFkZENoaWxkKGNoaWxkKSB7XG4gICAgdGhpcy5yb290LmNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICB9XG4gIHJlZHVjZShyZWR1Y2UpIHtcbiAgICByZXR1cm4gcmVkdWNlKCh0aGlzLnJvb3QuZGF0YSB8fCBbXSkuY29uY2F0KHRoaXMucm9vdC5jaGlsZHJlbikpO1xuICB9XG59IiwgImltcG9ydCB7IFVuaXhGUyB9IGZyb20gJ2lwZnMtdW5peGZzJztcbmltcG9ydCBwZXJzaXN0IGZyb20gJy4uLy4uL3V0aWxzL3BlcnNpc3QuanMnO1xuaW1wb3J0ICogYXMgZGFnUGIgZnJvbSAnQGlwbGQvZGFnLXBiJztcbmltcG9ydCAqIGFzIHJhdyBmcm9tICdtdWx0aWZvcm1hdHMvY29kZWNzL3Jhdyc7XG5hc3luYyBmdW5jdGlvbiogYnVmZmVySW1wb3J0ZXIoZmlsZSwgYmxvY2ssIG9wdGlvbnMpIHtcbiAgZm9yIGF3YWl0IChsZXQgYnVmZmVyIG9mIGZpbGUuY29udGVudCkge1xuICAgIHlpZWxkIGFzeW5jICgpID0+IHtcbiAgICAgIG9wdGlvbnMucHJvZ3Jlc3MoYnVmZmVyLmxlbmd0aCwgZmlsZS5wYXRoKTtcbiAgICAgIGxldCB1bml4ZnM7XG4gICAgICBjb25zdCBvcHRzID0ge1xuICAgICAgICBjb2RlYzogZGFnUGIsXG4gICAgICAgIGNpZFZlcnNpb246IG9wdGlvbnMuY2lkVmVyc2lvbixcbiAgICAgICAgaGFzaGVyOiBvcHRpb25zLmhhc2hlcixcbiAgICAgICAgb25seUhhc2g6IG9wdGlvbnMub25seUhhc2hcbiAgICAgIH07XG4gICAgICBpZiAob3B0aW9ucy5yYXdMZWF2ZXMpIHtcbiAgICAgICAgb3B0cy5jb2RlYyA9IHJhdztcbiAgICAgICAgb3B0cy5jaWRWZXJzaW9uID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVuaXhmcyA9IG5ldyBVbml4RlMoe1xuICAgICAgICAgIHR5cGU6IG9wdGlvbnMubGVhZlR5cGUsXG4gICAgICAgICAgZGF0YTogYnVmZmVyXG4gICAgICAgIH0pO1xuICAgICAgICBidWZmZXIgPSBkYWdQYi5lbmNvZGUoe1xuICAgICAgICAgIERhdGE6IHVuaXhmcy5tYXJzaGFsKCksXG4gICAgICAgICAgTGlua3M6IFtdXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY2lkOiBhd2FpdCBwZXJzaXN0KGJ1ZmZlciwgYmxvY2ssIG9wdHMpLFxuICAgICAgICB1bml4ZnMsXG4gICAgICAgIHNpemU6IGJ1ZmZlci5sZW5ndGhcbiAgICAgIH07XG4gICAgfTtcbiAgfVxufVxuZXhwb3J0IGRlZmF1bHQgYnVmZmVySW1wb3J0ZXI7IiwgImltcG9ydCBkaXJCdWlsZGVyIGZyb20gJy4vZGlyLmpzJztcbmltcG9ydCBmaWxlQnVpbGRlciBmcm9tICcuL2ZpbGUvaW5kZXguanMnO1xuaW1wb3J0IGVyckNvZGUgZnJvbSAnZXJyLWNvZGUnO1xuaW1wb3J0IHJhYmluIGZyb20gJy4uL2NodW5rZXIvcmFiaW4uanMnO1xuaW1wb3J0IGZpeGVkU2l6ZSBmcm9tICcuLi9jaHVua2VyL2ZpeGVkLXNpemUuanMnO1xuaW1wb3J0IHZhbGlkYXRlQ2h1bmtzIGZyb20gJy4vdmFsaWRhdGUtY2h1bmtzLmpzJztcbmZ1bmN0aW9uIGlzSXRlcmFibGUodGhpbmcpIHtcbiAgcmV0dXJuIFN5bWJvbC5pdGVyYXRvciBpbiB0aGluZztcbn1cbmZ1bmN0aW9uIGlzQXN5bmNJdGVyYWJsZSh0aGluZykge1xuICByZXR1cm4gU3ltYm9sLmFzeW5jSXRlcmF0b3IgaW4gdGhpbmc7XG59XG5mdW5jdGlvbiBjb250ZW50QXNBc3luY0l0ZXJhYmxlKGNvbnRlbnQpIHtcbiAgdHJ5IHtcbiAgICBpZiAoY29udGVudCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgIHJldHVybiBhc3luYyBmdW5jdGlvbiogKCkge1xuICAgICAgICB5aWVsZCBjb250ZW50O1xuICAgICAgfSgpO1xuICAgIH0gZWxzZSBpZiAoaXNJdGVyYWJsZShjb250ZW50KSkge1xuICAgICAgcmV0dXJuIGFzeW5jIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIHlpZWxkKiBjb250ZW50O1xuICAgICAgfSgpO1xuICAgIH0gZWxzZSBpZiAoaXNBc3luY0l0ZXJhYmxlKGNvbnRlbnQpKSB7XG4gICAgICByZXR1cm4gY29udGVudDtcbiAgICB9XG4gIH0gY2F0Y2gge1xuICAgIHRocm93IGVyckNvZGUobmV3IEVycm9yKCdDb250ZW50IHdhcyBpbnZhbGlkJyksICdFUlJfSU5WQUxJRF9DT05URU5UJyk7XG4gIH1cbiAgdGhyb3cgZXJyQ29kZShuZXcgRXJyb3IoJ0NvbnRlbnQgd2FzIGludmFsaWQnKSwgJ0VSUl9JTlZBTElEX0NPTlRFTlQnKTtcbn1cbmFzeW5jIGZ1bmN0aW9uKiBkYWdCdWlsZGVyKHNvdXJjZSwgYmxvY2tzdG9yZSwgb3B0aW9ucykge1xuICBmb3IgYXdhaXQgKGNvbnN0IGVudHJ5IG9mIHNvdXJjZSkge1xuICAgIGlmIChlbnRyeS5wYXRoKSB7XG4gICAgICBpZiAoZW50cnkucGF0aC5zdWJzdHJpbmcoMCwgMikgPT09ICcuLycpIHtcbiAgICAgICAgb3B0aW9ucy53cmFwV2l0aERpcmVjdG9yeSA9IHRydWU7XG4gICAgICB9XG4gICAgICBlbnRyeS5wYXRoID0gZW50cnkucGF0aC5zcGxpdCgnLycpLmZpbHRlcihwYXRoID0+IHBhdGggJiYgcGF0aCAhPT0gJy4nKS5qb2luKCcvJyk7XG4gICAgfVxuICAgIGlmIChlbnRyeS5jb250ZW50KSB7XG4gICAgICBsZXQgY2h1bmtlcjtcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5jaHVua2VyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNodW5rZXIgPSBvcHRpb25zLmNodW5rZXI7XG4gICAgICB9IGVsc2UgaWYgKG9wdGlvbnMuY2h1bmtlciA9PT0gJ3JhYmluJykge1xuICAgICAgICBjaHVua2VyID0gcmFiaW47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaHVua2VyID0gZml4ZWRTaXplO1xuICAgICAgfVxuICAgICAgbGV0IGNodW5rVmFsaWRhdG9yO1xuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmNodW5rVmFsaWRhdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNodW5rVmFsaWRhdG9yID0gb3B0aW9ucy5jaHVua1ZhbGlkYXRvcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNodW5rVmFsaWRhdG9yID0gdmFsaWRhdGVDaHVua3M7XG4gICAgICB9XG4gICAgICBjb25zdCBmaWxlID0ge1xuICAgICAgICBwYXRoOiBlbnRyeS5wYXRoLFxuICAgICAgICBtdGltZTogZW50cnkubXRpbWUsXG4gICAgICAgIG1vZGU6IGVudHJ5Lm1vZGUsXG4gICAgICAgIGNvbnRlbnQ6IGNodW5rZXIoY2h1bmtWYWxpZGF0b3IoY29udGVudEFzQXN5bmNJdGVyYWJsZShlbnRyeS5jb250ZW50KSwgb3B0aW9ucyksIG9wdGlvbnMpXG4gICAgICB9O1xuICAgICAgeWllbGQgKCkgPT4gZmlsZUJ1aWxkZXIoZmlsZSwgYmxvY2tzdG9yZSwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIGlmIChlbnRyeS5wYXRoKSB7XG4gICAgICBjb25zdCBkaXIgPSB7XG4gICAgICAgIHBhdGg6IGVudHJ5LnBhdGgsXG4gICAgICAgIG10aW1lOiBlbnRyeS5tdGltZSxcbiAgICAgICAgbW9kZTogZW50cnkubW9kZVxuICAgICAgfTtcbiAgICAgIHlpZWxkICgpID0+IGRpckJ1aWxkZXIoZGlyLCBibG9ja3N0b3JlLCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbXBvcnQgY2FuZGlkYXRlIG11c3QgaGF2ZSBjb250ZW50IG9yIHBhdGggb3IgYm90aCcpO1xuICAgIH1cbiAgfVxufVxuZXhwb3J0IGRlZmF1bHQgZGFnQnVpbGRlcjsiLCAiaW1wb3J0IEJ1ZmZlckxpc3QgZnJvbSAnYmwvQnVmZmVyTGlzdC5qcyc7XG5pbXBvcnQgeyBjcmVhdGUgfSBmcm9tICdyYWJpbi13YXNtJztcbmltcG9ydCBlcnJjb2RlIGZyb20gJ2Vyci1jb2RlJztcbmFzeW5jIGZ1bmN0aW9uKiByYWJpbkNodW5rZXIoc291cmNlLCBvcHRpb25zKSB7XG4gIGxldCBtaW4sIG1heCwgYXZnO1xuICBpZiAob3B0aW9ucy5taW5DaHVua1NpemUgJiYgb3B0aW9ucy5tYXhDaHVua1NpemUgJiYgb3B0aW9ucy5hdmdDaHVua1NpemUpIHtcbiAgICBhdmcgPSBvcHRpb25zLmF2Z0NodW5rU2l6ZTtcbiAgICBtaW4gPSBvcHRpb25zLm1pbkNodW5rU2l6ZTtcbiAgICBtYXggPSBvcHRpb25zLm1heENodW5rU2l6ZTtcbiAgfSBlbHNlIGlmICghb3B0aW9ucy5hdmdDaHVua1NpemUpIHtcbiAgICB0aHJvdyBlcnJjb2RlKG5ldyBFcnJvcigncGxlYXNlIHNwZWNpZnkgYW4gYXZlcmFnZSBjaHVuayBzaXplJyksICdFUlJfSU5WQUxJRF9BVkdfQ0hVTktfU0laRScpO1xuICB9IGVsc2Uge1xuICAgIGF2ZyA9IG9wdGlvbnMuYXZnQ2h1bmtTaXplO1xuICAgIG1pbiA9IGF2ZyAvIDM7XG4gICAgbWF4ID0gYXZnICsgYXZnIC8gMjtcbiAgfVxuICBpZiAobWluIDwgMTYpIHtcbiAgICB0aHJvdyBlcnJjb2RlKG5ldyBFcnJvcigncmFiaW4gbWluIG11c3QgYmUgZ3JlYXRlciB0aGFuIDE2JyksICdFUlJfSU5WQUxJRF9NSU5fQ0hVTktfU0laRScpO1xuICB9XG4gIGlmIChtYXggPCBtaW4pIHtcbiAgICBtYXggPSBtaW47XG4gIH1cbiAgaWYgKGF2ZyA8IG1pbikge1xuICAgIGF2ZyA9IG1pbjtcbiAgfVxuICBjb25zdCBzaXplcG93ID0gTWF0aC5mbG9vcihNYXRoLmxvZzIoYXZnKSk7XG4gIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgcmFiaW4oc291cmNlLCB7XG4gICAgICBtaW46IG1pbixcbiAgICAgIG1heDogbWF4LFxuICAgICAgYml0czogc2l6ZXBvdyxcbiAgICAgIHdpbmRvdzogb3B0aW9ucy53aW5kb3csXG4gICAgICBwb2x5bm9taWFsOiBvcHRpb25zLnBvbHlub21pYWxcbiAgICB9KSkge1xuICAgIHlpZWxkIGNodW5rO1xuICB9XG59XG5leHBvcnQgZGVmYXVsdCByYWJpbkNodW5rZXI7XG5hc3luYyBmdW5jdGlvbiogcmFiaW4oc291cmNlLCBvcHRpb25zKSB7XG4gIGNvbnN0IHIgPSBhd2FpdCBjcmVhdGUob3B0aW9ucy5iaXRzLCBvcHRpb25zLm1pbiwgb3B0aW9ucy5tYXgsIG9wdGlvbnMud2luZG93KTtcbiAgY29uc3QgYnVmZmVycyA9IG5ldyBCdWZmZXJMaXN0KCk7XG4gIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2Ygc291cmNlKSB7XG4gICAgYnVmZmVycy5hcHBlbmQoY2h1bmspO1xuICAgIGNvbnN0IHNpemVzID0gci5maW5nZXJwcmludChjaHVuayk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaXplcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgc2l6ZSA9IHNpemVzW2ldO1xuICAgICAgY29uc3QgYnVmID0gYnVmZmVycy5zbGljZSgwLCBzaXplKTtcbiAgICAgIGJ1ZmZlcnMuY29uc3VtZShzaXplKTtcbiAgICAgIHlpZWxkIGJ1ZjtcbiAgICB9XG4gIH1cbiAgaWYgKGJ1ZmZlcnMubGVuZ3RoKSB7XG4gICAgeWllbGQgYnVmZmVycy5zbGljZSgwKTtcbiAgfVxufSIsICJpbXBvcnQgQnVmZmVyTGlzdCBmcm9tICdibC9CdWZmZXJMaXN0LmpzJztcbmFzeW5jIGZ1bmN0aW9uKiBmaXhlZFNpemVDaHVua2VyKHNvdXJjZSwgb3B0aW9ucykge1xuICBsZXQgYmwgPSBuZXcgQnVmZmVyTGlzdCgpO1xuICBsZXQgY3VycmVudExlbmd0aCA9IDA7XG4gIGxldCBlbWl0dGVkID0gZmFsc2U7XG4gIGNvbnN0IG1heENodW5rU2l6ZSA9IG9wdGlvbnMubWF4Q2h1bmtTaXplO1xuICBmb3IgYXdhaXQgKGNvbnN0IGJ1ZmZlciBvZiBzb3VyY2UpIHtcbiAgICBibC5hcHBlbmQoYnVmZmVyKTtcbiAgICBjdXJyZW50TGVuZ3RoICs9IGJ1ZmZlci5sZW5ndGg7XG4gICAgd2hpbGUgKGN1cnJlbnRMZW5ndGggPj0gbWF4Q2h1bmtTaXplKSB7XG4gICAgICB5aWVsZCBibC5zbGljZSgwLCBtYXhDaHVua1NpemUpO1xuICAgICAgZW1pdHRlZCA9IHRydWU7XG4gICAgICBpZiAobWF4Q2h1bmtTaXplID09PSBibC5sZW5ndGgpIHtcbiAgICAgICAgYmwgPSBuZXcgQnVmZmVyTGlzdCgpO1xuICAgICAgICBjdXJyZW50TGVuZ3RoID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IG5ld0JsID0gbmV3IEJ1ZmZlckxpc3QoKTtcbiAgICAgICAgbmV3QmwuYXBwZW5kKGJsLnNoYWxsb3dTbGljZShtYXhDaHVua1NpemUpKTtcbiAgICAgICAgYmwgPSBuZXdCbDtcbiAgICAgICAgY3VycmVudExlbmd0aCAtPSBtYXhDaHVua1NpemU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICghZW1pdHRlZCB8fCBjdXJyZW50TGVuZ3RoKSB7XG4gICAgeWllbGQgYmwuc2xpY2UoMCwgY3VycmVudExlbmd0aCk7XG4gIH1cbn1cbmV4cG9ydCBkZWZhdWx0IGZpeGVkU2l6ZUNodW5rZXI7IiwgImltcG9ydCBlcnJDb2RlIGZyb20gJ2Vyci1jb2RlJztcbmltcG9ydCB7IGZyb21TdHJpbmcgYXMgdWludDhBcnJheUZyb21TdHJpbmcgfSBmcm9tICd1aW50OGFycmF5cy9mcm9tLXN0cmluZyc7XG5hc3luYyBmdW5jdGlvbiogdmFsaWRhdGVDaHVua3Moc291cmNlKSB7XG4gIGZvciBhd2FpdCAoY29uc3QgY29udGVudCBvZiBzb3VyY2UpIHtcbiAgICBpZiAoY29udGVudC5sZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgZXJyQ29kZShuZXcgRXJyb3IoJ0NvbnRlbnQgd2FzIGludmFsaWQnKSwgJ0VSUl9JTlZBTElEX0NPTlRFTlQnKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJyB8fCBjb250ZW50IGluc3RhbmNlb2YgU3RyaW5nKSB7XG4gICAgICB5aWVsZCB1aW50OEFycmF5RnJvbVN0cmluZyhjb250ZW50LnRvU3RyaW5nKCkpO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShjb250ZW50KSkge1xuICAgICAgeWllbGQgVWludDhBcnJheS5mcm9tKGNvbnRlbnQpO1xuICAgIH0gZWxzZSBpZiAoY29udGVudCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgIHlpZWxkIGNvbnRlbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGVyckNvZGUobmV3IEVycm9yKCdDb250ZW50IHdhcyBpbnZhbGlkJyksICdFUlJfSU5WQUxJRF9DT05URU5UJyk7XG4gICAgfVxuICB9XG59XG5leHBvcnQgZGVmYXVsdCB2YWxpZGF0ZUNodW5rczsiLCAiaW1wb3J0IHsgZnJvbSB9IGZyb20gJy4vYmFzZS5qcyc7XG5pbXBvcnQge1xuICBmcm9tU3RyaW5nLFxuICB0b1N0cmluZ1xufSBmcm9tICcuLi9ieXRlcy5qcyc7XG5leHBvcnQgY29uc3QgaWRlbnRpdHkgPSBmcm9tKHtcbiAgcHJlZml4OiAnXFwwJyxcbiAgbmFtZTogJ2lkZW50aXR5JyxcbiAgZW5jb2RlOiBidWYgPT4gdG9TdHJpbmcoYnVmKSxcbiAgZGVjb2RlOiBzdHIgPT4gZnJvbVN0cmluZyhzdHIpXG59KTsiLCAiaW1wb3J0IHsgcmZjNDY0OCB9IGZyb20gJy4vYmFzZS5qcyc7XG5leHBvcnQgY29uc3QgYmFzZTIgPSByZmM0NjQ4KHtcbiAgcHJlZml4OiAnMCcsXG4gIG5hbWU6ICdiYXNlMicsXG4gIGFscGhhYmV0OiAnMDEnLFxuICBiaXRzUGVyQ2hhcjogMVxufSk7IiwgImltcG9ydCB7IHJmYzQ2NDggfSBmcm9tICcuL2Jhc2UuanMnO1xuZXhwb3J0IGNvbnN0IGJhc2U4ID0gcmZjNDY0OCh7XG4gIHByZWZpeDogJzcnLFxuICBuYW1lOiAnYmFzZTgnLFxuICBhbHBoYWJldDogJzAxMjM0NTY3JyxcbiAgYml0c1BlckNoYXI6IDNcbn0pOyIsICJpbXBvcnQgeyBiYXNlWCB9IGZyb20gJy4vYmFzZS5qcyc7XG5leHBvcnQgY29uc3QgYmFzZTEwID0gYmFzZVgoe1xuICBwcmVmaXg6ICc5JyxcbiAgbmFtZTogJ2Jhc2UxMCcsXG4gIGFscGhhYmV0OiAnMDEyMzQ1Njc4OSdcbn0pOyIsICJpbXBvcnQgeyByZmM0NjQ4IH0gZnJvbSAnLi9iYXNlLmpzJztcbmV4cG9ydCBjb25zdCBiYXNlMTYgPSByZmM0NjQ4KHtcbiAgcHJlZml4OiAnZicsXG4gIG5hbWU6ICdiYXNlMTYnLFxuICBhbHBoYWJldDogJzAxMjM0NTY3ODlhYmNkZWYnLFxuICBiaXRzUGVyQ2hhcjogNFxufSk7XG5leHBvcnQgY29uc3QgYmFzZTE2dXBwZXIgPSByZmM0NjQ4KHtcbiAgcHJlZml4OiAnRicsXG4gIG5hbWU6ICdiYXNlMTZ1cHBlcicsXG4gIGFscGhhYmV0OiAnMDEyMzQ1Njc4OUFCQ0RFRicsXG4gIGJpdHNQZXJDaGFyOiA0XG59KTsiLCAiaW1wb3J0IHsgYmFzZVggfSBmcm9tICcuL2Jhc2UuanMnO1xuZXhwb3J0IGNvbnN0IGJhc2UzNiA9IGJhc2VYKHtcbiAgcHJlZml4OiAnaycsXG4gIG5hbWU6ICdiYXNlMzYnLFxuICBhbHBoYWJldDogJzAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5eidcbn0pO1xuZXhwb3J0IGNvbnN0IGJhc2UzNnVwcGVyID0gYmFzZVgoe1xuICBwcmVmaXg6ICdLJyxcbiAgbmFtZTogJ2Jhc2UzNnVwcGVyJyxcbiAgYWxwaGFiZXQ6ICcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVonXG59KTsiLCAiaW1wb3J0IHsgcmZjNDY0OCB9IGZyb20gJy4vYmFzZS5qcyc7XG5leHBvcnQgY29uc3QgYmFzZTY0ID0gcmZjNDY0OCh7XG4gIHByZWZpeDogJ20nLFxuICBuYW1lOiAnYmFzZTY0JyxcbiAgYWxwaGFiZXQ6ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJyxcbiAgYml0c1BlckNoYXI6IDZcbn0pO1xuZXhwb3J0IGNvbnN0IGJhc2U2NHBhZCA9IHJmYzQ2NDgoe1xuICBwcmVmaXg6ICdNJyxcbiAgbmFtZTogJ2Jhc2U2NHBhZCcsXG4gIGFscGhhYmV0OiAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz0nLFxuICBiaXRzUGVyQ2hhcjogNlxufSk7XG5leHBvcnQgY29uc3QgYmFzZTY0dXJsID0gcmZjNDY0OCh7XG4gIHByZWZpeDogJ3UnLFxuICBuYW1lOiAnYmFzZTY0dXJsJyxcbiAgYWxwaGFiZXQ6ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OS1fJyxcbiAgYml0c1BlckNoYXI6IDZcbn0pO1xuZXhwb3J0IGNvbnN0IGJhc2U2NHVybHBhZCA9IHJmYzQ2NDgoe1xuICBwcmVmaXg6ICdVJyxcbiAgbmFtZTogJ2Jhc2U2NHVybHBhZCcsXG4gIGFscGhhYmV0OiAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODktXz0nLFxuICBiaXRzUGVyQ2hhcjogNlxufSk7IiwgImltcG9ydCB7IGZyb20gfSBmcm9tICcuL2Jhc2UuanMnO1xuY29uc3QgYWxwaGFiZXQgPSBBcnJheS5mcm9tKCdcXHVEODNEXFx1REU4MFxcdUQ4M0VcXHVERTkwXFx1MjYwNFxcdUQ4M0RcXHVERUYwXFx1RDgzQ1xcdURGMENcXHVEODNDXFx1REYxMVxcdUQ4M0NcXHVERjEyXFx1RDgzQ1xcdURGMTNcXHVEODNDXFx1REYxNFxcdUQ4M0NcXHVERjE1XFx1RDgzQ1xcdURGMTZcXHVEODNDXFx1REYxN1xcdUQ4M0NcXHVERjE4XFx1RDgzQ1xcdURGMERcXHVEODNDXFx1REYwRlxcdUQ4M0NcXHVERjBFXFx1RDgzRFxcdURDMDlcXHUyNjAwXFx1RDgzRFxcdURDQkJcXHVEODNEXFx1RERBNVxcdUQ4M0RcXHVEQ0JFXFx1RDgzRFxcdURDQkZcXHVEODNEXFx1REUwMlxcdTI3NjRcXHVEODNEXFx1REUwRFxcdUQ4M0VcXHVERDIzXFx1RDgzRFxcdURFMEFcXHVEODNEXFx1REU0RlxcdUQ4M0RcXHVEQzk1XFx1RDgzRFxcdURFMkRcXHVEODNEXFx1REUxOFxcdUQ4M0RcXHVEQzREXFx1RDgzRFxcdURFMDVcXHVEODNEXFx1REM0RlxcdUQ4M0RcXHVERTAxXFx1RDgzRFxcdUREMjVcXHVEODNFXFx1REQ3MFxcdUQ4M0RcXHVEQzk0XFx1RDgzRFxcdURDOTZcXHVEODNEXFx1REM5OVxcdUQ4M0RcXHVERTIyXFx1RDgzRVxcdUREMTRcXHVEODNEXFx1REUwNlxcdUQ4M0RcXHVERTQ0XFx1RDgzRFxcdURDQUFcXHVEODNEXFx1REUwOVxcdTI2M0FcXHVEODNEXFx1REM0Q1xcdUQ4M0VcXHVERDE3XFx1RDgzRFxcdURDOUNcXHVEODNEXFx1REUxNFxcdUQ4M0RcXHVERTBFXFx1RDgzRFxcdURFMDdcXHVEODNDXFx1REYzOVxcdUQ4M0VcXHVERDI2XFx1RDgzQ1xcdURGODlcXHVEODNEXFx1REM5RVxcdTI3MENcXHUyNzI4XFx1RDgzRVxcdUREMzdcXHVEODNEXFx1REUzMVxcdUQ4M0RcXHVERTBDXFx1RDgzQ1xcdURGMzhcXHVEODNEXFx1REU0Q1xcdUQ4M0RcXHVERTBCXFx1RDgzRFxcdURDOTdcXHVEODNEXFx1REM5QVxcdUQ4M0RcXHVERTBGXFx1RDgzRFxcdURDOUJcXHVEODNEXFx1REU0MlxcdUQ4M0RcXHVEQzkzXFx1RDgzRVxcdUREMjlcXHVEODNEXFx1REUwNFxcdUQ4M0RcXHVERTAwXFx1RDgzRFxcdUREQTRcXHVEODNEXFx1REUwM1xcdUQ4M0RcXHVEQ0FGXFx1RDgzRFxcdURFNDhcXHVEODNEXFx1REM0N1xcdUQ4M0NcXHVERkI2XFx1RDgzRFxcdURFMTJcXHVEODNFXFx1REQyRFxcdTI3NjNcXHVEODNEXFx1REUxQ1xcdUQ4M0RcXHVEQzhCXFx1RDgzRFxcdURDNDBcXHVEODNEXFx1REUyQVxcdUQ4M0RcXHVERTExXFx1RDgzRFxcdURDQTVcXHVEODNEXFx1REU0QlxcdUQ4M0RcXHVERTFFXFx1RDgzRFxcdURFMjlcXHVEODNEXFx1REUyMVxcdUQ4M0VcXHVERDJBXFx1RDgzRFxcdURDNEFcXHVEODNFXFx1REQ3M1xcdUQ4M0RcXHVERTI1XFx1RDgzRVxcdUREMjRcXHVEODNEXFx1REM0OVxcdUQ4M0RcXHVEQzgzXFx1RDgzRFxcdURFMzNcXHUyNzBCXFx1RDgzRFxcdURFMUFcXHVEODNEXFx1REUxRFxcdUQ4M0RcXHVERTM0XFx1RDgzQ1xcdURGMUZcXHVEODNEXFx1REUyQ1xcdUQ4M0RcXHVERTQzXFx1RDgzQ1xcdURGNDBcXHVEODNDXFx1REYzN1xcdUQ4M0RcXHVERTNCXFx1RDgzRFxcdURFMTNcXHUyQjUwXFx1MjcwNVxcdUQ4M0VcXHVERDdBXFx1RDgzQ1xcdURGMDhcXHVEODNEXFx1REUwOFxcdUQ4M0VcXHVERDE4XFx1RDgzRFxcdURDQTZcXHUyNzE0XFx1RDgzRFxcdURFMjNcXHVEODNDXFx1REZDM1xcdUQ4M0RcXHVEQzkwXFx1MjYzOVxcdUQ4M0NcXHVERjhBXFx1RDgzRFxcdURDOThcXHVEODNEXFx1REUyMFxcdTI2MURcXHVEODNEXFx1REUxNVxcdUQ4M0NcXHVERjNBXFx1RDgzQ1xcdURGODJcXHVEODNDXFx1REYzQlxcdUQ4M0RcXHVERTEwXFx1RDgzRFxcdUREOTVcXHVEODNEXFx1REM5RFxcdUQ4M0RcXHVERTRBXFx1RDgzRFxcdURFMzlcXHVEODNEXFx1RERFM1xcdUQ4M0RcXHVEQ0FCXFx1RDgzRFxcdURDODBcXHVEODNEXFx1REM1MVxcdUQ4M0NcXHVERkI1XFx1RDgzRVxcdUREMUVcXHVEODNEXFx1REUxQlxcdUQ4M0RcXHVERDM0XFx1RDgzRFxcdURFMjRcXHVEODNDXFx1REYzQ1xcdUQ4M0RcXHVERTJCXFx1MjZCRFxcdUQ4M0VcXHVERDE5XFx1MjYxNVxcdUQ4M0NcXHVERkM2XFx1RDgzRVxcdUREMkJcXHVEODNEXFx1REM0OFxcdUQ4M0RcXHVERTJFXFx1RDgzRFxcdURFNDZcXHVEODNDXFx1REY3QlxcdUQ4M0NcXHVERjQzXFx1RDgzRFxcdURDMzZcXHVEODNEXFx1REM4MVxcdUQ4M0RcXHVERTMyXFx1RDgzQ1xcdURGM0ZcXHVEODNFXFx1RERFMVxcdUQ4M0NcXHVERjgxXFx1MjZBMVxcdUQ4M0NcXHVERjFFXFx1RDgzQ1xcdURGODhcXHUyNzRDXFx1MjcwQVxcdUQ4M0RcXHVEQzRCXFx1RDgzRFxcdURFMzBcXHVEODNFXFx1REQyOFxcdUQ4M0RcXHVERTM2XFx1RDgzRVxcdUREMURcXHVEODNEXFx1REVCNlxcdUQ4M0RcXHVEQ0IwXFx1RDgzQ1xcdURGNTNcXHVEODNEXFx1RENBMlxcdUQ4M0VcXHVERDFGXFx1RDgzRFxcdURFNDFcXHVEODNEXFx1REVBOFxcdUQ4M0RcXHVEQ0E4XFx1RDgzRVxcdUREMkNcXHUyNzA4XFx1RDgzQ1xcdURGODBcXHVEODNDXFx1REY3QVxcdUQ4M0VcXHVERDEzXFx1RDgzRFxcdURFMTlcXHVEODNEXFx1REM5RlxcdUQ4M0NcXHVERjMxXFx1RDgzRFxcdURFMTZcXHVEODNEXFx1REM3NlxcdUQ4M0VcXHVERDc0XFx1MjVCNlxcdTI3QTFcXHUyNzUzXFx1RDgzRFxcdURDOEVcXHVEODNEXFx1RENCOFxcdTJCMDdcXHVEODNEXFx1REUyOFxcdUQ4M0NcXHVERjFBXFx1RDgzRVxcdUREOEJcXHVEODNEXFx1REUzN1xcdUQ4M0RcXHVERDdBXFx1MjZBMFxcdUQ4M0RcXHVERTQ1XFx1RDgzRFxcdURFMUZcXHVEODNEXFx1REUzNVxcdUQ4M0RcXHVEQzRFXFx1RDgzRVxcdUREMzJcXHVEODNFXFx1REQyMFxcdUQ4M0VcXHVERDI3XFx1RDgzRFxcdURDQ0NcXHVEODNEXFx1REQzNVxcdUQ4M0RcXHVEQzg1XFx1RDgzRVxcdURERDBcXHVEODNEXFx1REMzRVxcdUQ4M0NcXHVERjUyXFx1RDgzRFxcdURFMTdcXHVEODNFXFx1REQxMVxcdUQ4M0NcXHVERjBBXFx1RDgzRVxcdUREMkZcXHVEODNEXFx1REMzN1xcdTI2MEVcXHVEODNEXFx1RENBN1xcdUQ4M0RcXHVERTJGXFx1RDgzRFxcdURDODZcXHVEODNEXFx1REM0NlxcdUQ4M0NcXHVERkE0XFx1RDgzRFxcdURFNDdcXHVEODNDXFx1REY1MVxcdTI3NDRcXHVEODNDXFx1REYzNFxcdUQ4M0RcXHVEQ0EzXFx1RDgzRFxcdURDMzhcXHVEODNEXFx1REM4Q1xcdUQ4M0RcXHVEQ0NEXFx1RDgzRVxcdURENDBcXHVEODNFXFx1REQyMlxcdUQ4M0RcXHVEQzQ1XFx1RDgzRFxcdURDQTFcXHVEODNEXFx1RENBOVxcdUQ4M0RcXHVEQzUwXFx1RDgzRFxcdURDRjhcXHVEODNEXFx1REM3QlxcdUQ4M0VcXHVERDEwXFx1RDgzRVxcdUREMkVcXHVEODNDXFx1REZCQ1xcdUQ4M0VcXHVERDc1XFx1RDgzRFxcdURFQTlcXHVEODNDXFx1REY0RVxcdUQ4M0NcXHVERjRBXFx1RDgzRFxcdURDN0NcXHVEODNEXFx1REM4RFxcdUQ4M0RcXHVEQ0UzXFx1RDgzRVxcdURENDInKTtcbmNvbnN0IGFscGhhYmV0Qnl0ZXNUb0NoYXJzID0gYWxwaGFiZXQucmVkdWNlKChwLCBjLCBpKSA9PiB7XG4gIHBbaV0gPSBjO1xuICByZXR1cm4gcDtcbn0sIFtdKTtcbmNvbnN0IGFscGhhYmV0Q2hhcnNUb0J5dGVzID0gYWxwaGFiZXQucmVkdWNlKChwLCBjLCBpKSA9PiB7XG4gIHBbYy5jb2RlUG9pbnRBdCgwKV0gPSBpO1xuICByZXR1cm4gcDtcbn0sIFtdKTtcbmZ1bmN0aW9uIGVuY29kZShkYXRhKSB7XG4gIHJldHVybiBkYXRhLnJlZHVjZSgocCwgYykgPT4ge1xuICAgIHAgKz0gYWxwaGFiZXRCeXRlc1RvQ2hhcnNbY107XG4gICAgcmV0dXJuIHA7XG4gIH0sICcnKTtcbn1cbmZ1bmN0aW9uIGRlY29kZShzdHIpIHtcbiAgY29uc3QgYnl0cyA9IFtdO1xuICBmb3IgKGNvbnN0IGNoYXIgb2Ygc3RyKSB7XG4gICAgY29uc3QgYnl0ID0gYWxwaGFiZXRDaGFyc1RvQnl0ZXNbY2hhci5jb2RlUG9pbnRBdCgwKV07XG4gICAgaWYgKGJ5dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vbi1iYXNlMjU2ZW1vamkgY2hhcmFjdGVyOiAkeyBjaGFyIH1gKTtcbiAgICB9XG4gICAgYnl0cy5wdXNoKGJ5dCk7XG4gIH1cbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ5dHMpO1xufVxuZXhwb3J0IGNvbnN0IGJhc2UyNTZlbW9qaSA9IGZyb20oe1xuICBwcmVmaXg6ICdcXHVEODNEXFx1REU4MCcsXG4gIG5hbWU6ICdiYXNlMjU2ZW1vamknLFxuICBlbmNvZGUsXG4gIGRlY29kZVxufSk7IiwgImltcG9ydCB7IGNvZXJjZSB9IGZyb20gJy4uL2J5dGVzLmpzJztcbmltcG9ydCAqIGFzIERpZ2VzdCBmcm9tICcuL2RpZ2VzdC5qcyc7XG5jb25zdCBjb2RlID0gMDtcbmNvbnN0IG5hbWUgPSAnaWRlbnRpdHknO1xuY29uc3QgZW5jb2RlID0gY29lcmNlO1xuY29uc3QgZGlnZXN0ID0gaW5wdXQgPT4gRGlnZXN0LmNyZWF0ZShjb2RlLCBlbmNvZGUoaW5wdXQpKTtcbmV4cG9ydCBjb25zdCBpZGVudGl0eSA9IHtcbiAgY29kZSxcbiAgbmFtZSxcbiAgZW5jb2RlLFxuICBkaWdlc3Rcbn07IiwgImNvbnN0IHRleHRFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG5jb25zdCB0ZXh0RGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xuZXhwb3J0IGNvbnN0IG5hbWUgPSAnanNvbic7XG5leHBvcnQgY29uc3QgY29kZSA9IDUxMjtcbmV4cG9ydCBjb25zdCBlbmNvZGUgPSBub2RlID0+IHRleHRFbmNvZGVyLmVuY29kZShKU09OLnN0cmluZ2lmeShub2RlKSk7XG5leHBvcnQgY29uc3QgZGVjb2RlID0gZGF0YSA9PiBKU09OLnBhcnNlKHRleHREZWNvZGVyLmRlY29kZShkYXRhKSk7IiwgImltcG9ydCAqIGFzIGlkZW50aXR5QmFzZSBmcm9tICcuL2Jhc2VzL2lkZW50aXR5LmpzJztcbmltcG9ydCAqIGFzIGJhc2UyIGZyb20gJy4vYmFzZXMvYmFzZTIuanMnO1xuaW1wb3J0ICogYXMgYmFzZTggZnJvbSAnLi9iYXNlcy9iYXNlOC5qcyc7XG5pbXBvcnQgKiBhcyBiYXNlMTAgZnJvbSAnLi9iYXNlcy9iYXNlMTAuanMnO1xuaW1wb3J0ICogYXMgYmFzZTE2IGZyb20gJy4vYmFzZXMvYmFzZTE2LmpzJztcbmltcG9ydCAqIGFzIGJhc2UzMiBmcm9tICcuL2Jhc2VzL2Jhc2UzMi5qcyc7XG5pbXBvcnQgKiBhcyBiYXNlMzYgZnJvbSAnLi9iYXNlcy9iYXNlMzYuanMnO1xuaW1wb3J0ICogYXMgYmFzZTU4IGZyb20gJy4vYmFzZXMvYmFzZTU4LmpzJztcbmltcG9ydCAqIGFzIGJhc2U2NCBmcm9tICcuL2Jhc2VzL2Jhc2U2NC5qcyc7XG5pbXBvcnQgKiBhcyBiYXNlMjU2ZW1vamkgZnJvbSAnLi9iYXNlcy9iYXNlMjU2ZW1vamkuanMnO1xuaW1wb3J0ICogYXMgc2hhMiBmcm9tICcuL2hhc2hlcy9zaGEyLmpzJztcbmltcG9ydCAqIGFzIGlkZW50aXR5IGZyb20gJy4vaGFzaGVzL2lkZW50aXR5LmpzJztcbmltcG9ydCAqIGFzIHJhdyBmcm9tICcuL2NvZGVjcy9yYXcuanMnO1xuaW1wb3J0ICogYXMganNvbiBmcm9tICcuL2NvZGVjcy9qc29uLmpzJztcbmltcG9ydCB7XG4gIENJRCxcbiAgaGFzaGVyLFxuICBkaWdlc3QsXG4gIHZhcmludCxcbiAgYnl0ZXNcbn0gZnJvbSAnLi9pbmRleC5qcyc7XG5jb25zdCBiYXNlcyA9IHtcbiAgLi4uaWRlbnRpdHlCYXNlLFxuICAuLi5iYXNlMixcbiAgLi4uYmFzZTgsXG4gIC4uLmJhc2UxMCxcbiAgLi4uYmFzZTE2LFxuICAuLi5iYXNlMzIsXG4gIC4uLmJhc2UzNixcbiAgLi4uYmFzZTU4LFxuICAuLi5iYXNlNjQsXG4gIC4uLmJhc2UyNTZlbW9qaVxufTtcbmNvbnN0IGhhc2hlcyA9IHtcbiAgLi4uc2hhMixcbiAgLi4uaWRlbnRpdHlcbn07XG5jb25zdCBjb2RlY3MgPSB7XG4gIHJhdyxcbiAganNvblxufTtcbmV4cG9ydCB7XG4gIENJRCxcbiAgaGFzaGVyLFxuICBkaWdlc3QsXG4gIHZhcmludCxcbiAgYnl0ZXMsXG4gIGhhc2hlcyxcbiAgYmFzZXMsXG4gIGNvZGVjc1xufTsiLCAiZXhwb3J0IGZ1bmN0aW9uIGFzVWludDhBcnJheShidWYpIHtcbiAgaWYgKGdsb2JhbFRoaXMuQnVmZmVyICE9IG51bGwpIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnVmLmJ1ZmZlciwgYnVmLmJ5dGVPZmZzZXQsIGJ1Zi5ieXRlTGVuZ3RoKTtcbiAgfVxuICByZXR1cm4gYnVmO1xufSIsICJpbXBvcnQgeyBhc1VpbnQ4QXJyYXkgfSBmcm9tICcuL3V0aWwvYXMtdWludDhhcnJheS5qcyc7XG5leHBvcnQgZnVuY3Rpb24gYWxsb2Moc2l6ZSA9IDApIHtcbiAgaWYgKGdsb2JhbFRoaXMuQnVmZmVyICE9IG51bGwgJiYgZ2xvYmFsVGhpcy5CdWZmZXIuYWxsb2MgIT0gbnVsbCkge1xuICAgIHJldHVybiBhc1VpbnQ4QXJyYXkoZ2xvYmFsVGhpcy5CdWZmZXIuYWxsb2Moc2l6ZSkpO1xuICB9XG4gIHJldHVybiBuZXcgVWludDhBcnJheShzaXplKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBhbGxvY1Vuc2FmZShzaXplID0gMCkge1xuICBpZiAoZ2xvYmFsVGhpcy5CdWZmZXIgIT0gbnVsbCAmJiBnbG9iYWxUaGlzLkJ1ZmZlci5hbGxvY1Vuc2FmZSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIGFzVWludDhBcnJheShnbG9iYWxUaGlzLkJ1ZmZlci5hbGxvY1Vuc2FmZShzaXplKSk7XG4gIH1cbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHNpemUpO1xufSIsICJpbXBvcnQgeyBiYXNlcyB9IGZyb20gJ211bHRpZm9ybWF0cy9iYXNpY3MnO1xuaW1wb3J0IHsgYWxsb2NVbnNhZmUgfSBmcm9tICcuLi9hbGxvYy5qcyc7XG5mdW5jdGlvbiBjcmVhdGVDb2RlYyhuYW1lLCBwcmVmaXgsIGVuY29kZSwgZGVjb2RlKSB7XG4gIHJldHVybiB7XG4gICAgbmFtZSxcbiAgICBwcmVmaXgsXG4gICAgZW5jb2Rlcjoge1xuICAgICAgbmFtZSxcbiAgICAgIHByZWZpeCxcbiAgICAgIGVuY29kZVxuICAgIH0sXG4gICAgZGVjb2RlcjogeyBkZWNvZGUgfVxuICB9O1xufVxuY29uc3Qgc3RyaW5nID0gY3JlYXRlQ29kZWMoJ3V0ZjgnLCAndScsIGJ1ZiA9PiB7XG4gIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoJ3V0ZjgnKTtcbiAgcmV0dXJuICd1JyArIGRlY29kZXIuZGVjb2RlKGJ1Zik7XG59LCBzdHIgPT4ge1xuICBjb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gIHJldHVybiBlbmNvZGVyLmVuY29kZShzdHIuc3Vic3RyaW5nKDEpKTtcbn0pO1xuY29uc3QgYXNjaWkgPSBjcmVhdGVDb2RlYygnYXNjaWknLCAnYScsIGJ1ZiA9PiB7XG4gIGxldCBzdHJpbmcgPSAnYSc7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmLmxlbmd0aDsgaSsrKSB7XG4gICAgc3RyaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKTtcbiAgfVxuICByZXR1cm4gc3RyaW5nO1xufSwgc3RyID0+IHtcbiAgc3RyID0gc3RyLnN1YnN0cmluZygxKTtcbiAgY29uc3QgYnVmID0gYWxsb2NVbnNhZmUoc3RyLmxlbmd0aCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgYnVmW2ldID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gIH1cbiAgcmV0dXJuIGJ1Zjtcbn0pO1xuY29uc3QgQkFTRVMgPSB7XG4gIHV0Zjg6IHN0cmluZyxcbiAgJ3V0Zi04Jzogc3RyaW5nLFxuICBoZXg6IGJhc2VzLmJhc2UxNixcbiAgbGF0aW4xOiBhc2NpaSxcbiAgYXNjaWk6IGFzY2lpLFxuICBiaW5hcnk6IGFzY2lpLFxuICAuLi5iYXNlc1xufTtcbmV4cG9ydCBkZWZhdWx0IEJBU0VTOyIsICJpbXBvcnQgYmFzZXMgZnJvbSAnLi91dGlsL2Jhc2VzLmpzJztcbmltcG9ydCB7IGFzVWludDhBcnJheSB9IGZyb20gJy4vdXRpbC9hcy11aW50OGFycmF5LmpzJztcbmV4cG9ydCBmdW5jdGlvbiBmcm9tU3RyaW5nKHN0cmluZywgZW5jb2RpbmcgPSAndXRmOCcpIHtcbiAgY29uc3QgYmFzZSA9IGJhc2VzW2VuY29kaW5nXTtcbiAgaWYgKCFiYXNlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBlbmNvZGluZyBcIiR7IGVuY29kaW5nIH1cImApO1xuICB9XG4gIGlmICgoZW5jb2RpbmcgPT09ICd1dGY4JyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi04JykgJiYgZ2xvYmFsVGhpcy5CdWZmZXIgIT0gbnVsbCAmJiBnbG9iYWxUaGlzLkJ1ZmZlci5mcm9tICE9IG51bGwpIHtcbiAgICByZXR1cm4gYXNVaW50OEFycmF5KGdsb2JhbFRoaXMuQnVmZmVyLmZyb20oc3RyaW5nLCAndXRmLTgnKSk7XG4gIH1cbiAgcmV0dXJuIGJhc2UuZGVjb2Rlci5kZWNvZGUoYCR7IGJhc2UucHJlZml4IH0keyBzdHJpbmcgfWApO1xufSIsICJjbGFzcyBEaXIge1xuICBjb25zdHJ1Y3Rvcihwcm9wcywgb3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdGhpcy5yb290ID0gcHJvcHMucm9vdDtcbiAgICB0aGlzLmRpciA9IHByb3BzLmRpcjtcbiAgICB0aGlzLnBhdGggPSBwcm9wcy5wYXRoO1xuICAgIHRoaXMuZGlydHkgPSBwcm9wcy5kaXJ0eTtcbiAgICB0aGlzLmZsYXQgPSBwcm9wcy5mbGF0O1xuICAgIHRoaXMucGFyZW50ID0gcHJvcHMucGFyZW50O1xuICAgIHRoaXMucGFyZW50S2V5ID0gcHJvcHMucGFyZW50S2V5O1xuICAgIHRoaXMudW5peGZzID0gcHJvcHMudW5peGZzO1xuICAgIHRoaXMubW9kZSA9IHByb3BzLm1vZGU7XG4gICAgdGhpcy5tdGltZSA9IHByb3BzLm10aW1lO1xuICAgIHRoaXMuY2lkID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuc2l6ZSA9IHVuZGVmaW5lZDtcbiAgfVxuICBhc3luYyBwdXQobmFtZSwgdmFsdWUpIHtcbiAgfVxuICBnZXQobmFtZSkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcyk7XG4gIH1cbiAgYXN5bmMgKmVhY2hDaGlsZFNlcmllcygpIHtcbiAgfVxuICBhc3luYyAqZmx1c2goYmxvY2tzdG9yZSkge1xuICB9XG59XG5leHBvcnQgZGVmYXVsdCBEaXI7IiwgImltcG9ydCB7XG4gIGVuY29kZSxcbiAgcHJlcGFyZVxufSBmcm9tICdAaXBsZC9kYWctcGInO1xuaW1wb3J0IHsgVW5peEZTIH0gZnJvbSAnaXBmcy11bml4ZnMnO1xuaW1wb3J0IERpciBmcm9tICcuL2Rpci5qcyc7XG5pbXBvcnQgcGVyc2lzdCBmcm9tICcuL3V0aWxzL3BlcnNpc3QuanMnO1xuY2xhc3MgRGlyRmxhdCBleHRlbmRzIERpciB7XG4gIGNvbnN0cnVjdG9yKHByb3BzLCBvcHRpb25zKSB7XG4gICAgc3VwZXIocHJvcHMsIG9wdGlvbnMpO1xuICAgIHRoaXMuX2NoaWxkcmVuID0ge307XG4gIH1cbiAgYXN5bmMgcHV0KG5hbWUsIHZhbHVlKSB7XG4gICAgdGhpcy5jaWQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5zaXplID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2NoaWxkcmVuW25hbWVdID0gdmFsdWU7XG4gIH1cbiAgZ2V0KG5hbWUpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2NoaWxkcmVuW25hbWVdKTtcbiAgfVxuICBjaGlsZENvdW50KCkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLl9jaGlsZHJlbikubGVuZ3RoO1xuICB9XG4gIGRpcmVjdENoaWxkcmVuQ291bnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hpbGRDb3VudCgpO1xuICB9XG4gIG9ubHlDaGlsZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2hpbGRyZW5bT2JqZWN0LmtleXModGhpcy5fY2hpbGRyZW4pWzBdXTtcbiAgfVxuICBhc3luYyAqZWFjaENoaWxkU2VyaWVzKCkge1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh0aGlzLl9jaGlsZHJlbik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgICAgeWllbGQge1xuICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgY2hpbGQ6IHRoaXMuX2NoaWxkcmVuW2tleV1cbiAgICAgIH07XG4gICAgfVxuICB9XG4gIGFzeW5jICpmbHVzaChibG9jaykge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gT2JqZWN0LmtleXModGhpcy5fY2hpbGRyZW4pO1xuICAgIGNvbnN0IGxpbmtzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IGNoaWxkID0gdGhpcy5fY2hpbGRyZW5bY2hpbGRyZW5baV1dO1xuICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgRGlyKSB7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgZW50cnkgb2YgY2hpbGQuZmx1c2goYmxvY2spKSB7XG4gICAgICAgICAgY2hpbGQgPSBlbnRyeTtcbiAgICAgICAgICB5aWVsZCBjaGlsZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNoaWxkLnNpemUgIT0gbnVsbCAmJiBjaGlsZC5jaWQpIHtcbiAgICAgICAgbGlua3MucHVzaCh7XG4gICAgICAgICAgTmFtZTogY2hpbGRyZW5baV0sXG4gICAgICAgICAgVHNpemU6IGNoaWxkLnNpemUsXG4gICAgICAgICAgSGFzaDogY2hpbGQuY2lkXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB1bml4ZnMgPSBuZXcgVW5peEZTKHtcbiAgICAgIHR5cGU6ICdkaXJlY3RvcnknLFxuICAgICAgbXRpbWU6IHRoaXMubXRpbWUsXG4gICAgICBtb2RlOiB0aGlzLm1vZGVcbiAgICB9KTtcbiAgICBjb25zdCBub2RlID0ge1xuICAgICAgRGF0YTogdW5peGZzLm1hcnNoYWwoKSxcbiAgICAgIExpbmtzOiBsaW5rc1xuICAgIH07XG4gICAgY29uc3QgYnVmZmVyID0gZW5jb2RlKHByZXBhcmUobm9kZSkpO1xuICAgIGNvbnN0IGNpZCA9IGF3YWl0IHBlcnNpc3QoYnVmZmVyLCBibG9jaywgdGhpcy5vcHRpb25zKTtcbiAgICBjb25zdCBzaXplID0gYnVmZmVyLmxlbmd0aCArIG5vZGUuTGlua3MucmVkdWNlKChhY2MsIGN1cnIpID0+IGFjYyArIChjdXJyLlRzaXplID09IG51bGwgPyAwIDogY3Vyci5Uc2l6ZSksIDApO1xuICAgIHRoaXMuY2lkID0gY2lkO1xuICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gICAgeWllbGQge1xuICAgICAgY2lkLFxuICAgICAgdW5peGZzLFxuICAgICAgcGF0aDogdGhpcy5wYXRoLFxuICAgICAgc2l6ZVxuICAgIH07XG4gIH1cbn1cbmV4cG9ydCBkZWZhdWx0IERpckZsYXQ7IiwgImltcG9ydCB7XG4gIGVuY29kZSxcbiAgcHJlcGFyZVxufSBmcm9tICdAaXBsZC9kYWctcGInO1xuaW1wb3J0IHsgVW5peEZTIH0gZnJvbSAnaXBmcy11bml4ZnMnO1xuaW1wb3J0IERpciBmcm9tICcuL2Rpci5qcyc7XG5pbXBvcnQgcGVyc2lzdCBmcm9tICcuL3V0aWxzL3BlcnNpc3QuanMnO1xuaW1wb3J0IHtcbiAgY3JlYXRlSEFNVCxcbiAgQnVja2V0XG59IGZyb20gJ2hhbXQtc2hhcmRpbmcnO1xuY2xhc3MgRGlyU2hhcmRlZCBleHRlbmRzIERpciB7XG4gIGNvbnN0cnVjdG9yKHByb3BzLCBvcHRpb25zKSB7XG4gICAgc3VwZXIocHJvcHMsIG9wdGlvbnMpO1xuICAgIHRoaXMuX2J1Y2tldCA9IGNyZWF0ZUhBTVQoe1xuICAgICAgaGFzaEZuOiBvcHRpb25zLmhhbXRIYXNoRm4sXG4gICAgICBiaXRzOiBvcHRpb25zLmhhbXRCdWNrZXRCaXRzXG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgcHV0KG5hbWUsIHZhbHVlKSB7XG4gICAgYXdhaXQgdGhpcy5fYnVja2V0LnB1dChuYW1lLCB2YWx1ZSk7XG4gIH1cbiAgZ2V0KG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5fYnVja2V0LmdldChuYW1lKTtcbiAgfVxuICBjaGlsZENvdW50KCkge1xuICAgIHJldHVybiB0aGlzLl9idWNrZXQubGVhZkNvdW50KCk7XG4gIH1cbiAgZGlyZWN0Q2hpbGRyZW5Db3VudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fYnVja2V0LmNoaWxkcmVuQ291bnQoKTtcbiAgfVxuICBvbmx5Q2hpbGQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2J1Y2tldC5vbmx5Q2hpbGQoKTtcbiAgfVxuICBhc3luYyAqZWFjaENoaWxkU2VyaWVzKCkge1xuICAgIGZvciBhd2FpdCAoY29uc3Qge2tleSwgdmFsdWV9IG9mIHRoaXMuX2J1Y2tldC5lYWNoTGVhZlNlcmllcygpKSB7XG4gICAgICB5aWVsZCB7XG4gICAgICAgIGtleSxcbiAgICAgICAgY2hpbGQ6IHZhbHVlXG4gICAgICB9O1xuICAgIH1cbiAgfVxuICBhc3luYyAqZmx1c2goYmxvY2tzdG9yZSkge1xuICAgIGZvciBhd2FpdCAoY29uc3QgZW50cnkgb2YgZmx1c2godGhpcy5fYnVja2V0LCBibG9ja3N0b3JlLCB0aGlzLCB0aGlzLm9wdGlvbnMpKSB7XG4gICAgICB5aWVsZCB7XG4gICAgICAgIC4uLmVudHJ5LFxuICAgICAgICBwYXRoOiB0aGlzLnBhdGhcbiAgICAgIH07XG4gICAgfVxuICB9XG59XG5leHBvcnQgZGVmYXVsdCBEaXJTaGFyZGVkO1xuYXN5bmMgZnVuY3Rpb24qIGZsdXNoKGJ1Y2tldCwgYmxvY2tzdG9yZSwgc2hhcmRSb290LCBvcHRpb25zKSB7XG4gIGNvbnN0IGNoaWxkcmVuID0gYnVja2V0Ll9jaGlsZHJlbjtcbiAgY29uc3QgbGlua3MgPSBbXTtcbiAgbGV0IGNoaWxkcmVuU2l6ZSA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuLmdldChpKTtcbiAgICBpZiAoIWNoaWxkKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgbGFiZWxQcmVmaXggPSBpLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpLnBhZFN0YXJ0KDIsICcwJyk7XG4gICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgQnVja2V0KSB7XG4gICAgICBsZXQgc2hhcmQ7XG4gICAgICBmb3IgYXdhaXQgKGNvbnN0IHN1YlNoYXJkIG9mIGF3YWl0IGZsdXNoKGNoaWxkLCBibG9ja3N0b3JlLCBudWxsLCBvcHRpb25zKSkge1xuICAgICAgICBzaGFyZCA9IHN1YlNoYXJkO1xuICAgICAgfVxuICAgICAgaWYgKCFzaGFyZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBmbHVzaCBzaGFyZGVkIGRpcmVjdG9yeSwgbm8gc3Vic2hhcmQgZm91bmQnKTtcbiAgICAgIH1cbiAgICAgIGxpbmtzLnB1c2goe1xuICAgICAgICBOYW1lOiBsYWJlbFByZWZpeCxcbiAgICAgICAgVHNpemU6IHNoYXJkLnNpemUsXG4gICAgICAgIEhhc2g6IHNoYXJkLmNpZFxuICAgICAgfSk7XG4gICAgICBjaGlsZHJlblNpemUgKz0gc2hhcmQuc2l6ZTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBjaGlsZC52YWx1ZS5mbHVzaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29uc3QgZGlyID0gY2hpbGQudmFsdWU7XG4gICAgICBsZXQgZmx1c2hlZERpcjtcbiAgICAgIGZvciBhd2FpdCAoY29uc3QgZW50cnkgb2YgZGlyLmZsdXNoKGJsb2Nrc3RvcmUpKSB7XG4gICAgICAgIGZsdXNoZWREaXIgPSBlbnRyeTtcbiAgICAgICAgeWllbGQgZmx1c2hlZERpcjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxhYmVsID0gbGFiZWxQcmVmaXggKyBjaGlsZC5rZXk7XG4gICAgICBsaW5rcy5wdXNoKHtcbiAgICAgICAgTmFtZTogbGFiZWwsXG4gICAgICAgIFRzaXplOiBmbHVzaGVkRGlyLnNpemUsXG4gICAgICAgIEhhc2g6IGZsdXNoZWREaXIuY2lkXG4gICAgICB9KTtcbiAgICAgIGNoaWxkcmVuU2l6ZSArPSBmbHVzaGVkRGlyLnNpemU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gY2hpbGQudmFsdWU7XG4gICAgICBpZiAoIXZhbHVlLmNpZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxhYmVsID0gbGFiZWxQcmVmaXggKyBjaGlsZC5rZXk7XG4gICAgICBjb25zdCBzaXplID0gdmFsdWUuc2l6ZTtcbiAgICAgIGxpbmtzLnB1c2goe1xuICAgICAgICBOYW1lOiBsYWJlbCxcbiAgICAgICAgVHNpemU6IHNpemUsXG4gICAgICAgIEhhc2g6IHZhbHVlLmNpZFxuICAgICAgfSk7XG4gICAgICBjaGlsZHJlblNpemUgKz0gc2l6ZTtcbiAgICB9XG4gIH1cbiAgY29uc3QgZGF0YSA9IFVpbnQ4QXJyYXkuZnJvbShjaGlsZHJlbi5iaXRGaWVsZCgpLnJldmVyc2UoKSk7XG4gIGNvbnN0IGRpciA9IG5ldyBVbml4RlMoe1xuICAgIHR5cGU6ICdoYW10LXNoYXJkZWQtZGlyZWN0b3J5JyxcbiAgICBkYXRhLFxuICAgIGZhbm91dDogYnVja2V0LnRhYmxlU2l6ZSgpLFxuICAgIGhhc2hUeXBlOiBvcHRpb25zLmhhbXRIYXNoQ29kZSxcbiAgICBtdGltZTogc2hhcmRSb290ICYmIHNoYXJkUm9vdC5tdGltZSxcbiAgICBtb2RlOiBzaGFyZFJvb3QgJiYgc2hhcmRSb290Lm1vZGVcbiAgfSk7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgRGF0YTogZGlyLm1hcnNoYWwoKSxcbiAgICBMaW5rczogbGlua3NcbiAgfTtcbiAgY29uc3QgYnVmZmVyID0gZW5jb2RlKHByZXBhcmUobm9kZSkpO1xuICBjb25zdCBjaWQgPSBhd2FpdCBwZXJzaXN0KGJ1ZmZlciwgYmxvY2tzdG9yZSwgb3B0aW9ucyk7XG4gIGNvbnN0IHNpemUgPSBidWZmZXIubGVuZ3RoICsgY2hpbGRyZW5TaXplO1xuICB5aWVsZCB7XG4gICAgY2lkLFxuICAgIHVuaXhmczogZGlyLFxuICAgIHNpemVcbiAgfTtcbn0iLCAiaW1wb3J0IERpclNoYXJkZWQgZnJvbSAnLi9kaXItc2hhcmRlZC5qcyc7XG5pbXBvcnQgRGlyRmxhdCBmcm9tICcuL2Rpci1mbGF0LmpzJztcbmFzeW5jIGZ1bmN0aW9uIGZsYXRUb1NoYXJkKGNoaWxkLCBkaXIsIHRocmVzaG9sZCwgb3B0aW9ucykge1xuICBsZXQgbmV3RGlyID0gZGlyO1xuICBpZiAoZGlyIGluc3RhbmNlb2YgRGlyRmxhdCAmJiBkaXIuZGlyZWN0Q2hpbGRyZW5Db3VudCgpID49IHRocmVzaG9sZCkge1xuICAgIG5ld0RpciA9IGF3YWl0IGNvbnZlcnRUb1NoYXJkKGRpciwgb3B0aW9ucyk7XG4gIH1cbiAgY29uc3QgcGFyZW50ID0gbmV3RGlyLnBhcmVudDtcbiAgaWYgKHBhcmVudCkge1xuICAgIGlmIChuZXdEaXIgIT09IGRpcikge1xuICAgICAgaWYgKGNoaWxkKSB7XG4gICAgICAgIGNoaWxkLnBhcmVudCA9IG5ld0RpcjtcbiAgICAgIH1cbiAgICAgIGlmICghbmV3RGlyLnBhcmVudEtleSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHBhcmVudCBrZXkgZm91bmQnKTtcbiAgICAgIH1cbiAgICAgIGF3YWl0IHBhcmVudC5wdXQobmV3RGlyLnBhcmVudEtleSwgbmV3RGlyKTtcbiAgICB9XG4gICAgcmV0dXJuIGZsYXRUb1NoYXJkKG5ld0RpciwgcGFyZW50LCB0aHJlc2hvbGQsIG9wdGlvbnMpO1xuICB9XG4gIHJldHVybiBuZXdEaXI7XG59XG5hc3luYyBmdW5jdGlvbiBjb252ZXJ0VG9TaGFyZChvbGREaXIsIG9wdGlvbnMpIHtcbiAgY29uc3QgbmV3RGlyID0gbmV3IERpclNoYXJkZWQoe1xuICAgIHJvb3Q6IG9sZERpci5yb290LFxuICAgIGRpcjogdHJ1ZSxcbiAgICBwYXJlbnQ6IG9sZERpci5wYXJlbnQsXG4gICAgcGFyZW50S2V5OiBvbGREaXIucGFyZW50S2V5LFxuICAgIHBhdGg6IG9sZERpci5wYXRoLFxuICAgIGRpcnR5OiBvbGREaXIuZGlydHksXG4gICAgZmxhdDogZmFsc2UsXG4gICAgbXRpbWU6IG9sZERpci5tdGltZSxcbiAgICBtb2RlOiBvbGREaXIubW9kZVxuICB9LCBvcHRpb25zKTtcbiAgZm9yIGF3YWl0IChjb25zdCB7a2V5LCBjaGlsZH0gb2Ygb2xkRGlyLmVhY2hDaGlsZFNlcmllcygpKSB7XG4gICAgYXdhaXQgbmV3RGlyLnB1dChrZXksIGNoaWxkKTtcbiAgfVxuICByZXR1cm4gbmV3RGlyO1xufVxuZXhwb3J0IGRlZmF1bHQgZmxhdFRvU2hhcmQ7IiwgImNvbnN0IHRvUGF0aENvbXBvbmVudHMgPSAocGF0aCA9ICcnKSA9PiB7XG4gIHJldHVybiAocGF0aC50cmltKCkubWF0Y2goLyhbXlxcXFwvXXxcXFxcXFwvKSsvZykgfHwgW10pLmZpbHRlcihCb29sZWFuKTtcbn07XG5leHBvcnQgZGVmYXVsdCB0b1BhdGhDb21wb25lbnRzOyIsICJpbXBvcnQgRGlyRmxhdCBmcm9tICcuL2Rpci1mbGF0LmpzJztcbmltcG9ydCBmbGF0VG9TaGFyZCBmcm9tICcuL2ZsYXQtdG8tc2hhcmQuanMnO1xuaW1wb3J0IERpciBmcm9tICcuL2Rpci5qcyc7XG5pbXBvcnQgdG9QYXRoQ29tcG9uZW50cyBmcm9tICcuL3V0aWxzL3RvLXBhdGgtY29tcG9uZW50cy5qcyc7XG5hc3luYyBmdW5jdGlvbiBhZGRUb1RyZWUoZWxlbSwgdHJlZSwgb3B0aW9ucykge1xuICBjb25zdCBwYXRoRWxlbXMgPSB0b1BhdGhDb21wb25lbnRzKGVsZW0ucGF0aCB8fCAnJyk7XG4gIGNvbnN0IGxhc3RJbmRleCA9IHBhdGhFbGVtcy5sZW5ndGggLSAxO1xuICBsZXQgcGFyZW50ID0gdHJlZTtcbiAgbGV0IGN1cnJlbnRQYXRoID0gJyc7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aEVsZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgcGF0aEVsZW0gPSBwYXRoRWxlbXNbaV07XG4gICAgY3VycmVudFBhdGggKz0gYCR7IGN1cnJlbnRQYXRoID8gJy8nIDogJycgfSR7IHBhdGhFbGVtIH1gO1xuICAgIGNvbnN0IGxhc3QgPSBpID09PSBsYXN0SW5kZXg7XG4gICAgcGFyZW50LmRpcnR5ID0gdHJ1ZTtcbiAgICBwYXJlbnQuY2lkID0gdW5kZWZpbmVkO1xuICAgIHBhcmVudC5zaXplID0gdW5kZWZpbmVkO1xuICAgIGlmIChsYXN0KSB7XG4gICAgICBhd2FpdCBwYXJlbnQucHV0KHBhdGhFbGVtLCBlbGVtKTtcbiAgICAgIHRyZWUgPSBhd2FpdCBmbGF0VG9TaGFyZChudWxsLCBwYXJlbnQsIG9wdGlvbnMuc2hhcmRTcGxpdFRocmVzaG9sZCwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBkaXIgPSBhd2FpdCBwYXJlbnQuZ2V0KHBhdGhFbGVtKTtcbiAgICAgIGlmICghZGlyIHx8ICEoZGlyIGluc3RhbmNlb2YgRGlyKSkge1xuICAgICAgICBkaXIgPSBuZXcgRGlyRmxhdCh7XG4gICAgICAgICAgcm9vdDogZmFsc2UsXG4gICAgICAgICAgZGlyOiB0cnVlLFxuICAgICAgICAgIHBhcmVudDogcGFyZW50LFxuICAgICAgICAgIHBhcmVudEtleTogcGF0aEVsZW0sXG4gICAgICAgICAgcGF0aDogY3VycmVudFBhdGgsXG4gICAgICAgICAgZGlydHk6IHRydWUsXG4gICAgICAgICAgZmxhdDogdHJ1ZSxcbiAgICAgICAgICBtdGltZTogZGlyICYmIGRpci51bml4ZnMgJiYgZGlyLnVuaXhmcy5tdGltZSxcbiAgICAgICAgICBtb2RlOiBkaXIgJiYgZGlyLnVuaXhmcyAmJiBkaXIudW5peGZzLm1vZGVcbiAgICAgICAgfSwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBhd2FpdCBwYXJlbnQucHV0KHBhdGhFbGVtLCBkaXIpO1xuICAgICAgcGFyZW50ID0gZGlyO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJlZTtcbn1cbmFzeW5jIGZ1bmN0aW9uKiBmbHVzaEFuZFlpZWxkKHRyZWUsIGJsb2Nrc3RvcmUpIHtcbiAgaWYgKCEodHJlZSBpbnN0YW5jZW9mIERpcikpIHtcbiAgICBpZiAodHJlZSAmJiB0cmVlLnVuaXhmcyAmJiB0cmVlLnVuaXhmcy5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICB5aWVsZCB0cmVlO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbiAgeWllbGQqIHRyZWUuZmx1c2goYmxvY2tzdG9yZSk7XG59XG5hc3luYyBmdW5jdGlvbiogdHJlZUJ1aWxkZXIoc291cmNlLCBibG9jaywgb3B0aW9ucykge1xuICBsZXQgdHJlZSA9IG5ldyBEaXJGbGF0KHtcbiAgICByb290OiB0cnVlLFxuICAgIGRpcjogdHJ1ZSxcbiAgICBwYXRoOiAnJyxcbiAgICBkaXJ0eTogdHJ1ZSxcbiAgICBmbGF0OiB0cnVlXG4gIH0sIG9wdGlvbnMpO1xuICBmb3IgYXdhaXQgKGNvbnN0IGVudHJ5IG9mIHNvdXJjZSkge1xuICAgIGlmICghZW50cnkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB0cmVlID0gYXdhaXQgYWRkVG9UcmVlKGVudHJ5LCB0cmVlLCBvcHRpb25zKTtcbiAgICBpZiAoIWVudHJ5LnVuaXhmcyB8fCAhZW50cnkudW5peGZzLmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgIHlpZWxkIGVudHJ5O1xuICAgIH1cbiAgfVxuICBpZiAob3B0aW9ucy53cmFwV2l0aERpcmVjdG9yeSkge1xuICAgIHlpZWxkKiBmbHVzaEFuZFlpZWxkKHRyZWUsIGJsb2NrKTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IHVud3JhcHBlZCBvZiB0cmVlLmVhY2hDaGlsZFNlcmllcygpKSB7XG4gICAgICBpZiAoIXVud3JhcHBlZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHlpZWxkKiBmbHVzaEFuZFlpZWxkKHVud3JhcHBlZC5jaGlsZCwgYmxvY2spO1xuICAgIH1cbiAgfVxufVxuZXhwb3J0IGRlZmF1bHQgdHJlZUJ1aWxkZXI7IiwgImltcG9ydCBlcnJDb2RlIGZyb20gJ2Vyci1jb2RlJztcbmltcG9ydCB7IGZyb21TdHJpbmcgYXMgdWludDhBcnJheUZyb21TdHJpbmcgfSBmcm9tICd1aW50OGFycmF5cy9mcm9tLXN0cmluZyc7XG5pbXBvcnQgYnJvd3NlclN0cmVhbVRvSXQgZnJvbSAnYnJvd3Nlci1yZWFkYWJsZXN0cmVhbS10by1pdCc7XG5pbXBvcnQgYmxvYlRvSXQgZnJvbSAnYmxvYi10by1pdCc7XG5pbXBvcnQgaXRQZWVrYWJsZSBmcm9tICdpdC1wZWVrYWJsZSc7XG5pbXBvcnQgYWxsIGZyb20gJ2l0LWFsbCc7XG5pbXBvcnQgbWFwIGZyb20gJ2l0LW1hcCc7XG5pbXBvcnQge1xuICBpc0J5dGVzLFxuICBpc1JlYWRhYmxlU3RyZWFtLFxuICBpc0Jsb2Jcbn0gZnJvbSAnLi91dGlscy5qcyc7XG5hc3luYyBmdW5jdGlvbiogdG9Bc3luY0l0ZXJhYmxlKHRoaW5nKSB7XG4gIHlpZWxkIHRoaW5nO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIG5vcm1hbGlzZUNvbnRlbnQoaW5wdXQpIHtcbiAgaWYgKGlzQnl0ZXMoaW5wdXQpKSB7XG4gICAgcmV0dXJuIHRvQXN5bmNJdGVyYWJsZSh0b0J5dGVzKGlucHV0KSk7XG4gIH1cbiAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycgfHwgaW5wdXQgaW5zdGFuY2VvZiBTdHJpbmcpIHtcbiAgICByZXR1cm4gdG9Bc3luY0l0ZXJhYmxlKHRvQnl0ZXMoaW5wdXQudG9TdHJpbmcoKSkpO1xuICB9XG4gIGlmIChpc0Jsb2IoaW5wdXQpKSB7XG4gICAgcmV0dXJuIGJsb2JUb0l0KGlucHV0KTtcbiAgfVxuICBpZiAoaXNSZWFkYWJsZVN0cmVhbShpbnB1dCkpIHtcbiAgICBpbnB1dCA9IGJyb3dzZXJTdHJlYW1Ub0l0KGlucHV0KTtcbiAgfVxuICBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIGlucHV0IHx8IFN5bWJvbC5hc3luY0l0ZXJhdG9yIGluIGlucHV0KSB7XG4gICAgY29uc3QgcGVla2FibGUgPSBpdFBlZWthYmxlKGlucHV0KTtcbiAgICBjb25zdCB7dmFsdWUsIGRvbmV9ID0gYXdhaXQgcGVla2FibGUucGVlaygpO1xuICAgIGlmIChkb25lKSB7XG4gICAgICByZXR1cm4gdG9Bc3luY0l0ZXJhYmxlKG5ldyBVaW50OEFycmF5KDApKTtcbiAgICB9XG4gICAgcGVla2FibGUucHVzaCh2YWx1ZSk7XG4gICAgaWYgKE51bWJlci5pc0ludGVnZXIodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdG9Bc3luY0l0ZXJhYmxlKFVpbnQ4QXJyYXkuZnJvbShhd2FpdCBhbGwocGVla2FibGUpKSk7XG4gICAgfVxuICAgIGlmIChpc0J5dGVzKHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8IHZhbHVlIGluc3RhbmNlb2YgU3RyaW5nKSB7XG4gICAgICByZXR1cm4gbWFwKHBlZWthYmxlLCB0b0J5dGVzKTtcbiAgICB9XG4gIH1cbiAgdGhyb3cgZXJyQ29kZShuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgaW5wdXQ6ICR7IGlucHV0IH1gKSwgJ0VSUl9VTkVYUEVDVEVEX0lOUFVUJyk7XG59XG5mdW5jdGlvbiB0b0J5dGVzKGNodW5rKSB7XG4gIGlmIChjaHVuayBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICByZXR1cm4gY2h1bms7XG4gIH1cbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhjaHVuaykpIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoY2h1bmsuYnVmZmVyLCBjaHVuay5ieXRlT2Zmc2V0LCBjaHVuay5ieXRlTGVuZ3RoKTtcbiAgfVxuICBpZiAoY2h1bmsgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShjaHVuayk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkoY2h1bmspKSB7XG4gICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShjaHVuayk7XG4gIH1cbiAgcmV0dXJuIHVpbnQ4QXJyYXlGcm9tU3RyaW5nKGNodW5rLnRvU3RyaW5nKCkpO1xufSIsICJleHBvcnQgZnVuY3Rpb24gaXNCeXRlcyhvYmopIHtcbiAgcmV0dXJuIEFycmF5QnVmZmVyLmlzVmlldyhvYmopIHx8IG9iaiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzQmxvYihvYmopIHtcbiAgcmV0dXJuIG9iai5jb25zdHJ1Y3RvciAmJiAob2JqLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdCbG9iJyB8fCBvYmouY29uc3RydWN0b3IubmFtZSA9PT0gJ0ZpbGUnKSAmJiB0eXBlb2Ygb2JqLnN0cmVhbSA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0ZpbGVPYmplY3Qob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiAob2JqLnBhdGggfHwgb2JqLmNvbnRlbnQpO1xufVxuZXhwb3J0IGNvbnN0IGlzUmVhZGFibGVTdHJlYW0gPSB2YWx1ZSA9PiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUuZ2V0UmVhZGVyID09PSAnZnVuY3Rpb24nOyIsICJpbXBvcnQgZXJyQ29kZSBmcm9tICdlcnItY29kZSc7XG5pbXBvcnQgYnJvd3NlclN0cmVhbVRvSXQgZnJvbSAnYnJvd3Nlci1yZWFkYWJsZXN0cmVhbS10by1pdCc7XG5pbXBvcnQgaXRQZWVrYWJsZSBmcm9tICdpdC1wZWVrYWJsZSc7XG5pbXBvcnQge1xuICBpc0J5dGVzLFxuICBpc0Jsb2IsXG4gIGlzUmVhZGFibGVTdHJlYW0sXG4gIGlzRmlsZU9iamVjdFxufSBmcm9tICcuL3V0aWxzLmpzJztcbmltcG9ydCB7XG4gIHBhcnNlTXRpbWUsXG4gIHBhcnNlTW9kZVxufSBmcm9tICdpcGZzLXVuaXhmcyc7XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24qIG5vcm1hbGlzZUNhbmRpZGF0ZVNpbmdsZShpbnB1dCwgbm9ybWFsaXNlQ29udGVudCkge1xuICBpZiAoaW5wdXQgPT09IG51bGwgfHwgaW5wdXQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IGVyckNvZGUobmV3IEVycm9yKGBVbmV4cGVjdGVkIGlucHV0OiAkeyBpbnB1dCB9YCksICdFUlJfVU5FWFBFQ1RFRF9JTlBVVCcpO1xuICB9XG4gIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnIHx8IGlucHV0IGluc3RhbmNlb2YgU3RyaW5nKSB7XG4gICAgeWllbGQgdG9GaWxlT2JqZWN0KGlucHV0LnRvU3RyaW5nKCksIG5vcm1hbGlzZUNvbnRlbnQpO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoaXNCeXRlcyhpbnB1dCkgfHwgaXNCbG9iKGlucHV0KSkge1xuICAgIHlpZWxkIHRvRmlsZU9iamVjdChpbnB1dCwgbm9ybWFsaXNlQ29udGVudCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChpc1JlYWRhYmxlU3RyZWFtKGlucHV0KSkge1xuICAgIGlucHV0ID0gYnJvd3NlclN0cmVhbVRvSXQoaW5wdXQpO1xuICB9XG4gIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gaW5wdXQgfHwgU3ltYm9sLmFzeW5jSXRlcmF0b3IgaW4gaW5wdXQpIHtcbiAgICBjb25zdCBwZWVrYWJsZSA9IGl0UGVla2FibGUoaW5wdXQpO1xuICAgIGNvbnN0IHt2YWx1ZSwgZG9uZX0gPSBhd2FpdCBwZWVrYWJsZS5wZWVrKCk7XG4gICAgaWYgKGRvbmUpIHtcbiAgICAgIHlpZWxkIHsgY29udGVudDogW10gfTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcGVla2FibGUucHVzaCh2YWx1ZSk7XG4gICAgaWYgKE51bWJlci5pc0ludGVnZXIodmFsdWUpIHx8IGlzQnl0ZXModmFsdWUpIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgdmFsdWUgaW5zdGFuY2VvZiBTdHJpbmcpIHtcbiAgICAgIHlpZWxkIHRvRmlsZU9iamVjdChwZWVrYWJsZSwgbm9ybWFsaXNlQ29udGVudCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRocm93IGVyckNvZGUobmV3IEVycm9yKCdVbmV4cGVjdGVkIGlucHV0OiBtdWx0aXBsZSBpdGVtcyBwYXNzZWQgLSBpZiB5b3UgYXJlIHVzaW5nIGlwZnMuYWRkLCBwbGVhc2UgdXNlIGlwZnMuYWRkQWxsIGluc3RlYWQnKSwgJ0VSUl9VTkVYUEVDVEVEX0lOUFVUJyk7XG4gIH1cbiAgaWYgKGlzRmlsZU9iamVjdChpbnB1dCkpIHtcbiAgICB5aWVsZCB0b0ZpbGVPYmplY3QoaW5wdXQsIG5vcm1hbGlzZUNvbnRlbnQpO1xuICAgIHJldHVybjtcbiAgfVxuICB0aHJvdyBlcnJDb2RlKG5ldyBFcnJvcignVW5leHBlY3RlZCBpbnB1dDogY2Fubm90IGNvbnZlcnQgXCInICsgdHlwZW9mIGlucHV0ICsgJ1wiIGludG8gSW1wb3J0Q2FuZGlkYXRlJyksICdFUlJfVU5FWFBFQ1RFRF9JTlBVVCcpO1xufVxuYXN5bmMgZnVuY3Rpb24gdG9GaWxlT2JqZWN0KGlucHV0LCBub3JtYWxpc2VDb250ZW50KSB7XG4gIGNvbnN0IHtwYXRoLCBtb2RlLCBtdGltZSwgY29udGVudH0gPSBpbnB1dDtcbiAgY29uc3QgZmlsZSA9IHtcbiAgICBwYXRoOiBwYXRoIHx8ICcnLFxuICAgIG1vZGU6IHBhcnNlTW9kZShtb2RlKSxcbiAgICBtdGltZTogcGFyc2VNdGltZShtdGltZSlcbiAgfTtcbiAgaWYgKGNvbnRlbnQpIHtcbiAgICBmaWxlLmNvbnRlbnQgPSBhd2FpdCBub3JtYWxpc2VDb250ZW50KGNvbnRlbnQpO1xuICB9IGVsc2UgaWYgKCFwYXRoKSB7XG4gICAgZmlsZS5jb250ZW50ID0gYXdhaXQgbm9ybWFsaXNlQ29udGVudChpbnB1dCk7XG4gIH1cbiAgcmV0dXJuIGZpbGU7XG59IiwgImltcG9ydCB7IG5vcm1hbGlzZUNvbnRlbnQgfSBmcm9tICcuL25vcm1hbGlzZS1jb250ZW50LmpzJztcbmltcG9ydCB7IG5vcm1hbGlzZUNhbmRpZGF0ZVNpbmdsZSB9IGZyb20gJy4vbm9ybWFsaXNlLWNhbmRpZGF0ZS1zaW5nbGUuanMnO1xuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGlzZUlucHV0KGlucHV0KSB7XG4gIHJldHVybiBub3JtYWxpc2VDYW5kaWRhdGVTaW5nbGUoaW5wdXQsIG5vcm1hbGlzZUNvbnRlbnQpO1xufSIsICJpbXBvcnQgZXJyQ29kZSBmcm9tICdlcnItY29kZSc7XG5pbXBvcnQgYnJvd3NlclN0cmVhbVRvSXQgZnJvbSAnYnJvd3Nlci1yZWFkYWJsZXN0cmVhbS10by1pdCc7XG5pbXBvcnQgaXRQZWVrYWJsZSBmcm9tICdpdC1wZWVrYWJsZSc7XG5pbXBvcnQgbWFwIGZyb20gJ2l0LW1hcCc7XG5pbXBvcnQge1xuICBpc0J5dGVzLFxuICBpc0Jsb2IsXG4gIGlzUmVhZGFibGVTdHJlYW0sXG4gIGlzRmlsZU9iamVjdFxufSBmcm9tICcuL3V0aWxzLmpzJztcbmltcG9ydCB7XG4gIHBhcnNlTXRpbWUsXG4gIHBhcnNlTW9kZVxufSBmcm9tICdpcGZzLXVuaXhmcyc7XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24qIG5vcm1hbGlzZUNhbmRpZGF0ZU11bHRpcGxlKGlucHV0LCBub3JtYWxpc2VDb250ZW50KSB7XG4gIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnIHx8IGlucHV0IGluc3RhbmNlb2YgU3RyaW5nIHx8IGlzQnl0ZXMoaW5wdXQpIHx8IGlzQmxvYihpbnB1dCkgfHwgaW5wdXQuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICB0aHJvdyBlcnJDb2RlKG5ldyBFcnJvcignVW5leHBlY3RlZCBpbnB1dDogc2luZ2xlIGl0ZW0gcGFzc2VkIC0gaWYgeW91IGFyZSB1c2luZyBpcGZzLmFkZEFsbCwgcGxlYXNlIHVzZSBpcGZzLmFkZCBpbnN0ZWFkJyksICdFUlJfVU5FWFBFQ1RFRF9JTlBVVCcpO1xuICB9XG4gIGlmIChpc1JlYWRhYmxlU3RyZWFtKGlucHV0KSkge1xuICAgIGlucHV0ID0gYnJvd3NlclN0cmVhbVRvSXQoaW5wdXQpO1xuICB9XG4gIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gaW5wdXQgfHwgU3ltYm9sLmFzeW5jSXRlcmF0b3IgaW4gaW5wdXQpIHtcbiAgICBjb25zdCBwZWVrYWJsZSA9IGl0UGVla2FibGUoaW5wdXQpO1xuICAgIGNvbnN0IHt2YWx1ZSwgZG9uZX0gPSBhd2FpdCBwZWVrYWJsZS5wZWVrKCk7XG4gICAgaWYgKGRvbmUpIHtcbiAgICAgIHlpZWxkKiBbXTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcGVla2FibGUucHVzaCh2YWx1ZSk7XG4gICAgaWYgKE51bWJlci5pc0ludGVnZXIodmFsdWUpKSB7XG4gICAgICB0aHJvdyBlcnJDb2RlKG5ldyBFcnJvcignVW5leHBlY3RlZCBpbnB1dDogc2luZ2xlIGl0ZW0gcGFzc2VkIC0gaWYgeW91IGFyZSB1c2luZyBpcGZzLmFkZEFsbCwgcGxlYXNlIHVzZSBpcGZzLmFkZCBpbnN0ZWFkJyksICdFUlJfVU5FWFBFQ1RFRF9JTlBVVCcpO1xuICAgIH1cbiAgICBpZiAodmFsdWUuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICAgIHlpZWxkKiBtYXAocGVla2FibGUsIHZhbHVlID0+IHRvRmlsZU9iamVjdCh7IGNvbnRlbnQ6IHZhbHVlIH0sIG5vcm1hbGlzZUNvbnRlbnQpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGlzQnl0ZXModmFsdWUpKSB7XG4gICAgICB5aWVsZCB0b0ZpbGVPYmplY3QoeyBjb250ZW50OiBwZWVrYWJsZSB9LCBub3JtYWxpc2VDb250ZW50KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGlzRmlsZU9iamVjdCh2YWx1ZSkgfHwgdmFsdWVbU3ltYm9sLml0ZXJhdG9yXSB8fCB2YWx1ZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gfHwgaXNSZWFkYWJsZVN0cmVhbSh2YWx1ZSkgfHwgaXNCbG9iKHZhbHVlKSkge1xuICAgICAgeWllbGQqIG1hcChwZWVrYWJsZSwgdmFsdWUgPT4gdG9GaWxlT2JqZWN0KHZhbHVlLCBub3JtYWxpc2VDb250ZW50KSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIGlmIChpc0ZpbGVPYmplY3QoaW5wdXQpKSB7XG4gICAgdGhyb3cgZXJyQ29kZShuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgaW5wdXQ6IHNpbmdsZSBpdGVtIHBhc3NlZCAtIGlmIHlvdSBhcmUgdXNpbmcgaXBmcy5hZGRBbGwsIHBsZWFzZSB1c2UgaXBmcy5hZGQgaW5zdGVhZCcpLCAnRVJSX1VORVhQRUNURURfSU5QVVQnKTtcbiAgfVxuICB0aHJvdyBlcnJDb2RlKG5ldyBFcnJvcignVW5leHBlY3RlZCBpbnB1dDogJyArIHR5cGVvZiBpbnB1dCksICdFUlJfVU5FWFBFQ1RFRF9JTlBVVCcpO1xufVxuYXN5bmMgZnVuY3Rpb24gdG9GaWxlT2JqZWN0KGlucHV0LCBub3JtYWxpc2VDb250ZW50KSB7XG4gIGNvbnN0IHtwYXRoLCBtb2RlLCBtdGltZSwgY29udGVudH0gPSBpbnB1dDtcbiAgY29uc3QgZmlsZSA9IHtcbiAgICBwYXRoOiBwYXRoIHx8ICcnLFxuICAgIG1vZGU6IHBhcnNlTW9kZShtb2RlKSxcbiAgICBtdGltZTogcGFyc2VNdGltZShtdGltZSlcbiAgfTtcbiAgaWYgKGNvbnRlbnQpIHtcbiAgICBmaWxlLmNvbnRlbnQgPSBhd2FpdCBub3JtYWxpc2VDb250ZW50KGNvbnRlbnQpO1xuICB9IGVsc2UgaWYgKCFwYXRoKSB7XG4gICAgZmlsZS5jb250ZW50ID0gYXdhaXQgbm9ybWFsaXNlQ29udGVudChpbnB1dCk7XG4gIH1cbiAgcmV0dXJuIGZpbGU7XG59IiwgImltcG9ydCB7IG5vcm1hbGlzZUNvbnRlbnQgfSBmcm9tICcuL25vcm1hbGlzZS1jb250ZW50LmpzJztcbmltcG9ydCB7IG5vcm1hbGlzZUNhbmRpZGF0ZU11bHRpcGxlIH0gZnJvbSAnLi9ub3JtYWxpc2UtY2FuZGlkYXRlLW11bHRpcGxlLmpzJztcbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpc2VJbnB1dChpbnB1dCkge1xuICByZXR1cm4gbm9ybWFsaXNlQ2FuZGlkYXRlTXVsdGlwbGUoaW5wdXQsIG5vcm1hbGlzZUNvbnRlbnQpO1xufSIsICJpbXBvcnQgeyBub3JtYWxpc2VJbnB1dCBhcyBub3JtYWxpc2VJbnB1dFNpbmdsZSB9IGZyb20gJ2lwZnMtY29yZS11dGlscy9maWxlcy9ub3JtYWxpc2UtaW5wdXQtc2luZ2xlJztcbmltcG9ydCB7IG5vcm1hbGlzZUlucHV0IGFzIG5vcm1hbGlzZUlucHV0TXVsdGlwbGUgfSBmcm9tICdpcGZzLWNvcmUtdXRpbHMvZmlsZXMvbm9ybWFsaXNlLWlucHV0LW11bHRpcGxlJztcbmZ1bmN0aW9uIGlzQnl0ZXMob2JqKSB7XG4gICAgcmV0dXJuIEFycmF5QnVmZmVyLmlzVmlldyhvYmopIHx8IG9iaiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyO1xufVxuZnVuY3Rpb24gaXNCbG9iKG9iaikge1xuICAgIHJldHVybiBCb29sZWFuKG9iai5jb25zdHJ1Y3RvcikgJiZcbiAgICAgICAgKG9iai5jb25zdHJ1Y3Rvci5uYW1lID09PSAnQmxvYicgfHwgb2JqLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdGaWxlJykgJiZcbiAgICAgICAgdHlwZW9mIG9iai5zdHJlYW0gPT09ICdmdW5jdGlvbic7XG59XG5mdW5jdGlvbiBpc1NpbmdsZShpbnB1dCkge1xuICAgIHJldHVybiB0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnIHx8IGlucHV0IGluc3RhbmNlb2YgU3RyaW5nIHx8IGlzQnl0ZXMoaW5wdXQpIHx8IGlzQmxvYihpbnB1dCkgfHwgJ19yZWFkYWJsZVN0YXRlJyBpbiBpbnB1dDtcbn1cbi8qKlxuICogR2V0IGEgc2luZ2xlIG9yIG11bHRpcGxlIG5vcm1hbGlzZXIgZGVwZW5kaW5nIG9uIHRoZSBpbnB1dC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE5vcm1hbGlzZXIoaW5wdXQpIHtcbiAgICBpZiAoaXNTaW5nbGUoaW5wdXQpKSB7XG4gICAgICAgIHJldHVybiBub3JtYWxpc2VJbnB1dFNpbmdsZShpbnB1dCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbm9ybWFsaXNlSW5wdXRNdWx0aXBsZShpbnB1dCk7XG4gICAgfVxufVxuIiwgImltcG9ydCBlcnJDb2RlIGZyb20gJ2Vyci1jb2RlJztcbmV4cG9ydCBmdW5jdGlvbiBub3RGb3VuZEVycm9yKGVycikge1xuICBlcnIgPSBlcnIgfHwgbmV3IEVycm9yKCdOb3QgRm91bmQnKTtcbiAgcmV0dXJuIGVyckNvZGUoZXJyLCAnRVJSX05PVF9GT1VORCcpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGFib3J0ZWRFcnJvcihlcnIpIHtcbiAgZXJyID0gZXJyIHx8IG5ldyBFcnJvcignQWJvcnRlZCcpO1xuICByZXR1cm4gZXJyQ29kZShlcnIsICdFUlJfQUJPUlRFRCcpO1xufSIsICJpbXBvcnQgZHJhaW4gZnJvbSAnaXQtZHJhaW4nO1xuaW1wb3J0IGZpbHRlciBmcm9tICdpdC1maWx0ZXInO1xuaW1wb3J0IHRha2UgZnJvbSAnaXQtdGFrZSc7XG5pbXBvcnQgYWxsIGZyb20gJ2l0LWFsbCc7XG5jb25zdCBzb3J0QWxsID0gKGl0ZXJhYmxlLCBzb3J0ZXIpID0+IHtcbiAgcmV0dXJuIGFzeW5jIGZ1bmN0aW9uKiAoKSB7XG4gICAgY29uc3QgdmFsdWVzID0gYXdhaXQgYWxsKGl0ZXJhYmxlKTtcbiAgICB5aWVsZCogdmFsdWVzLnNvcnQoc29ydGVyKTtcbiAgfSgpO1xufTtcbmV4cG9ydCBjbGFzcyBCYXNlQmxvY2tzdG9yZSB7XG4gIG9wZW4oKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignLm9wZW4gaXMgbm90IGltcGxlbWVudGVkJykpO1xuICB9XG4gIGNsb3NlKCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJy5jbG9zZSBpcyBub3QgaW1wbGVtZW50ZWQnKSk7XG4gIH1cbiAgcHV0KGtleSwgdmFsLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignLnB1dCBpcyBub3QgaW1wbGVtZW50ZWQnKSk7XG4gIH1cbiAgZ2V0KGtleSwgb3B0aW9ucykge1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJy5nZXQgaXMgbm90IGltcGxlbWVudGVkJykpO1xuICB9XG4gIGhhcyhrZXksIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCcuaGFzIGlzIG5vdCBpbXBsZW1lbnRlZCcpKTtcbiAgfVxuICBkZWxldGUoa2V5LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignLmRlbGV0ZSBpcyBub3QgaW1wbGVtZW50ZWQnKSk7XG4gIH1cbiAgYXN5bmMgKnB1dE1hbnkoc291cmNlLCBvcHRpb25zID0ge30pIHtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IHtrZXksIHZhbHVlfSBvZiBzb3VyY2UpIHtcbiAgICAgIGF3YWl0IHRoaXMucHV0KGtleSwgdmFsdWUsIG9wdGlvbnMpO1xuICAgICAgeWllbGQge1xuICAgICAgICBrZXksXG4gICAgICAgIHZhbHVlXG4gICAgICB9O1xuICAgIH1cbiAgfVxuICBhc3luYyAqZ2V0TWFueShzb3VyY2UsIG9wdGlvbnMgPSB7fSkge1xuICAgIGZvciBhd2FpdCAoY29uc3Qga2V5IG9mIHNvdXJjZSkge1xuICAgICAgeWllbGQgdGhpcy5nZXQoa2V5LCBvcHRpb25zKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgKmRlbGV0ZU1hbnkoc291cmNlLCBvcHRpb25zID0ge30pIHtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IGtleSBvZiBzb3VyY2UpIHtcbiAgICAgIGF3YWl0IHRoaXMuZGVsZXRlKGtleSwgb3B0aW9ucyk7XG4gICAgICB5aWVsZCBrZXk7XG4gICAgfVxuICB9XG4gIGJhdGNoKCkge1xuICAgIGxldCBwdXRzID0gW107XG4gICAgbGV0IGRlbHMgPSBbXTtcbiAgICByZXR1cm4ge1xuICAgICAgcHV0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgcHV0cy5wdXNoKHtcbiAgICAgICAgICBrZXksXG4gICAgICAgICAgdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgZGVsZXRlKGtleSkge1xuICAgICAgICBkZWxzLnB1c2goa2V5KTtcbiAgICAgIH0sXG4gICAgICBjb21taXQ6IGFzeW5jIG9wdGlvbnMgPT4ge1xuICAgICAgICBhd2FpdCBkcmFpbih0aGlzLnB1dE1hbnkocHV0cywgb3B0aW9ucykpO1xuICAgICAgICBwdXRzID0gW107XG4gICAgICAgIGF3YWl0IGRyYWluKHRoaXMuZGVsZXRlTWFueShkZWxzLCBvcHRpb25zKSk7XG4gICAgICAgIGRlbHMgPSBbXTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGFzeW5jICpfYWxsKHEsIG9wdGlvbnMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJy5fYWxsIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xuICB9XG4gIGFzeW5jICpfYWxsS2V5cyhxLCBvcHRpb25zKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCcuX2FsbEtleXMgaXMgbm90IGltcGxlbWVudGVkJyk7XG4gIH1cbiAgcXVlcnkocSwgb3B0aW9ucykge1xuICAgIGxldCBpdCA9IHRoaXMuX2FsbChxLCBvcHRpb25zKTtcbiAgICBpZiAocS5wcmVmaXggIT0gbnVsbCkge1xuICAgICAgaXQgPSBmaWx0ZXIoaXQsIGUgPT4gZS5rZXkudG9TdHJpbmcoKS5zdGFydHNXaXRoKHEucHJlZml4IHx8ICcnKSk7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KHEuZmlsdGVycykpIHtcbiAgICAgIGl0ID0gcS5maWx0ZXJzLnJlZHVjZSgoaXQsIGYpID0+IGZpbHRlcihpdCwgZiksIGl0KTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocS5vcmRlcnMpKSB7XG4gICAgICBpdCA9IHEub3JkZXJzLnJlZHVjZSgoaXQsIGYpID0+IHNvcnRBbGwoaXQsIGYpLCBpdCk7XG4gICAgfVxuICAgIGlmIChxLm9mZnNldCAhPSBudWxsKSB7XG4gICAgICBsZXQgaSA9IDA7XG4gICAgICBpdCA9IGZpbHRlcihpdCwgKCkgPT4gaSsrID49IChxLm9mZnNldCB8fCAwKSk7XG4gICAgfVxuICAgIGlmIChxLmxpbWl0ICE9IG51bGwpIHtcbiAgICAgIGl0ID0gdGFrZShpdCwgcS5saW1pdCk7XG4gICAgfVxuICAgIHJldHVybiBpdDtcbiAgfVxuICBxdWVyeUtleXMocSwgb3B0aW9ucykge1xuICAgIGxldCBpdCA9IHRoaXMuX2FsbEtleXMocSwgb3B0aW9ucyk7XG4gICAgaWYgKHEucHJlZml4ICE9IG51bGwpIHtcbiAgICAgIGl0ID0gZmlsdGVyKGl0LCBjaWQgPT4gY2lkLnRvU3RyaW5nKCkuc3RhcnRzV2l0aChxLnByZWZpeCB8fCAnJykpO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShxLmZpbHRlcnMpKSB7XG4gICAgICBpdCA9IHEuZmlsdGVycy5yZWR1Y2UoKGl0LCBmKSA9PiBmaWx0ZXIoaXQsIGYpLCBpdCk7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KHEub3JkZXJzKSkge1xuICAgICAgaXQgPSBxLm9yZGVycy5yZWR1Y2UoKGl0LCBmKSA9PiBzb3J0QWxsKGl0LCBmKSwgaXQpO1xuICAgIH1cbiAgICBpZiAocS5vZmZzZXQgIT0gbnVsbCkge1xuICAgICAgbGV0IGkgPSAwO1xuICAgICAgaXQgPSBmaWx0ZXIoaXQsICgpID0+IGkrKyA+PSBxLm9mZnNldCk7XG4gICAgfVxuICAgIGlmIChxLmxpbWl0ICE9IG51bGwpIHtcbiAgICAgIGl0ID0gdGFrZShpdCwgcS5saW1pdCk7XG4gICAgfVxuICAgIHJldHVybiBpdDtcbiAgfVxufSIsICJpbXBvcnQgKiBhcyBFcnJvcnNJbXBvcnQgZnJvbSAnLi9lcnJvcnMuanMnO1xuZXhwb3J0IHtcbiAgQmFzZUJsb2Nrc3RvcmVcbn0gZnJvbSAnLi9iYXNlLmpzJztcbmV4cG9ydCB7XG4gIE1lbW9yeUJsb2Nrc3RvcmVcbn0gZnJvbSAnLi9tZW1vcnkuanMnO1xuZXhwb3J0IGNvbnN0IEVycm9ycyA9IHsgLi4uRXJyb3JzSW1wb3J0IH07IiwgImltcG9ydCB7IENJRCB9IGZyb20gJ211bHRpZm9ybWF0cyc7XG5pbXBvcnQgeyBCYXNlQmxvY2tzdG9yZSB9IGZyb20gJ2Jsb2Nrc3RvcmUtY29yZSc7XG5leHBvcnQgY2xhc3MgTWVtb3J5QmxvY2tTdG9yZSBleHRlbmRzIEJhc2VCbG9ja3N0b3JlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zdG9yZSA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgYXN5bmMgKmJsb2NrcygpIHtcbiAgICAgICAgZm9yIChjb25zdCBbY2lkU3RyLCBieXRlc10gb2YgdGhpcy5zdG9yZS5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgIHlpZWxkIHsgY2lkOiBDSUQucGFyc2UoY2lkU3RyKSwgYnl0ZXMgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwdXQoY2lkLCBieXRlcykge1xuICAgICAgICB0aGlzLnN0b3JlLnNldChjaWQudG9TdHJpbmcoKSwgYnl0ZXMpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIGdldChjaWQpIHtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSB0aGlzLnN0b3JlLmdldChjaWQudG9TdHJpbmcoKSk7XG4gICAgICAgIGlmICghYnl0ZXMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgYmxvY2sgd2l0aCBjaWQgJHtjaWQudG9TdHJpbmcoKX0gbm8gZm91bmRgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGJ5dGVzKTtcbiAgICB9XG4gICAgaGFzKGNpZCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuc3RvcmUuaGFzKGNpZC50b1N0cmluZygpKSk7XG4gICAgfVxuICAgIGNsb3NlKCkge1xuICAgICAgICB0aGlzLnN0b3JlLmNsZWFyKCk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHsgc2hhMjU2IH0gZnJvbSAnbXVsdGlmb3JtYXRzL2hhc2hlcy9zaGEyJztcbmV4cG9ydCBjb25zdCB1bml4ZnNJbXBvcnRlck9wdGlvbnNEZWZhdWx0ID0ge1xuICAgIGNpZFZlcnNpb246IDEsXG4gICAgY2h1bmtlcjogJ2ZpeGVkJyxcbiAgICBtYXhDaHVua1NpemU6IDI2MjE0NCxcbiAgICBoYXNoZXI6IHNoYTI1NixcbiAgICByYXdMZWF2ZXM6IHRydWUsXG4gICAgd3JhcFdpdGhEaXJlY3Rvcnk6IHRydWUsXG4gICAgbWF4Q2hpbGRyZW5QZXJOb2RlOiAxNzRcbn07XG4iLCAiLyoqXG4gKiBJbmRleC5qc1xuICpcbiAqIGEgcmVxdWVzdCBBUEkgY29tcGF0aWJsZSB3aXRoIHdpbmRvdy5mZXRjaFxuICpcbiAqIEFsbCBzcGVjIGFsZ29yaXRobSBzdGVwIG51bWJlcnMgYXJlIGJhc2VkIG9uIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnL2NvbW1pdC1zbmFwc2hvdHMvYWU3MTY4MjJjYjNhNjE4NDMyMjZjZDA5MGVlZmM2NTg5NDQ2YzFkMi8uXG4gKi9cblxuaW1wb3J0IGh0dHAgZnJvbSAnaHR0cCc7XG5pbXBvcnQgaHR0cHMgZnJvbSAnaHR0cHMnO1xuaW1wb3J0IHpsaWIgZnJvbSAnemxpYic7XG5pbXBvcnQgZnMgZnJvbSAnZnMnO1xuaW1wb3J0ICogYXMgbWltZSBmcm9tICdtcm1pbWUnXG5pbXBvcnQgZGF0YVVyaVRvQnVmZmVyIGZyb20gJ2RhdGEtdXJpLXRvLWJ1ZmZlcic7XG5pbXBvcnQge0J1ZmZlcn0gZnJvbSAnYnVmZmVyJztcblxuaW1wb3J0IHt3cml0ZVRvU3RyZWFtLCBmcm9tQXN5bmNJdGVyYWJsZX0gZnJvbSAnLi9ib2R5LmpzJztcbmltcG9ydCBSZXNwb25zZSBmcm9tICcuL3Jlc3BvbnNlLmpzJztcbmltcG9ydCBIZWFkZXJzLCB7ZnJvbVJhd0hlYWRlcnN9IGZyb20gJy4vaGVhZGVycy5qcyc7XG5pbXBvcnQgUmVxdWVzdCwge2dldE5vZGVSZXF1ZXN0T3B0aW9uc30gZnJvbSAnLi9yZXF1ZXN0LmpzJztcbmltcG9ydCB7RmV0Y2hFcnJvcn0gZnJvbSAnLi9lcnJvcnMvZmV0Y2gtZXJyb3IuanMnO1xuaW1wb3J0IHtBYm9ydEVycm9yfSBmcm9tICcuL2Vycm9ycy9hYm9ydC1lcnJvci5qcyc7XG5pbXBvcnQge2lzUmVkaXJlY3R9IGZyb20gJy4vdXRpbHMvaXMtcmVkaXJlY3QuanMnO1xuaW1wb3J0IHtwaXBlbGluZSBhcyBwdW1wLCBQYXNzVGhyb3VnaH0gZnJvbSAnc3RyZWFtJztcbmltcG9ydCAqIGFzIFN0cmVhbSBmcm9tICdzdHJlYW0nO1xuaW1wb3J0IHsgUmVhZGFibGVTdHJlYW0sIEJsb2IsIEZvcm1EYXRhICB9IGZyb20gJy4vcGFja2FnZS5qcyc7XG5cblxuZXhwb3J0IHtIZWFkZXJzLCBSZXF1ZXN0LCBSZXNwb25zZSwgUmVhZGFibGVTdHJlYW0sIEJsb2IsIEZvcm1EYXRhfTtcblxuY29uc3Qgc3VwcG9ydGVkU2NoZW1hcyA9IG5ldyBTZXQoWydkYXRhOicsICdodHRwOicsICdodHRwczonLCAnZmlsZTonXSk7XG5cbi8qKlxuICogRmV0Y2ggZnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0gICB7c3RyaW5nIHwgVVJMIHwgaW1wb3J0KCcuL3JlcXVlc3QuanMnKS5kZWZhdWx0fSB1cmwgLSBBYnNvbHV0ZSB1cmwgb3IgUmVxdWVzdCBpbnN0YW5jZVxuICogQHBhcmFtICAge1JlcXVlc3RJbml0ICYgaW1wb3J0KCcuL3JlcXVlc3QuanMnKS5SZXF1ZXN0RXh0cmFPcHRpb25zfSBbb3B0aW9uc19dIC0gRmV0Y2ggb3B0aW9uc1xuICogQHJldHVybiAge1Byb21pc2U8aW1wb3J0KCcuL3Jlc3BvbnNlLmpzJykuZGVmYXVsdD59XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGZldGNoKHVybCwgb3B0aW9uc18gPSB7fSkge1xuXHRyZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXHRcdC8vIEJ1aWxkIHJlcXVlc3Qgb2JqZWN0XG5cdFx0Y29uc3QgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KHVybCwgb3B0aW9uc18pO1xuXHRcdGNvbnN0IG9wdGlvbnMgPSBnZXROb2RlUmVxdWVzdE9wdGlvbnMocmVxdWVzdCk7XG5cdFx0aWYgKCFzdXBwb3J0ZWRTY2hlbWFzLmhhcyhvcHRpb25zLnByb3RvY29sKSkge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihgbm9kZS1mZXRjaCBjYW5ub3QgbG9hZCAke3VybH0uIFVSTCBzY2hlbWUgXCIke29wdGlvbnMucHJvdG9jb2wucmVwbGFjZSgvOiQvLCAnJyl9XCIgaXMgbm90IHN1cHBvcnRlZC5gKTtcblx0XHR9XG5cblx0XHRpZiAob3B0aW9ucy5wcm90b2NvbCA9PT0gJ2RhdGE6Jykge1xuXHRcdFx0Y29uc3QgZGF0YSA9IGRhdGFVcmlUb0J1ZmZlcihyZXF1ZXN0LnVybC50b1N0cmluZygpKTtcblx0XHRcdGNvbnN0IHJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKGRhdGEsIHtoZWFkZXJzOiB7J0NvbnRlbnQtVHlwZSc6IGRhdGEudHlwZUZ1bGx9fSk7XG5cdFx0XHRyZXNvbHZlKHJlc3BvbnNlKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAob3B0aW9ucy5wcm90b2NvbCA9PT0gJ2ZpbGU6Jykge1xuXHRcdFx0Y29uc3Qgc3RyZWFtID0gZnMuY3JlYXRlUmVhZFN0cmVhbShuZXcgVVJMKHJlcXVlc3QudXJsKSlcblx0XHRcdGNvbnN0IHR5cGUgPSBtaW1lLmxvb2t1cChyZXF1ZXN0LnVybCkgfHwgJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbSdcblx0XHRcdGNvbnN0IHJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKHN0cmVhbSwge2hlYWRlcnM6IHsnQ29udGVudC1UeXBlJzogdHlwZSB9fSk7XG5cdFx0XHRyZXNvbHZlKHJlc3BvbnNlKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBXcmFwIGh0dHAucmVxdWVzdCBpbnRvIGZldGNoXG5cdFx0Y29uc3Qgc2VuZCA9IChvcHRpb25zLnByb3RvY29sID09PSAnaHR0cHM6JyA/IGh0dHBzIDogaHR0cCkucmVxdWVzdDtcblx0XHRjb25zdCB7c2lnbmFsfSA9IHJlcXVlc3Q7XG5cdFx0LyoqIEB0eXBlIHtSZXNwb25zZXxudWxsfSAqL1xuXHRcdGxldCByZXNwb25zZSA9IG51bGw7XG5cdFx0LyoqIEB0eXBlIHtpbXBvcnQoJ2h0dHAnKS5JbmNvbWluZ01lc3NhZ2V8bnVsbH0gKi9cblx0XHRsZXQgcmVzcG9uc2VfID0gbnVsbDtcblxuXHRcdGNvbnN0IGFib3J0ID0gKCkgPT4ge1xuXHRcdFx0Y29uc3QgZXJyb3IgPSBuZXcgQWJvcnRFcnJvcignVGhlIG9wZXJhdGlvbiB3YXMgYWJvcnRlZC4nKTtcblx0XHRcdHJlamVjdChlcnJvcik7XG5cdFx0XHRpZiAocmVxdWVzdC5ib2R5KSB7XG5cdFx0XHRcdHJlcXVlc3QuYm9keS5jYW5jZWwoZXJyb3IpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIXJlc3BvbnNlXykge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHJlc3BvbnNlXy5lbWl0KCdlcnJvcicsIGVycm9yKTtcblx0XHR9O1xuXG5cdFx0aWYgKHNpZ25hbCAmJiBzaWduYWwuYWJvcnRlZCkge1xuXHRcdFx0YWJvcnQoKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRjb25zdCBhYm9ydEFuZEZpbmFsaXplID0gKCkgPT4ge1xuXHRcdFx0YWJvcnQoKTtcblx0XHRcdGZpbmFsaXplKCk7XG5cdFx0fTtcblxuXHRcdC8vIFNlbmQgcmVxdWVzdFxuXHRcdGNvbnN0IHJlcXVlc3RfID0gc2VuZChvcHRpb25zKTtcblxuXHRcdGlmIChzaWduYWwpIHtcblx0XHRcdHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIGFib3J0QW5kRmluYWxpemUpO1xuXHRcdH1cblxuXHRcdGNvbnN0IGZpbmFsaXplID0gKCkgPT4ge1xuXHRcdFx0cmVxdWVzdF8uYWJvcnQoKTtcblx0XHRcdGlmIChzaWduYWwpIHtcblx0XHRcdFx0c2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRBbmRGaW5hbGl6ZSk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdHJlcXVlc3RfLm9uKCdlcnJvcicsIGVyciA9PiB7XG5cdFx0XHQvLyBAdHMtZXhwZWN0LWVycm9yIC0gZXJyIG1heSBub3QgYmUgU3lzdGVtRXJyb3Jcblx0XHRcdHJlamVjdChuZXcgRmV0Y2hFcnJvcihgcmVxdWVzdCB0byAke3JlcXVlc3QudXJsfSBmYWlsZWQsIHJlYXNvbjogJHtlcnIubWVzc2FnZX1gLCAnc3lzdGVtJywgZXJyKSk7XG5cdFx0XHRmaW5hbGl6ZSgpO1xuXHRcdH0pO1xuXG5cdFx0Zml4UmVzcG9uc2VDaHVua2VkVHJhbnNmZXJCYWRFbmRpbmcocmVxdWVzdF8sIGVyciA9PiB7XG5cdFx0XHRpZiAoc2lnbmFsICYmIHNpZ25hbC5hYm9ydGVkKSB7XG5cdFx0XHRcdHJldHVyblxuXHRcdFx0fVxuXG5cdFx0XHRyZXNwb25zZV8/LmVtaXQoXCJlcnJvclwiLCBlcnIpO1xuXHRcdH0pO1xuXG5cdFx0LyogYzggaWdub3JlIG5leHQgMTggKi9cblx0XHRpZiAocGFyc2VJbnQocHJvY2Vzcy52ZXJzaW9uLnN1YnN0cmluZygxKSkgPCAxNCkge1xuXHRcdFx0Ly8gQmVmb3JlIE5vZGUuanMgMTQsIHBpcGVsaW5lKCkgZG9lcyBub3QgZnVsbHkgc3VwcG9ydCBhc3luYyBpdGVyYXRvcnMgYW5kIGRvZXMgbm90IGFsd2F5c1xuXHRcdFx0Ly8gcHJvcGVybHkgaGFuZGxlIHdoZW4gdGhlIHNvY2tldCBjbG9zZS9lbmQgZXZlbnRzIGFyZSBvdXQgb2Ygb3JkZXIuXG5cdFx0XHRyZXF1ZXN0Xy5vbignc29ja2V0JywgcyA9PiB7XG5cdFx0XHRcdHMucHJlcGVuZExpc3RlbmVyKCdjbG9zZScsIGhhZEVycm9yID0+IHtcblx0XHRcdFx0XHQvLyBpZiBhIGRhdGEgbGlzdGVuZXIgaXMgc3RpbGwgcHJlc2VudCB3ZSBkaWRuJ3QgZW5kIGNsZWFubHlcblx0XHRcdFx0XHRjb25zdCBoYXNEYXRhTGlzdGVuZXIgPSBzLmxpc3RlbmVyQ291bnQoJ2RhdGEnKSA+IDBcblxuXHRcdFx0XHRcdC8vIGlmIGVuZCBoYXBwZW5lZCBiZWZvcmUgY2xvc2UgYnV0IHRoZSBzb2NrZXQgZGlkbid0IGVtaXQgYW4gZXJyb3IsIGRvIGl0IG5vd1xuXHRcdFx0XHRcdGlmIChyZXNwb25zZSAmJiBoYXNEYXRhTGlzdGVuZXIgJiYgIWhhZEVycm9yICYmICEoc2lnbmFsICYmIHNpZ25hbC5hYm9ydGVkKSkge1xuXHRcdFx0XHRcdFx0Y29uc3QgZXJyID0gT2JqZWN0LmFzc2lnbihuZXcgRXJyb3IoJ1ByZW1hdHVyZSBjbG9zZScpLCB7XG5cdFx0XHRcdFx0XHRcdGNvZGU6ICdFUlJfU1RSRUFNX1BSRU1BVFVSRV9DTE9TRSdcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0cmVzcG9uc2VfPy5lbWl0KCdlcnJvcicsIGVycik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHJlcXVlc3RfLm9uKCdyZXNwb25zZScsIGluY29taW5nID0+IHtcblx0XHRcdHJlc3BvbnNlXyA9IGluY29taW5nO1xuXHRcdFx0cmVxdWVzdF8uc2V0VGltZW91dCgwKTtcblx0XHRcdGNvbnN0IGhlYWRlcnMgPSBmcm9tUmF3SGVhZGVycyhyZXNwb25zZV8ucmF3SGVhZGVycyk7XG5cblx0XHRcdC8vIEhUVFAgZmV0Y2ggc3RlcCA1XG5cdFx0XHRpZiAoaXNSZWRpcmVjdChOdW1iZXIocmVzcG9uc2VfLnN0YXR1c0NvZGUpKSkge1xuXHRcdFx0XHQvLyBIVFRQIGZldGNoIHN0ZXAgNS4yXG5cdFx0XHRcdGNvbnN0IGxvY2F0aW9uID0gaGVhZGVycy5nZXQoJ0xvY2F0aW9uJyk7XG5cblx0XHRcdFx0Ly8gSFRUUCBmZXRjaCBzdGVwIDUuM1xuXHRcdFx0XHRjb25zdCBsb2NhdGlvblVSTCA9IGxvY2F0aW9uID09PSBudWxsID8gbnVsbCA6IG5ldyBVUkwobG9jYXRpb24sIHJlcXVlc3QudXJsKTtcblxuXHRcdFx0XHQvLyBIVFRQIGZldGNoIHN0ZXAgNS41XG5cdFx0XHRcdHN3aXRjaCAocmVxdWVzdC5yZWRpcmVjdCkge1xuXHRcdFx0XHRcdGNhc2UgJ2Vycm9yJzpcblx0XHRcdFx0XHRcdHJlamVjdChuZXcgRmV0Y2hFcnJvcihgdXJpIHJlcXVlc3RlZCByZXNwb25kcyB3aXRoIGEgcmVkaXJlY3QsIHJlZGlyZWN0IG1vZGUgaXMgc2V0IHRvIGVycm9yOiAke3JlcXVlc3QudXJsfWAsICduby1yZWRpcmVjdCcpKTtcblx0XHRcdFx0XHRcdGZpbmFsaXplKCk7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0Y2FzZSAnbWFudWFsJzpcblx0XHRcdFx0XHRcdC8vIE5vZGUtZmV0Y2gtc3BlY2lmaWMgc3RlcDogbWFrZSBtYW51YWwgcmVkaXJlY3QgYSBiaXQgZWFzaWVyIHRvIHVzZSBieSBzZXR0aW5nIHRoZSBMb2NhdGlvbiBoZWFkZXIgdmFsdWUgdG8gdGhlIHJlc29sdmVkIFVSTC5cblx0XHRcdFx0XHRcdGlmIChsb2NhdGlvblVSTCAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0XHRoZWFkZXJzLnNldCgnTG9jYXRpb24nLCBsb2NhdGlvblVSTC50b1N0cmluZygpKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAnZm9sbG93Jzoge1xuXHRcdFx0XHRcdFx0Ly8gSFRUUC1yZWRpcmVjdCBmZXRjaCBzdGVwIDJcblx0XHRcdFx0XHRcdGlmIChsb2NhdGlvblVSTCA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gSFRUUC1yZWRpcmVjdCBmZXRjaCBzdGVwIDVcblx0XHRcdFx0XHRcdGlmIChyZXF1ZXN0LmNvdW50ZXIgPj0gcmVxdWVzdC5mb2xsb3cpIHtcblx0XHRcdFx0XHRcdFx0cmVqZWN0KG5ldyBGZXRjaEVycm9yKGBtYXhpbXVtIHJlZGlyZWN0IHJlYWNoZWQgYXQ6ICR7cmVxdWVzdC51cmx9YCwgJ21heC1yZWRpcmVjdCcpKTtcblx0XHRcdFx0XHRcdFx0ZmluYWxpemUoKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBIVFRQLXJlZGlyZWN0IGZldGNoIHN0ZXAgNiAoY291bnRlciBpbmNyZW1lbnQpXG5cdFx0XHRcdFx0XHQvLyBDcmVhdGUgYSBuZXcgUmVxdWVzdCBvYmplY3QuXG5cdFx0XHRcdFx0XHRjb25zdCByZXF1ZXN0T3B0aW9ucyA9IHtcblx0XHRcdFx0XHRcdFx0aGVhZGVyczogbmV3IEhlYWRlcnMocmVxdWVzdC5oZWFkZXJzKSxcblx0XHRcdFx0XHRcdFx0Zm9sbG93OiByZXF1ZXN0LmZvbGxvdyxcblx0XHRcdFx0XHRcdFx0Y291bnRlcjogcmVxdWVzdC5jb3VudGVyICsgMSxcblx0XHRcdFx0XHRcdFx0YWdlbnQ6IHJlcXVlc3QuYWdlbnQsXG5cdFx0XHRcdFx0XHRcdGNvbXByZXNzOiByZXF1ZXN0LmNvbXByZXNzLFxuXHRcdFx0XHRcdFx0XHRtZXRob2Q6IHJlcXVlc3QubWV0aG9kLFxuXHRcdFx0XHRcdFx0XHQvLyBOb3RlOiBXZSBjYW4gbm90IHVzZSBgcmVxdWVzdC5ib2R5YCBiZWNhdXNlIHNlbmQgd291bGQgaGF2ZVxuXHRcdFx0XHRcdFx0XHQvLyBjb25zdW1lZCBpdCBhbHJlYWR5LlxuXHRcdFx0XHRcdFx0XHRib2R5OiBvcHRpb25zXy5ib2R5LFxuXHRcdFx0XHRcdFx0XHRzaWduYWw6IHNpZ25hbCxcblx0XHRcdFx0XHRcdFx0c2l6ZTogcmVxdWVzdC5zaXplXG5cdFx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0XHQvLyBIVFRQLXJlZGlyZWN0IGZldGNoIHN0ZXAgOVxuXHRcdFx0XHRcdFx0Y29uc3QgaXNTdHJlYW1Cb2R5ID1cblx0XHRcdFx0XHRcdFx0cmVxdWVzdE9wdGlvbnMuYm9keSBpbnN0YW5jZW9mIFJlYWRhYmxlU3RyZWFtIHx8XG5cdFx0XHRcdFx0XHRcdHJlcXVlc3RPcHRpb25zLmJvZHkgaW5zdGFuY2VvZiBTdHJlYW0uUmVhZGFibGU7XG5cdFx0XHRcdFx0XHRpZiAocmVzcG9uc2VfLnN0YXR1c0NvZGUgIT09IDMwMyAmJiBpc1N0cmVhbUJvZHkpIHtcblx0XHRcdFx0XHRcdFx0cmVqZWN0KG5ldyBGZXRjaEVycm9yKCdDYW5ub3QgZm9sbG93IHJlZGlyZWN0IHdpdGggYm9keSBiZWluZyBhIHJlYWRhYmxlIHN0cmVhbScsICd1bnN1cHBvcnRlZC1yZWRpcmVjdCcpKTtcblx0XHRcdFx0XHRcdFx0ZmluYWxpemUoKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBIVFRQLXJlZGlyZWN0IGZldGNoIHN0ZXAgMTFcblx0XHRcdFx0XHRcdGlmIChyZXNwb25zZV8uc3RhdHVzQ29kZSA9PT0gMzAzIHx8ICgocmVzcG9uc2VfLnN0YXR1c0NvZGUgPT09IDMwMSB8fCByZXNwb25zZV8uc3RhdHVzQ29kZSA9PT0gMzAyKSAmJiByZXF1ZXN0Lm1ldGhvZCA9PT0gJ1BPU1QnKSkge1xuXHRcdFx0XHRcdFx0XHRyZXF1ZXN0T3B0aW9ucy5tZXRob2QgPSAnR0VUJztcblx0XHRcdFx0XHRcdFx0cmVxdWVzdE9wdGlvbnMuYm9keSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdFx0cmVxdWVzdE9wdGlvbnMuaGVhZGVycy5kZWxldGUoJ2NvbnRlbnQtbGVuZ3RoJyk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIEhUVFAtcmVkaXJlY3QgZmV0Y2ggc3RlcCAxNVxuXHRcdFx0XHRcdFx0ZmV0Y2gobmV3IFJlcXVlc3QobG9jYXRpb25VUkwuaHJlZiwgcmVxdWVzdE9wdGlvbnMpKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG5cdFx0XHRcdFx0XHRmaW5hbGl6ZSgpO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVqZWN0KG5ldyBUeXBlRXJyb3IoYFJlZGlyZWN0IG9wdGlvbiAnJHtyZXF1ZXN0LnJlZGlyZWN0fScgaXMgbm90IGEgdmFsaWQgdmFsdWUgb2YgUmVxdWVzdFJlZGlyZWN0YCkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFByZXBhcmUgcmVzcG9uc2Vcblx0XHRcdGlmIChzaWduYWwpIHtcblx0XHRcdFx0cmVzcG9uc2VfLm9uY2UoJ2VuZCcsICgpID0+IHtcblx0XHRcdFx0XHRzaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydEFuZEZpbmFsaXplKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdGxldCBib2R5ID0gcHVtcChyZXNwb25zZV8sIG5ldyBQYXNzVGhyb3VnaCgpLCByZWplY3QpO1xuXHRcdFx0Ly8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9wdWxsLzI5Mzc2XG5cdFx0XHQvKiBjOCBpZ25vcmUgbmV4dCAzICovXG5cdFx0XHRpZiAocHJvY2Vzcy52ZXJzaW9uIDwgJ3YxMi4xMCcpIHtcblx0XHRcdFx0cmVzcG9uc2VfLm9uKCdhYm9ydGVkJywgYWJvcnRBbmRGaW5hbGl6ZSk7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHJlc3BvbnNlT3B0aW9ucyA9IHtcblx0XHRcdFx0dXJsOiByZXF1ZXN0LnVybCxcblx0XHRcdFx0c3RhdHVzOiByZXNwb25zZV8uc3RhdHVzQ29kZSxcblx0XHRcdFx0c3RhdHVzVGV4dDogcmVzcG9uc2VfLnN0YXR1c01lc3NhZ2UsXG5cdFx0XHRcdGhlYWRlcnMsXG5cdFx0XHRcdHNpemU6IHJlcXVlc3Quc2l6ZSxcblx0XHRcdFx0Y291bnRlcjogcmVxdWVzdC5jb3VudGVyLFxuXHRcdFx0XHRoaWdoV2F0ZXJNYXJrOiByZXF1ZXN0LmhpZ2hXYXRlck1hcmtcblx0XHRcdH07XG5cblx0XHRcdC8vIEhUVFAtbmV0d29yayBmZXRjaCBzdGVwIDEyLjEuMS4zXG5cdFx0XHRjb25zdCBjb2RpbmdzID0gaGVhZGVycy5nZXQoJ0NvbnRlbnQtRW5jb2RpbmcnKTtcblxuXHRcdFx0Ly8gSFRUUC1uZXR3b3JrIGZldGNoIHN0ZXAgMTIuMS4xLjQ6IGhhbmRsZSBjb250ZW50IGNvZGluZ3NcblxuXHRcdFx0Ly8gaW4gZm9sbG93aW5nIHNjZW5hcmlvcyB3ZSBpZ25vcmUgY29tcHJlc3Npb24gc3VwcG9ydFxuXHRcdFx0Ly8gMS4gY29tcHJlc3Npb24gc3VwcG9ydCBpcyBkaXNhYmxlZFxuXHRcdFx0Ly8gMi4gSEVBRCByZXF1ZXN0XG5cdFx0XHQvLyAzLiBubyBDb250ZW50LUVuY29kaW5nIGhlYWRlclxuXHRcdFx0Ly8gNC4gbm8gY29udGVudCByZXNwb25zZSAoMjA0KVxuXHRcdFx0Ly8gNS4gY29udGVudCBub3QgbW9kaWZpZWQgcmVzcG9uc2UgKDMwNClcblx0XHRcdGlmICghcmVxdWVzdC5jb21wcmVzcyB8fCByZXF1ZXN0Lm1ldGhvZCA9PT0gJ0hFQUQnIHx8IGNvZGluZ3MgPT09IG51bGwgfHwgcmVzcG9uc2VfLnN0YXR1c0NvZGUgPT09IDIwNCB8fCByZXNwb25zZV8uc3RhdHVzQ29kZSA9PT0gMzA0KSB7XG5cdFx0XHRcdHJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKGJvZHksIHJlc3BvbnNlT3B0aW9ucyk7XG5cdFx0XHRcdHJlc29sdmUocmVzcG9uc2UpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZvciBOb2RlIHY2K1xuXHRcdFx0Ly8gQmUgbGVzcyBzdHJpY3Qgd2hlbiBkZWNvZGluZyBjb21wcmVzc2VkIHJlc3BvbnNlcywgc2luY2Ugc29tZXRpbWVzXG5cdFx0XHQvLyBzZXJ2ZXJzIHNlbmQgc2xpZ2h0bHkgaW52YWxpZCByZXNwb25zZXMgdGhhdCBhcmUgc3RpbGwgYWNjZXB0ZWRcblx0XHRcdC8vIGJ5IGNvbW1vbiBicm93c2Vycy5cblx0XHRcdC8vIEFsd2F5cyB1c2luZyBaX1NZTkNfRkxVU0ggaXMgd2hhdCBjVVJMIGRvZXMuXG5cdFx0XHRjb25zdCB6bGliT3B0aW9ucyA9IHtcblx0XHRcdFx0Zmx1c2g6IHpsaWIuWl9TWU5DX0ZMVVNILFxuXHRcdFx0XHRmaW5pc2hGbHVzaDogemxpYi5aX1NZTkNfRkxVU0hcblx0XHRcdH07XG5cblx0XHRcdC8vIEZvciBnemlwXG5cdFx0XHRpZiAoY29kaW5ncyA9PT0gJ2d6aXAnIHx8IGNvZGluZ3MgPT09ICd4LWd6aXAnKSB7XG5cdFx0XHRcdGJvZHkgPSBwdW1wKGJvZHksIHpsaWIuY3JlYXRlR3VuemlwKHpsaWJPcHRpb25zKSwgcmVqZWN0KTtcblx0XHRcdFx0cmVzcG9uc2UgPSBuZXcgUmVzcG9uc2UoZnJvbUFzeW5jSXRlcmFibGUoYm9keSksIHJlc3BvbnNlT3B0aW9ucyk7XG5cdFx0XHRcdHJlc29sdmUocmVzcG9uc2UpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZvciBkZWZsYXRlXG5cdFx0XHRpZiAoY29kaW5ncyA9PT0gJ2RlZmxhdGUnIHx8IGNvZGluZ3MgPT09ICd4LWRlZmxhdGUnKSB7XG5cdFx0XHRcdC8vIEhhbmRsZSB0aGUgaW5mYW1vdXMgcmF3IGRlZmxhdGUgcmVzcG9uc2UgZnJvbSBvbGQgc2VydmVyc1xuXHRcdFx0XHQvLyBhIGhhY2sgZm9yIG9sZCBJSVMgYW5kIEFwYWNoZSBzZXJ2ZXJzXG5cdFx0XHRcdGNvbnN0IHJhdyA9IHB1bXAocmVzcG9uc2VfLCBuZXcgUGFzc1Rocm91Z2goKSwgcmVqZWN0KTtcblx0XHRcdFx0cmF3Lm9uY2UoJ2RhdGEnLCBjaHVuayA9PiB7XG5cdFx0XHRcdFx0Ly8gU2VlIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzc1MTk4Mjhcblx0XHRcdFx0XHRpZiAoKGNodW5rWzBdICYgMHgwRikgPT09IDB4MDgpIHtcblx0XHRcdFx0XHRcdGJvZHkgPSBwdW1wKGJvZHksIHpsaWIuY3JlYXRlSW5mbGF0ZSgpLCByZWplY3QpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRib2R5ID0gcHVtcChib2R5LCB6bGliLmNyZWF0ZUluZmxhdGVSYXcoKSwgcmVqZWN0KTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXNwb25zZSA9IG5ldyBSZXNwb25zZShmcm9tQXN5bmNJdGVyYWJsZShib2R5KSwgcmVzcG9uc2VPcHRpb25zKTtcblx0XHRcdFx0XHRyZXNvbHZlKHJlc3BvbnNlKTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRm9yIGJyXG5cdFx0XHRpZiAoY29kaW5ncyA9PT0gJ2JyJykge1xuXHRcdFx0XHRib2R5ID0gcHVtcChib2R5LCB6bGliLmNyZWF0ZUJyb3RsaURlY29tcHJlc3MoKSwgcmVqZWN0KTtcblx0XHRcdFx0cmVzcG9uc2UgPSBuZXcgUmVzcG9uc2UoZnJvbUFzeW5jSXRlcmFibGUoYm9keSksIHJlc3BvbnNlT3B0aW9ucyk7XG5cdFx0XHRcdHJlc29sdmUocmVzcG9uc2UpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIE90aGVyd2lzZSwgdXNlIHJlc3BvbnNlIGFzLWlzXG5cdFx0XHRyZXNwb25zZSA9IG5ldyBSZXNwb25zZShmcm9tQXN5bmNJdGVyYWJsZShib2R5KSwgcmVzcG9uc2VPcHRpb25zKTtcblx0XHRcdHJlc29sdmUocmVzcG9uc2UpO1xuXHRcdH0pO1xuXG5cdFx0d3JpdGVUb1N0cmVhbShyZXF1ZXN0XywgcmVxdWVzdCk7XG5cdH0pO1xufVxuXG4vKipcbiAqXG4gKiBAcGFyYW0ge2ltcG9ydCgnaHR0cCcpLkNsaWVudFJlcXVlc3R9IHJlcXVlc3RcbiAqIEBwYXJhbSB7KGVycm9yOkVycm9yKSA9PiB2b2lkfSBlcnJvckNhbGxiYWNrXG4gKi9cbmZ1bmN0aW9uIGZpeFJlc3BvbnNlQ2h1bmtlZFRyYW5zZmVyQmFkRW5kaW5nKHJlcXVlc3QsIGVycm9yQ2FsbGJhY2spIHtcblx0Y29uc3QgTEFTVF9DSFVOSyA9IEJ1ZmZlci5mcm9tKCcwXFxyXFxuXFxyXFxuJyk7XG5cblx0bGV0IGlzQ2h1bmtlZFRyYW5zZmVyID0gZmFsc2U7XG5cdGxldCBwcm9wZXJMYXN0Q2h1bmtSZWNlaXZlZCA9IGZhbHNlO1xuXHQvKiogQHR5cGUge0J1ZmZlciB8IHVuZGVmaW5lZH0gKi9cblx0bGV0IHByZXZpb3VzQ2h1bms7XG5cblx0cmVxdWVzdC5vbigncmVzcG9uc2UnLCByZXNwb25zZSA9PiB7XG5cdFx0Y29uc3Qge2hlYWRlcnN9ID0gcmVzcG9uc2U7XG5cdFx0aXNDaHVua2VkVHJhbnNmZXIgPSBoZWFkZXJzWyd0cmFuc2Zlci1lbmNvZGluZyddID09PSAnY2h1bmtlZCcgJiYgIWhlYWRlcnNbJ2NvbnRlbnQtbGVuZ3RoJ107XG5cdH0pO1xuXG5cdHJlcXVlc3Qub24oJ3NvY2tldCcsIHNvY2tldCA9PiB7XG5cdFx0Y29uc3Qgb25Tb2NrZXRDbG9zZSA9ICgpID0+IHtcblx0XHRcdGlmIChpc0NodW5rZWRUcmFuc2ZlciAmJiAhcHJvcGVyTGFzdENodW5rUmVjZWl2ZWQpIHtcblx0XHRcdFx0Y29uc3QgZXJyb3IgPSBPYmplY3QuYXNzaWduKG5ldyBFcnJvcignUHJlbWF0dXJlIGNsb3NlJyksIHtcblx0XHRcdFx0XHRjb2RlOiAnRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0UnXG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRlcnJvckNhbGxiYWNrKGVycm9yKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0LyoqIEBwYXJhbSB7QnVmZmVyfSBidWYgKi9cblx0XHRjb25zdCBvbkRhdGEgPSBidWYgPT4ge1xuXHRcdFx0cHJvcGVyTGFzdENodW5rUmVjZWl2ZWQgPSBCdWZmZXIuY29tcGFyZShidWYuc2xpY2UoLTUpLCBMQVNUX0NIVU5LKSA9PT0gMDtcblxuXHRcdFx0Ly8gU29tZXRpbWVzIGZpbmFsIDAtbGVuZ3RoIGNodW5rIGFuZCBlbmQgb2YgbWVzc2FnZSBjb2RlIGFyZSBpbiBzZXBhcmF0ZSBwYWNrZXRzXG5cdFx0XHRpZiAoIXByb3Blckxhc3RDaHVua1JlY2VpdmVkICYmIHByZXZpb3VzQ2h1bmspIHtcblx0XHRcdFx0cHJvcGVyTGFzdENodW5rUmVjZWl2ZWQgPSAoXG5cdFx0XHRcdFx0QnVmZmVyLmNvbXBhcmUocHJldmlvdXNDaHVuay5zbGljZSgtMyksIExBU1RfQ0hVTksuc2xpY2UoMCwgMykpID09PSAwICYmXG5cdFx0XHRcdFx0QnVmZmVyLmNvbXBhcmUoYnVmLnNsaWNlKC0yKSwgTEFTVF9DSFVOSy5zbGljZSgzKSkgPT09IDBcblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0cHJldmlvdXNDaHVuayA9IGJ1Zjtcblx0XHR9O1xuXG5cdFx0c29ja2V0LnByZXBlbmRMaXN0ZW5lcignY2xvc2UnLCBvblNvY2tldENsb3NlKTtcblx0XHRzb2NrZXQub24oJ2RhdGEnLCBvbkRhdGEpO1xuXG5cdFx0Y29uc3QgcmVtb3ZlU29ja2V0TGlzdGVuZXJzID0gKCkgPT4ge1xuXHRcdFx0c29ja2V0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uU29ja2V0Q2xvc2UpO1xuXHRcdFx0c29ja2V0LnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25EYXRhKTtcblx0XHR9XG5cblx0XHRyZXF1ZXN0Lm9uKCdjbG9zZScsIHJlbW92ZVNvY2tldExpc3RlbmVycyk7XG5cdFx0cmVxdWVzdC5vbignYWJvcnQnLCByZW1vdmVTb2NrZXRMaXN0ZW5lcnMpO1xuXHR9KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZmV0Y2hcbmV4cG9ydCB7IGZldGNoIH1cbiIsICJleHBvcnQgY29uc3QgbWltZXMgPSB7XG4gIFwiZXpcIjogXCJhcHBsaWNhdGlvbi9hbmRyZXctaW5zZXRcIixcbiAgXCJhd1wiOiBcImFwcGxpY2F0aW9uL2FwcGxpeHdhcmVcIixcbiAgXCJhdG9tXCI6IFwiYXBwbGljYXRpb24vYXRvbSt4bWxcIixcbiAgXCJhdG9tY2F0XCI6IFwiYXBwbGljYXRpb24vYXRvbWNhdCt4bWxcIixcbiAgXCJhdG9tZGVsZXRlZFwiOiBcImFwcGxpY2F0aW9uL2F0b21kZWxldGVkK3htbFwiLFxuICBcImF0b21zdmNcIjogXCJhcHBsaWNhdGlvbi9hdG9tc3ZjK3htbFwiLFxuICBcImR3ZFwiOiBcImFwcGxpY2F0aW9uL2F0c2MtZHdkK3htbFwiLFxuICBcImhlbGRcIjogXCJhcHBsaWNhdGlvbi9hdHNjLWhlbGQreG1sXCIsXG4gIFwicnNhdFwiOiBcImFwcGxpY2F0aW9uL2F0c2MtcnNhdCt4bWxcIixcbiAgXCJiZG9jXCI6IFwiYXBwbGljYXRpb24vYmRvY1wiLFxuICBcInhjc1wiOiBcImFwcGxpY2F0aW9uL2NhbGVuZGFyK3htbFwiLFxuICBcImNjeG1sXCI6IFwiYXBwbGljYXRpb24vY2N4bWwreG1sXCIsXG4gIFwiY2RmeFwiOiBcImFwcGxpY2F0aW9uL2NkZngreG1sXCIsXG4gIFwiY2RtaWFcIjogXCJhcHBsaWNhdGlvbi9jZG1pLWNhcGFiaWxpdHlcIixcbiAgXCJjZG1pY1wiOiBcImFwcGxpY2F0aW9uL2NkbWktY29udGFpbmVyXCIsXG4gIFwiY2RtaWRcIjogXCJhcHBsaWNhdGlvbi9jZG1pLWRvbWFpblwiLFxuICBcImNkbWlvXCI6IFwiYXBwbGljYXRpb24vY2RtaS1vYmplY3RcIixcbiAgXCJjZG1pcVwiOiBcImFwcGxpY2F0aW9uL2NkbWktcXVldWVcIixcbiAgXCJjdVwiOiBcImFwcGxpY2F0aW9uL2N1LXNlZW1lXCIsXG4gIFwibXBkXCI6IFwiYXBwbGljYXRpb24vZGFzaCt4bWxcIixcbiAgXCJkYXZtb3VudFwiOiBcImFwcGxpY2F0aW9uL2Rhdm1vdW50K3htbFwiLFxuICBcImRia1wiOiBcImFwcGxpY2F0aW9uL2RvY2Jvb2sreG1sXCIsXG4gIFwiZHNzY1wiOiBcImFwcGxpY2F0aW9uL2Rzc2MrZGVyXCIsXG4gIFwieGRzc2NcIjogXCJhcHBsaWNhdGlvbi9kc3NjK3htbFwiLFxuICBcImVzXCI6IFwiYXBwbGljYXRpb24vZWNtYXNjcmlwdFwiLFxuICBcImVjbWFcIjogXCJhcHBsaWNhdGlvbi9lY21hc2NyaXB0XCIsXG4gIFwiZW1tYVwiOiBcImFwcGxpY2F0aW9uL2VtbWEreG1sXCIsXG4gIFwiZW1vdGlvbm1sXCI6IFwiYXBwbGljYXRpb24vZW1vdGlvbm1sK3htbFwiLFxuICBcImVwdWJcIjogXCJhcHBsaWNhdGlvbi9lcHViK3ppcFwiLFxuICBcImV4aVwiOiBcImFwcGxpY2F0aW9uL2V4aVwiLFxuICBcImZkdFwiOiBcImFwcGxpY2F0aW9uL2ZkdCt4bWxcIixcbiAgXCJwZnJcIjogXCJhcHBsaWNhdGlvbi9mb250LXRkcGZyXCIsXG4gIFwiZ2VvanNvblwiOiBcImFwcGxpY2F0aW9uL2dlbytqc29uXCIsXG4gIFwiZ21sXCI6IFwiYXBwbGljYXRpb24vZ21sK3htbFwiLFxuICBcImdweFwiOiBcImFwcGxpY2F0aW9uL2dweCt4bWxcIixcbiAgXCJneGZcIjogXCJhcHBsaWNhdGlvbi9neGZcIixcbiAgXCJnelwiOiBcImFwcGxpY2F0aW9uL2d6aXBcIixcbiAgXCJoanNvblwiOiBcImFwcGxpY2F0aW9uL2hqc29uXCIsXG4gIFwic3RrXCI6IFwiYXBwbGljYXRpb24vaHlwZXJzdHVkaW9cIixcbiAgXCJpbmtcIjogXCJhcHBsaWNhdGlvbi9pbmttbCt4bWxcIixcbiAgXCJpbmttbFwiOiBcImFwcGxpY2F0aW9uL2lua21sK3htbFwiLFxuICBcImlwZml4XCI6IFwiYXBwbGljYXRpb24vaXBmaXhcIixcbiAgXCJpdHNcIjogXCJhcHBsaWNhdGlvbi9pdHMreG1sXCIsXG4gIFwiamFyXCI6IFwiYXBwbGljYXRpb24vamF2YS1hcmNoaXZlXCIsXG4gIFwid2FyXCI6IFwiYXBwbGljYXRpb24vamF2YS1hcmNoaXZlXCIsXG4gIFwiZWFyXCI6IFwiYXBwbGljYXRpb24vamF2YS1hcmNoaXZlXCIsXG4gIFwic2VyXCI6IFwiYXBwbGljYXRpb24vamF2YS1zZXJpYWxpemVkLW9iamVjdFwiLFxuICBcImNsYXNzXCI6IFwiYXBwbGljYXRpb24vamF2YS12bVwiLFxuICBcImpzXCI6IFwiYXBwbGljYXRpb24vamF2YXNjcmlwdFwiLFxuICBcIm1qc1wiOiBcImFwcGxpY2F0aW9uL2phdmFzY3JpcHRcIixcbiAgXCJqc29uXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICBcIm1hcFwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgXCJqc29uNVwiOiBcImFwcGxpY2F0aW9uL2pzb241XCIsXG4gIFwianNvbm1sXCI6IFwiYXBwbGljYXRpb24vanNvbm1sK2pzb25cIixcbiAgXCJqc29ubGRcIjogXCJhcHBsaWNhdGlvbi9sZCtqc29uXCIsXG4gIFwibGdyXCI6IFwiYXBwbGljYXRpb24vbGdyK3htbFwiLFxuICBcImxvc3R4bWxcIjogXCJhcHBsaWNhdGlvbi9sb3N0K3htbFwiLFxuICBcImhxeFwiOiBcImFwcGxpY2F0aW9uL21hYy1iaW5oZXg0MFwiLFxuICBcImNwdFwiOiBcImFwcGxpY2F0aW9uL21hYy1jb21wYWN0cHJvXCIsXG4gIFwibWFkc1wiOiBcImFwcGxpY2F0aW9uL21hZHMreG1sXCIsXG4gIFwid2VibWFuaWZlc3RcIjogXCJhcHBsaWNhdGlvbi9tYW5pZmVzdCtqc29uXCIsXG4gIFwibXJjXCI6IFwiYXBwbGljYXRpb24vbWFyY1wiLFxuICBcIm1yY3hcIjogXCJhcHBsaWNhdGlvbi9tYXJjeG1sK3htbFwiLFxuICBcIm1hXCI6IFwiYXBwbGljYXRpb24vbWF0aGVtYXRpY2FcIixcbiAgXCJuYlwiOiBcImFwcGxpY2F0aW9uL21hdGhlbWF0aWNhXCIsXG4gIFwibWJcIjogXCJhcHBsaWNhdGlvbi9tYXRoZW1hdGljYVwiLFxuICBcIm1hdGhtbFwiOiBcImFwcGxpY2F0aW9uL21hdGhtbCt4bWxcIixcbiAgXCJtYm94XCI6IFwiYXBwbGljYXRpb24vbWJveFwiLFxuICBcIm1zY21sXCI6IFwiYXBwbGljYXRpb24vbWVkaWFzZXJ2ZXJjb250cm9sK3htbFwiLFxuICBcIm1ldGFsaW5rXCI6IFwiYXBwbGljYXRpb24vbWV0YWxpbmsreG1sXCIsXG4gIFwibWV0YTRcIjogXCJhcHBsaWNhdGlvbi9tZXRhbGluazQreG1sXCIsXG4gIFwibWV0c1wiOiBcImFwcGxpY2F0aW9uL21ldHMreG1sXCIsXG4gIFwibWFlaVwiOiBcImFwcGxpY2F0aW9uL21tdC1hZWkreG1sXCIsXG4gIFwibXVzZFwiOiBcImFwcGxpY2F0aW9uL21tdC11c2QreG1sXCIsXG4gIFwibW9kc1wiOiBcImFwcGxpY2F0aW9uL21vZHMreG1sXCIsXG4gIFwibTIxXCI6IFwiYXBwbGljYXRpb24vbXAyMVwiLFxuICBcIm1wMjFcIjogXCJhcHBsaWNhdGlvbi9tcDIxXCIsXG4gIFwibXA0c1wiOiBcImFwcGxpY2F0aW9uL21wNFwiLFxuICBcIm00cFwiOiBcImFwcGxpY2F0aW9uL21wNFwiLFxuICBcImRvY1wiOiBcImFwcGxpY2F0aW9uL21zd29yZFwiLFxuICBcImRvdFwiOiBcImFwcGxpY2F0aW9uL21zd29yZFwiLFxuICBcIm14ZlwiOiBcImFwcGxpY2F0aW9uL214ZlwiLFxuICBcIm5xXCI6IFwiYXBwbGljYXRpb24vbi1xdWFkc1wiLFxuICBcIm50XCI6IFwiYXBwbGljYXRpb24vbi10cmlwbGVzXCIsXG4gIFwiY2pzXCI6IFwiYXBwbGljYXRpb24vbm9kZVwiLFxuICBcImJpblwiOiBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiLFxuICBcImRtc1wiOiBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiLFxuICBcImxyZlwiOiBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiLFxuICBcIm1hclwiOiBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiLFxuICBcInNvXCI6IFwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCIsXG4gIFwiZGlzdFwiOiBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiLFxuICBcImRpc3R6XCI6IFwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCIsXG4gIFwicGtnXCI6IFwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCIsXG4gIFwiYnBrXCI6IFwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCIsXG4gIFwiZHVtcFwiOiBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiLFxuICBcImVsY1wiOiBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiLFxuICBcImRlcGxveVwiOiBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiLFxuICBcImV4ZVwiOiBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiLFxuICBcImRsbFwiOiBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiLFxuICBcImRlYlwiOiBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiLFxuICBcImRtZ1wiOiBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiLFxuICBcImlzb1wiOiBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiLFxuICBcImltZ1wiOiBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiLFxuICBcIm1zaVwiOiBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiLFxuICBcIm1zcFwiOiBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiLFxuICBcIm1zbVwiOiBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiLFxuICBcImJ1ZmZlclwiOiBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiLFxuICBcIm9kYVwiOiBcImFwcGxpY2F0aW9uL29kYVwiLFxuICBcIm9wZlwiOiBcImFwcGxpY2F0aW9uL29lYnBzLXBhY2thZ2UreG1sXCIsXG4gIFwib2d4XCI6IFwiYXBwbGljYXRpb24vb2dnXCIsXG4gIFwib21kb2NcIjogXCJhcHBsaWNhdGlvbi9vbWRvYyt4bWxcIixcbiAgXCJvbmV0b2NcIjogXCJhcHBsaWNhdGlvbi9vbmVub3RlXCIsXG4gIFwib25ldG9jMlwiOiBcImFwcGxpY2F0aW9uL29uZW5vdGVcIixcbiAgXCJvbmV0bXBcIjogXCJhcHBsaWNhdGlvbi9vbmVub3RlXCIsXG4gIFwib25lcGtnXCI6IFwiYXBwbGljYXRpb24vb25lbm90ZVwiLFxuICBcIm94cHNcIjogXCJhcHBsaWNhdGlvbi9veHBzXCIsXG4gIFwicmVsb1wiOiBcImFwcGxpY2F0aW9uL3AycC1vdmVybGF5K3htbFwiLFxuICBcInhlclwiOiBcImFwcGxpY2F0aW9uL3BhdGNoLW9wcy1lcnJvcit4bWxcIixcbiAgXCJwZGZcIjogXCJhcHBsaWNhdGlvbi9wZGZcIixcbiAgXCJwZ3BcIjogXCJhcHBsaWNhdGlvbi9wZ3AtZW5jcnlwdGVkXCIsXG4gIFwiYXNjXCI6IFwiYXBwbGljYXRpb24vcGdwLXNpZ25hdHVyZVwiLFxuICBcInNpZ1wiOiBcImFwcGxpY2F0aW9uL3BncC1zaWduYXR1cmVcIixcbiAgXCJwcmZcIjogXCJhcHBsaWNhdGlvbi9waWNzLXJ1bGVzXCIsXG4gIFwicDEwXCI6IFwiYXBwbGljYXRpb24vcGtjczEwXCIsXG4gIFwicDdtXCI6IFwiYXBwbGljYXRpb24vcGtjczctbWltZVwiLFxuICBcInA3Y1wiOiBcImFwcGxpY2F0aW9uL3BrY3M3LW1pbWVcIixcbiAgXCJwN3NcIjogXCJhcHBsaWNhdGlvbi9wa2NzNy1zaWduYXR1cmVcIixcbiAgXCJwOFwiOiBcImFwcGxpY2F0aW9uL3BrY3M4XCIsXG4gIFwiYWNcIjogXCJhcHBsaWNhdGlvbi9wa2l4LWF0dHItY2VydFwiLFxuICBcImNlclwiOiBcImFwcGxpY2F0aW9uL3BraXgtY2VydFwiLFxuICBcImNybFwiOiBcImFwcGxpY2F0aW9uL3BraXgtY3JsXCIsXG4gIFwicGtpcGF0aFwiOiBcImFwcGxpY2F0aW9uL3BraXgtcGtpcGF0aFwiLFxuICBcInBraVwiOiBcImFwcGxpY2F0aW9uL3BraXhjbXBcIixcbiAgXCJwbHNcIjogXCJhcHBsaWNhdGlvbi9wbHMreG1sXCIsXG4gIFwiYWlcIjogXCJhcHBsaWNhdGlvbi9wb3N0c2NyaXB0XCIsXG4gIFwiZXBzXCI6IFwiYXBwbGljYXRpb24vcG9zdHNjcmlwdFwiLFxuICBcInBzXCI6IFwiYXBwbGljYXRpb24vcG9zdHNjcmlwdFwiLFxuICBcInByb3Z4XCI6IFwiYXBwbGljYXRpb24vcHJvdmVuYW5jZSt4bWxcIixcbiAgXCJjd3dcIjogXCJhcHBsaWNhdGlvbi9wcnMuY3d3XCIsXG4gIFwicHNrY3htbFwiOiBcImFwcGxpY2F0aW9uL3Bza2MreG1sXCIsXG4gIFwicmFtbFwiOiBcImFwcGxpY2F0aW9uL3JhbWwreWFtbFwiLFxuICBcInJkZlwiOiBcImFwcGxpY2F0aW9uL3JkZit4bWxcIixcbiAgXCJvd2xcIjogXCJhcHBsaWNhdGlvbi9yZGYreG1sXCIsXG4gIFwicmlmXCI6IFwiYXBwbGljYXRpb24vcmVnaW5mbyt4bWxcIixcbiAgXCJybmNcIjogXCJhcHBsaWNhdGlvbi9yZWxheC1uZy1jb21wYWN0LXN5bnRheFwiLFxuICBcInJsXCI6IFwiYXBwbGljYXRpb24vcmVzb3VyY2UtbGlzdHMreG1sXCIsXG4gIFwicmxkXCI6IFwiYXBwbGljYXRpb24vcmVzb3VyY2UtbGlzdHMtZGlmZit4bWxcIixcbiAgXCJyc1wiOiBcImFwcGxpY2F0aW9uL3Jscy1zZXJ2aWNlcyt4bWxcIixcbiAgXCJyYXBkXCI6IFwiYXBwbGljYXRpb24vcm91dGUtYXBkK3htbFwiLFxuICBcInNsc1wiOiBcImFwcGxpY2F0aW9uL3JvdXRlLXMtdHNpZCt4bWxcIixcbiAgXCJydXNkXCI6IFwiYXBwbGljYXRpb24vcm91dGUtdXNkK3htbFwiLFxuICBcImdiclwiOiBcImFwcGxpY2F0aW9uL3Jwa2ktZ2hvc3RidXN0ZXJzXCIsXG4gIFwibWZ0XCI6IFwiYXBwbGljYXRpb24vcnBraS1tYW5pZmVzdFwiLFxuICBcInJvYVwiOiBcImFwcGxpY2F0aW9uL3Jwa2ktcm9hXCIsXG4gIFwicnNkXCI6IFwiYXBwbGljYXRpb24vcnNkK3htbFwiLFxuICBcInJzc1wiOiBcImFwcGxpY2F0aW9uL3Jzcyt4bWxcIixcbiAgXCJydGZcIjogXCJhcHBsaWNhdGlvbi9ydGZcIixcbiAgXCJzYm1sXCI6IFwiYXBwbGljYXRpb24vc2JtbCt4bWxcIixcbiAgXCJzY3FcIjogXCJhcHBsaWNhdGlvbi9zY3ZwLWN2LXJlcXVlc3RcIixcbiAgXCJzY3NcIjogXCJhcHBsaWNhdGlvbi9zY3ZwLWN2LXJlc3BvbnNlXCIsXG4gIFwic3BxXCI6IFwiYXBwbGljYXRpb24vc2N2cC12cC1yZXF1ZXN0XCIsXG4gIFwic3BwXCI6IFwiYXBwbGljYXRpb24vc2N2cC12cC1yZXNwb25zZVwiLFxuICBcInNkcFwiOiBcImFwcGxpY2F0aW9uL3NkcFwiLFxuICBcInNlbm1seFwiOiBcImFwcGxpY2F0aW9uL3Nlbm1sK3htbFwiLFxuICBcInNlbnNtbHhcIjogXCJhcHBsaWNhdGlvbi9zZW5zbWwreG1sXCIsXG4gIFwic2V0cGF5XCI6IFwiYXBwbGljYXRpb24vc2V0LXBheW1lbnQtaW5pdGlhdGlvblwiLFxuICBcInNldHJlZ1wiOiBcImFwcGxpY2F0aW9uL3NldC1yZWdpc3RyYXRpb24taW5pdGlhdGlvblwiLFxuICBcInNoZlwiOiBcImFwcGxpY2F0aW9uL3NoZit4bWxcIixcbiAgXCJzaXZcIjogXCJhcHBsaWNhdGlvbi9zaWV2ZVwiLFxuICBcInNpZXZlXCI6IFwiYXBwbGljYXRpb24vc2lldmVcIixcbiAgXCJzbWlcIjogXCJhcHBsaWNhdGlvbi9zbWlsK3htbFwiLFxuICBcInNtaWxcIjogXCJhcHBsaWNhdGlvbi9zbWlsK3htbFwiLFxuICBcInJxXCI6IFwiYXBwbGljYXRpb24vc3BhcnFsLXF1ZXJ5XCIsXG4gIFwic3J4XCI6IFwiYXBwbGljYXRpb24vc3BhcnFsLXJlc3VsdHMreG1sXCIsXG4gIFwiZ3JhbVwiOiBcImFwcGxpY2F0aW9uL3NyZ3NcIixcbiAgXCJncnhtbFwiOiBcImFwcGxpY2F0aW9uL3NyZ3MreG1sXCIsXG4gIFwic3J1XCI6IFwiYXBwbGljYXRpb24vc3J1K3htbFwiLFxuICBcInNzZGxcIjogXCJhcHBsaWNhdGlvbi9zc2RsK3htbFwiLFxuICBcInNzbWxcIjogXCJhcHBsaWNhdGlvbi9zc21sK3htbFwiLFxuICBcInN3aWR0YWdcIjogXCJhcHBsaWNhdGlvbi9zd2lkK3htbFwiLFxuICBcInRlaVwiOiBcImFwcGxpY2F0aW9uL3RlaSt4bWxcIixcbiAgXCJ0ZWljb3JwdXNcIjogXCJhcHBsaWNhdGlvbi90ZWkreG1sXCIsXG4gIFwidGZpXCI6IFwiYXBwbGljYXRpb24vdGhyYXVkK3htbFwiLFxuICBcInRzZFwiOiBcImFwcGxpY2F0aW9uL3RpbWVzdGFtcGVkLWRhdGFcIixcbiAgXCJ0b21sXCI6IFwiYXBwbGljYXRpb24vdG9tbFwiLFxuICBcInRyaWdcIjogXCJhcHBsaWNhdGlvbi90cmlnXCIsXG4gIFwidHRtbFwiOiBcImFwcGxpY2F0aW9uL3R0bWwreG1sXCIsXG4gIFwidWJqXCI6IFwiYXBwbGljYXRpb24vdWJqc29uXCIsXG4gIFwicnNoZWV0XCI6IFwiYXBwbGljYXRpb24vdXJjLXJlc3NoZWV0K3htbFwiLFxuICBcInRkXCI6IFwiYXBwbGljYXRpb24vdXJjLXRhcmdldGRlc2MreG1sXCIsXG4gIFwidnhtbFwiOiBcImFwcGxpY2F0aW9uL3ZvaWNleG1sK3htbFwiLFxuICBcIndhc21cIjogXCJhcHBsaWNhdGlvbi93YXNtXCIsXG4gIFwid2d0XCI6IFwiYXBwbGljYXRpb24vd2lkZ2V0XCIsXG4gIFwiaGxwXCI6IFwiYXBwbGljYXRpb24vd2luaGxwXCIsXG4gIFwid3NkbFwiOiBcImFwcGxpY2F0aW9uL3dzZGwreG1sXCIsXG4gIFwid3Nwb2xpY3lcIjogXCJhcHBsaWNhdGlvbi93c3BvbGljeSt4bWxcIixcbiAgXCJ4YW1sXCI6IFwiYXBwbGljYXRpb24veGFtbCt4bWxcIixcbiAgXCJ4YXZcIjogXCJhcHBsaWNhdGlvbi94Y2FwLWF0dCt4bWxcIixcbiAgXCJ4Y2FcIjogXCJhcHBsaWNhdGlvbi94Y2FwLWNhcHMreG1sXCIsXG4gIFwieGRmXCI6IFwiYXBwbGljYXRpb24veGNhcC1kaWZmK3htbFwiLFxuICBcInhlbFwiOiBcImFwcGxpY2F0aW9uL3hjYXAtZWwreG1sXCIsXG4gIFwieG5zXCI6IFwiYXBwbGljYXRpb24veGNhcC1ucyt4bWxcIixcbiAgXCJ4ZW5jXCI6IFwiYXBwbGljYXRpb24veGVuYyt4bWxcIixcbiAgXCJ4aHRtbFwiOiBcImFwcGxpY2F0aW9uL3hodG1sK3htbFwiLFxuICBcInhodFwiOiBcImFwcGxpY2F0aW9uL3hodG1sK3htbFwiLFxuICBcInhsZlwiOiBcImFwcGxpY2F0aW9uL3hsaWZmK3htbFwiLFxuICBcInhtbFwiOiBcImFwcGxpY2F0aW9uL3htbFwiLFxuICBcInhzbFwiOiBcImFwcGxpY2F0aW9uL3htbFwiLFxuICBcInhzZFwiOiBcImFwcGxpY2F0aW9uL3htbFwiLFxuICBcInJuZ1wiOiBcImFwcGxpY2F0aW9uL3htbFwiLFxuICBcImR0ZFwiOiBcImFwcGxpY2F0aW9uL3htbC1kdGRcIixcbiAgXCJ4b3BcIjogXCJhcHBsaWNhdGlvbi94b3AreG1sXCIsXG4gIFwieHBsXCI6IFwiYXBwbGljYXRpb24veHByb2MreG1sXCIsXG4gIFwieHNsdFwiOiBcImFwcGxpY2F0aW9uL3htbFwiLFxuICBcInhzcGZcIjogXCJhcHBsaWNhdGlvbi94c3BmK3htbFwiLFxuICBcIm14bWxcIjogXCJhcHBsaWNhdGlvbi94dit4bWxcIixcbiAgXCJ4aHZtbFwiOiBcImFwcGxpY2F0aW9uL3h2K3htbFwiLFxuICBcInh2bWxcIjogXCJhcHBsaWNhdGlvbi94dit4bWxcIixcbiAgXCJ4dm1cIjogXCJhcHBsaWNhdGlvbi94dit4bWxcIixcbiAgXCJ5YW5nXCI6IFwiYXBwbGljYXRpb24veWFuZ1wiLFxuICBcInlpblwiOiBcImFwcGxpY2F0aW9uL3lpbit4bWxcIixcbiAgXCJ6aXBcIjogXCJhcHBsaWNhdGlvbi96aXBcIixcbiAgXCIzZ3BwXCI6IFwidmlkZW8vM2dwcFwiLFxuICBcImFkcFwiOiBcImF1ZGlvL2FkcGNtXCIsXG4gIFwiYW1yXCI6IFwiYXVkaW8vYW1yXCIsXG4gIFwiYXVcIjogXCJhdWRpby9iYXNpY1wiLFxuICBcInNuZFwiOiBcImF1ZGlvL2Jhc2ljXCIsXG4gIFwibWlkXCI6IFwiYXVkaW8vbWlkaVwiLFxuICBcIm1pZGlcIjogXCJhdWRpby9taWRpXCIsXG4gIFwia2FyXCI6IFwiYXVkaW8vbWlkaVwiLFxuICBcInJtaVwiOiBcImF1ZGlvL21pZGlcIixcbiAgXCJteG1mXCI6IFwiYXVkaW8vbW9iaWxlLXhtZlwiLFxuICBcIm1wM1wiOiBcImF1ZGlvL21wZWdcIixcbiAgXCJtNGFcIjogXCJhdWRpby9tcDRcIixcbiAgXCJtcDRhXCI6IFwiYXVkaW8vbXA0XCIsXG4gIFwibXBnYVwiOiBcImF1ZGlvL21wZWdcIixcbiAgXCJtcDJcIjogXCJhdWRpby9tcGVnXCIsXG4gIFwibXAyYVwiOiBcImF1ZGlvL21wZWdcIixcbiAgXCJtMmFcIjogXCJhdWRpby9tcGVnXCIsXG4gIFwibTNhXCI6IFwiYXVkaW8vbXBlZ1wiLFxuICBcIm9nYVwiOiBcImF1ZGlvL29nZ1wiLFxuICBcIm9nZ1wiOiBcImF1ZGlvL29nZ1wiLFxuICBcInNweFwiOiBcImF1ZGlvL29nZ1wiLFxuICBcIm9wdXNcIjogXCJhdWRpby9vZ2dcIixcbiAgXCJzM21cIjogXCJhdWRpby9zM21cIixcbiAgXCJzaWxcIjogXCJhdWRpby9zaWxrXCIsXG4gIFwid2F2XCI6IFwiYXVkaW8vd2F2XCIsXG4gIFwid2ViYVwiOiBcImF1ZGlvL3dlYm1cIixcbiAgXCJ4bVwiOiBcImF1ZGlvL3htXCIsXG4gIFwidHRjXCI6IFwiZm9udC9jb2xsZWN0aW9uXCIsXG4gIFwib3RmXCI6IFwiZm9udC9vdGZcIixcbiAgXCJ0dGZcIjogXCJmb250L3R0ZlwiLFxuICBcIndvZmZcIjogXCJmb250L3dvZmZcIixcbiAgXCJ3b2ZmMlwiOiBcImZvbnQvd29mZjJcIixcbiAgXCJleHJcIjogXCJpbWFnZS9hY2VzXCIsXG4gIFwiYXBuZ1wiOiBcImltYWdlL2FwbmdcIixcbiAgXCJhdmlmXCI6IFwiaW1hZ2UvYXZpZlwiLFxuICBcImJtcFwiOiBcImltYWdlL2JtcFwiLFxuICBcImNnbVwiOiBcImltYWdlL2NnbVwiLFxuICBcImRybGVcIjogXCJpbWFnZS9kaWNvbS1ybGVcIixcbiAgXCJlbWZcIjogXCJpbWFnZS9lbWZcIixcbiAgXCJmaXRzXCI6IFwiaW1hZ2UvZml0c1wiLFxuICBcImczXCI6IFwiaW1hZ2UvZzNmYXhcIixcbiAgXCJnaWZcIjogXCJpbWFnZS9naWZcIixcbiAgXCJoZWljXCI6IFwiaW1hZ2UvaGVpY1wiLFxuICBcImhlaWNzXCI6IFwiaW1hZ2UvaGVpYy1zZXF1ZW5jZVwiLFxuICBcImhlaWZcIjogXCJpbWFnZS9oZWlmXCIsXG4gIFwiaGVpZnNcIjogXCJpbWFnZS9oZWlmLXNlcXVlbmNlXCIsXG4gIFwiaGVqMlwiOiBcImltYWdlL2hlajJrXCIsXG4gIFwiaHNqMlwiOiBcImltYWdlL2hzajJcIixcbiAgXCJpZWZcIjogXCJpbWFnZS9pZWZcIixcbiAgXCJqbHNcIjogXCJpbWFnZS9qbHNcIixcbiAgXCJqcDJcIjogXCJpbWFnZS9qcDJcIixcbiAgXCJqcGcyXCI6IFwiaW1hZ2UvanAyXCIsXG4gIFwianBlZ1wiOiBcImltYWdlL2pwZWdcIixcbiAgXCJqcGdcIjogXCJpbWFnZS9qcGVnXCIsXG4gIFwianBlXCI6IFwiaW1hZ2UvanBlZ1wiLFxuICBcImpwaFwiOiBcImltYWdlL2pwaFwiLFxuICBcImpoY1wiOiBcImltYWdlL2pwaGNcIixcbiAgXCJqcG1cIjogXCJpbWFnZS9qcG1cIixcbiAgXCJqcHhcIjogXCJpbWFnZS9qcHhcIixcbiAgXCJqcGZcIjogXCJpbWFnZS9qcHhcIixcbiAgXCJqeHJcIjogXCJpbWFnZS9qeHJcIixcbiAgXCJqeHJhXCI6IFwiaW1hZ2UvanhyYVwiLFxuICBcImp4cnNcIjogXCJpbWFnZS9qeHJzXCIsXG4gIFwianhzXCI6IFwiaW1hZ2UvanhzXCIsXG4gIFwianhzY1wiOiBcImltYWdlL2p4c2NcIixcbiAgXCJqeHNpXCI6IFwiaW1hZ2UvanhzaVwiLFxuICBcImp4c3NcIjogXCJpbWFnZS9qeHNzXCIsXG4gIFwia3R4XCI6IFwiaW1hZ2Uva3R4XCIsXG4gIFwia3R4MlwiOiBcImltYWdlL2t0eDJcIixcbiAgXCJwbmdcIjogXCJpbWFnZS9wbmdcIixcbiAgXCJidGlmXCI6IFwiaW1hZ2UvcHJzLmJ0aWZcIixcbiAgXCJwdGlcIjogXCJpbWFnZS9wcnMucHRpXCIsXG4gIFwic2dpXCI6IFwiaW1hZ2Uvc2dpXCIsXG4gIFwic3ZnXCI6IFwiaW1hZ2Uvc3ZnK3htbFwiLFxuICBcInN2Z3pcIjogXCJpbWFnZS9zdmcreG1sXCIsXG4gIFwidDM4XCI6IFwiaW1hZ2UvdDM4XCIsXG4gIFwidGlmXCI6IFwiaW1hZ2UvdGlmZlwiLFxuICBcInRpZmZcIjogXCJpbWFnZS90aWZmXCIsXG4gIFwidGZ4XCI6IFwiaW1hZ2UvdGlmZi1meFwiLFxuICBcIndlYnBcIjogXCJpbWFnZS93ZWJwXCIsXG4gIFwid21mXCI6IFwiaW1hZ2Uvd21mXCIsXG4gIFwiZGlzcG9zaXRpb24tbm90aWZpY2F0aW9uXCI6IFwibWVzc2FnZS9kaXNwb3NpdGlvbi1ub3RpZmljYXRpb25cIixcbiAgXCJ1OG1zZ1wiOiBcIm1lc3NhZ2UvZ2xvYmFsXCIsXG4gIFwidThkc25cIjogXCJtZXNzYWdlL2dsb2JhbC1kZWxpdmVyeS1zdGF0dXNcIixcbiAgXCJ1OG1kblwiOiBcIm1lc3NhZ2UvZ2xvYmFsLWRpc3Bvc2l0aW9uLW5vdGlmaWNhdGlvblwiLFxuICBcInU4aGRyXCI6IFwibWVzc2FnZS9nbG9iYWwtaGVhZGVyc1wiLFxuICBcImVtbFwiOiBcIm1lc3NhZ2UvcmZjODIyXCIsXG4gIFwibWltZVwiOiBcIm1lc3NhZ2UvcmZjODIyXCIsXG4gIFwiM21mXCI6IFwibW9kZWwvM21mXCIsXG4gIFwiZ2x0ZlwiOiBcIm1vZGVsL2dsdGYranNvblwiLFxuICBcImdsYlwiOiBcIm1vZGVsL2dsdGYtYmluYXJ5XCIsXG4gIFwiaWdzXCI6IFwibW9kZWwvaWdlc1wiLFxuICBcImlnZXNcIjogXCJtb2RlbC9pZ2VzXCIsXG4gIFwibXNoXCI6IFwibW9kZWwvbWVzaFwiLFxuICBcIm1lc2hcIjogXCJtb2RlbC9tZXNoXCIsXG4gIFwic2lsb1wiOiBcIm1vZGVsL21lc2hcIixcbiAgXCJtdGxcIjogXCJtb2RlbC9tdGxcIixcbiAgXCJvYmpcIjogXCJtb2RlbC9vYmpcIixcbiAgXCJzdHB6XCI6IFwibW9kZWwvc3RlcCt6aXBcIixcbiAgXCJzdHB4elwiOiBcIm1vZGVsL3N0ZXAteG1sK3ppcFwiLFxuICBcInN0bFwiOiBcIm1vZGVsL3N0bFwiLFxuICBcIndybFwiOiBcIm1vZGVsL3ZybWxcIixcbiAgXCJ2cm1sXCI6IFwibW9kZWwvdnJtbFwiLFxuICBcIngzZGJcIjogXCJtb2RlbC94M2QrZmFzdGluZm9zZXRcIixcbiAgXCJ4M2RielwiOiBcIm1vZGVsL3gzZCtiaW5hcnlcIixcbiAgXCJ4M2R2XCI6IFwibW9kZWwveDNkLXZybWxcIixcbiAgXCJ4M2R2elwiOiBcIm1vZGVsL3gzZCt2cm1sXCIsXG4gIFwieDNkXCI6IFwibW9kZWwveDNkK3htbFwiLFxuICBcIngzZHpcIjogXCJtb2RlbC94M2QreG1sXCIsXG4gIFwiYXBwY2FjaGVcIjogXCJ0ZXh0L2NhY2hlLW1hbmlmZXN0XCIsXG4gIFwibWFuaWZlc3RcIjogXCJ0ZXh0L2NhY2hlLW1hbmlmZXN0XCIsXG4gIFwiaWNzXCI6IFwidGV4dC9jYWxlbmRhclwiLFxuICBcImlmYlwiOiBcInRleHQvY2FsZW5kYXJcIixcbiAgXCJjb2ZmZWVcIjogXCJ0ZXh0L2NvZmZlZXNjcmlwdFwiLFxuICBcImxpdGNvZmZlZVwiOiBcInRleHQvY29mZmVlc2NyaXB0XCIsXG4gIFwiY3NzXCI6IFwidGV4dC9jc3NcIixcbiAgXCJjc3ZcIjogXCJ0ZXh0L2NzdlwiLFxuICBcImh0bWxcIjogXCJ0ZXh0L2h0bWxcIixcbiAgXCJodG1cIjogXCJ0ZXh0L2h0bWxcIixcbiAgXCJzaHRtbFwiOiBcInRleHQvaHRtbFwiLFxuICBcImphZGVcIjogXCJ0ZXh0L2phZGVcIixcbiAgXCJqc3hcIjogXCJ0ZXh0L2pzeFwiLFxuICBcImxlc3NcIjogXCJ0ZXh0L2xlc3NcIixcbiAgXCJtYXJrZG93blwiOiBcInRleHQvbWFya2Rvd25cIixcbiAgXCJtZFwiOiBcInRleHQvbWFya2Rvd25cIixcbiAgXCJtbWxcIjogXCJ0ZXh0L21hdGhtbFwiLFxuICBcIm1keFwiOiBcInRleHQvbWR4XCIsXG4gIFwibjNcIjogXCJ0ZXh0L24zXCIsXG4gIFwidHh0XCI6IFwidGV4dC9wbGFpblwiLFxuICBcInRleHRcIjogXCJ0ZXh0L3BsYWluXCIsXG4gIFwiY29uZlwiOiBcInRleHQvcGxhaW5cIixcbiAgXCJkZWZcIjogXCJ0ZXh0L3BsYWluXCIsXG4gIFwibGlzdFwiOiBcInRleHQvcGxhaW5cIixcbiAgXCJsb2dcIjogXCJ0ZXh0L3BsYWluXCIsXG4gIFwiaW5cIjogXCJ0ZXh0L3BsYWluXCIsXG4gIFwiaW5pXCI6IFwidGV4dC9wbGFpblwiLFxuICBcImRzY1wiOiBcInRleHQvcHJzLmxpbmVzLnRhZ1wiLFxuICBcInJ0eFwiOiBcInRleHQvcmljaHRleHRcIixcbiAgXCJzZ21sXCI6IFwidGV4dC9zZ21sXCIsXG4gIFwic2dtXCI6IFwidGV4dC9zZ21sXCIsXG4gIFwic2hleFwiOiBcInRleHQvc2hleFwiLFxuICBcInNsaW1cIjogXCJ0ZXh0L3NsaW1cIixcbiAgXCJzbG1cIjogXCJ0ZXh0L3NsaW1cIixcbiAgXCJzcGR4XCI6IFwidGV4dC9zcGR4XCIsXG4gIFwic3R5bHVzXCI6IFwidGV4dC9zdHlsdXNcIixcbiAgXCJzdHlsXCI6IFwidGV4dC9zdHlsdXNcIixcbiAgXCJ0c3ZcIjogXCJ0ZXh0L3RhYi1zZXBhcmF0ZWQtdmFsdWVzXCIsXG4gIFwidFwiOiBcInRleHQvdHJvZmZcIixcbiAgXCJ0clwiOiBcInRleHQvdHJvZmZcIixcbiAgXCJyb2ZmXCI6IFwidGV4dC90cm9mZlwiLFxuICBcIm1hblwiOiBcInRleHQvdHJvZmZcIixcbiAgXCJtZVwiOiBcInRleHQvdHJvZmZcIixcbiAgXCJtc1wiOiBcInRleHQvdHJvZmZcIixcbiAgXCJ0dGxcIjogXCJ0ZXh0L3R1cnRsZVwiLFxuICBcInVyaVwiOiBcInRleHQvdXJpLWxpc3RcIixcbiAgXCJ1cmlzXCI6IFwidGV4dC91cmktbGlzdFwiLFxuICBcInVybHNcIjogXCJ0ZXh0L3VyaS1saXN0XCIsXG4gIFwidmNhcmRcIjogXCJ0ZXh0L3ZjYXJkXCIsXG4gIFwidnR0XCI6IFwidGV4dC92dHRcIixcbiAgXCJ5YW1sXCI6IFwidGV4dC95YW1sXCIsXG4gIFwieW1sXCI6IFwidGV4dC95YW1sXCIsXG4gIFwiM2dwXCI6IFwidmlkZW8vM2dwcFwiLFxuICBcIjNnMlwiOiBcInZpZGVvLzNncHAyXCIsXG4gIFwiaDI2MVwiOiBcInZpZGVvL2gyNjFcIixcbiAgXCJoMjYzXCI6IFwidmlkZW8vaDI2M1wiLFxuICBcImgyNjRcIjogXCJ2aWRlby9oMjY0XCIsXG4gIFwibTRzXCI6IFwidmlkZW8vaXNvLnNlZ21lbnRcIixcbiAgXCJqcGd2XCI6IFwidmlkZW8vanBlZ1wiLFxuICBcImpwZ21cIjogXCJpbWFnZS9qcG1cIixcbiAgXCJtajJcIjogXCJ2aWRlby9tajJcIixcbiAgXCJtanAyXCI6IFwidmlkZW8vbWoyXCIsXG4gIFwidHNcIjogXCJ2aWRlby9tcDJ0XCIsXG4gIFwibXA0XCI6IFwidmlkZW8vbXA0XCIsXG4gIFwibXA0dlwiOiBcInZpZGVvL21wNFwiLFxuICBcIm1wZzRcIjogXCJ2aWRlby9tcDRcIixcbiAgXCJtcGVnXCI6IFwidmlkZW8vbXBlZ1wiLFxuICBcIm1wZ1wiOiBcInZpZGVvL21wZWdcIixcbiAgXCJtcGVcIjogXCJ2aWRlby9tcGVnXCIsXG4gIFwibTF2XCI6IFwidmlkZW8vbXBlZ1wiLFxuICBcIm0ydlwiOiBcInZpZGVvL21wZWdcIixcbiAgXCJvZ3ZcIjogXCJ2aWRlby9vZ2dcIixcbiAgXCJxdFwiOiBcInZpZGVvL3F1aWNrdGltZVwiLFxuICBcIm1vdlwiOiBcInZpZGVvL3F1aWNrdGltZVwiLFxuICBcIndlYm1cIjogXCJ2aWRlby93ZWJtXCJcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBsb29rdXAoZXh0bikge1xuXHRsZXQgdG1wID0gKCcnICsgZXh0bikudHJpbSgpLnRvTG93ZXJDYXNlKCk7XG5cdGxldCBpZHggPSB0bXAubGFzdEluZGV4T2YoJy4nKTtcblx0cmV0dXJuIG1pbWVzWyF+aWR4ID8gdG1wIDogdG1wLnN1YnN0cmluZygrK2lkeCldO1xufVxuIiwgIi8vIEB0cy1jaGVja1xuLyoqXG4gKiBCb2R5LmpzXG4gKlxuICogQm9keSBpbnRlcmZhY2UgcHJvdmlkZXMgY29tbW9uIG1ldGhvZHMgZm9yIFJlcXVlc3QgYW5kIFJlc3BvbnNlXG4gKi9cblxuaW1wb3J0IFN0cmVhbSBmcm9tICdzdHJlYW0nO1xuaW1wb3J0IHt0eXBlc30gZnJvbSAndXRpbCc7XG5cbmltcG9ydCB7QmxvYiwgUmVhZGFibGVTdHJlYW19IGZyb20gJy4vcGFja2FnZS5qcyc7XG5cbmltcG9ydCB7RmV0Y2hFcnJvcn0gZnJvbSAnLi9lcnJvcnMvZmV0Y2gtZXJyb3IuanMnO1xuaW1wb3J0IHtGZXRjaEJhc2VFcnJvcn0gZnJvbSAnLi9lcnJvcnMvYmFzZS5qcyc7XG5pbXBvcnQge2Zvcm1EYXRhSXRlcmF0b3IsIGdldEJvdW5kYXJ5LCBnZXRGb3JtRGF0YUxlbmd0aCwgdG9Gb3JtRGF0YX0gZnJvbSAnLi91dGlscy9mb3JtLWRhdGEuanMnO1xuaW1wb3J0IHtpc0Jsb2IsIGlzVVJMU2VhcmNoUGFyYW1ldGVycywgaXNGb3JtRGF0YSwgaXNNdWx0aXBhcnRGb3JtRGF0YVN0cmVhbSwgaXNSZWFkYWJsZVN0cmVhbX0gZnJvbSAnLi91dGlscy9pcy5qcyc7XG5pbXBvcnQgKiBhcyB1dGY4IGZyb20gJy4vdXRpbHMvdXRmOC5qcyc7XG5jb25zdCB7cmVhZGFibGVIaWdoV2F0ZXJNYXJrfSA9IG5ldyBTdHJlYW0uUmVhZGFibGUoKTtcblxuY29uc3QgSU5URVJOQUxTID0gU3ltYm9sKCdCb2R5IGludGVybmFscycpO1xuXG4vKipcbiAqIEJvZHkgbWl4aW5cbiAqXG4gKiBSZWY6IGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNib2R5XG4gKiBAaW1wbGVtZW50cyB7Z2xvYmFsVGhpcy5Cb2R5fVxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJvZHkge1xuXHQvKipcblx0ICogQHBhcmFtIHtCb2R5SW5pdHxTdHJlYW18bnVsbH0gYm9keVxuXHQgKiBAcGFyYW0ge3tzaXplPzpudW1iZXJ9fSBvcHRpb25zXG5cdCAqL1xuXHRjb25zdHJ1Y3Rvcihib2R5LCB7XG5cdFx0c2l6ZSA9IDBcblx0fSA9IHt9KSB7XG5cdFx0Y29uc3Qgc3RhdGUgPSB7XG5cdFx0XHQvKiogQHR5cGUge251bGx8UmVhZGFibGVTdHJlYW08VWludDhBcnJheT59ICovXG5cdFx0XHRib2R5OiBudWxsLFxuXHRcdFx0LyoqIEB0eXBlIHtzdHJpbmd8bnVsbH0gKi9cblx0XHRcdHR5cGU6IG51bGwsXG5cdFx0XHQvKiogQHR5cGUge251bWJlcnxudWxsfSAqL1xuXHRcdFx0c2l6ZTogbnVsbCxcblx0XHRcdC8qKiBAdHlwZSB7bnVsbHxzdHJpbmd9ICovXG5cdFx0XHRib3VuZGFyeTogbnVsbCxcblx0XHRcdGRpc3R1cmJlZDogZmFsc2UsXG5cdFx0XHQvKiogQHR5cGUge251bGx8RXJyb3J9ICovXG5cdFx0XHRlcnJvcjogbnVsbFxuXHRcdH07XG5cdFx0LyoqIEBwcml2YXRlICovXG5cdFx0dGhpc1tJTlRFUk5BTFNdID0gc3RhdGU7XG5cblx0XHRpZiAoYm9keSA9PT0gbnVsbCkge1xuXHRcdFx0Ly8gQm9keSBpcyB1bmRlZmluZWQgb3IgbnVsbFxuXHRcdFx0c3RhdGUuYm9keSA9IG51bGw7XG5cdFx0XHRzdGF0ZS5zaXplID0gMDtcblx0XHR9IGVsc2UgaWYgKGlzVVJMU2VhcmNoUGFyYW1ldGVycyhib2R5KSkge1xuXHRcdC8vIEJvZHkgaXMgYSBVUkxTZWFyY2hQYXJhbXNcblx0XHRcdGNvbnN0IGJ5dGVzID0gdXRmOC5lbmNvZGUoYm9keS50b1N0cmluZygpKTtcblx0XHRcdHN0YXRlLmJvZHkgPSBmcm9tQnl0ZXMoYnl0ZXMpO1xuXHRcdFx0c3RhdGUuc2l6ZSA9IGJ5dGVzLmJ5dGVMZW5ndGg7XG5cdFx0XHRzdGF0ZS50eXBlID0gJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDtjaGFyc2V0PVVURi04Jztcblx0XHR9IGVsc2UgaWYgKGlzQmxvYihib2R5KSkge1xuXHRcdFx0Ly8gQm9keSBpcyBibG9iXG5cdFx0XHRzdGF0ZS5zaXplID0gYm9keS5zaXplO1xuXHRcdFx0c3RhdGUudHlwZSA9IGJvZHkudHlwZSB8fCBudWxsO1xuXHRcdFx0c3RhdGUuYm9keSA9IGJvZHkuc3RyZWFtKCk7XG5cdFx0fSBlbHNlIGlmIChib2R5IGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuXHRcdFx0Ly8gQm9keSBpcyBCdWZmZXJcblx0XHRcdHN0YXRlLmJvZHkgPSBmcm9tQnl0ZXMoYm9keSk7XG5cdFx0XHRzdGF0ZS5zaXplID0gYm9keS5ieXRlTGVuZ3RoO1xuXHRcdH0gZWxzZSBpZiAodHlwZXMuaXNBbnlBcnJheUJ1ZmZlcihib2R5KSkge1xuXHRcdFx0Ly8gQm9keSBpcyBBcnJheUJ1ZmZlclxuXHRcdFx0Y29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShib2R5KTtcblx0XHRcdHN0YXRlLmJvZHkgPSBmcm9tQnl0ZXMoYnl0ZXMpO1xuXHRcdFx0c3RhdGUuc2l6ZSA9IGJ5dGVzLmJ5dGVMZW5ndGg7XG5cdFx0fSBlbHNlIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoYm9keSkpIHtcblx0XHRcdC8vIEJvZHkgaXMgQXJyYXlCdWZmZXJWaWV3XG5cdFx0XHRjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGJvZHkuYnVmZmVyLCBib2R5LmJ5dGVPZmZzZXQsIGJvZHkuYnl0ZUxlbmd0aCk7XG5cdFx0XHRzdGF0ZS5ib2R5ID0gZnJvbUJ5dGVzKGJ5dGVzKTtcblx0XHRcdHN0YXRlLnNpemUgPSBieXRlcy5ieXRlTGVuZ3RoO1xuXHRcdH0gZWxzZSBpZiAoaXNSZWFkYWJsZVN0cmVhbShib2R5KSkge1xuXHRcdFx0Ly8gQm9keSBpcyBzdHJlYW1cblx0XHRcdHN0YXRlLmJvZHkgPSBib2R5O1xuXHRcdH0gZWxzZSBpZiAoaXNGb3JtRGF0YShib2R5KSkge1xuXHRcdFx0Ly8gQm9keSBpcyBhbiBpbnN0YW5jZSBvZiBmb3JtZGF0YS1ub2RlXG5cdFx0XHRjb25zdCBib3VuZGFyeSA9IGBOb2RlRmV0Y2hGb3JtRGF0YUJvdW5kYXJ5JHtnZXRCb3VuZGFyeSgpfWA7XG5cdFx0XHRzdGF0ZS50eXBlID0gYG11bHRpcGFydC9mb3JtLWRhdGE7IGJvdW5kYXJ5PSR7Ym91bmRhcnl9YDtcblx0XHRcdHN0YXRlLnNpemUgPSBnZXRGb3JtRGF0YUxlbmd0aChib2R5LCBib3VuZGFyeSk7XG5cdFx0XHRzdGF0ZS5ib2R5ID0gZnJvbUFzeW5jSXRlcmFibGUoZm9ybURhdGFJdGVyYXRvcihib2R5LCBib3VuZGFyeSkpO1xuXHRcdH0gZWxzZSBpZiAoaXNNdWx0aXBhcnRGb3JtRGF0YVN0cmVhbShib2R5KSkge1xuXHRcdFx0c3RhdGUudHlwZSA9IGBtdWx0aXBhcnQvZm9ybS1kYXRhOyBib3VuZGFyeT0ke2JvZHkuZ2V0Qm91bmRhcnkoKX1gO1xuXHRcdFx0c3RhdGUuc2l6ZSA9IGJvZHkuaGFzS25vd25MZW5ndGgoKSA/IGJvZHkuZ2V0TGVuZ3RoU3luYygpIDogbnVsbDtcblx0XHRcdHN0YXRlLmJvZHkgPSBmcm9tU3RyZWFtKGJvZHkpO1xuXHRcdH0gZWxzZSBpZiAoYm9keSBpbnN0YW5jZW9mIFN0cmVhbSkge1xuXHRcdFx0c3RhdGUuYm9keSA9IGZyb21TdHJlYW0oYm9keSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIE5vbmUgb2YgdGhlIGFib3ZlXG5cdFx0XHQvLyBjb2VyY2UgdG8gc3RyaW5nIHRoZW4gYnVmZmVyXG5cdFx0XHRjb25zdCBieXRlcyA9IHV0ZjguZW5jb2RlKFN0cmluZyhib2R5KSk7XG5cdFx0XHRzdGF0ZS50eXBlID0gJ3RleHQvcGxhaW47Y2hhcnNldD1VVEYtOCc7XG5cdFx0XHRzdGF0ZS5zaXplID0gYnl0ZXMuYnl0ZUxlbmd0aDtcblx0XHRcdHN0YXRlLmJvZHkgPSBmcm9tQnl0ZXMoYnl0ZXMpO1xuXHRcdH1cblxuXHRcdHRoaXMuc2l6ZSA9IHNpemU7XG5cblx0XHQvLyBpZiAoYm9keSBpbnN0YW5jZW9mIFN0cmVhbSkge1xuXHRcdC8vIFx0Ym9keS5vbignZXJyb3InLCBlcnIgPT4ge1xuXHRcdC8vIFx0XHRjb25zdCBlcnJvciA9IGVyciBpbnN0YW5jZW9mIEZldGNoQmFzZUVycm9yID9cblx0XHQvLyBcdFx0XHRlcnIgOlxuXHRcdC8vIFx0XHRcdG5ldyBGZXRjaEVycm9yKGBJbnZhbGlkIHJlc3BvbnNlIGJvZHkgd2hpbGUgdHJ5aW5nIHRvIGZldGNoICR7dGhpcy51cmx9OiAke2Vyci5tZXNzYWdlfWAsICdzeXN0ZW0nLCBlcnIpO1xuXHRcdC8vIFx0XHR0aGlzW0lOVEVSTkFMU10uZXJyb3IgPSBlcnJvcjtcblx0XHQvLyBcdH0pO1xuXHRcdC8vIH1cblx0fVxuXG5cdC8qKiBAdHlwZSB7SGVhZGVyc30gKi9cblx0LyogYzggaWdub3JlIG5leHQgMyAqL1xuXHRnZXQgaGVhZGVycygpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKGAnZ2V0IGhlYWRlcnMnIGNhbGxlZCBvbiBhbiBvYmplY3QgdGhhdCBkb2VzIG5vdCBpbXBsZW1lbnRzIGludGVyZmFjZS5gKVxuXHR9XG5cblx0Z2V0IGJvZHkoKSB7XG5cdFx0cmV0dXJuIHRoaXNbSU5URVJOQUxTXS5ib2R5O1xuXHR9XG5cblx0Z2V0IGJvZHlVc2VkKCkge1xuXHRcdHJldHVybiB0aGlzW0lOVEVSTkFMU10uZGlzdHVyYmVkO1xuXHR9XG5cblx0LyoqXG5cdCAqIERlY29kZSByZXNwb25zZSBhcyBBcnJheUJ1ZmZlclxuXHQgKlxuXHQgKiBAcmV0dXJuIHtQcm9taXNlPEFycmF5QnVmZmVyPn1cblx0ICovXG5cdGFzeW5jIGFycmF5QnVmZmVyKCkge1xuXHRcdGNvbnN0IHtidWZmZXIsIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGh9ID0gYXdhaXQgY29uc3VtZUJvZHkodGhpcyk7XG5cdFx0cmV0dXJuIGJ1ZmZlci5zbGljZShieXRlT2Zmc2V0LCBieXRlT2Zmc2V0ICsgYnl0ZUxlbmd0aCk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJuIHJhdyByZXNwb25zZSBhcyBCbG9iXG5cdCAqXG5cdCAqIEByZXR1cm4gUHJvbWlzZVxuXHQgKi9cblx0YXN5bmMgYmxvYigpIHtcblx0XHRjb25zdCBjdCA9ICh0aGlzLmhlYWRlcnMgJiYgdGhpcy5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJykpIHx8ICh0aGlzW0lOVEVSTkFMU10uYm9keSAmJiB0aGlzW0lOVEVSTkFMU10udHlwZSkgfHwgJyc7XG5cdFx0Y29uc3QgYnVmID0gYXdhaXQgY29uc3VtZUJvZHkodGhpcyk7XG5cblx0XHRyZXR1cm4gbmV3IEJsb2IoW2J1Zl0sIHtcblx0XHRcdHR5cGU6IGN0XG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogRGVjb2RlIHJlc3BvbnNlIGFzIGpzb25cblx0ICpcblx0ICogQHJldHVybiAgUHJvbWlzZVxuXHQgKi9cblx0YXN5bmMganNvbigpIHtcblx0XHRyZXR1cm4gSlNPTi5wYXJzZShhd2FpdCB0aGlzLnRleHQoKSk7XG5cdH1cblxuXHQvKipcblx0ICogRGVjb2RlIHJlc3BvbnNlIGFzIHRleHRcblx0ICpcblx0ICogQHJldHVybiAgUHJvbWlzZVxuXHQgKi9cblx0YXN5bmMgdGV4dCgpIHtcblx0XHRjb25zdCBidWZmZXIgPSBhd2FpdCBjb25zdW1lQm9keSh0aGlzKTtcblx0XHRyZXR1cm4gdXRmOC5kZWNvZGUoYnVmZmVyKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7UHJvbWlzZTxGb3JtRGF0YT59XG5cdCAqL1xuXG5cdGFzeW5jIGZvcm1EYXRhKCkge1xuXHRcdHJldHVybiB0b0Zvcm1EYXRhKHRoaXMpXG5cdH1cbn1cblxuLy8gSW4gYnJvd3NlcnMsIGFsbCBwcm9wZXJ0aWVzIGFyZSBlbnVtZXJhYmxlLlxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQm9keS5wcm90b3R5cGUsIHtcblx0Ym9keToge2VudW1lcmFibGU6IHRydWV9LFxuXHRib2R5VXNlZDoge2VudW1lcmFibGU6IHRydWV9LFxuXHRhcnJheUJ1ZmZlcjoge2VudW1lcmFibGU6IHRydWV9LFxuXHRibG9iOiB7ZW51bWVyYWJsZTogdHJ1ZX0sXG5cdGpzb246IHtlbnVtZXJhYmxlOiB0cnVlfSxcblx0dGV4dDoge2VudW1lcmFibGU6IHRydWV9LFxuXHRmb3JtRGF0YToge2VudW1lcmFibGU6IHRydWV9XG59KTtcblxuLyoqXG4gKiBDb25zdW1lIGFuZCBjb252ZXJ0IGFuIGVudGlyZSBCb2R5IHRvIGEgQnVmZmVyLlxuICpcbiAqIFJlZjogaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtYm9keS1jb25zdW1lLWJvZHlcbiAqXG4gKiBAcGFyYW0ge0JvZHkgJiB7dXJsPzpzdHJpbmd9fSBkYXRhXG4gKiBAcmV0dXJuIHtQcm9taXNlPFVpbnQ4QXJyYXk+fVxuICovXG5hc3luYyBmdW5jdGlvbiBjb25zdW1lQm9keShkYXRhKSB7XG5cdGNvbnN0IHN0YXRlID0gZGF0YVtJTlRFUk5BTFNdO1xuXHRpZiAoc3RhdGUuZGlzdHVyYmVkKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihgYm9keSB1c2VkIGFscmVhZHkgZm9yOiAke2RhdGEudXJsfWApO1xuXHR9XG5cblx0c3RhdGUuZGlzdHVyYmVkID0gdHJ1ZTtcblxuXHRpZiAoc3RhdGUuZXJyb3IpIHtcblx0XHR0aHJvdyBzdGF0ZS5lcnJvcjtcblx0fVxuXG5cdGNvbnN0IHtib2R5fSA9IHN0YXRlO1xuXG5cdC8vIEJvZHkgaXMgbnVsbFxuXHRpZiAoYm9keSA9PT0gbnVsbCkge1xuXHRcdHJldHVybiBuZXcgVWludDhBcnJheSgwKTtcblx0fVxuXG5cdC8vIEJvZHkgaXMgc3RyZWFtXG5cdC8vIGdldCByZWFkeSB0byBhY3R1YWxseSBjb25zdW1lIHRoZSBib2R5XG5cdC8qKiBAdHlwZSB7W1VpbnQ4QXJyYXl8bnVsbCwgVWludDhBcnJheVtdLCBudW1iZXJdfSAqL1xuXHRjb25zdCBbYnVmZmVyLCBjaHVua3MsIGxpbWl0XSA9IGRhdGEuc2l6ZSA+IDAgP1xuXHRcdFtuZXcgVWludDhBcnJheShkYXRhLnNpemUpLCBbXSwgZGF0YS5zaXplXSA6XG5cdFx0W251bGwsIFtdLCBJbmZpbml0eV07XG5cdGxldCBvZmZzZXQgPSAwO1xuXG5cdGNvbnN0IHNvdXJjZSA9IHN0cmVhbUl0ZXJhdG9yKGJvZHkpO1xuXHR0cnkge1xuXHRcdGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2Ygc291cmNlKSB7XG5cdFx0XHRjb25zdCBieXRlcyA9IGNodW5rIGluc3RhbmNlb2YgVWludDhBcnJheSA/XG5cdFx0XHRcdGNodW5rIDpcblx0XHRcdFx0QnVmZmVyLmZyb20oY2h1bmspO1xuXG5cdFx0XHRpZiAob2Zmc2V0ICsgYnl0ZXMuYnl0ZUxlbmd0aCA+IGxpbWl0KSB7XG5cdFx0XHRcdGNvbnN0IGVycm9yID0gbmV3IEZldGNoRXJyb3IoYGNvbnRlbnQgc2l6ZSBhdCAke2RhdGEudXJsfSBvdmVyIGxpbWl0OiAke2xpbWl0fWAsICdtYXgtc2l6ZScpO1xuXHRcdFx0XHRzb3VyY2UudGhyb3coZXJyb3IpO1xuXHRcdFx0XHR0aHJvdyBlcnJvcjtcblx0XHRcdH0gZWxzZSBpZiAoYnVmZmVyKSB7XG5cdFx0XHRcdGJ1ZmZlci5zZXQoYnl0ZXMsIG9mZnNldCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjaHVua3MucHVzaChieXRlcyk7XG5cdFx0XHR9XG5cblx0XHRcdG9mZnNldCArPSBieXRlcy5ieXRlTGVuZ3RoO1xuXHRcdH1cblxuXHRcdGlmIChidWZmZXIpIHtcblx0XHRcdGlmIChvZmZzZXQgPCBidWZmZXIuYnl0ZUxlbmd0aCkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRmV0Y2hFcnJvcihgUHJlbWF0dXJlIGNsb3NlIG9mIHNlcnZlciByZXNwb25zZSB3aGlsZSB0cnlpbmcgdG8gZmV0Y2ggJHtkYXRhLnVybH1gLCAncHJlbWF0dXJlLWNsb3NlJyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gYnVmZmVyO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gd3JpdGVCeXRlcyhuZXcgVWludDhBcnJheShvZmZzZXQpLCBjaHVua3MpO1xuXHRcdH1cblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRpZiAoZXJyb3IgaW5zdGFuY2VvZiBGZXRjaEJhc2VFcnJvcikge1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0Ly8gQHRzLWV4cGVjdC1lcnJvciAtIHdlIGtub3cgaXQgd2lsbCBoYXZlIGEgbmFtZVxuXHRcdH0gZWxzZSBpZiAoZXJyb3IgJiYgZXJyb3IubmFtZSA9PT0gJ0Fib3J0RXJyb3InKSB7XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29uc3QgZSA9IC8qKiBAdHlwZSB7aW1wb3J0KCcuL2Vycm9ycy9mZXRjaC1lcnJvcicpLlN5c3RlbUVycm9yfSAqLyhlcnJvcilcblx0XHRcdC8vIE90aGVyIGVycm9ycywgc3VjaCBhcyBpbmNvcnJlY3QgY29udGVudC1lbmNvZGluZ1xuXHRcdFx0dGhyb3cgbmV3IEZldGNoRXJyb3IoYEludmFsaWQgcmVzcG9uc2UgYm9keSB3aGlsZSB0cnlpbmcgdG8gZmV0Y2ggJHtkYXRhLnVybH06ICR7ZS5tZXNzYWdlfWAsICdzeXN0ZW0nLCBlKTtcblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBDbG9uZSBib2R5IGdpdmVuIFJlcy9SZXEgaW5zdGFuY2VcbiAqXG4gKiBAcGFyYW0ge0JvZHl9IGluc3RhbmNlICAgICAgIFJlc3BvbnNlIG9yIFJlcXVlc3QgaW5zdGFuY2VcbiAqIEByZXR1cm4ge1JlYWRhYmxlU3RyZWFtPFVpbnQ4QXJyYXk+IHwgbnVsbH1cbiAqL1xuZXhwb3J0IGNvbnN0IGNsb25lID0gaW5zdGFuY2UgPT4ge1xuXHRjb25zdCB7Ym9keX0gPSBpbnN0YW5jZTtcblxuXHQvLyBEb24ndCBhbGxvdyBjbG9uaW5nIGEgdXNlZCBib2R5XG5cdGlmIChpbnN0YW5jZS5ib2R5VXNlZCkge1xuXHRcdHRocm93IG5ldyBFcnJvcignY2Fubm90IGNsb25lIGJvZHkgYWZ0ZXIgaXQgaXMgdXNlZCcpO1xuXHR9XG5cblx0aWYgKCFib2R5KSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHRjb25zdCBbbGVmdCwgcmlnaHRdID0gYm9keS50ZWUoKTtcblx0aW5zdGFuY2VbSU5URVJOQUxTXS5ib2R5ID0gbGVmdDtcblx0cmV0dXJuIHJpZ2h0O1xufTtcblxuLyoqXG4gKiBQZXJmb3JtcyB0aGUgb3BlcmF0aW9uIFwiZXh0cmFjdCBhIGBDb250ZW50LVR5cGVgIHZhbHVlIGZyb20gfG9iamVjdHxcIiBhc1xuICogc3BlY2lmaWVkIGluIHRoZSBzcGVjaWZpY2F0aW9uOlxuICogaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtYm9keWluaXQtZXh0cmFjdFxuICpcbiAqIFRoaXMgZnVuY3Rpb24gYXNzdW1lcyB0aGF0IGluc3RhbmNlLmJvZHkgaXMgcHJlc2VudC5cbiAqXG4gKiBAcGFyYW0ge0JvZHl9IHNvdXJjZSBBbnkgb3B0aW9ucy5ib2R5IGlucHV0XG4gKiBAcmV0dXJucyB7c3RyaW5nIHwgbnVsbH1cbiAqL1xuZXhwb3J0IGNvbnN0IGV4dHJhY3RDb250ZW50VHlwZSA9IHNvdXJjZSA9PiBzb3VyY2VbSU5URVJOQUxTXS50eXBlO1xuXG4vKipcbiAqIFRoZSBGZXRjaCBTdGFuZGFyZCB0cmVhdHMgdGhpcyBhcyBpZiBcInRvdGFsIGJ5dGVzXCIgaXMgYSBwcm9wZXJ0eSBvbiB0aGUgYm9keS5cbiAqIEZvciB1cywgd2UgaGF2ZSB0byBleHBsaWNpdGx5IGdldCBpdCB3aXRoIGEgZnVuY3Rpb24uXG4gKlxuICogcmVmOiBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1ib2R5LXRvdGFsLWJ5dGVzXG4gKlxuICogQHBhcmFtIHtCb2R5fSBzb3VyY2UgLSBCb2R5IG9iamVjdCBmcm9tIHRoZSBCb2R5IGluc3RhbmNlLlxuICogQHJldHVybnMge251bWJlciB8IG51bGx9XG4gKi9cbmV4cG9ydCBjb25zdCBnZXRUb3RhbEJ5dGVzID0gc291cmNlID0+IHNvdXJjZVtJTlRFUk5BTFNdLnNpemU7XG5cbi8qKlxuICogV3JpdGUgYSBCb2R5IHRvIGEgTm9kZS5qcyBXcml0YWJsZVN0cmVhbSAoZS5nLiBodHRwLlJlcXVlc3QpIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge1N0cmVhbS5Xcml0YWJsZX0gZGVzdCAtIFRoZSBzdHJlYW0gdG8gd3JpdGUgdG8uXG4gKiBAcGFyYW0ge0JvZHl9IHNvdXJjZSAtIEJvZHkgb2JqZWN0IGZyb20gdGhlIEJvZHkgaW5zdGFuY2UuXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGNvbnN0IHdyaXRlVG9TdHJlYW0gPSAoZGVzdCwge2JvZHl9KSA9PiB7XG5cdGlmIChib2R5ID09PSBudWxsKSB7XG5cdFx0Ly8gQm9keSBpcyBudWxsXG5cdFx0ZGVzdC5lbmQoKTtcblx0fSBlbHNlIHtcblx0XHRTdHJlYW0uUmVhZGFibGUuZnJvbShzdHJlYW1JdGVyYXRvcihib2R5KSkucGlwZShkZXN0KTtcblx0fVxufTtcblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQGltcGxlbWVudHMge0FzeW5jR2VuZXJhdG9yPFQsIHZvaWQsIHZvaWQ+fVxuICovXG5jbGFzcyBTdHJlYW1JdGVyYWJsZUl0ZXJhdG9yIHtcblx0LyoqXG5cdCAqIEBwYXJhbSB7UmVhZGFibGVTdHJlYW08VD59IHN0cmVhbVxuXHQgKi9cblx0Y29uc3RydWN0b3Ioc3RyZWFtKSB7XG5cdFx0dGhpcy5zdHJlYW0gPSBzdHJlYW07XG5cdFx0dGhpcy5yZWFkZXIgPSBudWxsO1xuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm5zIHtBc3luY0dlbmVyYXRvcjxULCB2b2lkLCB2b2lkPn1cblx0ICovXG5cdFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHRnZXRSZWFkZXIoKSB7XG5cdFx0aWYgKHRoaXMucmVhZGVyKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5yZWFkZXI7XG5cdFx0fVxuXG5cdFx0Y29uc3QgcmVhZGVyID0gdGhpcy5zdHJlYW0uZ2V0UmVhZGVyKCk7XG5cdFx0dGhpcy5yZWFkZXIgPSByZWFkZXI7XG5cdFx0cmV0dXJuIHJlYWRlcjtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7UHJvbWlzZTxJdGVyYXRvclJlc3VsdDxULCB2b2lkPj59XG5cdCAqL1xuXHRuZXh0KCkge1xuXHRcdHJldHVybiAvKiogQHR5cGUge1Byb21pc2U8SXRlcmF0b3JSZXN1bHQ8VCwgdm9pZD4+fSAqLyAodGhpcy5nZXRSZWFkZXIoKS5yZWFkKCkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm5zIHtQcm9taXNlPEl0ZXJhdG9yUmVzdWx0PFQsIHZvaWQ+Pn1cblx0ICovXG5cdGFzeW5jIHJldHVybigpIHtcblx0XHRpZiAodGhpcy5yZWFkZXIpIHtcblx0XHRcdGF3YWl0IHRoaXMucmVhZGVyLmNhbmNlbCgpO1xuXHRcdH1cblxuXHRcdHJldHVybiB7ZG9uZTogdHJ1ZSwgdmFsdWU6IHVuZGVmaW5lZH07XG5cdH1cblxuXHQvKipcblx0ICogXG5cdCAqIEBwYXJhbSB7YW55fSBlcnJvciBcblx0ICogQHJldHVybnMge1Byb21pc2U8SXRlcmF0b3JSZXN1bHQ8VCwgdm9pZD4+fVxuXHQgKi9cblx0YXN5bmMgdGhyb3coZXJyb3IpIHtcblx0XHRhd2FpdCB0aGlzLmdldFJlYWRlcigpLmNhbmNlbChlcnJvcik7XG5cdFx0cmV0dXJuIHtkb25lOiB0cnVlLCB2YWx1ZTogdW5kZWZpbmVkfTtcblx0fVxufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge1JlYWRhYmxlU3RyZWFtPFQ+fSBzdHJlYW1cbiAqL1xuZXhwb3J0IGNvbnN0IHN0cmVhbUl0ZXJhdG9yID0gc3RyZWFtID0+IG5ldyBTdHJlYW1JdGVyYWJsZUl0ZXJhdG9yKHN0cmVhbSk7XG5cbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWZmZXJcbiAqIEBwYXJhbSB7VWludDhBcnJheVtdfSBjaHVua3NcbiAqL1xuY29uc3Qgd3JpdGVCeXRlcyA9IChidWZmZXIsIGNodW5rcykgPT4ge1xuXHRsZXQgb2Zmc2V0ID0gMDtcblx0Zm9yIChjb25zdCBjaHVuayBvZiBjaHVua3MpIHtcblx0XHRidWZmZXIuc2V0KGNodW5rLCBvZmZzZXQpO1xuXHRcdG9mZnNldCArPSBjaHVuay5ieXRlTGVuZ3RoO1xuXHR9XG5cblx0cmV0dXJuIGJ1ZmZlcjtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBieXRlc1xuICogQHJldHVybnMge1JlYWRhYmxlU3RyZWFtPFVpbnQ4QXJyYXk+fVxuICovXG4vLyBAdHMtaWdub3JlXG5jb25zdCBmcm9tQnl0ZXMgPSBieXRlcyA9PiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuXHRzdGFydChjb250cm9sbGVyKSB7XG5cdFx0Y29udHJvbGxlci5lbnF1ZXVlKGJ5dGVzKTtcblx0XHRjb250cm9sbGVyLmNsb3NlKCk7XG5cdH1cbn0pO1xuXG4vKipcbiAqIEBwYXJhbSB7QXN5bmNJdGVyYWJsZTxVaW50OEFycmF5Pn0gY29udGVudFxuICogQHJldHVybnMge1JlYWRhYmxlU3RyZWFtPFVpbnQ4QXJyYXk+fVxuICovXG5leHBvcnQgY29uc3QgZnJvbUFzeW5jSXRlcmFibGUgPSBjb250ZW50ID0+XG5cdC8vIEB0cy1pZ25vcmVcblx0bmV3IFJlYWRhYmxlU3RyZWFtKG5ldyBBc3luY0l0ZXJhYmxlUHVtcChjb250ZW50KSk7XG5cbi8qKlxuICogQGltcGxlbWVudHMge1VuZGVybHlpbmdTb3VyY2U8VWludDhBcnJheT59XG4gKi9cbmNsYXNzIEFzeW5jSXRlcmFibGVQdW1wIHtcblx0LyoqXG5cdCAqIEBwYXJhbSB7QXN5bmNJdGVyYWJsZTxVaW50OEFycmF5Pn0gc291cmNlXG5cdCAqL1xuXHRjb25zdHJ1Y3Rvcihzb3VyY2UpIHtcblx0XHR0aGlzLnNvdXJjZSA9IHNvdXJjZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcjxVaW50OEFycmF5Pn0gY29udHJvbGxlclxuXHQgKi9cblx0YXN5bmMgcHVsbChjb250cm9sbGVyKSB7XG5cdFx0dHJ5IHtcblx0XHRcdHdoaWxlIChjb250cm9sbGVyLmRlc2lyZWRTaXplIHx8IDAgPiAwKSB7XG5cdFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1hd2FpdC1pbi1sb29wXG5cdFx0XHRcdGNvbnN0IG5leHQgPSBhd2FpdCB0aGlzLnNvdXJjZS5uZXh0KCk7XG5cdFx0XHRcdGlmIChuZXh0LmRvbmUpIHtcblx0XHRcdFx0XHRjb250cm9sbGVyLmNsb3NlKCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y29udHJvbGxlci5lbnF1ZXVlKG5leHQudmFsdWUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGNvbnRyb2xsZXIuZXJyb3IoZXJyb3IpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge2FueX0gW3JlYXNvbl1cblx0ICovXG5cdGNhbmNlbChyZWFzb24pIHtcblx0XHRpZiAocmVhc29uKSB7XG5cdFx0XHRpZiAodHlwZW9mIHRoaXMuc291cmNlLnRocm93ID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdHRoaXMuc291cmNlLnRocm93KHJlYXNvbik7XG5cdFx0XHR9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLnNvdXJjZS5yZXR1cm4gPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0dGhpcy5zb3VyY2UucmV0dXJuKCk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmICh0eXBlb2YgdGhpcy5zb3VyY2UucmV0dXJuID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHR0aGlzLnNvdXJjZS5yZXR1cm4oKTtcblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1N0cmVhbSAmIHtyZWFkYWJsZUhpZ2hXYXRlck1hcms/Om51bWJlcn19IHNvdXJjZVxuICogQHJldHVybnMge1JlYWRhYmxlU3RyZWFtPFVpbnQ4QXJyYXk+fVxuICovXG5leHBvcnQgY29uc3QgZnJvbVN0cmVhbSA9IHNvdXJjZSA9PiB7XG5cdGNvbnN0IHB1bXAgPSBuZXcgU3RyZWFtUHVtcChzb3VyY2UpO1xuXHRjb25zdCBzdHJlYW0gPSBuZXcgUmVhZGFibGVTdHJlYW0ocHVtcCwgcHVtcCk7XG5cdHJldHVybiBzdHJlYW07XG59O1xuXG4vKipcbiAqIEBpbXBsZW1lbnRzIHtVbmRlcmx5aW5nU291cmNlPFVpbnQ4QXJyYXk+fVxuICogQGltcGxlbWVudHMge1F1ZXVpbmdTdHJhdGVneTxVaW50OEFycmF5Pn1cbiAqL1xuY2xhc3MgU3RyZWFtUHVtcCB7XG5cdC8qKlxuXHQgKiBAcGFyYW0ge1N0cmVhbSAmIHtcblx0ICogXHRyZWFkYWJsZUhpZ2hXYXRlck1hcms/OiBudW1iZXJcblx0ICogXHRyZWFkYWJsZT86Ym9vbGVhbixcblx0ICogXHRyZXN1bWU/OiAoKSA9PiB2b2lkLFxuXHQgKiBcdHBhdXNlPzogKCkgPT4gdm9pZFxuXHQgKiBcdGRlc3Ryb3k/OiAoZXJyb3I/OkVycm9yKSA9PiB2b2lkXG5cdCAqIH19IHN0cmVhbVxuXHQgKi9cblx0Y29uc3RydWN0b3Ioc3RyZWFtKSB7XG5cdFx0dGhpcy5oaWdoV2F0ZXJNYXJrID0gc3RyZWFtLnJlYWRhYmxlSGlnaFdhdGVyTWFyayB8fCByZWFkYWJsZUhpZ2hXYXRlck1hcms7XG5cdFx0dGhpcy5hY2N1bWFsYXRlZFNpemUgPSAwO1xuXHRcdHRoaXMuc3RyZWFtID0gc3RyZWFtO1xuXHRcdHRoaXMuZW5xdWV1ZSA9IHRoaXMuZW5xdWV1ZS5iaW5kKHRoaXMpO1xuXHRcdHRoaXMuZXJyb3IgPSB0aGlzLmVycm9yLmJpbmQodGhpcyk7XG5cdFx0dGhpcy5jbG9zZSA9IHRoaXMuY2xvc2UuYmluZCh0aGlzKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IFtjaHVua11cblx0ICovXG5cdHNpemUoY2h1bmspIHtcblx0XHRyZXR1cm4gY2h1bms/LmJ5dGVMZW5ndGggfHwgMDtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcjxVaW50OEFycmF5Pn0gY29udHJvbGxlclxuXHQgKi9cblx0c3RhcnQoY29udHJvbGxlcikge1xuXHRcdHRoaXMuY29udHJvbGxlciA9IGNvbnRyb2xsZXI7XG5cdFx0dGhpcy5zdHJlYW0ub24oJ2RhdGEnLCB0aGlzLmVucXVldWUpO1xuXHRcdHRoaXMuc3RyZWFtLm9uY2UoJ2Vycm9yJywgdGhpcy5lcnJvcik7XG5cdFx0dGhpcy5zdHJlYW0ub25jZSgnZW5kJywgdGhpcy5jbG9zZSk7XG5cdFx0dGhpcy5zdHJlYW0ub25jZSgnY2xvc2UnLCB0aGlzLmNsb3NlKTtcblx0fVxuXG5cdHB1bGwoKSB7XG5cdFx0dGhpcy5yZXN1bWUoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge2FueX0gW3JlYXNvbl1cblx0ICovXG5cdGNhbmNlbChyZWFzb24pIHtcblx0XHRpZiAodGhpcy5zdHJlYW0uZGVzdHJveSkge1xuXHRcdFx0dGhpcy5zdHJlYW0uZGVzdHJveShyZWFzb24pO1xuXHRcdH1cblxuXHRcdHRoaXMuc3RyZWFtLm9mZignZGF0YScsIHRoaXMuZW5xdWV1ZSk7XG5cdFx0dGhpcy5zdHJlYW0ub2ZmKCdlcnJvcicsIHRoaXMuZXJyb3IpO1xuXHRcdHRoaXMuc3RyZWFtLm9mZignZW5kJywgdGhpcy5jbG9zZSk7XG5cdFx0dGhpcy5zdHJlYW0ub2ZmKCdjbG9zZScsIHRoaXMuY2xvc2UpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7VWludDhBcnJheXxzdHJpbmd9IGNodW5rXG5cdCAqL1xuXHRlbnF1ZXVlKGNodW5rKSB7XG5cdFx0aWYgKHRoaXMuY29udHJvbGxlcikge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Y29uc3QgYnl0ZXMgPSBjaHVuayBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgP1xuXHRcdFx0XHRcdGNodW5rIDpcblx0XHRcdFx0XHRCdWZmZXIuZnJvbShjaHVuayk7XG5cblx0XHRcdFx0Y29uc3QgYXZhaWxhYmxlID0gKHRoaXMuY29udHJvbGxlci5kZXNpcmVkU2l6ZSB8fCAwKSAtIGJ5dGVzLmJ5dGVMZW5ndGg7XG5cdFx0XHRcdHRoaXMuY29udHJvbGxlci5lbnF1ZXVlKGJ5dGVzKTtcblx0XHRcdFx0aWYgKGF2YWlsYWJsZSA8PSAwKSB7XG5cdFx0XHRcdFx0dGhpcy5wYXVzZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGNhdGNoIHtcblx0XHRcdFx0dGhpcy5jb250cm9sbGVyLmVycm9yKG5ldyBFcnJvcignQ291bGQgbm90IGNyZWF0ZSBCdWZmZXIsIGNodW5rIG11c3QgYmUgb2YgdHlwZSBzdHJpbmcgb3IgYW4gaW5zdGFuY2Ugb2YgQnVmZmVyLCBBcnJheUJ1ZmZlciwgb3IgQXJyYXkgb3IgYW4gQXJyYXktbGlrZSBPYmplY3QnKSk7XG5cdFx0XHRcdHRoaXMuY2FuY2VsKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cGF1c2UoKSB7XG5cdFx0aWYgKHRoaXMuc3RyZWFtLnBhdXNlKSB7XG5cdFx0XHR0aGlzLnN0cmVhbS5wYXVzZSgpO1xuXHRcdH1cblx0fVxuXG5cdHJlc3VtZSgpIHtcblx0XHRpZiAodGhpcy5zdHJlYW0ucmVhZGFibGUgJiYgdGhpcy5zdHJlYW0ucmVzdW1lKSB7XG5cdFx0XHR0aGlzLnN0cmVhbS5yZXN1bWUoKTtcblx0XHR9XG5cdH1cblxuXHRjbG9zZSgpIHtcblx0XHRpZiAodGhpcy5jb250cm9sbGVyKSB7XG5cdFx0XHR0aGlzLmNvbnRyb2xsZXIuY2xvc2UoKTtcblx0XHRcdGRlbGV0ZSB0aGlzLmNvbnRyb2xsZXI7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7RXJyb3J9IGVycm9yIFxuXHQgKi9cblx0ZXJyb3IoZXJyb3IpIHtcblx0XHRpZiAodGhpcy5jb250cm9sbGVyKSB7XG5cdFx0XHR0aGlzLmNvbnRyb2xsZXIuZXJyb3IoZXJyb3IpO1xuXHRcdFx0ZGVsZXRlIHRoaXMuY29udHJvbGxlcjtcblx0XHR9XG5cdH1cbn1cbiIsICIvLyBJbiBub2RlIGBleHBvcnQgeyBUZXh0RW5jb2RlciB9YCB0aHJvd3M6XG4vLyBcIkV4cG9ydCAnVGV4dEVuY29kZXInIGlzIG5vdCBkZWZpbmVkIGluIG1vZHVsZVwiXG4vLyBUbyB3b3JrYXJvdW5kIHdlIGZpcnN0IGRlZmluZSBjb25zdGFudHMgYW5kIHRoZW4gZXhwb3J0IHdpdGggYXMuXG5jb25zdCBFbmNvZGVyID0gVGV4dEVuY29kZXJcbmNvbnN0IERlY29kZXIgPSBUZXh0RGVjb2RlclxuXG5leHBvcnQgeyBFbmNvZGVyIGFzIFRleHRFbmNvZGVyLCBEZWNvZGVyIGFzIFRleHREZWNvZGVyIH1cbiIsICIvLyBAdHMtaWdub3JlXG5pbXBvcnQgc3RyZWFtcyBmcm9tIFwiLi9zdHJlYW0uY2pzXCJcbmV4cG9ydCBjb25zdCB7XG4gIFJlYWRhYmxlU3RyZWFtLFxuICBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIsXG4gIFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlcixcbiAgUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdCxcbiAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcixcbiAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcixcbiAgVHJhbnNmb3JtU3RyZWFtLFxuICBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlcixcbiAgV3JpdGFibGVTdHJlYW0sXG4gIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcixcbiAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcixcbiAgQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneSxcbiAgQ291bnRRdWV1aW5nU3RyYXRlZ3ksXG4gIFRleHRFbmNvZGVyU3RyZWFtLFxuICBUZXh0RGVjb2RlclN0cmVhbSxcbn0gPSBzdHJlYW1zXG4iLCAiaW1wb3J0IHsgUmVhZGFibGVTdHJlYW0sIFRleHRFbmNvZGVyLCBUZXh0RGVjb2RlciB9IGZyb20gXCIuL3BhY2thZ2UuanNcIlxuXG4vKipcbiAqIEBpbXBsZW1lbnRzIHtnbG9iYWxUaGlzLkJsb2J9XG4gKi9cbmNvbnN0IFdlYkJsb2IgPSBjbGFzcyBCbG9iIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7QmxvYlBhcnRbXX0gW2luaXRdXG4gICAqIEBwYXJhbSB7QmxvYlByb3BlcnR5QmFnfSBbb3B0aW9uc11cbiAgICovXG4gIGNvbnN0cnVjdG9yKGluaXQgPSBbXSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgLyoqIEB0eXBlIHtVaW50OEFycmF5W119ICovXG4gICAgY29uc3QgcGFydHMgPSBbXVxuXG4gICAgbGV0IHNpemUgPSAwXG4gICAgZm9yIChjb25zdCBwYXJ0IG9mIGluaXQpIHtcbiAgICAgIGlmICh0eXBlb2YgcGFydCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBjb25zdCBieXRlcyA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShwYXJ0KVxuICAgICAgICBwYXJ0cy5wdXNoKGJ5dGVzKVxuICAgICAgICBzaXplICs9IGJ5dGVzLmJ5dGVMZW5ndGhcbiAgICAgIH0gZWxzZSBpZiAocGFydCBpbnN0YW5jZW9mIFdlYkJsb2IpIHtcbiAgICAgICAgc2l6ZSArPSBwYXJ0LnNpemVcbiAgICAgICAgLy8gQHRzLWlnbm9yZSAtIGBfcGFydHNgIGlzIG1hcmtlZCBwcml2YXRlIHNvIFRTIHdpbGwgY29tcGxhaW4gYWJvdXRcbiAgICAgICAgLy8gYWNjZXNzaW5nIGl0LlxuICAgICAgICBwYXJ0cy5wdXNoKC4uLnBhcnQuX3BhcnRzKVxuICAgICAgfSBlbHNlIGlmIChwYXJ0IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgcGFydHMucHVzaChuZXcgVWludDhBcnJheShwYXJ0KSlcbiAgICAgICAgc2l6ZSArPSBwYXJ0LmJ5dGVMZW5ndGhcbiAgICAgIH0gZWxzZSBpZiAocGFydCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgcGFydHMucHVzaChwYXJ0KVxuICAgICAgICBzaXplICs9IHBhcnQuYnl0ZUxlbmd0aFxuICAgICAgfSBlbHNlIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcocGFydCkpIHtcbiAgICAgICAgY29uc3QgeyBidWZmZXIsIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGggfSA9IHBhcnRcbiAgICAgICAgcGFydHMucHVzaChuZXcgVWludDhBcnJheShidWZmZXIsIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGgpKVxuICAgICAgICBzaXplICs9IGJ5dGVMZW5ndGhcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKFN0cmluZyhwYXJ0KSlcbiAgICAgICAgcGFydHMucHVzaChieXRlcylcbiAgICAgICAgc2l6ZSArPSBieXRlcy5ieXRlTGVuZ3RoXG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgdGhpcy5fc2l6ZSA9IHNpemVcbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICB0aGlzLl90eXBlID0gcmVhZFR5cGUob3B0aW9ucy50eXBlKVxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIHRoaXMuX3BhcnRzID0gcGFydHNcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgIF9zaXplOiB7IGVudW1lcmFibGU6IGZhbHNlIH0sXG4gICAgICBfdHlwZTogeyBlbnVtZXJhYmxlOiBmYWxzZSB9LFxuICAgICAgX3BhcnRzOiB7IGVudW1lcmFibGU6IGZhbHNlIH0sXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHN0cmluZyBpbmRpY2F0aW5nIHRoZSBNSU1FIHR5cGUgb2YgdGhlIGRhdGEgY29udGFpbmVkIGluIHRoZSBCbG9iLlxuICAgKiBJZiB0aGUgdHlwZSBpcyB1bmtub3duLCB0aGlzIHN0cmluZyBpcyBlbXB0eS5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCB0eXBlKCkge1xuICAgIHJldHVybiB0aGlzLl90eXBlXG4gIH1cbiAgLyoqXG4gICAqIFRoZSBzaXplLCBpbiBieXRlcywgb2YgdGhlIGRhdGEgY29udGFpbmVkIGluIHRoZSBCbG9iIG9iamVjdC5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBzaXplKCkge1xuICAgIHJldHVybiB0aGlzLl9zaXplXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIG5ldyBCbG9iIG9iamVjdCBjb250YWluaW5nIHRoZSBkYXRhIGluIHRoZSBzcGVjaWZpZWQgcmFuZ2Ugb2ZcbiAgICogYnl0ZXMgb2YgdGhlIGJsb2Igb24gd2hpY2ggaXQncyBjYWxsZWQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gLSBBbiBpbmRleCBpbnRvIHRoZSBCbG9iIGluZGljYXRpbmcgdGhlIGZpcnN0XG4gICAqIGJ5dGUgdG8gaW5jbHVkZSBpbiB0aGUgbmV3IEJsb2IuIElmIHlvdSBzcGVjaWZ5IGEgbmVnYXRpdmUgdmFsdWUsIGl0J3NcbiAgICogdHJlYXRlZCBhcyBhbiBvZmZzZXQgZnJvbSB0aGUgZW5kIG9mIHRoZSBCbG9iIHRvd2FyZCB0aGUgYmVnaW5uaW5nLiBGb3JcbiAgICogZXhhbXBsZSwgYC0xMGAgd291bGQgYmUgdGhlIDEwdGggZnJvbSBsYXN0IGJ5dGUgaW4gdGhlIEJsb2IuIFRoZSBkZWZhdWx0XG4gICAqIHZhbHVlIGlzIGAwYC4gSWYgeW91IHNwZWNpZnkgYSB2YWx1ZSBmb3Igc3RhcnQgdGhhdCBpcyBsYXJnZXIgdGhhbiB0aGVcbiAgICogc2l6ZSBvZiB0aGUgc291cmNlIEJsb2IsIHRoZSByZXR1cm5lZCBCbG9iIGhhcyBzaXplIDAgYW5kIGNvbnRhaW5zIG5vXG4gICAqIGRhdGEuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kXSAtIEFuIGluZGV4IGludG8gdGhlIGBCbG9iYCBpbmRpY2F0aW5nIHRoZSBmaXJzdCBieXRlXG4gICAqICB0aGF0IHdpbGwgKm5vdCogYmUgaW5jbHVkZWQgaW4gdGhlIG5ldyBgQmxvYmAgKGkuZS4gdGhlIGJ5dGUgZXhhY3RseSBhdFxuICAgKiB0aGlzIGluZGV4IGlzIG5vdCBpbmNsdWRlZCkuIElmIHlvdSBzcGVjaWZ5IGEgbmVnYXRpdmUgdmFsdWUsIGl0J3MgdHJlYXRlZFxuICAgKiBhcyBhbiBvZmZzZXQgZnJvbSB0aGUgZW5kIG9mIHRoZSBCbG9iIHRvd2FyZCB0aGUgYmVnaW5uaW5nLiBGb3IgZXhhbXBsZSxcbiAgICogYC0xMGAgd291bGQgYmUgdGhlIDEwdGggZnJvbSBsYXN0IGJ5dGUgaW4gdGhlIGBCbG9iYC4gVGhlIGRlZmF1bHQgdmFsdWUgaXNcbiAgICogc2l6ZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFt0eXBlXSAtIFRoZSBjb250ZW50IHR5cGUgdG8gYXNzaWduIHRvIHRoZSBuZXcgQmxvYjtcbiAgICogdGhpcyB3aWxsIGJlIHRoZSB2YWx1ZSBvZiBpdHMgdHlwZSBwcm9wZXJ0eS4gVGhlIGRlZmF1bHQgdmFsdWUgaXMgYW4gZW1wdHlcbiAgICogc3RyaW5nLlxuICAgKiBAcmV0dXJucyB7QmxvYn1cbiAgICovXG4gIHNsaWNlKHN0YXJ0ID0gMCwgZW5kID0gdGhpcy5zaXplLCB0eXBlID0gXCJcIikge1xuICAgIGNvbnN0IHsgc2l6ZSwgX3BhcnRzIH0gPSB0aGlzXG4gICAgbGV0IG9mZnNldCA9IHN0YXJ0IDwgMCA/IE1hdGgubWF4KHNpemUgKyBzdGFydCwgMCkgOiBNYXRoLm1pbihzdGFydCwgc2l6ZSlcblxuICAgIGxldCBsaW1pdCA9IGVuZCA8IDAgPyBNYXRoLm1heChzaXplICsgZW5kLCAwKSA6IE1hdGgubWluKGVuZCwgc2l6ZSlcbiAgICBjb25zdCBzcGFuID0gTWF0aC5tYXgobGltaXQgLSBvZmZzZXQsIDApXG4gICAgY29uc3QgYmxvYiA9IG5ldyBCbG9iKFtdLCB7IHR5cGUgfSlcblxuICAgIGlmIChzcGFuID09PSAwKSB7XG4gICAgICByZXR1cm4gYmxvYlxuICAgIH1cblxuICAgIGxldCBibG9iU2l6ZSA9IDBcbiAgICBjb25zdCBibG9iUGFydHMgPSBbXVxuICAgIGZvciAoY29uc3QgcGFydCBvZiBfcGFydHMpIHtcbiAgICAgIGNvbnN0IHsgYnl0ZUxlbmd0aCB9ID0gcGFydFxuICAgICAgaWYgKG9mZnNldCA+IDAgJiYgYnl0ZUxlbmd0aCA8PSBvZmZzZXQpIHtcbiAgICAgICAgb2Zmc2V0IC09IGJ5dGVMZW5ndGhcbiAgICAgICAgbGltaXQgLT0gYnl0ZUxlbmd0aFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgY2h1bmsgPSBwYXJ0LnN1YmFycmF5KG9mZnNldCwgTWF0aC5taW4oYnl0ZUxlbmd0aCwgbGltaXQpKVxuICAgICAgICBibG9iUGFydHMucHVzaChjaHVuaylcbiAgICAgICAgYmxvYlNpemUgKz0gY2h1bmsuYnl0ZUxlbmd0aFxuICAgICAgICAvLyBubyBsb25nZXIgbmVlZCB0byB0YWtlIHRoYXQgaW50byBhY2NvdW50XG4gICAgICAgIG9mZnNldCA9IDBcblxuICAgICAgICAvLyBkb24ndCBhZGQgdGhlIG92ZXJmbG93IHRvIG5ldyBibG9iUGFydHNcbiAgICAgICAgaWYgKGJsb2JTaXplID49IHNwYW4pIHtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgYmxvYi5fcGFydHMgPSBibG9iUGFydHNcbiAgICBibG9iLl9zaXplID0gYmxvYlNpemVcblxuICAgIHJldHVybiBibG9iXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIGFuIEFycmF5QnVmZmVyIGNvbnRhaW5pbmcgdGhlIGVudGlyZVxuICAgKiBjb250ZW50cyBvZiB0aGUgQmxvYiBhcyBiaW5hcnkgZGF0YS5cbiAgICogQHJldHVybnMge1Byb21pc2U8QXJyYXlCdWZmZXI+fVxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlcXVpcmUtYXdhaXRcbiAgYXN5bmMgYXJyYXlCdWZmZXIoKSB7XG4gICAgY29uc3QgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKHRoaXMuc2l6ZSlcbiAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlcilcbiAgICBsZXQgb2Zmc2V0ID0gMFxuICAgIGZvciAoY29uc3QgcGFydCBvZiB0aGlzLl9wYXJ0cykge1xuICAgICAgYnl0ZXMuc2V0KHBhcnQsIG9mZnNldClcbiAgICAgIG9mZnNldCArPSBwYXJ0LmJ5dGVMZW5ndGhcbiAgICB9XG4gICAgcmV0dXJuIGJ1ZmZlclxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCBhIFVTVlN0cmluZyBjb250YWluaW5nIHRoZSBlbnRpcmVcbiAgICogY29udGVudHMgb2YgdGhlIEJsb2IgaW50ZXJwcmV0ZWQgYXMgVVRGLTggdGV4dC5cbiAgICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nPn1cbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZXF1aXJlLWF3YWl0XG4gIGFzeW5jIHRleHQoKSB7XG4gICAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpXG4gICAgbGV0IHRleHQgPSBcIlwiXG4gICAgZm9yIChjb25zdCBwYXJ0IG9mIHRoaXMuX3BhcnRzKSB7XG4gICAgICB0ZXh0ICs9IGRlY29kZXIuZGVjb2RlKHBhcnQpXG4gICAgfVxuICAgIHJldHVybiB0ZXh0XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMge0Jsb2JTdHJlYW19XG4gICAqL1xuICBzdHJlYW0oKSB7XG4gICAgcmV0dXJuIG5ldyBCbG9iU3RyZWFtKHRoaXMuX3BhcnRzKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IEJsb2JdXCJcbiAgfVxuXG4gIGdldCBbU3ltYm9sLnRvU3RyaW5nVGFnXSgpIHtcbiAgICByZXR1cm4gXCJCbG9iXCJcbiAgfVxufVxuXG4vLyBNYXJraW5nIGV4cG9ydCBhcyBhIERPTSBGaWxlIG9iamVjdCBpbnN0ZWFkIG9mIGN1c3RvbSBjbGFzcy5cbi8qKiBAdHlwZSB7dHlwZW9mIGdsb2JhbFRoaXMuQmxvYn0gKi9cbmNvbnN0IEJsb2IgPSBXZWJCbG9iXG5cbi8qKlxuICogQmxvYiBzdHJlYW0gaXMgYSBgUmVhZGFibGVTdHJlYW1gIGV4dGVuc2lvbiBvcHRpbWl6ZWQgdG8gaGF2ZSBtaW5pbWFsXG4gKiBvdmVyaGVhZCB3aGVuIGNvbnN1bWVkIGFzIGBBc3luY0l0ZXJhYmxlPFVpbnQ4QXJyYXk+YC5cbiAqIEBleHRlbmRzIHtSZWFkYWJsZVN0cmVhbTxVaW50OEFycmF5Pn1cbiAqIEBpbXBsZW1lbnRzIHtBc3luY0l0ZXJhYmxlPFVpbnQ4QXJyYXk+fVxuICovXG5jbGFzcyBCbG9iU3RyZWFtIGV4dGVuZHMgUmVhZGFibGVTdHJlYW0ge1xuICAvKipcbiAgICogQHBhcmFtIHtVaW50OEFycmF5W119IGNodW5rc1xuICAgKi9cbiAgY29uc3RydWN0b3IoY2h1bmtzKSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHN1cGVyKG5ldyBCbG9iU3RyZWFtQ29udHJvbGxlcihjaHVua3MudmFsdWVzKCkpLCB7IHR5cGU6IFwiYnl0ZXNcIiB9KVxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIHRoaXMuX2NodW5rcyA9IGNodW5rc1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbX29wdGlvbnNdXG4gICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW19vcHRpb25zLnByZXZlbnRDYW5jZWxdXG4gICAqIEByZXR1cm5zIHtBc3luY0l0ZXJhdG9yPFVpbnQ4QXJyYXk+fVxuICAgKi9cbiAgYXN5bmMgKltTeW1ib2wuYXN5bmNJdGVyYXRvcl0oX29wdGlvbnMpIHtcbiAgICBjb25zdCByZWFkZXIgPSB0aGlzLmdldFJlYWRlcigpXG4gICAgeWllbGQqIHRoaXMuX2NodW5rc1xuICAgIHJlYWRlci5yZWxlYXNlTG9jaygpXG4gIH1cbn1cblxuY2xhc3MgQmxvYlN0cmVhbUNvbnRyb2xsZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtJdGVyYXRvcjxVaW50OEFycmF5Pn0gY2h1bmtzXG4gICAqL1xuICBjb25zdHJ1Y3RvcihjaHVua3MpIHtcbiAgICB0aGlzLmNodW5rcyA9IGNodW5rc1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7UmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcn0gY29udHJvbGxlclxuICAgKi9cbiAgc3RhcnQoY29udHJvbGxlcikge1xuICAgIHRoaXMud29yayhjb250cm9sbGVyKVxuICAgIHRoaXMuaXNXb3JraW5nID0gZmFsc2VcbiAgICB0aGlzLmlzQ2FuY2VsbGVkID0gZmFsc2VcbiAgfVxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyfSBjb250cm9sbGVyXG4gICAqL1xuICBhc3luYyB3b3JrKGNvbnRyb2xsZXIpIHtcbiAgICBjb25zdCB7IGNodW5rcyB9ID0gdGhpc1xuXG4gICAgdGhpcy5pc1dvcmtpbmcgPSB0cnVlXG4gICAgd2hpbGUgKCF0aGlzLmlzQ2FuY2VsbGVkICYmIChjb250cm9sbGVyLmRlc2lyZWRTaXplIHx8IDApID4gMCkge1xuICAgICAgbGV0IG5leHQgPSBudWxsXG4gICAgICB0cnkge1xuICAgICAgICBuZXh0ID0gY2h1bmtzLm5leHQoKVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29udHJvbGxlci5lcnJvcihlcnJvcilcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cblxuICAgICAgaWYgKG5leHQpIHtcbiAgICAgICAgaWYgKCFuZXh0LmRvbmUgJiYgIXRoaXMuaXNDYW5jZWxsZWQpIHtcbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUobmV4dC52YWx1ZSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb250cm9sbGVyLmNsb3NlKClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuaXNXb3JraW5nID0gZmFsc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1JlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJ9IGNvbnRyb2xsZXJcbiAgICovXG4gIHB1bGwoY29udHJvbGxlcikge1xuICAgIGlmICghdGhpcy5pc1dvcmtpbmcpIHtcbiAgICAgIHRoaXMud29yayhjb250cm9sbGVyKVxuICAgIH1cbiAgfVxuICBjYW5jZWwoKSB7XG4gICAgdGhpcy5pc0NhbmNlbGxlZCA9IHRydWVcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBbaW5wdXRdXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5jb25zdCByZWFkVHlwZSA9IChpbnB1dCA9IFwiXCIpID0+IHtcbiAgY29uc3QgdHlwZSA9IFN0cmluZyhpbnB1dCkudG9Mb3dlckNhc2UoKVxuICByZXR1cm4gL1teXFx1MDAyMC1cXHUwMDdFXS8udGVzdCh0eXBlKSA/IFwiXCIgOiB0eXBlXG59XG5cbmV4cG9ydCB7IEJsb2IsIFJlYWRhYmxlU3RyZWFtLCBUZXh0RW5jb2RlciwgVGV4dERlY29kZXIgfVxuIiwgImV4cG9ydCB7IFRleHRFbmNvZGVyLCBUZXh0RGVjb2RlciwgUmVhZGFibGVTdHJlYW0gfSBmcm9tIFwiLi9wYWNrYWdlLmpzXCJcbi8vIGltcG9ydCB7IEJsb2IgYXMgTm9kZUJsb2IgfSBmcm9tIFwiLi9ibG9iLm5vZGUuanNcIlxuaW1wb3J0IHsgQmxvYiBhcyBXZWJCbG9iIH0gZnJvbSBcIi4vYmxvYi5qc1wiXG5cbi8qKiBAdHlwZSB7dHlwZW9mIGdsb2JhbFRoaXMuQmxvYn0gKi9cbi8vIE91ciBmaXJzdCBjaG9pc2UgaXMgdG8gdXNlIGdsb2JhbCBgQmxvYmAgYmVjYXVzZSBpdCBtYXkgYmUgYXZhaWxhYmxlIGUuZy4gaW5cbi8vIGVsZWN0cm9uIHJlbmRlcnJlciBwcm9jZXNzLiBJZiBub3QgYXZhaWxhYmxlIGZhbGwgYmFjayB0byBub2RlIG5hdGl2ZVxuLy8gaW1wbGVtZW50YXRpb24sIGlmIGFsc28gbm90IGF2YWlsYWJsZSB1c2Ugb3VyIGltcGxlbWVudGF0aW9uLlxuZXhwb3J0IGNvbnN0IEJsb2IgPVxuICBnbG9iYWxUaGlzLkJsb2IgfHwgXG4gIC8vIERpc2FibGUgbm9kZSBuYXRpdmUgYmxvYiB1bnRpbCBpbXByYWN0aWNhbCBwZXJmIGlzc3VlIGlzIGZpeGVkXG4gIC8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2lzc3Vlcy80MjEwOFxuICAvLyBOb2RlQmxvYiB8fFxuICBXZWJCbG9iXG4iLCAiaW1wb3J0IHsgQmxvYiB9IGZyb20gXCIuL3BhY2thZ2UuanNcIlxuXG4vKipcbiAqIEBpbXBsZW1lbnRzIHtnbG9iYWxUaGlzLkZpbGV9XG4gKi9cbmV4cG9ydCBjbGFzcyBGaWxlIGV4dGVuZHMgQmxvYiB7XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge0Jsb2JQYXJ0W119IGluaXRcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBBIFVTVlN0cmluZyByZXByZXNlbnRpbmcgdGhlIGZpbGUgbmFtZSBvciB0aGUgcGF0aFxuICAgKiB0byB0aGUgZmlsZS5cbiAgICogQHBhcmFtIHtGaWxlUHJvcGVydHlCYWd9IFtvcHRpb25zXVxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgaW5pdCxcbiAgICBuYW1lID0gcGFuaWMobmV3IFR5cGVFcnJvcihcIkZpbGUgY29uc3RydWN0b3IgcmVxdWlyZXMgbmFtZSBhcmd1bWVudFwiKSksXG4gICAgb3B0aW9ucyA9IHt9XG4gICkge1xuICAgIHN1cGVyKGluaXQsIG9wdGlvbnMpXG4gICAgLy8gUGVyIEZpbGUgQVBJIHNwZWMgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL0ZpbGVBUEkvI2ZpbGUtY29uc3RydWN0b3JcbiAgICAvLyBFdmVyeSBcIi9cIiBjaGFyYWN0ZXIgb2YgZmlsZSBuYW1lIG11c3QgYmUgcmVwbGFjZWQgd2l0aCBhIFwiOlwiLlxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIHRoaXMuX25hbWUgPSBuYW1lXG4gICAgLy8gSXQgYXBwZWFycyB0aGF0IGJyb3dzZXIgZG8gbm90IGZvbGxvdyB0aGUgc3BlYyBoZXJlLlxuICAgIC8vIFN0cmluZyhuYW1lKS5yZXBsYWNlKC9cXC8vZywgXCI6XCIpXG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgdGhpcy5fbGFzdE1vZGlmaWVkID0gb3B0aW9ucy5sYXN0TW9kaWZpZWQgfHwgRGF0ZS5ub3coKVxuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBuYW1lIG9mIHRoZSBmaWxlIHJlZmVyZW5jZWQgYnkgdGhlIEZpbGUgb2JqZWN0LlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IG5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX25hbWVcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgcGF0aCB0aGUgVVJMIG9mIHRoZSBGaWxlIGlzIHJlbGF0aXZlIHRvLlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IHdlYmtpdFJlbGF0aXZlUGF0aCgpIHtcbiAgICByZXR1cm4gXCJcIlxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGxhc3QgbW9kaWZpZWQgdGltZSBvZiB0aGUgZmlsZSwgaW4gbWlsbGlzZWNvbmQgc2luY2UgdGhlIFVOSVhcbiAgICogZXBvY2ggKEphbnVhcnkgMXN0LCAxOTcwIGF0IE1pZG5pZ2h0KS5cbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICovXG4gIGdldCBsYXN0TW9kaWZpZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xhc3RNb2RpZmllZFxuICB9XG5cbiAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCkge1xuICAgIHJldHVybiBcIkZpbGVcIlxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHsqfSBlcnJvclxuICogQHJldHVybnMge25ldmVyfVxuICovXG5jb25zdCBwYW5pYyA9IGVycm9yID0+IHtcbiAgdGhyb3cgZXJyb3Jcbn1cbiIsICJcInVzZSBzdHJpY3RcIlxuXG5pbXBvcnQgeyBCbG9iIH0gZnJvbSBcIi4vcGFja2FnZS5qc1wiXG5pbXBvcnQgeyBGaWxlIGFzIFdlYkZpbGUgfSBmcm9tIFwiLi9maWxlLmpzXCJcblxuLy8gRWxlY3Ryb24tcmVuZGVyZXIgc2hvdWxkIGdldCB0aGUgYnJvd3NlciBpbXBsZW1lbnRhdGlvbiBpbnN0ZWFkIG9mIG5vZGVcbi8vIEJyb3dzZXIgY29uZmlndXJhdGlvbiBpcyBub3QgZW5vdWdoXG5cbi8vIE1hcmtpbmcgZXhwb3J0IGFzIGEgRE9NIEZpbGUgb2JqZWN0IGluc3RlYWQgb2YgY3VzdG9tIGNsYXNzLlxuLyoqIEB0eXBlIHt0eXBlb2YgZ2xvYmFsVGhpcy5GaWxlfSAqL1xuY29uc3QgRmlsZSA9IHR5cGVvZiBnbG9iYWxUaGlzLkZpbGUgPT09IFwiZnVuY3Rpb25cIiA/IGdsb2JhbFRoaXMuRmlsZSA6IFdlYkZpbGVcblxuZXhwb3J0IHsgRmlsZSwgQmxvYiB9XG4iLCAiLyoqXG4gKiBAaW1wbGVtZW50cyB7Z2xvYmFsVGhpcy5Gb3JtRGF0YX1cbiAqL1xuZXhwb3J0IGNsYXNzIEZvcm1EYXRhIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEZvcm1FbGVtZW50fSBbZm9ybV1cbiAgICovXG4gIGNvbnN0cnVjdG9yKGZvcm0pIHtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZWFkb25seVxuICAgICAqIEB0eXBlIHtBcnJheTxbc3RyaW5nLCBGb3JtRGF0YUVudHJ5VmFsdWVdPn1cbiAgICAgKi9cbiAgICB0aGlzLl9lbnRyaWVzID0gW11cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9lbnRyaWVzXCIsIHsgZW51bWVyYWJsZTogZmFsc2UgfSlcblxuICAgIGlmIChpc0hUTUxGb3JtRWxlbWVudChmb3JtKSkge1xuICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGZvcm0uZWxlbWVudHMpIHtcbiAgICAgICAgaWYgKGlzU2VsZWN0RWxlbWVudChlbGVtZW50KSkge1xuICAgICAgICAgIGZvciAoY29uc3Qgb3B0aW9uIG9mIGVsZW1lbnQub3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKG9wdGlvbi5zZWxlY3RlZCkge1xuICAgICAgICAgICAgICB0aGlzLmFwcGVuZChlbGVtZW50Lm5hbWUsIG9wdGlvbi52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgIGlzSW5wdXRFbGVtZW50KGVsZW1lbnQpICYmXG4gICAgICAgICAgKGVsZW1lbnQuY2hlY2tlZCB8fCAhW1wicmFkaW9cIiwgXCJjaGVja2JveFwiXS5pbmNsdWRlcyhlbGVtZW50LnR5cGUpKSAmJlxuICAgICAgICAgIGVsZW1lbnQubmFtZVxuICAgICAgICApIHtcbiAgICAgICAgICB0aGlzLmFwcGVuZChlbGVtZW50Lm5hbWUsIGVsZW1lbnQudmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGdldCBbU3ltYm9sLnRvU3RyaW5nVGFnXSgpIHtcbiAgICByZXR1cm4gXCJGb3JtRGF0YVwiXG4gIH1cblxuICAvKipcbiAgICogQXBwZW5kcyBhIG5ldyB2YWx1ZSBvbnRvIGFuIGV4aXN0aW5nIGtleSBpbnNpZGUgYSBGb3JtRGF0YSBvYmplY3QsIG9yIGFkZHNcbiAgICogdGhlIGtleSBpZiBpdCBkb2VzIG5vdCBhbHJlYWR5IGV4aXN0LlxuICAgKlxuICAgKiBUaGUgZGlmZmVyZW5jZSBiZXR3ZWVuIGBzZXRgIGFuZCBgYXBwZW5kYCBpcyB0aGF0IGlmIHRoZSBzcGVjaWZpZWQga2V5XG4gICAqIGFscmVhZHkgZXhpc3RzLCBgc2V0YCB3aWxsIG92ZXJ3cml0ZSBhbGwgZXhpc3RpbmcgdmFsdWVzIHdpdGggdGhlIG5ldyBvbmUsXG4gICAqIHdoZXJlYXMgYGFwcGVuZGAgd2lsbCBhcHBlbmQgdGhlIG5ldyB2YWx1ZSBvbnRvIHRoZSBlbmQgb2YgdGhlIGV4aXN0aW5nXG4gICAqIHNldCBvZiB2YWx1ZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfEJsb2J8RmlsZX0gdmFsdWUgLSBUaGUgbmFtZSBvZiB0aGUgZmllbGQgd2hvc2UgZGF0YSBpc1xuICAgKiBjb250YWluZWQgaW4gdmFsdWUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbZmlsZW5hbWVdIC0gVGhlIGZpbGVuYW1lIHJlcG9ydGVkIHRvIHRoZSBzZXJ2ZXIsIHdoZW4gYVxuICAgKiB2YWx1ZSBpcyBhIGBCbG9iYCBvciBhIGBGaWxlYC4gVGhlIGRlZmF1bHQgZmlsZW5hbWUgZm9yIGEgYEJsb2JgIG9iamVjdHMgaXNcbiAgICogYFwiYmxvYlwiYC4gVGhlIGRlZmF1bHQgZmlsZW5hbWUgZm9yIGEgYEZpbGVgIGlzIHRoZSBpdCdzIG5hbWUuXG4gICAqL1xuICBhcHBlbmQoXG4gICAgbmFtZSxcbiAgICB2YWx1ZSA9IHBhbmljKFxuICAgICAgbmV3IFR5cGVFcnJvcihcIkZvcm1EYXRhLmFwcGVuZDogcmVxdWlyZXMgYXQgbGVhc3QgMiBhcmd1bWVudHNcIilcbiAgICApLFxuICAgIGZpbGVuYW1lXG4gICkge1xuICAgIHRoaXMuX2VudHJpZXMucHVzaChbbmFtZSwgdG9FbnRyeVZhbHVlKHZhbHVlLCBmaWxlbmFtZSldKVxuICB9XG5cbiAgLyoqXG4gICAqIERlbGV0ZXMgYSBrZXkgYW5kIGFsbCBpdHMgdmFsdWVzIGZyb20gYSBGb3JtRGF0YSBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqL1xuICBkZWxldGUoXG4gICAgbmFtZSA9IHBhbmljKG5ldyBUeXBlRXJyb3IoXCJGb3JtRGF0YS5kZWxldGU6IHJlcXVpcmVzIHN0cmluZyBhcmd1bWVudFwiKSlcbiAgKSB7XG4gICAgY29uc3QgZW50cmllcyA9IHRoaXMuX2VudHJpZXNcbiAgICBsZXQgaW5kZXggPSAwXG4gICAgd2hpbGUgKGluZGV4IDwgZW50cmllcy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IFtlbnRyeU5hbWVdID0gLyoqIEB0eXBlIHtbc3RyaW5nLCBGb3JtRGF0YUVudHJ5VmFsdWVdfSovIChcbiAgICAgICAgZW50cmllc1tpbmRleF1cbiAgICAgIClcbiAgICAgIGlmIChlbnRyeU5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgZW50cmllcy5zcGxpY2UoaW5kZXgsIDEpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbmRleCsrXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGZpcnN0IHZhbHVlIGFzc29jaWF0ZWQgd2l0aCBhIGdpdmVuIGtleSBmcm9tIHdpdGhpbiBhXG4gICAqIEZvcm1EYXRhIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHJldHVybnMge0Zvcm1EYXRhRW50cnlWYWx1ZXxudWxsfVxuICAgKi9cblxuICBnZXQobmFtZSA9IHBhbmljKG5ldyBUeXBlRXJyb3IoXCJGb3JtRGF0YS5nZXQ6IHJlcXVpcmVzIHN0cmluZyBhcmd1bWVudFwiKSkpIHtcbiAgICBmb3IgKGNvbnN0IFtlbnRyeU5hbWUsIHZhbHVlXSBvZiB0aGlzLl9lbnRyaWVzKSB7XG4gICAgICBpZiAoZW50cnlOYW1lID09PSBuYW1lKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gYXJyYXkgb2YgYWxsIHRoZSB2YWx1ZXMgYXNzb2NpYXRlZCB3aXRoIGEgZ2l2ZW4ga2V5IGZyb20gd2l0aGluXG4gICAqIGEgRm9ybURhdGEuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEByZXR1cm5zIHtGb3JtRGF0YUVudHJ5VmFsdWVbXX1cbiAgICovXG4gIGdldEFsbChcbiAgICBuYW1lID0gcGFuaWMobmV3IFR5cGVFcnJvcihcIkZvcm1EYXRhLmdldEFsbDogcmVxdWlyZXMgc3RyaW5nIGFyZ3VtZW50XCIpKVxuICApIHtcbiAgICBjb25zdCB2YWx1ZXMgPSBbXVxuICAgIGZvciAoY29uc3QgW2VudHJ5TmFtZSwgdmFsdWVdIG9mIHRoaXMuX2VudHJpZXMpIHtcbiAgICAgIGlmIChlbnRyeU5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgdmFsdWVzLnB1c2godmFsdWUpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZXNcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgYm9vbGVhbiBzdGF0aW5nIHdoZXRoZXIgYSBGb3JtRGF0YSBvYmplY3QgY29udGFpbnMgYSBjZXJ0YWluIGtleS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICovXG5cbiAgaGFzKG5hbWUgPSBwYW5pYyhuZXcgVHlwZUVycm9yKFwiRm9ybURhdGEuaGFzOiByZXF1aXJlcyBzdHJpbmcgYXJndW1lbnRcIikpKSB7XG4gICAgZm9yIChjb25zdCBbZW50cnlOYW1lXSBvZiB0aGlzLl9lbnRyaWVzKSB7XG4gICAgICBpZiAoZW50cnlOYW1lID09PSBuYW1lKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgYSBuZXcgdmFsdWUgZm9yIGFuIGV4aXN0aW5nIGtleSBpbnNpZGUgYSBGb3JtRGF0YSBvYmplY3QsIG9yIGFkZHMgdGhlXG4gICAqIGtleS92YWx1ZSBpZiBpdCBkb2VzIG5vdCBhbHJlYWR5IGV4aXN0LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0ge3N0cmluZ3xCbG9ifEZpbGV9IHZhbHVlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbZmlsZW5hbWVdXG4gICAqL1xuXG4gIHNldChcbiAgICBuYW1lLFxuICAgIHZhbHVlID0gcGFuaWMobmV3IFR5cGVFcnJvcihcIkZvcm1EYXRhLnNldDogcmVxdWlyZXMgYXQgbGVhc3QgMiBhcmd1bWVudHNcIikpLFxuICAgIGZpbGVuYW1lXG4gICkge1xuICAgIGxldCBpbmRleCA9IDBcbiAgICBjb25zdCB7IF9lbnRyaWVzOiBlbnRyaWVzIH0gPSB0aGlzXG4gICAgY29uc3QgZW50cnlWYWx1ZSA9IHRvRW50cnlWYWx1ZSh2YWx1ZSwgZmlsZW5hbWUpXG4gICAgbGV0IHdhc1NldCA9IGZhbHNlXG4gICAgd2hpbGUgKGluZGV4IDwgZW50cmllcy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGVudHJ5ID0gLyoqIEB0eXBlIHtbc3RyaW5nLCBGb3JtRGF0YUVudHJ5VmFsdWVdfSovIChlbnRyaWVzW2luZGV4XSlcbiAgICAgIGlmIChlbnRyeVswXSA9PT0gbmFtZSkge1xuICAgICAgICBpZiAod2FzU2V0KSB7XG4gICAgICAgICAgZW50cmllcy5zcGxpY2UoaW5kZXgsIDEpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2FzU2V0ID0gdHJ1ZVxuICAgICAgICAgIGVudHJ5WzFdID0gZW50cnlWYWx1ZVxuICAgICAgICAgIGluZGV4KytcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5kZXgrK1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghd2FzU2V0KSB7XG4gICAgICBlbnRyaWVzLnB1c2goW25hbWUsIGVudHJ5VmFsdWVdKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgcmV0dXJucyBhbiBpdGVyYXRvciBhbGxvd2luZyB0byBnbyB0aHJvdWdoIGFsbCBrZXkvdmFsdWUgcGFpcnNcbiAgICogY29udGFpbmVkIGluIHRoaXMgb2JqZWN0LlxuICAgKi9cbiAgZW50cmllcygpIHtcbiAgICByZXR1cm4gdGhpcy5fZW50cmllcy52YWx1ZXMoKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gaXRlcmF0b3IgYWxsb3dpbmcgdG8gZ28gdGhyb3VnaCBhbGwga2V5cyBvZiB0aGUga2V5L3ZhbHVlIHBhaXJzXG4gICAqIGNvbnRhaW5lZCBpbiB0aGlzIG9iamVjdC5cbiAgICpcbiAgICogQHJldHVybnMge0l0ZXJhYmxlSXRlcmF0b3I8c3RyaW5nPn1cbiAgICovXG4gICprZXlzKCkge1xuICAgIGZvciAoY29uc3QgW25hbWVdIG9mIHRoaXMuX2VudHJpZXMpIHtcbiAgICAgIHlpZWxkIG5hbWVcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBpdGVyYXRvciBhbGxvd2luZyB0byBnbyB0aHJvdWdoIGFsbCB2YWx1ZXMgY29udGFpbmVkIGluIHRoaXNcbiAgICogb2JqZWN0LlxuICAgKlxuICAgKiBAcmV0dXJucyB7SXRlcmFibGVJdGVyYXRvcjxGb3JtRGF0YUVudHJ5VmFsdWU+fVxuICAgKi9cbiAgKnZhbHVlcygpIHtcbiAgICBmb3IgKGNvbnN0IFtfLCB2YWx1ZV0gb2YgdGhpcy5fZW50cmllcykge1xuICAgICAgeWllbGQgdmFsdWVcbiAgICB9XG4gIH1cblxuICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZW50cmllcy52YWx1ZXMoKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7KHZhbHVlOiBGb3JtRGF0YUVudHJ5VmFsdWUsIGtleTogc3RyaW5nLCBwYXJlbnQ6IGdsb2JhbFRoaXMuRm9ybURhdGEpID0+IHZvaWR9IGZuXG4gICAqIEBwYXJhbSB7YW55fSBbdGhpc0FyZ11cbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBmb3JFYWNoKGZuLCB0aGlzQXJnKSB7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgdGhpcy5fZW50cmllcykge1xuICAgICAgZm4uY2FsbCh0aGlzQXJnLCB2YWx1ZSwga2V5LCB0aGlzKVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuICogQHJldHVybnMge3ZhbHVlIGlzIEhUTUxGb3JtRWxlbWVudH1cbiAqL1xuY29uc3QgaXNIVE1MRm9ybUVsZW1lbnQgPSB2YWx1ZSA9PlxuICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpID09PSBcIltvYmplY3QgSFRNTEZvcm1FbGVtZW50XVwiXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8QmxvYnxGaWxlfSB2YWx1ZVxuICogQHBhcmFtIHtzdHJpbmd9IFtmaWxlbmFtZV1cbiAqIEByZXR1cm5zIHtGb3JtRGF0YUVudHJ5VmFsdWV9XG4gKi9cbmNvbnN0IHRvRW50cnlWYWx1ZSA9ICh2YWx1ZSwgZmlsZW5hbWUpID0+IHtcbiAgaWYgKGlzRmlsZSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmlsZW5hbWUgIT0gbnVsbCA/IG5ldyBCbG9iRmlsZShbdmFsdWVdLCBmaWxlbmFtZSwgdmFsdWUpIDogdmFsdWVcbiAgfSBlbHNlIGlmIChpc0Jsb2IodmFsdWUpKSB7XG4gICAgcmV0dXJuIG5ldyBCbG9iRmlsZShbdmFsdWVdLCBmaWxlbmFtZSAhPSBudWxsID8gZmlsZW5hbWUgOiBcImJsb2JcIilcbiAgfSBlbHNlIHtcbiAgICBpZiAoZmlsZW5hbWUgIT0gbnVsbCAmJiBmaWxlbmFtZSAhPSBcIlwiKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICBcImZpbGVuYW1lIGlzIG9ubHkgc3VwcG9ydGVkIHdoZW4gdmFsdWUgaXMgQmxvYiBvciBGaWxlXCJcbiAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIGAke3ZhbHVlfWBcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuICogQHJldHVybnMge3ZhbHVlIGlzIEZpbGV9XG4gKi9cbmNvbnN0IGlzRmlsZSA9IHZhbHVlID0+XG4gIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09IFwiW29iamVjdCBGaWxlXVwiICYmXG4gIHR5cGVvZiB2YWx1ZS5uYW1lID09PSBcInN0cmluZ1wiXG5cbi8qKlxuICogQHBhcmFtIHthbnl9IHZhbHVlXG4gKiBAcmV0dXJucyB7dmFsdWUgaXMgQmxvYn1cbiAqL1xuY29uc3QgaXNCbG9iID0gdmFsdWUgPT5cbiAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gXCJbb2JqZWN0IEJsb2JdXCJcblxuLyoqXG4gKiBTaW1wbGUgYEZpbGVgIGltcGxlbWVudGF0aW9uIHRoYXQganVzdCB3cmFwcyBhIGdpdmVuIGJsb2IuXG4gKiBAaW1wbGVtZW50cyB7Z2xvYmFsVGhpcy5GaWxlfVxuICovXG5jb25zdCBCbG9iRmlsZSA9IGNsYXNzIEZpbGUge1xuICAvKipcbiAgICogQHBhcmFtIHtbQmxvYl19IHBhcnRzXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7RmlsZVByb3BlcnR5QmFnfSBbb3B0aW9uc11cbiAgICovXG4gIGNvbnN0cnVjdG9yKFtibG9iXSwgbmFtZSwgeyBsYXN0TW9kaWZpZWQgPSBEYXRlLm5vdygpIH0gPSB7fSkge1xuICAgIHRoaXMuYmxvYiA9IGJsb2JcbiAgICB0aGlzLm5hbWUgPSBuYW1lXG4gICAgdGhpcy5sYXN0TW9kaWZpZWQgPSBsYXN0TW9kaWZpZWRcbiAgfVxuICBnZXQgd2Via2l0UmVsYXRpdmVQYXRoKCkge1xuICAgIHJldHVybiBcIlwiXG4gIH1cbiAgZ2V0IHNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuYmxvYi5zaXplXG4gIH1cbiAgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuYmxvYi50eXBlXG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnRdXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kXVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2NvbnRlbnRUeXBlXVxuICAgKi9cbiAgc2xpY2Uoc3RhcnQsIGVuZCwgY29udGVudFR5cGUpIHtcbiAgICByZXR1cm4gdGhpcy5ibG9iLnNsaWNlKHN0YXJ0LCBlbmQsIGNvbnRlbnRUeXBlKVxuICB9XG4gIHN0cmVhbSgpIHtcbiAgICByZXR1cm4gdGhpcy5ibG9iLnN0cmVhbSgpXG4gIH1cbiAgdGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy5ibG9iLnRleHQoKVxuICB9XG4gIGFycmF5QnVmZmVyKCkge1xuICAgIHJldHVybiB0aGlzLmJsb2IuYXJyYXlCdWZmZXIoKVxuICB9XG4gIGdldCBbU3ltYm9sLnRvU3RyaW5nVGFnXSgpIHtcbiAgICByZXR1cm4gXCJGaWxlXCJcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7Kn0gZXJyb3JcbiAqIEByZXR1cm5zIHtuZXZlcn1cbiAqL1xuY29uc3QgcGFuaWMgPSBlcnJvciA9PiB7XG4gIHRocm93IGVycm9yXG59XG5cbi8qKlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge2VsZW1lbnQgaXMgSFRNTFNlbGVjdEVsZW1lbnR9XG4gKi9cbmZ1bmN0aW9uIGlzU2VsZWN0RWxlbWVudChlbGVtZW50KSB7XG4gIHJldHVybiBlbGVtZW50LnRhZ05hbWUgPT09IFwiU0VMRUNUXCI7XG59XG5cbi8qKlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge2VsZW1lbnQgaXMgSFRNTElucHV0RWxlbWVudH1cbiAqL1xuZnVuY3Rpb24gaXNJbnB1dEVsZW1lbnQoZWxlbWVudCkge1xuICByZXR1cm4gZWxlbWVudC50YWdOYW1lID09PSBcIklOUFVUXCIgfHwgZWxlbWVudC50YWdOYW1lID09PSBcIlRFWFRBUkVBXCI7XG59XG4iLCAiLy8gQHRzLWNoZWNrXG5cInVzZSBzdHJpY3RcIlxuXG5pbXBvcnQgKiBhcyBwb2x5ZmlsbCBmcm9tIFwiLi9mb3JtLWRhdGEuanNcIlxuXG4vLyBFbGVjdHJvbi1yZW5kZXJlciBzaG91bGQgZ2V0IHRoZSBicm93c2VyIGltcGxlbWVudGF0aW9uIGluc3RlYWQgb2Ygbm9kZVxuLy8gd2hpY2ggaXMgd2h5IHdlIGNoZWNrIGdsb2JhbCBmaXJzdC5cbmV4cG9ydCBjb25zdCBGb3JtRGF0YSA9XG4gIHR5cGVvZiBnbG9iYWxUaGlzLkZvcm1EYXRhID09PSBcImZ1bmN0aW9uXCJcbiAgICA/IGdsb2JhbFRoaXMuRm9ybURhdGFcbiAgICA6IHBvbHlmaWxsLkZvcm1EYXRhXG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnQgY2xhc3MgRmV0Y2hCYXNlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG5cdC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSBcblx0ICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihtZXNzYWdlLCB0eXBlKSB7XG5cdFx0c3VwZXIobWVzc2FnZSk7XG5cdFx0Ly8gSGlkZSBjdXN0b20gZXJyb3IgaW1wbGVtZW50YXRpb24gZGV0YWlscyBmcm9tIGVuZC11c2Vyc1xuXHRcdEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpO1xuXG5cdFx0dGhpcy50eXBlID0gdHlwZTtcblx0fVxuXG5cdGdldCBuYW1lKCkge1xuXHRcdHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG5cdH1cblxuXHRnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG5cdFx0cmV0dXJuIHRoaXMuY29uc3RydWN0b3IubmFtZTtcblx0fVxufVxuXG4iLCAiXG5pbXBvcnQge0ZldGNoQmFzZUVycm9yfSBmcm9tICcuL2Jhc2UuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHt7XG4gKiBhZGRyZXNzPzogc3RyaW5nXG4gKiBjb2RlOiBzdHJpbmdcbiAqIGRlc3Q/OiBzdHJpbmdcbiAqIGVycm5vOiBudW1iZXJcbiAqIGluZm8/OiBvYmplY3RcbiAqIG1lc3NhZ2U6IHN0cmluZ1xuICogcGF0aD86IHN0cmluZ1xuICogcG9ydD86IG51bWJlclxuICogc3lzY2FsbDogc3RyaW5nXG4gKiB9fSBTeXN0ZW1FcnJvclxuKi9cblxuLyoqXG4gKiBGZXRjaEVycm9yIGludGVyZmFjZSBmb3Igb3BlcmF0aW9uYWwgZXJyb3JzXG4gKi9cbmV4cG9ydCBjbGFzcyBGZXRjaEVycm9yIGV4dGVuZHMgRmV0Y2hCYXNlRXJyb3Ige1xuXHQvKipcblx0ICogQHBhcmFtICB7c3RyaW5nfSBtZXNzYWdlIC0gICAgICBFcnJvciBtZXNzYWdlIGZvciBodW1hblxuXHQgKiBAcGFyYW0gIHtzdHJpbmd9IHR5cGUgLSAgICAgICAgRXJyb3IgdHlwZSBmb3IgbWFjaGluZVxuXHQgKiBAcGFyYW0gIHtTeXN0ZW1FcnJvcn0gW3N5c3RlbUVycm9yXSAtIEZvciBOb2RlLmpzIHN5c3RlbSBlcnJvclxuXHQgKi9cblx0Y29uc3RydWN0b3IobWVzc2FnZSwgdHlwZSwgc3lzdGVtRXJyb3IpIHtcblx0XHRzdXBlcihtZXNzYWdlLCB0eXBlKTtcblx0XHQvLyBXaGVuIGVyci50eXBlIGlzIGBzeXN0ZW1gLCBlcnIuZXJyb3JlZFN5c0NhbGwgY29udGFpbnMgc3lzdGVtIGVycm9yIGFuZCBlcnIuY29kZSBjb250YWlucyBzeXN0ZW0gZXJyb3IgY29kZVxuXHRcdGlmIChzeXN0ZW1FcnJvcikge1xuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW11bHRpLWFzc2lnblxuXHRcdFx0dGhpcy5jb2RlID0gdGhpcy5lcnJubyA9IHN5c3RlbUVycm9yLmNvZGU7XG5cdFx0XHR0aGlzLmVycm9yZWRTeXNDYWxsID0gc3lzdGVtRXJyb3Iuc3lzY2FsbDtcblx0XHR9XG5cdH1cbn1cbiIsICJpbXBvcnQge3JhbmRvbUJ5dGVzfSBmcm9tICdjcnlwdG8nO1xuaW1wb3J0IHsgaXRlcmF0ZU11bHRpcGFydCB9IGZyb20gJ0B3ZWIzLXN0b3JhZ2UvbXVsdGlwYXJ0LXBhcnNlcic7XG5pbXBvcnQgeyBGb3JtRGF0YSwgRmlsZSB9IGZyb20gJy4uL3BhY2thZ2UuanMnO1xuaW1wb3J0IHsgaXNCbG9iIH0gZnJvbSAnLi9pcy5qcyc7XG5cbmNvbnN0IGNhcnJpYWdlID0gJ1xcclxcbic7XG5jb25zdCBkYXNoZXMgPSAnLScucmVwZWF0KDIpO1xuY29uc3QgY2FycmlhZ2VMZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aChjYXJyaWFnZSk7XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGJvdW5kYXJ5XG4gKi9cbmNvbnN0IGdldEZvb3RlciA9IGJvdW5kYXJ5ID0+IGAke2Rhc2hlc30ke2JvdW5kYXJ5fSR7ZGFzaGVzfSR7Y2FycmlhZ2UucmVwZWF0KDIpfWA7XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGJvdW5kYXJ5XG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHsqfSBmaWVsZFxuICpcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZ2V0SGVhZGVyKGJvdW5kYXJ5LCBuYW1lLCBmaWVsZCkge1xuXHRsZXQgaGVhZGVyID0gJyc7XG5cblx0aGVhZGVyICs9IGAke2Rhc2hlc30ke2JvdW5kYXJ5fSR7Y2FycmlhZ2V9YDtcblx0aGVhZGVyICs9IGBDb250ZW50LURpc3Bvc2l0aW9uOiBmb3JtLWRhdGE7IG5hbWU9XCIke25hbWV9XCJgO1xuXG5cdGlmIChpc0Jsb2IoZmllbGQpKSB7XG5cdFx0Y29uc3QgeyBuYW1lID0gJ2Jsb2InLCB0eXBlIH0gPSAvKiogQHR5cGUge0Jsb2IgJiB7bmFtZT86c3RyaW5nfX0gKi8gKGZpZWxkKTtcblx0XHRoZWFkZXIgKz0gYDsgZmlsZW5hbWU9XCIke25hbWV9XCIke2NhcnJpYWdlfWA7XG5cdFx0aGVhZGVyICs9IGBDb250ZW50LVR5cGU6ICR7dHlwZSB8fCAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJ31gO1xuXHR9XG5cblx0cmV0dXJuIGAke2hlYWRlcn0ke2NhcnJpYWdlLnJlcGVhdCgyKX1gO1xufVxuXG4vKipcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGNvbnN0IGdldEJvdW5kYXJ5ID0gKCkgPT4gcmFuZG9tQnl0ZXMoOCkudG9TdHJpbmcoJ2hleCcpO1xuXG4vKipcbiAqIEBwYXJhbSB7Rm9ybURhdGF9IGZvcm1cbiAqIEBwYXJhbSB7c3RyaW5nfSBib3VuZGFyeVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gKiBmb3JtRGF0YUl0ZXJhdG9yKGZvcm0sIGJvdW5kYXJ5KSB7XG5cdGNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcblx0Zm9yIChjb25zdCBbbmFtZSwgdmFsdWVdIG9mIGZvcm0pIHtcblx0XHR5aWVsZCBlbmNvZGVyLmVuY29kZShnZXRIZWFkZXIoYm91bmRhcnksIG5hbWUsIHZhbHVlKSk7XG5cblx0XHRpZiAoaXNCbG9iKHZhbHVlKSkge1xuXHRcdFx0Ly8gQHRzLWlnbm9yZSAtIHdlIGtub3cgb3VyIHN0cmVhbXMgaW1wbGVtZW50IGF5c25jIGl0ZXJhdGlvblxuXHRcdFx0eWllbGQgKiB2YWx1ZS5zdHJlYW0oKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0eWllbGQgZW5jb2Rlci5lbmNvZGUodmFsdWUpO1xuXHRcdH1cblxuXHRcdHlpZWxkIGVuY29kZXIuZW5jb2RlKGNhcnJpYWdlKTtcblx0fVxuXG5cdHlpZWxkIGVuY29kZXIuZW5jb2RlKGdldEZvb3Rlcihib3VuZGFyeSkpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Rm9ybURhdGF9IGZvcm1cbiAqIEBwYXJhbSB7c3RyaW5nfSBib3VuZGFyeVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Rm9ybURhdGFMZW5ndGgoZm9ybSwgYm91bmRhcnkpIHtcblx0bGV0IGxlbmd0aCA9IDA7XG5cblx0Zm9yIChjb25zdCBbbmFtZSwgdmFsdWVdIG9mIGZvcm0pIHtcblx0XHRsZW5ndGggKz0gQnVmZmVyLmJ5dGVMZW5ndGgoZ2V0SGVhZGVyKGJvdW5kYXJ5LCBuYW1lLCB2YWx1ZSkpO1xuXG5cdFx0aWYgKGlzQmxvYih2YWx1ZSkpIHtcblx0XHRcdGxlbmd0aCArPSB2YWx1ZS5zaXplO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRsZW5ndGggKz0gQnVmZmVyLmJ5dGVMZW5ndGgoU3RyaW5nKHZhbHVlKSk7XG5cdFx0fVxuXG5cdFx0bGVuZ3RoICs9IGNhcnJpYWdlTGVuZ3RoO1xuXHR9XG5cblx0bGVuZ3RoICs9IEJ1ZmZlci5ieXRlTGVuZ3RoKGdldEZvb3Rlcihib3VuZGFyeSkpO1xuXG5cdHJldHVybiBsZW5ndGg7XG59XG5cbi8qKlxuICogQHBhcmFtIHtCb2R5ICYge2hlYWRlcnM/OkhlYWRlcnN9fSBzb3VyY2VcbiAqL1xuZXhwb3J0IGNvbnN0IHRvRm9ybURhdGEgPSBhc3luYyAoc291cmNlKSA9PiB7XG4gIGxldCB7IGJvZHksIGhlYWRlcnMgfSA9IHNvdXJjZTtcbiAgY29uc3QgY29udGVudFR5cGUgPSBoZWFkZXJzPy5nZXQoJ0NvbnRlbnQtVHlwZScpIHx8ICcnXG5cbiAgaWYgKGNvbnRlbnRUeXBlLnN0YXJ0c1dpdGgoJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcpICYmIGJvZHkgIT0gbnVsbCkge1xuXHRjb25zdCBmb3JtID0gbmV3IEZvcm1EYXRhKCk7XG5cdGxldCBib2R5VGV4dCA9IGF3YWl0IHNvdXJjZS50ZXh0KCk7XG5cdG5ldyBVUkxTZWFyY2hQYXJhbXMoYm9keVRleHQpLmZvckVhY2goKHYsIGspID0+IGZvcm0uYXBwZW5kKGssIHYpKTtcblx0cmV0dXJuIGZvcm07XG4gIH1cblxuICBjb25zdCBbdHlwZSwgYm91bmRhcnldID0gY29udGVudFR5cGUuc3BsaXQoL1xccyo7XFxzKmJvdW5kYXJ5PS8pXG4gIGlmICh0eXBlID09PSAnbXVsdGlwYXJ0L2Zvcm0tZGF0YScgJiYgYm91bmRhcnkgIT0gbnVsbCAmJiBib2R5ICE9IG51bGwpIHtcbiAgICBjb25zdCBmb3JtID0gbmV3IEZvcm1EYXRhKClcbiAgICBjb25zdCBwYXJ0cyA9IGl0ZXJhdGVNdWx0aXBhcnQoYm9keSwgYm91bmRhcnkpXG4gICAgZm9yIGF3YWl0IChjb25zdCB7IG5hbWUsIGRhdGEsIGZpbGVuYW1lLCBjb250ZW50VHlwZSB9IG9mIHBhcnRzKSB7XG4gICAgICBpZiAodHlwZW9mIGZpbGVuYW1lID09PSAnc3RyaW5nJykge1xuICAgICAgICBmb3JtLmFwcGVuZChuYW1lLCBuZXcgRmlsZShbZGF0YV0sIGZpbGVuYW1lLCB7IHR5cGU6IGNvbnRlbnRUeXBlIH0pKVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZmlsZW5hbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGZvcm0uYXBwZW5kKG5hbWUsIG5ldyBGaWxlKFtdLCAnJywgeyB0eXBlOiBjb250ZW50VHlwZSB9KSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvcm0uYXBwZW5kKG5hbWUsIG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShkYXRhKSwgZmlsZW5hbWUpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmb3JtXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ291bGQgbm90IHBhcnNlIGNvbnRlbnQgYXMgRm9ybURhdGEuJylcbiAgfVxufVxuIiwgImV4cG9ydCBmdW5jdGlvbiBzdHJpbmdUb0FycmF5KHMpIHtcbiAgY29uc3QgdXRmOCA9IHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChzKSk7XG4gIHJldHVybiBVaW50OEFycmF5LmZyb20odXRmOCwgKF8sIGkpID0+IHV0ZjguY2hhckNvZGVBdChpKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gYXJyYXlUb1N0cmluZyhhKSB7XG4gIGNvbnN0IHV0ZjggPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGEpO1xuICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGVzY2FwZSh1dGY4KSk7XG59XG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VBcnJheXMoLi4uYXJyYXlzKSB7XG4gIGNvbnN0IG91dCA9IG5ldyBVaW50OEFycmF5KGFycmF5cy5yZWR1Y2UoKHRvdGFsLCBhcnIpID0+IHRvdGFsICsgYXJyLmxlbmd0aCwgMCkpO1xuICBsZXQgb2Zmc2V0ID0gMDtcbiAgZm9yIChjb25zdCBhcnIgb2YgYXJyYXlzKSB7XG4gICAgb3V0LnNldChhcnIsIG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IGFyci5sZW5ndGg7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBhcnJheXNFcXVhbChhLCBiKSB7XG4gIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59IiwgImltcG9ydCB7XG4gIHN0cmluZ1RvQXJyYXksXG4gIG1lcmdlQXJyYXlzLFxuICBhcnJheVRvU3RyaW5nXG59IGZyb20gJy4vdXRpbHMuanMnO1xuZnVuY3Rpb24gY29lcmNlKGEpIHtcbiAgaWYgKGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgcmV0dXJuIGluZGV4ID0+IGFbaW5kZXhdO1xuICB9XG4gIHJldHVybiBhO1xufVxuZnVuY3Rpb24ganNtZW1jbXAoYnVmMSwgcG9zMSwgYnVmMiwgcG9zMiwgbGVuKSB7XG4gIGNvbnN0IGZuMSA9IGNvZXJjZShidWYxKTtcbiAgY29uc3QgZm4yID0gY29lcmNlKGJ1ZjIpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGZuMShwb3MxICsgaSkgIT09IGZuMihwb3MyICsgaSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBjcmVhdGVPY2N1cmVuY2VUYWJsZShzKSB7XG4gIGNvbnN0IHRhYmxlID0gbmV3IEFycmF5KDI1NikuZmlsbChzLmxlbmd0aCk7XG4gIGlmIChzLmxlbmd0aCA+IDEpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICB0YWJsZVtzW2ldXSA9IHMubGVuZ3RoIC0gMSAtIGk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0YWJsZTtcbn1cbmNvbnN0IE1BVENIID0gU3ltYm9sKCdNYXRjaCcpO1xuY2xhc3MgU3RyZWFtU2VhcmNoIHtcbiAgY29uc3RydWN0b3IobmVlZGxlKSB7XG4gICAgdGhpcy5fbG9va2JlaGluZCA9IG5ldyBVaW50OEFycmF5KCk7XG4gICAgaWYgKHR5cGVvZiBuZWVkbGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLl9uZWVkbGUgPSBuZWVkbGUgPSBzdHJpbmdUb0FycmF5KG5lZWRsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX25lZWRsZSA9IG5lZWRsZTtcbiAgICB9XG4gICAgdGhpcy5fbGFzdENoYXIgPSBuZWVkbGVbbmVlZGxlLmxlbmd0aCAtIDFdO1xuICAgIHRoaXMuX29jYyA9IGNyZWF0ZU9jY3VyZW5jZVRhYmxlKG5lZWRsZSk7XG4gIH1cbiAgZmVlZChjaHVuaykge1xuICAgIGxldCBwb3MgPSAwO1xuICAgIGxldCB0b2tlbnM7XG4gICAgY29uc3QgYWxsVG9rZW5zID0gW107XG4gICAgd2hpbGUgKHBvcyAhPT0gY2h1bmsubGVuZ3RoKSB7XG4gICAgICA7XG4gICAgICBbcG9zLCAuLi50b2tlbnNdID0gdGhpcy5fZmVlZChjaHVuaywgcG9zKTtcbiAgICAgIGFsbFRva2Vucy5wdXNoKC4uLnRva2Vucyk7XG4gICAgfVxuICAgIHJldHVybiBhbGxUb2tlbnM7XG4gIH1cbiAgZW5kKCkge1xuICAgIGNvbnN0IHRhaWwgPSB0aGlzLl9sb29rYmVoaW5kO1xuICAgIHRoaXMuX2xvb2tiZWhpbmQgPSBuZXcgVWludDhBcnJheSgpO1xuICAgIHJldHVybiB0YWlsO1xuICB9XG4gIF9mZWVkKGRhdGEsIGJ1ZlBvcykge1xuICAgIGNvbnN0IHRva2VucyA9IFtdO1xuICAgIGxldCBwb3MgPSAtdGhpcy5fbG9va2JlaGluZC5sZW5ndGg7XG4gICAgaWYgKHBvcyA8IDApIHtcbiAgICAgIHdoaWxlIChwb3MgPCAwICYmIHBvcyA8PSBkYXRhLmxlbmd0aCAtIHRoaXMuX25lZWRsZS5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgY2ggPSB0aGlzLl9jaGFyQXQoZGF0YSwgcG9zICsgdGhpcy5fbmVlZGxlLmxlbmd0aCAtIDEpO1xuICAgICAgICBpZiAoY2ggPT09IHRoaXMuX2xhc3RDaGFyICYmIHRoaXMuX21lbWNtcChkYXRhLCBwb3MsIHRoaXMuX25lZWRsZS5sZW5ndGggLSAxKSkge1xuICAgICAgICAgIGlmIChwb3MgPiAtdGhpcy5fbG9va2JlaGluZC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHRoaXMuX2xvb2tiZWhpbmQuc2xpY2UoMCwgdGhpcy5fbG9va2JlaGluZC5sZW5ndGggKyBwb3MpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdG9rZW5zLnB1c2goTUFUQ0gpO1xuICAgICAgICAgIHRoaXMuX2xvb2tiZWhpbmQgPSBuZXcgVWludDhBcnJheSgpO1xuICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBwb3MgKyB0aGlzLl9uZWVkbGUubGVuZ3RoLFxuICAgICAgICAgICAgLi4udG9rZW5zXG4gICAgICAgICAgXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwb3MgKz0gdGhpcy5fb2NjW2NoXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHBvcyA8IDApIHtcbiAgICAgICAgd2hpbGUgKHBvcyA8IDAgJiYgIXRoaXMuX21lbWNtcChkYXRhLCBwb3MsIGRhdGEubGVuZ3RoIC0gcG9zKSkge1xuICAgICAgICAgIHBvcysrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocG9zID49IDApIHtcbiAgICAgICAgdG9rZW5zLnB1c2godGhpcy5fbG9va2JlaGluZCk7XG4gICAgICAgIHRoaXMuX2xvb2tiZWhpbmQgPSBuZXcgVWludDhBcnJheSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgYnl0ZXNUb0N1dE9mZiA9IHRoaXMuX2xvb2tiZWhpbmQubGVuZ3RoICsgcG9zO1xuICAgICAgICBpZiAoYnl0ZXNUb0N1dE9mZiA+IDApIHtcbiAgICAgICAgICB0b2tlbnMucHVzaCh0aGlzLl9sb29rYmVoaW5kLnNsaWNlKDAsIGJ5dGVzVG9DdXRPZmYpKTtcbiAgICAgICAgICB0aGlzLl9sb29rYmVoaW5kID0gdGhpcy5fbG9va2JlaGluZC5zbGljZShieXRlc1RvQ3V0T2ZmKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9sb29rYmVoaW5kID0gVWludDhBcnJheS5mcm9tKG5ldyBBcnJheSh0aGlzLl9sb29rYmVoaW5kLmxlbmd0aCArIGRhdGEubGVuZ3RoKSwgKF8sIGkpID0+IHRoaXMuX2NoYXJBdChkYXRhLCBpIC0gdGhpcy5fbG9va2JlaGluZC5sZW5ndGgpKTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICBkYXRhLmxlbmd0aCxcbiAgICAgICAgICAuLi50b2tlbnNcbiAgICAgICAgXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcG9zICs9IGJ1ZlBvcztcbiAgICB3aGlsZSAocG9zIDw9IGRhdGEubGVuZ3RoIC0gdGhpcy5fbmVlZGxlLmxlbmd0aCkge1xuICAgICAgY29uc3QgY2ggPSBkYXRhW3BvcyArIHRoaXMuX25lZWRsZS5sZW5ndGggLSAxXTtcbiAgICAgIGlmIChjaCA9PT0gdGhpcy5fbGFzdENoYXIgJiYgZGF0YVtwb3NdID09PSB0aGlzLl9uZWVkbGVbMF0gJiYganNtZW1jbXAodGhpcy5fbmVlZGxlLCAwLCBkYXRhLCBwb3MsIHRoaXMuX25lZWRsZS5sZW5ndGggLSAxKSkge1xuICAgICAgICBpZiAocG9zID4gYnVmUG9zKSB7XG4gICAgICAgICAgdG9rZW5zLnB1c2goZGF0YS5zbGljZShidWZQb3MsIHBvcykpO1xuICAgICAgICB9XG4gICAgICAgIHRva2Vucy5wdXNoKE1BVENIKTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICBwb3MgKyB0aGlzLl9uZWVkbGUubGVuZ3RoLFxuICAgICAgICAgIC4uLnRva2Vuc1xuICAgICAgICBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcG9zICs9IHRoaXMuX29jY1tjaF07XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwb3MgPCBkYXRhLmxlbmd0aCkge1xuICAgICAgd2hpbGUgKHBvcyA8IGRhdGEubGVuZ3RoICYmIChkYXRhW3Bvc10gIT09IHRoaXMuX25lZWRsZVswXSB8fCAhanNtZW1jbXAoZGF0YSwgcG9zLCB0aGlzLl9uZWVkbGUsIDAsIGRhdGEubGVuZ3RoIC0gcG9zKSkpIHtcbiAgICAgICAgKytwb3M7XG4gICAgICB9XG4gICAgICBpZiAocG9zIDwgZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5fbG9va2JlaGluZCA9IGRhdGEuc2xpY2UocG9zKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBvcyA+IDApIHtcbiAgICAgIHRva2Vucy5wdXNoKGRhdGEuc2xpY2UoYnVmUG9zLCBwb3MgPCBkYXRhLmxlbmd0aCA/IHBvcyA6IGRhdGEubGVuZ3RoKSk7XG4gICAgfVxuICAgIHJldHVybiBbXG4gICAgICBkYXRhLmxlbmd0aCxcbiAgICAgIC4uLnRva2Vuc1xuICAgIF07XG4gIH1cbiAgX2NoYXJBdChkYXRhLCBwb3MpIHtcbiAgICBpZiAocG9zIDwgMCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2xvb2tiZWhpbmRbdGhpcy5fbG9va2JlaGluZC5sZW5ndGggKyBwb3NdO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YVtwb3NdO1xuICB9XG4gIF9tZW1jbXAoZGF0YSwgcG9zLCBsZW4pIHtcbiAgICByZXR1cm4ganNtZW1jbXAodGhpcy5fY2hhckF0LmJpbmQodGhpcywgZGF0YSksIHBvcywgdGhpcy5fbmVlZGxlLCAwLCBsZW4pO1xuICB9XG59XG5jbGFzcyBSZWFkYWJsZVN0cmVhbVNlYXJjaCB7XG4gIGNvbnN0cnVjdG9yKG5lZWRsZSwgX3JlYWRhYmxlU3RyZWFtKSB7XG4gICAgdGhpcy5fcmVhZGFibGVTdHJlYW0gPSBfcmVhZGFibGVTdHJlYW07XG4gICAgdGhpcy5fc2VhcmNoID0gbmV3IFN0cmVhbVNlYXJjaChuZWVkbGUpO1xuICB9XG4gIGFzeW5jICpbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgIGNvbnN0IHJlYWRlciA9IHRoaXMuX3JlYWRhYmxlU3RyZWFtLmdldFJlYWRlcigpO1xuICAgIHRyeSB7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICBpZiAocmVzdWx0LmRvbmUpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB5aWVsZCogdGhpcy5fc2VhcmNoLmZlZWQocmVzdWx0LnZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRhaWwgPSB0aGlzLl9zZWFyY2guZW5kKCk7XG4gICAgICBpZiAodGFpbC5sZW5ndGgpIHtcbiAgICAgICAgeWllbGQgdGFpbDtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgcmVhZGVyLnJlbGVhc2VMb2NrKCk7XG4gICAgfVxuICB9XG59XG5jb25zdCBFT1EgPSBTeW1ib2woJ0VuZCBvZiBRdWV1ZScpO1xuY2xhc3MgUXVldWVhYmxlU3RyZWFtU2VhcmNoIHtcbiAgY29uc3RydWN0b3IobmVlZGxlKSB7XG4gICAgdGhpcy5fY2h1bmtzUXVldWUgPSBbXTtcbiAgICB0aGlzLl9jbG9zZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9zZWFyY2ggPSBuZXcgU3RyZWFtU2VhcmNoKG5lZWRsZSk7XG4gIH1cbiAgcHVzaCguLi5jaHVua3MpIHtcbiAgICBpZiAodGhpcy5fY2xvc2VkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBjYWxsIHB1c2ggYWZ0ZXIgY2xvc2UnKTtcbiAgICB9XG4gICAgdGhpcy5fY2h1bmtzUXVldWUucHVzaCguLi5jaHVua3MpO1xuICAgIGlmICh0aGlzLl9ub3RpZnkpIHtcbiAgICAgIHRoaXMuX25vdGlmeSgpO1xuICAgIH1cbiAgfVxuICBjbG9zZSgpIHtcbiAgICBpZiAodGhpcy5fY2xvc2VkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nsb3NlIHdhcyBhbHJlYWR5IGNhbGxlZCcpO1xuICAgIH1cbiAgICB0aGlzLl9jbG9zZWQgPSB0cnVlO1xuICAgIHRoaXMuX2NodW5rc1F1ZXVlLnB1c2goRU9RKTtcbiAgICBpZiAodGhpcy5fbm90aWZ5KSB7XG4gICAgICB0aGlzLl9ub3RpZnkoKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgKltTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGxldCBjaHVuaztcbiAgICAgIHdoaWxlICghKGNodW5rID0gdGhpcy5fY2h1bmtzUXVldWUuc2hpZnQoKSkpIHtcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiB0aGlzLl9ub3RpZnkgPSByZXNvbHZlKTtcbiAgICAgICAgdGhpcy5fbm90aWZ5ID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgaWYgKGNodW5rID09PSBFT1EpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICB5aWVsZCogdGhpcy5fc2VhcmNoLmZlZWQoY2h1bmspO1xuICAgIH1cbiAgICBjb25zdCB0YWlsID0gdGhpcy5fc2VhcmNoLmVuZCgpO1xuICAgIGlmICh0YWlsLmxlbmd0aCkge1xuICAgICAgeWllbGQgdGFpbDtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHNwbGl0Q2h1bmtzKGNodW5rcywgbmVlZGxlKSB7XG4gIGNvbnN0IHNlYXJjaCA9IG5ldyBTdHJlYW1TZWFyY2gobmVlZGxlKTtcbiAgY29uc3Qgb3V0Y2h1bmtzID0gW1tdXTtcbiAgZm9yIChjb25zdCBjaHVuayBvZiBjaHVua3MpIHtcbiAgICBmb3IgKGNvbnN0IHRva2VuIG9mIHNlYXJjaC5mZWVkKGNodW5rKSkge1xuICAgICAgaWYgKHRva2VuID09PSBNQVRDSCkge1xuICAgICAgICBvdXRjaHVua3MucHVzaChbXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXRjaHVua3Nbb3V0Y2h1bmtzLmxlbmd0aCAtIDFdLnB1c2godG9rZW4pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb25zdCBlbmQgPSBzZWFyY2guZW5kKCk7XG4gIG91dGNodW5rc1tvdXRjaHVua3MubGVuZ3RoIC0gMV0ucHVzaChlbmQpO1xuICByZXR1cm4gb3V0Y2h1bmtzLm1hcChjaHVua3MgPT4gbWVyZ2VBcnJheXMoLi4uY2h1bmtzKSk7XG59XG5mdW5jdGlvbiBzcGxpdChidWYsIG5lZWRsZSkge1xuICByZXR1cm4gc3BsaXRDaHVua3MoW2J1Zl0sIG5lZWRsZSk7XG59XG5hc3luYyBmdW5jdGlvbiogY2h1bmtzSXRlcmF0b3IoaXRlcikge1xuICBsZXQgY2h1bmtzID0gW107XG4gIGZvciBhd2FpdCAoY29uc3QgdmFsdWUgb2YgaXRlcikge1xuICAgIGlmICh2YWx1ZSA9PT0gTUFUQ0gpIHtcbiAgICAgIHlpZWxkIGNodW5rcztcbiAgICAgIGNodW5rcyA9IFtdO1xuICAgIH0gZWxzZSB7XG4gICAgICBjaHVua3MucHVzaCh2YWx1ZSk7XG4gICAgfVxuICB9XG4gIHlpZWxkIGNodW5rcztcbn1cbmFzeW5jIGZ1bmN0aW9uKiBzdHJpbmdJdGVyYXRvcihpdGVyKSB7XG4gIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgY2h1bmtzSXRlcmF0b3IoaXRlcikpIHtcbiAgICB5aWVsZCBjaHVuay5tYXAoYXJyYXlUb1N0cmluZykuam9pbignJyk7XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGFsbFN0cmluZ3MoaXRlcikge1xuICBjb25zdCBzZWdtZW50cyA9IFtdO1xuICBmb3IgYXdhaXQgKGNvbnN0IHZhbHVlIG9mIHN0cmluZ0l0ZXJhdG9yKGl0ZXIpKSB7XG4gICAgc2VnbWVudHMucHVzaCh2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHNlZ21lbnRzO1xufVxuYXN5bmMgZnVuY3Rpb24qIGFycmF5SXRlcmF0b3IoaXRlcikge1xuICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIGNodW5rc0l0ZXJhdG9yKGl0ZXIpKSB7XG4gICAgeWllbGQgbWVyZ2VBcnJheXMoLi4uY2h1bmspO1xuICB9XG59XG5leHBvcnQge1xuICBNQVRDSCxcbiAgUXVldWVhYmxlU3RyZWFtU2VhcmNoLFxuICBSZWFkYWJsZVN0cmVhbVNlYXJjaCxcbiAgU3RyZWFtU2VhcmNoLFxuICBhbGxTdHJpbmdzLFxuICBhcnJheUl0ZXJhdG9yLFxuICBjaHVua3NJdGVyYXRvcixcbiAgc3BsaXQsXG4gIHNwbGl0Q2h1bmtzLFxuICBzdHJpbmdJdGVyYXRvclxufTsiLCAiaW1wb3J0IHtcbiAgUmVhZGFibGVTdHJlYW1TZWFyY2gsXG4gIFN0cmVhbVNlYXJjaCxcbiAgTUFUQ0hcbn0gZnJvbSAnLi9zZWFyY2guanMnO1xuaW1wb3J0IHtcbiAgYXJyYXlzRXF1YWwsXG4gIHN0cmluZ1RvQXJyYXksXG4gIGFycmF5VG9TdHJpbmcsXG4gIG1lcmdlQXJyYXlzXG59IGZyb20gJy4vdXRpbHMuanMnO1xuY29uc3QgbWVyZ2VBcnJheXMyID0gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmJpbmQobWVyZ2VBcnJheXMsIHVuZGVmaW5lZCk7XG5jb25zdCBkYXNoID0gc3RyaW5nVG9BcnJheSgnLS0nKTtcbmNvbnN0IENSTEYgPSBzdHJpbmdUb0FycmF5KCdcXHJcXG4nKTtcbmZ1bmN0aW9uIHBhcnNlQ29udGVudERpc3Bvc2l0aW9uKGhlYWRlcikge1xuICBjb25zdCBwYXJ0cyA9IGhlYWRlci5zcGxpdCgnOycpLm1hcChwYXJ0ID0+IHBhcnQudHJpbSgpKTtcbiAgaWYgKHBhcnRzLnNoaWZ0KCkgIT09ICdmb3JtLWRhdGEnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdtYWxmb3JtZWQgY29udGVudC1kaXNwb3NpdGlvbiBoZWFkZXI6IG1pc3NpbmcgXCJmb3JtLWRhdGFcIiBpbiBgJyArIEpTT04uc3RyaW5naWZ5KHBhcnRzKSArICdgJyk7XG4gIH1cbiAgY29uc3Qgb3V0ID0ge307XG4gIGZvciAoY29uc3QgcGFydCBvZiBwYXJ0cykge1xuICAgIGNvbnN0IGt2ID0gcGFydC5zcGxpdCgnPScsIDIpO1xuICAgIGlmIChrdi5sZW5ndGggIT09IDIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWFsZm9ybWVkIGNvbnRlbnQtZGlzcG9zaXRpb24gaGVhZGVyOiBrZXktdmFsdWUgcGFpciBub3QgZm91bmQgLSAnICsgcGFydCArICcgaW4gYCcgKyBoZWFkZXIgKyAnYCcpO1xuICAgIH1cbiAgICBjb25zdCBbbmFtZSwgdmFsdWVdID0ga3Y7XG4gICAgaWYgKHZhbHVlWzBdID09PSAnXCInICYmIHZhbHVlW3ZhbHVlLmxlbmd0aCAtIDFdID09PSAnXCInKSB7XG4gICAgICBvdXRbbmFtZV0gPSB2YWx1ZS5zbGljZSgxLCAtMSkucmVwbGFjZSgvXFxcXFwiL2csICdcIicpO1xuICAgIH0gZWxzZSBpZiAodmFsdWVbMF0gIT09ICdcIicgJiYgdmFsdWVbdmFsdWUubGVuZ3RoIC0gMV0gIT09ICdcIicpIHtcbiAgICAgIG91dFtuYW1lXSA9IHZhbHVlO1xuICAgIH0gZWxzZSBpZiAodmFsdWVbMF0gPT09ICdcIicgJiYgdmFsdWVbdmFsdWUubGVuZ3RoIC0gMV0gIT09ICdcIicgfHwgdmFsdWVbMF0gIT09ICdcIicgJiYgdmFsdWVbdmFsdWUubGVuZ3RoIC0gMV0gPT09ICdcIicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWFsZm9ybWVkIGNvbnRlbnQtZGlzcG9zaXRpb24gaGVhZGVyOiBtaXNtYXRjaGVkIHF1b3RhdGlvbnMgaW4gYCcgKyBoZWFkZXIgKyAnYCcpO1xuICAgIH1cbiAgfVxuICBpZiAoIW91dC5uYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdtYWxmb3JtZWQgY29udGVudC1kaXNwb3NpdGlvbiBoZWFkZXI6IG1pc3NpbmcgZmllbGQgbmFtZSBpbiBgJyArIGhlYWRlciArICdgJyk7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cbmZ1bmN0aW9uIHBhcnNlUGFydEhlYWRlcnMobGluZXMpIHtcbiAgY29uc3QgZW50cmllcyA9IFtdO1xuICBsZXQgZGlzcG9zaXRpb24gPSBmYWxzZTtcbiAgbGV0IGxpbmU7XG4gIHdoaWxlICh0eXBlb2YgKGxpbmUgPSBsaW5lcy5zaGlmdCgpKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBjb25zdCBjb2xvbiA9IGxpbmUuaW5kZXhPZignOicpO1xuICAgIGlmIChjb2xvbiA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWFsZm9ybWVkIG11bHRpcGFydC1mb3JtIGhlYWRlcjogbWlzc2luZyBjb2xvbicpO1xuICAgIH1cbiAgICBjb25zdCBoZWFkZXIgPSBsaW5lLnNsaWNlKDAsIGNvbG9uKS50cmltKCkudG9Mb3dlckNhc2UoKTtcbiAgICBjb25zdCB2YWx1ZSA9IGxpbmUuc2xpY2UoY29sb24gKyAxKS50cmltKCk7XG4gICAgc3dpdGNoIChoZWFkZXIpIHtcbiAgICBjYXNlICdjb250ZW50LWRpc3Bvc2l0aW9uJzpcbiAgICAgIGRpc3Bvc2l0aW9uID0gdHJ1ZTtcbiAgICAgIGVudHJpZXMucHVzaCguLi5PYmplY3QuZW50cmllcyhwYXJzZUNvbnRlbnREaXNwb3NpdGlvbih2YWx1ZSkpKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2NvbnRlbnQtdHlwZSc6XG4gICAgICBlbnRyaWVzLnB1c2goW1xuICAgICAgICAnY29udGVudFR5cGUnLFxuICAgICAgICB2YWx1ZVxuICAgICAgXSk7XG4gICAgfVxuICB9XG4gIGlmICghZGlzcG9zaXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ21hbGZvcm1lZCBtdWx0aXBhcnQtZm9ybSBoZWFkZXI6IG1pc3NpbmcgY29udGVudC1kaXNwb3NpdGlvbicpO1xuICB9XG4gIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoZW50cmllcyk7XG59XG5hc3luYyBmdW5jdGlvbiByZWFkSGVhZGVyTGluZXMoaXQsIG5lZWRsZSkge1xuICBsZXQgZmlyc3RDaHVuayA9IHRydWU7XG4gIGxldCBsYXN0VG9rZW5XYXNNYXRjaCA9IGZhbHNlO1xuICBjb25zdCBoZWFkZXJMaW5lcyA9IFtbXV07XG4gIGNvbnN0IGNybGZTZWFyY2ggPSBuZXcgU3RyZWFtU2VhcmNoKENSTEYpO1xuICBmb3IgKDs7KSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgaXQubmV4dCgpO1xuICAgIGlmIChyZXN1bHQuZG9uZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYWxmb3JtZWQgbXVsdGlwYXJ0LWZvcm0gZGF0YTogdW5leHBlY3RlZCBlbmQgb2Ygc3RyZWFtJyk7XG4gICAgfVxuICAgIGlmIChmaXJzdENodW5rICYmIHJlc3VsdC52YWx1ZSAhPT0gTUFUQ0ggJiYgYXJyYXlzRXF1YWwocmVzdWx0LnZhbHVlLnNsaWNlKDAsIDIpLCBkYXNoKSkge1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICBuZXcgVWludDhBcnJheSgpXG4gICAgICBdO1xuICAgIH1cbiAgICBsZXQgY2h1bms7XG4gICAgaWYgKHJlc3VsdC52YWx1ZSAhPT0gTUFUQ0gpIHtcbiAgICAgIGNodW5rID0gcmVzdWx0LnZhbHVlO1xuICAgIH0gZWxzZSBpZiAoIWxhc3RUb2tlbldhc01hdGNoKSB7XG4gICAgICBjaHVuayA9IG5lZWRsZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYWxmb3JtZWQgbXVsdGlwYXJ0LWZvcm0gZGF0YTogdW5leHBlY3RlZCBib3VuZGFyeScpO1xuICAgIH1cbiAgICBpZiAoIWNodW5rLmxlbmd0aCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChmaXJzdENodW5rKSB7XG4gICAgICBmaXJzdENodW5rID0gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHRva2VucyA9IGNybGZTZWFyY2guZmVlZChjaHVuayk7XG4gICAgZm9yIChjb25zdCBbaSwgdG9rZW5dIG9mIHRva2Vucy5lbnRyaWVzKCkpIHtcbiAgICAgIGNvbnN0IGlzTWF0Y2ggPSB0b2tlbiA9PT0gTUFUQ0g7XG4gICAgICBpZiAoIWlzTWF0Y2ggJiYgIXRva2VuLmxlbmd0aCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChsYXN0VG9rZW5XYXNNYXRjaCAmJiBpc01hdGNoKSB7XG4gICAgICAgIHRva2Vucy5wdXNoKGNybGZTZWFyY2guZW5kKCkpO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIGhlYWRlckxpbmVzLmZpbHRlcihjaHVua3MgPT4gY2h1bmtzLmxlbmd0aCkubWFwKG1lcmdlQXJyYXlzMikubWFwKGFycmF5VG9TdHJpbmcpLFxuICAgICAgICAgIG1lcmdlQXJyYXlzKC4uLnRva2Vucy5zbGljZShpICsgMSkubWFwKHRva2VuID0+IHRva2VuID09PSBNQVRDSCA/IENSTEYgOiB0b2tlbikpXG4gICAgICAgIF07XG4gICAgICB9XG4gICAgICBpZiAobGFzdFRva2VuV2FzTWF0Y2ggPSBpc01hdGNoKSB7XG4gICAgICAgIGhlYWRlckxpbmVzLnB1c2goW10pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGVhZGVyTGluZXNbaGVhZGVyTGluZXMubGVuZ3RoIC0gMV0ucHVzaCh0b2tlbik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24qIHN0cmVhbU11bHRpcGFydChib2R5LCBib3VuZGFyeSkge1xuICBjb25zdCBuZWVkbGUgPSBtZXJnZUFycmF5cyhkYXNoLCBzdHJpbmdUb0FycmF5KGJvdW5kYXJ5KSk7XG4gIGNvbnN0IGl0ID0gbmV3IFJlYWRhYmxlU3RyZWFtU2VhcmNoKG5lZWRsZSwgYm9keSlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCk7XG4gIGZvciAoOzspIHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBpdC5uZXh0KCk7XG4gICAgaWYgKHJlc3VsdC5kb25lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChyZXN1bHQudmFsdWUgPT09IE1BVENIKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgY29uc3QgY3JsZlNlYXJjaCA9IG5ldyBTdHJlYW1TZWFyY2goQ1JMRik7XG4gIGZvciAoOzspIHtcbiAgICBjb25zdCBbaGVhZGVyTGluZXMsIHRhaWxdID0gYXdhaXQgcmVhZEhlYWRlckxpbmVzKGl0LCBuZWVkbGUpO1xuICAgIGlmICghaGVhZGVyTGluZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYXN5bmMgZnVuY3Rpb24gbmV4dFRva2VuKCkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgaXQubmV4dCgpO1xuICAgICAgaWYgKHJlc3VsdC5kb25lKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWFsZm9ybWVkIG11bHRpcGFydC1mb3JtIGRhdGE6IHVuZXhwZWN0ZWQgZW5kIG9mIHN0cmVhbScpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgbGV0IHRyYWlsaW5nQ1JMRiA9IGZhbHNlO1xuICAgIGZ1bmN0aW9uIGZlZWRDaHVuayhjaHVuaykge1xuICAgICAgY29uc3QgY2h1bmtzID0gW107XG4gICAgICBmb3IgKGNvbnN0IHRva2VuIG9mIGNybGZTZWFyY2guZmVlZChjaHVuaykpIHtcbiAgICAgICAgaWYgKHRyYWlsaW5nQ1JMRikge1xuICAgICAgICAgIGNodW5rcy5wdXNoKENSTEYpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKHRyYWlsaW5nQ1JMRiA9IHRva2VuID09PSBNQVRDSCkpIHtcbiAgICAgICAgICBjaHVua3MucHVzaCh0b2tlbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBtZXJnZUFycmF5cyguLi5jaHVua3MpO1xuICAgIH1cbiAgICBsZXQgZG9uZSA9IGZhbHNlO1xuICAgIGFzeW5jIGZ1bmN0aW9uIG5leHRDaHVuaygpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IG5leHRUb2tlbigpO1xuICAgICAgbGV0IGNodW5rO1xuICAgICAgaWYgKHJlc3VsdC52YWx1ZSAhPT0gTUFUQ0gpIHtcbiAgICAgICAgY2h1bmsgPSByZXN1bHQudmFsdWU7XG4gICAgICB9IGVsc2UgaWYgKCF0cmFpbGluZ0NSTEYpIHtcbiAgICAgICAgY2h1bmsgPSBDUkxGO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgIHJldHVybiB7IHZhbHVlOiBjcmxmU2VhcmNoLmVuZCgpIH07XG4gICAgICB9XG4gICAgICByZXR1cm4geyB2YWx1ZTogZmVlZENodW5rKGNodW5rKSB9O1xuICAgIH1cbiAgICBjb25zdCBidWZmZXJlZENodW5rcyA9IFt7IHZhbHVlOiBmZWVkQ2h1bmsodGFpbCkgfV07XG4gICAgeWllbGQge1xuICAgICAgLi4ucGFyc2VQYXJ0SGVhZGVycyhoZWFkZXJMaW5lcyksXG4gICAgICBkYXRhOiB7XG4gICAgICAgIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIGFzeW5jIG5leHQoKSB7XG4gICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYnVmZmVyZWRDaHVua3Muc2hpZnQoKTtcbiAgICAgICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdC52YWx1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZG9uZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdW5kZWZpbmVkXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBuZXh0Q2h1bmsoKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQudmFsdWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgd2hpbGUgKCFkb25lKSB7XG4gICAgICBidWZmZXJlZENodW5rcy5wdXNoKGF3YWl0IG5leHRDaHVuaygpKTtcbiAgICB9XG4gIH1cbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiogaXRlcmF0ZU11bHRpcGFydChib2R5LCBib3VuZGFyeSkge1xuICBmb3IgYXdhaXQgKGNvbnN0IHBhcnQgb2Ygc3RyZWFtTXVsdGlwYXJ0KGJvZHksIGJvdW5kYXJ5KSkge1xuICAgIGNvbnN0IGNodW5rcyA9IFtdO1xuICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgcGFydC5kYXRhKSB7XG4gICAgICBjaHVua3MucHVzaChjaHVuayk7XG4gICAgfVxuICAgIHlpZWxkIHtcbiAgICAgIC4uLnBhcnQsXG4gICAgICBkYXRhOiBtZXJnZUFycmF5cyguLi5jaHVua3MpXG4gICAgfTtcbiAgfVxufSIsICJpbXBvcnQgU3RyZWFtIGZyb20gXCJzdHJlYW1cIjtcblxuLyoqXG4gKiBJcy5qc1xuICpcbiAqIE9iamVjdCB0eXBlIGNoZWNrcy5cbiAqL1xuXG5jb25zdCBOQU1FID0gU3ltYm9sLnRvU3RyaW5nVGFnO1xuXG4vKipcbiAqIENoZWNrIGlmIGBvYmpgIGlzIGEgVVJMU2VhcmNoUGFyYW1zIG9iamVjdFxuICogcmVmOiBodHRwczovL2dpdGh1Yi5jb20vbm9kZS1mZXRjaC9ub2RlLWZldGNoL2lzc3Vlcy8yOTYjaXNzdWVjb21tZW50LTMwNzU5ODE0M1xuICpcbiAqIEBwYXJhbSAge2FueX0gb2JqZWN0XG4gKiBAcmV0dXJuIHtvYmogaXMgVVJMU2VhcmNoUGFyYW1zfVxuICovXG5leHBvcnQgY29uc3QgaXNVUkxTZWFyY2hQYXJhbWV0ZXJzID0gKG9iamVjdCkgPT4ge1xuXHRyZXR1cm4gKFxuXHRcdHR5cGVvZiBvYmplY3QgPT09IFwib2JqZWN0XCIgJiZcblx0XHR0eXBlb2Ygb2JqZWN0LmFwcGVuZCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIG9iamVjdC5kZWxldGUgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBvYmplY3QuZ2V0ID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2Ygb2JqZWN0LmdldEFsbCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIG9iamVjdC5oYXMgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBvYmplY3Quc2V0ID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2Ygb2JqZWN0LnNvcnQgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdG9iamVjdFtOQU1FXSA9PT0gXCJVUkxTZWFyY2hQYXJhbXNcIlxuXHQpO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiBgb2JqZWN0YCBpcyBhIFczQyBgQmxvYmAgb2JqZWN0ICh3aGljaCBgRmlsZWAgaW5oZXJpdHMgZnJvbSlcbiAqXG4gKiBAcGFyYW0gIHsqfSBvYmplY3RcbiAqIEByZXR1cm4ge29iamVjdCBpcyBCbG9ifVxuICovXG5leHBvcnQgY29uc3QgaXNCbG9iID0gKG9iamVjdCkgPT4ge1xuXHRyZXR1cm4gKFxuXHRcdHR5cGVvZiBvYmplY3QgPT09IFwib2JqZWN0XCIgJiZcblx0XHR0eXBlb2Ygb2JqZWN0LmFycmF5QnVmZmVyID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2Ygb2JqZWN0LnR5cGUgPT09IFwic3RyaW5nXCIgJiZcblx0XHR0eXBlb2Ygb2JqZWN0LnN0cmVhbSA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIG9iamVjdC5jb25zdHJ1Y3RvciA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0L14oQmxvYnxGaWxlKSQvLnRlc3Qob2JqZWN0W05BTUVdKVxuXHQpO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiBgb2JqYCBpcyBhIHNwZWMtY29tcGxpYW50IGBGb3JtRGF0YWAgb2JqZWN0XG4gKlxuICogQHBhcmFtIHsqfSBvYmplY3RcbiAqIEByZXR1cm4ge29iamVjdCBpcyBGb3JtRGF0YX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRm9ybURhdGEob2JqZWN0KSB7XG5cdHJldHVybiAoXG5cdFx0dHlwZW9mIG9iamVjdCA9PT0gXCJvYmplY3RcIiAmJlxuXHRcdHR5cGVvZiBvYmplY3QuYXBwZW5kID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2Ygb2JqZWN0LnNldCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIG9iamVjdC5nZXQgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBvYmplY3QuZ2V0QWxsID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2Ygb2JqZWN0LmRlbGV0ZSA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIG9iamVjdC5rZXlzID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2Ygb2JqZWN0LnZhbHVlcyA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIG9iamVjdC5lbnRyaWVzID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2Ygb2JqZWN0LmNvbnN0cnVjdG9yID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHRvYmplY3RbTkFNRV0gPT09IFwiRm9ybURhdGFcIlxuXHQpO1xufVxuXG4vKipcbiAqIERldGVjdCBmb3JtIGRhdGEgaW5wdXQgZnJvbSBmb3JtLWRhdGEgbW9kdWxlXG4gKlxuICogQHBhcmFtIHthbnl9IHZhbHVlXG4gKiBAcmV0dXJucyB7dmFsdWUgaXMgU3RyZWFtICYge2dldEJvdW5kYXJ5KCk6c3RyaW5nLCBoYXNLbm93bkxlbmd0aCgpOmJvb2xlYW4sIGdldExlbmd0aFN5bmMoKTpudW1iZXJ8bnVsbH19XG4gKi9cbmV4cG9ydCBjb25zdCBpc011bHRpcGFydEZvcm1EYXRhU3RyZWFtID0gKHZhbHVlKSA9PiB7XG5cdHJldHVybiAoXG5cdFx0dmFsdWUgaW5zdGFuY2VvZiBTdHJlYW0gPT09IHRydWUgJiZcblx0XHR0eXBlb2YgdmFsdWUuZ2V0Qm91bmRhcnkgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiB2YWx1ZS5oYXNLbm93bkxlbmd0aCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIHZhbHVlLmdldExlbmd0aFN5bmMgPT09IFwiZnVuY3Rpb25cIlxuXHQpO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiBgb2JqYCBpcyBhbiBpbnN0YW5jZSBvZiBBYm9ydFNpZ25hbC5cbiAqXG4gKiBAcGFyYW0gIHthbnl9IG9iamVjdFxuICogQHJldHVybiB7b2JqIGlzIEFib3J0U2lnbmFsfVxuICovXG5leHBvcnQgY29uc3QgaXNBYm9ydFNpZ25hbCA9IChvYmplY3QpID0+IHtcblx0cmV0dXJuIChcblx0XHR0eXBlb2Ygb2JqZWN0ID09PSBcIm9iamVjdFwiICYmXG5cdFx0KG9iamVjdFtOQU1FXSA9PT0gXCJBYm9ydFNpZ25hbFwiIHx8IG9iamVjdFtOQU1FXSA9PT0gXCJFdmVudFRhcmdldFwiKVxuXHQpO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiBgdmFsdWVgIGlzIGEgUmVhZGFibGVTdHJlYW0uXG4gKlxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHJldHVybnMge3ZhbHVlIGlzIFJlYWRhYmxlU3RyZWFtfVxuICovXG5leHBvcnQgY29uc3QgaXNSZWFkYWJsZVN0cmVhbSA9ICh2YWx1ZSkgPT4ge1xuXHRyZXR1cm4gKFxuXHRcdHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJlxuXHRcdHR5cGVvZiB2YWx1ZS5nZXRSZWFkZXIgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiB2YWx1ZS5jYW5jZWwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiB2YWx1ZS50ZWUgPT09IFwiZnVuY3Rpb25cIlxuXHQpO1xufTtcblxuLyoqXG4gKlxuICogQHBhcmFtIHthbnl9IHZhbHVlXG4gKiBAcmV0dXJucyB7dmFsdWUgaXMgSXRlcmFibGU8dW5rbm93bj59XG4gKi9cbmV4cG9ydCBjb25zdCBpc0l0ZXJhYmxlID0gKHZhbHVlKSA9PiB2YWx1ZSAmJiBTeW1ib2wuaXRlcmF0b3IgaW4gdmFsdWU7XG4iLCAiaW1wb3J0IHtUZXh0RW5jb2RlciwgVGV4dERlY29kZXJ9IGZyb20gJ3V0aWwnO1xuXG5jb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG5jb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAqL1xuZXhwb3J0IGNvbnN0IGVuY29kZSA9IHRleHQgPT4gZW5jb2Rlci5lbmNvZGUodGV4dCk7XG5cbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBieXRlc1xuICovXG5leHBvcnQgY29uc3QgZGVjb2RlID0gYnl0ZXMgPT4gZGVjb2Rlci5kZWNvZGUoYnl0ZXMpO1xuIiwgIi8qKlxuICogSGVhZGVycy5qc1xuICpcbiAqIEhlYWRlcnMgY2xhc3Mgb2ZmZXJzIGNvbnZlbmllbnQgaGVscGVyc1xuICovXG5cbmltcG9ydCB7dHlwZXN9IGZyb20gJ3V0aWwnO1xuaW1wb3J0IGh0dHAgZnJvbSAnaHR0cCc7XG5pbXBvcnQgeyBpc0l0ZXJhYmxlIH0gZnJvbSAnLi91dGlscy9pcy5qcydcblxuY29uc3QgdmFsaWRhdG9ycyA9IC8qKiBAdHlwZSB7e3ZhbGlkYXRlSGVhZGVyTmFtZT86KG5hbWU6c3RyaW5nKSA9PiBhbnksIHZhbGlkYXRlSGVhZGVyVmFsdWU/OihuYW1lOnN0cmluZywgdmFsdWU6c3RyaW5nKSA9PiBhbnl9fSAqL1xuKGh0dHApXG5cbmNvbnN0IHZhbGlkYXRlSGVhZGVyTmFtZSA9IHR5cGVvZiB2YWxpZGF0b3JzLnZhbGlkYXRlSGVhZGVyTmFtZSA9PT0gJ2Z1bmN0aW9uJyA/XG5cdHZhbGlkYXRvcnMudmFsaWRhdGVIZWFkZXJOYW1lIDpcblx0LyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFxuXHQgKi9cblx0bmFtZSA9PiB7XG5cdFx0aWYgKCEvXltcXF5gXFwtXFx3ISMkJSYnKisufH5dKyQvLnRlc3QobmFtZSkpIHtcblx0XHRcdGNvbnN0IGVyciA9IG5ldyBUeXBlRXJyb3IoYEhlYWRlciBuYW1lIG11c3QgYmUgYSB2YWxpZCBIVFRQIHRva2VuIFske25hbWV9XWApO1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGVyciwgJ2NvZGUnLCB7dmFsdWU6ICdFUlJfSU5WQUxJRF9IVFRQX1RPS0VOJ30pO1xuXHRcdFx0dGhyb3cgZXJyO1xuXHRcdH1cblx0fTtcblxuY29uc3QgdmFsaWRhdGVIZWFkZXJWYWx1ZSA9IHR5cGVvZiB2YWxpZGF0b3JzLnZhbGlkYXRlSGVhZGVyVmFsdWUgPT09ICdmdW5jdGlvbicgP1xuXHR2YWxpZGF0b3JzLnZhbGlkYXRlSGVhZGVyVmFsdWUgOlxuXHQvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBcblx0ICovXG5cdChuYW1lLCB2YWx1ZSkgPT4ge1xuXHRcdGlmICgvW15cXHRcXHUwMDIwLVxcdTAwN0VcXHUwMDgwLVxcdTAwRkZdLy50ZXN0KHZhbHVlKSkge1xuXHRcdFx0Y29uc3QgZXJyID0gbmV3IFR5cGVFcnJvcihgSW52YWxpZCBjaGFyYWN0ZXIgaW4gaGVhZGVyIGNvbnRlbnQgW1wiJHtuYW1lfVwiXWApO1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGVyciwgJ2NvZGUnLCB7dmFsdWU6ICdFUlJfSU5WQUxJRF9DSEFSJ30pO1xuXHRcdFx0dGhyb3cgZXJyO1xuXHRcdH1cblx0fTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7SGVhZGVycyB8IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gfCBJdGVyYWJsZTxyZWFkb25seSBbc3RyaW5nLCBzdHJpbmddPiB8IEl0ZXJhYmxlPEl0ZXJhYmxlPHN0cmluZz4+fSBIZWFkZXJzSW5pdFxuICovXG5cbi8qKlxuICogVGhpcyBGZXRjaCBBUEkgaW50ZXJmYWNlIGFsbG93cyB5b3UgdG8gcGVyZm9ybSB2YXJpb3VzIGFjdGlvbnMgb24gSFRUUCByZXF1ZXN0IGFuZCByZXNwb25zZSBoZWFkZXJzLlxuICogVGhlc2UgYWN0aW9ucyBpbmNsdWRlIHJldHJpZXZpbmcsIHNldHRpbmcsIGFkZGluZyB0bywgYW5kIHJlbW92aW5nLlxuICogQSBIZWFkZXJzIG9iamVjdCBoYXMgYW4gYXNzb2NpYXRlZCBoZWFkZXIgbGlzdCwgd2hpY2ggaXMgaW5pdGlhbGx5IGVtcHR5IGFuZCBjb25zaXN0cyBvZiB6ZXJvIG9yIG1vcmUgbmFtZSBhbmQgdmFsdWUgcGFpcnMuXG4gKiBZb3UgY2FuIGFkZCB0byB0aGlzIHVzaW5nIG1ldGhvZHMgbGlrZSBhcHBlbmQoKSAoc2VlIEV4YW1wbGVzLilcbiAqIEluIGFsbCBtZXRob2RzIG9mIHRoaXMgaW50ZXJmYWNlLCBoZWFkZXIgbmFtZXMgYXJlIG1hdGNoZWQgYnkgY2FzZS1pbnNlbnNpdGl2ZSBieXRlIHNlcXVlbmNlLlxuICpcbiAqIEBpbXBsZW1lbnRzIHtnbG9iYWxUaGlzLkhlYWRlcnN9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEhlYWRlcnMgZXh0ZW5kcyBVUkxTZWFyY2hQYXJhbXMge1xuXHQvKipcblx0ICogSGVhZGVycyBjbGFzc1xuXHQgKlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtIZWFkZXJzSW5pdH0gW2luaXRdIC0gUmVzcG9uc2UgaGVhZGVyc1xuXHQgKi9cblx0Y29uc3RydWN0b3IoaW5pdCkge1xuXHRcdC8vIFZhbGlkYXRlIGFuZCBub3JtYWxpemUgaW5pdCBvYmplY3QgaW4gW25hbWUsIHZhbHVlKHMpXVtdXG5cdFx0LyoqIEB0eXBlIHtzdHJpbmdbXVtdfSAqL1xuXHRcdGxldCByZXN1bHQgPSBbXTtcblx0XHRpZiAoaW5pdCBpbnN0YW5jZW9mIEhlYWRlcnMpIHtcblx0XHRcdGNvbnN0IHJhdyA9IGluaXQucmF3KCk7XG5cdFx0XHRmb3IgKGNvbnN0IFtuYW1lLCB2YWx1ZXNdIG9mIE9iamVjdC5lbnRyaWVzKHJhdykpIHtcblx0XHRcdFx0cmVzdWx0LnB1c2goLi4udmFsdWVzLm1hcCh2YWx1ZSA9PiBbbmFtZSwgdmFsdWVdKSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChpbml0ID09IG51bGwpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1lcS1udWxsLCBlcWVxZXFcblx0XHRcdC8vIE5vIG9wXG5cdFx0fSBlbHNlIGlmIChpc0l0ZXJhYmxlKGluaXQpKSB7XG5cdFx0XHQvLyBTZXF1ZW5jZTxzZXF1ZW5jZTxCeXRlU3RyaW5nPj5cblx0XHRcdC8vIE5vdGU6IHBlciBzcGVjIHdlIGhhdmUgdG8gZmlyc3QgZXhoYXVzdCB0aGUgbGlzdHMgdGhlbiBwcm9jZXNzIHRoZW1cblx0XHRcdHJlc3VsdCA9IFsuLi5pbml0XVxuXHRcdFx0XHQubWFwKHBhaXIgPT4ge1xuXHRcdFx0XHRcdGlmIChcblx0XHRcdFx0XHRcdHR5cGVvZiBwYWlyICE9PSAnb2JqZWN0JyB8fCB0eXBlcy5pc0JveGVkUHJpbWl0aXZlKHBhaXIpXG5cdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdFYWNoIGhlYWRlciBwYWlyIG11c3QgYmUgYW4gaXRlcmFibGUgb2JqZWN0Jyk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIFsuLi5wYWlyXTtcblx0XHRcdFx0fSkubWFwKHBhaXIgPT4ge1xuXHRcdFx0XHRcdGlmIChwYWlyLmxlbmd0aCAhPT0gMikge1xuXHRcdFx0XHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignRWFjaCBoZWFkZXIgcGFpciBtdXN0IGJlIGEgbmFtZS92YWx1ZSB0dXBsZScpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiBbLi4ucGFpcl07XG5cdFx0XHRcdH0pO1xuXHRcdH0gZWxzZSBpZiAodHlwZW9mIGluaXQgPT09IFwib2JqZWN0XCIgJiYgaW5pdCAhPT0gbnVsbCkge1xuXHRcdFx0Ly8gUmVjb3JkPEJ5dGVTdHJpbmcsIEJ5dGVTdHJpbmc+XG5cdFx0XHRyZXN1bHQucHVzaCguLi5PYmplY3QuZW50cmllcyhpbml0KSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZhaWxlZCB0byBjb25zdHJ1Y3QgXFwnSGVhZGVyc1xcJzogVGhlIHByb3ZpZGVkIHZhbHVlIGlzIG5vdCBvZiB0eXBlIFxcJyhzZXF1ZW5jZTxzZXF1ZW5jZTxCeXRlU3RyaW5nPj4gb3IgcmVjb3JkPEJ5dGVTdHJpbmcsIEJ5dGVTdHJpbmc+KScpO1xuXHRcdH1cblxuXHRcdC8vIFZhbGlkYXRlIGFuZCBsb3dlcmNhc2Vcblx0XHRyZXN1bHQgPVxuXHRcdFx0cmVzdWx0Lmxlbmd0aCA+IDAgP1xuXHRcdFx0XHRyZXN1bHQubWFwKChbbmFtZSwgdmFsdWVdKSA9PiB7XG5cdFx0XHRcdFx0dmFsaWRhdGVIZWFkZXJOYW1lKG5hbWUpO1xuXHRcdFx0XHRcdHZhbGlkYXRlSGVhZGVyVmFsdWUobmFtZSwgU3RyaW5nKHZhbHVlKSk7XG5cdFx0XHRcdFx0cmV0dXJuIFtTdHJpbmcobmFtZSkudG9Mb3dlckNhc2UoKSwgU3RyaW5nKHZhbHVlKV07XG5cdFx0XHRcdH0pIDpcblx0XHRcdFx0W107XG5cblx0XHRzdXBlcihyZXN1bHQpO1xuXG5cdFx0Ly8gUmV0dXJuaW5nIGEgUHJveHkgdGhhdCB3aWxsIGxvd2VyY2FzZSBrZXkgbmFtZXMsIHZhbGlkYXRlIHBhcmFtZXRlcnMgYW5kIHNvcnQga2V5c1xuXHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zdHJ1Y3Rvci1yZXR1cm5cblx0XHRyZXR1cm4gbmV3IFByb3h5KHRoaXMsIHtcblx0XHRcdGdldCh0YXJnZXQsIHAsIHJlY2VpdmVyKSB7XG5cdFx0XHRcdHN3aXRjaCAocCkge1xuXHRcdFx0XHRcdGNhc2UgJ2FwcGVuZCc6XG5cdFx0XHRcdFx0Y2FzZSAnc2V0Jzpcblx0XHRcdFx0XHRcdC8qKlxuXHRcdFx0XHRcdFx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcblx0XHRcdFx0XHRcdCAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuXHRcdFx0XHRcdFx0ICovXG5cdFx0XHRcdFx0XHRyZXR1cm4gKG5hbWUsIHZhbHVlKSA9PiB7XG5cdFx0XHRcdFx0XHRcdHZhbGlkYXRlSGVhZGVyTmFtZShuYW1lKTtcblx0XHRcdFx0XHRcdFx0dmFsaWRhdGVIZWFkZXJWYWx1ZShuYW1lLCBTdHJpbmcodmFsdWUpKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGVbcF0uY2FsbChcblx0XHRcdFx0XHRcdFx0XHRyZWNlaXZlcixcblx0XHRcdFx0XHRcdFx0XHRTdHJpbmcobmFtZSkudG9Mb3dlckNhc2UoKSxcblx0XHRcdFx0XHRcdFx0XHRTdHJpbmcodmFsdWUpXG5cdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0Y2FzZSAnZGVsZXRlJzpcblx0XHRcdFx0XHRjYXNlICdoYXMnOlxuXHRcdFx0XHRcdGNhc2UgJ2dldEFsbCc6XG5cdFx0XHRcdFx0XHQvKipcblx0XHRcdFx0XHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG5cdFx0XHRcdFx0XHQgKi9cblx0XHRcdFx0XHRcdHJldHVybiBuYW1lID0+IHtcblx0XHRcdFx0XHRcdFx0dmFsaWRhdGVIZWFkZXJOYW1lKG5hbWUpO1xuXHRcdFx0XHRcdFx0XHQvLyBAdHMtaWdub3JlXG5cdFx0XHRcdFx0XHRcdHJldHVybiBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlW3BdLmNhbGwoXG5cdFx0XHRcdFx0XHRcdFx0cmVjZWl2ZXIsXG5cdFx0XHRcdFx0XHRcdFx0U3RyaW5nKG5hbWUpLnRvTG93ZXJDYXNlKClcblx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRjYXNlICdrZXlzJzpcblx0XHRcdFx0XHRcdHJldHVybiAoKSA9PiB7XG5cdFx0XHRcdFx0XHRcdHRhcmdldC5zb3J0KCk7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBuZXcgU2V0KFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUua2V5cy5jYWxsKHRhcmdldCkpLmtleXMoKTtcblx0XHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0cmV0dXJuIFJlZmxlY3QuZ2V0KHRhcmdldCwgcCwgcmVjZWl2ZXIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvKiBjOCBpZ25vcmUgbmV4dCAqL1xuXHRcdH0pO1xuXHR9XG5cblx0Z2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCkge1xuXHRcdHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG5cdH1cblxuXHR0b1N0cmluZygpIHtcblx0XHRyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHRoaXMpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBcblx0ICovXG5cdGdldChuYW1lKSB7XG5cdFx0Y29uc3QgdmFsdWVzID0gdGhpcy5nZXRBbGwobmFtZSk7XG5cdFx0aWYgKHZhbHVlcy5sZW5ndGggPT09IDApIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdGxldCB2YWx1ZSA9IHZhbHVlcy5qb2luKCcsICcpO1xuXHRcdGlmICgvXmNvbnRlbnQtZW5jb2RpbmckL2kudGVzdChuYW1lKSkge1xuXHRcdFx0dmFsdWUgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuXHRcdH1cblxuXHRcdHJldHVybiB2YWx1ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0geyh2YWx1ZTogc3RyaW5nLCBrZXk6IHN0cmluZywgcGFyZW50OiB0aGlzKSA9PiB2b2lkfSBjYWxsYmFjayBcblx0ICogQHBhcmFtIHthbnl9IHRoaXNBcmcgXG5cdCAqIEByZXR1cm5zIHt2b2lkfVxuXHQgKi9cblx0Zm9yRWFjaChjYWxsYmFjaywgdGhpc0FyZyA9IHVuZGVmaW5lZCkge1xuXHRcdGZvciAoY29uc3QgbmFtZSBvZiB0aGlzLmtleXMoKSkge1xuXHRcdFx0aWYgKG5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3NldC1jb29raWUnKSB7XG5cdFx0XHRcdGxldCBjb29raWVzID0gdGhpcy5nZXRBbGwobmFtZSk7XG5cdFx0XHRcdHdoaWxlIChjb29raWVzLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0XHRSZWZsZWN0LmFwcGx5KGNhbGxiYWNrLCB0aGlzQXJnLCBbY29va2llcy5zaGlmdCgpLCBuYW1lLCB0aGlzXSlcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0UmVmbGVjdC5hcHBseShjYWxsYmFjaywgdGhpc0FyZywgW3RoaXMuZ2V0KG5hbWUpLCBuYW1lLCB0aGlzXSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm5zIHtJdGVyYWJsZUl0ZXJhdG9yPHN0cmluZz59XG5cdCAqL1xuXHQqIHZhbHVlcygpIHtcblx0XHRmb3IgKGNvbnN0IG5hbWUgb2YgdGhpcy5rZXlzKCkpIHtcblx0XHRcdGlmIChuYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdzZXQtY29va2llJykge1xuXHRcdFx0XHRsZXQgY29va2llcyA9IHRoaXMuZ2V0QWxsKG5hbWUpO1xuXHRcdFx0XHR3aGlsZSAoY29va2llcy5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdFx0eWllbGQgLyoqIEB0eXBlIHtzdHJpbmd9ICovKGNvb2tpZXMuc2hpZnQoKSk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHlpZWxkIC8qKiBAdHlwZSB7c3RyaW5nfSAqLyh0aGlzLmdldChuYW1lKSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm5zIHtJdGVyYWJsZUl0ZXJhdG9yPFtzdHJpbmcsIHN0cmluZ10+fVxuXHQgKi9cblx0KiBlbnRyaWVzKCkge1xuXHRcdGZvciAoY29uc3QgbmFtZSBvZiB0aGlzLmtleXMoKSkge1xuXHRcdFx0aWYgKG5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3NldC1jb29raWUnKSB7XG5cdFx0XHRcdGxldCBjb29raWVzID0gdGhpcy5nZXRBbGwobmFtZSk7XG5cdFx0XHRcdHdoaWxlIChjb29raWVzLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0XHR5aWVsZCBbbmFtZSwgLyoqIEB0eXBlIHtzdHJpbmd9ICovKGNvb2tpZXMuc2hpZnQoKSldO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR5aWVsZCBbbmFtZSwgLyoqIEB0eXBlIHtzdHJpbmd9ICovKHRoaXMuZ2V0KG5hbWUpKV07XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0W1N5bWJvbC5pdGVyYXRvcl0oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZW50cmllcygpO1xuXHR9XG5cblx0LyoqXG5cdCAqIE5vZGUtZmV0Y2ggbm9uLXNwZWMgbWV0aG9kXG5cdCAqIHJldHVybmluZyBhbGwgaGVhZGVycyBhbmQgdGhlaXIgdmFsdWVzIGFzIGFycmF5XG5cdCAqIEByZXR1cm5zIHtSZWNvcmQ8c3RyaW5nLCBzdHJpbmdbXT59XG5cdCAqL1xuXHRyYXcoKSB7XG5cdFx0cmV0dXJuIFsuLi50aGlzLmtleXMoKV0ucmVkdWNlKChyZXN1bHQsIGtleSkgPT4ge1xuXHRcdFx0cmVzdWx0W2tleV0gPSB0aGlzLmdldEFsbChrZXkpO1xuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9LCAvKiogQHR5cGUge1JlY29yZDxzdHJpbmcsIHN0cmluZ1tdPn0gKi8oe30pKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBGb3IgYmV0dGVyIGNvbnNvbGUubG9nKGhlYWRlcnMpIGFuZCBhbHNvIHRvIGNvbnZlcnQgSGVhZGVycyBpbnRvIE5vZGUuanMgUmVxdWVzdCBjb21wYXRpYmxlIGZvcm1hdFxuXHQgKi9cblx0W1N5bWJvbC5mb3IoJ25vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tJyldKCkge1xuXHRcdHJldHVybiBbLi4udGhpcy5rZXlzKCldLnJlZHVjZSgocmVzdWx0LCBrZXkpID0+IHtcblx0XHRcdGNvbnN0IHZhbHVlcyA9IHRoaXMuZ2V0QWxsKGtleSk7XG5cdFx0XHQvLyBIdHRwLnJlcXVlc3QoKSBvbmx5IHN1cHBvcnRzIHN0cmluZyBhcyBIb3N0IGhlYWRlci5cblx0XHRcdC8vIFRoaXMgaGFjayBtYWtlcyBzcGVjaWZ5aW5nIGN1c3RvbSBIb3N0IGhlYWRlciBwb3NzaWJsZS5cblx0XHRcdGlmIChrZXkgPT09ICdob3N0Jykge1xuXHRcdFx0XHRyZXN1bHRba2V5XSA9IHZhbHVlc1swXTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJlc3VsdFtrZXldID0gdmFsdWVzLmxlbmd0aCA+IDEgPyB2YWx1ZXMgOiB2YWx1ZXNbMF07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fSwgLyoqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLCBzdHJpbmd8c3RyaW5nW10+fSAqLyh7fSkpO1xuXHR9XG59XG5cbi8qKlxuICogUmUtc2hhcGluZyBvYmplY3QgZm9yIFdlYiBJREwgdGVzdHNcbiAqIE9ubHkgbmVlZCB0byBkbyBpdCBmb3Igb3ZlcnJpZGRlbiBtZXRob2RzXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFxuXHRIZWFkZXJzLnByb3RvdHlwZSxcblx0WydnZXQnLCAnZW50cmllcycsICdmb3JFYWNoJywgJ3ZhbHVlcyddLnJlZHVjZSgocmVzdWx0LCBwcm9wZXJ0eSkgPT4ge1xuXHRcdHJlc3VsdFtwcm9wZXJ0eV0gPSB7ZW51bWVyYWJsZTogdHJ1ZX07XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fSwgLyoqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLCB7ZW51bWVyYWJsZTp0cnVlfT59ICovICh7fSkpXG4pO1xuXG4vKipcbiAqIENyZWF0ZSBhIEhlYWRlcnMgb2JqZWN0IGZyb20gYW4gaHR0cC5JbmNvbWluZ01lc3NhZ2UucmF3SGVhZGVycywgaWdub3JpbmcgdGhvc2UgdGhhdCBkb1xuICogbm90IGNvbmZvcm0gdG8gSFRUUCBncmFtbWFyIHByb2R1Y3Rpb25zLlxuICogQHBhcmFtIHtpbXBvcnQoJ2h0dHAnKS5JbmNvbWluZ01lc3NhZ2VbJ3Jhd0hlYWRlcnMnXX0gaGVhZGVyc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVJhd0hlYWRlcnMoaGVhZGVycyA9IFtdKSB7XG5cdHJldHVybiBuZXcgSGVhZGVycyhcblx0XHRoZWFkZXJzXG5cdFx0XHQvLyBTcGxpdCBpbnRvIHBhaXJzXG5cdFx0XHQucmVkdWNlKChyZXN1bHQsIHZhbHVlLCBpbmRleCwgYXJyYXkpID0+IHtcblx0XHRcdFx0aWYgKGluZGV4ICUgMiA9PT0gMCkge1xuXHRcdFx0XHRcdHJlc3VsdC5wdXNoKGFycmF5LnNsaWNlKGluZGV4LCBpbmRleCArIDIpKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0XHR9LCAvKiogQHR5cGUge3N0cmluZ1tdW119ICovKFtdKSlcblx0XHRcdC5maWx0ZXIoKFtuYW1lLCB2YWx1ZV0pID0+IHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHR2YWxpZGF0ZUhlYWRlck5hbWUobmFtZSk7XG5cdFx0XHRcdFx0dmFsaWRhdGVIZWFkZXJWYWx1ZShuYW1lLCBTdHJpbmcodmFsdWUpKTtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fSBjYXRjaCB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9KVxuXG5cdCk7XG59XG4iLCAiY29uc3QgcmVkaXJlY3RTdGF0dXMgPSBuZXcgU2V0KFszMDEsIDMwMiwgMzAzLCAzMDcsIDMwOF0pO1xuXG4vKipcbiAqIFJlZGlyZWN0IGNvZGUgbWF0Y2hpbmdcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gY29kZSAtIFN0YXR1cyBjb2RlXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgY29uc3QgaXNSZWRpcmVjdCA9IGNvZGUgPT4ge1xuXHRyZXR1cm4gcmVkaXJlY3RTdGF0dXMuaGFzKGNvZGUpO1xufTtcbiIsICIvKipcbiAqIFJlc3BvbnNlLmpzXG4gKlxuICogUmVzcG9uc2UgY2xhc3MgcHJvdmlkZXMgY29udGVudCBkZWNvZGluZ1xuICovXG5cbmltcG9ydCBIZWFkZXJzIGZyb20gJy4vaGVhZGVycy5qcyc7XG5pbXBvcnQgQm9keSwge2Nsb25lLCBleHRyYWN0Q29udGVudFR5cGV9IGZyb20gJy4vYm9keS5qcyc7XG5pbXBvcnQge2lzUmVkaXJlY3R9IGZyb20gJy4vdXRpbHMvaXMtcmVkaXJlY3QuanMnO1xuXG5jb25zdCBJTlRFUk5BTFMgPSBTeW1ib2woJ1Jlc3BvbnNlIGludGVybmFscycpO1xuXG4vKipcbiAqIFJlc3BvbnNlIGNsYXNzXG4gKiBcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEV4dFxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtzaXplXVxuICogQHByb3BlcnR5IHtzdHJpbmd9IFt1cmxdXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2NvdW50ZXJdXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2hpZ2hXYXRlck1hcmtdXG4gKiBcbiAqIEBpbXBsZW1lbnRzIHtnbG9iYWxUaGlzLlJlc3BvbnNlfVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZXNwb25zZSBleHRlbmRzIEJvZHkge1xuXHQvKipcblx0ICogQHBhcmFtIHtCb2R5SW5pdHxpbXBvcnQoJ3N0cmVhbScpLlN0cmVhbXxudWxsfSBbYm9keV0gLSBSZWFkYWJsZSBzdHJlYW1cblx0ICogQHBhcmFtIHtSZXNwb25zZUluaXQgJiBFeHR9IFtvcHRpb25zXSAtIFJlc3BvbnNlIG9wdGlvbnNcblx0ICovXG5cdGNvbnN0cnVjdG9yKGJvZHkgPSBudWxsLCBvcHRpb25zID0ge30pIHtcblx0XHRzdXBlcihib2R5LCBvcHRpb25zKTtcblxuXHRcdGNvbnN0IHN0YXR1cyA9IG9wdGlvbnMuc3RhdHVzIHx8IDIwMDtcblx0XHRjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnMob3B0aW9ucy5oZWFkZXJzKTtcblxuXHRcdGlmIChib2R5ICE9PSBudWxsICYmICFoZWFkZXJzLmhhcygnQ29udGVudC1UeXBlJykpIHtcblx0XHRcdGNvbnN0IGNvbnRlbnRUeXBlID0gZXh0cmFjdENvbnRlbnRUeXBlKHRoaXMpO1xuXHRcdFx0aWYgKGNvbnRlbnRUeXBlKSB7XG5cdFx0XHRcdGhlYWRlcnMuYXBwZW5kKCdDb250ZW50LVR5cGUnLCBjb250ZW50VHlwZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogQHByaXZhdGVcblx0XHQqL1xuXHRcdHRoaXNbSU5URVJOQUxTXSA9IHtcblx0XHRcdHVybDogb3B0aW9ucy51cmwsXG5cdFx0XHRzdGF0dXMsXG5cdFx0XHRzdGF0dXNUZXh0OiBvcHRpb25zLnN0YXR1c1RleHQgfHwgJycsXG5cdFx0XHRoZWFkZXJzLFxuXHRcdFx0Y291bnRlcjogb3B0aW9ucy5jb3VudGVyIHx8IDAsXG5cdFx0XHRoaWdoV2F0ZXJNYXJrOiBvcHRpb25zLmhpZ2hXYXRlck1hcmtcblx0XHR9O1xuXHR9XG5cblx0LyoqXG5cdCAqIEB0eXBlIHtSZXNwb25zZVR5cGV9XG5cdCAqL1xuXHRnZXQgdHlwZSgpIHtcblx0XHRyZXR1cm4gXCJkZWZhdWx0XCJcblx0fVxuXG5cdGdldCB1cmwoKSB7XG5cdFx0cmV0dXJuIHRoaXNbSU5URVJOQUxTXS51cmwgfHwgJyc7XG5cdH1cblxuXHRnZXQgc3RhdHVzKCkge1xuXHRcdHJldHVybiB0aGlzW0lOVEVSTkFMU10uc3RhdHVzO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlbmllbmNlIHByb3BlcnR5IHJlcHJlc2VudGluZyBpZiB0aGUgcmVxdWVzdCBlbmRlZCBub3JtYWxseVxuXHQgKi9cblx0Z2V0IG9rKCkge1xuXHRcdHJldHVybiB0aGlzW0lOVEVSTkFMU10uc3RhdHVzID49IDIwMCAmJiB0aGlzW0lOVEVSTkFMU10uc3RhdHVzIDwgMzAwO1xuXHR9XG5cblx0Z2V0IHJlZGlyZWN0ZWQoKSB7XG5cdFx0cmV0dXJuIHRoaXNbSU5URVJOQUxTXS5jb3VudGVyID4gMDtcblx0fVxuXG5cdGdldCBzdGF0dXNUZXh0KCkge1xuXHRcdHJldHVybiB0aGlzW0lOVEVSTkFMU10uc3RhdHVzVGV4dDtcblx0fVxuXG5cdC8qKlxuXHQgKiBAdHlwZSB7SGVhZGVyc31cblx0ICovXG5cdGdldCBoZWFkZXJzKCkge1xuXHRcdHJldHVybiB0aGlzW0lOVEVSTkFMU10uaGVhZGVycztcblx0fVxuXG5cdGdldCBoaWdoV2F0ZXJNYXJrKCkge1xuXHRcdHJldHVybiB0aGlzW0lOVEVSTkFMU10uaGlnaFdhdGVyTWFyaztcblx0fVxuXG5cdC8qKlxuXHQgKiBDbG9uZSB0aGlzIHJlc3BvbnNlXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtSZXNwb25zZX1cblx0ICovXG5cdGNsb25lKCkge1xuXHRcdHJldHVybiBuZXcgUmVzcG9uc2UoY2xvbmUodGhpcyksIHtcblx0XHRcdHVybDogdGhpcy51cmwsXG5cdFx0XHRzdGF0dXM6IHRoaXMuc3RhdHVzLFxuXHRcdFx0c3RhdHVzVGV4dDogdGhpcy5zdGF0dXNUZXh0LFxuXHRcdFx0aGVhZGVyczogdGhpcy5oZWFkZXJzLFxuXHRcdFx0c2l6ZTogdGhpcy5zaXplXG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IHVybCAgICBUaGUgVVJMIHRoYXQgdGhlIG5ldyByZXNwb25zZSBpcyB0byBvcmlnaW5hdGUgZnJvbS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHN0YXR1cyBBbiBvcHRpb25hbCBzdGF0dXMgY29kZSBmb3IgdGhlIHJlc3BvbnNlIChlLmcuLCAzMDIuKVxuXHQgKiBAcmV0dXJucyB7UmVzcG9uc2V9ICAgIEEgUmVzcG9uc2Ugb2JqZWN0LlxuXHQgKi9cblx0c3RhdGljIHJlZGlyZWN0KHVybCwgc3RhdHVzID0gMzAyKSB7XG5cdFx0aWYgKCFpc1JlZGlyZWN0KHN0YXR1cykpIHtcblx0XHRcdHRocm93IG5ldyBSYW5nZUVycm9yKCdGYWlsZWQgdG8gZXhlY3V0ZSBcInJlZGlyZWN0XCIgb24gXCJyZXNwb25zZVwiOiBJbnZhbGlkIHN0YXR1cyBjb2RlJyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG5ldyBSZXNwb25zZShudWxsLCB7XG5cdFx0XHRoZWFkZXJzOiB7XG5cdFx0XHRcdGxvY2F0aW9uOiBuZXcgVVJMKHVybCkudG9TdHJpbmcoKVxuXHRcdFx0fSxcblx0XHRcdHN0YXR1c1xuXHRcdH0pO1xuXHR9XG5cblx0Z2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCkge1xuXHRcdHJldHVybiAnUmVzcG9uc2UnO1xuXHR9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFJlc3BvbnNlLnByb3RvdHlwZSwge1xuXHR1cmw6IHtlbnVtZXJhYmxlOiB0cnVlfSxcblx0c3RhdHVzOiB7ZW51bWVyYWJsZTogdHJ1ZX0sXG5cdG9rOiB7ZW51bWVyYWJsZTogdHJ1ZX0sXG5cdHJlZGlyZWN0ZWQ6IHtlbnVtZXJhYmxlOiB0cnVlfSxcblx0c3RhdHVzVGV4dDoge2VudW1lcmFibGU6IHRydWV9LFxuXHRoZWFkZXJzOiB7ZW51bWVyYWJsZTogdHJ1ZX0sXG5cdGNsb25lOiB7ZW51bWVyYWJsZTogdHJ1ZX1cbn0pO1xuXG4iLCAiXG4vKipcbiAqIFJlcXVlc3QuanNcbiAqXG4gKiBSZXF1ZXN0IGNsYXNzIGNvbnRhaW5zIHNlcnZlciBvbmx5IG9wdGlvbnNcbiAqXG4gKiBBbGwgc3BlYyBhbGdvcml0aG0gc3RlcCBudW1iZXJzIGFyZSBiYXNlZCBvbiBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy9jb21taXQtc25hcHNob3RzL2FlNzE2ODIyY2IzYTYxODQzMjI2Y2QwOTBlZWZjNjU4OTQ0NmMxZDIvLlxuICovXG5cbmltcG9ydCB7Zm9ybWF0IGFzIGZvcm1hdFVybH0gZnJvbSAndXJsJztcbmltcG9ydCB7QWJvcnRDb250cm9sbGVyIGFzIEFib3J0Q29udHJvbGxlclBvbHlmaWxsfSBmcm9tICdhYm9ydC1jb250cm9sbGVyJztcbmltcG9ydCBIZWFkZXJzIGZyb20gJy4vaGVhZGVycy5qcyc7XG5pbXBvcnQgQm9keSwge2Nsb25lLCBleHRyYWN0Q29udGVudFR5cGUsIGdldFRvdGFsQnl0ZXN9IGZyb20gJy4vYm9keS5qcyc7XG5pbXBvcnQge2lzQWJvcnRTaWduYWx9IGZyb20gJy4vdXRpbHMvaXMuanMnO1xuaW1wb3J0IHtnZXRTZWFyY2h9IGZyb20gJy4vdXRpbHMvZ2V0LXNlYXJjaC5qcyc7XG5cbmNvbnN0IElOVEVSTkFMUyA9IFN5bWJvbCgnUmVxdWVzdCBpbnRlcm5hbHMnKTtcblxuY29uc3QgZm9yYmlkZGVuTWV0aG9kcyA9IG5ldyBTZXQoW1wiQ09OTkVDVFwiLCBcIlRSQUNFXCIsIFwiVFJBQ0tcIl0pO1xuY29uc3Qgbm9ybWFsaXplZE1ldGhvZHMgPSBuZXcgU2V0KFtcIkRFTEVURVwiLCBcIkdFVFwiLCBcIkhFQURcIiwgXCJPUFRJT05TXCIsIFwiUE9TVFwiLCBcIlBVVFwiXSk7XG5cbi8qKlxuICogQ2hlY2sgaWYgYG9iamAgaXMgYW4gaW5zdGFuY2Ugb2YgUmVxdWVzdC5cbiAqXG4gKiBAcGFyYW0gIHthbnl9IG9iamVjdFxuICogQHJldHVybiB7b2JqZWN0IGlzIFJlcXVlc3R9XG4gKi9cbmNvbnN0IGlzUmVxdWVzdCA9IG9iamVjdCA9PiB7XG5cdHJldHVybiAoXG5cdFx0dHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiZcblx0XHR0eXBlb2Ygb2JqZWN0W0lOVEVSTkFMU10gPT09ICdvYmplY3QnXG5cdCk7XG59O1xuXG5cbi8qKlxuICogUmVxdWVzdCBjbGFzc1xuICogQGltcGxlbWVudHMge2dsb2JhbFRoaXMuUmVxdWVzdH1cbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBSZXF1ZXN0U3RhdGVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBtZXRob2RcbiAqIEBwcm9wZXJ0eSB7UmVxdWVzdFJlZGlyZWN0fSByZWRpcmVjdFxuICogQHByb3BlcnR5IHtnbG9iYWxUaGlzLkhlYWRlcnN9IGhlYWRlcnNcbiAqIEBwcm9wZXJ0eSB7UmVxdWVzdENyZWRlbnRpYWxzfSBjcmVkZW50aWFsc1xuICogQHByb3BlcnR5IHtVUkx9IHBhcnNlZFVSTFxuICogQHByb3BlcnR5IHtBYm9ydFNpZ25hbHxudWxsfSBzaWduYWxcbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBSZXF1ZXN0RXh0cmFPcHRpb25zXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2ZvbGxvd11cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2NvbXByZXNzXVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtzaXplXVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtjb3VudGVyXVxuICogQHByb3BlcnR5IHtBZ2VudH0gW2FnZW50XVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtoaWdoV2F0ZXJNYXJrXVxuICogQHByb3BlcnR5IHtib29sZWFufSBbaW5zZWN1cmVIVFRQUGFyc2VyXVxuICpcbiAqIEB0eXBlZGVmIHsoKHVybDpVUkwpID0+IGltcG9ydCgnaHR0cCcpLkFnZW50IHwgaW1wb3J0KCdodHRwcycpLkFnZW50KSB8IGltcG9ydCgnaHR0cCcpLkFnZW50IHwgaW1wb3J0KCdodHRwcycpLkFnZW50fSBBZ2VudFxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFJlcXVlc3RPcHRpb25zXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW21ldGhvZF1cbiAqIEBwcm9wZXJ0eSB7UmVhZGFibGVTdHJlYW08VWludDhBcnJheT58bnVsbH0gW2JvZHldXG4gKiBAcHJvcGVydHkge2dsb2JhbFRoaXMuSGVhZGVyc30gW2hlYWRlcnNdXG4gKiBAcHJvcGVydHkge1JlcXVlc3RSZWRpcmVjdH0gW3JlZGlyZWN0XVxuICpcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVxdWVzdCBleHRlbmRzIEJvZHkge1xuXHQvKipcblx0ICogQHBhcmFtIHtzdHJpbmd8UmVxdWVzdHxVUkx9IGluZm8gIFVybCBvciBSZXF1ZXN0IGluc3RhbmNlXG5cdCAqIEBwYXJhbSB7UmVxdWVzdEluaXQgJiBSZXF1ZXN0RXh0cmFPcHRpb25zfSBpbml0ICAgQ3VzdG9tIG9wdGlvbnNcblx0ICovXG5cdGNvbnN0cnVjdG9yKGluZm8sIGluaXQgPSB7fSkge1xuXHRcdGxldCBwYXJzZWRVUkw7XG5cdFx0LyoqIEB0eXBlIHtSZXF1ZXN0T3B0aW9ucyAmIFJlcXVlc3RFeHRyYU9wdGlvbnN9ICovXG5cdFx0bGV0IHNldHRpbmdzXG5cblx0XHQvLyBOb3JtYWxpemUgaW5wdXQgYW5kIGZvcmNlIFVSTCB0byBiZSBlbmNvZGVkIGFzIFVURi04IChodHRwczovL2dpdGh1Yi5jb20vbm9kZS1mZXRjaC9ub2RlLWZldGNoL2lzc3Vlcy8yNDUpXG5cdFx0aWYgKGlzUmVxdWVzdChpbmZvKSkge1xuXHRcdFx0cGFyc2VkVVJMID0gbmV3IFVSTChpbmZvLnVybCk7XG5cdFx0XHRzZXR0aW5ncyA9IChpbmZvKVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRwYXJzZWRVUkwgPSBuZXcgVVJMKGluZm8pO1xuXHRcdFx0c2V0dGluZ3MgPSB7fTtcblx0XHR9XG5cblxuXG5cdFx0Ly8gTm9ybWFsaXplIG1ldGhvZDogaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI21ldGhvZHNcblx0XHRsZXQgbWV0aG9kID0gaW5pdC5tZXRob2QgfHwgc2V0dGluZ3MubWV0aG9kIHx8ICdHRVQnO1xuXHRcdGlmIChmb3JiaWRkZW5NZXRob2RzLmhhcyhtZXRob2QudG9VcHBlckNhc2UoKSkpIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoYEZhaWxlZCB0byBjb25zdHJ1Y3QgJ1JlcXVlc3QnOiAnJHttZXRob2R9JyBIVFRQIG1ldGhvZCBpcyB1bnN1cHBvcnRlZC5gKVxuXHRcdH0gZWxzZSBpZiAobm9ybWFsaXplZE1ldGhvZHMuaGFzKG1ldGhvZC50b1VwcGVyQ2FzZSgpKSkge1xuXHRcdFx0bWV0aG9kID0gbWV0aG9kLnRvVXBwZXJDYXNlKCk7XG5cdFx0fVxuXG5cdFx0Y29uc3QgaW5wdXRCb2R5ID0gaW5pdC5ib2R5ICE9IG51bGxcblx0XHRcdD8gaW5pdC5ib2R5XG5cdFx0XHQ6IChpc1JlcXVlc3QoaW5mbykgJiYgaW5mby5ib2R5ICE9PSBudWxsKVxuXHRcdFx0PyBjbG9uZShpbmZvKVxuXHRcdFx0OiBudWxsO1xuXG5cdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVxLW51bGwsIGVxZXFlcVxuXHRcdGlmIChpbnB1dEJvZHkgIT0gbnVsbCAmJiAobWV0aG9kID09PSAnR0VUJyB8fCBtZXRob2QgPT09ICdIRUFEJykpIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ1JlcXVlc3Qgd2l0aCBHRVQvSEVBRCBtZXRob2QgY2Fubm90IGhhdmUgYm9keScpO1xuXHRcdH1cblxuXHRcdHN1cGVyKGlucHV0Qm9keSwge1xuXHRcdFx0c2l6ZTogaW5pdC5zaXplIHx8IHNldHRpbmdzLnNpemUgfHwgMFxuXHRcdH0pO1xuXHRcdGNvbnN0IGlucHV0ID0gc2V0dGluZ3NcblxuXG5cdFx0Y29uc3QgaGVhZGVycyA9IC8qKiBAdHlwZSB7Z2xvYmFsVGhpcy5IZWFkZXJzfSAqL1xuXHRcdFx0KG5ldyBIZWFkZXJzKGluaXQuaGVhZGVycyB8fCBpbnB1dC5oZWFkZXJzIHx8IHt9KSk7XG5cblx0XHRpZiAoaW5wdXRCb2R5ICE9PSBudWxsICYmICFoZWFkZXJzLmhhcygnQ29udGVudC1UeXBlJykpIHtcblx0XHRcdGNvbnN0IGNvbnRlbnRUeXBlID0gZXh0cmFjdENvbnRlbnRUeXBlKHRoaXMpO1xuXHRcdFx0aWYgKGNvbnRlbnRUeXBlKSB7XG5cdFx0XHRcdGhlYWRlcnMuYXBwZW5kKCdDb250ZW50LVR5cGUnLCBjb250ZW50VHlwZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0bGV0IHNpZ25hbCA9ICdzaWduYWwnIGluIGluaXRcblx0XHRcdD8gaW5pdC5zaWduYWxcblx0XHRcdDogaXNSZXF1ZXN0KGlucHV0KVxuXHRcdFx0PyBpbnB1dC5zaWduYWxcblx0XHRcdDogbnVsbDtcblxuXHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lcS1udWxsLCBlcWVxZXFcblx0XHRpZiAoc2lnbmFsICE9IG51bGwgJiYgIWlzQWJvcnRTaWduYWwoc2lnbmFsKSkge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgc2lnbmFsIHRvIGJlIGFuIGluc3RhbmNlb2YgQWJvcnRTaWduYWwgb3IgRXZlbnRUYXJnZXQnKTtcblx0XHR9XG5cdFx0XG5cdFx0aWYgKCFzaWduYWwpIHtcblx0XHRcdGxldCBBYm9ydENvbnRyb2xsZXJDb25zdHJ1Y3RvciA9IHR5cGVvZiBBYm9ydENvbnRyb2xsZXIgIT0gXCJ1bmRlZmluZWRcIlxuXHRcdFx0PyBBYm9ydENvbnRyb2xsZXJcblx0XHRcdDogQWJvcnRDb250cm9sbGVyUG9seWZpbGw7XG5cdFx0XHQvKiogQHR5cGUge2FueX0gKi9cblx0XHRcdGxldCBuZXdTaWduYWwgPSBuZXcgQWJvcnRDb250cm9sbGVyQ29uc3RydWN0b3IoKS5zaWduYWw7XG5cdFx0XHRzaWduYWwgPSBuZXdTaWduYWw7XG5cdFx0fVxuXG5cdFx0LyoqIEB0eXBlIHtSZXF1ZXN0U3RhdGV9ICovXG5cdFx0dGhpc1tJTlRFUk5BTFNdID0ge1xuXHRcdFx0bWV0aG9kLFxuXHRcdFx0cmVkaXJlY3Q6IGluaXQucmVkaXJlY3QgfHwgaW5wdXQucmVkaXJlY3QgfHwgJ2ZvbGxvdycsXG5cdFx0XHRoZWFkZXJzLFxuXHRcdFx0Y3JlZGVudGlhbHM6IGluaXQuY3JlZGVudGlhbHMgfHwgJ3NhbWUtb3JpZ2luJyxcblx0XHRcdHBhcnNlZFVSTCxcblx0XHRcdHNpZ25hbDogc2lnbmFsIHx8IG51bGxcblx0XHR9O1xuXG5cdFx0LyoqIEB0eXBlIHtib29sZWFufSAqL1xuXHRcdHRoaXMua2VlcGFsaXZlXG5cblx0XHQvLyBOb2RlLWZldGNoLW9ubHkgb3B0aW9uc1xuXHRcdC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuXHRcdHRoaXMuZm9sbG93ID0gaW5pdC5mb2xsb3cgPT09IHVuZGVmaW5lZCA/IChpbnB1dC5mb2xsb3cgPT09IHVuZGVmaW5lZCA/IDIwIDogaW5wdXQuZm9sbG93KSA6IGluaXQuZm9sbG93O1xuXHRcdC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cblx0XHR0aGlzLmNvbXByZXNzID0gaW5pdC5jb21wcmVzcyA9PT0gdW5kZWZpbmVkID8gKGlucHV0LmNvbXByZXNzID09PSB1bmRlZmluZWQgPyB0cnVlIDogaW5wdXQuY29tcHJlc3MpIDogaW5pdC5jb21wcmVzcztcblx0XHQvKiogQHR5cGUge251bWJlcn0gKi9cblx0XHR0aGlzLmNvdW50ZXIgPSBpbml0LmNvdW50ZXIgfHwgaW5wdXQuY291bnRlciB8fCAwO1xuXHRcdC8qKiBAdHlwZSB7QWdlbnR8dW5kZWZpbmVkfSAqL1xuXHRcdHRoaXMuYWdlbnQgPSBpbml0LmFnZW50IHx8IGlucHV0LmFnZW50O1xuXHRcdC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuXHRcdHRoaXMuaGlnaFdhdGVyTWFyayA9IGluaXQuaGlnaFdhdGVyTWFyayB8fCBpbnB1dC5oaWdoV2F0ZXJNYXJrIHx8IDE2Mzg0O1xuXHRcdC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cblx0XHR0aGlzLmluc2VjdXJlSFRUUFBhcnNlciA9IGluaXQuaW5zZWN1cmVIVFRQUGFyc2VyIHx8IGlucHV0Lmluc2VjdXJlSFRUUFBhcnNlciB8fCBmYWxzZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAdHlwZSB7UmVxdWVzdENhY2hlfVxuXHQgKi9cblx0Z2V0IGNhY2hlKCkge1xuXHRcdHJldHVybiBcImRlZmF1bHRcIlxuXHR9XG5cblx0LyoqXG5cdCAqIEB0eXBlIHtSZXF1ZXN0Q3JlZGVudGlhbHN9XG5cdCAqL1xuXG5cdGdldCBjcmVkZW50aWFscygpIHtcblx0XHRyZXR1cm4gdGhpc1tJTlRFUk5BTFNdLmNyZWRlbnRpYWxzXG5cdH1cblxuXHQvKipcblx0ICogQHR5cGUge1JlcXVlc3REZXN0aW5hdGlvbn1cblx0ICovXG5cdGdldCBkZXN0aW5hdGlvbigpIHtcblx0XHRyZXR1cm4gXCJcIlxuXHR9XG5cblx0Z2V0IGludGVncml0eSgpIHtcblx0XHRyZXR1cm4gXCJcIlxuXHR9XG5cblx0LyoqIEB0eXBlIHtSZXF1ZXN0TW9kZX0gKi9cblx0Z2V0IG1vZGUoKSB7XG5cdFx0cmV0dXJuIFwiY29yc1wiXG5cdH1cblxuXHQvKiogQHR5cGUge3N0cmluZ30gKi9cblx0Z2V0IHJlZmVycmVyKCkge1xuXHRcdHJldHVybiAgXCJcIlxuXHR9XG5cblx0LyoqIEB0eXBlIHtSZWZlcnJlclBvbGljeX0gKi9cblx0Z2V0IHJlZmVycmVyUG9saWN5KCkge1xuXHRcdHJldHVybiBcIlwiXG5cdH1cblx0Z2V0IG1ldGhvZCgpIHtcblx0XHRyZXR1cm4gdGhpc1tJTlRFUk5BTFNdLm1ldGhvZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBAdHlwZSB7c3RyaW5nfVxuXHQgKi9cblx0Z2V0IHVybCgpIHtcblx0XHRyZXR1cm4gZm9ybWF0VXJsKHRoaXNbSU5URVJOQUxTXS5wYXJzZWRVUkwpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEB0eXBlIHtnbG9iYWxUaGlzLkhlYWRlcnN9XG5cdCAqL1xuXHRnZXQgaGVhZGVycygpIHtcblx0XHRyZXR1cm4gdGhpc1tJTlRFUk5BTFNdLmhlYWRlcnM7XG5cdH1cblxuXHRnZXQgcmVkaXJlY3QoKSB7XG5cdFx0cmV0dXJuIHRoaXNbSU5URVJOQUxTXS5yZWRpcmVjdDtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7QWJvcnRTaWduYWx9XG5cdCAqL1xuXHRnZXQgc2lnbmFsKCkge1xuXHRcdC8vIEB0cy1pZ25vcmVcblx0XHRyZXR1cm4gdGhpc1tJTlRFUk5BTFNdLnNpZ25hbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDbG9uZSB0aGlzIHJlcXVlc3Rcblx0ICpcblx0ICogQHJldHVybiAge2dsb2JhbFRoaXMuUmVxdWVzdH1cblx0ICovXG5cdGNsb25lKCkge1xuXHRcdHJldHVybiBuZXcgUmVxdWVzdCh0aGlzKTtcblx0fVxuXG5cdGdldCBbU3ltYm9sLnRvU3RyaW5nVGFnXSgpIHtcblx0XHRyZXR1cm4gJ1JlcXVlc3QnO1xuXHR9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFJlcXVlc3QucHJvdG90eXBlLCB7XG5cdG1ldGhvZDoge2VudW1lcmFibGU6IHRydWV9LFxuXHR1cmw6IHtlbnVtZXJhYmxlOiB0cnVlfSxcblx0aGVhZGVyczoge2VudW1lcmFibGU6IHRydWV9LFxuXHRyZWRpcmVjdDoge2VudW1lcmFibGU6IHRydWV9LFxuXHRjbG9uZToge2VudW1lcmFibGU6IHRydWV9LFxuXHRzaWduYWw6IHtlbnVtZXJhYmxlOiB0cnVlfVxufSk7XG5cbi8qKlxuICogQ29udmVydCBhIFJlcXVlc3QgdG8gTm9kZS5qcyBodHRwIHJlcXVlc3Qgb3B0aW9ucy5cbiAqIFRoZSBvcHRpb25zIG9iamVjdCB0byBiZSBwYXNzZWQgdG8gaHR0cC5yZXF1ZXN0XG4gKlxuICogQHBhcmFtIHtSZXF1ZXN0ICYgUmVjb3JkPElOVEVSTkFMUywgUmVxdWVzdFN0YXRlPn0gcmVxdWVzdCAtICBBIFJlcXVlc3QgaW5zdGFuY2VcbiAqL1xuZXhwb3J0IGNvbnN0IGdldE5vZGVSZXF1ZXN0T3B0aW9ucyA9IHJlcXVlc3QgPT4ge1xuXHRjb25zdCB7cGFyc2VkVVJMfSA9IHJlcXVlc3RbSU5URVJOQUxTXTtcblx0Y29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKHJlcXVlc3RbSU5URVJOQUxTXS5oZWFkZXJzKTtcblxuXHQvLyBGZXRjaCBzdGVwIDEuM1xuXHRpZiAoIWhlYWRlcnMuaGFzKCdBY2NlcHQnKSkge1xuXHRcdGhlYWRlcnMuc2V0KCdBY2NlcHQnLCAnKi8qJyk7XG5cdH1cblxuXHQvLyBIVFRQLW5ldHdvcmstb3ItY2FjaGUgZmV0Y2ggc3RlcHMgMi40LTIuN1xuXHRsZXQgY29udGVudExlbmd0aFZhbHVlID0gbnVsbDtcblx0aWYgKHJlcXVlc3QuYm9keSA9PT0gbnVsbCAmJiAvXihwb3N0fHB1dCkkL2kudGVzdChyZXF1ZXN0Lm1ldGhvZCkpIHtcblx0XHRjb250ZW50TGVuZ3RoVmFsdWUgPSAnMCc7XG5cdH1cblxuXHRpZiAocmVxdWVzdC5ib2R5ICE9PSBudWxsKSB7XG5cdFx0Y29uc3QgdG90YWxCeXRlcyA9IGdldFRvdGFsQnl0ZXMocmVxdWVzdCk7XG5cdFx0Ly8gU2V0IENvbnRlbnQtTGVuZ3RoIGlmIHRvdGFsQnl0ZXMgaXMgYSBudW1iZXIgKHRoYXQgaXMgbm90IE5hTilcblx0XHRpZiAodHlwZW9mIHRvdGFsQnl0ZXMgPT09ICdudW1iZXInICYmICFOdW1iZXIuaXNOYU4odG90YWxCeXRlcykpIHtcblx0XHRcdGNvbnRlbnRMZW5ndGhWYWx1ZSA9IFN0cmluZyh0b3RhbEJ5dGVzKTtcblx0XHR9XG5cdH1cblxuXHRpZiAoY29udGVudExlbmd0aFZhbHVlKSB7XG5cdFx0aGVhZGVycy5zZXQoJ0NvbnRlbnQtTGVuZ3RoJywgY29udGVudExlbmd0aFZhbHVlKTtcblx0fVxuXG5cdC8vIEhUVFAtbmV0d29yay1vci1jYWNoZSBmZXRjaCBzdGVwIDIuMTFcblx0aWYgKCFoZWFkZXJzLmhhcygnVXNlci1BZ2VudCcpKSB7XG5cdFx0aGVhZGVycy5zZXQoJ1VzZXItQWdlbnQnLCAnbm9kZS1mZXRjaCcpO1xuXHR9XG5cblx0Ly8gSFRUUC1uZXR3b3JrLW9yLWNhY2hlIGZldGNoIHN0ZXAgMi4xNVxuXHRpZiAocmVxdWVzdC5jb21wcmVzcyAmJiAhaGVhZGVycy5oYXMoJ0FjY2VwdC1FbmNvZGluZycpKSB7XG5cdFx0aGVhZGVycy5zZXQoJ0FjY2VwdC1FbmNvZGluZycsICdnemlwLGRlZmxhdGUsYnInKTtcblx0fVxuXG5cdGxldCB7YWdlbnR9ID0gcmVxdWVzdDtcblx0aWYgKHR5cGVvZiBhZ2VudCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdGFnZW50ID0gYWdlbnQocGFyc2VkVVJMKTtcblx0fVxuXG5cdGlmICghaGVhZGVycy5oYXMoJ0Nvbm5lY3Rpb24nKSAmJiAhYWdlbnQpIHtcblx0XHRoZWFkZXJzLnNldCgnQ29ubmVjdGlvbicsICdjbG9zZScpO1xuXHR9XG5cblx0Ly8gSFRUUC1uZXR3b3JrIGZldGNoIHN0ZXAgNC4yXG5cdC8vIGNodW5rZWQgZW5jb2RpbmcgaXMgaGFuZGxlZCBieSBOb2RlLmpzXG5cblx0Y29uc3Qgc2VhcmNoID0gZ2V0U2VhcmNoKHBhcnNlZFVSTCk7XG5cblx0Ly8gTWFudWFsbHkgc3ByZWFkIHRoZSBVUkwgb2JqZWN0IGluc3RlYWQgb2Ygc3ByZWFkIHN5bnRheFxuXHRjb25zdCByZXF1ZXN0T3B0aW9ucyA9IHtcblx0XHRwYXRoOiBwYXJzZWRVUkwucGF0aG5hbWUgKyBzZWFyY2gsXG5cdFx0cGF0aG5hbWU6IHBhcnNlZFVSTC5wYXRobmFtZSxcblx0XHRob3N0bmFtZTogcGFyc2VkVVJMLmhvc3RuYW1lLFxuXHRcdHByb3RvY29sOiBwYXJzZWRVUkwucHJvdG9jb2wsXG5cdFx0cG9ydDogcGFyc2VkVVJMLnBvcnQsXG5cdFx0aGFzaDogcGFyc2VkVVJMLmhhc2gsXG5cdFx0c2VhcmNoOiBwYXJzZWRVUkwuc2VhcmNoLFxuXHRcdC8vIEB0cy1pZ25vcmUgLSBpdCBkb2VzIG5vdCBoYXMgYSBxdWVyeVxuXHRcdHF1ZXJ5OiBwYXJzZWRVUkwucXVlcnksXG5cdFx0aHJlZjogcGFyc2VkVVJMLmhyZWYsXG5cdFx0bWV0aG9kOiByZXF1ZXN0Lm1ldGhvZCxcblx0XHQvLyBAdHMtaWdub3JlIC0gbm90IHN1cmUgd2hhdCB0aGlzIHN1cHBvc2VkIHRvIGRvXG5cdFx0aGVhZGVyczogaGVhZGVyc1tTeW1ib2wuZm9yKCdub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbScpXSgpLFxuXHRcdGluc2VjdXJlSFRUUFBhcnNlcjogcmVxdWVzdC5pbnNlY3VyZUhUVFBQYXJzZXIsXG5cdFx0YWdlbnRcblx0fTtcblxuXHRyZXR1cm4gcmVxdWVzdE9wdGlvbnM7XG59O1xuIiwgIi8qKlxuICogQHBhcmFtIHtVUkx9IHBhcnNlZFVSTCBcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBjb25zdCBnZXRTZWFyY2ggPSBwYXJzZWRVUkwgPT4ge1xuXHRpZiAocGFyc2VkVVJMLnNlYXJjaCkge1xuXHRcdHJldHVybiBwYXJzZWRVUkwuc2VhcmNoO1xuXHR9XG5cblx0Y29uc3QgbGFzdE9mZnNldCA9IHBhcnNlZFVSTC5ocmVmLmxlbmd0aCAtIDE7XG5cdGNvbnN0IGhhc2ggPSBwYXJzZWRVUkwuaGFzaCB8fCAocGFyc2VkVVJMLmhyZWZbbGFzdE9mZnNldF0gPT09ICcjJyA/ICcjJyA6ICcnKTtcblx0cmV0dXJuIHBhcnNlZFVSTC5ocmVmW2xhc3RPZmZzZXQgLSBoYXNoLmxlbmd0aF0gPT09ICc/JyA/ICc/JyA6ICcnO1xufTtcbiIsICJpbXBvcnQge0ZldGNoQmFzZUVycm9yfSBmcm9tICcuL2Jhc2UuanMnO1xuXG4vKipcbiAqIEFib3J0RXJyb3IgaW50ZXJmYWNlIGZvciBjYW5jZWxsZWQgcmVxdWVzdHNcbiAqL1xuZXhwb3J0IGNsYXNzIEFib3J0RXJyb3IgZXh0ZW5kcyBGZXRjaEJhc2VFcnJvciB7XG5cdC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSBcblx0ICogQHBhcmFtIHtzdHJpbmd9IFt0eXBlXVxuXHQgKi9cblx0Y29uc3RydWN0b3IobWVzc2FnZSwgdHlwZSA9ICdhYm9ydGVkJykge1xuXHRcdHN1cGVyKG1lc3NhZ2UsIHR5cGUpO1xuXHR9XG59XG4iLCAiaW1wb3J0IHsgZmV0Y2ggYXMgd2ViRmV0Y2gsIEhlYWRlcnMgYXMgV2ViSGVhZGVycywgUmVxdWVzdCBhcyBXZWJSZXF1ZXN0LCBSZXNwb25zZSBhcyBXZWJSZXNwb25zZSB9IGZyb20gXCIuL2ZldGNoLmpzXCJcblxuZXhwb3J0IHsgUmVhZGFibGVTdHJlYW0sIEJsb2IsIEZvcm1EYXRhLCBGaWxlICB9IGZyb20gJy4vcGFja2FnZS5qcyc7XG4vLyBFbGVjdHJvbi1yZW5kZXJlciBzaG91bGQgZ2V0IHRoZSBicm93c2VyIGltcGxlbWVudGF0aW9uIGluc3RlYWQgb2Ygbm9kZVxuLy8gQnJvd3NlciBjb25maWd1cmF0aW9uIGlzIG5vdCBlbm91Z2hcblxuLy8gTWFya2luZyBleHBvcnQgYXMgYSBET00gRmlsZSBvYmplY3QgaW5zdGVhZCBvZiBjdXN0b20gY2xhc3MuXG5leHBvcnQgY29uc3QgZmV0Y2ggPSAvKiogQHR5cGUge3R5cGVvZiBnbG9iYWxUaGlzLmZldGNofSAqL1xuICAodHlwZW9mIGdsb2JhbFRoaXMuZmV0Y2ggPT09IFwiZnVuY3Rpb25cIiA/IGdsb2JhbFRoaXMuZmV0Y2guYmluZChnbG9iYWxUaGlzKSA6IHdlYkZldGNoKVxuXG5leHBvcnQgY29uc3QgSGVhZGVycyA9IGdsb2JhbFRoaXMuSGVhZGVycyB8fCBXZWJIZWFkZXJzXG5leHBvcnQgY29uc3QgUmVxdWVzdCA9IGdsb2JhbFRoaXMuUmVxdWVzdCB8fCBXZWJSZXF1ZXN0XG5leHBvcnQgY29uc3QgUmVzcG9uc2UgPSBnbG9iYWxUaGlzLlJlc3BvbnNlIHx8IFdlYlJlc3BvbnNlXG5cbmV4cG9ydCBkZWZhdWx0IGZldGNoXG4iLCAiaW1wb3J0IGZzIGZyb20gJ2ZzJztcbmltcG9ydCBvcyBmcm9tICdvcyc7XG5pbXBvcnQgeyBDSUQgfSBmcm9tICdtdWx0aWZvcm1hdHMnO1xuaW1wb3J0IHsgQmFzZUJsb2Nrc3RvcmUgfSBmcm9tICdibG9ja3N0b3JlLWNvcmUnO1xuZXhwb3J0IGNsYXNzIEZzQmxvY2tTdG9yZSBleHRlbmRzIEJhc2VCbG9ja3N0b3JlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5wYXRoID0gYCR7b3MudG1wZGlyKCl9LyR7KHBhcnNlSW50KFN0cmluZyhNYXRoLnJhbmRvbSgpICogMWU5KSwgMTApKS50b1N0cmluZygpICsgRGF0ZS5ub3coKX1gO1xuICAgICAgICB0aGlzLl9vcGVuZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgYXN5bmMgX29wZW4oKSB7XG4gICAgICAgIGlmICh0aGlzLl9vcGVuaW5nKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9vcGVuaW5nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fb3BlbmluZyA9IGZzLnByb21pc2VzLm1rZGlyKHRoaXMucGF0aCk7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9vcGVuaW5nO1xuICAgICAgICAgICAgdGhpcy5fb3BlbmVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBwdXQoY2lkLCBieXRlcykge1xuICAgICAgICBpZiAoIXRoaXMuX29wZW5lZCkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fb3BlbigpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNpZFN0ciA9IGNpZC50b1N0cmluZygpO1xuICAgICAgICBjb25zdCBsb2NhdGlvbiA9IGAke3RoaXMucGF0aH0vJHtjaWRTdHJ9YDtcbiAgICAgICAgYXdhaXQgZnMucHJvbWlzZXMud3JpdGVGaWxlKGxvY2F0aW9uLCBieXRlcyk7XG4gICAgfVxuICAgIGFzeW5jIGdldChjaWQpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9vcGVuZWQpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX29wZW4oKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjaWRTdHIgPSBjaWQudG9TdHJpbmcoKTtcbiAgICAgICAgY29uc3QgbG9jYXRpb24gPSBgJHt0aGlzLnBhdGh9LyR7Y2lkU3RyfWA7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gYXdhaXQgZnMucHJvbWlzZXMucmVhZEZpbGUobG9jYXRpb24pO1xuICAgICAgICByZXR1cm4gYnl0ZXM7XG4gICAgfVxuICAgIGFzeW5jIGhhcyhjaWQpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9vcGVuZWQpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX29wZW4oKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjaWRTdHIgPSBjaWQudG9TdHJpbmcoKTtcbiAgICAgICAgY29uc3QgbG9jYXRpb24gPSBgJHt0aGlzLnBhdGh9LyR7Y2lkU3RyfWA7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCBmcy5wcm9taXNlcy5hY2Nlc3MobG9jYXRpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jICpibG9ja3MoKSB7XG4gICAgICAgIGlmICghdGhpcy5fb3BlbmVkKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9vcGVuKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2lkcyA9IGF3YWl0IGZzLnByb21pc2VzLnJlYWRkaXIodGhpcy5wYXRoKTtcbiAgICAgICAgZm9yIChjb25zdCBjaWRTdHIgb2YgY2lkcykge1xuICAgICAgICAgICAgY29uc3QgbG9jYXRpb24gPSBgJHt0aGlzLnBhdGh9LyR7Y2lkU3RyfWA7XG4gICAgICAgICAgICBjb25zdCBieXRlcyA9IGF3YWl0IGZzLnByb21pc2VzLnJlYWRGaWxlKGxvY2F0aW9uKTtcbiAgICAgICAgICAgIHlpZWxkIHsgY2lkOiBDSUQucGFyc2UoY2lkU3RyKSwgYnl0ZXMgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBjbG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX29wZW5lZCkge1xuICAgICAgICAgICAgYXdhaXQgZnMucHJvbWlzZXMucm0odGhpcy5wYXRoLCB7IHJlY3Vyc2l2ZTogdHJ1ZSB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9vcGVuZWQgPSBmYWxzZTtcbiAgICB9XG59XG4iLCAiZXhwb3J0IGNvbnN0IEdBVEVXQVkgPSBuZXcgVVJMKCdodHRwczovL25mdHN0b3JhZ2UubGluay8nKVxuXG4vKipcbiAqIEB0eXBlZGVmIHtzdHJpbmd8VVJMfSBHYXRld2F5VVJMIEJhc2UgVVJMIG9mIGFuIElQRlMgR2F0ZXdheSBlLmcuIGh0dHBzOi8vZHdlYi5saW5rLyBvciBodHRwczovL2lwZnMuaW8vXG4gKiBAdHlwZWRlZiB7eyBnYXRld2F5PzogR2F0ZXdheVVSTCB9fSBHYXRld2F5VVJMT3B0aW9uc1xuICovXG5cbi8qKlxuICogQ29udmVydCBhbiBJUEZTIFVSTCAoc3RhcnRpbmcgaXBmczovLykgdG8gYSBnYXRld2F5IFVSTCAoc3RhcnRpbmcgaHR0cHM6Ly8pXG4gKiB0aGF0IGNhbiBiZSB1c2VkIGluIGEgd2VicGFnZS4gSWYgdGhlIHBhc3NlZCBVUkwgaXMgbm90IGFuIElQRlMgVVJMIGl0IGlzXG4gKiByZXR1cm5lZCBhcyBhIG5ldyBVUkwgb2JqZWN0IHdpdGggbm8gZnVydGhlciBjaGFuZ2VzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfFVSTH0gdXJsIEFuIElQRlMgVVJMIGUuZy4gaXBmczovL2JhZnkuLi4vcGF0aFxuICogQHBhcmFtIHtHYXRld2F5VVJMT3B0aW9uc30gW29wdGlvbnNdIE9wdGlvbnMgdGhhdCBhbGxvdyBjdXN0b21pemF0aW9uIG9mIHRoZSBnYXRld2F5IHVzZWQuXG4gKiBAcmV0dXJucyB7VVJMfSBBbiBJUEZTIGdhdGV3YXkgVVJMIGUuZy4gaHR0cHM6Ly9uZnRzdG9yYWdlLmxpbmsvaXBmcy9iYWZ5Li4uL3BhdGhcbiAqL1xuZXhwb3J0IGNvbnN0IHRvR2F0ZXdheVVSTCA9ICh1cmwsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICBjb25zdCBnYXRld2F5ID0gb3B0aW9ucy5nYXRld2F5IHx8IEdBVEVXQVlcbiAgdXJsID0gbmV3IFVSTChTdHJpbmcodXJsKSlcbiAgcmV0dXJuIHVybC5wcm90b2NvbCA9PT0gJ2lwZnM6J1xuICAgID8gbmV3IFVSTChgL2lwZnMvJHt1cmwuaHJlZi5zbGljZSgnaXBmczovLycubGVuZ3RoKX1gLCBnYXRld2F5KVxuICAgIDogdXJsXG59XG4iLCAiLyoqXG4gKiBBbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgQ0FSIHJlYWRlciBpbnRlcmZhY2UgdGhhdCBpcyBiYWNrZWQgYnkgYSBibG9ja3N0b3JlLlxuICpcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ211bHRpZm9ybWF0cycpLkNJRH0gQ0lEXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdAaXBsZC9jYXIvYXBpJykuQ2FyUmVhZGVyfSBDYXJSZWFkZXJcbiAqIEBpbXBsZW1lbnRzIHtDYXJSZWFkZXJ9XG4gKi9cbmV4cG9ydCBjbGFzcyBCbG9ja3N0b3JlQ2FyUmVhZGVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2ZXJzaW9uXG4gICAqIEBwYXJhbSB7Q0lEW119IHJvb3RzXG4gICAqIEBwYXJhbSB7aW1wb3J0KCdpcGZzLWNhci9ibG9ja3N0b3JlJykuQmxvY2tzdG9yZX0gYmxvY2tzdG9yZVxuICAgKi9cbiAgY29uc3RydWN0b3IodmVyc2lvbiwgcm9vdHMsIGJsb2Nrc3RvcmUpIHtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3ZlcnNpb24gPSB2ZXJzaW9uXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9yb290cyA9IHJvb3RzXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9ibG9ja3N0b3JlID0gYmxvY2tzdG9yZVxuICB9XG5cbiAgZ2V0IHZlcnNpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZlcnNpb25cbiAgfVxuXG4gIGdldCBibG9ja3N0b3JlKCkge1xuICAgIHJldHVybiB0aGlzLl9ibG9ja3N0b3JlXG4gIH1cblxuICBhc3luYyBnZXRSb290cygpIHtcbiAgICByZXR1cm4gdGhpcy5fcm9vdHNcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0NJRH0gY2lkXG4gICAqL1xuICBoYXMoY2lkKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Jsb2Nrc3RvcmUuaGFzKGNpZClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0NJRH0gY2lkXG4gICAqL1xuICBhc3luYyBnZXQoY2lkKSB7XG4gICAgY29uc3QgYnl0ZXMgPSBhd2FpdCB0aGlzLl9ibG9ja3N0b3JlLmdldChjaWQpXG4gICAgcmV0dXJuIHsgY2lkLCBieXRlcyB9XG4gIH1cblxuICBibG9ja3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Jsb2Nrc3RvcmUuYmxvY2tzKClcbiAgfVxuXG4gIGFzeW5jICpjaWRzKCkge1xuICAgIGZvciBhd2FpdCAoY29uc3QgYiBvZiB0aGlzLmJsb2NrcygpKSB7XG4gICAgICB5aWVsZCBiLmNpZFxuICAgIH1cbiAgfVxufVxuIiwgImltcG9ydCB7IHBhY2sgfSBmcm9tICdpcGZzLWNhci9wYWNrJ1xuaW1wb3J0IHsgQ0lEIH0gZnJvbSAnbXVsdGlmb3JtYXRzL2NpZCdcbmltcG9ydCAqIGFzIEJsb2NrIGZyb20gJ211bHRpZm9ybWF0cy9ibG9jaydcbmltcG9ydCB7IHNoYTI1NiB9IGZyb20gJ211bHRpZm9ybWF0cy9oYXNoZXMvc2hhMidcbmltcG9ydCAqIGFzIGRhZ0Nib3IgZnJvbSAnQGlwbGQvZGFnLWNib3InXG5pbXBvcnQgeyBCbG9iLCBGb3JtRGF0YSwgQmxvY2tzdG9yZSB9IGZyb20gJy4vcGxhdGZvcm0uanMnXG5pbXBvcnQgeyB0b0dhdGV3YXlVUkwsIEdBVEVXQVkgfSBmcm9tICcuL2dhdGV3YXkuanMnXG5pbXBvcnQgeyBCbG9ja3N0b3JlQ2FyUmVhZGVyIH0gZnJvbSAnLi9icy1jYXItcmVhZGVyLmpzJ1xuXG4vKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4vZ2F0ZXdheS5qcycpLkdhdGV3YXlVUkxPcHRpb25zfSBFbWJlZE9wdGlvbnNcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4vbGliL2ludGVyZmFjZS5qcycpLlRva2VuSW5wdXR9IFRva2VuSW5wdXRcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2lwZnMtY2FyL2Jsb2Nrc3RvcmUnKS5CbG9ja3N0b3JlfSBCbG9ja3N0b3JlXG4gKi9cblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHR5cGVkZWYge2ltcG9ydCgnLi9saWIvaW50ZXJmYWNlLmpzJykuRW5jb2RlZDxULCBbW0Jsb2IsIFVSTF1dPn0gRW5jb2RlZEJsb2JVcmxcbiAqL1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBHXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuL2xpYi9pbnRlcmZhY2UuanMnKS5FbmNvZGVkPEcsIFtbQmxvYiwgQmxvYl1dPn0gRW5jb2RlZEJsb2JCbG9iXG4gKi9cblxuLyoqXG4gKiBAdGVtcGxhdGUge2ltcG9ydCgnLi9saWIvaW50ZXJmYWNlLmpzJykuVG9rZW5JbnB1dH0gVFxuICogQHR5cGVkZWYge2ltcG9ydCgnLi9saWIvaW50ZXJmYWNlLmpzJykuVG9rZW48VD59IFRva2VuVHlwZVxuICovXG5cbi8qKlxuICogQHRlbXBsYXRlIHtUb2tlbklucHV0fSBUXG4gKiBAaW1wbGVtZW50cyB7VG9rZW5UeXBlPFQ+fVxuICovXG5leHBvcnQgY2xhc3MgVG9rZW4ge1xuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoJy4vbGliL2ludGVyZmFjZS5qcycpLkNJRFN0cmluZ30gaXBuZnRcbiAgICogQHBhcmFtIHtpbXBvcnQoJy4vbGliL2ludGVyZmFjZS5qcycpLkVuY29kZWRVUkx9IHVybFxuICAgKiBAcGFyYW0ge2ltcG9ydCgnLi9saWIvaW50ZXJmYWNlLmpzJykuRW5jb2RlZDxULCBbW0Jsb2IsIFVSTF1dPn0gZGF0YVxuICAgKi9cbiAgY29uc3RydWN0b3IoaXBuZnQsIHVybCwgZGF0YSkge1xuICAgIC8qKiBAcmVhZG9ubHkgKi9cbiAgICB0aGlzLmlwbmZ0ID0gaXBuZnRcbiAgICAvKiogQHJlYWRvbmx5ICovXG4gICAgdGhpcy51cmwgPSB1cmxcbiAgICAvKiogQHJlYWRvbmx5ICovXG4gICAgdGhpcy5kYXRhID0gZGF0YVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgaXBuZnQ6IHsgZW51bWVyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IGZhbHNlIH0sXG4gICAgICB1cmw6IHsgZW51bWVyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IGZhbHNlIH0sXG4gICAgICBkYXRhOiB7IGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogZmFsc2UgfSxcbiAgICB9KVxuICB9XG4gIC8qKlxuICAgKiBAcmV0dXJucyB7aW1wb3J0KCcuL2xpYi9pbnRlcmZhY2UuanMnKS5FbmNvZGVkPFQsIFtbQmxvYiwgVVJMXV0+fVxuICAgKi9cbiAgZW1iZWQoKSB7XG4gICAgcmV0dXJuIFRva2VuLmVtYmVkKHRoaXMpXG4gIH1cblxuICAvKipcbiAgICogQHRlbXBsYXRlIHtUb2tlbklucHV0fSBUXG4gICAqIEBwYXJhbSB7e2RhdGE6IGltcG9ydCgnLi9saWIvaW50ZXJmYWNlLmpzJykuRW5jb2RlZDxULCBbW0Jsb2IsIFVSTF1dPn19IHRva2VuXG4gICAqIEByZXR1cm5zIHtpbXBvcnQoJy4vbGliL2ludGVyZmFjZS5qcycpLkVuY29kZWQ8VCwgW1tCbG9iLCBVUkxdXT59XG4gICAqL1xuICBzdGF0aWMgZW1iZWQoeyBkYXRhIH0pIHtcbiAgICByZXR1cm4gZW1iZWQoZGF0YSwgeyBnYXRld2F5OiBHQVRFV0FZIH0pXG4gIH1cblxuICAvKipcbiAgICogVGFrZXMgdG9rZW4gaW5wdXQsIGVuY29kZXMgaXQgYXMgYSBEQUcsIHdyYXBzIGl0IGluIGEgQ0FSIGFuZCBjcmVhdGVzIGEgbmV3XG4gICAqIFRva2VuIGluc3RhbmNlIGZyb20gaXQuIFdoZXJlIHZhbHVlcyBhcmUgZGlzY292ZXJlZCBgQmxvYmAgKG9yIGBGaWxlYClcbiAgICogb2JqZWN0cyBpbiB0aGUgZ2l2ZW4gaW5wdXQsIHRoZXkgYXJlIHJlcGxhY2VkIHdpdGggSVBGUyBVUkxzIChhbiBgaXBmczovL2BcbiAgICogcHJlZml4ZWQgQ0lEIHdpdGggYW4gb3B0aW9uYWwgcGF0aCkuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IGNhdCA9IG5ldyBGaWxlKFsnLi4uJ10sICdjYXQucG5nJylcbiAgICogY29uc3Qga2l0dHkgPSBuZXcgRmlsZShbJy4uLiddLCAna2l0dHkucG5nJylcbiAgICogY29uc3QgeyB0b2tlbiwgY2FyIH0gPSBhd2FpdCBUb2tlbi5lbmNvZGUoe1xuICAgKiAgIG5hbWU6ICdoZWxsbydcbiAgICogICBpbWFnZTogY2F0XG4gICAqICAgcHJvcGVydGllczoge1xuICAgKiAgICAgZXh0cmE6IHtcbiAgICogICAgICAgaW1hZ2U6IGtpdHR5XG4gICAqICAgICB9XG4gICAqICAgfVxuICAgKiB9KVxuICAgKiBgYGBcbiAgICpcbiAgICogQHRlbXBsYXRlIHtUb2tlbklucHV0fSBUXG4gICAqIEBwYXJhbSB7VH0gaW5wdXRcbiAgICogQHJldHVybnMge1Byb21pc2U8eyBjaWQ6IENJRCwgdG9rZW46IFRva2VuVHlwZTxUPiwgY2FyOiBpbXBvcnQoJy4vbGliL2ludGVyZmFjZS5qcycpLkNhclJlYWRlciB9Pn1cbiAgICovXG4gIHN0YXRpYyBhc3luYyBlbmNvZGUoaW5wdXQpIHtcbiAgICBjb25zdCBibG9ja3N0b3JlID0gbmV3IEJsb2Nrc3RvcmUoKVxuICAgIGNvbnN0IFtibG9icywgbWV0YV0gPSBtYXBUb2tlbklucHV0QmxvYnMoaW5wdXQpXG4gICAgLyoqIEB0eXBlIHtFbmNvZGVkQmxvYlVybDxUPn0gKi9cbiAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShtZXRhKSlcbiAgICAvKiogQHR5cGUge2ltcG9ydCgnLi9saWIvaW50ZXJmYWNlLmpzJykuRW5jb2RlZDxULCBbW0Jsb2IsIENJRF1dPn0gKi9cbiAgICBjb25zdCBkYWcgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG1ldGEpKVxuXG4gICAgZm9yIChjb25zdCBbZG90UGF0aCwgYmxvYl0gb2YgYmxvYnMuZW50cmllcygpKSB7XG4gICAgICAvKiogQHR5cGUge3N0cmluZ3x1bmRlZmluZWR9ICovXG4gICAgICAvLyBAdHMtaWdub3JlIGJsb2IgbWF5IGJlIGEgRmlsZSFcbiAgICAgIGNvbnN0IG5hbWUgPSBibG9iLm5hbWUgfHwgJ2Jsb2InXG4gICAgICAvKiogQHR5cGUge2ltcG9ydCgnLi9wbGF0Zm9ybS5qcycpLlJlYWRhYmxlU3RyZWFtfSAqL1xuICAgICAgbGV0IGNvbnRlbnRcbiAgICAgIC8vIEZJWE1FOiBzaG91bGQgbm90IGJlIG5lY2Vzc2FyeSB0byBhd2FpdCBhcnJheUJ1ZmZlcigpIVxuICAgICAgLy8gTm9kZS5qcyAyMCBoYW5ncyByZWFkaW5nIHRoZSBzdHJlYW0gKGl0IG5ldmVyIGVuZHMpIGJ1dCBpblxuICAgICAgLy8gb2xkZXIgbm9kZSB2ZXJzaW9ucyBhbmQgdGhlIGJyb3dzZXIgaXQgaXMgZmluZSB0byB1c2UgYmxvYi5zdHJlYW0oKS5cbiAgICAgIC8qIGM4IGlnbm9yZSBuZXh0IDUgKi9cbiAgICAgIGlmIChwYXJzZUludChnbG9iYWxUaGlzLnByb2Nlc3M/LnZlcnNpb25zPy5ub2RlKSA+IDE4KSB7XG4gICAgICAgIGNvbnRlbnQgPSBuZXcgVWludDhBcnJheShhd2FpdCBibG9iLmFycmF5QnVmZmVyKCkpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250ZW50ID0gYmxvYi5zdHJlYW0oKVxuICAgICAgfVxuICAgICAgY29uc3QgeyByb290OiBjaWQgfSA9IGF3YWl0IHBhY2soe1xuICAgICAgICBpbnB1dDogW3sgcGF0aDogbmFtZSwgY29udGVudCB9XSxcbiAgICAgICAgYmxvY2tzdG9yZSxcbiAgICAgICAgd3JhcFdpdGhEaXJlY3Rvcnk6IHRydWUsXG4gICAgICB9KVxuXG4gICAgICBjb25zdCBocmVmID0gbmV3IFVSTChgaXBmczovLyR7Y2lkfS8ke25hbWV9YClcbiAgICAgIGNvbnN0IHBhdGggPSBkb3RQYXRoLnNwbGl0KCcuJylcbiAgICAgIHNldEluKGRhdGEsIHBhdGgsIGhyZWYpXG4gICAgICBzZXRJbihkYWcsIHBhdGgsIGNpZClcbiAgICB9XG5cbiAgICBjb25zdCB7IHJvb3Q6IG1ldGFkYXRhSnNvbkNpZCB9ID0gYXdhaXQgcGFjayh7XG4gICAgICBpbnB1dDogW3sgcGF0aDogJ21ldGFkYXRhLmpzb24nLCBjb250ZW50OiBKU09OLnN0cmluZ2lmeShkYXRhKSB9XSxcbiAgICAgIGJsb2Nrc3RvcmUsXG4gICAgICB3cmFwV2l0aERpcmVjdG9yeTogZmFsc2UsXG4gICAgfSlcblxuICAgIGNvbnN0IGJsb2NrID0gYXdhaXQgQmxvY2suZW5jb2RlKHtcbiAgICAgIHZhbHVlOiB7XG4gICAgICAgIC4uLmRhZyxcbiAgICAgICAgJ21ldGFkYXRhLmpzb24nOiBtZXRhZGF0YUpzb25DaWQsXG4gICAgICAgIHR5cGU6ICduZnQnLFxuICAgICAgfSxcbiAgICAgIGNvZGVjOiBkYWdDYm9yLFxuICAgICAgaGFzaGVyOiBzaGEyNTYsXG4gICAgfSlcbiAgICBhd2FpdCBibG9ja3N0b3JlLnB1dChibG9jay5jaWQsIGJsb2NrLmJ5dGVzKVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGNpZDogYmxvY2suY2lkLFxuICAgICAgdG9rZW46IG5ldyBUb2tlbihcbiAgICAgICAgYmxvY2suY2lkLnRvU3RyaW5nKCksXG4gICAgICAgIGBpcGZzOi8vJHtibG9jay5jaWR9L21ldGFkYXRhLmpzb25gLFxuICAgICAgICBkYXRhXG4gICAgICApLFxuICAgICAgY2FyOiBuZXcgQmxvY2tzdG9yZUNhclJlYWRlcigxLCBbYmxvY2suY2lkXSwgYmxvY2tzdG9yZSksXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7RW5jb2RlZEJsb2JVcmw8VD59IGlucHV0XG4gKiBAcGFyYW0ge0VtYmVkT3B0aW9uc30gb3B0aW9uc1xuICogQHJldHVybnMge0VuY29kZWRCbG9iVXJsPFQ+fVxuICovXG5leHBvcnQgY29uc3QgZW1iZWQgPSAoaW5wdXQsIG9wdGlvbnMpID0+XG4gIG1hcFdpdGgoaW5wdXQsIGlzVVJMLCBlbWJlZFVSTCwgb3B0aW9ucylcblxuLyoqXG4gKiBAdGVtcGxhdGUge1Rva2VuSW5wdXR9IFRcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2xpYi9pbnRlcmZhY2UuanMnKS5FbmNvZGVkVG9rZW48VD59IHZhbHVlXG4gKiBAcGFyYW0ge1NldDxzdHJpbmc+fSBwYXRocyAtIFBhdGhzIHdlcmUgdG8gZXhwZWN0IEVuY29kZWRVUkxzXG4gKiBAcmV0dXJucyB7VG9rZW48VD59XG4gKi9cbmV4cG9ydCBjb25zdCBkZWNvZGUgPSAoeyBpcG5mdCwgdXJsLCBkYXRhIH0sIHBhdGhzKSA9PlxuICBuZXcgVG9rZW4oaXBuZnQsIHVybCwgbWFwV2l0aChkYXRhLCBpc0VuY29kZWRVUkwsIGRlY29kZVVSTCwgcGF0aHMpKVxuXG4vKipcbiAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuICogQHJldHVybnMge3ZhbHVlIGlzIFVSTH1cbiAqL1xuY29uc3QgaXNVUkwgPSAodmFsdWUpID0+IHZhbHVlIGluc3RhbmNlb2YgVVJMXG5cbi8qKlxuICogQHRlbXBsYXRlIFN0YXRlXG4gKiBAcGFyYW0ge1N0YXRlfSBzdGF0ZVxuICogQHBhcmFtIHtpbXBvcnQoJy4vbGliL2ludGVyZmFjZS5qcycpLkVuY29kZWRVUkx9IHVybFxuICogQHJldHVybnMge1tTdGF0ZSwgVVJMXX1cbiAqL1xuY29uc3QgZGVjb2RlVVJMID0gKHN0YXRlLCB1cmwpID0+IFtzdGF0ZSwgbmV3IFVSTCh1cmwpXVxuXG4vKipcbiAqIEBwYXJhbSB7RW1iZWRPcHRpb25zfSBjb250ZXh0XG4gKiBAcGFyYW0ge1VSTH0gdXJsXG4gKiBAcmV0dXJucyB7W0VtYmVkT3B0aW9ucywgVVJMXX1cbiAqL1xuY29uc3QgZW1iZWRVUkwgPSAoY29udGV4dCwgdXJsKSA9PiBbY29udGV4dCwgdG9HYXRld2F5VVJMKHVybCwgY29udGV4dCldXG5cbi8qKlxuICogQHBhcmFtIHthbnl9IHZhbHVlXG4gKiBAcmV0dXJucyB7dmFsdWUgaXMgb2JqZWN0fVxuICovXG5jb25zdCBpc09iamVjdCA9ICh2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPSBudWxsXG5cbi8qKlxuICogQHBhcmFtIHthbnl9IHZhbHVlXG4gKiBAcGFyYW0ge1NldDxzdHJpbmc+fSBhc3NldFBhdGhzXG4gKiBAcGFyYW0ge1Byb3BlcnR5S2V5W119IHBhdGhcbiAqIEByZXR1cm5zIHt2YWx1ZSBpcyBpbXBvcnQoJy4vbGliL2ludGVyZmFjZS5qcycpLkVuY29kZWRVUkx9XG4gKi9cbmNvbnN0IGlzRW5jb2RlZFVSTCA9ICh2YWx1ZSwgYXNzZXRQYXRocywgcGF0aCkgPT5cbiAgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiBhc3NldFBhdGhzLmhhcyhwYXRoLmpvaW4oJy4nKSlcblxuLyoqXG4gKiBUYWtlcyB0b2tlbiBpbnB1dCBhbmQgZW5jb2RlcyBpdCBpbnRvXG4gKiBbRm9ybURhdGFdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Gb3JtRGF0YSlcbiAqIG9iamVjdCB3aGVyZSBmb3JtIGZpZWxkIHZhbHVlcyBhcmUgZGlzY292ZXJlZCBgQmxvYmAgKG9yIGBGaWxlYCkgb2JqZWN0cyBpblxuICogdGhlIGdpdmVuIHRva2VuIGFuZCBmaWVsZCBrZXlzIGFyZSBgLmAgam9pbmVkIHBhdGhzIHdoZXJlIHRoZXkgd2VyZSBkaXNjb3ZlcmRcbiAqIGluIHRoZSB0b2tlbi4gQWRkaXRpb25hbGx5IGVuY29kZWQgYEZvcm1EYXRhYCB3aWxsIGFsc28gaGF2ZSBhIGZpZWxkXG4gKiBuYW1lZCBgbWV0YWAgY29udGFpbmluZyBKU09OIHNlcmlhbGl6ZWQgdG9rZW4gd2l0aCBibG9icyBhbmQgZmlsZSB2YWx1ZXNcbiAqIGBudWxsYCBzZXQgdG8gbnVsbCAodGhpcyBhbGxvd3MgYmFja2VuZCB0byBpbmplc3QgYWxsIG9mIHRoZSBmaWxlcyBmcm9tXG4gKiBgbXVsdGlwYXJ0L2Zvcm0tZGF0YWAgcmVxdWVzdCBhbmQgdXBkYXRlIHByb3ZpZGVkIFwibWV0YVwiIGRhdGEgd2l0aFxuICogY29ycmVzcG9uZGluZyBmaWxlIGlwZnM6Ly8gVVJMcylcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqIGNvbnN0IGNhdCA9IG5ldyBGaWxlKFtdLCAnY2F0LnBuZycpXG4gKiBjb25zdCBraXR0eSA9IG5ldyBGaWxlKFtdLCAna2l0dHkucG5nJylcbiAqIGNvbnN0IGZvcm0gPSBlbmNvZGUoe1xuICogICBuYW1lOiAnaGVsbG8nXG4gKiAgIGltYWdlOiBjYXRcbiAqICAgcHJvcGVydGllczoge1xuICogICAgIGV4dHJhOiB7XG4gKiAgICAgICBpbWFnZToga2l0dHlcbiAqICAgICB9XG4gKiAgIH1cbiAqIH0pXG4gKiBbLi4uZm9ybS5lbnRyaWVzKCldIC8vPlxuICogLy8gW1xuICogLy8gICBbJ2ltYWdlJywgY2F0XSxcbiAqIC8vICAgWydwcm9wZXJ0aWVzLmV4dHJhLmltYWdlJywga2l0dHldLFxuICogLy8gICBbJ21ldGEnLCAne1wibmFtZVwiOlwiaGVsbG9cIixpbWFnZTpudWxsLFwicHJvcGVydGllc1wiOntcImV4dHJhXCI6e1wia2l0dHlcIjogbnVsbH19fSddXG4gKiAvLyBdXG4gKiBgYGBcbiAqXG4gKiBAdGVtcGxhdGUge1Rva2VuSW5wdXR9IFRcbiAqIEBwYXJhbSB7RW5jb2RlZEJsb2JCbG9iPFQ+fSBpbnB1dFxuICogQHJldHVybnMge0Zvcm1EYXRhfVxuICovXG5leHBvcnQgY29uc3QgZW5jb2RlID0gKGlucHV0KSA9PiB7XG4gIGNvbnN0IFttYXAsIG1ldGFdID0gbWFwVmFsdWVXaXRoKGlucHV0LCBpc0Jsb2IsIGVuY29kZUJsb2IsIG5ldyBNYXAoKSwgW10pXG4gIGNvbnN0IGZvcm0gPSBuZXcgRm9ybURhdGEoKVxuICBmb3IgKGNvbnN0IFtrLCB2XSBvZiBtYXAuZW50cmllcygpKSB7XG4gICAgZm9ybS5zZXQoaywgdilcbiAgfVxuICBmb3JtLnNldCgnbWV0YScsIEpTT04uc3RyaW5naWZ5KG1ldGEpKVxuICByZXR1cm4gZm9ybVxufVxuXG4vKipcbiAqIEBwYXJhbSB7TWFwPHN0cmluZywgQmxvYj59IGRhdGFcbiAqIEBwYXJhbSB7QmxvYn0gYmxvYlxuICogQHBhcmFtIHtQcm9wZXJ0eUtleVtdfSBwYXRoXG4gKiBAcmV0dXJucyB7W01hcDxzdHJpbmcsIEJsb2I+LCB2b2lkXX1cbiAqL1xuY29uc3QgZW5jb2RlQmxvYiA9IChkYXRhLCBibG9iLCBwYXRoKSA9PiB7XG4gIGRhdGEuc2V0KHBhdGguam9pbignLicpLCBibG9iKVxuICByZXR1cm4gW2RhdGEsIHVuZGVmaW5lZF1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gdmFsdWVcbiAqIEByZXR1cm5zIHt2YWx1ZSBpcyBCbG9ifVxuICovXG5jb25zdCBpc0Jsb2IgPSAodmFsdWUpID0+IHZhbHVlIGluc3RhbmNlb2YgQmxvYlxuXG4vKipcbiAqIEB0ZW1wbGF0ZSB7VG9rZW5JbnB1dH0gVFxuICogQHBhcmFtIHtFbmNvZGVkQmxvYkJsb2I8VD59IGlucHV0XG4gKi9cbmNvbnN0IG1hcFRva2VuSW5wdXRCbG9icyA9IChpbnB1dCkgPT4ge1xuICByZXR1cm4gbWFwVmFsdWVXaXRoKGlucHV0LCBpc0Jsb2IsIGVuY29kZUJsb2IsIG5ldyBNYXAoKSwgW10pXG59XG5cbi8qKlxuICogU3Vic3RpdHVlcyB2YWx1ZXMgaW4gdGhlIGdpdmVuIGBpbnB1dGAgdGhhdCBtYXRjaCBgcCh2YWx1ZSkgPT0gdHJ1ZWAgd2l0aFxuICogYGYodmFsdWUsIGNvbnRleHQsIHBhdGgpYCB3aGVyZSBgY29udGV4dGAgaXMgd2hhdGV2ZXIgeW91IHBhc3MgKHVzdWFsbHlcbiAqIGEgbXV0YWJsZSBzdGF0ZSkgYW5kIGBwYXRoYCBpcyBhIGFycmF5IG9mIGtleXMgLyBpbmRleGVzIHdoZXJlIHRoZSB2YWx1ZVxuICogd2FzIGVuY291bnRlcmVkLlxuICpcbiAqIEB0ZW1wbGF0ZSBULCBJLCBYLCBPLCBTdGF0ZVxuICogQHBhcmFtIHtpbXBvcnQoJy4vbGliL2ludGVyZmFjZS5qcycpLkVuY29kZWQ8VCwgW1tJLCBYXV0+fSBpbnB1dCAtIEFyYml0cmFyeSBpbnB1dC5cbiAqIEBwYXJhbSB7KGlucHV0OmFueSwgc3RhdGU6U3RhdGUsIHBhdGg6UHJvcGVydHlLZXlbXSkgPT4gaW5wdXQgaXMgWH0gcCAtIFByZWRpY2F0ZSBmdW5jdGlvbiB0byBkZXRlcm1pbmVcbiAqIHdoaWNoIHZhbHVlcyB0byBzd2FwLlxuICogQHBhcmFtIHsoc3RhdGU6U3RhdGUsIGlucHV0OlgsIHBhdGg6UHJvcGVydHlLZXlbXSkgPT4gW1N0YXRlLCBPXX0gZiAtIEZ1bmN0aW9uXG4gKiB0aGF0IHN3YXBzIG1hdGNoaW5nIHZhbHVlcy5cbiAqIEBwYXJhbSB7U3RhdGV9IHN0YXRlIC0gU29tZSBhZGRpdGlvbmFsIGNvbnRleHQgeW91IG5lZWQgaW4gdGhlIHByb2Nlc3MuXG4gKiBsaWtleSB5b3UnbGwgc3RhcnQgd2l0aCBgW11gLlxuICogQHJldHVybnMge2ltcG9ydCgnLi9saWIvaW50ZXJmYWNlLmpzJykuRW5jb2RlZDxULCBbW0ksIE9dXT59XG4gKi9cbmV4cG9ydCBjb25zdCBtYXBXaXRoID0gKGlucHV0LCBwLCBmLCBzdGF0ZSkgPT4ge1xuICBjb25zdCBbLCBvdXRwdXRdID0gbWFwVmFsdWVXaXRoKGlucHV0LCBwLCBmLCBzdGF0ZSwgW10pXG4gIHJldHVybiBvdXRwdXRcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVCwgSSwgWCwgTywgU3RhdGVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2xpYi9pbnRlcmZhY2UuanMnKS5FbmNvZGVkPFQsIFtbSSwgWF1dPn0gaW5wdXQgLSBBcmJpdHJhcnkgaW5wdXQuXG4gKiBAcGFyYW0geyhpbnB1dDphbnksIHN0YXRlOlN0YXRlLCBwYXRoOlByb3BlcnR5S2V5W10pID0+IGlucHV0IGlzIFh9IHAgLSBQcmVkaWNhdGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lXG4gKiB3aGljaCB2YWx1ZXMgdG8gc3dhcC5cbiAqIEBwYXJhbSB7KHN0YXRlOlN0YXRlLCBpbnB1dDpYLCBwYXRoOlByb3BlcnR5S2V5W10pID0+IFtTdGF0ZSwgT119IGYgLSBGdW5jdGlvblxuICogdGhhdCBzd2FwcyBtYXRjaGluZyB2YWx1ZXMuXG4gKiBAcGFyYW0ge1N0YXRlfSBzdGF0ZSAtIFNvbWUgYWRkaXRpb25hbCBjb250ZXh0IHlvdSBuZWVkIGluIHRoZSBwcm9jZXNzLlxuICogQHBhcmFtIHtQcm9wZXJ0eUtleVtdfSBwYXRoIC0gUGF0aCB3aGVyZSB0aGUgdmFsdWUgd2FzIGVuY291bnRlcmVkLiBNb3N0XG4gKiBsaWtleSB5b3UnbGwgc3RhcnQgd2l0aCBgW11gLlxuICogQHJldHVybnMge1tTdGF0ZSwgaW1wb3J0KCcuL2xpYi9pbnRlcmZhY2UuanMnKS5FbmNvZGVkPFQsIFtbSSwgT11dPl19XG4gKi9cbmNvbnN0IG1hcFZhbHVlV2l0aCA9IChpbnB1dCwgcCwgZiwgc3RhdGUsIHBhdGgpID0+XG4gIHAoaW5wdXQsIHN0YXRlLCBwYXRoKVxuICAgID8gZihzdGF0ZSwgaW5wdXQsIHBhdGgpXG4gICAgOiBBcnJheS5pc0FycmF5KGlucHV0KVxuICAgID8gbWFwQXJyYXlXaXRoKGlucHV0LCBwLCBmLCBzdGF0ZSwgcGF0aClcbiAgICA6IGlzT2JqZWN0KGlucHV0KVxuICAgID8gbWFwT2JqZWN0V2l0aChpbnB1dCwgcCwgZiwgc3RhdGUsIHBhdGgpXG4gICAgOiBbc3RhdGUsIC8qKiBAdHlwZSB7YW55fSAqLyAoaW5wdXQpXVxuXG4vKipcbiAqIEp1c3QgbGlrZSBgbWFwV2l0aGAgZXhjZXB0XG4gKlxuICogQHRlbXBsYXRlIFN0YXRlLCBULCBJLCBYLCBPXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9saWIvaW50ZXJmYWNlLmpzJykuRW5jb2RlZDxULCBbW0ksIFhdXT59IGlucHV0XG4gKiBAcGFyYW0geyhpbnB1dDphbnksIHN0YXRlOlN0YXRlLCBwYXRoOlByb3BlcnR5S2V5W10pID0+IGlucHV0IGlzIFh9IHBcbiAqIEBwYXJhbSB7KHN0YXRlOiBTdGF0ZSwgaW5wdXQ6WCwgcGF0aDpQcm9wZXJ0eUtleVtdKSA9PiBbU3RhdGUsIE9dfSBmXG4gKiBAcGFyYW0ge1N0YXRlfSBpbml0XG4gKiBAcGFyYW0ge1Byb3BlcnR5S2V5W119IHBhdGhcbiAqIEByZXR1cm5zIHtbU3RhdGUsIGltcG9ydCgnLi9saWIvaW50ZXJmYWNlLmpzJykuRW5jb2RlZDxULCBbW0ksIE9dXT5dfVxuICovXG5jb25zdCBtYXBPYmplY3RXaXRoID0gKGlucHV0LCBwLCBmLCBpbml0LCBwYXRoKSA9PiB7XG4gIGxldCBzdGF0ZSA9IGluaXRcbiAgY29uc3Qgb3V0cHV0ID1cbiAgICAvKiogQHR5cGUge2ltcG9ydCgnLi9saWIvaW50ZXJmYWNlLmpzJykuRW5jb2RlZDxULCBbW0ksIE9dXT59ICovICh7fSlcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoaW5wdXQpKSB7XG4gICAgY29uc3QgW25leHQsIG91dF0gPSBtYXBWYWx1ZVdpdGgodmFsdWUsIHAsIGYsIHN0YXRlLCBbLi4ucGF0aCwga2V5XSlcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgb3V0cHV0W2tleV0gPSBvdXRcbiAgICBzdGF0ZSA9IG5leHRcbiAgfVxuICByZXR1cm4gW3N0YXRlLCBvdXRwdXRdXG59XG5cbi8qKlxuICogSnVzdCBsaWtlIGBtYXBXaXRoYCBleGNlcHQgZm9yIEFycmF5cy5cbiAqXG4gKiBAdGVtcGxhdGUgSSwgWCwgTywgU3RhdGVcbiAqIEB0ZW1wbGF0ZSB7YW55W119IFRcbiAqIEBwYXJhbSB7VH0gaW5wdXRcbiAqIEBwYXJhbSB7KGlucHV0OmFueSwgc3RhdGU6U3RhdGUsIHBhdGg6UHJvcGVydHlLZXlbXSkgPT4gaW5wdXQgaXMgWH0gcFxuICogQHBhcmFtIHsoc3RhdGU6IFN0YXRlLCBpbnB1dDpYLCBwYXRoOlByb3BlcnR5S2V5W10pID0+IFtTdGF0ZSwgT119IGZcbiAqIEBwYXJhbSB7U3RhdGV9IGluaXRcbiAqIEBwYXJhbSB7UHJvcGVydHlLZXlbXX0gcGF0aFxuICogQHJldHVybnMge1tTdGF0ZSwgaW1wb3J0KCcuL2xpYi9pbnRlcmZhY2UuanMnKS5FbmNvZGVkPFQsIFtbSSwgT11dPl19XG4gKi9cbmNvbnN0IG1hcEFycmF5V2l0aCA9IChpbnB1dCwgcCwgZiwgaW5pdCwgcGF0aCkgPT4ge1xuICBjb25zdCBvdXRwdXQgPSAvKiogQHR5cGUge3Vua25vd25bXX0gKi8gKFtdKVxuXG4gIGxldCBzdGF0ZSA9IGluaXRcbiAgZm9yIChjb25zdCBbaW5kZXgsIGVsZW1lbnRdIG9mIGlucHV0LmVudHJpZXMoKSkge1xuICAgIGNvbnN0IFtuZXh0LCBvdXRdID0gbWFwVmFsdWVXaXRoKGVsZW1lbnQsIHAsIGYsIHN0YXRlLCBbLi4ucGF0aCwgaW5kZXhdKVxuICAgIG91dHB1dFtpbmRleF0gPSBvdXRcbiAgICBzdGF0ZSA9IG5leHRcbiAgfVxuXG4gIHJldHVybiBbXG4gICAgc3RhdGUsXG4gICAgLyoqIEB0eXBlIHtpbXBvcnQoJy4vbGliL2ludGVyZmFjZS5qcycpLkVuY29kZWQ8VCwgW1tJLCBPXV0+fSAqLyAob3V0cHV0KSxcbiAgXVxufVxuXG4vKipcbiAqIFNldHMgYSBnaXZlbiBgdmFsdWVgIGF0IHRoZSBnaXZlbiBgcGF0aGAgb24gYSBwYXNzZWQgYG9iamVjdGAuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiBjb25zdCBvYmogPSB7IGE6IHsgYjogeyBjOiAxIH19fVxuICogc2V0SW4ob2JqLCBbJ2EnLCAnYicsICdjJ10sIDUpXG4gKiBvYmouYS5iLmMgLy8+IDVcbiAqIGBgYFxuICpcbiAqIEB0ZW1wbGF0ZSBWXG4gKiBAcGFyYW0ge2FueX0gb2JqZWN0XG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXRoXG4gKiBAcGFyYW0ge1Z9IHZhbHVlXG4gKi9cbmNvbnN0IHNldEluID0gKG9iamVjdCwgcGF0aCwgdmFsdWUpID0+IHtcbiAgY29uc3QgbiA9IHBhdGgubGVuZ3RoIC0gMVxuICBsZXQgdGFyZ2V0ID0gb2JqZWN0XG4gIGZvciAobGV0IFtpbmRleCwga2V5XSBvZiBwYXRoLmVudHJpZXMoKSkge1xuICAgIGlmIChpbmRleCA9PT0gbikge1xuICAgICAgdGFyZ2V0W2tleV0gPSB2YWx1ZVxuICAgIH0gZWxzZSB7XG4gICAgICB0YXJnZXQgPSB0YXJnZXRba2V5XVxuICAgIH1cbiAgfVxufVxuIiwgImltcG9ydCB7XG4gIFB1YmxpY0tleSxcbiAgU3lzdGVtUHJvZ3JhbSxcbiAgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbixcbn0gZnJvbSAnQHNvbGFuYS93ZWIzLmpzJztcblxuaW1wb3J0IEJOIGZyb20gJ2JuLmpzJztcblxuaW1wb3J0IHtcbiAgY3JlYXRlQXBwcm92ZUluc3RydWN0aW9uLFxuICBjcmVhdGVBc3NvY2lhdGVkVG9rZW5BY2NvdW50SW5zdHJ1Y3Rpb24sXG4gIGNyZWF0ZUluaXRpYWxpemVNaW50SW5zdHJ1Y3Rpb24sXG4gIGNyZWF0ZU1pbnRUb0NoZWNrZWRJbnN0cnVjdGlvbixcbiAgZ2V0QXNzb2NpYXRlZFRva2VuQWRkcmVzc1N5bmMsXG4gIGdldE1pbmltdW1CYWxhbmNlRm9yUmVudEV4ZW1wdE1pbnQsXG4gIE1JTlRfU0laRSxcbiAgVE9LRU5fUFJPR1JBTV9JRCxcbn0gZnJvbSAnQHNvbGFuYS9zcGwtdG9rZW4nO1xuaW1wb3J0IHtcbiAgZGVidWdMb2csXG4gIEtleXBhaXJBY2NvdW50LFxuICBNaW50SW5zdHJ1Y3Rpb24sXG4gIFB1YmtleSxcbiAgUmVzdWx0LFxuICBTZWNyZXQsXG4gIFRyeSxcbn0gZnJvbSAnQHNvbGFuYS1zdWl0ZS9zaGFyZWQnO1xuXG5pbXBvcnQgeyBTdG9yYWdlIH0gZnJvbSAnaW50ZXJuYWwvc3RvcmFnZSc7XG5cbmltcG9ydCB7XG4gIENvbnZlcnQsXG4gIFBkYSxcbiAgUm95YWx0eSxcbiAgVXNlclNpZGVJbnB1dCxcbiAgVmFsaWRhdG9yLFxufSBmcm9tICdpbnRlcm5hbC9zaGFyZWQtbWV0YXBsZXgnO1xuXG5pbXBvcnQge1xuICBjcmVhdGVDcmVhdGVNYXN0ZXJFZGl0aW9uVjNJbnN0cnVjdGlvbixcbiAgY3JlYXRlQ3JlYXRlTWV0YWRhdGFBY2NvdW50VjNJbnN0cnVjdGlvbixcbiAgRGF0YVYyLFxufSBmcm9tICdAbWV0YXBsZXgtZm91bmRhdGlvbi9tcGwtdG9rZW4tbWV0YWRhdGEnO1xuaW1wb3J0IHsgTm9kZSB9IGZyb20gJ0Bzb2xhbmEtc3VpdGUvc2hhcmVkJztcbmNvbnN0IE5GVF9BTU9VTlQgPSAxO1xuZXhwb3J0IG5hbWVzcGFjZSBNZXRhcGxleCB7XG4gIGV4cG9ydCBjb25zdCBjcmVhdGVEZWxlYWdhdGVJbnN0cnVjdGlvbiA9IChcbiAgICBtaW50OiBQdWJsaWNLZXksXG4gICAgb3duZXI6IFB1YmxpY0tleSxcbiAgICBkZWxlZ2F0ZUF1dGhvcml0eTogUHVibGljS2V5LFxuICApOiBUcmFuc2FjdGlvbkluc3RydWN0aW9uID0+IHtcbiAgICBjb25zdCB0b2tlbkFjY291bnQgPSBnZXRBc3NvY2lhdGVkVG9rZW5BZGRyZXNzU3luYyhtaW50LCBvd25lcik7XG5cbiAgICByZXR1cm4gY3JlYXRlQXBwcm92ZUluc3RydWN0aW9uKFxuICAgICAgdG9rZW5BY2NvdW50LFxuICAgICAgZGVsZWdhdGVBdXRob3JpdHksXG4gICAgICBvd25lcixcbiAgICAgIE5GVF9BTU9VTlQsXG4gICAgKTtcbiAgfTtcblxuICBleHBvcnQgY29uc3QgY3JlYXRlTWludEluc3RydWN0aW9ucyA9IGFzeW5jIChcbiAgICBtaW50OiBQdWJsaWNLZXksXG4gICAgb3duZXI6IFB1YmxpY0tleSxcbiAgICBuZnRNZXRhZGF0YTogRGF0YVYyLFxuICAgIGZlZVBheWVyOiBQdWJsaWNLZXksXG4gICAgaXNNdXRhYmxlOiBib29sZWFuLFxuICApOiBQcm9taXNlPFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb25bXT4gPT4ge1xuICAgIGNvbnN0IGF0YSA9IGdldEFzc29jaWF0ZWRUb2tlbkFkZHJlc3NTeW5jKG1pbnQsIG93bmVyKTtcbiAgICBjb25zdCB0b2tlbk1ldGFkYXRhUHVia2V5ID0gUGRhLmdldE1ldGFkYXRhKG1pbnQudG9TdHJpbmcoKSk7XG4gICAgY29uc3QgbWFzdGVyRWRpdGlvblB1YmtleSA9IFBkYS5nZXRNYXN0ZXJFZGl0aW9uKG1pbnQudG9TdHJpbmcoKSk7XG4gICAgY29uc3QgY29ubmVjdGlvbiA9IE5vZGUuZ2V0Q29ubmVjdGlvbigpO1xuXG4gICAgY29uc3QgaW5zdDEgPSBTeXN0ZW1Qcm9ncmFtLmNyZWF0ZUFjY291bnQoe1xuICAgICAgZnJvbVB1YmtleTogZmVlUGF5ZXIsXG4gICAgICBuZXdBY2NvdW50UHVia2V5OiBtaW50LFxuICAgICAgbGFtcG9ydHM6IGF3YWl0IGdldE1pbmltdW1CYWxhbmNlRm9yUmVudEV4ZW1wdE1pbnQoY29ubmVjdGlvbiksXG4gICAgICBzcGFjZTogTUlOVF9TSVpFLFxuICAgICAgcHJvZ3JhbUlkOiBUT0tFTl9QUk9HUkFNX0lELFxuICAgIH0pO1xuXG4gICAgY29uc3QgaW5zdDIgPSBjcmVhdGVJbml0aWFsaXplTWludEluc3RydWN0aW9uKG1pbnQsIDAsIG93bmVyLCBvd25lcik7XG5cbiAgICBjb25zdCBpbnN0MyA9IGNyZWF0ZUFzc29jaWF0ZWRUb2tlbkFjY291bnRJbnN0cnVjdGlvbihcbiAgICAgIGZlZVBheWVyLFxuICAgICAgYXRhLFxuICAgICAgb3duZXIsXG4gICAgICBtaW50LFxuICAgICk7XG5cbiAgICBjb25zdCBpbnN0NCA9IGNyZWF0ZU1pbnRUb0NoZWNrZWRJbnN0cnVjdGlvbihtaW50LCBhdGEsIG93bmVyLCAxLCAwKTtcblxuICAgIGNvbnN0IGluc3Q1ID0gY3JlYXRlQ3JlYXRlTWV0YWRhdGFBY2NvdW50VjNJbnN0cnVjdGlvbihcbiAgICAgIHtcbiAgICAgICAgbWV0YWRhdGE6IHRva2VuTWV0YWRhdGFQdWJrZXksXG4gICAgICAgIG1pbnQsXG4gICAgICAgIG1pbnRBdXRob3JpdHk6IG93bmVyLFxuICAgICAgICBwYXllcjogZmVlUGF5ZXIsXG4gICAgICAgIHVwZGF0ZUF1dGhvcml0eTogb3duZXIsXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBjcmVhdGVNZXRhZGF0YUFjY291bnRBcmdzVjM6IHtcbiAgICAgICAgICBkYXRhOiBuZnRNZXRhZGF0YSxcbiAgICAgICAgICBpc011dGFibGUsXG4gICAgICAgICAgY29sbGVjdGlvbkRldGFpbHM6IHsgX19raW5kOiAnVjEnLCBzaXplOiBuZXcgQk4oMSkgfSxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgKTtcblxuICAgIGNvbnN0IGluc3Q2ID0gY3JlYXRlQ3JlYXRlTWFzdGVyRWRpdGlvblYzSW5zdHJ1Y3Rpb24oXG4gICAgICB7XG4gICAgICAgIGVkaXRpb246IG1hc3RlckVkaXRpb25QdWJrZXksXG4gICAgICAgIG1pbnQsXG4gICAgICAgIHVwZGF0ZUF1dGhvcml0eTogb3duZXIsXG4gICAgICAgIG1pbnRBdXRob3JpdHk6IG93bmVyLFxuICAgICAgICBwYXllcjogZmVlUGF5ZXIsXG4gICAgICAgIG1ldGFkYXRhOiB0b2tlbk1ldGFkYXRhUHVia2V5LFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgY3JlYXRlTWFzdGVyRWRpdGlvbkFyZ3M6IHtcbiAgICAgICAgICBtYXhTdXBwbHk6IDAsXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICk7XG4gICAgcmV0dXJuIFtpbnN0MSwgaW5zdDIsIGluc3QzLCBpbnN0NCwgaW5zdDUsIGluc3Q2XTtcbiAgfTtcblxuICAvKipcbiAgICogVXBsb2FkIGNvbnRlbnQgYW5kIE5GVCBtaW50XG4gICAqXG4gICAqIEBwYXJhbSB7UHVia2V5fSBvd25lciAgICAgICAgICAvLyBmaXJzdCBtaW50ZWQgb3duZXJcbiAgICogQHBhcmFtIHtTZWNyZXR9IHNpZ25lciAgICAgICAgIC8vIG93bmVyJ3MgU2VjcmV0XG4gICAqIEBwYXJhbSB7VXNlclNpZGVJbnB1dC5OZnRNZXRhZGF0YX0gaW5wdXRcbiAgICoge1xuICAgKiAgIG5hbWU6IHN0cmluZyAgICAgICAgICAgICAgIC8vIG5mdCBjb250ZW50IG5hbWVcbiAgICogICBzeW1ib2w6IHN0cmluZyAgICAgICAgICAgICAvLyBuZnQgdGlja2VyIHN5bWJvbFxuICAgKiAgIGZpbGVQYXRoOiBzdHJpbmcgfCBGaWxlICAgIC8vIG5mdCB0aWNrZXIgc3ltYm9sXG4gICAqICAgcm95YWx0eTogbnVtYmVyICAgICAgICAgICAgLy8gcm95YWx0eSBwZXJjZW50YWdlXG4gICAqICAgc3RvcmFnZVR5cGU6ICdhcndlYXZlJ3wnbmZ0U3RvcmFnZScgLy8gcm95YWx0eSBwZXJjZW50YWdlXG4gICAqICAgZGVzY3JpcHRpb24/OiBzdHJpbmcgICAgICAgLy8gbmZ0IGNvbnRlbnQgZGVzY3JpcHRpb25cbiAgICogICBleHRlcm5hbF91cmw/OiBzdHJpbmcgICAgICAvLyBsYW5kaW5nIHBhZ2UsIGhvbWUgcGFnZSB1cmksIHJlbGF0ZWQgdXJsXG4gICAqICAgYXR0cmlidXRlcz86IE1ldGFkYXRhQXR0cmlidXRlW10gICAgIC8vIGdhbWUgY2hhcmFjdGVyIHBhcmFtZXRlciwgcGVyc29uYWxpdHksIGNoYXJhY3RlcmlzdGljc1xuICAgKiAgIHByb3BlcnRpZXM/OiBNZXRhZGF0YVByb3BlcnRpZXM8VXJpPiAvLyBpbmNsdWRlIGZpbGUgbmFtZSwgdXJpLCBzdXBwb3J0ZWQgZmlsZSB0eXBlXG4gICAqICAgY29sbGVjdGlvbj86IFB1YmtleSAgICAgICAgICAgLy8gY29sbGVjdGlvbnMgb2YgZGlmZmVyZW50IGNvbG9ycywgc2hhcGVzLCBldGMuXG4gICAqICAgY3JlYXRvcnM/OiBJbnB1dENyZWF0b3JzW10gICAgLy8gb3RoZXIgY3JlYXRvcnMgdGhhbiBvd25lclxuICAgKiAgIHVzZXM/OiBVc2VzICAgICAgICAgICAgICAgICAgIC8vIHVzYWdlIGZlYXR1cmU6IGJ1cm4sIHNpbmdsZSwgbXVsdGlwbGVcbiAgICogICBpc011dGFibGU/OiBib29sZWFuICAgICAgICAgICAvLyBlbmFibGUgdXBkYXRlKClcbiAgICogICBvcHRpb25zPzogW2tleTogc3RyaW5nXT86IHVua25vd24gICAgICAgLy8gb3B0aW9uYWwgcGFyYW0sIFVzdWFsbHkgbm90IHVzZWQuXG4gICAqIH1cbiAgICogQHBhcmFtIHtTZWNyZXR9IGZlZVBheWVyPyAgICAgICAgIC8vIGZlZSBwYXllclxuICAgKiBAcGFyYW0ge1B1YmtleX0gZnJlZXplQXV0aG9yaXR5PyAgLy8gZnJlZXplIGF1dGhvcml0eVxuICAgKiBAcmV0dXJuIFByb21pc2U8UmVzdWx0PE1pbnRJbnN0cnVjdGlvbiwgRXJyb3I+PlxuICAgKi9cbiAgZXhwb3J0IGNvbnN0IG1pbnQgPSBhc3luYyAoXG4gICAgb3duZXI6IFB1YmtleSxcbiAgICBzaWduZXI6IFNlY3JldCxcbiAgICBpbnB1dDogVXNlclNpZGVJbnB1dC5OZnRNZXRhZGF0YSxcbiAgICBmZWVQYXllcj86IFNlY3JldCxcbiAgICBmcmVlemVBdXRob3JpdHk/OiBQdWJrZXksXG4gICk6IFByb21pc2U8UmVzdWx0PE1pbnRJbnN0cnVjdGlvbiwgRXJyb3I+PiA9PiB7XG4gICAgcmV0dXJuIFRyeShhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB2YWxpZCA9IFZhbGlkYXRvci5jaGVja0FsbDxVc2VyU2lkZUlucHV0Lk5mdE1ldGFkYXRhPihpbnB1dCk7XG4gICAgICBpZiAodmFsaWQuaXNFcnIpIHtcbiAgICAgICAgdGhyb3cgdmFsaWQuZXJyb3I7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHBheWVyID0gZmVlUGF5ZXIgPyBmZWVQYXllciA6IHNpZ25lcjtcblxuICAgICAgLy8tLS0gcG9ycGVydGllcywgVXBsb2FkIGNvbnRlbnQgLS0tXG4gICAgICBsZXQgcHJvcGVydGllcztcbiAgICAgIGlmIChpbnB1dC5wcm9wZXJ0aWVzICYmIGlucHV0LnN0b3JhZ2VUeXBlKSB7XG4gICAgICAgIHByb3BlcnRpZXMgPSBhd2FpdCBDb252ZXJ0LlByb3BlcnRpZXMuaW50b0luZnJhU2lkZShcbiAgICAgICAgICBpbnB1dC5wcm9wZXJ0aWVzLFxuICAgICAgICAgIFN0b3JhZ2UudXBsb2FkQ29udGVudCxcbiAgICAgICAgICBpbnB1dC5zdG9yYWdlVHlwZSxcbiAgICAgICAgICBwYXllcixcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSBpZiAoaW5wdXQucHJvcGVydGllcyAmJiAhaW5wdXQuc3RvcmFnZVR5cGUpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ011c3Qgc2V0IHN0b3JhZ2VUeXBlIGlmIHdpbGwgdXNlIHByb3BlcnRpZXMnKTtcbiAgICAgIH1cblxuICAgICAgaW5wdXQgPSB7XG4gICAgICAgIC4uLmlucHV0LFxuICAgICAgICBwcm9wZXJ0aWVzLFxuICAgICAgfTtcbiAgICAgIC8vLS0tIHBvcnBlcnRpZXMsIFVwbG9hZCBjb250ZW50IC0tLVxuXG4gICAgICBjb25zdCBzZWxsZXJGZWVCYXNpc1BvaW50cyA9IFJveWFsdHkuY29udmVydChpbnB1dC5yb3lhbHR5KTtcbiAgICAgIGNvbnN0IG5mdFN0b3JhZ2VNZXRhZGF0YSA9IFN0b3JhZ2UudG9Db252ZXJ0T2ZmY2hhaW5kYXRhKFxuICAgICAgICBpbnB1dCxcbiAgICAgICAgc2VsbGVyRmVlQmFzaXNQb2ludHMsXG4gICAgICApO1xuXG4gICAgICAvLyBjcmVhdGVkIGF0IGJ5IHVuaXggdGltZXN0YW1wXG4gICAgICBjb25zdCBjcmVhdGVkQXQgPSBNYXRoLmZsb29yKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC8gMTAwMCk7XG4gICAgICBuZnRTdG9yYWdlTWV0YWRhdGEuY3JlYXRlZF9hdCA9IGNyZWF0ZWRBdDtcblxuICAgICAgbGV0IHVyaSE6IHN0cmluZztcbiAgICAgIGlmIChpbnB1dC5maWxlUGF0aCAmJiBpbnB1dC5zdG9yYWdlVHlwZSkge1xuICAgICAgICBjb25zdCB1cGxvYWRlZCA9IGF3YWl0IFN0b3JhZ2UudXBsb2FkTWV0YUFuZENvbnRlbnQoXG4gICAgICAgICAgbmZ0U3RvcmFnZU1ldGFkYXRhLFxuICAgICAgICAgIGlucHV0LmZpbGVQYXRoLFxuICAgICAgICAgIGlucHV0LnN0b3JhZ2VUeXBlLFxuICAgICAgICAgIHBheWVyLFxuICAgICAgICApO1xuICAgICAgICBkZWJ1Z0xvZygnIyB1cGxvYWQgY29udGVudCB1cmw6ICcsIHVwbG9hZGVkKTtcbiAgICAgICAgaWYgKHVwbG9hZGVkLmlzRXJyKSB7XG4gICAgICAgICAgdGhyb3cgdXBsb2FkZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdXJpID0gdXBsb2FkZWQudmFsdWU7XG4gICAgICB9IGVsc2UgaWYgKGlucHV0LnVyaSkge1xuICAgICAgICB1cmkgPSBpbnB1dC51cmk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBFcnJvcihgTXVzdCBzZXQgJ3N0b3JhZ2VUeXBlICsgZmlsZVBhdGgnIG9yICd1cmknYCk7XG4gICAgICB9XG5cbiAgICAgIGxldCBkYXRhdjIgPSBDb252ZXJ0Lk5mdE1ldGFkYXRhLmludG9JbmZyYVNpZGUoXG4gICAgICAgIGlucHV0LFxuICAgICAgICB1cmksXG4gICAgICAgIHNlbGxlckZlZUJhc2lzUG9pbnRzLFxuICAgICAgKTtcblxuICAgICAgLy8tLS0gY29sbGVjdGlvbiAtLS1cbiAgICAgIGxldCBjb2xsZWN0aW9uO1xuICAgICAgaWYgKGlucHV0LmNvbGxlY3Rpb24gJiYgaW5wdXQuY29sbGVjdGlvbikge1xuICAgICAgICBjb2xsZWN0aW9uID0gQ29udmVydC5Db2xsZWN0aW9uLmludG9JbmZyYVNpZGUoaW5wdXQuY29sbGVjdGlvbik7XG4gICAgICAgIGRhdGF2MiA9IHsgLi4uZGF0YXYyLCBjb2xsZWN0aW9uIH07XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGlzTXV0YWJsZSA9IGlucHV0LmlzTXV0YWJsZSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGlucHV0LmlzTXV0YWJsZTtcblxuICAgICAgZGVidWdMb2coJyMgaW5wdXQ6ICcsIGlucHV0KTtcbiAgICAgIGRlYnVnTG9nKCcjIHNlbGxlckZlZUJhc2lzUG9pbnRzOiAnLCBzZWxsZXJGZWVCYXNpc1BvaW50cyk7XG4gICAgICBkZWJ1Z0xvZygnIyBkYXRhdjI6ICcsIGRhdGF2Mik7XG5cbiAgICAgIGNvbnN0IG1pbnQgPSBLZXlwYWlyQWNjb3VudC5jcmVhdGUoKTtcblxuICAgICAgY29uc3QgaW5zdHMgPSBhd2FpdCBjcmVhdGVNaW50SW5zdHJ1Y3Rpb25zKFxuICAgICAgICBtaW50LnRvUHVibGljS2V5KCksXG4gICAgICAgIG93bmVyLnRvUHVibGljS2V5KCksXG4gICAgICAgIGRhdGF2MixcbiAgICAgICAgcGF5ZXIudG9LZXlwYWlyKCkucHVibGljS2V5LFxuICAgICAgICBpc011dGFibGUsXG4gICAgICApO1xuXG4gICAgICAvLyBmcmVlemVBdXRob3JpdHlcbiAgICAgIGlmIChmcmVlemVBdXRob3JpdHkpIHtcbiAgICAgICAgaW5zdHMucHVzaChcbiAgICAgICAgICBjcmVhdGVEZWxlYWdhdGVJbnN0cnVjdGlvbihcbiAgICAgICAgICAgIG1pbnQudG9QdWJsaWNLZXkoKSxcbiAgICAgICAgICAgIG93bmVyLnRvUHVibGljS2V5KCksXG4gICAgICAgICAgICBmcmVlemVBdXRob3JpdHkudG9QdWJsaWNLZXkoKSxcbiAgICAgICAgICApLFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IE1pbnRJbnN0cnVjdGlvbihcbiAgICAgICAgaW5zdHMsXG4gICAgICAgIFtzaWduZXIudG9LZXlwYWlyKCksIG1pbnQudG9LZXlwYWlyKCldLFxuICAgICAgICBwYXllci50b0tleXBhaXIoKSxcbiAgICAgICAgbWludC5wdWJrZXksXG4gICAgICApO1xuICAgIH0pO1xuICB9O1xufVxuIiwgImltcG9ydCB7XG4gIFBhcnRpYWxTaWduSW5zdHJ1Y3Rpb24sXG4gIFB1YmtleSxcbiAgUmVzdWx0LFxuICBTZWNyZXQsXG59IGZyb20gJ0Bzb2xhbmEtc3VpdGUvc2hhcmVkJztcbmltcG9ydCB7IFNwbFRva2VuIH0gZnJvbSAnQHNvbGFuYS1zdWl0ZS9jb3JlJztcblxuZXhwb3J0IG5hbWVzcGFjZSBNZXRhcGxleCB7XG4gIGNvbnN0IE5GVF9BTU9VTlQgPSAxO1xuICBjb25zdCBORlRfREVDSU1BTFMgPSAwO1xuXG4gIGV4cG9ydCBjb25zdCBmZWVQYXllclBhcnRpYWxTaWduVHJhbnNmZXJOZnQgPSBhc3luYyAoXG4gICAgbWludDogUHVia2V5LFxuICAgIG93bmVyOiBQdWJrZXksXG4gICAgZGVzdDogUHVia2V5LFxuICAgIHNpZ25lcnM6IFNlY3JldFtdLFxuICAgIGZlZVBheWVyOiBQdWJrZXlcbiAgKTogUHJvbWlzZTxSZXN1bHQ8UGFydGlhbFNpZ25JbnN0cnVjdGlvbiwgRXJyb3I+PiA9PiB7XG4gICAgcmV0dXJuIFNwbFRva2VuLmZlZVBheWVyUGFydGlhbFNpZ25UcmFuc2ZlcihcbiAgICAgIG1pbnQsXG4gICAgICBvd25lcixcbiAgICAgIGRlc3QsXG4gICAgICBzaWduZXJzLFxuICAgICAgTkZUX0FNT1VOVCxcbiAgICAgIE5GVF9ERUNJTUFMUyxcbiAgICAgIGZlZVBheWVyXG4gICAgKTtcbiAgfTtcbn1cbiIsICJpbXBvcnQge1xuICBJbnN0cnVjdGlvbixcbiAgS2V5cGFpckFjY291bnQsXG4gIFB1YmtleSxcbiAgUmVzdWx0LFxuICBTZWNyZXQsXG4gIFRyeSxcbn0gZnJvbSAnQHNvbGFuYS1zdWl0ZS9zaGFyZWQnO1xuaW1wb3J0IHsgUGRhIH0gZnJvbSAnaW50ZXJuYWwvc2hhcmVkLW1ldGFwbGV4JztcbmltcG9ydCB7IGdldEFzc29jaWF0ZWRUb2tlbkFkZHJlc3NTeW5jIH0gZnJvbSAnQHNvbGFuYS9zcGwtdG9rZW4nO1xuaW1wb3J0IHsgY3JlYXRlVGhhd0RlbGVnYXRlZEFjY291bnRJbnN0cnVjdGlvbiB9IGZyb20gJ0BtZXRhcGxleC1mb3VuZGF0aW9uL21wbC10b2tlbi1tZXRhZGF0YSc7XG5cbmV4cG9ydCBuYW1lc3BhY2UgTWV0YXBsZXgge1xuICAvKipcbiAgICogVGhhd2luZyBhIHRhcmdldCBORlRcbiAgICogaXQgc2hvdWxkIHNldCB0byBmcmVlemVBdXRob3JpdHkgd2hlbiBtaW50KClcbiAgICpcbiAgICogQHBhcmFtIHtQdWJrZXl9IG1pbnQgICAgICAgICAgICAgLy8gbWludCBhZGRyZXNzXG4gICAqIEBwYXJhbSB7UHVia2V5fSBvd25lciAgICAgICAgICAgIC8vIGN1cnJlbnQgb3duZXJcbiAgICogQHBhcmFtIHtTZWNyZXR9IGZyZWV6ZUF1dGhvcml0eSAgLy8gc2V0dGVkIGZyZWV6ZSBhdXRob3JpdHkgb2YgbmZ0XG4gICAqIEBwYXJhbSB7U2VjcmV0fSBmZWVQYXllcj8gICAgICAgLy8gZmVlIHBheWVyXG4gICAqL1xuICBleHBvcnQgY29uc3QgdGhhdyA9IChcbiAgICBtaW50OiBQdWJrZXksXG4gICAgb3duZXI6IFB1YmtleSxcbiAgICBmcmVlemVBdXRob3JpdHk6IFNlY3JldCxcbiAgICBmZWVQYXllcj86IFNlY3JldFxuICApOiBSZXN1bHQ8SW5zdHJ1Y3Rpb24sIEVycm9yPiA9PiB7XG4gICAgY29uc3QgcGF5ZXIgPSBmZWVQYXllciA/IGZlZVBheWVyIDogZnJlZXplQXV0aG9yaXR5O1xuICAgIHJldHVybiBUcnkoKCkgPT4ge1xuICAgICAgY29uc3QgdG9rZW5BY2NvdW50ID0gZ2V0QXNzb2NpYXRlZFRva2VuQWRkcmVzc1N5bmMoXG4gICAgICAgIG1pbnQudG9QdWJsaWNLZXkoKSxcbiAgICAgICAgb3duZXIudG9QdWJsaWNLZXkoKVxuICAgICAgKTtcbiAgICAgIGNvbnN0IGVkaXRpb25BZGRyZXNzID0gUGRhLmdldE1hc3RlckVkaXRpb24obWludCk7XG5cbiAgICAgIGNvbnN0IGluc3QgPSBjcmVhdGVUaGF3RGVsZWdhdGVkQWNjb3VudEluc3RydWN0aW9uKHtcbiAgICAgICAgZGVsZWdhdGU6IG5ldyBLZXlwYWlyQWNjb3VudCh7IHNlY3JldDogZnJlZXplQXV0aG9yaXR5IH0pLnRvUHVibGljS2V5KCksXG4gICAgICAgIHRva2VuQWNjb3VudDogdG9rZW5BY2NvdW50LFxuICAgICAgICBlZGl0aW9uOiBlZGl0aW9uQWRkcmVzcyxcbiAgICAgICAgbWludDogbWludC50b1B1YmxpY0tleSgpLFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gbmV3IEluc3RydWN0aW9uKFxuICAgICAgICBbaW5zdF0sXG4gICAgICAgIFtmcmVlemVBdXRob3JpdHkudG9LZXlwYWlyKCldLFxuICAgICAgICBwYXllci50b0tleXBhaXIoKVxuICAgICAgKTtcbiAgICB9KTtcbiAgfTtcbn1cbiIsICJpbXBvcnQgeyBJbnN0cnVjdGlvbiwgUHVia2V5LCBSZXN1bHQsIFNlY3JldCB9IGZyb20gJ0Bzb2xhbmEtc3VpdGUvc2hhcmVkJztcbmltcG9ydCB7IFNwbFRva2VuIH0gZnJvbSAnQHNvbGFuYS1zdWl0ZS9jb3JlJztcblxuZXhwb3J0IG5hbWVzcGFjZSBNZXRhcGxleCB7XG4gIGNvbnN0IE5GVF9BTU9VTlQgPSAxO1xuICBjb25zdCBORlRfREVDSU1BTFMgPSAwO1xuXG4gIGV4cG9ydCBjb25zdCB0cmFuc2ZlciA9IGFzeW5jIChcbiAgICBtaW50OiBQdWJrZXksXG4gICAgb3duZXI6IFB1YmtleSxcbiAgICBkZXN0OiBQdWJrZXksXG4gICAgc2lnbmVyczogU2VjcmV0W10sXG4gICAgZmVlUGF5ZXI/OiBTZWNyZXRcbiAgKTogUHJvbWlzZTxSZXN1bHQ8SW5zdHJ1Y3Rpb24sIEVycm9yPj4gPT4ge1xuICAgIHJldHVybiBTcGxUb2tlbi50cmFuc2ZlcihcbiAgICAgIG1pbnQsXG4gICAgICBvd25lcixcbiAgICAgIGRlc3QsXG4gICAgICBzaWduZXJzLFxuICAgICAgTkZUX0FNT1VOVCxcbiAgICAgIE5GVF9ERUNJTUFMUyxcbiAgICAgIGZlZVBheWVyXG4gICAgKTtcbiAgfTtcbn1cbiIsICJpbXBvcnQgeyBNZXRhcGxleCBhcyBCdXJuIH0gZnJvbSAnLi9idXJuJztcbmltcG9ydCB7IE1ldGFwbGV4IGFzIEZpbmQgfSBmcm9tICcuL2ZpbmQnO1xuaW1wb3J0IHsgTWV0YXBsZXggYXMgRnJlZXplIH0gZnJvbSAnLi9mcmVlemUnO1xuaW1wb3J0IHsgTWV0YXBsZXggYXMgRmVlUGF5ZXIgfSBmcm9tICcuL2ZlZS1wYXllci1wYXJ0aWFsLXNpZ24tbWludCc7XG5pbXBvcnQgeyBNZXRhcGxleCBhcyBGZWVQYXllclRyYW5zZmVyIH0gZnJvbSAnLi9mZWUtcGF5ZXItcGFydGlhbC1zaWduLXRyYW5zZmVyJztcbmltcG9ydCB7IE1ldGFwbGV4IGFzIE1pbnQgfSBmcm9tICcuL21pbnQnO1xuaW1wb3J0IHsgTWV0YXBsZXggYXMgVGhhdyB9IGZyb20gJy4vdGhhdyc7XG5pbXBvcnQgeyBNZXRhcGxleCBhcyBUcmFuc2ZlciB9IGZyb20gJy4vdHJhbnNmZXInO1xuXG5leHBvcnQgY29uc3QgTWV0YXBsZXggPSBPYmplY3QuYXNzaWduKFxuICB7fSxcbiAgQnVybixcbiAgRmluZCxcbiAgRnJlZXplLFxuICBGZWVQYXllcixcbiAgRmVlUGF5ZXJUcmFuc2ZlcixcbiAgTWludCxcbiAgVGhhdyxcbiAgVHJhbnNmZXIsXG4pO1xuIl0s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LE1BQU07QUFDakIsVUFBRSxDQUFDLEtBQUs7QUFFUixVQUFFLENBQUMsS0FBSyxFQUFFLENBQUMsSUFBSSxFQUFFLENBQUM7QUFDbEIsVUFBRSxDQUFDLEtBQUssRUFBRSxDQUFDLE1BQU07QUFDakIsVUFBRSxDQUFDLEtBQUs7QUFFUixVQUFFLENBQUMsS0FBSyxFQUFFLENBQUMsSUFBSSxFQUFFLENBQUM7QUFDbEIsVUFBRSxDQUFDLEtBQUssRUFBRSxDQUFDLE1BQU07QUFDakIsVUFBRSxDQUFDLEtBQUs7QUFFUixVQUFFLENBQUMsS0FBSyxFQUFFLENBQUMsSUFBSSxFQUFFLENBQUM7QUFDbEIsVUFBRSxDQUFDLEtBQUssRUFBRSxDQUFDLE1BQU07QUFDakIsVUFBRSxDQUFDLEtBQUs7QUFFUixVQUFFLENBQUMsS0FBSyxFQUFFLENBQUMsSUFBSSxFQUFFLENBQUM7QUFDbEIsVUFBRSxDQUFDLEtBQUssRUFBRSxDQUFDLE1BQU07QUFDakIsVUFBRSxDQUFDLEtBQUs7QUFFUixVQUFFLENBQUMsS0FBSyxFQUFFLENBQUMsSUFBSSxFQUFFLENBQUM7QUFDbEIsVUFBRSxDQUFDLEtBQUssRUFBRSxDQUFDLE1BQU07QUFDakIsVUFBRSxDQUFDLEtBQUs7QUFFUixVQUFFLENBQUMsS0FBTSxFQUFFLENBQUMsSUFBSSxFQUFFLENBQUMsSUFBTSxFQUFFLENBQUMsSUFBSSxFQUFFLENBQUMsSUFBTSxFQUFFLENBQUMsSUFBSSxFQUFFLENBQUMsSUFBTSxFQUFFLENBQUMsSUFBSSxFQUFFLENBQUM7QUFDbkUsVUFBRSxDQUFDLEtBQUs7QUFFUixlQUFPLENBQUUsRUFBRSxDQUFDLEtBQUssS0FBTSxFQUFFLENBQUMsR0FBSSxFQUFFLENBQUMsS0FBSyxLQUFNLEVBQUUsQ0FBQyxDQUFDO0FBQUEsTUFDcEQ7QUFFQSxlQUFTLFNBQVMsR0FBRyxHQUFHO0FBT3BCLGFBQUs7QUFFTCxZQUFJLE1BQU0sSUFBSTtBQUNWLGlCQUFPLENBQUMsRUFBRSxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUM7QUFBQSxRQUN0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QUFBLFVBRTFELEtBQUs7QUFDRCxpQkFBSyxRQUFRLElBQUksY0FBYyxDQUFDLEdBQUcsTUFBTSxJQUFJLEVBQUUsQ0FBQyxHQUFHLEVBQUUsQ0FBQztBQUFBLFVBRTFELEtBQUs7QUFDRCxpQkFBSyxRQUFRLElBQUksY0FBYyxDQUFDLEdBQUcsTUFBTSxJQUFJLEVBQUUsQ0FBQyxHQUFHLEVBQUUsQ0FBQztBQUFBLFVBRTFELEtBQUs7QUFDRCxpQkFBSyxRQUFRLElBQUksY0FBYyxDQUFDLEdBQUcsTUFBTSxJQUFJLEVBQUUsQ0FBQyxHQUFHLEVBQUUsQ0FBQztBQUFBLFVBRTFELEtBQUs7QUFDRCxpQkFBSyxRQUFRLElBQUksY0FBYyxDQUFDLEdBQUcsTUFBTSxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUFBLFVBRXhELEtBQUs7QUFDRCxpQkFBSyxRQUFRLElBQUksQ0FBQyxHQUFHLE1BQU0sSUFBSSxDQUFDLENBQUMsQ0FBQztBQUNsQyxpQkFBSyxhQUFhLElBQUksRUFBRTtBQUN4QixpQkFBSyxTQUFTLElBQUksRUFBRTtBQUNwQixpQkFBSyxhQUFhLElBQUksRUFBRTtBQUN4QixpQkFBSyxRQUFRLElBQUksRUFBRTtBQUFBLFVBRXZCLEtBQUs7QUFDRCxpQkFBSyxRQUFRLElBQUksY0FBYyxDQUFDLEdBQUcsTUFBTSxJQUFJLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztBQUFBLFVBRXpELEtBQUs7QUFDRCxpQkFBSyxRQUFRLElBQUksY0FBYyxDQUFDLEdBQUcsTUFBTSxJQUFJLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztBQUFBLFVBRXpELEtBQUs7QUFDRCxpQkFBSyxRQUFRLElBQUksY0FBYyxDQUFDLEdBQUcsTUFBTSxJQUFJLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztBQUFBLFVBRXpELEtBQUs7QUFDRCxpQkFBSyxRQUFRLElBQUksY0FBYyxDQUFDLEdBQUcsTUFBTSxJQUFJLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztBQUFBLFVBRXpELEtBQUs7QUFDRCxpQkFB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RUFDUDtBQUNBLFNBQU8sS0FBSyxLQUFLO0FBQ2YsVUFBTSxRQUFRLElBQUksSUFBSSxNQUFNO0FBQzVCLFdBQU87QUFBQSxFQUNUO0FBQ0EsUUFBTSxNQUFNLElBQUk7QUFDaEIsU0FBT0E7QUFDVDtBQUNBLFNBQVMsSUFBSSxHQUFHO0FBQ2QsTUFBSSxJQUFJLE1BQU0sR0FBRztBQUNmO0FBQUEsRUFDRjtBQUNBLFNBQU8sS0FBSyxPQUFPLE1BQU0sQ0FBQyxJQUFJLEtBQUssQ0FBQztBQUN0QztBQUNBLFNBQVMsTUFBTSxHQUFHO0FBQ2hCLE1BQUksSUFBSTtBQUNSLE1BQUksS0FBSyxVQUFVO0FBQ2pCLFFBQUksS0FBSyxNQUFNLElBQUksUUFBUTtBQUMzQixRQUFJO0FBQUEsRUFDTjtBQUNBLE1BQUksS0FBSyxLQUFLLElBQUk7QUFDaEIsV0FBTztBQUNQLFNBQUs7QUFBQSxFQUNQO0FBQ0EsTUFBSSxLQUFLLEtBQUssR0FBRztBQUNmLFdBQU87QUFDUCxTQUFLO0FBQUEsRUFDUDtBQUNBLFNBQU8sSUFBSSxRQUFRLENBQUM7QUFDdEI7QUFDQSxJQUFNLFVBQVU7QUFBQSxFQUNkO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtB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QSxFQUNQLE1BQU07QUFBQSxFQUNOLFNBQVM7QUFBQSxFQUNULE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLFNBQVM7QUFBQSxFQUNULFNBQVM7QUFBQSxFQUNULE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLFNBQVM7QUFBQSxFQUNULE1BQU07QUFBQSxFQUNOLE9BQU87QUFBQSxFQUNQLFFBQVE7QUFBQSxFQUNSLE9BQU87QUFBQSxFQUNQLFNBQVM7QUFBQSxFQUNULFVBQVU7QUFBQSxFQUNWLFVBQVU7QUFBQSxFQUNWLE9BQU87QUFBQSxFQUNQLFdBQVc7QUFBQSxFQUNYLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLFFBQVE7QUFBQSxFQUNSLGVBQWU7QUFBQSxFQUNmLE9BQU87QUFBQSxFQUNQLFFBQVE7QUFBQSxFQUNSLE1BQU07QUFBQSxFQUNOLE1BQU07QUFBQSxFQUNOLE1BQU07QUFBQSxFQUNOLFVBQVU7QUFBQSxFQUNWLFFBQVE7QUFBQSxFQUNSLFNBQVM7QUFBQSxFQUNULFlBQVk7QUFBQSxFQUNaLFNBQVM7QUFBQSxFQUNULFFBQVE7QUFBQSxFQUNSLFFBQVE7QUFBQSxFQUNSLFFBQVE7QUFBQSxFQUNSLFFBQVE7QUFBQSxFQUNSLE9BQU87QUFBQSxFQUNQLFFBQVE7QUFBQSxFQUNSLFFBQVE7QUFBQSxFQUNSLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLE1BQU07QUFBQSxFQUNOLE1BQU07QUFBQSxFQUNOLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLE1BQU07QUFBQSxFQUNOLFFBQVE7QUFBQSxFQUNSLFNBQVM7QUFBQSxFQUNULE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLFFBQVE7QUFBQSxFQUNSLE9BQU87QUFBQSxFQUNQLFVBQVU7QUFBQSxFQUNWLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLFVBQVU7QUFBQSxFQUNWLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLFNBQVM7QUFBQSxFQUNULFVBQVU7QUFBQSxFQUNWLFdBQVc7QUFBQSxFQUNYLFVBQVU7QUFBQSxFQUNWLFVBQVU7QUFBQSxFQUNWLFFBQVE7QUFBQSxFQUNSLFFBQVE7QUFBQSxFQUNSLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLE1BQU07QUFBQSxFQUNOLE1BQU07QUFBQSxFQUNOLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLFdBQVc7QUFBQSxFQUNYLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLE1BQU07QUFBQSxFQUNOLE9BQU87QUFBQSxFQUNQLE1BQU07QUFBQSxFQUNOLFNBQVM7QUFBQSxFQUNULE9BQU87QUFBQSxFQUNQLFdBQVc7QUFBQSxFQUNYLFFBQVE7QUFBQSxFQUNSLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLE1BQU07QUFBQSxFQUNOLE9BQU87QUFBQSxFQUNQLE1BQU07QUFBQSxFQUNOLFFBQVE7QUFBQSxFQUNSLE9BQU87QUFBQSxFQUNQLFFBQVE7QUFBQSxFQUNSLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLFFBQVE7QUFBQSxFQUNSLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLFVBQVU7QUFBQSxFQUNWLFdBQVc7QUFBQSxFQUNYLFVBQVU7QUFBQSxFQUNWLFVBQVU7QUFBQSxFQUNWLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLFNBQVM7QUFBQSxFQUNULE9BQU87QUFBQSxFQUNQLFFBQVE7QUFBQSxFQUNSLE1BQU07QUFBQSxFQUNOLE9BQU87QUFBQSxFQUNQLFFBQVE7QUFBQSxFQUNSLFNBQVM7QUFBQSxFQUNULE9BQU87QUFBQSxFQUNQLFFBQVE7QUFBQSxFQUNSLFFBQVE7QUFBQSxFQUNSLFdBQVc7QUFBQSxFQUNYLE9BQU87QUFBQSxFQUNQLGFBQWE7QUFBQSxFQUNiLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLFFBQVE7QUFBQSxFQUNSLFFBQVE7QUFBQSxFQUNSLFFBQVE7QUFBQSxFQUNSLE9BQU87QUFBQSxFQUNQLFVBQVU7QUFBQSxFQUNWLE1BQU07QUFBQSxFQUNOLFFBQVE7QUFBQSxFQUNSLFFBQVE7QUFBQSxFQUNSLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLFFBQVE7QUFBQSxFQUNSLFlBQVk7QUFBQSxFQUNaLFFBQVE7QUFBQSxFQUNSLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLFFBQVE7QUFBQSxFQUNSLFNBQVM7QUFBQSxFQUNULE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLFFBQVE7QUFBQSxFQUNSLFFBQVE7QUFBQSxFQUNSLFFBQVE7QUFBQSxFQUNSLFNBQVM7QUFBQSxFQUNULFFBQVE7QUFBQSxFQUNSLE9BQU87QUFBQSxFQUNQLFFBQVE7QUFBQSxFQUNSLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLFFBQVE7QUFBQSxFQUNSLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLE1BQU07QUFBQSxFQUNOLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLFFBQVE7QUFBQSxFQUNSLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLFFBQVE7QUFBQSxFQUNSLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLFFBQVE7QUFBQSxFQUNSLFFBQVE7QUFBQSxFQUNSLE9BQU87QUFBQSxFQUNQLFFBQVE7QUFBQSxFQUNSLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLFFBQVE7QUFBQSxFQUNSLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLFFBQVE7QUFBQSxFQUNSLE1BQU07QUFBQSxFQUNOLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLFFBQVE7QUFBQSxFQUNSLFNBQVM7QUFBQSxFQUNULE9BQU87QUFBQSxFQUNQLFFBQVE7QUFBQSxFQUNSLFFBQVE7QUFBQSxFQUNSLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLFFBQVE7QUFBQSxFQUNSLE9BQU87QUFBQSxFQUNQLFFBQVE7QUFBQSxFQUNSLE1BQU07QUFBQSxFQUNOLE9BQU87QUFBQSxFQUNQLFFBQVE7QUFBQSxFQUNSLFNBQVM7QUFBQSxFQUNULFFBQVE7QUFBQSxFQUNSLFNBQVM7QUFBQSxFQUNULFFBQVE7QUFBQSxFQUNSLFFBQVE7QUFBQSxFQUNSLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLFFBQVE7QUFBQSxFQUNSLFFBQVE7QUFBQSxFQUNSLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLFFBQVE7QUFBQSxFQUNSLFFBQVE7QUFBQSxFQUNSLE9BQU87QUFBQSxFQUNQLFFBQVE7QUFBQSxFQUNSLFFBQVE7QUFBQSxFQUNSLFFBQVE7QUFBQSxFQUNSLE9BQU87QUFBQSxFQUNQLFFBQVE7QUFBQSxFQUNSLE9BQU87QUFBQSxFQUNQLFFBQVE7QUFBQSxFQUNSLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLFFBQVE7QUFBQSxFQUNSLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLFFBQVE7QUFBQSxFQUNSLE9BQU87QUFBQSxFQUNQLFFBQVE7QUFBQSxFQUNSLE9BQU87QUFBQSxFQUNQLDRCQUE0QjtBQUFBLEVBQzVCLFNBQVM7QUFBQSxFQUNULFNBQVM7QUFBQSxFQUNULFNBQVM7QUFBQSxFQUNULFNBQVM7QUFBQSxFQUNULE9BQU87QUFBQSxFQUNQLFFBQVE7QUFBQSxFQUNSLE9BQU87QUFBQSxFQUNQLFFBQVE7QUFBQSxFQUNSLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLFFBQVE7QUFBQSxFQUNSLE9BQU87QUFBQSxFQUNQLFFBQVE7QUFBQSxFQUNSLFFBQVE7QUFBQSxFQUNSLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLFFBQVE7QUFBQSxFQUNSLFNBQVM7QUFBQSxFQUNULE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLFFBQVE7QUFBQSxFQUNSLFFBQVE7QUFBQSxFQUNSLFNBQVM7QUFBQSxFQUNULFFBQVE7QUFBQSxFQUNSLFNBQVM7QUFBQSxFQUNULE9BQU87QUFBQSxFQUNQLFFBQVE7QUFBQSxFQUNSLFlBQVk7QUFBQSxFQUNaLFlBQVk7QUFBQSxFQUNaLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLFVBQVU7QUFBQSxFQUNWLGFBQWE7QUFBQSxFQUNiLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLFFBQVE7QUFBQSxFQUNSLE9BQU87QUFBQSxFQUNQLFNBQVM7QUFBQSxFQUNULFFBQVE7QUFBQSxFQUNSLE9BQU87QUFBQSxFQUNQLFFBQVE7QUFBQSxFQUNSLFlBQVk7QUFBQSxFQUNaLE1BQU07QUFBQSxFQUNOLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLE1BQU07QUFBQSxFQUNOLE9BQU87QUFBQSxFQUNQLFFBQVE7QUFBQSxFQUNSLFFBQVE7QUFBQSxFQUNSLE9BQU87QUFBQSxFQUNQLFFBQVE7QUFBQSxFQUNSLE9BQU87QUFBQSxFQUNQLE1BQU07QUFBQSxFQUNOLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLFFBQVE7QUFBQSxFQUNSLE9BQU87QUFBQSxFQUNQLFFBQVE7QUFBQSxFQUNSLFFBQVE7QUFBQSxFQUNSLE9BQU87QUFBQSxFQUNQLFFBQVE7QUFBQSxFQUNSLFVBQVU7QUFBQSxFQUNWLFFBQVE7QUFBQSxFQUNSLE9BQU87QUFBQSxFQUNQLEtBQUs7QUFBQSxFQUNMLE1BQU07QUFBQSxFQUNOLFFBQVE7QUFBQSxFQUNSLE9BQU87QUFBQSxFQUNQLE1BQU07QUFBQSxFQUNOLE1BQU07QUFBQSxFQUNOLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLFFBQVE7QUFBQSxFQUNSLFFBQVE7QUFBQSxFQUNSLFNBQVM7QUFBQSxFQUNULE9BQU87QUFBQSxFQUNQLFFBQVE7QUFBQSxFQUNSLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLFFBQVE7QUFBQSxFQUNSLFFBQVE7QUFBQSxFQUNSLFFBQVE7QUFBQSxFQUNSLE9BQU87QUFBQSxFQUNQLFFBQVE7QUFBQSxFQUNSLFFBQVE7QUFBQSxFQUNSLE9BQU87QUFBQSxFQUNQLFFBQVE7QUFBQSxFQUNSLE1BQU07QUFBQSxFQUNOLE9BQU87QUFBQSxFQUNQLFFBQVE7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Q0FBQyxFQUFFLFlBQVk7QUFBQSxRQUN0RTtBQUFBLFFBQ0EsU0FBUztBQUFBLFFBQ1QsTUFBTSxLQUFLLFlBQVk7QUFBQSxNQUN6QixDQUFDO0FBQ0QsYUFBTyxJQUFJO0FBQUEsUUFDVCxDQUFDLElBQUk7QUFBQSxRQUNMLENBQUMsZ0JBQWdCLFVBQVUsQ0FBQztBQUFBLFFBQzVCLE1BQU0sVUFBVTtBQUFBLE1BQ2xCO0FBQUEsSUFDRixDQUFDO0FBQUEsRUFDSDtBQUFBLEdBcENlQSwwQkFBQTs7O0FDWGpCLElBQUFDLGVBQXlCO0FBRWxCLElBQVVDO0FBQUEsQ0FBVixDQUFVQSxlQUFWO0FBQ0wsUUFBTUMsY0FBYTtBQUNuQixRQUFNLGVBQWU7QUFFZCxFQUFNRCxXQUFBLFdBQVcsQ0FDdEIsTUFDQSxPQUNBLE1BQ0EsU0FDQSxhQUN3QztBQUN4QyxXQUFPLHNCQUFTO0FBQUEsTUFDZDtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0FDO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxJQUNGO0FBQUEsRUFDRjtBQUFBLEdBcEJlRCwwQkFBQTs7O0FDTVYsSUFBTUUsWUFBVyxPQUFPO0FBQUEsRUFDN0IsQ0FBQztBQUFBLEVBQ0Q7QUFBQSxFQUNBQTtBQUFBLEVBQ0FBO0FBQUEsRUFDQUE7QUFBQSxFQUNBQTtBQUFBLEVBQ0FBO0FBQUEsRUFDQUE7QUFBQSxFQUNBQTtBQUNGOyIsCiAgIm5hbWVzIjogWyJleHBvcnRzIiwgIm1vZHVsZSIsICJzZWxmIiwgImV4cG9ydHMiLCAib3JpZ2luYWwiLCAicmVxdWlyZV9yZXRyeSIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJBYm9ydEVycm9yIiwgInBSZXRyeSIsICJlcnJvciIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJlbmNvZGUiLCAiTVNCIiwgIlJFU1QiLCAiTVNCQUxMIiwgIklOVCIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJyZWFkIiwgIk1TQiIsICJSRVNUIiwgImJ1ZiIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJOMSIsICJOMiIsICJOMyIsICJONCIsICJONSIsICJONiIsICJONyIsICJOOCIsICJOOSIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJsYXN0IiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImlzSXRlcmFibGUiLCAicGlwZSIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJiYXRjaCIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJiYXRjaCIsICJwYXJhbGxlbEJhdGNoIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgIm5hbWUiLCAiZ2xvYmFsVGhpcyIsICJjbG9uZSIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJ1bmRlZmluZWQiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAiY29kZSIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJwYXJhbXMiLCAib2Zmc2V0IiwgImV4cG9ydHMiLCAiYmFzZTY0IiwgImxlbmd0aCIsICJzdHJpbmciLCAiZW5jb2RlIiwgImJ1ZmZlciIsICJpIiwgImRlY29kZSIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJidWYiLCAiZXhwb3J0cyIsICJzdHJpbmciLCAiYnVmZmVyIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImFsbG9jIiwgInNsaWNlIiwgInNpemUiLCAiYnVmIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImZyb20iLCAibGVuZ3RoIiwgImV4cG9ydHMiLCAiaXNPYmplY3QiLCAiQnVmZmVyIiwgInNyYyIsICJuYW1lIiwgInRvU3RyaW5nIiwgImkiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAiYmFzZTY0IiwgIm5vb3AiLCAiY3JlYXRlIiwgImFsbG9jIiwgImJ1ZiIsICJ3cml0ZUJ5dGVzIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImJ1ZiIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJidWZmZXIiLCAiY3JlYXRlX2FycmF5IiwgImNyZWF0ZSIsICJidWYiLCAibGVuZ3RoIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImJ1ZmZlciIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJzZWxmIiwgImVyciIsICJleHBvcnRzIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImV4cG9ydHMiLCAicmVxdWlyZV9taW5pbWFsIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImFsbCIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJCdWZmZXIiLCAiQnVmZmVyTGlzdCIsICJidWYiLCAiZ2V0IiwgInNsaWNlIiwgImNvcHkiLCAidG9TdHJpbmciLCAibSIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJidWYiLCAiZXhwb3J0cyIsICJidWZmZXIiLCAibGVuZ3RoIiwgImxhc3QiLCAiYWxsb2MiLCAiYnVmIiwgIlR5cGUiLCAibW9kdWxlIiwgIm5hbWUiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAiZnMiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAiY3JlYXRlIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImxhc3QiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAiYmFzZSIsICJuYW1lIiwgImVuY29kZSIsICJsZW5ndGgiLCAiaSIsICJqIiwgImRlY29kZSIsICJzdHJpbmciLCAiYnVmZmVyIiwgInNyYyIsICJfYnJycF9fbXVsdGlmb3JtYXRzX3Njb3BlX2Jhc2VYIiwgImV4cG9ydHMiLCAiZW1wdHkiLCAidG9IZXgiLCAiZnJvbUhleCIsICJlcXVhbHMiLCAiY29lcmNlIiwgImlzQmluYXJ5IiwgImZyb21TdHJpbmciLCAidG9TdHJpbmciLCAiZXhwb3J0cyIsICJFbmNvZGVyIiwgIm5hbWUiLCAiYnl0ZXMiLCAiRGVjb2RlciIsICJkZWNvZGVyIiwgIm9yIiwgIkNvbXBvc2VkRGVjb2RlciIsICJDb2RlYyIsICJmcm9tIiwgImVuY29kZSIsICJkZWNvZGUiLCAiYmFzZVgiLCAiYWxwaGFiZXQiLCAic3RyaW5nIiwgImJ1ZmZlciIsICJyZmM0NjQ4IiwgImV4cG9ydHMiLCAiYmFzZSIsICJpZGVudGl0eSIsICJidWYiLCAiZXhwb3J0cyIsICJiYXNlIiwgImJhc2UyIiwgImV4cG9ydHMiLCAiYmFzZSIsICJiYXNlOCIsICJleHBvcnRzIiwgImJhc2UiLCAiYmFzZTEwIiwgImV4cG9ydHMiLCAiYmFzZSIsICJiYXNlMTYiLCAiYmFzZTE2dXBwZXIiLCAiZXhwb3J0cyIsICJiYXNlIiwgImJhc2UzMiIsICJiYXNlMzJ1cHBlciIsICJiYXNlMzJwYWQiLCAiYmFzZTMycGFkdXBwZXIiLCAiYmFzZTMyaGV4IiwgImJhc2UzMmhleHVwcGVyIiwgImJhc2UzMmhleHBhZCIsICJiYXNlMzJoZXhwYWR1cHBlciIsICJiYXNlMzJ6IiwgImV4cG9ydHMiLCAiYmFzZSIsICJiYXNlMzYiLCAiYmFzZTM2dXBwZXIiLCAiZXhwb3J0cyIsICJiYXNlIiwgImJhc2U1OGJ0YyIsICJiYXNlNThmbGlja3IiLCAicmVxdWlyZV9iYXNlNjQiLCAiZXhwb3J0cyIsICJiYXNlIiwgImJhc2U2NCIsICJiYXNlNjRwYWQiLCAiYmFzZTY0dXJsIiwgImJhc2U2NHVybHBhZCIsICJleHBvcnRzIiwgImJhc2UiLCAiYWxwaGFiZXQiLCAiYWxwaGFiZXRCeXRlc1RvQ2hhcnMiLCAiYWxwaGFiZXRDaGFyc1RvQnl0ZXMiLCAiZW5jb2RlIiwgImRlY29kZSIsICJiYXNlMjU2ZW1vamkiLCAicmVxdWlyZV92YXJpbnQiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAiZW5jb2RlXzEiLCAiZW5jb2RlIiwgIk1TQiIsICJSRVNUIiwgIk1TQkFMTCIsICJJTlQiLCAiZGVjb2RlIiwgInJlYWQiLCAiTVNCJDEiLCAiUkVTVCQxIiwgImJ1ZiIsICJOMSIsICJOMiIsICJOMyIsICJONCIsICJONSIsICJONiIsICJONyIsICJOOCIsICJOOSIsICJsZW5ndGgiLCAidmFyaW50IiwgIl9icnJwX3ZhcmludCIsICJyZXF1aXJlX3ZhcmludCIsICJleHBvcnRzIiwgImRlY29kZSIsICJjb2RlIiwgImVuY29kZVRvIiwgImVuY29kaW5nTGVuZ3RoIiwgImV4cG9ydHMiLCAidmFyaW50IiwgImNyZWF0ZSIsICJjb2RlIiwgImRpZ2VzdCIsICJieXRlcyIsICJEaWdlc3QiLCAiZGVjb2RlIiwgImVxdWFscyIsICJleHBvcnRzIiwgImRpZ2VzdCIsICJmcm9tIiwgIm5hbWUiLCAiY29kZSIsICJlbmNvZGUiLCAiSGFzaGVyIiwgImV4cG9ydHMiLCAiY3J5cHRvIiwgInNoYTI1NiIsICJzaGE1MTIiLCAicmVxdWlyZV9pZGVudGl0eSIsICJleHBvcnRzIiwgImNvZGUiLCAibmFtZSIsICJlbmNvZGUiLCAiZGlnZXN0IiwgImlkZW50aXR5IiwgImV4cG9ydHMiLCAibmFtZSIsICJjb2RlIiwgImVuY29kZSIsICJkZWNvZGUiLCAiZXhwb3J0cyIsICJ0ZXh0RW5jb2RlciIsICJ0ZXh0RGVjb2RlciIsICJuYW1lIiwgImNvZGUiLCAiZW5jb2RlIiwgImRlY29kZSIsICJleHBvcnRzIiwgInZhcmludCIsICJkaWdlc3QiLCAiYmFzZTMyIiwgIkNJRCIsICJ2ZXJzaW9uIiwgImNvZGUiLCAiYnl0ZXMiLCAiaGlkZGVuIiwgInJlYWRvbmx5IiwgIkRBR19QQl9DT0RFIiwgIlNIQV8yNTZfQ09ERSIsICJiYXNlIiwgInRvU3RyaW5nVjAiLCAidG9TdHJpbmdWMSIsICJkZXByZWNhdGUiLCAiSVNfQ0lEX0RFUFJFQ0FUSU9OIiwgImNpZFN5bWJvbCIsICJlbmNvZGVDSUQiLCAibGVuZ3RoIiwgInBhcnNlQ0lEdG9CeXRlcyIsICJkZWNvZGVyIiwgImNpZCIsICJyZXF1aXJlX3NyYyIsICJleHBvcnRzIiwgInZhcmludCIsICJkaWdlc3QiLCAiZXhwb3J0cyIsICJpZGVudGl0eSIsICJiYXNlMiIsICJiYXNlOCIsICJiYXNlMTAiLCAiYmFzZTE2IiwgImJhc2UzMiIsICJiYXNlMzYiLCAiYmFzZTY0IiwgImJhc2UyNTZlbW9qaSIsICJkaWdlc3QiLCAidmFyaW50IiwgImJhc2VzIiwgImhhc2hlcyIsICJleHBvcnRzIiwgImFzVWludDhBcnJheSIsICJidWYiLCAiZXhwb3J0cyIsICJhbGxvYyIsICJhbGxvY1Vuc2FmZSIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJhbGxvYyIsICJjcmVhdGVDb2RlYyIsICJuYW1lIiwgImVuY29kZSIsICJkZWNvZGUiLCAic3RyaW5nIiwgImJ1ZiIsICJkZWNvZGVyIiwgImVuY29kZXIiLCAiYXNjaWkiLCAiQkFTRVMiLCAiZXhwb3J0cyIsICJiYXNlcyIsICJmcm9tU3RyaW5nIiwgInN0cmluZyIsICJiYXNlIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgIkJ1Y2tldCIsICJtYXAiLCAicmVkdWNlIiwgImFjYyIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJsZW5ndGgiLCAiZXhwb3J0cyIsICJhbGxvYyIsICJjb25jYXQiLCAibGVuZ3RoIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImJ1ZmZlciIsICJyZXF1aXJlX3NyYyIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJCdWNrZXQiLCAiY3JlYXRlSEFNVCIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJibG9iVG9JdCIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJtYXAiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAiZHJhaW4iLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAiZmlsdGVyIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgInRha2UiLCAidGhyb3R0bGVkUXVldWUiLCAiX2EiLCAibW9kdWxlIiwgImV4cG9ydHMiLCAiZGF0YVVyaVRvQnVmZmVyIiwgImJhc2U2NCIsICJidWZmZXIiLCAibW9kdWxlIiwgIm5vb3AiLCAibmFtZSIsICJfYSIsICJzcmMiLCAiYnVmZmVyIiwgImxlbmd0aCIsICJzbGljZSIsICJzdHJlYW1CcmFuZENoZWNrRXhjZXB0aW9uIiwgImRlZmF1bHRDb250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbiIsICJET01FeGNlcHRpb24iLCAiZmx1c2giLCAidHJhbnNmb3JtIiwgInJlYWRhYmxlSGlnaFdhdGVyTWFyayIsICJTaW1wbGVRdWV1ZSIsICJTeW1ib2wiLCAiUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyIiwgIlJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvckltcGwiLCAiUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdCIsICJSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyIiwgIlJlYWRhYmxlU3RyZWFtQllPQlJlYWRlciIsICJXcml0YWJsZVN0cmVhbSIsICJXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIiLCAiV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlciIsICJSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyIiwgIlJlYWRhYmxlU3RyZWFtIiwgIkJ5dGVMZW5ndGhRdWV1aW5nU3RyYXRlZ3kiLCAiQ291bnRRdWV1aW5nU3RyYXRlZ3kiLCAiVHJhbnNmb3JtU3RyZWFtIiwgIlRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImlzT2JqZWN0IiwgInR5cGVzIiwgIkV2ZW50VGFyZ2V0IiwgImRlZmluZUV2ZW50QXR0cmlidXRlIiwgIkFib3J0Q29udHJvbGxlciIsICJzcmNfZXhwb3J0cyIsICJNZXRhcGxleCIsICJNZXRhcGxleCIsICJORlRfQU1PVU5UIiwgImltcG9ydF9zaGFyZWQiLCAiQ29udmVydCIsICJDb2xsZWN0aW9uIiwgIkNyZWF0b3JzIiwgIlVzZXMiLCAiVG9rZW5NZXRhZGF0YSIsICJOZnRNZXRhZGF0YSIsICJjb252ZXJ0VGltZXN0YW1wVG9EYXRlVGltZSIsICJQcm9wZXJ0aWVzIiwgIl9fYXN5bmMiLCAiX19zcHJlYWRQcm9wcyIsICJfX3NwcmVhZFZhbHVlcyIsICJVc2VyU2lkZUlucHV0IiwgIlRva2VuU3RhbmRhcmQiLCAiX1NoYXJlZCIsICJVc2VNZXRob2QiLCAiUGRhIiwgIlJveWFsdHkiLCAiVmFsaWRhdG9yIiwgIk1lc3NhZ2UiLCAibmFtZSIsICJpbXBvcnRfY29yZSIsICJNZXRhcGxleCIsICJpbXBvcnRfc2hhcmVkIiwgImltcG9ydF9tcGxfdG9rZW5fbWV0YWRhdGEiLCAiTWV0YXBsZXgiLCAiaW1wb3J0X3NoYXJlZCIsICJpbXBvcnRfd2ViMyIsICJpbXBvcnRfc2hhcmVkIiwgImltcG9ydF9qcyIsICJpbXBvcnRfdmFyaW50IiwgImJ1ZiIsICJkZWNvZGUiLCAiY29kZSIsICJjb2RlIiwgImRpZ2VzdCIsICJkZWNvZGUiLCAiZXF1YWxzIiwgIm5hbWUiLCAiZW5jb2RlIiwgImxlbmd0aCIsICJpIiwgImoiLCAiZGVjb2RlIiwgInN0cmluZyIsICJidWZmZXIiLCAibmFtZSIsICJkZWNvZGVyIiwgImVuY29kZSIsICJkZWNvZGUiLCAiYWxwaGFiZXQiLCAic3RyaW5nIiwgImJ1ZmZlciIsICJ2ZXJzaW9uIiwgImNvZGUiLCAiZGlnZXN0IiwgImVxdWFscyIsICJiYXNlIiwgImRlY29kZSIsICJsZW5ndGgiLCAiZGVjb2RlciIsICJjaWQiLCAibmFtZSIsICJpc0J1ZmZlciIsICJidWYiLCAidG9TdHJpbmciLCAiZnJvbVN0cmluZyIsICJzdHJpbmciLCAibGVuZ3RoIiwgImlzQnVmZmVyIiwgInN0cmluZyIsICJsZW5ndGgiLCAiYnVmIiwgImJ1ZiIsICJlbmNvZGVkU2l6ZSIsICJidWYiLCAiZW5jb2RlZFNpemUiLCAiY29tcGFyZVRva2VucyIsICJsZW5ndGgiLCAiYnVmIiwgImZyb21TdHJpbmciLCAiZW5jb2RlZFNpemUiLCAiY29tcGFyZVRva2VucyIsICJ0b1Rva2VuIiwgImxlbmd0aCIsICJ0b1N0cmluZyIsICJ0b1Rva2VuIiwgImxlbmd0aCIsICJidWYiLCAiZW5jb2RlZFNpemUiLCAidG9Ub2tlbiIsICJsZW5ndGgiLCAiYnVmIiwgImVuY29kZWRTaXplIiwgImJ1ZiIsICJlbmNvZGVkU2l6ZSIsICJidWYiLCAiZW5jb2RlZFNpemUiLCAidWk4YSIsICJsZW5ndGgiLCAiYnVmIiwgImVuY29kZXIiLCAiZW5jb2RlIiwgImRlY29kZXIiLCAiZGVjb2RlIiwgImVuY29kZSIsICJkZWNvZGUiLCAidmFyaW50IiwgImxlbmd0aCIsICJkZWNvZGUiLCAiYnl0ZXMiLCAibXVsdGloYXNoIiwgInZlcnNpb24iLCAicmVhZCIsICJ2ZXJzaW9uIiwgImRlY29kZXIiLCAiZnMiLCAiQ2FyUmVhZGVyIiwgInJlYWQiLCAidmVyc2lvbiIsICJkZWNvZGVyIiwgInZlcnNpb24iLCAiZGVjb2RlciIsICJpbXBvcnRfZnMiLCAiaW1wb3J0X3V0aWwiLCAiaW1wb3J0X3ZhcmludCIsICJlbmNvZGUiLCAidmFyaW50IiwgImNyZWF0ZSIsICJkcmFpbmVyIiwgImVuY29kZXIiLCAiY3JlYXRlIiwgImZzcmVhZCIsICJmcyIsICJDYXJXcml0ZXIiLCAicmVhZCIsICJmcm9tIiwgIm5hbWUiLCAiY29kZSIsICJlbmNvZGUiLCAiZGlnZXN0IiwgInJlYWRvbmx5IiwgImJhc2UiLCAiZW5jb2RlIiwgImRlY29kZSIsICJlbmNvZGUiLCAiZW5jb2RlIiwgImRlY29kZSIsICJjb2RlIiwgImRlY29kZSIsICJlbmNvZGUiLCAibmFtZSIsICJDSURfQ0JPUl9UQUciLCAiY2lkRW5jb2RlciIsICJ1bmRlZmluZWRFbmNvZGVyIiwgIm51bWJlckVuY29kZXIiLCAiZW5jb2RlT3B0aW9ucyIsICJjaWREZWNvZGVyIiwgImRlY29kZU9wdGlvbnMiLCAibmFtZSIsICJjb2RlIiwgImVuY29kZSIsICJkZWNvZGUiLCAiY29kZSIsICJkZWNvZGUiLCAiZW5jb2RlIiwgIm5hbWUiLCAidGV4dERlY29kZXIiLCAibGlua3MiLCAidGV4dEVuY29kZXIiLCAic2l6ZSIsICJiYXNlIiwgInRleHRFbmNvZGVyIiwgImxpbmtzIiwgIm5hbWUiLCAibmFtZSIsICJjb2RlIiwgImVuY29kZSIsICJkZWNvZGUiLCAiZGVjb2RlciIsICJDYXJXcml0ZXIiLCAiY2lkIiwgIkNhclJlYWRlciIsICJidWZmZXIiLCAiaW1wb3J0X2l0X3BhcmFsbGVsX2JhdGNoIiwgImltcG9ydF9pbmRleCIsICJtZXJnZU9wdGlvbnMiLCAiZnJvbSIsICJjcnlwdG8iLCAiZnJvbSIsICJtdXIiLCAiYnVmIiwgIiRwcm90b2J1ZiIsICJEYXRhIiwgImVuY29kZSIsICJkZWNvZGUiLCAiVW5peFRpbWUiLCAiTWV0YWRhdGEiLCAiZXJyY29kZSIsICJidWZmZXIiLCAiYnVmZmVyIiwgImVuY29kZSIsICJpbXBvcnRfZXJyX2NvZGUiLCAicmVkdWNlIiwgImFsbCIsICJyZWR1Y2UiLCAiYmF0Y2giLCAiaW1wb3J0X2l0X2JhdGNoIiwgInJlZHVjZSIsICJiYXRjaCIsICJidWZmZXIiLCAiZW5jb2RlIiwgImJ1ZmZlckltcG9ydGVyIiwgInBhcmFsbGVsQmF0Y2giLCAiYnVmZmVyIiwgImVuY29kZSIsICJsaW5rcyIsICJkYWdCdWlsZGVyIiwgImVyckNvZGUiLCAiaW1wb3J0X2Vycl9jb2RlIiwgImltcG9ydF9lcnJfY29kZSIsICJlcnJjb2RlIiwgIkJ1ZmZlckxpc3QiLCAiYnVmIiwgImltcG9ydF9CdWZmZXJMaXN0IiwgIkJ1ZmZlckxpc3QiLCAiYnVmZmVyIiwgImltcG9ydF9lcnJfY29kZSIsICJidWYiLCAiZW5jb2RlIiwgImRlY29kZSIsICJpZGVudGl0eV9leHBvcnRzIiwgImlkZW50aXR5IiwgImNvZGUiLCAibmFtZSIsICJlbmNvZGUiLCAiaWRlbnRpdHkiLCAidGV4dEVuY29kZXIiLCAidGV4dERlY29kZXIiLCAiaWRlbnRpdHlfZXhwb3J0cyIsICJidWYiLCAibmFtZSIsICJlbmNvZGUiLCAiZGVjb2RlIiwgImJ1ZiIsICJkZWNvZGVyIiwgImVuY29kZXIiLCAic3RyaW5nIiwgImZyb21TdHJpbmciLCAic3RyaW5nIiwgImJhc2UiLCAiZXJyQ29kZSIsICJmcm9tU3RyaW5nIiwgImVyckNvZGUiLCAibmFtZSIsICJkaXJfZGVmYXVsdCIsICJkaXJfZGVmYXVsdCIsICJuYW1lIiwgImxpbmtzIiwgImJ1ZmZlciIsICJlbmNvZGUiLCAiZGlyX2RlZmF1bHQiLCAibmFtZSIsICJsaW5rcyIsICJkaXIiLCAiaXRlciIsICJtb3JlIiwgInRlbXAiLCAiZXJyb3IiLCAic2l6ZSIsICJidWZmZXIiLCAiZW5jb2RlIiwgInRyZWUiLCAibGFzdCIsICJkaXJfZGVmYXVsdCIsICJpdGVyIiwgIm1vcmUiLCAidGVtcCIsICJlcnJvciIsICJkYWdCdWlsZGVyIiwgInRyZWVCdWlsZGVyIiwgInBhcmFsbGVsQmF0Y2giLCAiaW1wb3J0X2Vycl9jb2RlIiwgImltcG9ydF9pdF9hbGwiLCAiYmxvYlRvSXQiLCAiYnJvd3NlclN0cmVhbVRvSXQiLCAiaXRQZWVrYWJsZSIsICJhbGwiLCAibWFwIiwgImVyckNvZGUiLCAiZnJvbVN0cmluZyIsICJpbXBvcnRfZXJyX2NvZGUiLCAiaW1wb3J0X2Jyb3dzZXJfcmVhZGFibGVzdHJlYW1fdG9faXQiLCAiaW1wb3J0X2l0X3BlZWthYmxlIiwgIm5vcm1hbGlzZUNvbnRlbnQiLCAiZXJyQ29kZSIsICJicm93c2VyU3RyZWFtVG9JdCIsICJpdFBlZWthYmxlIiwgImltcG9ydF9lcnJfY29kZSIsICJpbXBvcnRfYnJvd3Nlcl9yZWFkYWJsZXN0cmVhbV90b19pdCIsICJpbXBvcnRfaXRfcGVla2FibGUiLCAiaW1wb3J0X2l0X21hcCIsICJub3JtYWxpc2VDb250ZW50IiwgImVyckNvZGUiLCAiYnJvd3NlclN0cmVhbVRvSXQiLCAiaXRQZWVrYWJsZSIsICJtYXAiLCAidmFsdWUiLCAidG9GaWxlT2JqZWN0IiwgIm5vcm1hbGlzZUlucHV0IiwgImlzQnl0ZXMiLCAiaXNCbG9iIiwgIm5vcm1hbGlzZUlucHV0IiwgImltcG9ydF9lcnJfY29kZSIsICJlcnJDb2RlIiwgImltcG9ydF9pdF9hbGwiLCAiYWxsIiwgImRyYWluIiwgImZpbHRlciIsICJpdCIsICJ0YWtlIiwgImxhc3QiLCAicGlwZSIsICJDYXJXcml0ZXIiLCAiaW1wb3J0X2h0dHAiLCAiaW1wb3J0X2ZzIiwgImltcG9ydF9zdHJlYW0iLCAiaW1wb3J0X3V0aWwiLCAiRW5jb2RlciIsICJEZWNvZGVyIiwgIlJlYWRhYmxlU3RyZWFtIiwgIlJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlciIsICJSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIiLCAiUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdCIsICJSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyIiwgIlJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIiLCAiVHJhbnNmb3JtU3RyZWFtIiwgIlRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyIiwgIldyaXRhYmxlU3RyZWFtIiwgIldyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlciIsICJXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyIiwgIkJ5dGVMZW5ndGhRdWV1aW5nU3RyYXRlZ3kiLCAiQ291bnRRdWV1aW5nU3RyYXRlZ3kiLCAic3RyZWFtcyIsICJFbmNvZGVyIiwgImJ1ZmZlciIsICJkZWNvZGVyIiwgIkRlY29kZXIiLCAiQmxvYiIsICJSZWFkYWJsZVN0cmVhbSIsICJCbG9iIiwgIkJsb2IiLCAibmFtZSIsICJGaWxlIiwgIm5hbWUiLCAicGFuaWMiLCAiaXNCbG9iIiwgIkZpbGUiLCAiRm9ybURhdGEiLCAiaW1wb3J0X2NyeXB0byIsICJjb2VyY2UiLCAibmFtZSIsICJ0b2tlbiIsICJmZWVkQ2h1bmsiLCAiX2EiLCAiaXRlciIsICJtb3JlIiwgInRlbXAiLCAiZXJyb3IiLCAiaW1wb3J0X3N0cmVhbSIsICJpc0Jsb2IiLCAiU3RyZWFtIiwgImlzQWJvcnRTaWduYWwiLCAiaXNSZWFkYWJsZVN0cmVhbSIsICJpc0l0ZXJhYmxlIiwgIm5hbWUiLCAiaXNCbG9iIiwgImVuY29kZXIiLCAibGVuZ3RoIiwgIkZvcm1EYXRhIiwgImNvbnRlbnRUeXBlIiwgIkZpbGUiLCAiaW1wb3J0X3V0aWwiLCAiZW5jb2RlIiwgImRlY29kZSIsICJTdHJlYW0iLCAiZW5jb2RlIiwgImZyb21CeXRlcyIsICJpc0Jsb2IiLCAiaXNSZWFkYWJsZVN0cmVhbSIsICJidWZmZXIiLCAiYnVmIiwgIkJsb2IiLCAiZGVjb2RlIiwgImVycm9yIiwgIlJlYWRhYmxlU3RyZWFtIiwgInB1bXAiLCAiaW1wb3J0X3V0aWwiLCAiaHR0cCIsICJuYW1lIiwgImlzSXRlcmFibGUiLCAiY29kZSIsICJJTlRFUk5BTFMiLCAiUmVzcG9uc2UiLCAiSU5URVJOQUxTIiwgImlzQWJvcnRTaWduYWwiLCAiQWJvcnRDb250cm9sbGVyUG9seWZpbGwiLCAiZm9ybWF0VXJsIiwgImltcG9ydF9zdHJlYW0iLCAiU3RyZWFtIiwgImRhdGFVcmlUb0J1ZmZlciIsICJyZXNwb25zZSIsICJSZXNwb25zZSIsICJmcyIsICJodHRwcyIsICJodHRwIiwgIlJlYWRhYmxlU3RyZWFtIiwgInB1bXAiLCAiemxpYiIsICJidWYiLCAiZmV0Y2giLCAiSGVhZGVycyIsICJSZXF1ZXN0IiwgIlJlc3BvbnNlIiwgImltcG9ydF9mcyIsICJvcyIsICJmcyIsICJ2ZXJzaW9uIiwgIlRva2VuIiwgIl9hIiwgIm5hbWUiLCAiZW5jb2RlIiwgImlzT2JqZWN0IiwgImlzQmxvYiIsICJCbG9iIiwgImlzT2JqZWN0IiwgImltcG9ydF9pdF9waXBlIiwgInRocm90dGxlZFF1ZXVlIiwgIl9hIiwgIkJsb2IiLCAiY2FyIiwgIl9iIiwgIml0ZXIiLCAibW9yZSIsICJ0ZW1wIiwgImVycm9yIiwgInBSZXRyeSIsICJUb2tlbiIsICJwaXBlIiwgImZpbGVzIiwgIm5hbWUiLCAiQmxvYiIsICJpbXBvcnRfc2hhcmVkIiwgImltcG9ydF9qcyIsICJCdW5kbHIiLCAiTWV0YXBsZXhGb3VuZGF0aW9uIiwgIkFyd2VhdmUiLCAiX19hc3luYyIsICJidWZmZXIiLCAiTmZ0U3RvcmFnZSIsICJDb25zdGFudHMiLCAiVHJ5IiwgImRlYnVnTG9nIiwgImlzTm9kZSIsICJpc0Jyb3dzZXIiLCAidG9NZXRhcGxleEZpbGUiLCAiQmxvYiIsICJTdG9yYWdlIiwgImltcG9ydF93ZWIzIiwgImltcG9ydF9zcGxfdG9rZW4iLCAiaW1wb3J0X3NoYXJlZCIsICJpbXBvcnRfbXBsX3Rva2VuX21ldGFkYXRhIiwgImltcG9ydF9zaGFyZWQiLCAiTWV0YXBsZXgiLCAibWludCIsICJCTiIsICJNZXRhcGxleCIsICJzaWduZXIiLCAiaW1wb3J0X2NvcmUiLCAiTWV0YXBsZXgiLCAiTkZUX0FNT1VOVCIsICJpbXBvcnRfc2hhcmVkIiwgImltcG9ydF9zcGxfdG9rZW4iLCAiaW1wb3J0X21wbF90b2tlbl9tZXRhZGF0YSIsICJNZXRhcGxleCIsICJpbXBvcnRfY29yZSIsICJNZXRhcGxleCIsICJORlRfQU1PVU5UIiwgIk1ldGFwbGV4Il0KfQo=
"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/index.ts
var src_exports = {};
__export(src_exports, {
  Metaplex: () => Metaplex9
});
module.exports = __toCommonJS(src_exports);

// src/metaplex/burn.ts
var import_core = require("@solana-suite/core");
var Metaplex;
((Metaplex10) => {
  const NFT_AMOUNT2 = 1;
  const NFT_DECIMALS = 0;
  Metaplex10.burn = (mint, owner, signer, feePayer) => {
    return import_core.SplToken.burn(
      mint,
      owner,
      [signer],
      NFT_AMOUNT2,
      NFT_DECIMALS,
      feePayer
    );
  };
})(Metaplex || (Metaplex = {}));

// src/metaplex/find.ts
var import_shared_metaplex = require("internals/shared-metaplex");
var import_core2 = require("@solana-suite/core");
var Metaplex2;
((Metaplex10) => {
  Metaplex10.findByOwner = (owner, onOk, onErr, options) => __async(void 0, null, function* () {
    const sortable = !(options == null ? void 0 : options.sortable) ? import_core2.Sortable.Desc : options == null ? void 0 : options.sortable;
    const isHolder = !(options == null ? void 0 : options.isHolder) ? true : false;
    yield import_core2.SplToken.genericFindByOwner(
      owner,
      (result) => result.match(onOk, onErr),
      import_shared_metaplex.UserSideInput.TokenStandard.NonFungible,
      sortable,
      isHolder
    );
  });
  Metaplex10.findByMint = (mint) => __async(void 0, null, function* () {
    return yield import_core2.SplToken.genericFindByMint(
      mint,
      import_shared_metaplex.UserSideInput.TokenStandard.NonFungible
    );
  });
})(Metaplex2 || (Metaplex2 = {}));

// src/metaplex/freeze.ts
var import_shared = require("@solana-suite/shared");
var import_shared_metaplex2 = require("internals/shared-metaplex");
var import_spl_token = require("@solana/spl-token");
var import_mpl_token_metadata = require("@metaplex-foundation/mpl-token-metadata");
var Metaplex3;
((Metaplex10) => {
  Metaplex10.freeze = (mint, owner, freezeAuthority, feePayer) => {
    const payer = feePayer ? feePayer : freezeAuthority;
    return (0, import_shared.Try)(() => {
      const tokenAccount = (0, import_spl_token.getAssociatedTokenAddressSync)(
        mint.toPublicKey(),
        owner.toPublicKey()
      );
      const editionAddress = import_shared_metaplex2.Pda.getMasterEdition(mint);
      const inst = (0, import_mpl_token_metadata.createFreezeDelegatedAccountInstruction)({
        delegate: new import_shared.KeypairAccount({ secret: freezeAuthority }).toPublicKey(),
        tokenAccount,
        edition: editionAddress,
        mint: mint.toPublicKey()
      });
      return new import_shared.Instruction(
        [inst],
        [freezeAuthority.toKeypair()],
        payer.toKeypair()
      );
    });
  };
})(Metaplex3 || (Metaplex3 = {}));

// src/metaplex/fee-payer-partial-sign-mint.ts
var import_shared4 = require("@solana-suite/shared");
var import_web32 = require("@solana/web3.js");
var import_storage2 = require("internals/storage");
var import_shared_metaplex4 = require("internals/shared-metaplex");

// src/metaplex/mint.ts
var import_web3 = require("@solana/web3.js");
var import_bn = __toESM(require("bn.js"));
var import_spl_token2 = require("@solana/spl-token");
var import_shared2 = require("@solana-suite/shared");
var import_storage = require("internals/storage");
var import_shared_metaplex3 = require("internals/shared-metaplex");
var import_mpl_token_metadata2 = require("@metaplex-foundation/mpl-token-metadata");
var import_shared3 = require("@solana-suite/shared");
var NFT_AMOUNT = 1;
var Metaplex4;
((Metaplex10) => {
  Metaplex10.createDeleagateInstruction = (mint2, owner, delegateAuthority) => {
    const tokenAccount = (0, import_spl_token2.getAssociatedTokenAddressSync)(mint2, owner);
    return (0, import_spl_token2.createApproveInstruction)(
      tokenAccount,
      delegateAuthority,
      owner,
      NFT_AMOUNT
    );
  };
  Metaplex10.createMintInstructions = (mint2, owner, nftMetadata, feePayer, isMutable) => __async(void 0, null, function* () {
    const ata = (0, import_spl_token2.getAssociatedTokenAddressSync)(mint2, owner);
    const tokenMetadataPubkey = import_shared_metaplex3.Pda.getMetadata(mint2.toString());
    const masterEditionPubkey = import_shared_metaplex3.Pda.getMasterEdition(mint2.toString());
    const connection = import_shared3.Node.getConnection();
    const inst1 = import_web3.SystemProgram.createAccount({
      fromPubkey: feePayer,
      newAccountPubkey: mint2,
      lamports: yield (0, import_spl_token2.getMinimumBalanceForRentExemptMint)(connection),
      space: import_spl_token2.MINT_SIZE,
      programId: import_spl_token2.TOKEN_PROGRAM_ID
    });
    const inst2 = (0, import_spl_token2.createInitializeMintInstruction)(mint2, 0, owner, owner);
    const inst3 = (0, import_spl_token2.createAssociatedTokenAccountInstruction)(
      feePayer,
      ata,
      owner,
      mint2
    );
    const inst4 = (0, import_spl_token2.createMintToCheckedInstruction)(mint2, ata, owner, 1, 0);
    const inst5 = (0, import_mpl_token_metadata2.createCreateMetadataAccountV3Instruction)(
      {
        metadata: tokenMetadataPubkey,
        mint: mint2,
        mintAuthority: owner,
        payer: feePayer,
        updateAuthority: owner
      },
      {
        createMetadataAccountArgsV3: {
          data: nftMetadata,
          isMutable,
          collectionDetails: { __kind: "V1", size: new import_bn.default(1) }
        }
      }
    );
    const inst6 = (0, import_mpl_token_metadata2.createCreateMasterEditionV3Instruction)(
      {
        edition: masterEditionPubkey,
        mint: mint2,
        updateAuthority: owner,
        mintAuthority: owner,
        payer: feePayer,
        metadata: tokenMetadataPubkey
      },
      {
        createMasterEditionArgs: {
          maxSupply: 0
        }
      }
    );
    return [inst1, inst2, inst3, inst4, inst5, inst6];
  });
  Metaplex10.mint = (owner, signer, input, feePayer, freezeAuthority) => __async(void 0, null, function* () {
    return (0, import_shared2.Try)(() => __async(void 0, null, function* () {
      const valid = import_shared_metaplex3.Validator.checkAll(input);
      if (valid.isErr) {
        throw valid.error;
      }
      const payer = feePayer ? feePayer : signer;
      let properties;
      if (input.properties && input.storageType) {
        properties = yield import_shared_metaplex3.Convert.Properties.intoInfraSide(
          input.properties,
          import_storage.Storage.uploadContent,
          input.storageType,
          payer
        );
      } else if (input.properties && !input.storageType) {
        throw Error("Must set storageType if will use properties");
      }
      input = __spreadProps(__spreadValues({}, input), {
        properties
      });
      const sellerFeeBasisPoints = import_shared_metaplex3.Royalty.convert(input.royalty);
      const nftStorageMetadata = import_storage.Storage.toConvertOffchaindata(
        input,
        sellerFeeBasisPoints
      );
      const createdAt = Math.floor((/* @__PURE__ */ new Date()).getTime() / 1e3);
      nftStorageMetadata.created_at = createdAt;
      let uri;
      if (input.filePath && input.storageType) {
        const uploaded = yield import_storage.Storage.uploadMetaAndContent(
          nftStorageMetadata,
          input.filePath,
          input.storageType,
          payer
        );
        (0, import_shared2.debugLog)("# upload content url: ", uploaded);
        if (uploaded.isErr) {
          throw uploaded;
        }
        uri = uploaded.value;
      } else if (input.uri) {
        uri = input.uri;
      } else {
        throw Error(`Must set 'storageType + filePath' or 'uri'`);
      }
      let datav2 = import_shared_metaplex3.Convert.NftMetadata.intoInfraSide(
        input,
        uri,
        sellerFeeBasisPoints
      );
      let collection;
      if (input.collection && input.collection) {
        collection = import_shared_metaplex3.Convert.Collection.intoInfraSide(input.collection);
        datav2 = __spreadProps(__spreadValues({}, datav2), { collection });
      }
      const isMutable = input.isMutable === void 0 ? true : input.isMutable;
      (0, import_shared2.debugLog)("# input: ", input);
      (0, import_shared2.debugLog)("# sellerFeeBasisPoints: ", sellerFeeBasisPoints);
      (0, import_shared2.debugLog)("# datav2: ", datav2);
      const mint2 = import_shared2.KeypairAccount.create();
      const insts = yield (0, Metaplex10.createMintInstructions)(
        mint2.toPublicKey(),
        owner.toPublicKey(),
        datav2,
        payer.toKeypair().publicKey,
        isMutable
      );
      if (freezeAuthority) {
        insts.push(
          (0, Metaplex10.createDeleagateInstruction)(
            mint2.toPublicKey(),
            owner.toPublicKey(),
            freezeAuthority.toPublicKey()
          )
        );
      }
      return new import_shared2.MintInstruction(
        insts,
        [signer.toKeypair(), mint2.toKeypair()],
        payer.toKeypair(),
        mint2.pubkey
      );
    }));
  });
})(Metaplex4 || (Metaplex4 = {}));

// src/metaplex/fee-payer-partial-sign-mint.ts
var Metaplex5;
((Metaplex10) => {
  Metaplex10.feePayerPartialSignMint = (owner, signer, input, feePayer, freezeAuthority) => __async(void 0, null, function* () {
    return (0, import_shared4.Try)(() => __async(void 0, null, function* () {
      const valid = import_shared_metaplex4.Validator.checkAll(input);
      if (valid.isErr) {
        throw valid.error;
      }
      const sellerFeeBasisPoints = import_shared_metaplex4.Royalty.convert(input.royalty);
      let uri = "";
      if (input.filePath && input.storageType === "nftStorage") {
        const properties = yield import_shared_metaplex4.Convert.Properties.intoInfraSide(
          input.properties,
          import_storage2.Storage.uploadContent,
          input.storageType
        );
        const nftStorageMetadata = import_storage2.Storage.toConvertOffchaindata(
          __spreadProps(__spreadValues({}, input), { properties }),
          sellerFeeBasisPoints
        );
        const uploaded = yield import_storage2.Storage.uploadMetaAndContent(
          nftStorageMetadata,
          input.filePath,
          input.storageType
        );
        if (uploaded.isErr) {
          throw uploaded;
        }
        uri = uploaded.value;
        (0, import_shared4.debugLog)("# upload content url: ", uploaded);
      } else if (input.uri) {
        uri = input.uri;
      } else {
        throw Error(`Must set 'storageType=nftStorage + filePath' or 'uri'`);
      }
      let datav2 = import_shared_metaplex4.Convert.NftMetadata.intoInfraSide(
        input,
        uri,
        sellerFeeBasisPoints
      );
      let collection;
      if (input.collection && input.collection) {
        collection = import_shared_metaplex4.Convert.Collection.intoInfraSide(input.collection);
        datav2 = __spreadProps(__spreadValues({}, datav2), { collection });
      }
      const isMutable = input.isMutable === void 0 ? true : input.isMutable;
      (0, import_shared4.debugLog)("# input: ", input);
      (0, import_shared4.debugLog)("# sellerFeeBasisPoints: ", sellerFeeBasisPoints);
      (0, import_shared4.debugLog)("# datav2: ", datav2);
      const mint = import_shared4.KeypairAccount.create();
      const insts = yield Metaplex4.createMintInstructions(
        mint.toPublicKey(),
        owner.toPublicKey(),
        datav2,
        feePayer.toPublicKey(),
        isMutable
      );
      if (freezeAuthority) {
        insts.push(
          Metaplex4.createDeleagateInstruction(
            mint.toPublicKey(),
            owner.toPublicKey(),
            freezeAuthority.toPublicKey()
          )
        );
      }
      const blockhashObj = yield import_shared4.Node.getConnection().getLatestBlockhash();
      const tx = new import_web32.Transaction({
        lastValidBlockHeight: blockhashObj.lastValidBlockHeight,
        blockhash: blockhashObj.blockhash,
        feePayer: feePayer.toPublicKey()
      });
      insts.forEach((inst) => tx.add(inst));
      tx.recentBlockhash = blockhashObj.blockhash;
      [signer, mint].forEach((signer2) => tx.partialSign(signer2.toKeypair()));
      const serializedTx = tx.serialize({
        requireAllSignatures: false
      });
      const hex = serializedTx.toString("hex");
      return new import_shared4.PartialSignInstruction(hex, mint.pubkey);
    }));
  });
})(Metaplex5 || (Metaplex5 = {}));

// src/metaplex/fee-payer-partial-sign-transfer.ts
var import_core3 = require("@solana-suite/core");
var Metaplex6;
((Metaplex10) => {
  const NFT_AMOUNT2 = 1;
  const NFT_DECIMALS = 0;
  Metaplex10.feePayerPartialSignTransferNft = (mint, owner, dest, signers, feePayer) => __async(void 0, null, function* () {
    return import_core3.SplToken.feePayerPartialSignTransfer(
      mint,
      owner,
      dest,
      signers,
      NFT_AMOUNT2,
      NFT_DECIMALS,
      feePayer
    );
  });
})(Metaplex6 || (Metaplex6 = {}));

// src/metaplex/thaw.ts
var import_shared5 = require("@solana-suite/shared");
var import_shared_metaplex5 = require("internals/shared-metaplex");
var import_spl_token3 = require("@solana/spl-token");
var import_mpl_token_metadata3 = require("@metaplex-foundation/mpl-token-metadata");
var Metaplex7;
((Metaplex10) => {
  Metaplex10.thaw = (mint, owner, freezeAuthority, feePayer) => {
    const payer = feePayer ? feePayer : freezeAuthority;
    return (0, import_shared5.Try)(() => {
      const tokenAccount = (0, import_spl_token3.getAssociatedTokenAddressSync)(
        mint.toPublicKey(),
        owner.toPublicKey()
      );
      const editionAddress = import_shared_metaplex5.Pda.getMasterEdition(mint);
      const inst = (0, import_mpl_token_metadata3.createThawDelegatedAccountInstruction)({
        delegate: new import_shared5.KeypairAccount({ secret: freezeAuthority }).toPublicKey(),
        tokenAccount,
        edition: editionAddress,
        mint: mint.toPublicKey()
      });
      return new import_shared5.Instruction(
        [inst],
        [freezeAuthority.toKeypair()],
        payer.toKeypair()
      );
    });
  };
})(Metaplex7 || (Metaplex7 = {}));

// src/metaplex/transfer.ts
var import_core4 = require("@solana-suite/core");
var Metaplex8;
((Metaplex10) => {
  const NFT_AMOUNT2 = 1;
  const NFT_DECIMALS = 0;
  Metaplex10.transfer = (mint, owner, dest, signers, feePayer) => __async(void 0, null, function* () {
    return import_core4.SplToken.transfer(
      mint,
      owner,
      dest,
      signers,
      NFT_AMOUNT2,
      NFT_DECIMALS,
      feePayer
    );
  });
})(Metaplex8 || (Metaplex8 = {}));

// src/metaplex/index.ts
var Metaplex9 = Object.assign(
  {},
  Metaplex,
  Metaplex2,
  Metaplex3,
  Metaplex5,
  Metaplex6,
  Metaplex4,
  Metaplex7,
  Metaplex8
);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Metaplex
});
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vc3JjL2luZGV4LnRzIiwgIi4uL3NyYy9tZXRhcGxleC9idXJuLnRzIiwgIi4uL3NyYy9tZXRhcGxleC9maW5kLnRzIiwgIi4uL3NyYy9tZXRhcGxleC9mcmVlemUudHMiLCAiLi4vc3JjL21ldGFwbGV4L2ZlZS1wYXllci1wYXJ0aWFsLXNpZ24tbWludC50cyIsICIuLi9zcmMvbWV0YXBsZXgvbWludC50cyIsICIuLi9zcmMvbWV0YXBsZXgvZmVlLXBheWVyLXBhcnRpYWwtc2lnbi10cmFuc2Zlci50cyIsICIuLi9zcmMvbWV0YXBsZXgvdGhhdy50cyIsICIuLi9zcmMvbWV0YXBsZXgvdHJhbnNmZXIudHMiLCAiLi4vc3JjL21ldGFwbGV4L2luZGV4LnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyJleHBvcnQgKiBmcm9tICcuL21ldGFwbGV4JztcbmV4cG9ydCAqIGZyb20gJy4vdHlwZXMnO1xuIiwgImltcG9ydCB7IEluc3RydWN0aW9uLCBQdWJrZXksIFJlc3VsdCwgU2VjcmV0IH0gZnJvbSAnQHNvbGFuYS1zdWl0ZS9zaGFyZWQnO1xuaW1wb3J0IHsgU3BsVG9rZW4gfSBmcm9tICdAc29sYW5hLXN1aXRlL2NvcmUnO1xuXG5leHBvcnQgbmFtZXNwYWNlIE1ldGFwbGV4IHtcbiAgY29uc3QgTkZUX0FNT1VOVCA9IDE7XG4gIGNvbnN0IE5GVF9ERUNJTUFMUyA9IDA7XG5cbiAgZXhwb3J0IGNvbnN0IGJ1cm4gPSAoXG4gICAgbWludDogUHVia2V5LFxuICAgIG93bmVyOiBQdWJrZXksXG4gICAgc2lnbmVyOiBTZWNyZXQsXG4gICAgZmVlUGF5ZXI/OiBTZWNyZXRcbiAgKTogUmVzdWx0PEluc3RydWN0aW9uLCBFcnJvcj4gPT4ge1xuICAgIHJldHVybiBTcGxUb2tlbi5idXJuKFxuICAgICAgbWludCxcbiAgICAgIG93bmVyLFxuICAgICAgW3NpZ25lcl0sXG4gICAgICBORlRfQU1PVU5ULFxuICAgICAgTkZUX0RFQ0lNQUxTLFxuICAgICAgZmVlUGF5ZXJcbiAgICApO1xuICB9O1xufVxuIiwgImltcG9ydCB7IFB1YmtleSwgUmVzdWx0IH0gZnJvbSAnQHNvbGFuYS1zdWl0ZS9zaGFyZWQnO1xuaW1wb3J0IHsgVXNlclNpZGVJbnB1dCB9IGZyb20gJ2ludGVybmFscy9zaGFyZWQtbWV0YXBsZXgnO1xuaW1wb3J0IHsgRmluZCwgT25FcnIsIE9uT2ssIFNvcnRhYmxlLCBTcGxUb2tlbiB9IGZyb20gJ0Bzb2xhbmEtc3VpdGUvY29yZSc7XG5pbXBvcnQgeyBOZnRNZXRhZGF0YSB9IGZyb20gJy4uL3R5cGVzLyc7XG5cbmV4cG9ydCBuYW1lc3BhY2UgTWV0YXBsZXgge1xuICAvKipcbiAgICogRmV0Y2ggbWludGVkIG1ldGFkYXRhIGJ5IG93bmVyIFB1YmtleVxuICAgKlxuICAgKiBAcGFyYW0ge1B1YmtleX0gb3duZXJcbiAgICogQHBhcmFtIHtPbk9rfSBvbk9rIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7T25FcnJ9IG9uRXJyIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7e3NvcnRhYmxlPzogU29ydGFibGUsIGlzSG9sZGVyPzogYm9vbGVhbn19IG9wdGlvbnM/XG4gICAqIEByZXR1cm4gUHJvbWlzZTx2b2lkPlxuICAgKi9cbiAgZXhwb3J0IGNvbnN0IGZpbmRCeU93bmVyID0gYXN5bmMgKFxuICAgIG93bmVyOiBQdWJrZXksXG4gICAgb25PazogT25PazxGaW5kPixcbiAgICBvbkVycjogT25FcnIsXG4gICAgb3B0aW9ucz86IHsgc29ydGFibGU/OiBTb3J0YWJsZTsgaXNIb2xkZXI/OiBib29sZWFuIH1cbiAgKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gICAgY29uc3Qgc29ydGFibGUgPSAhb3B0aW9ucz8uc29ydGFibGUgPyBTb3J0YWJsZS5EZXNjIDogb3B0aW9ucz8uc29ydGFibGU7XG4gICAgY29uc3QgaXNIb2xkZXIgPSAhb3B0aW9ucz8uaXNIb2xkZXIgPyB0cnVlIDogZmFsc2U7XG4gICAgYXdhaXQgU3BsVG9rZW4uZ2VuZXJpY0ZpbmRCeU93bmVyKFxuICAgICAgb3duZXIsXG4gICAgICAocmVzdWx0OiBSZXN1bHQ8W10sIEVycm9yPikgPT4gcmVzdWx0Lm1hdGNoKG9uT2ssIG9uRXJyKSxcbiAgICAgIFVzZXJTaWRlSW5wdXQuVG9rZW5TdGFuZGFyZC5Ob25GdW5naWJsZSxcbiAgICAgIHNvcnRhYmxlLFxuICAgICAgaXNIb2xkZXJcbiAgICApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBGZXRjaCBtaW50ZWQgbWV0YWRhdGEgYnkgbWludCBhZGRyZXNzXG4gICAqXG4gICAqIEBwYXJhbSB7UHVia2V5fSBtaW50XG4gICAqIEByZXR1cm4gUHJvbWlzZTxSZXN1bHQ8TmZ0TWV0YWRhdGEsIEVycm9yPj5cbiAgICovXG4gIGV4cG9ydCBjb25zdCBmaW5kQnlNaW50ID0gYXN5bmMgKFxuICAgIG1pbnQ6IFB1YmtleVxuICApOiBQcm9taXNlPFJlc3VsdDxOZnRNZXRhZGF0YSwgRXJyb3I+PiA9PiB7XG4gICAgLy8gcmV0dXJuIGF3YWl0IFNwbFRva2VuLmdlbmVyaWNGaW5kQnlNaW50PE5mdE1ldGFkYXRhPihcbiAgICByZXR1cm4gYXdhaXQgU3BsVG9rZW4uZ2VuZXJpY0ZpbmRCeU1pbnQoXG4gICAgICBtaW50LFxuICAgICAgVXNlclNpZGVJbnB1dC5Ub2tlblN0YW5kYXJkLk5vbkZ1bmdpYmxlXG4gICAgKTtcbiAgfTtcbn1cbiIsICJpbXBvcnQge1xuICBJbnN0cnVjdGlvbixcbiAgS2V5cGFpckFjY291bnQsXG4gIFB1YmtleSxcbiAgUmVzdWx0LFxuICBTZWNyZXQsXG4gIFRyeSxcbn0gZnJvbSAnQHNvbGFuYS1zdWl0ZS9zaGFyZWQnO1xuaW1wb3J0IHsgUGRhIH0gZnJvbSAnaW50ZXJuYWxzL3NoYXJlZC1tZXRhcGxleCc7XG5pbXBvcnQgeyBnZXRBc3NvY2lhdGVkVG9rZW5BZGRyZXNzU3luYyB9IGZyb20gJ0Bzb2xhbmEvc3BsLXRva2VuJztcbmltcG9ydCB7IGNyZWF0ZUZyZWV6ZURlbGVnYXRlZEFjY291bnRJbnN0cnVjdGlvbiB9IGZyb20gJ0BtZXRhcGxleC1mb3VuZGF0aW9uL21wbC10b2tlbi1tZXRhZGF0YSc7XG5cbmV4cG9ydCBuYW1lc3BhY2UgTWV0YXBsZXgge1xuICAvKipcbiAgICogRnJlZXppbmcgYSB0YXJnZXQgbmZ0XG4gICAqIGl0IHNob3VsZCBzZXQgdG8gZnJlZXplQXV0aG9yaXR5IHdoZW4gbWludCgpXG4gICAqIEBwYXJhbSB7UHVia2V5fSBtaW50ICAgICAgICAgICAgIC8vIG1pbnQgYWRkcmVzc1xuICAgKiBAcGFyYW0ge1B1YmtleX0gb3duZXIgICAgICAgICAgICAvLyBjdXJyZW50IG93bmVyXG4gICAqIEBwYXJhbSB7U2VjcmV0fSBmcmVlemVBdXRob3JpdHkgIC8vIHNldHRlZCBmcmVlemUgYXV0aG9yaXR5IG9mIG5mdFxuICAgKiBAcGFyYW0ge1NlY3JldH0gZmVlUGF5ZXI/ICAgICAgIC8vIGZlZSBwYXllclxuICAgKi9cbiAgZXhwb3J0IGNvbnN0IGZyZWV6ZSA9IChcbiAgICBtaW50OiBQdWJrZXksXG4gICAgb3duZXI6IFB1YmtleSxcbiAgICBmcmVlemVBdXRob3JpdHk6IFNlY3JldCxcbiAgICBmZWVQYXllcj86IFNlY3JldFxuICApOiBSZXN1bHQ8SW5zdHJ1Y3Rpb24sIEVycm9yPiA9PiB7XG4gICAgY29uc3QgcGF5ZXIgPSBmZWVQYXllciA/IGZlZVBheWVyIDogZnJlZXplQXV0aG9yaXR5O1xuICAgIHJldHVybiBUcnkoKCkgPT4ge1xuICAgICAgY29uc3QgdG9rZW5BY2NvdW50ID0gZ2V0QXNzb2NpYXRlZFRva2VuQWRkcmVzc1N5bmMoXG4gICAgICAgIG1pbnQudG9QdWJsaWNLZXkoKSxcbiAgICAgICAgb3duZXIudG9QdWJsaWNLZXkoKVxuICAgICAgKTtcbiAgICAgIGNvbnN0IGVkaXRpb25BZGRyZXNzID0gUGRhLmdldE1hc3RlckVkaXRpb24obWludCk7XG5cbiAgICAgIGNvbnN0IGluc3QgPSBjcmVhdGVGcmVlemVEZWxlZ2F0ZWRBY2NvdW50SW5zdHJ1Y3Rpb24oe1xuICAgICAgICBkZWxlZ2F0ZTogbmV3IEtleXBhaXJBY2NvdW50KHsgc2VjcmV0OiBmcmVlemVBdXRob3JpdHkgfSkudG9QdWJsaWNLZXkoKSxcbiAgICAgICAgdG9rZW5BY2NvdW50OiB0b2tlbkFjY291bnQsXG4gICAgICAgIGVkaXRpb246IGVkaXRpb25BZGRyZXNzLFxuICAgICAgICBtaW50OiBtaW50LnRvUHVibGljS2V5KCksXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBuZXcgSW5zdHJ1Y3Rpb24oXG4gICAgICAgIFtpbnN0XSxcbiAgICAgICAgW2ZyZWV6ZUF1dGhvcml0eS50b0tleXBhaXIoKV0sXG4gICAgICAgIHBheWVyLnRvS2V5cGFpcigpXG4gICAgICApO1xuICAgIH0pO1xuICB9O1xufVxuIiwgImltcG9ydCB7XG4gIGRlYnVnTG9nLFxuICBLZXlwYWlyQWNjb3VudCxcbiAgTm9kZSxcbiAgUGFydGlhbFNpZ25JbnN0cnVjdGlvbixcbiAgUHVia2V5LFxuICBSZXN1bHQsXG4gIFNlY3JldCxcbiAgVHJ5LFxufSBmcm9tICdAc29sYW5hLXN1aXRlL3NoYXJlZCc7XG5cbmltcG9ydCB7IFRyYW5zYWN0aW9uIH0gZnJvbSAnQHNvbGFuYS93ZWIzLmpzJztcblxuaW1wb3J0IHsgU3RvcmFnZSB9IGZyb20gJ2ludGVybmFscy9zdG9yYWdlJztcblxuaW1wb3J0IHtcbiAgQ29udmVydCxcbiAgUm95YWx0eSxcbiAgVXNlclNpZGVJbnB1dCxcbiAgVmFsaWRhdG9yLFxufSBmcm9tICdpbnRlcm5hbHMvc2hhcmVkLW1ldGFwbGV4JztcblxuaW1wb3J0IHsgTWV0YXBsZXggYXMgX01pbnQgfSBmcm9tICcuL21pbnQnO1xuXG5leHBvcnQgbmFtZXNwYWNlIE1ldGFwbGV4IHtcbiAgLyoqXG4gICAqIFVwbG9hZCBjb250ZW50IGFuZCBORlQgbWludCB3aXRoIFBhcnRpYWwgU2lnblxuICAgKlxuICAgKiBAcGFyYW0ge1B1YmtleX0gb3duZXIgICAgICAgICAgLy8gZmlyc3QgbWludGVkIG93bmVyXG4gICAqIEBwYXJhbSB7U2VjcmV0fSBzaWduZXIgICAgICAgICAvLyBvd25lcidzIFNlY3JldFxuICAgKiBAcGFyYW0ge1VzZXJTaWRlSW5wdXQuTmZ0TWV0YWRhdGF9IGlucHV0XG4gICAqIHtcbiAgICogICBuYW1lOiBzdHJpbmcgICAgICAgICAgICAgICAvLyBuZnQgY29udGVudCBuYW1lXG4gICAqICAgc3ltYm9sOiBzdHJpbmcgICAgICAgICAgICAgLy8gbmZ0IHRpY2tlciBzeW1ib2xcbiAgICogICBmaWxlUGF0aDogc3RyaW5nIHwgRmlsZSAgICAvLyBuZnQgdGlja2VyIHN5bWJvbFxuICAgKiAgIHJveWFsdHk6IG51bWJlciAgICAgICAgICAgIC8vIHJveWFsdHkgcGVyY2VudGFnZVxuICAgKiAgIHN0b3JhZ2VUeXBlOiAnYXJ3ZWF2ZSd8J25mdFN0b3JhZ2UnIC8vIHJveWFsdHkgcGVyY2VudGFnZVxuICAgKiAgIGRlc2NyaXB0aW9uPzogc3RyaW5nICAgICAgIC8vIG5mdCBjb250ZW50IGRlc2NyaXB0aW9uXG4gICAqICAgZXh0ZXJuYWxfdXJsPzogc3RyaW5nICAgICAgLy8gbGFuZGluZyBwYWdlLCBob21lIHBhZ2UgdXJpLCByZWxhdGVkIHVybFxuICAgKiAgIGF0dHJpYnV0ZXM/OiBNZXRhZGF0YUF0dHJpYnV0ZVtdICAgICAvLyBnYW1lIGNoYXJhY3RlciBwYXJhbWV0ZXIsIHBlcnNvbmFsaXR5LCBjaGFyYWN0ZXJpc3RpY3NcbiAgICogICBwcm9wZXJ0aWVzPzogTWV0YWRhdGFQcm9wZXJ0aWVzPFVyaT4gLy8gaW5jbHVkZSBmaWxlIG5hbWUsIHVyaSwgc3VwcG9ydGVkIGZpbGUgdHlwZVxuICAgKiAgIGNvbGxlY3Rpb24/OiBQdWJrZXkgICAgICAgICAgIC8vIGNvbGxlY3Rpb25zIG9mIGRpZmZlcmVudCBjb2xvcnMsIHNoYXBlcywgZXRjLlxuICAgKiAgIFtrZXk6IHN0cmluZ10/OiB1bmtub3duICAgICAgIC8vIG9wdGlvbmFsIHBhcmFtLCBVc3VhbGx5IG5vdCB1c2VkLlxuICAgKiAgIGNyZWF0b3JzPzogSW5wdXRDcmVhdG9yc1tdICAgICAgICAgIC8vIG90aGVyIGNyZWF0b3JzIHRoYW4gb3duZXJcbiAgICogICB1c2VzPzogVXNlcyAgICAgICAgICAgICAgICAgICAvLyB1c2FnZSBmZWF0dXJlOiBidXJuLCBzaW5nbGUsIG11bHRpcGxlXG4gICAqICAgaXNNdXRhYmxlPzogYm9vbGVhbiAgICAgICAgICAgLy8gZW5hYmxlIHVwZGF0ZSgpXG4gICAqIH1cbiAgICogQHBhcmFtIHtTZWNyZXR9IGZlZVBheWVyPyAgICAgICAgIC8vIGZlZSBwYXllclxuICAgKiBAcGFyYW0ge1B1YmtleX0gZnJlZXplQXV0aG9yaXR5PyAgLy8gZnJlZXplIGF1dGhvcml0eVxuICAgKiBAcmV0dXJuIFByb21pc2U8UmVzdWx0PFBhcnRpYWxTaWduSW5zdHJ1Y3Rpb24sIEVycm9yPj5cbiAgICovXG4gIGV4cG9ydCBjb25zdCBmZWVQYXllclBhcnRpYWxTaWduTWludCA9IGFzeW5jIChcbiAgICBvd25lcjogUHVia2V5LFxuICAgIHNpZ25lcjogU2VjcmV0LFxuICAgIGlucHV0OiBVc2VyU2lkZUlucHV0Lk5mdE1ldGFkYXRhLFxuICAgIGZlZVBheWVyOiBQdWJrZXksXG4gICAgZnJlZXplQXV0aG9yaXR5PzogU2VjcmV0XG4gICk6IFByb21pc2U8UmVzdWx0PFBhcnRpYWxTaWduSW5zdHJ1Y3Rpb24sIEVycm9yPj4gPT4ge1xuICAgIHJldHVybiBUcnkoYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdmFsaWQgPSBWYWxpZGF0b3IuY2hlY2tBbGw8VXNlclNpZGVJbnB1dC5OZnRNZXRhZGF0YT4oaW5wdXQpO1xuICAgICAgaWYgKHZhbGlkLmlzRXJyKSB7XG4gICAgICAgIHRocm93IHZhbGlkLmVycm9yO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBzZWxsZXJGZWVCYXNpc1BvaW50cyA9IFJveWFsdHkuY29udmVydChpbnB1dC5yb3lhbHR5KTtcblxuICAgICAgLy8tLS0gcG9ycGVydGllcywgVXBsb2FkIGNvbnRlbnQgLS0tXG4gICAgICBsZXQgdXJpID0gJyc7XG4gICAgICBpZiAoaW5wdXQuZmlsZVBhdGggJiYgaW5wdXQuc3RvcmFnZVR5cGUgPT09ICduZnRTdG9yYWdlJykge1xuICAgICAgICBjb25zdCBwcm9wZXJ0aWVzID0gYXdhaXQgQ29udmVydC5Qcm9wZXJ0aWVzLmludG9JbmZyYVNpZGUoXG4gICAgICAgICAgaW5wdXQucHJvcGVydGllcyxcbiAgICAgICAgICBTdG9yYWdlLnVwbG9hZENvbnRlbnQsXG4gICAgICAgICAgaW5wdXQuc3RvcmFnZVR5cGVcbiAgICAgICAgKTtcblxuICAgICAgICBjb25zdCBuZnRTdG9yYWdlTWV0YWRhdGEgPSBTdG9yYWdlLnRvQ29udmVydE9mZmNoYWluZGF0YShcbiAgICAgICAgICB7IC4uLmlucHV0LCBwcm9wZXJ0aWVzIH0sXG4gICAgICAgICAgc2VsbGVyRmVlQmFzaXNQb2ludHNcbiAgICAgICAgKTtcblxuICAgICAgICBjb25zdCB1cGxvYWRlZCA9IGF3YWl0IFN0b3JhZ2UudXBsb2FkTWV0YUFuZENvbnRlbnQoXG4gICAgICAgICAgbmZ0U3RvcmFnZU1ldGFkYXRhLFxuICAgICAgICAgIGlucHV0LmZpbGVQYXRoLFxuICAgICAgICAgIGlucHV0LnN0b3JhZ2VUeXBlXG4gICAgICAgICk7XG4gICAgICAgIGlmICh1cGxvYWRlZC5pc0Vycikge1xuICAgICAgICAgIHRocm93IHVwbG9hZGVkO1xuICAgICAgICB9XG4gICAgICAgIHVyaSA9IHVwbG9hZGVkLnZhbHVlO1xuICAgICAgICBkZWJ1Z0xvZygnIyB1cGxvYWQgY29udGVudCB1cmw6ICcsIHVwbG9hZGVkKTtcbiAgICAgIH0gZWxzZSBpZiAoaW5wdXQudXJpKSB7XG4gICAgICAgIHVyaSA9IGlucHV0LnVyaTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IEVycm9yKGBNdXN0IHNldCAnc3RvcmFnZVR5cGU9bmZ0U3RvcmFnZSArIGZpbGVQYXRoJyBvciAndXJpJ2ApO1xuICAgICAgfVxuICAgICAgLy8tLS0gcG9ycGVydGllcywgVXBsb2FkIGNvbnRlbnQgLS0tXG5cbiAgICAgIGxldCBkYXRhdjIgPSBDb252ZXJ0Lk5mdE1ldGFkYXRhLmludG9JbmZyYVNpZGUoXG4gICAgICAgIGlucHV0LFxuICAgICAgICB1cmksXG4gICAgICAgIHNlbGxlckZlZUJhc2lzUG9pbnRzXG4gICAgICApO1xuXG4gICAgICAvLy0tLSBjb2xsZWN0aW9uIC0tLVxuICAgICAgbGV0IGNvbGxlY3Rpb247XG4gICAgICBpZiAoaW5wdXQuY29sbGVjdGlvbiAmJiBpbnB1dC5jb2xsZWN0aW9uKSB7XG4gICAgICAgIGNvbGxlY3Rpb24gPSBDb252ZXJ0LkNvbGxlY3Rpb24uaW50b0luZnJhU2lkZShpbnB1dC5jb2xsZWN0aW9uKTtcbiAgICAgICAgZGF0YXYyID0geyAuLi5kYXRhdjIsIGNvbGxlY3Rpb24gfTtcbiAgICAgIH1cbiAgICAgIC8vLS0tIGNvbGxlY3Rpb24gLS0tXG5cbiAgICAgIGNvbnN0IGlzTXV0YWJsZSA9IGlucHV0LmlzTXV0YWJsZSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGlucHV0LmlzTXV0YWJsZTtcblxuICAgICAgZGVidWdMb2coJyMgaW5wdXQ6ICcsIGlucHV0KTtcbiAgICAgIGRlYnVnTG9nKCcjIHNlbGxlckZlZUJhc2lzUG9pbnRzOiAnLCBzZWxsZXJGZWVCYXNpc1BvaW50cyk7XG4gICAgICBkZWJ1Z0xvZygnIyBkYXRhdjI6ICcsIGRhdGF2Mik7XG5cbiAgICAgIGNvbnN0IG1pbnQgPSBLZXlwYWlyQWNjb3VudC5jcmVhdGUoKTtcbiAgICAgIGNvbnN0IGluc3RzID0gYXdhaXQgX01pbnQuY3JlYXRlTWludEluc3RydWN0aW9ucyhcbiAgICAgICAgbWludC50b1B1YmxpY0tleSgpLFxuICAgICAgICBvd25lci50b1B1YmxpY0tleSgpLFxuICAgICAgICBkYXRhdjIsXG4gICAgICAgIGZlZVBheWVyLnRvUHVibGljS2V5KCksXG4gICAgICAgIGlzTXV0YWJsZVxuICAgICAgKTtcblxuICAgICAgLy8gZnJlZXplQXV0aG9yaXR5XG4gICAgICBpZiAoZnJlZXplQXV0aG9yaXR5KSB7XG4gICAgICAgIGluc3RzLnB1c2goXG4gICAgICAgICAgX01pbnQuY3JlYXRlRGVsZWFnYXRlSW5zdHJ1Y3Rpb24oXG4gICAgICAgICAgICBtaW50LnRvUHVibGljS2V5KCksXG4gICAgICAgICAgICBvd25lci50b1B1YmxpY0tleSgpLFxuICAgICAgICAgICAgZnJlZXplQXV0aG9yaXR5LnRvUHVibGljS2V5KClcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGJsb2NraGFzaE9iaiA9IGF3YWl0IE5vZGUuZ2V0Q29ubmVjdGlvbigpLmdldExhdGVzdEJsb2NraGFzaCgpO1xuICAgICAgY29uc3QgdHggPSBuZXcgVHJhbnNhY3Rpb24oe1xuICAgICAgICBsYXN0VmFsaWRCbG9ja0hlaWdodDogYmxvY2toYXNoT2JqLmxhc3RWYWxpZEJsb2NrSGVpZ2h0LFxuICAgICAgICBibG9ja2hhc2g6IGJsb2NraGFzaE9iai5ibG9ja2hhc2gsXG4gICAgICAgIGZlZVBheWVyOiBmZWVQYXllci50b1B1YmxpY0tleSgpLFxuICAgICAgfSk7XG5cbiAgICAgIGluc3RzLmZvckVhY2goKGluc3QpID0+IHR4LmFkZChpbnN0KSk7XG4gICAgICB0eC5yZWNlbnRCbG9ja2hhc2ggPSBibG9ja2hhc2hPYmouYmxvY2toYXNoO1xuICAgICAgW3NpZ25lciwgbWludF0uZm9yRWFjaCgoc2lnbmVyKSA9PiB0eC5wYXJ0aWFsU2lnbihzaWduZXIudG9LZXlwYWlyKCkpKTtcblxuICAgICAgY29uc3Qgc2VyaWFsaXplZFR4ID0gdHguc2VyaWFsaXplKHtcbiAgICAgICAgcmVxdWlyZUFsbFNpZ25hdHVyZXM6IGZhbHNlLFxuICAgICAgfSk7XG4gICAgICBjb25zdCBoZXggPSBzZXJpYWxpemVkVHgudG9TdHJpbmcoJ2hleCcpO1xuICAgICAgcmV0dXJuIG5ldyBQYXJ0aWFsU2lnbkluc3RydWN0aW9uKGhleCwgbWludC5wdWJrZXkpO1xuICAgIH0pO1xuICB9O1xufVxuIiwgImltcG9ydCB7XG4gIFB1YmxpY0tleSxcbiAgU3lzdGVtUHJvZ3JhbSxcbiAgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbixcbn0gZnJvbSAnQHNvbGFuYS93ZWIzLmpzJztcblxuaW1wb3J0IEJOIGZyb20gJ2JuLmpzJztcblxuaW1wb3J0IHtcbiAgY3JlYXRlQXBwcm92ZUluc3RydWN0aW9uLFxuICBjcmVhdGVBc3NvY2lhdGVkVG9rZW5BY2NvdW50SW5zdHJ1Y3Rpb24sXG4gIGNyZWF0ZUluaXRpYWxpemVNaW50SW5zdHJ1Y3Rpb24sXG4gIGNyZWF0ZU1pbnRUb0NoZWNrZWRJbnN0cnVjdGlvbixcbiAgZ2V0QXNzb2NpYXRlZFRva2VuQWRkcmVzc1N5bmMsXG4gIGdldE1pbmltdW1CYWxhbmNlRm9yUmVudEV4ZW1wdE1pbnQsXG4gIE1JTlRfU0laRSxcbiAgVE9LRU5fUFJPR1JBTV9JRCxcbn0gZnJvbSAnQHNvbGFuYS9zcGwtdG9rZW4nO1xuaW1wb3J0IHtcbiAgZGVidWdMb2csXG4gIEtleXBhaXJBY2NvdW50LFxuICBNaW50SW5zdHJ1Y3Rpb24sXG4gIFB1YmtleSxcbiAgUmVzdWx0LFxuICBTZWNyZXQsXG4gIFRyeSxcbn0gZnJvbSAnQHNvbGFuYS1zdWl0ZS9zaGFyZWQnO1xuXG5pbXBvcnQgeyBTdG9yYWdlIH0gZnJvbSAnaW50ZXJuYWxzL3N0b3JhZ2UnO1xuXG5pbXBvcnQge1xuICBDb252ZXJ0LFxuICBQZGEsXG4gIFJveWFsdHksXG4gIFVzZXJTaWRlSW5wdXQsXG4gIFZhbGlkYXRvcixcbn0gZnJvbSAnaW50ZXJuYWxzL3NoYXJlZC1tZXRhcGxleCc7XG5cbmltcG9ydCB7XG4gIGNyZWF0ZUNyZWF0ZU1hc3RlckVkaXRpb25WM0luc3RydWN0aW9uLFxuICBjcmVhdGVDcmVhdGVNZXRhZGF0YUFjY291bnRWM0luc3RydWN0aW9uLFxuICBEYXRhVjIsXG59IGZyb20gJ0BtZXRhcGxleC1mb3VuZGF0aW9uL21wbC10b2tlbi1tZXRhZGF0YSc7XG5pbXBvcnQgeyBOb2RlIH0gZnJvbSAnQHNvbGFuYS1zdWl0ZS9zaGFyZWQnO1xuY29uc3QgTkZUX0FNT1VOVCA9IDE7XG5leHBvcnQgbmFtZXNwYWNlIE1ldGFwbGV4IHtcbiAgZXhwb3J0IGNvbnN0IGNyZWF0ZURlbGVhZ2F0ZUluc3RydWN0aW9uID0gKFxuICAgIG1pbnQ6IFB1YmxpY0tleSxcbiAgICBvd25lcjogUHVibGljS2V5LFxuICAgIGRlbGVnYXRlQXV0aG9yaXR5OiBQdWJsaWNLZXksXG4gICk6IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24gPT4ge1xuICAgIGNvbnN0IHRva2VuQWNjb3VudCA9IGdldEFzc29jaWF0ZWRUb2tlbkFkZHJlc3NTeW5jKG1pbnQsIG93bmVyKTtcblxuICAgIHJldHVybiBjcmVhdGVBcHByb3ZlSW5zdHJ1Y3Rpb24oXG4gICAgICB0b2tlbkFjY291bnQsXG4gICAgICBkZWxlZ2F0ZUF1dGhvcml0eSxcbiAgICAgIG93bmVyLFxuICAgICAgTkZUX0FNT1VOVCxcbiAgICApO1xuICB9O1xuXG4gIGV4cG9ydCBjb25zdCBjcmVhdGVNaW50SW5zdHJ1Y3Rpb25zID0gYXN5bmMgKFxuICAgIG1pbnQ6IFB1YmxpY0tleSxcbiAgICBvd25lcjogUHVibGljS2V5LFxuICAgIG5mdE1ldGFkYXRhOiBEYXRhVjIsXG4gICAgZmVlUGF5ZXI6IFB1YmxpY0tleSxcbiAgICBpc011dGFibGU6IGJvb2xlYW4sXG4gICk6IFByb21pc2U8VHJhbnNhY3Rpb25JbnN0cnVjdGlvbltdPiA9PiB7XG4gICAgY29uc3QgYXRhID0gZ2V0QXNzb2NpYXRlZFRva2VuQWRkcmVzc1N5bmMobWludCwgb3duZXIpO1xuICAgIGNvbnN0IHRva2VuTWV0YWRhdGFQdWJrZXkgPSBQZGEuZ2V0TWV0YWRhdGEobWludC50b1N0cmluZygpKTtcbiAgICBjb25zdCBtYXN0ZXJFZGl0aW9uUHVia2V5ID0gUGRhLmdldE1hc3RlckVkaXRpb24obWludC50b1N0cmluZygpKTtcbiAgICBjb25zdCBjb25uZWN0aW9uID0gTm9kZS5nZXRDb25uZWN0aW9uKCk7XG5cbiAgICBjb25zdCBpbnN0MSA9IFN5c3RlbVByb2dyYW0uY3JlYXRlQWNjb3VudCh7XG4gICAgICBmcm9tUHVia2V5OiBmZWVQYXllcixcbiAgICAgIG5ld0FjY291bnRQdWJrZXk6IG1pbnQsXG4gICAgICBsYW1wb3J0czogYXdhaXQgZ2V0TWluaW11bUJhbGFuY2VGb3JSZW50RXhlbXB0TWludChjb25uZWN0aW9uKSxcbiAgICAgIHNwYWNlOiBNSU5UX1NJWkUsXG4gICAgICBwcm9ncmFtSWQ6IFRPS0VOX1BST0dSQU1fSUQsXG4gICAgfSk7XG5cbiAgICBjb25zdCBpbnN0MiA9IGNyZWF0ZUluaXRpYWxpemVNaW50SW5zdHJ1Y3Rpb24obWludCwgMCwgb3duZXIsIG93bmVyKTtcblxuICAgIGNvbnN0IGluc3QzID0gY3JlYXRlQXNzb2NpYXRlZFRva2VuQWNjb3VudEluc3RydWN0aW9uKFxuICAgICAgZmVlUGF5ZXIsXG4gICAgICBhdGEsXG4gICAgICBvd25lcixcbiAgICAgIG1pbnQsXG4gICAgKTtcblxuICAgIGNvbnN0IGluc3Q0ID0gY3JlYXRlTWludFRvQ2hlY2tlZEluc3RydWN0aW9uKG1pbnQsIGF0YSwgb3duZXIsIDEsIDApO1xuXG4gICAgY29uc3QgaW5zdDUgPSBjcmVhdGVDcmVhdGVNZXRhZGF0YUFjY291bnRWM0luc3RydWN0aW9uKFxuICAgICAge1xuICAgICAgICBtZXRhZGF0YTogdG9rZW5NZXRhZGF0YVB1YmtleSxcbiAgICAgICAgbWludCxcbiAgICAgICAgbWludEF1dGhvcml0eTogb3duZXIsXG4gICAgICAgIHBheWVyOiBmZWVQYXllcixcbiAgICAgICAgdXBkYXRlQXV0aG9yaXR5OiBvd25lcixcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGNyZWF0ZU1ldGFkYXRhQWNjb3VudEFyZ3NWMzoge1xuICAgICAgICAgIGRhdGE6IG5mdE1ldGFkYXRhLFxuICAgICAgICAgIGlzTXV0YWJsZSxcbiAgICAgICAgICBjb2xsZWN0aW9uRGV0YWlsczogeyBfX2tpbmQ6ICdWMScsIHNpemU6IG5ldyBCTigxKSB9LFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICApO1xuXG4gICAgY29uc3QgaW5zdDYgPSBjcmVhdGVDcmVhdGVNYXN0ZXJFZGl0aW9uVjNJbnN0cnVjdGlvbihcbiAgICAgIHtcbiAgICAgICAgZWRpdGlvbjogbWFzdGVyRWRpdGlvblB1YmtleSxcbiAgICAgICAgbWludCxcbiAgICAgICAgdXBkYXRlQXV0aG9yaXR5OiBvd25lcixcbiAgICAgICAgbWludEF1dGhvcml0eTogb3duZXIsXG4gICAgICAgIHBheWVyOiBmZWVQYXllcixcbiAgICAgICAgbWV0YWRhdGE6IHRva2VuTWV0YWRhdGFQdWJrZXksXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBjcmVhdGVNYXN0ZXJFZGl0aW9uQXJnczoge1xuICAgICAgICAgIG1heFN1cHBseTogMCxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgKTtcbiAgICByZXR1cm4gW2luc3QxLCBpbnN0MiwgaW5zdDMsIGluc3Q0LCBpbnN0NSwgaW5zdDZdO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVcGxvYWQgY29udGVudCBhbmQgTkZUIG1pbnRcbiAgICpcbiAgICogQHBhcmFtIHtQdWJrZXl9IG93bmVyICAgICAgICAgIC8vIGZpcnN0IG1pbnRlZCBvd25lclxuICAgKiBAcGFyYW0ge1NlY3JldH0gc2lnbmVyICAgICAgICAgLy8gb3duZXIncyBTZWNyZXRcbiAgICogQHBhcmFtIHtVc2VyU2lkZUlucHV0Lk5mdE1ldGFkYXRhfSBpbnB1dFxuICAgKiB7XG4gICAqICAgbmFtZTogc3RyaW5nICAgICAgICAgICAgICAgLy8gbmZ0IGNvbnRlbnQgbmFtZVxuICAgKiAgIHN5bWJvbDogc3RyaW5nICAgICAgICAgICAgIC8vIG5mdCB0aWNrZXIgc3ltYm9sXG4gICAqICAgZmlsZVBhdGg6IHN0cmluZyB8IEZpbGUgICAgLy8gbmZ0IHRpY2tlciBzeW1ib2xcbiAgICogICByb3lhbHR5OiBudW1iZXIgICAgICAgICAgICAvLyByb3lhbHR5IHBlcmNlbnRhZ2VcbiAgICogICBzdG9yYWdlVHlwZTogJ2Fyd2VhdmUnfCduZnRTdG9yYWdlJyAvLyByb3lhbHR5IHBlcmNlbnRhZ2VcbiAgICogICBkZXNjcmlwdGlvbj86IHN0cmluZyAgICAgICAvLyBuZnQgY29udGVudCBkZXNjcmlwdGlvblxuICAgKiAgIGV4dGVybmFsX3VybD86IHN0cmluZyAgICAgIC8vIGxhbmRpbmcgcGFnZSwgaG9tZSBwYWdlIHVyaSwgcmVsYXRlZCB1cmxcbiAgICogICBhdHRyaWJ1dGVzPzogTWV0YWRhdGFBdHRyaWJ1dGVbXSAgICAgLy8gZ2FtZSBjaGFyYWN0ZXIgcGFyYW1ldGVyLCBwZXJzb25hbGl0eSwgY2hhcmFjdGVyaXN0aWNzXG4gICAqICAgcHJvcGVydGllcz86IE1ldGFkYXRhUHJvcGVydGllczxVcmk+IC8vIGluY2x1ZGUgZmlsZSBuYW1lLCB1cmksIHN1cHBvcnRlZCBmaWxlIHR5cGVcbiAgICogICBjb2xsZWN0aW9uPzogUHVia2V5ICAgICAgICAgICAvLyBjb2xsZWN0aW9ucyBvZiBkaWZmZXJlbnQgY29sb3JzLCBzaGFwZXMsIGV0Yy5cbiAgICogICBjcmVhdG9ycz86IElucHV0Q3JlYXRvcnNbXSAgICAvLyBvdGhlciBjcmVhdG9ycyB0aGFuIG93bmVyXG4gICAqICAgdXNlcz86IFVzZXMgICAgICAgICAgICAgICAgICAgLy8gdXNhZ2UgZmVhdHVyZTogYnVybiwgc2luZ2xlLCBtdWx0aXBsZVxuICAgKiAgIGlzTXV0YWJsZT86IGJvb2xlYW4gICAgICAgICAgIC8vIGVuYWJsZSB1cGRhdGUoKVxuICAgKiAgIG9wdGlvbnM/OiBba2V5OiBzdHJpbmddPzogdW5rbm93biAgICAgICAvLyBvcHRpb25hbCBwYXJhbSwgVXN1YWxseSBub3QgdXNlZC5cbiAgICogfVxuICAgKiBAcGFyYW0ge1NlY3JldH0gZmVlUGF5ZXI/ICAgICAgICAgLy8gZmVlIHBheWVyXG4gICAqIEBwYXJhbSB7UHVia2V5fSBmcmVlemVBdXRob3JpdHk/ICAvLyBmcmVlemUgYXV0aG9yaXR5XG4gICAqIEByZXR1cm4gUHJvbWlzZTxSZXN1bHQ8TWludEluc3RydWN0aW9uLCBFcnJvcj4+XG4gICAqL1xuICBleHBvcnQgY29uc3QgbWludCA9IGFzeW5jIChcbiAgICBvd25lcjogUHVia2V5LFxuICAgIHNpZ25lcjogU2VjcmV0LFxuICAgIGlucHV0OiBVc2VyU2lkZUlucHV0Lk5mdE1ldGFkYXRhLFxuICAgIGZlZVBheWVyPzogU2VjcmV0LFxuICAgIGZyZWV6ZUF1dGhvcml0eT86IFB1YmtleSxcbiAgKTogUHJvbWlzZTxSZXN1bHQ8TWludEluc3RydWN0aW9uLCBFcnJvcj4+ID0+IHtcbiAgICByZXR1cm4gVHJ5KGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHZhbGlkID0gVmFsaWRhdG9yLmNoZWNrQWxsPFVzZXJTaWRlSW5wdXQuTmZ0TWV0YWRhdGE+KGlucHV0KTtcbiAgICAgIGlmICh2YWxpZC5pc0Vycikge1xuICAgICAgICB0aHJvdyB2YWxpZC5lcnJvcjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcGF5ZXIgPSBmZWVQYXllciA/IGZlZVBheWVyIDogc2lnbmVyO1xuXG4gICAgICAvLy0tLSBwb3JwZXJ0aWVzLCBVcGxvYWQgY29udGVudCAtLS1cbiAgICAgIGxldCBwcm9wZXJ0aWVzO1xuICAgICAgaWYgKGlucHV0LnByb3BlcnRpZXMgJiYgaW5wdXQuc3RvcmFnZVR5cGUpIHtcbiAgICAgICAgcHJvcGVydGllcyA9IGF3YWl0IENvbnZlcnQuUHJvcGVydGllcy5pbnRvSW5mcmFTaWRlKFxuICAgICAgICAgIGlucHV0LnByb3BlcnRpZXMsXG4gICAgICAgICAgU3RvcmFnZS51cGxvYWRDb250ZW50LFxuICAgICAgICAgIGlucHV0LnN0b3JhZ2VUeXBlLFxuICAgICAgICAgIHBheWVyLFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIGlmIChpbnB1dC5wcm9wZXJ0aWVzICYmICFpbnB1dC5zdG9yYWdlVHlwZSkge1xuICAgICAgICB0aHJvdyBFcnJvcignTXVzdCBzZXQgc3RvcmFnZVR5cGUgaWYgd2lsbCB1c2UgcHJvcGVydGllcycpO1xuICAgICAgfVxuXG4gICAgICBpbnB1dCA9IHtcbiAgICAgICAgLi4uaW5wdXQsXG4gICAgICAgIHByb3BlcnRpZXMsXG4gICAgICB9O1xuICAgICAgLy8tLS0gcG9ycGVydGllcywgVXBsb2FkIGNvbnRlbnQgLS0tXG5cbiAgICAgIGNvbnN0IHNlbGxlckZlZUJhc2lzUG9pbnRzID0gUm95YWx0eS5jb252ZXJ0KGlucHV0LnJveWFsdHkpO1xuICAgICAgY29uc3QgbmZ0U3RvcmFnZU1ldGFkYXRhID0gU3RvcmFnZS50b0NvbnZlcnRPZmZjaGFpbmRhdGEoXG4gICAgICAgIGlucHV0LFxuICAgICAgICBzZWxsZXJGZWVCYXNpc1BvaW50cyxcbiAgICAgICk7XG5cbiAgICAgIC8vIGNyZWF0ZWQgYXQgYnkgdW5peCB0aW1lc3RhbXBcbiAgICAgIGNvbnN0IGNyZWF0ZWRBdCA9IE1hdGguZmxvb3IobmV3IERhdGUoKS5nZXRUaW1lKCkgLyAxMDAwKTtcbiAgICAgIG5mdFN0b3JhZ2VNZXRhZGF0YS5jcmVhdGVkX2F0ID0gY3JlYXRlZEF0O1xuXG4gICAgICBsZXQgdXJpITogc3RyaW5nO1xuICAgICAgaWYgKGlucHV0LmZpbGVQYXRoICYmIGlucHV0LnN0b3JhZ2VUeXBlKSB7XG4gICAgICAgIGNvbnN0IHVwbG9hZGVkID0gYXdhaXQgU3RvcmFnZS51cGxvYWRNZXRhQW5kQ29udGVudChcbiAgICAgICAgICBuZnRTdG9yYWdlTWV0YWRhdGEsXG4gICAgICAgICAgaW5wdXQuZmlsZVBhdGgsXG4gICAgICAgICAgaW5wdXQuc3RvcmFnZVR5cGUsXG4gICAgICAgICAgcGF5ZXIsXG4gICAgICAgICk7XG4gICAgICAgIGRlYnVnTG9nKCcjIHVwbG9hZCBjb250ZW50IHVybDogJywgdXBsb2FkZWQpO1xuICAgICAgICBpZiAodXBsb2FkZWQuaXNFcnIpIHtcbiAgICAgICAgICB0aHJvdyB1cGxvYWRlZDtcbiAgICAgICAgfVxuICAgICAgICB1cmkgPSB1cGxvYWRlZC52YWx1ZTtcbiAgICAgIH0gZWxzZSBpZiAoaW5wdXQudXJpKSB7XG4gICAgICAgIHVyaSA9IGlucHV0LnVyaTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IEVycm9yKGBNdXN0IHNldCAnc3RvcmFnZVR5cGUgKyBmaWxlUGF0aCcgb3IgJ3VyaSdgKTtcbiAgICAgIH1cblxuICAgICAgbGV0IGRhdGF2MiA9IENvbnZlcnQuTmZ0TWV0YWRhdGEuaW50b0luZnJhU2lkZShcbiAgICAgICAgaW5wdXQsXG4gICAgICAgIHVyaSxcbiAgICAgICAgc2VsbGVyRmVlQmFzaXNQb2ludHMsXG4gICAgICApO1xuXG4gICAgICAvLy0tLSBjb2xsZWN0aW9uIC0tLVxuICAgICAgbGV0IGNvbGxlY3Rpb247XG4gICAgICBpZiAoaW5wdXQuY29sbGVjdGlvbiAmJiBpbnB1dC5jb2xsZWN0aW9uKSB7XG4gICAgICAgIGNvbGxlY3Rpb24gPSBDb252ZXJ0LkNvbGxlY3Rpb24uaW50b0luZnJhU2lkZShpbnB1dC5jb2xsZWN0aW9uKTtcbiAgICAgICAgZGF0YXYyID0geyAuLi5kYXRhdjIsIGNvbGxlY3Rpb24gfTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgaXNNdXRhYmxlID0gaW5wdXQuaXNNdXRhYmxlID09PSB1bmRlZmluZWQgPyB0cnVlIDogaW5wdXQuaXNNdXRhYmxlO1xuXG4gICAgICBkZWJ1Z0xvZygnIyBpbnB1dDogJywgaW5wdXQpO1xuICAgICAgZGVidWdMb2coJyMgc2VsbGVyRmVlQmFzaXNQb2ludHM6ICcsIHNlbGxlckZlZUJhc2lzUG9pbnRzKTtcbiAgICAgIGRlYnVnTG9nKCcjIGRhdGF2MjogJywgZGF0YXYyKTtcblxuICAgICAgY29uc3QgbWludCA9IEtleXBhaXJBY2NvdW50LmNyZWF0ZSgpO1xuXG4gICAgICBjb25zdCBpbnN0cyA9IGF3YWl0IGNyZWF0ZU1pbnRJbnN0cnVjdGlvbnMoXG4gICAgICAgIG1pbnQudG9QdWJsaWNLZXkoKSxcbiAgICAgICAgb3duZXIudG9QdWJsaWNLZXkoKSxcbiAgICAgICAgZGF0YXYyLFxuICAgICAgICBwYXllci50b0tleXBhaXIoKS5wdWJsaWNLZXksXG4gICAgICAgIGlzTXV0YWJsZSxcbiAgICAgICk7XG5cbiAgICAgIC8vIGZyZWV6ZUF1dGhvcml0eVxuICAgICAgaWYgKGZyZWV6ZUF1dGhvcml0eSkge1xuICAgICAgICBpbnN0cy5wdXNoKFxuICAgICAgICAgIGNyZWF0ZURlbGVhZ2F0ZUluc3RydWN0aW9uKFxuICAgICAgICAgICAgbWludC50b1B1YmxpY0tleSgpLFxuICAgICAgICAgICAgb3duZXIudG9QdWJsaWNLZXkoKSxcbiAgICAgICAgICAgIGZyZWV6ZUF1dGhvcml0eS50b1B1YmxpY0tleSgpLFxuICAgICAgICAgICksXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgTWludEluc3RydWN0aW9uKFxuICAgICAgICBpbnN0cyxcbiAgICAgICAgW3NpZ25lci50b0tleXBhaXIoKSwgbWludC50b0tleXBhaXIoKV0sXG4gICAgICAgIHBheWVyLnRvS2V5cGFpcigpLFxuICAgICAgICBtaW50LnB1YmtleSxcbiAgICAgICk7XG4gICAgfSk7XG4gIH07XG59XG4iLCAiaW1wb3J0IHtcbiAgUGFydGlhbFNpZ25JbnN0cnVjdGlvbixcbiAgUHVia2V5LFxuICBSZXN1bHQsXG4gIFNlY3JldCxcbn0gZnJvbSAnQHNvbGFuYS1zdWl0ZS9zaGFyZWQnO1xuaW1wb3J0IHsgU3BsVG9rZW4gfSBmcm9tICdAc29sYW5hLXN1aXRlL2NvcmUnO1xuXG5leHBvcnQgbmFtZXNwYWNlIE1ldGFwbGV4IHtcbiAgY29uc3QgTkZUX0FNT1VOVCA9IDE7XG4gIGNvbnN0IE5GVF9ERUNJTUFMUyA9IDA7XG5cbiAgZXhwb3J0IGNvbnN0IGZlZVBheWVyUGFydGlhbFNpZ25UcmFuc2Zlck5mdCA9IGFzeW5jIChcbiAgICBtaW50OiBQdWJrZXksXG4gICAgb3duZXI6IFB1YmtleSxcbiAgICBkZXN0OiBQdWJrZXksXG4gICAgc2lnbmVyczogU2VjcmV0W10sXG4gICAgZmVlUGF5ZXI6IFB1YmtleVxuICApOiBQcm9taXNlPFJlc3VsdDxQYXJ0aWFsU2lnbkluc3RydWN0aW9uLCBFcnJvcj4+ID0+IHtcbiAgICByZXR1cm4gU3BsVG9rZW4uZmVlUGF5ZXJQYXJ0aWFsU2lnblRyYW5zZmVyKFxuICAgICAgbWludCxcbiAgICAgIG93bmVyLFxuICAgICAgZGVzdCxcbiAgICAgIHNpZ25lcnMsXG4gICAgICBORlRfQU1PVU5ULFxuICAgICAgTkZUX0RFQ0lNQUxTLFxuICAgICAgZmVlUGF5ZXJcbiAgICApO1xuICB9O1xufVxuIiwgImltcG9ydCB7XG4gIEluc3RydWN0aW9uLFxuICBLZXlwYWlyQWNjb3VudCxcbiAgUHVia2V5LFxuICBSZXN1bHQsXG4gIFNlY3JldCxcbiAgVHJ5LFxufSBmcm9tICdAc29sYW5hLXN1aXRlL3NoYXJlZCc7XG5pbXBvcnQgeyBQZGEgfSBmcm9tICdpbnRlcm5hbHMvc2hhcmVkLW1ldGFwbGV4JztcbmltcG9ydCB7IGdldEFzc29jaWF0ZWRUb2tlbkFkZHJlc3NTeW5jIH0gZnJvbSAnQHNvbGFuYS9zcGwtdG9rZW4nO1xuaW1wb3J0IHsgY3JlYXRlVGhhd0RlbGVnYXRlZEFjY291bnRJbnN0cnVjdGlvbiB9IGZyb20gJ0BtZXRhcGxleC1mb3VuZGF0aW9uL21wbC10b2tlbi1tZXRhZGF0YSc7XG5cbmV4cG9ydCBuYW1lc3BhY2UgTWV0YXBsZXgge1xuICAvKipcbiAgICogVGhhd2luZyBhIHRhcmdldCBORlRcbiAgICogaXQgc2hvdWxkIHNldCB0byBmcmVlemVBdXRob3JpdHkgd2hlbiBtaW50KClcbiAgICpcbiAgICogQHBhcmFtIHtQdWJrZXl9IG1pbnQgICAgICAgICAgICAgLy8gbWludCBhZGRyZXNzXG4gICAqIEBwYXJhbSB7UHVia2V5fSBvd25lciAgICAgICAgICAgIC8vIGN1cnJlbnQgb3duZXJcbiAgICogQHBhcmFtIHtTZWNyZXR9IGZyZWV6ZUF1dGhvcml0eSAgLy8gc2V0dGVkIGZyZWV6ZSBhdXRob3JpdHkgb2YgbmZ0XG4gICAqIEBwYXJhbSB7U2VjcmV0fSBmZWVQYXllcj8gICAgICAgLy8gZmVlIHBheWVyXG4gICAqL1xuICBleHBvcnQgY29uc3QgdGhhdyA9IChcbiAgICBtaW50OiBQdWJrZXksXG4gICAgb3duZXI6IFB1YmtleSxcbiAgICBmcmVlemVBdXRob3JpdHk6IFNlY3JldCxcbiAgICBmZWVQYXllcj86IFNlY3JldFxuICApOiBSZXN1bHQ8SW5zdHJ1Y3Rpb24sIEVycm9yPiA9PiB7XG4gICAgY29uc3QgcGF5ZXIgPSBmZWVQYXllciA/IGZlZVBheWVyIDogZnJlZXplQXV0aG9yaXR5O1xuICAgIHJldHVybiBUcnkoKCkgPT4ge1xuICAgICAgY29uc3QgdG9rZW5BY2NvdW50ID0gZ2V0QXNzb2NpYXRlZFRva2VuQWRkcmVzc1N5bmMoXG4gICAgICAgIG1pbnQudG9QdWJsaWNLZXkoKSxcbiAgICAgICAgb3duZXIudG9QdWJsaWNLZXkoKVxuICAgICAgKTtcbiAgICAgIGNvbnN0IGVkaXRpb25BZGRyZXNzID0gUGRhLmdldE1hc3RlckVkaXRpb24obWludCk7XG5cbiAgICAgIGNvbnN0IGluc3QgPSBjcmVhdGVUaGF3RGVsZWdhdGVkQWNjb3VudEluc3RydWN0aW9uKHtcbiAgICAgICAgZGVsZWdhdGU6IG5ldyBLZXlwYWlyQWNjb3VudCh7IHNlY3JldDogZnJlZXplQXV0aG9yaXR5IH0pLnRvUHVibGljS2V5KCksXG4gICAgICAgIHRva2VuQWNjb3VudDogdG9rZW5BY2NvdW50LFxuICAgICAgICBlZGl0aW9uOiBlZGl0aW9uQWRkcmVzcyxcbiAgICAgICAgbWludDogbWludC50b1B1YmxpY0tleSgpLFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gbmV3IEluc3RydWN0aW9uKFxuICAgICAgICBbaW5zdF0sXG4gICAgICAgIFtmcmVlemVBdXRob3JpdHkudG9LZXlwYWlyKCldLFxuICAgICAgICBwYXllci50b0tleXBhaXIoKVxuICAgICAgKTtcbiAgICB9KTtcbiAgfTtcbn1cbiIsICJpbXBvcnQgeyBJbnN0cnVjdGlvbiwgUHVia2V5LCBSZXN1bHQsIFNlY3JldCB9IGZyb20gJ0Bzb2xhbmEtc3VpdGUvc2hhcmVkJztcbmltcG9ydCB7IFNwbFRva2VuIH0gZnJvbSAnQHNvbGFuYS1zdWl0ZS9jb3JlJztcblxuZXhwb3J0IG5hbWVzcGFjZSBNZXRhcGxleCB7XG4gIGNvbnN0IE5GVF9BTU9VTlQgPSAxO1xuICBjb25zdCBORlRfREVDSU1BTFMgPSAwO1xuXG4gIGV4cG9ydCBjb25zdCB0cmFuc2ZlciA9IGFzeW5jIChcbiAgICBtaW50OiBQdWJrZXksXG4gICAgb3duZXI6IFB1YmtleSxcbiAgICBkZXN0OiBQdWJrZXksXG4gICAgc2lnbmVyczogU2VjcmV0W10sXG4gICAgZmVlUGF5ZXI/OiBTZWNyZXRcbiAgKTogUHJvbWlzZTxSZXN1bHQ8SW5zdHJ1Y3Rpb24sIEVycm9yPj4gPT4ge1xuICAgIHJldHVybiBTcGxUb2tlbi50cmFuc2ZlcihcbiAgICAgIG1pbnQsXG4gICAgICBvd25lcixcbiAgICAgIGRlc3QsXG4gICAgICBzaWduZXJzLFxuICAgICAgTkZUX0FNT1VOVCxcbiAgICAgIE5GVF9ERUNJTUFMUyxcbiAgICAgIGZlZVBheWVyXG4gICAgKTtcbiAgfTtcbn1cbiIsICJpbXBvcnQgeyBNZXRhcGxleCBhcyBCdXJuIH0gZnJvbSAnLi9idXJuJztcbmltcG9ydCB7IE1ldGFwbGV4IGFzIEZpbmQgfSBmcm9tICcuL2ZpbmQnO1xuaW1wb3J0IHsgTWV0YXBsZXggYXMgRnJlZXplIH0gZnJvbSAnLi9mcmVlemUnO1xuaW1wb3J0IHsgTWV0YXBsZXggYXMgRmVlUGF5ZXIgfSBmcm9tICcuL2ZlZS1wYXllci1wYXJ0aWFsLXNpZ24tbWludCc7XG5pbXBvcnQgeyBNZXRhcGxleCBhcyBGZWVQYXllclRyYW5zZmVyIH0gZnJvbSAnLi9mZWUtcGF5ZXItcGFydGlhbC1zaWduLXRyYW5zZmVyJztcbmltcG9ydCB7IE1ldGFwbGV4IGFzIE1pbnQgfSBmcm9tICcuL21pbnQnO1xuaW1wb3J0IHsgTWV0YXBsZXggYXMgVGhhdyB9IGZyb20gJy4vdGhhdyc7XG5pbXBvcnQgeyBNZXRhcGxleCBhcyBUcmFuc2ZlciB9IGZyb20gJy4vdHJhbnNmZXInO1xuXG5leHBvcnQgY29uc3QgTWV0YXBsZXggPSBPYmplY3QuYXNzaWduKFxuICB7fSxcbiAgQnVybixcbiAgRmluZCxcbiAgRnJlZXplLFxuICBGZWVQYXllcixcbiAgRmVlUGF5ZXJUcmFuc2ZlcixcbiAgTWludCxcbiAgVGhhdyxcbiAgVHJhbnNmZXIsXG4pO1xuIl0sCiAgIm1hcHBpbmdzIjogIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQUE7QUFBQSxrQkFBQUE7QUFBQTtBQUFBOzs7QUNDQSxrQkFBeUI7QUFFbEIsSUFBVTtBQUFBLENBQVYsQ0FBVUMsZUFBVjtBQUNMLFFBQU1DLGNBQWE7QUFDbkIsUUFBTSxlQUFlO0FBRWQsRUFBTUQsV0FBQSxPQUFPLENBQ2xCLE1BQ0EsT0FDQSxRQUNBLGFBQytCO0FBQy9CLFdBQU8scUJBQVM7QUFBQSxNQUNkO0FBQUEsTUFDQTtBQUFBLE1BQ0EsQ0FBQyxNQUFNO0FBQUEsTUFDUEM7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLElBQ0Y7QUFBQSxFQUNGO0FBQUEsR0FsQmU7OztBQ0ZqQiw2QkFBOEI7QUFDOUIsSUFBQUMsZUFBc0Q7QUFHL0MsSUFBVUM7QUFBQSxDQUFWLENBQVVBLGVBQVY7QUFVRSxFQUFNQSxXQUFBLGNBQWMsQ0FDekIsT0FDQSxNQUNBLE9BQ0EsWUFDa0I7QUFDbEIsVUFBTSxXQUFXLEVBQUMsbUNBQVMsWUFBVyxzQkFBUyxPQUFPLG1DQUFTO0FBQy9ELFVBQU0s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QUEsUUFDakQsVUFBVSxJQUFJLDhCQUFlLEVBQUUsUUFBUSxnQkFBZ0IsQ0FBQyxFQUFFLFlBQVk7QUFBQSxRQUN0RTtBQUFBLFFBQ0EsU0FBUztBQUFBLFFBQ1QsTUFBTSxLQUFLLFlBQVk7QUFBQSxNQUN6QixDQUFDO0FBQ0QsYUFBTyxJQUFJO0FBQUEsUUFDVCxDQUFDLElBQUk7QUFBQSxRQUNMLENBQUMsZ0JBQWdCLFVBQVUsQ0FBQztBQUFBLFFBQzVCLE1BQU0sVUFBVTtBQUFBLE1BQ2xCO0FBQUEsSUFDRixDQUFDO0FBQUEsRUFDSDtBQUFBLEdBcENlQSwwQkFBQTs7O0FDWGpCLElBQUFDLGVBQXlCO0FBRWxCLElBQVVDO0FBQUEsQ0FBVixDQUFVQSxlQUFWO0FBQ0wsUUFBTUMsY0FBYTtBQUNuQixRQUFNLGVBQWU7QUFFZCxFQUFNRCxXQUFBLFdBQVcsQ0FDdEIsTUFDQSxPQUNBLE1BQ0EsU0FDQSxhQUN3QztBQUN4QyxXQUFPLHNCQUFTO0FBQUEsTUFDZDtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0FDO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxJQUNGO0FBQUEsRUFDRjtBQUFBLEdBcEJlRCwwQkFBQTs7O0FDTVYsSUFBTUUsWUFBVyxPQUFPO0FBQUEsRUFDN0IsQ0FBQztBQUFBLEVBQ0Q7QUFBQSxFQUNBQTtBQUFBLEVBQ0FBO0FBQUEsRUFDQUE7QUFBQSxFQUNBQTtBQUFBLEVBQ0FBO0FBQUEsRUFDQUE7QUFBQSxFQUNBQTtBQUNGOyIsCiAgIm5hbWVzIjogWyJNZXRhcGxleCIsICJNZXRhcGxleCIsICJORlRfQU1PVU5UIiwgImltcG9ydF9jb3JlIiwgIk1ldGFwbGV4IiwgImltcG9ydF9zaGFyZWRfbWV0YXBsZXgiLCAiTWV0YXBsZXgiLCAiaW1wb3J0X3NoYXJlZCIsICJpbXBvcnRfd2ViMyIsICJpbXBvcnRfc3RvcmFnZSIsICJpbXBvcnRfc2hhcmVkX21ldGFwbGV4IiwgImltcG9ydF9zcGxfdG9rZW4iLCAiaW1wb3J0X3NoYXJlZCIsICJpbXBvcnRfc2hhcmVkX21ldGFwbGV4IiwgImltcG9ydF9tcGxfdG9rZW5fbWV0YWRhdGEiLCAiTWV0YXBsZXgiLCAibWludCIsICJCTiIsICJNZXRhcGxleCIsICJzaWduZXIiLCAiaW1wb3J0X2NvcmUiLCAiTWV0YXBsZXgiLCAiTkZUX0FNT1VOVCIsICJpbXBvcnRfc2hhcmVkIiwgImltcG9ydF9zaGFyZWRfbWV0YXBsZXgiLCAiaW1wb3J0X3NwbF90b2tlbiIsICJpbXBvcnRfbXBsX3Rva2VuX21ldGFkYXRhIiwgIk1ldGFwbGV4IiwgImltcG9ydF9jb3JlIiwgIk1ldGFwbGV4IiwgIk5GVF9BTU9VTlQiLCAiTWV0YXBsZXgiXQp9Cg==
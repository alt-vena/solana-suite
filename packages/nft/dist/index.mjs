var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __knownSymbol = (name5, symbol) => {
  if (symbol = Symbol[name5])
    return symbol;
  throw Error("Symbol." + name5 + " is not defined");
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod2) => function __require2() {
  return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
};
var __export = (target, all4) => {
  for (var name5 in all4)
    __defProp(target, name5, { get: all4[name5], enumerable: true });
};
var __copyProps = (to, from3, except, desc) => {
  if (from3 && typeof from3 === "object" || typeof from3 === "function") {
    for (let key of __getOwnPropNames(from3))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from3[key], enumerable: !(desc = __getOwnPropDesc(from3, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", { value: mod2, enumerable: true }) : target,
  mod2
));
var __toCommonJS = (mod2) => __copyProps(__defProp({}, "__esModule", { value: true }), mod2);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var __await = function(promise, isYieldStar) {
  this[0] = promise;
  this[1] = isYieldStar;
};
var __asyncGenerator = (__this, __arguments, generator) => {
  var resume = (k, v, yes, no) => {
    try {
      var x = generator[k](v), isAwait = (v = x.value) instanceof __await, done = x.done;
      Promise.resolve(isAwait ? v[0] : v).then((y) => isAwait ? resume(k === "return" ? k : "next", v[1] ? { done: y.done, value: y.value } : y, yes, no) : yes({ value: y, done })).catch((e) => resume("throw", e, yes, no));
    } catch (e) {
      no(e);
    }
  };
  var method = (k) => it[k] = (x) => new Promise((yes, no) => resume(k, x, yes, no));
  var it = {};
  return generator = generator.apply(__this, __arguments), it[Symbol.asyncIterator] = () => it, method("next"), method("throw"), method("return"), it;
};
var __yieldStar = (value) => {
  var obj = value[__knownSymbol("asyncIterator")];
  var isAwait = false;
  var method;
  var it = {};
  if (obj == null) {
    obj = value[__knownSymbol("iterator")]();
    method = (k) => it[k] = (x) => obj[k](x);
  } else {
    obj = obj.call(value);
    method = (k) => it[k] = (v) => {
      if (isAwait) {
        isAwait = false;
        if (k === "throw")
          throw v;
        return v;
      }
      isAwait = true;
      return {
        done: false,
        value: new __await(new Promise((resolve) => {
          var x = obj[k](v);
          if (!(x instanceof Object))
            throw TypeError("Object expected");
          resolve(x);
        }), 1)
      };
    };
  }
  return it[__knownSymbol("iterator")] = () => it, method("next"), "throw" in obj ? method("throw") : it.throw = (x) => {
    throw x;
  }, "return" in obj && method("return"), it;
};
var __forAwait = (obj, it, method) => (it = obj[__knownSymbol("asyncIterator")]) ? it.call(obj) : (obj = obj[__knownSymbol("iterator")](), it = {}, method = (key, fn) => (fn = obj[key]) && (it[key] = (arg) => new Promise((yes, no, done) => (arg = fn.call(obj, arg), done = arg.done, Promise.resolve(arg.value).then((value) => yes({ value, done }), no)))), method("next"), method("return"), it);

// ../../node_modules/.pnpm/retry@0.13.1/node_modules/retry/lib/retry_operation.js
var require_retry_operation = __commonJS({
  "../../node_modules/.pnpm/retry@0.13.1/node_modules/retry/lib/retry_operation.js"(exports2, module2) {
    "use strict";
    function RetryOperation(timeouts, options) {
      if (typeof options === "boolean") {
        options = { forever: options };
      }
      this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));
      this._timeouts = timeouts;
      this._options = options || {};
      this._maxRetryTime = options && options.maxRetryTime || Infinity;
      this._fn = null;
      this._errors = [];
      this._attempts = 1;
      this._operationTimeout = null;
      this._operationTimeoutCb = null;
      this._timeout = null;
      this._operationStart = null;
      this._timer = null;
      if (this._options.forever) {
        this._cachedTimeouts = this._timeouts.slice(0);
      }
    }
    module2.exports = RetryOperation;
    RetryOperation.prototype.reset = function() {
      this._attempts = 1;
      this._timeouts = this._originalTimeouts.slice(0);
    };
    RetryOperation.prototype.stop = function() {
      if (this._timeout) {
        clearTimeout(this._timeout);
      }
      if (this._timer) {
        clearTimeout(this._timer);
      }
      this._timeouts = [];
      this._cachedTimeouts = null;
    };
    RetryOperation.prototype.retry = function(err) {
      if (this._timeout) {
        clearTimeout(this._timeout);
      }
      if (!err) {
        return false;
      }
      var currentTime = (/* @__PURE__ */ new Date()).getTime();
      if (err && currentTime - this._operationStart >= this._maxRetryTime) {
        this._errors.push(err);
        this._errors.unshift(new Error("RetryOperation timeout occurred"));
        return false;
      }
      this._errors.push(err);
      var timeout = this._timeouts.shift();
      if (timeout === void 0) {
        if (this._cachedTimeouts) {
          this._errors.splice(0, this._errors.length - 1);
          timeout = this._cachedTimeouts.slice(-1);
        } else {
          return false;
        }
      }
      var self2 = this;
      this._timer = setTimeout(function() {
        self2._attempts++;
        if (self2._operationTimeoutCb) {
          self2._timeout = setTimeout(function() {
            self2._operationTimeoutCb(self2._attempts);
          }, self2._operationTimeout);
          if (self2._options.unref) {
            self2._timeout.unref();
          }
        }
        self2._fn(self2._attempts);
      }, timeout);
      if (this._options.unref) {
        this._timer.unref();
      }
      return true;
    };
    RetryOperation.prototype.attempt = function(fn, timeoutOps) {
      this._fn = fn;
      if (timeoutOps) {
        if (timeoutOps.timeout) {
          this._operationTimeout = timeoutOps.timeout;
        }
        if (timeoutOps.cb) {
          this._operationTimeoutCb = timeoutOps.cb;
        }
      }
      var self2 = this;
      if (this._operationTimeoutCb) {
        this._timeout = setTimeout(function() {
          self2._operationTimeoutCb();
        }, self2._operationTimeout);
      }
      this._operationStart = (/* @__PURE__ */ new Date()).getTime();
      this._fn(this._attempts);
    };
    RetryOperation.prototype.try = function(fn) {
      console.log("Using RetryOperation.try() is deprecated");
      this.attempt(fn);
    };
    RetryOperation.prototype.start = function(fn) {
      console.log("Using RetryOperation.start() is deprecated");
      this.attempt(fn);
    };
    RetryOperation.prototype.start = RetryOperation.prototype.try;
    RetryOperation.prototype.errors = function() {
      return this._errors;
    };
    RetryOperation.prototype.attempts = function() {
      return this._attempts;
    };
    RetryOperation.prototype.mainError = function() {
      if (this._errors.length === 0) {
        return null;
      }
      var counts = {};
      var mainError = null;
      var mainErrorCount = 0;
      for (var i = 0; i < this._errors.length; i++) {
        var error = this._errors[i];
        var message = error.message;
        var count = (counts[message] || 0) + 1;
        counts[message] = count;
        if (count >= mainErrorCount) {
          mainError = error;
          mainErrorCount = count;
        }
      }
      return mainError;
    };
  }
});

// ../../node_modules/.pnpm/retry@0.13.1/node_modules/retry/lib/retry.js
var require_retry = __commonJS({
  "../../node_modules/.pnpm/retry@0.13.1/node_modules/retry/lib/retry.js"(exports2) {
    "use strict";
    var RetryOperation = require_retry_operation();
    exports2.operation = function(options) {
      var timeouts = exports2.timeouts(options);
      return new RetryOperation(timeouts, {
        forever: options && (options.forever || options.retries === Infinity),
        unref: options && options.unref,
        maxRetryTime: options && options.maxRetryTime
      });
    };
    exports2.timeouts = function(options) {
      if (options instanceof Array) {
        return [].concat(options);
      }
      var opts = {
        retries: 10,
        factor: 2,
        minTimeout: 1 * 1e3,
        maxTimeout: Infinity,
        randomize: false
      };
      for (var key in options) {
        opts[key] = options[key];
      }
      if (opts.minTimeout > opts.maxTimeout) {
        throw new Error("minTimeout is greater than maxTimeout");
      }
      var timeouts = [];
      for (var i = 0; i < opts.retries; i++) {
        timeouts.push(this.createTimeout(i, opts));
      }
      if (options && options.forever && !timeouts.length) {
        timeouts.push(this.createTimeout(i, opts));
      }
      timeouts.sort(function(a, b) {
        return a - b;
      });
      return timeouts;
    };
    exports2.createTimeout = function(attempt, opts) {
      var random = opts.randomize ? Math.random() + 1 : 1;
      var timeout = Math.round(random * Math.max(opts.minTimeout, 1) * Math.pow(opts.factor, attempt));
      timeout = Math.min(timeout, opts.maxTimeout);
      return timeout;
    };
    exports2.wrap = function(obj, options, methods) {
      if (options instanceof Array) {
        methods = options;
        options = null;
      }
      if (!methods) {
        methods = [];
        for (var key in obj) {
          if (typeof obj[key] === "function") {
            methods.push(key);
          }
        }
      }
      for (var i = 0; i < methods.length; i++) {
        var method = methods[i];
        var original = obj[method];
        obj[method] = function retryWrapper(original2) {
          var op = exports2.operation(options);
          var args = Array.prototype.slice.call(arguments, 1);
          var callback = args.pop();
          args.push(function(err) {
            if (op.retry(err)) {
              return;
            }
            if (err) {
              arguments[0] = op.mainError();
            }
            callback.apply(this, arguments);
          });
          op.attempt(function() {
            original2.apply(obj, args);
          });
        }.bind(obj, original);
        obj[method].options = options;
      }
    };
  }
});

// ../../node_modules/.pnpm/retry@0.13.1/node_modules/retry/index.js
var require_retry2 = __commonJS({
  "../../node_modules/.pnpm/retry@0.13.1/node_modules/retry/index.js"(exports2, module2) {
    "use strict";
    module2.exports = require_retry();
  }
});

// ../../node_modules/.pnpm/p-retry@4.6.2/node_modules/p-retry/index.js
var require_p_retry = __commonJS({
  "../../node_modules/.pnpm/p-retry@4.6.2/node_modules/p-retry/index.js"(exports2, module2) {
    "use strict";
    var retry = require_retry2();
    var networkErrorMsgs = [
      "Failed to fetch",
      // Chrome
      "NetworkError when attempting to fetch resource.",
      // Firefox
      "The Internet connection appears to be offline.",
      // Safari
      "Network request failed"
      // `cross-fetch`
    ];
    var AbortError3 = class extends Error {
      constructor(message) {
        super();
        if (message instanceof Error) {
          this.originalError = message;
          ({ message } = message);
        } else {
          this.originalError = new Error(message);
          this.originalError.stack = this.stack;
        }
        this.name = "AbortError";
        this.message = message;
      }
    };
    var decorateErrorWithCounts = (error, attemptNumber, options) => {
      const retriesLeft = options.retries - (attemptNumber - 1);
      error.attemptNumber = attemptNumber;
      error.retriesLeft = retriesLeft;
      return error;
    };
    var isNetworkError = (errorMessage) => networkErrorMsgs.includes(errorMessage);
    var pRetry2 = (input, options) => new Promise((resolve, reject) => {
      options = __spreadValues({
        onFailedAttempt: () => {
        },
        retries: 10
      }, options);
      const operation = retry.operation(options);
      operation.attempt((attemptNumber) => __async(exports2, null, function* () {
        try {
          resolve(yield input(attemptNumber));
        } catch (error) {
          if (!(error instanceof Error)) {
            reject(new TypeError(`Non-error was thrown: "${error}". You should only throw errors.`));
            return;
          }
          if (error instanceof AbortError3) {
            operation.stop();
            reject(error.originalError);
          } else if (error instanceof TypeError && !isNetworkError(error.message)) {
            operation.stop();
            reject(error);
          } else {
            decorateErrorWithCounts(error, attemptNumber, options);
            try {
              yield options.onFailedAttempt(error);
            } catch (error2) {
              reject(error2);
              return;
            }
            if (!operation.retry(error)) {
              reject(operation.mainError());
            }
          }
        }
      }));
    });
    module2.exports = pRetry2;
    module2.exports.default = pRetry2;
    module2.exports.AbortError = AbortError3;
  }
});

// ../../node_modules/.pnpm/varint@6.0.0/node_modules/varint/encode.js
var require_encode = __commonJS({
  "../../node_modules/.pnpm/varint@6.0.0/node_modules/varint/encode.js"(exports2, module2) {
    "use strict";
    module2.exports = encode12;
    var MSB2 = 128;
    var REST2 = 127;
    var MSBALL2 = ~REST2;
    var INT2 = Math.pow(2, 31);
    function encode12(num, out, offset) {
      if (Number.MAX_SAFE_INTEGER && num > Number.MAX_SAFE_INTEGER) {
        encode12.bytes = 0;
        throw new RangeError("Could not encode varint");
      }
      out = out || [];
      offset = offset || 0;
      var oldOffset = offset;
      while (num >= INT2) {
        out[offset++] = num & 255 | MSB2;
        num /= 128;
      }
      while (num & MSBALL2) {
        out[offset++] = num & 255 | MSB2;
        num >>>= 7;
      }
      out[offset] = num | 0;
      encode12.bytes = offset - oldOffset + 1;
      return out;
    }
  }
});

// ../../node_modules/.pnpm/varint@6.0.0/node_modules/varint/decode.js
var require_decode = __commonJS({
  "../../node_modules/.pnpm/varint@6.0.0/node_modules/varint/decode.js"(exports2, module2) {
    "use strict";
    module2.exports = read2;
    var MSB2 = 128;
    var REST2 = 127;
    function read2(buf2, offset) {
      var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf2.length;
      do {
        if (counter >= l || shift > 49) {
          read2.bytes = 0;
          throw new RangeError("Could not decode varint");
        }
        b = buf2[counter++];
        res += shift < 28 ? (b & REST2) << shift : (b & REST2) * Math.pow(2, shift);
        shift += 7;
      } while (b >= MSB2);
      read2.bytes = counter - offset;
      return res;
    }
  }
});

// ../../node_modules/.pnpm/varint@6.0.0/node_modules/varint/length.js
var require_length = __commonJS({
  "../../node_modules/.pnpm/varint@6.0.0/node_modules/varint/length.js"(exports2, module2) {
    "use strict";
    var N12 = Math.pow(2, 7);
    var N22 = Math.pow(2, 14);
    var N32 = Math.pow(2, 21);
    var N42 = Math.pow(2, 28);
    var N52 = Math.pow(2, 35);
    var N62 = Math.pow(2, 42);
    var N72 = Math.pow(2, 49);
    var N82 = Math.pow(2, 56);
    var N92 = Math.pow(2, 63);
    module2.exports = function(value) {
      return value < N12 ? 1 : value < N22 ? 2 : value < N32 ? 3 : value < N42 ? 4 : value < N52 ? 5 : value < N62 ? 6 : value < N72 ? 7 : value < N82 ? 8 : value < N92 ? 9 : 10;
    };
  }
});

// ../../node_modules/.pnpm/varint@6.0.0/node_modules/varint/index.js
var require_varint = __commonJS({
  "../../node_modules/.pnpm/varint@6.0.0/node_modules/varint/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      encode: require_encode(),
      decode: require_decode(),
      encodingLength: require_length()
    };
  }
});

// ../../node_modules/.pnpm/it-last@1.0.6/node_modules/it-last/index.js
var require_it_last = __commonJS({
  "../../node_modules/.pnpm/it-last@1.0.6/node_modules/it-last/index.js"(exports2, module2) {
    "use strict";
    var last2 = (source) => __async(exports2, null, function* () {
      let res;
      try {
        for (var iter = __forAwait(source), more, temp, error; more = !(temp = yield iter.next()).done; more = false) {
          const entry = temp.value;
          res = entry;
        }
      } catch (temp) {
        error = [temp];
      } finally {
        try {
          more && (temp = iter.return) && (yield temp.call(iter));
        } finally {
          if (error)
            throw error[0];
        }
      }
      return res;
    });
    module2.exports = last2;
  }
});

// ../../node_modules/.pnpm/it-pipe@1.1.0/node_modules/it-pipe/index.js
var require_it_pipe = __commonJS({
  "../../node_modules/.pnpm/it-pipe@1.1.0/node_modules/it-pipe/index.js"(exports2, module2) {
    "use strict";
    var rawPipe = (...fns) => {
      let res;
      while (fns.length) {
        res = fns.shift()(res);
      }
      return res;
    };
    var isIterable3 = (obj) => obj && (typeof obj[Symbol.asyncIterator] === "function" || typeof obj[Symbol.iterator] === "function" || typeof obj.next === "function");
    var isDuplex = (obj) => obj && typeof obj.sink === "function" && isIterable3(obj.source);
    var duplexPipelineFn = (duplex) => (source) => {
      duplex.sink(source);
      return duplex.source;
    };
    var pipe3 = (...fns) => {
      if (isDuplex(fns[0])) {
        const duplex = fns[0];
        fns[0] = () => duplex.source;
      } else if (isIterable3(fns[0])) {
        const source = fns[0];
        fns[0] = () => source;
      }
      if (fns.length > 1) {
        if (isDuplex(fns[fns.length - 1])) {
          fns[fns.length - 1] = fns[fns.length - 1].sink;
        }
      }
      if (fns.length > 2) {
        for (let i = 1; i < fns.length - 1; i++) {
          if (isDuplex(fns[i])) {
            fns[i] = duplexPipelineFn(fns[i]);
          }
        }
      }
      return rawPipe(...fns);
    };
    module2.exports = pipe3;
    module2.exports.pipe = pipe3;
    module2.exports.rawPipe = rawPipe;
    module2.exports.isIterable = isIterable3;
    module2.exports.isDuplex = isDuplex;
  }
});

// ../../node_modules/.pnpm/it-batch@1.0.9/node_modules/it-batch/index.js
var require_it_batch = __commonJS({
  "../../node_modules/.pnpm/it-batch@1.0.9/node_modules/it-batch/index.js"(exports2, module2) {
    "use strict";
    function batch3(source, size = 1) {
      return __asyncGenerator(this, null, function* () {
        let things = [];
        if (size < 1) {
          size = 1;
        }
        try {
          for (var iter = __forAwait(source), more, temp, error; more = !(temp = yield new __await(iter.next())).done; more = false) {
            const thing = temp.value;
            things.push(thing);
            while (things.length >= size) {
              yield things.slice(0, size);
              things = things.slice(size);
            }
          }
        } catch (temp) {
          error = [temp];
        } finally {
          try {
            more && (temp = iter.return) && (yield new __await(temp.call(iter)));
          } finally {
            if (error)
              throw error[0];
          }
        }
        while (things.length) {
          yield things.slice(0, size);
          things = things.slice(size);
        }
      });
    }
    module2.exports = batch3;
  }
});

// ../../node_modules/.pnpm/it-parallel-batch@1.0.11/node_modules/it-parallel-batch/index.js
var require_it_parallel_batch = __commonJS({
  "../../node_modules/.pnpm/it-parallel-batch@1.0.11/node_modules/it-parallel-batch/index.js"(exports2, module2) {
    "use strict";
    var batch3 = require_it_batch();
    function parallelBatch3(source, size = 1) {
      return __asyncGenerator(this, null, function* () {
        try {
          for (var iter = __forAwait(batch3(source, size)), more, temp, error; more = !(temp = yield new __await(iter.next())).done; more = false) {
            const tasks = temp.value;
            const things = tasks.map(
              /**
               * @param {() => Promise<T>} p
               */
              (p) => {
                return p().then((value) => ({ ok: true, value }), (err) => ({ ok: false, err }));
              }
            );
            for (let i = 0; i < things.length; i++) {
              const result = yield new __await(things[i]);
              if (result.ok) {
                yield result.value;
              } else {
                throw result.err;
              }
            }
          }
        } catch (temp) {
          error = [temp];
        } finally {
          try {
            more && (temp = iter.return) && (yield new __await(temp.call(iter)));
          } finally {
            if (error)
              throw error[0];
          }
        }
      });
    }
    module2.exports = parallelBatch3;
  }
});

// ../../node_modules/.pnpm/is-plain-obj@2.1.0/node_modules/is-plain-obj/index.js
var require_is_plain_obj = __commonJS({
  "../../node_modules/.pnpm/is-plain-obj@2.1.0/node_modules/is-plain-obj/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (value) => {
      if (Object.prototype.toString.call(value) !== "[object Object]") {
        return false;
      }
      const prototype = Object.getPrototypeOf(value);
      return prototype === null || prototype === Object.prototype;
    };
  }
});

// ../../node_modules/.pnpm/merge-options@3.0.4/node_modules/merge-options/index.js
var require_merge_options = __commonJS({
  "../../node_modules/.pnpm/merge-options@3.0.4/node_modules/merge-options/index.js"(exports2, module2) {
    "use strict";
    var isOptionObject = require_is_plain_obj();
    var { hasOwnProperty } = Object.prototype;
    var { propertyIsEnumerable } = Object;
    var defineProperty = (object, name5, value) => Object.defineProperty(object, name5, {
      value,
      writable: true,
      enumerable: true,
      configurable: true
    });
    var globalThis2 = exports2;
    var defaultMergeOptions = {
      concatArrays: false,
      ignoreUndefined: false
    };
    var getEnumerableOwnPropertyKeys = (value) => {
      const keys = [];
      for (const key in value) {
        if (hasOwnProperty.call(value, key)) {
          keys.push(key);
        }
      }
      if (Object.getOwnPropertySymbols) {
        const symbols = Object.getOwnPropertySymbols(value);
        for (const symbol of symbols) {
          if (propertyIsEnumerable.call(value, symbol)) {
            keys.push(symbol);
          }
        }
      }
      return keys;
    };
    function clone2(value) {
      if (Array.isArray(value)) {
        return cloneArray(value);
      }
      if (isOptionObject(value)) {
        return cloneOptionObject(value);
      }
      return value;
    }
    function cloneArray(array) {
      const result = array.slice(0, 0);
      getEnumerableOwnPropertyKeys(array).forEach((key) => {
        defineProperty(result, key, clone2(array[key]));
      });
      return result;
    }
    function cloneOptionObject(object) {
      const result = Object.getPrototypeOf(object) === null ? /* @__PURE__ */ Object.create(null) : {};
      getEnumerableOwnPropertyKeys(object).forEach((key) => {
        defineProperty(result, key, clone2(object[key]));
      });
      return result;
    }
    var mergeKeys = (merged, source, keys, config) => {
      keys.forEach((key) => {
        if (typeof source[key] === "undefined" && config.ignoreUndefined) {
          return;
        }
        if (key in merged && merged[key] !== Object.getPrototypeOf(merged)) {
          defineProperty(merged, key, merge(merged[key], source[key], config));
        } else {
          defineProperty(merged, key, clone2(source[key]));
        }
      });
      return merged;
    };
    var concatArrays = (merged, source, config) => {
      let result = merged.slice(0, 0);
      let resultIndex = 0;
      [merged, source].forEach((array) => {
        const indices = [];
        for (let k = 0; k < array.length; k++) {
          if (!hasOwnProperty.call(array, k)) {
            continue;
          }
          indices.push(String(k));
          if (array === merged) {
            defineProperty(result, resultIndex++, array[k]);
          } else {
            defineProperty(result, resultIndex++, clone2(array[k]));
          }
        }
        result = mergeKeys(result, array, getEnumerableOwnPropertyKeys(array).filter((key) => !indices.includes(key)), config);
      });
      return result;
    };
    function merge(merged, source, config) {
      if (config.concatArrays && Array.isArray(merged) && Array.isArray(source)) {
        return concatArrays(merged, source, config);
      }
      if (!isOptionObject(source) || !isOptionObject(merged)) {
        return clone2(source);
      }
      return mergeKeys(merged, source, getEnumerableOwnPropertyKeys(source), config);
    }
    module2.exports = function(...options) {
      const config = merge(clone2(defaultMergeOptions), this !== globalThis2 && this || {}, defaultMergeOptions);
      let merged = { _: {} };
      for (const option of options) {
        if (option === void 0) {
          continue;
        }
        if (!isOptionObject(option)) {
          throw new TypeError("`" + option + "` is not an Option Object");
        }
        merged = merge(merged, { _: option }, config);
      }
      return merged._;
    };
  }
});

// ../../node_modules/.pnpm/murmurhash3js-revisited@3.0.0/node_modules/murmurhash3js-revisited/lib/murmurHash3js.js
var require_murmurHash3js = __commonJS({
  "../../node_modules/.pnpm/murmurhash3js-revisited@3.0.0/node_modules/murmurhash3js-revisited/lib/murmurHash3js.js"(exports2, module2) {
    "use strict";
    (function(root, undefined2) {
      "use strict";
      var library = {
        "version": "3.0.0",
        "x86": {},
        "x64": {},
        "inputValidation": true
      };
      function _validBytes(bytes) {
        if (!Array.isArray(bytes) && !ArrayBuffer.isView(bytes)) {
          return false;
        }
        for (var i = 0; i < bytes.length; i++) {
          if (!Number.isInteger(bytes[i]) || bytes[i] < 0 || bytes[i] > 255) {
            return false;
          }
        }
        return true;
      }
      function _x86Multiply(m, n) {
        return (m & 65535) * n + (((m >>> 16) * n & 65535) << 16);
      }
      function _x86Rotl(m, n) {
        return m << n | m >>> 32 - n;
      }
      function _x86Fmix(h) {
        h ^= h >>> 16;
        h = _x86Multiply(h, 2246822507);
        h ^= h >>> 13;
        h = _x86Multiply(h, 3266489909);
        h ^= h >>> 16;
        return h;
      }
      function _x64Add(m, n) {
        m = [m[0] >>> 16, m[0] & 65535, m[1] >>> 16, m[1] & 65535];
        n = [n[0] >>> 16, n[0] & 65535, n[1] >>> 16, n[1] & 65535];
        var o = [0, 0, 0, 0];
        o[3] += m[3] + n[3];
        o[2] += o[3] >>> 16;
        o[3] &= 65535;
        o[2] += m[2] + n[2];
        o[1] += o[2] >>> 16;
        o[2] &= 65535;
        o[1] += m[1] + n[1];
        o[0] += o[1] >>> 16;
        o[1] &= 65535;
        o[0] += m[0] + n[0];
        o[0] &= 65535;
        return [o[0] << 16 | o[1], o[2] << 16 | o[3]];
      }
      function _x64Multiply(m, n) {
        m = [m[0] >>> 16, m[0] & 65535, m[1] >>> 16, m[1] & 65535];
        n = [n[0] >>> 16, n[0] & 65535, n[1] >>> 16, n[1] & 65535];
        var o = [0, 0, 0, 0];
        o[3] += m[3] * n[3];
        o[2] += o[3] >>> 16;
        o[3] &= 65535;
        o[2] += m[2] * n[3];
        o[1] += o[2] >>> 16;
        o[2] &= 65535;
        o[2] += m[3] * n[2];
        o[1] += o[2] >>> 16;
        o[2] &= 65535;
        o[1] += m[1] * n[3];
        o[0] += o[1] >>> 16;
        o[1] &= 65535;
        o[1] += m[2] * n[2];
        o[0] += o[1] >>> 16;
        o[1] &= 65535;
        o[1] += m[3] * n[1];
        o[0] += o[1] >>> 16;
        o[1] &= 65535;
        o[0] += m[0] * n[3] + m[1] * n[2] + m[2] * n[1] + m[3] * n[0];
        o[0] &= 65535;
        return [o[0] << 16 | o[1], o[2] << 16 | o[3]];
      }
      function _x64Rotl(m, n) {
        n %= 64;
        if (n === 32) {
          return [m[1], m[0]];
        } else if (n < 32) {
          return [m[0] << n | m[1] >>> 32 - n, m[1] << n | m[0] >>> 32 - n];
        } else {
          n -= 32;
          return [m[1] << n | m[0] >>> 32 - n, m[0] << n | m[1] >>> 32 - n];
        }
      }
      function _x64LeftShift(m, n) {
        n %= 64;
        if (n === 0) {
          return m;
        } else if (n < 32) {
          return [m[0] << n | m[1] >>> 32 - n, m[1] << n];
        } else {
          return [m[1] << n - 32, 0];
        }
      }
      function _x64Xor(m, n) {
        return [m[0] ^ n[0], m[1] ^ n[1]];
      }
      function _x64Fmix(h) {
        h = _x64Xor(h, [0, h[0] >>> 1]);
        h = _x64Multiply(h, [4283543511, 3981806797]);
        h = _x64Xor(h, [0, h[0] >>> 1]);
        h = _x64Multiply(h, [3301882366, 444984403]);
        h = _x64Xor(h, [0, h[0] >>> 1]);
        return h;
      }
      library.x86.hash32 = function(bytes, seed) {
        if (library.inputValidation && !_validBytes(bytes)) {
          return undefined2;
        }
        seed = seed || 0;
        var remainder = bytes.length % 4;
        var blocks = bytes.length - remainder;
        var h1 = seed;
        var k1 = 0;
        var c1 = 3432918353;
        var c2 = 461845907;
        for (var i = 0; i < blocks; i = i + 4) {
          k1 = bytes[i] | bytes[i + 1] << 8 | bytes[i + 2] << 16 | bytes[i + 3] << 24;
          k1 = _x86Multiply(k1, c1);
          k1 = _x86Rotl(k1, 15);
          k1 = _x86Multiply(k1, c2);
          h1 ^= k1;
          h1 = _x86Rotl(h1, 13);
          h1 = _x86Multiply(h1, 5) + 3864292196;
        }
        k1 = 0;
        switch (remainder) {
          case 3:
            k1 ^= bytes[i + 2] << 16;
          case 2:
            k1 ^= bytes[i + 1] << 8;
          case 1:
            k1 ^= bytes[i];
            k1 = _x86Multiply(k1, c1);
            k1 = _x86Rotl(k1, 15);
            k1 = _x86Multiply(k1, c2);
            h1 ^= k1;
        }
        h1 ^= bytes.length;
        h1 = _x86Fmix(h1);
        return h1 >>> 0;
      };
      library.x86.hash128 = function(bytes, seed) {
        if (library.inputValidation && !_validBytes(bytes)) {
          return undefined2;
        }
        seed = seed || 0;
        var remainder = bytes.length % 16;
        var blocks = bytes.length - remainder;
        var h1 = seed;
        var h2 = seed;
        var h3 = seed;
        var h4 = seed;
        var k1 = 0;
        var k2 = 0;
        var k3 = 0;
        var k4 = 0;
        var c1 = 597399067;
        var c2 = 2869860233;
        var c3 = 951274213;
        var c4 = 2716044179;
        for (var i = 0; i < blocks; i = i + 16) {
          k1 = bytes[i] | bytes[i + 1] << 8 | bytes[i + 2] << 16 | bytes[i + 3] << 24;
          k2 = bytes[i + 4] | bytes[i + 5] << 8 | bytes[i + 6] << 16 | bytes[i + 7] << 24;
          k3 = bytes[i + 8] | bytes[i + 9] << 8 | bytes[i + 10] << 16 | bytes[i + 11] << 24;
          k4 = bytes[i + 12] | bytes[i + 13] << 8 | bytes[i + 14] << 16 | bytes[i + 15] << 24;
          k1 = _x86Multiply(k1, c1);
          k1 = _x86Rotl(k1, 15);
          k1 = _x86Multiply(k1, c2);
          h1 ^= k1;
          h1 = _x86Rotl(h1, 19);
          h1 += h2;
          h1 = _x86Multiply(h1, 5) + 1444728091;
          k2 = _x86Multiply(k2, c2);
          k2 = _x86Rotl(k2, 16);
          k2 = _x86Multiply(k2, c3);
          h2 ^= k2;
          h2 = _x86Rotl(h2, 17);
          h2 += h3;
          h2 = _x86Multiply(h2, 5) + 197830471;
          k3 = _x86Multiply(k3, c3);
          k3 = _x86Rotl(k3, 17);
          k3 = _x86Multiply(k3, c4);
          h3 ^= k3;
          h3 = _x86Rotl(h3, 15);
          h3 += h4;
          h3 = _x86Multiply(h3, 5) + 2530024501;
          k4 = _x86Multiply(k4, c4);
          k4 = _x86Rotl(k4, 18);
          k4 = _x86Multiply(k4, c1);
          h4 ^= k4;
          h4 = _x86Rotl(h4, 13);
          h4 += h1;
          h4 = _x86Multiply(h4, 5) + 850148119;
        }
        k1 = 0;
        k2 = 0;
        k3 = 0;
        k4 = 0;
        switch (remainder) {
          case 15:
            k4 ^= bytes[i + 14] << 16;
          case 14:
            k4 ^= bytes[i + 13] << 8;
          case 13:
            k4 ^= bytes[i + 12];
            k4 = _x86Multiply(k4, c4);
            k4 = _x86Rotl(k4, 18);
            k4 = _x86Multiply(k4, c1);
            h4 ^= k4;
          case 12:
            k3 ^= bytes[i + 11] << 24;
          case 11:
            k3 ^= bytes[i + 10] << 16;
          case 10:
            k3 ^= bytes[i + 9] << 8;
          case 9:
            k3 ^= bytes[i + 8];
            k3 = _x86Multiply(k3, c3);
            k3 = _x86Rotl(k3, 17);
            k3 = _x86Multiply(k3, c4);
            h3 ^= k3;
          case 8:
            k2 ^= bytes[i + 7] << 24;
          case 7:
            k2 ^= bytes[i + 6] << 16;
          case 6:
            k2 ^= bytes[i + 5] << 8;
          case 5:
            k2 ^= bytes[i + 4];
            k2 = _x86Multiply(k2, c2);
            k2 = _x86Rotl(k2, 16);
            k2 = _x86Multiply(k2, c3);
            h2 ^= k2;
          case 4:
            k1 ^= bytes[i + 3] << 24;
          case 3:
            k1 ^= bytes[i + 2] << 16;
          case 2:
            k1 ^= bytes[i + 1] << 8;
          case 1:
            k1 ^= bytes[i];
            k1 = _x86Multiply(k1, c1);
            k1 = _x86Rotl(k1, 15);
            k1 = _x86Multiply(k1, c2);
            h1 ^= k1;
        }
        h1 ^= bytes.length;
        h2 ^= bytes.length;
        h3 ^= bytes.length;
        h4 ^= bytes.length;
        h1 += h2;
        h1 += h3;
        h1 += h4;
        h2 += h1;
        h3 += h1;
        h4 += h1;
        h1 = _x86Fmix(h1);
        h2 = _x86Fmix(h2);
        h3 = _x86Fmix(h3);
        h4 = _x86Fmix(h4);
        h1 += h2;
        h1 += h3;
        h1 += h4;
        h2 += h1;
        h3 += h1;
        h4 += h1;
        return ("00000000" + (h1 >>> 0).toString(16)).slice(-8) + ("00000000" + (h2 >>> 0).toString(16)).slice(-8) + ("00000000" + (h3 >>> 0).toString(16)).slice(-8) + ("00000000" + (h4 >>> 0).toString(16)).slice(-8);
      };
      library.x64.hash128 = function(bytes, seed) {
        if (library.inputValidation && !_validBytes(bytes)) {
          return undefined2;
        }
        seed = seed || 0;
        var remainder = bytes.length % 16;
        var blocks = bytes.length - remainder;
        var h1 = [0, seed];
        var h2 = [0, seed];
        var k1 = [0, 0];
        var k2 = [0, 0];
        var c1 = [2277735313, 289559509];
        var c2 = [1291169091, 658871167];
        for (var i = 0; i < blocks; i = i + 16) {
          k1 = [bytes[i + 4] | bytes[i + 5] << 8 | bytes[i + 6] << 16 | bytes[i + 7] << 24, bytes[i] | bytes[i + 1] << 8 | bytes[i + 2] << 16 | bytes[i + 3] << 24];
          k2 = [bytes[i + 12] | bytes[i + 13] << 8 | bytes[i + 14] << 16 | bytes[i + 15] << 24, bytes[i + 8] | bytes[i + 9] << 8 | bytes[i + 10] << 16 | bytes[i + 11] << 24];
          k1 = _x64Multiply(k1, c1);
          k1 = _x64Rotl(k1, 31);
          k1 = _x64Multiply(k1, c2);
          h1 = _x64Xor(h1, k1);
          h1 = _x64Rotl(h1, 27);
          h1 = _x64Add(h1, h2);
          h1 = _x64Add(_x64Multiply(h1, [0, 5]), [0, 1390208809]);
          k2 = _x64Multiply(k2, c2);
          k2 = _x64Rotl(k2, 33);
          k2 = _x64Multiply(k2, c1);
          h2 = _x64Xor(h2, k2);
          h2 = _x64Rotl(h2, 31);
          h2 = _x64Add(h2, h1);
          h2 = _x64Add(_x64Multiply(h2, [0, 5]), [0, 944331445]);
        }
        k1 = [0, 0];
        k2 = [0, 0];
        switch (remainder) {
          case 15:
            k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i + 14]], 48));
          case 14:
            k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i + 13]], 40));
          case 13:
            k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i + 12]], 32));
          case 12:
            k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i + 11]], 24));
          case 11:
            k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i + 10]], 16));
          case 10:
            k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i + 9]], 8));
          case 9:
            k2 = _x64Xor(k2, [0, bytes[i + 8]]);
            k2 = _x64Multiply(k2, c2);
            k2 = _x64Rotl(k2, 33);
            k2 = _x64Multiply(k2, c1);
            h2 = _x64Xor(h2, k2);
          case 8:
            k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i + 7]], 56));
          case 7:
            k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i + 6]], 48));
          case 6:
            k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i + 5]], 40));
          case 5:
            k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i + 4]], 32));
          case 4:
            k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i + 3]], 24));
          case 3:
            k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i + 2]], 16));
          case 2:
            k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i + 1]], 8));
          case 1:
            k1 = _x64Xor(k1, [0, bytes[i]]);
            k1 = _x64Multiply(k1, c1);
            k1 = _x64Rotl(k1, 31);
            k1 = _x64Multiply(k1, c2);
            h1 = _x64Xor(h1, k1);
        }
        h1 = _x64Xor(h1, [0, bytes.length]);
        h2 = _x64Xor(h2, [0, bytes.length]);
        h1 = _x64Add(h1, h2);
        h2 = _x64Add(h2, h1);
        h1 = _x64Fmix(h1);
        h2 = _x64Fmix(h2);
        h1 = _x64Add(h1, h2);
        h2 = _x64Add(h2, h1);
        return ("00000000" + (h1[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (h1[1] >>> 0).toString(16)).slice(-8) + ("00000000" + (h2[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (h2[1] >>> 0).toString(16)).slice(-8);
      };
      if (typeof exports2 !== "undefined") {
        if (typeof module2 !== "undefined" && module2.exports) {
          exports2 = module2.exports = library;
        }
        exports2.murmurHash3 = library;
      } else if (typeof define === "function" && define.amd) {
        define([], function() {
          return library;
        });
      } else {
        library._murmurHash3 = root.murmurHash3;
        library.noConflict = function() {
          root.murmurHash3 = library._murmurHash3;
          library._murmurHash3 = undefined2;
          library.noConflict = undefined2;
          return library;
        };
        root.murmurHash3 = library;
      }
    })(exports2);
  }
});

// ../../node_modules/.pnpm/murmurhash3js-revisited@3.0.0/node_modules/murmurhash3js-revisited/index.js
var require_murmurhash3js_revisited = __commonJS({
  "../../node_modules/.pnpm/murmurhash3js-revisited@3.0.0/node_modules/murmurhash3js-revisited/index.js"(exports2, module2) {
    "use strict";
    module2.exports = require_murmurHash3js();
  }
});

// ../../node_modules/.pnpm/err-code@3.0.1/node_modules/err-code/index.js
var require_err_code = __commonJS({
  "../../node_modules/.pnpm/err-code@3.0.1/node_modules/err-code/index.js"(exports2, module2) {
    "use strict";
    function assign(obj, props) {
      for (const key in props) {
        Object.defineProperty(obj, key, {
          value: props[key],
          enumerable: true,
          configurable: true
        });
      }
      return obj;
    }
    function createError(err, code5, props) {
      if (!err || typeof err === "string") {
        throw new TypeError("Please pass an Error to err-code");
      }
      if (!props) {
        props = {};
      }
      if (typeof code5 === "object") {
        props = code5;
        code5 = "";
      }
      if (code5) {
        props.code = code5;
      }
      try {
        return assign(err, props);
      } catch (_) {
        props.message = err.message;
        props.stack = err.stack;
        const ErrClass = function() {
        };
        ErrClass.prototype = Object.create(Object.getPrototypeOf(err));
        const output = assign(new ErrClass(), props);
        return output;
      }
    }
    module2.exports = createError;
  }
});

// ../../node_modules/.pnpm/@protobufjs+aspromise@1.1.2/node_modules/@protobufjs/aspromise/index.js
var require_aspromise = __commonJS({
  "../../node_modules/.pnpm/@protobufjs+aspromise@1.1.2/node_modules/@protobufjs/aspromise/index.js"(exports2, module2) {
    "use strict";
    module2.exports = asPromise;
    function asPromise(fn, ctx) {
      var params = new Array(arguments.length - 1), offset = 0, index = 2, pending = true;
      while (index < arguments.length)
        params[offset++] = arguments[index++];
      return new Promise(function executor(resolve, reject) {
        params[offset] = function callback(err) {
          if (pending) {
            pending = false;
            if (err)
              reject(err);
            else {
              var params2 = new Array(arguments.length - 1), offset2 = 0;
              while (offset2 < params2.length)
                params2[offset2++] = arguments[offset2];
              resolve.apply(null, params2);
            }
          }
        };
        try {
          fn.apply(ctx || null, params);
        } catch (err) {
          if (pending) {
            pending = false;
            reject(err);
          }
        }
      });
    }
  }
});

// ../../node_modules/.pnpm/@protobufjs+base64@1.1.2/node_modules/@protobufjs/base64/index.js
var require_base64 = __commonJS({
  "../../node_modules/.pnpm/@protobufjs+base64@1.1.2/node_modules/@protobufjs/base64/index.js"(exports2) {
    "use strict";
    var base642 = exports2;
    base642.length = function length2(string2) {
      var p = string2.length;
      if (!p)
        return 0;
      var n = 0;
      while (--p % 4 > 1 && string2.charAt(p) === "=")
        ++n;
      return Math.ceil(string2.length * 3) / 4 - n;
    };
    var b64 = new Array(64);
    var s64 = new Array(123);
    for (i = 0; i < 64; )
      s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;
    var i;
    base642.encode = function encode12(buffer2, start, end) {
      var parts = null, chunk = [];
      var i2 = 0, j = 0, t;
      while (start < end) {
        var b = buffer2[start++];
        switch (j) {
          case 0:
            chunk[i2++] = b64[b >> 2];
            t = (b & 3) << 4;
            j = 1;
            break;
          case 1:
            chunk[i2++] = b64[t | b >> 4];
            t = (b & 15) << 2;
            j = 2;
            break;
          case 2:
            chunk[i2++] = b64[t | b >> 6];
            chunk[i2++] = b64[b & 63];
            j = 0;
            break;
        }
        if (i2 > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i2 = 0;
        }
      }
      if (j) {
        chunk[i2++] = b64[t];
        chunk[i2++] = 61;
        if (j === 1)
          chunk[i2++] = 61;
      }
      if (parts) {
        if (i2)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i2)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i2));
    };
    var invalidEncoding = "invalid encoding";
    base642.decode = function decode12(string2, buffer2, offset) {
      var start = offset;
      var j = 0, t;
      for (var i2 = 0; i2 < string2.length; ) {
        var c = string2.charCodeAt(i2++);
        if (c === 61 && j > 1)
          break;
        if ((c = s64[c]) === void 0)
          throw Error(invalidEncoding);
        switch (j) {
          case 0:
            t = c;
            j = 1;
            break;
          case 1:
            buffer2[offset++] = t << 2 | (c & 48) >> 4;
            t = c;
            j = 2;
            break;
          case 2:
            buffer2[offset++] = (t & 15) << 4 | (c & 60) >> 2;
            t = c;
            j = 3;
            break;
          case 3:
            buffer2[offset++] = (t & 3) << 6 | c;
            j = 0;
            break;
        }
      }
      if (j === 1)
        throw Error(invalidEncoding);
      return offset - start;
    };
    base642.test = function test(string2) {
      return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string2);
    };
  }
});

// ../../node_modules/.pnpm/@protobufjs+eventemitter@1.1.0/node_modules/@protobufjs/eventemitter/index.js
var require_eventemitter = __commonJS({
  "../../node_modules/.pnpm/@protobufjs+eventemitter@1.1.0/node_modules/@protobufjs/eventemitter/index.js"(exports2, module2) {
    "use strict";
    module2.exports = EventEmitter;
    function EventEmitter() {
      this._listeners = {};
    }
    EventEmitter.prototype.on = function on(evt, fn, ctx) {
      (this._listeners[evt] || (this._listeners[evt] = [])).push({
        fn,
        ctx: ctx || this
      });
      return this;
    };
    EventEmitter.prototype.off = function off(evt, fn) {
      if (evt === void 0)
        this._listeners = {};
      else {
        if (fn === void 0)
          this._listeners[evt] = [];
        else {
          var listeners = this._listeners[evt];
          for (var i = 0; i < listeners.length; )
            if (listeners[i].fn === fn)
              listeners.splice(i, 1);
            else
              ++i;
        }
      }
      return this;
    };
    EventEmitter.prototype.emit = function emit(evt) {
      var listeners = this._listeners[evt];
      if (listeners) {
        var args = [], i = 1;
        for (; i < arguments.length; )
          args.push(arguments[i++]);
        for (i = 0; i < listeners.length; )
          listeners[i].fn.apply(listeners[i++].ctx, args);
      }
      return this;
    };
  }
});

// ../../node_modules/.pnpm/@protobufjs+float@1.0.2/node_modules/@protobufjs/float/index.js
var require_float = __commonJS({
  "../../node_modules/.pnpm/@protobufjs+float@1.0.2/node_modules/@protobufjs/float/index.js"(exports2, module2) {
    "use strict";
    module2.exports = factory(factory);
    function factory(exports3) {
      if (typeof Float32Array !== "undefined")
        (function() {
          var f32 = new Float32Array([-0]), f8b = new Uint8Array(f32.buffer), le = f8b[3] === 128;
          function writeFloat_f32_cpy(val, buf2, pos) {
            f32[0] = val;
            buf2[pos] = f8b[0];
            buf2[pos + 1] = f8b[1];
            buf2[pos + 2] = f8b[2];
            buf2[pos + 3] = f8b[3];
          }
          function writeFloat_f32_rev(val, buf2, pos) {
            f32[0] = val;
            buf2[pos] = f8b[3];
            buf2[pos + 1] = f8b[2];
            buf2[pos + 2] = f8b[1];
            buf2[pos + 3] = f8b[0];
          }
          exports3.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
          exports3.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;
          function readFloat_f32_cpy(buf2, pos) {
            f8b[0] = buf2[pos];
            f8b[1] = buf2[pos + 1];
            f8b[2] = buf2[pos + 2];
            f8b[3] = buf2[pos + 3];
            return f32[0];
          }
          function readFloat_f32_rev(buf2, pos) {
            f8b[3] = buf2[pos];
            f8b[2] = buf2[pos + 1];
            f8b[1] = buf2[pos + 2];
            f8b[0] = buf2[pos + 3];
            return f32[0];
          }
          exports3.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
          exports3.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;
        })();
      else
        (function() {
          function writeFloat_ieee754(writeUint, val, buf2, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
              val = -val;
            if (val === 0)
              writeUint(1 / val > 0 ? (
                /* positive */
                0
              ) : (
                /* negative 0 */
                2147483648
              ), buf2, pos);
            else if (isNaN(val))
              writeUint(2143289344, buf2, pos);
            else if (val > 34028234663852886e22)
              writeUint((sign << 31 | 2139095040) >>> 0, buf2, pos);
            else if (val < 11754943508222875e-54)
              writeUint((sign << 31 | Math.round(val / 1401298464324817e-60)) >>> 0, buf2, pos);
            else {
              var exponent = Math.floor(Math.log(val) / Math.LN2), mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
              writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf2, pos);
            }
          }
          exports3.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
          exports3.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);
          function readFloat_ieee754(readUint, buf2, pos) {
            var uint = readUint(buf2, pos), sign = (uint >> 31) * 2 + 1, exponent = uint >>> 23 & 255, mantissa = uint & 8388607;
            return exponent === 255 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 1401298464324817e-60 * mantissa : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
          }
          exports3.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
          exports3.readFloatBE = readFloat_ieee754.bind(null, readUintBE);
        })();
      if (typeof Float64Array !== "undefined")
        (function() {
          var f64 = new Float64Array([-0]), f8b = new Uint8Array(f64.buffer), le = f8b[7] === 128;
          function writeDouble_f64_cpy(val, buf2, pos) {
            f64[0] = val;
            buf2[pos] = f8b[0];
            buf2[pos + 1] = f8b[1];
            buf2[pos + 2] = f8b[2];
            buf2[pos + 3] = f8b[3];
            buf2[pos + 4] = f8b[4];
            buf2[pos + 5] = f8b[5];
            buf2[pos + 6] = f8b[6];
            buf2[pos + 7] = f8b[7];
          }
          function writeDouble_f64_rev(val, buf2, pos) {
            f64[0] = val;
            buf2[pos] = f8b[7];
            buf2[pos + 1] = f8b[6];
            buf2[pos + 2] = f8b[5];
            buf2[pos + 3] = f8b[4];
            buf2[pos + 4] = f8b[3];
            buf2[pos + 5] = f8b[2];
            buf2[pos + 6] = f8b[1];
            buf2[pos + 7] = f8b[0];
          }
          exports3.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
          exports3.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;
          function readDouble_f64_cpy(buf2, pos) {
            f8b[0] = buf2[pos];
            f8b[1] = buf2[pos + 1];
            f8b[2] = buf2[pos + 2];
            f8b[3] = buf2[pos + 3];
            f8b[4] = buf2[pos + 4];
            f8b[5] = buf2[pos + 5];
            f8b[6] = buf2[pos + 6];
            f8b[7] = buf2[pos + 7];
            return f64[0];
          }
          function readDouble_f64_rev(buf2, pos) {
            f8b[7] = buf2[pos];
            f8b[6] = buf2[pos + 1];
            f8b[5] = buf2[pos + 2];
            f8b[4] = buf2[pos + 3];
            f8b[3] = buf2[pos + 4];
            f8b[2] = buf2[pos + 5];
            f8b[1] = buf2[pos + 6];
            f8b[0] = buf2[pos + 7];
            return f64[0];
          }
          exports3.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
          exports3.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;
        })();
      else
        (function() {
          function writeDouble_ieee754(writeUint, off0, off1, val, buf2, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
              val = -val;
            if (val === 0) {
              writeUint(0, buf2, pos + off0);
              writeUint(1 / val > 0 ? (
                /* positive */
                0
              ) : (
                /* negative 0 */
                2147483648
              ), buf2, pos + off1);
            } else if (isNaN(val)) {
              writeUint(0, buf2, pos + off0);
              writeUint(2146959360, buf2, pos + off1);
            } else if (val > 17976931348623157e292) {
              writeUint(0, buf2, pos + off0);
              writeUint((sign << 31 | 2146435072) >>> 0, buf2, pos + off1);
            } else {
              var mantissa;
              if (val < 22250738585072014e-324) {
                mantissa = val / 5e-324;
                writeUint(mantissa >>> 0, buf2, pos + off0);
                writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf2, pos + off1);
              } else {
                var exponent = Math.floor(Math.log(val) / Math.LN2);
                if (exponent === 1024)
                  exponent = 1023;
                mantissa = val * Math.pow(2, -exponent);
                writeUint(mantissa * 4503599627370496 >>> 0, buf2, pos + off0);
                writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf2, pos + off1);
              }
            }
          }
          exports3.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
          exports3.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);
          function readDouble_ieee754(readUint, off0, off1, buf2, pos) {
            var lo = readUint(buf2, pos + off0), hi = readUint(buf2, pos + off1);
            var sign = (hi >> 31) * 2 + 1, exponent = hi >>> 20 & 2047, mantissa = 4294967296 * (hi & 1048575) + lo;
            return exponent === 2047 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 5e-324 * mantissa : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
          }
          exports3.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
          exports3.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);
        })();
      return exports3;
    }
    function writeUintLE(val, buf2, pos) {
      buf2[pos] = val & 255;
      buf2[pos + 1] = val >>> 8 & 255;
      buf2[pos + 2] = val >>> 16 & 255;
      buf2[pos + 3] = val >>> 24;
    }
    function writeUintBE(val, buf2, pos) {
      buf2[pos] = val >>> 24;
      buf2[pos + 1] = val >>> 16 & 255;
      buf2[pos + 2] = val >>> 8 & 255;
      buf2[pos + 3] = val & 255;
    }
    function readUintLE(buf2, pos) {
      return (buf2[pos] | buf2[pos + 1] << 8 | buf2[pos + 2] << 16 | buf2[pos + 3] << 24) >>> 0;
    }
    function readUintBE(buf2, pos) {
      return (buf2[pos] << 24 | buf2[pos + 1] << 16 | buf2[pos + 2] << 8 | buf2[pos + 3]) >>> 0;
    }
  }
});

// ../../node_modules/.pnpm/@protobufjs+inquire@1.1.0/node_modules/@protobufjs/inquire/index.js
var require_inquire = __commonJS({
  "../../node_modules/.pnpm/@protobufjs+inquire@1.1.0/node_modules/@protobufjs/inquire/index.js"(exports, module) {
    "use strict";
    module.exports = inquire;
    function inquire(moduleName) {
      try {
        var mod = eval("quire".replace(/^/, "re"))(moduleName);
        if (mod && (mod.length || Object.keys(mod).length))
          return mod;
      } catch (e) {
      }
      return null;
    }
  }
});

// ../../node_modules/.pnpm/@protobufjs+utf8@1.1.0/node_modules/@protobufjs/utf8/index.js
var require_utf8 = __commonJS({
  "../../node_modules/.pnpm/@protobufjs+utf8@1.1.0/node_modules/@protobufjs/utf8/index.js"(exports2) {
    "use strict";
    var utf8 = exports2;
    utf8.length = function utf8_length(string2) {
      var len = 0, c = 0;
      for (var i = 0; i < string2.length; ++i) {
        c = string2.charCodeAt(i);
        if (c < 128)
          len += 1;
        else if (c < 2048)
          len += 2;
        else if ((c & 64512) === 55296 && (string2.charCodeAt(i + 1) & 64512) === 56320) {
          ++i;
          len += 4;
        } else
          len += 3;
      }
      return len;
    };
    utf8.read = function utf8_read(buffer2, start, end) {
      var len = end - start;
      if (len < 1)
        return "";
      var parts = null, chunk = [], i = 0, t;
      while (start < end) {
        t = buffer2[start++];
        if (t < 128)
          chunk[i++] = t;
        else if (t > 191 && t < 224)
          chunk[i++] = (t & 31) << 6 | buffer2[start++] & 63;
        else if (t > 239 && t < 365) {
          t = ((t & 7) << 18 | (buffer2[start++] & 63) << 12 | (buffer2[start++] & 63) << 6 | buffer2[start++] & 63) - 65536;
          chunk[i++] = 55296 + (t >> 10);
          chunk[i++] = 56320 + (t & 1023);
        } else
          chunk[i++] = (t & 15) << 12 | (buffer2[start++] & 63) << 6 | buffer2[start++] & 63;
        if (i > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i = 0;
        }
      }
      if (parts) {
        if (i)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i));
    };
    utf8.write = function utf8_write(string2, buffer2, offset) {
      var start = offset, c1, c2;
      for (var i = 0; i < string2.length; ++i) {
        c1 = string2.charCodeAt(i);
        if (c1 < 128) {
          buffer2[offset++] = c1;
        } else if (c1 < 2048) {
          buffer2[offset++] = c1 >> 6 | 192;
          buffer2[offset++] = c1 & 63 | 128;
        } else if ((c1 & 64512) === 55296 && ((c2 = string2.charCodeAt(i + 1)) & 64512) === 56320) {
          c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
          ++i;
          buffer2[offset++] = c1 >> 18 | 240;
          buffer2[offset++] = c1 >> 12 & 63 | 128;
          buffer2[offset++] = c1 >> 6 & 63 | 128;
          buffer2[offset++] = c1 & 63 | 128;
        } else {
          buffer2[offset++] = c1 >> 12 | 224;
          buffer2[offset++] = c1 >> 6 & 63 | 128;
          buffer2[offset++] = c1 & 63 | 128;
        }
      }
      return offset - start;
    };
  }
});

// ../../node_modules/.pnpm/@protobufjs+pool@1.1.0/node_modules/@protobufjs/pool/index.js
var require_pool = __commonJS({
  "../../node_modules/.pnpm/@protobufjs+pool@1.1.0/node_modules/@protobufjs/pool/index.js"(exports2, module2) {
    "use strict";
    module2.exports = pool;
    function pool(alloc2, slice2, size) {
      var SIZE = size || 8192;
      var MAX = SIZE >>> 1;
      var slab = null;
      var offset = SIZE;
      return function pool_alloc(size2) {
        if (size2 < 1 || size2 > MAX)
          return alloc2(size2);
        if (offset + size2 > SIZE) {
          slab = alloc2(SIZE);
          offset = 0;
        }
        var buf2 = slice2.call(slab, offset, offset += size2);
        if (offset & 7)
          offset = (offset | 7) + 1;
        return buf2;
      };
    }
  }
});

// ../../node_modules/.pnpm/protobufjs@6.11.4/node_modules/protobufjs/src/util/longbits.js
var require_longbits = __commonJS({
  "../../node_modules/.pnpm/protobufjs@6.11.4/node_modules/protobufjs/src/util/longbits.js"(exports2, module2) {
    "use strict";
    module2.exports = LongBits;
    var util = require_minimal();
    function LongBits(lo, hi) {
      this.lo = lo >>> 0;
      this.hi = hi >>> 0;
    }
    var zero = LongBits.zero = new LongBits(0, 0);
    zero.toNumber = function() {
      return 0;
    };
    zero.zzEncode = zero.zzDecode = function() {
      return this;
    };
    zero.length = function() {
      return 1;
    };
    var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";
    LongBits.fromNumber = function fromNumber(value) {
      if (value === 0)
        return zero;
      var sign = value < 0;
      if (sign)
        value = -value;
      var lo = value >>> 0, hi = (value - lo) / 4294967296 >>> 0;
      if (sign) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
          lo = 0;
          if (++hi > 4294967295)
            hi = 0;
        }
      }
      return new LongBits(lo, hi);
    };
    LongBits.from = function from3(value) {
      if (typeof value === "number")
        return LongBits.fromNumber(value);
      if (util.isString(value)) {
        if (util.Long)
          value = util.Long.fromString(value);
        else
          return LongBits.fromNumber(parseInt(value, 10));
      }
      return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
    };
    LongBits.prototype.toNumber = function toNumber(unsigned) {
      if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;
        if (!lo)
          hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
      }
      return this.lo + this.hi * 4294967296;
    };
    LongBits.prototype.toLong = function toLong(unsigned) {
      return util.Long ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
    };
    var charCodeAt = String.prototype.charCodeAt;
    LongBits.fromHash = function fromHash(hash) {
      if (hash === zeroHash)
        return zero;
      return new LongBits(
        (charCodeAt.call(hash, 0) | charCodeAt.call(hash, 1) << 8 | charCodeAt.call(hash, 2) << 16 | charCodeAt.call(hash, 3) << 24) >>> 0,
        (charCodeAt.call(hash, 4) | charCodeAt.call(hash, 5) << 8 | charCodeAt.call(hash, 6) << 16 | charCodeAt.call(hash, 7) << 24) >>> 0
      );
    };
    LongBits.prototype.toHash = function toHash() {
      return String.fromCharCode(
        this.lo & 255,
        this.lo >>> 8 & 255,
        this.lo >>> 16 & 255,
        this.lo >>> 24,
        this.hi & 255,
        this.hi >>> 8 & 255,
        this.hi >>> 16 & 255,
        this.hi >>> 24
      );
    };
    LongBits.prototype.zzEncode = function zzEncode() {
      var mask = this.hi >> 31;
      this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
      this.lo = (this.lo << 1 ^ mask) >>> 0;
      return this;
    };
    LongBits.prototype.zzDecode = function zzDecode() {
      var mask = -(this.lo & 1);
      this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
      this.hi = (this.hi >>> 1 ^ mask) >>> 0;
      return this;
    };
    LongBits.prototype.length = function length2() {
      var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;
      return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
    };
  }
});

// ../../node_modules/.pnpm/protobufjs@6.11.4/node_modules/protobufjs/src/util/minimal.js
var require_minimal = __commonJS({
  "../../node_modules/.pnpm/protobufjs@6.11.4/node_modules/protobufjs/src/util/minimal.js"(exports2) {
    "use strict";
    var util = exports2;
    util.asPromise = require_aspromise();
    util.base64 = require_base64();
    util.EventEmitter = require_eventemitter();
    util.float = require_float();
    util.inquire = require_inquire();
    util.utf8 = require_utf8();
    util.pool = require_pool();
    util.LongBits = require_longbits();
    util.isNode = Boolean(typeof global !== "undefined" && global && global.process && global.process.versions && global.process.versions.node);
    util.global = util.isNode && global || typeof window !== "undefined" && window || typeof self !== "undefined" && self || exports2;
    util.emptyArray = Object.freeze ? Object.freeze([]) : (
      /* istanbul ignore next */
      []
    );
    util.emptyObject = Object.freeze ? Object.freeze({}) : (
      /* istanbul ignore next */
      {}
    );
    util.isInteger = Number.isInteger || /* istanbul ignore next */
    function isInteger(value) {
      return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
    };
    util.isString = function isString(value) {
      return typeof value === "string" || value instanceof String;
    };
    util.isObject = function isObject3(value) {
      return value && typeof value === "object";
    };
    util.isset = /**
     * Checks if a property on a message is considered to be present.
     * @param {Object} obj Plain object or message instance
     * @param {string} prop Property name
     * @returns {boolean} `true` if considered to be present, otherwise `false`
     */
    util.isSet = function isSet(obj, prop) {
      var value = obj[prop];
      if (value != null && obj.hasOwnProperty(prop))
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
      return false;
    };
    util.Buffer = function() {
      try {
        var Buffer3 = util.inquire("buffer").Buffer;
        return Buffer3.prototype.utf8Write ? Buffer3 : (
          /* istanbul ignore next */
          null
        );
      } catch (e) {
        return null;
      }
    }();
    util._Buffer_from = null;
    util._Buffer_allocUnsafe = null;
    util.newBuffer = function newBuffer(sizeOrArray) {
      return typeof sizeOrArray === "number" ? util.Buffer ? util._Buffer_allocUnsafe(sizeOrArray) : new util.Array(sizeOrArray) : util.Buffer ? util._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
    };
    util.Array = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    util.Long = /* istanbul ignore next */
    util.global.dcodeIO && /* istanbul ignore next */
    util.global.dcodeIO.Long || /* istanbul ignore next */
    util.global.Long || util.inquire("long");
    util.key2Re = /^true|false|0|1$/;
    util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
    util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
    util.longToHash = function longToHash(value) {
      return value ? util.LongBits.from(value).toHash() : util.LongBits.zeroHash;
    };
    util.longFromHash = function longFromHash(hash, unsigned) {
      var bits = util.LongBits.fromHash(hash);
      if (util.Long)
        return util.Long.fromBits(bits.lo, bits.hi, unsigned);
      return bits.toNumber(Boolean(unsigned));
    };
    function merge(dst, src2, ifNotSet) {
      for (var keys = Object.keys(src2), i = 0; i < keys.length; ++i)
        if (dst[keys[i]] === void 0 || !ifNotSet)
          dst[keys[i]] = src2[keys[i]];
      return dst;
    }
    util.merge = merge;
    util.lcFirst = function lcFirst(str) {
      return str.charAt(0).toLowerCase() + str.substring(1);
    };
    function newError(name5) {
      function CustomError(message, properties) {
        if (!(this instanceof CustomError))
          return new CustomError(message, properties);
        Object.defineProperty(this, "message", { get: function() {
          return message;
        } });
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, CustomError);
        else
          Object.defineProperty(this, "stack", { value: new Error().stack || "" });
        if (properties)
          merge(this, properties);
      }
      (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;
      Object.defineProperty(CustomError.prototype, "name", { get: function() {
        return name5;
      } });
      CustomError.prototype.toString = function toString3() {
        return this.name + ": " + this.message;
      };
      return CustomError;
    }
    util.newError = newError;
    util.ProtocolError = newError("ProtocolError");
    util.oneOfGetter = function getOneOf(fieldNames) {
      var fieldMap = {};
      for (var i = 0; i < fieldNames.length; ++i)
        fieldMap[fieldNames[i]] = 1;
      return function() {
        for (var keys = Object.keys(this), i2 = keys.length - 1; i2 > -1; --i2)
          if (fieldMap[keys[i2]] === 1 && this[keys[i2]] !== void 0 && this[keys[i2]] !== null)
            return keys[i2];
      };
    };
    util.oneOfSetter = function setOneOf(fieldNames) {
      return function(name5) {
        for (var i = 0; i < fieldNames.length; ++i)
          if (fieldNames[i] !== name5)
            delete this[fieldNames[i]];
      };
    };
    util.toJSONOptions = {
      longs: String,
      enums: String,
      bytes: String,
      json: true
    };
    util._configure = function() {
      var Buffer3 = util.Buffer;
      if (!Buffer3) {
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
      }
      util._Buffer_from = Buffer3.from !== Uint8Array.from && Buffer3.from || /* istanbul ignore next */
      function Buffer_from(value, encoding) {
        return new Buffer3(value, encoding);
      };
      util._Buffer_allocUnsafe = Buffer3.allocUnsafe || /* istanbul ignore next */
      function Buffer_allocUnsafe(size) {
        return new Buffer3(size);
      };
    };
  }
});

// ../../node_modules/.pnpm/protobufjs@6.11.4/node_modules/protobufjs/src/writer.js
var require_writer = __commonJS({
  "../../node_modules/.pnpm/protobufjs@6.11.4/node_modules/protobufjs/src/writer.js"(exports2, module2) {
    "use strict";
    module2.exports = Writer;
    var util = require_minimal();
    var BufferWriter;
    var LongBits = util.LongBits;
    var base642 = util.base64;
    var utf8 = util.utf8;
    function Op(fn, len, val) {
      this.fn = fn;
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    function noop3() {
    }
    function State(writer) {
      this.head = writer.head;
      this.tail = writer.tail;
      this.len = writer.len;
      this.next = writer.states;
    }
    function Writer() {
      this.len = 0;
      this.head = new Op(noop3, 0, 0);
      this.tail = this.head;
      this.states = null;
    }
    var create4 = function create5() {
      return util.Buffer ? function create_buffer_setup() {
        return (Writer.create = function create_buffer() {
          return new BufferWriter();
        })();
      } : function create_array() {
        return new Writer();
      };
    };
    Writer.create = create4();
    Writer.alloc = function alloc2(size) {
      return new util.Array(size);
    };
    if (util.Array !== Array)
      Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);
    Writer.prototype._push = function push(fn, len, val) {
      this.tail = this.tail.next = new Op(fn, len, val);
      this.len += len;
      return this;
    };
    function writeByte(val, buf2, pos) {
      buf2[pos] = val & 255;
    }
    function writeVarint32(val, buf2, pos) {
      while (val > 127) {
        buf2[pos++] = val & 127 | 128;
        val >>>= 7;
      }
      buf2[pos] = val;
    }
    function VarintOp(len, val) {
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    VarintOp.prototype = Object.create(Op.prototype);
    VarintOp.prototype.fn = writeVarint32;
    Writer.prototype.uint32 = function write_uint32(value) {
      this.len += (this.tail = this.tail.next = new VarintOp(
        (value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5,
        value
      )).len;
      return this;
    };
    Writer.prototype.int32 = function write_int32(value) {
      return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) : this.uint32(value);
    };
    Writer.prototype.sint32 = function write_sint32(value) {
      return this.uint32((value << 1 ^ value >> 31) >>> 0);
    };
    function writeVarint64(val, buf2, pos) {
      while (val.hi) {
        buf2[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
      }
      while (val.lo > 127) {
        buf2[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
      }
      buf2[pos++] = val.lo;
    }
    Writer.prototype.uint64 = function write_uint64(value) {
      var bits = LongBits.from(value);
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer.prototype.int64 = Writer.prototype.uint64;
    Writer.prototype.sint64 = function write_sint64(value) {
      var bits = LongBits.from(value).zzEncode();
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer.prototype.bool = function write_bool(value) {
      return this._push(writeByte, 1, value ? 1 : 0);
    };
    function writeFixed32(val, buf2, pos) {
      buf2[pos] = val & 255;
      buf2[pos + 1] = val >>> 8 & 255;
      buf2[pos + 2] = val >>> 16 & 255;
      buf2[pos + 3] = val >>> 24;
    }
    Writer.prototype.fixed32 = function write_fixed32(value) {
      return this._push(writeFixed32, 4, value >>> 0);
    };
    Writer.prototype.sfixed32 = Writer.prototype.fixed32;
    Writer.prototype.fixed64 = function write_fixed64(value) {
      var bits = LongBits.from(value);
      return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
    };
    Writer.prototype.sfixed64 = Writer.prototype.fixed64;
    Writer.prototype.float = function write_float(value) {
      return this._push(util.float.writeFloatLE, 4, value);
    };
    Writer.prototype.double = function write_double(value) {
      return this._push(util.float.writeDoubleLE, 8, value);
    };
    var writeBytes2 = util.Array.prototype.set ? function writeBytes_set(val, buf2, pos) {
      buf2.set(val, pos);
    } : function writeBytes_for(val, buf2, pos) {
      for (var i = 0; i < val.length; ++i)
        buf2[pos + i] = val[i];
    };
    Writer.prototype.bytes = function write_bytes(value) {
      var len = value.length >>> 0;
      if (!len)
        return this._push(writeByte, 1, 0);
      if (util.isString(value)) {
        var buf2 = Writer.alloc(len = base642.length(value));
        base642.decode(value, buf2, 0);
        value = buf2;
      }
      return this.uint32(len)._push(writeBytes2, len, value);
    };
    Writer.prototype.string = function write_string(value) {
      var len = utf8.length(value);
      return len ? this.uint32(len)._push(utf8.write, len, value) : this._push(writeByte, 1, 0);
    };
    Writer.prototype.fork = function fork() {
      this.states = new State(this);
      this.head = this.tail = new Op(noop3, 0, 0);
      this.len = 0;
      return this;
    };
    Writer.prototype.reset = function reset() {
      if (this.states) {
        this.head = this.states.head;
        this.tail = this.states.tail;
        this.len = this.states.len;
        this.states = this.states.next;
      } else {
        this.head = this.tail = new Op(noop3, 0, 0);
        this.len = 0;
      }
      return this;
    };
    Writer.prototype.ldelim = function ldelim() {
      var head = this.head, tail = this.tail, len = this.len;
      this.reset().uint32(len);
      if (len) {
        this.tail.next = head.next;
        this.tail = tail;
        this.len += len;
      }
      return this;
    };
    Writer.prototype.finish = function finish() {
      var head = this.head.next, buf2 = this.constructor.alloc(this.len), pos = 0;
      while (head) {
        head.fn(head.val, buf2, pos);
        pos += head.len;
        head = head.next;
      }
      return buf2;
    };
    Writer._configure = function(BufferWriter_) {
      BufferWriter = BufferWriter_;
      Writer.create = create4();
      BufferWriter._configure();
    };
  }
});

// ../../node_modules/.pnpm/protobufjs@6.11.4/node_modules/protobufjs/src/writer_buffer.js
var require_writer_buffer = __commonJS({
  "../../node_modules/.pnpm/protobufjs@6.11.4/node_modules/protobufjs/src/writer_buffer.js"(exports2, module2) {
    "use strict";
    module2.exports = BufferWriter;
    var Writer = require_writer();
    (BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
    var util = require_minimal();
    function BufferWriter() {
      Writer.call(this);
    }
    BufferWriter._configure = function() {
      BufferWriter.alloc = util._Buffer_allocUnsafe;
      BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === "set" ? function writeBytesBuffer_set(val, buf2, pos) {
        buf2.set(val, pos);
      } : function writeBytesBuffer_copy(val, buf2, pos) {
        if (val.copy)
          val.copy(buf2, pos, 0, val.length);
        else
          for (var i = 0; i < val.length; )
            buf2[pos++] = val[i++];
      };
    };
    BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
      if (util.isString(value))
        value = util._Buffer_from(value, "base64");
      var len = value.length >>> 0;
      this.uint32(len);
      if (len)
        this._push(BufferWriter.writeBytesBuffer, len, value);
      return this;
    };
    function writeStringBuffer(val, buf2, pos) {
      if (val.length < 40)
        util.utf8.write(val, buf2, pos);
      else if (buf2.utf8Write)
        buf2.utf8Write(val, pos);
      else
        buf2.write(val, pos);
    }
    BufferWriter.prototype.string = function write_string_buffer(value) {
      var len = util.Buffer.byteLength(value);
      this.uint32(len);
      if (len)
        this._push(writeStringBuffer, len, value);
      return this;
    };
    BufferWriter._configure();
  }
});

// ../../node_modules/.pnpm/protobufjs@6.11.4/node_modules/protobufjs/src/reader.js
var require_reader = __commonJS({
  "../../node_modules/.pnpm/protobufjs@6.11.4/node_modules/protobufjs/src/reader.js"(exports2, module2) {
    "use strict";
    module2.exports = Reader;
    var util = require_minimal();
    var BufferReader;
    var LongBits = util.LongBits;
    var utf8 = util.utf8;
    function indexOutOfRange(reader, writeLength) {
      return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
    }
    function Reader(buffer2) {
      this.buf = buffer2;
      this.pos = 0;
      this.len = buffer2.length;
    }
    var create_array = typeof Uint8Array !== "undefined" ? function create_typed_array(buffer2) {
      if (buffer2 instanceof Uint8Array || Array.isArray(buffer2))
        return new Reader(buffer2);
      throw Error("illegal buffer");
    } : function create_array2(buffer2) {
      if (Array.isArray(buffer2))
        return new Reader(buffer2);
      throw Error("illegal buffer");
    };
    var create4 = function create5() {
      return util.Buffer ? function create_buffer_setup(buffer2) {
        return (Reader.create = function create_buffer(buffer3) {
          return util.Buffer.isBuffer(buffer3) ? new BufferReader(buffer3) : create_array(buffer3);
        })(buffer2);
      } : create_array;
    };
    Reader.create = create4();
    Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */
    util.Array.prototype.slice;
    Reader.prototype.uint32 = function read_uint32_setup() {
      var value = 4294967295;
      return function read_uint32() {
        value = (this.buf[this.pos] & 127) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        if ((this.pos += 5) > this.len) {
          this.pos = this.len;
          throw indexOutOfRange(this, 10);
        }
        return value;
      };
    }();
    Reader.prototype.int32 = function read_int32() {
      return this.uint32() | 0;
    };
    Reader.prototype.sint32 = function read_sint32() {
      var value = this.uint32();
      return value >>> 1 ^ -(value & 1) | 0;
    };
    function readLongVarint() {
      var bits = new LongBits(0, 0);
      var i = 0;
      if (this.len - this.pos > 4) {
        for (; i < 4; ++i) {
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits;
        i = 0;
      } else {
        for (; i < 3; ++i) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits;
      }
      if (this.len - this.pos > 4) {
        for (; i < 5; ++i) {
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      } else {
        for (; i < 5; ++i) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      }
      throw Error("invalid varint encoding");
    }
    Reader.prototype.bool = function read_bool() {
      return this.uint32() !== 0;
    };
    function readFixed32_end(buf2, end) {
      return (buf2[end - 4] | buf2[end - 3] << 8 | buf2[end - 2] << 16 | buf2[end - 1] << 24) >>> 0;
    }
    Reader.prototype.fixed32 = function read_fixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4);
    };
    Reader.prototype.sfixed32 = function read_sfixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4) | 0;
    };
    function readFixed64() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);
      return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
    }
    Reader.prototype.float = function read_float() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util.float.readFloatLE(this.buf, this.pos);
      this.pos += 4;
      return value;
    };
    Reader.prototype.double = function read_double() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util.float.readDoubleLE(this.buf, this.pos);
      this.pos += 8;
      return value;
    };
    Reader.prototype.bytes = function read_bytes() {
      var length2 = this.uint32(), start = this.pos, end = this.pos + length2;
      if (end > this.len)
        throw indexOutOfRange(this, length2);
      this.pos += length2;
      if (Array.isArray(this.buf))
        return this.buf.slice(start, end);
      return start === end ? new this.buf.constructor(0) : this._slice.call(this.buf, start, end);
    };
    Reader.prototype.string = function read_string() {
      var bytes = this.bytes();
      return utf8.read(bytes, 0, bytes.length);
    };
    Reader.prototype.skip = function skip(length2) {
      if (typeof length2 === "number") {
        if (this.pos + length2 > this.len)
          throw indexOutOfRange(this, length2);
        this.pos += length2;
      } else {
        do {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
      }
      return this;
    };
    Reader.prototype.skipType = function(wireType) {
      switch (wireType) {
        case 0:
          this.skip();
          break;
        case 1:
          this.skip(8);
          break;
        case 2:
          this.skip(this.uint32());
          break;
        case 3:
          while ((wireType = this.uint32() & 7) !== 4) {
            this.skipType(wireType);
          }
          break;
        case 5:
          this.skip(4);
          break;
        default:
          throw Error("invalid wire type " + wireType + " at offset " + this.pos);
      }
      return this;
    };
    Reader._configure = function(BufferReader_) {
      BufferReader = BufferReader_;
      Reader.create = create4();
      BufferReader._configure();
      var fn = util.Long ? "toLong" : (
        /* istanbul ignore next */
        "toNumber"
      );
      util.merge(Reader.prototype, {
        int64: function read_int64() {
          return readLongVarint.call(this)[fn](false);
        },
        uint64: function read_uint64() {
          return readLongVarint.call(this)[fn](true);
        },
        sint64: function read_sint64() {
          return readLongVarint.call(this).zzDecode()[fn](false);
        },
        fixed64: function read_fixed64() {
          return readFixed64.call(this)[fn](true);
        },
        sfixed64: function read_sfixed64() {
          return readFixed64.call(this)[fn](false);
        }
      });
    };
  }
});

// ../../node_modules/.pnpm/protobufjs@6.11.4/node_modules/protobufjs/src/reader_buffer.js
var require_reader_buffer = __commonJS({
  "../../node_modules/.pnpm/protobufjs@6.11.4/node_modules/protobufjs/src/reader_buffer.js"(exports2, module2) {
    "use strict";
    module2.exports = BufferReader;
    var Reader = require_reader();
    (BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
    var util = require_minimal();
    function BufferReader(buffer2) {
      Reader.call(this, buffer2);
    }
    BufferReader._configure = function() {
      if (util.Buffer)
        BufferReader.prototype._slice = util.Buffer.prototype.slice;
    };
    BufferReader.prototype.string = function read_string_buffer() {
      var len = this.uint32();
      return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
    };
    BufferReader._configure();
  }
});

// ../../node_modules/.pnpm/protobufjs@6.11.4/node_modules/protobufjs/src/rpc/service.js
var require_service = __commonJS({
  "../../node_modules/.pnpm/protobufjs@6.11.4/node_modules/protobufjs/src/rpc/service.js"(exports2, module2) {
    "use strict";
    module2.exports = Service;
    var util = require_minimal();
    (Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;
    function Service(rpcImpl, requestDelimited, responseDelimited) {
      if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");
      util.EventEmitter.call(this);
      this.rpcImpl = rpcImpl;
      this.requestDelimited = Boolean(requestDelimited);
      this.responseDelimited = Boolean(responseDelimited);
    }
    Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {
      if (!request)
        throw TypeError("request must be specified");
      var self2 = this;
      if (!callback)
        return util.asPromise(rpcCall, self2, method, requestCtor, responseCtor, request);
      if (!self2.rpcImpl) {
        setTimeout(function() {
          callback(Error("already ended"));
        }, 0);
        return void 0;
      }
      try {
        return self2.rpcImpl(
          method,
          requestCtor[self2.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
          function rpcCallback(err, response) {
            if (err) {
              self2.emit("error", err, method);
              return callback(err);
            }
            if (response === null) {
              self2.end(
                /* endedByRPC */
                true
              );
              return void 0;
            }
            if (!(response instanceof responseCtor)) {
              try {
                response = responseCtor[self2.responseDelimited ? "decodeDelimited" : "decode"](response);
              } catch (err2) {
                self2.emit("error", err2, method);
                return callback(err2);
              }
            }
            self2.emit("data", response, method);
            return callback(null, response);
          }
        );
      } catch (err) {
        self2.emit("error", err, method);
        setTimeout(function() {
          callback(err);
        }, 0);
        return void 0;
      }
    };
    Service.prototype.end = function end(endedByRPC) {
      if (this.rpcImpl) {
        if (!endedByRPC)
          this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
      }
      return this;
    };
  }
});

// ../../node_modules/.pnpm/protobufjs@6.11.4/node_modules/protobufjs/src/rpc.js
var require_rpc = __commonJS({
  "../../node_modules/.pnpm/protobufjs@6.11.4/node_modules/protobufjs/src/rpc.js"(exports2) {
    "use strict";
    var rpc = exports2;
    rpc.Service = require_service();
  }
});

// ../../node_modules/.pnpm/protobufjs@6.11.4/node_modules/protobufjs/src/roots.js
var require_roots = __commonJS({
  "../../node_modules/.pnpm/protobufjs@6.11.4/node_modules/protobufjs/src/roots.js"(exports2, module2) {
    "use strict";
    module2.exports = {};
  }
});

// ../../node_modules/.pnpm/protobufjs@6.11.4/node_modules/protobufjs/src/index-minimal.js
var require_index_minimal = __commonJS({
  "../../node_modules/.pnpm/protobufjs@6.11.4/node_modules/protobufjs/src/index-minimal.js"(exports2) {
    "use strict";
    var protobuf = exports2;
    protobuf.build = "minimal";
    protobuf.Writer = require_writer();
    protobuf.BufferWriter = require_writer_buffer();
    protobuf.Reader = require_reader();
    protobuf.BufferReader = require_reader_buffer();
    protobuf.util = require_minimal();
    protobuf.rpc = require_rpc();
    protobuf.roots = require_roots();
    protobuf.configure = configure;
    function configure() {
      protobuf.util._configure();
      protobuf.Writer._configure(protobuf.BufferWriter);
      protobuf.Reader._configure(protobuf.BufferReader);
    }
    configure();
  }
});

// ../../node_modules/.pnpm/protobufjs@6.11.4/node_modules/protobufjs/minimal.js
var require_minimal2 = __commonJS({
  "../../node_modules/.pnpm/protobufjs@6.11.4/node_modules/protobufjs/minimal.js"(exports2, module2) {
    "use strict";
    module2.exports = require_index_minimal();
  }
});

// ../../node_modules/.pnpm/it-all@1.0.6/node_modules/it-all/index.js
var require_it_all = __commonJS({
  "../../node_modules/.pnpm/it-all@1.0.6/node_modules/it-all/index.js"(exports2, module2) {
    "use strict";
    var all4 = (source) => __async(exports2, null, function* () {
      const arr = [];
      try {
        for (var iter = __forAwait(source), more, temp, error; more = !(temp = yield iter.next()).done; more = false) {
          const entry = temp.value;
          arr.push(entry);
        }
      } catch (temp) {
        error = [temp];
      } finally {
        try {
          more && (temp = iter.return) && (yield temp.call(iter));
        } finally {
          if (error)
            throw error[0];
        }
      }
      return arr;
    });
    module2.exports = all4;
  }
});

// ../../node_modules/.pnpm/bl@5.1.0/node_modules/bl/BufferList.js
var require_BufferList = __commonJS({
  "../../node_modules/.pnpm/bl@5.1.0/node_modules/bl/BufferList.js"(exports2, module2) {
    "use strict";
    var { Buffer: Buffer3 } = __require("buffer");
    var symbol = Symbol.for("BufferList");
    function BufferList3(buf2) {
      if (!(this instanceof BufferList3)) {
        return new BufferList3(buf2);
      }
      BufferList3._init.call(this, buf2);
    }
    BufferList3._init = function _init(buf2) {
      Object.defineProperty(this, symbol, { value: true });
      this._bufs = [];
      this.length = 0;
      if (buf2) {
        this.append(buf2);
      }
    };
    BufferList3.prototype._new = function _new(buf2) {
      return new BufferList3(buf2);
    };
    BufferList3.prototype._offset = function _offset(offset) {
      if (offset === 0) {
        return [0, 0];
      }
      let tot = 0;
      for (let i = 0; i < this._bufs.length; i++) {
        const _t = tot + this._bufs[i].length;
        if (offset < _t || i === this._bufs.length - 1) {
          return [i, offset - tot];
        }
        tot = _t;
      }
    };
    BufferList3.prototype._reverseOffset = function(blOffset) {
      const bufferId = blOffset[0];
      let offset = blOffset[1];
      for (let i = 0; i < bufferId; i++) {
        offset += this._bufs[i].length;
      }
      return offset;
    };
    BufferList3.prototype.get = function get2(index) {
      if (index > this.length || index < 0) {
        return void 0;
      }
      const offset = this._offset(index);
      return this._bufs[offset[0]][offset[1]];
    };
    BufferList3.prototype.slice = function slice2(start, end) {
      if (typeof start === "number" && start < 0) {
        start += this.length;
      }
      if (typeof end === "number" && end < 0) {
        end += this.length;
      }
      return this.copy(null, 0, start, end);
    };
    BufferList3.prototype.copy = function copy(dst, dstStart, srcStart, srcEnd) {
      if (typeof srcStart !== "number" || srcStart < 0) {
        srcStart = 0;
      }
      if (typeof srcEnd !== "number" || srcEnd > this.length) {
        srcEnd = this.length;
      }
      if (srcStart >= this.length) {
        return dst || Buffer3.alloc(0);
      }
      if (srcEnd <= 0) {
        return dst || Buffer3.alloc(0);
      }
      const copy2 = !!dst;
      const off = this._offset(srcStart);
      const len = srcEnd - srcStart;
      let bytes = len;
      let bufoff = copy2 && dstStart || 0;
      let start = off[1];
      if (srcStart === 0 && srcEnd === this.length) {
        if (!copy2) {
          return this._bufs.length === 1 ? this._bufs[0] : Buffer3.concat(this._bufs, this.length);
        }
        for (let i = 0; i < this._bufs.length; i++) {
          this._bufs[i].copy(dst, bufoff);
          bufoff += this._bufs[i].length;
        }
        return dst;
      }
      if (bytes <= this._bufs[off[0]].length - start) {
        return copy2 ? this._bufs[off[0]].copy(dst, dstStart, start, start + bytes) : this._bufs[off[0]].slice(start, start + bytes);
      }
      if (!copy2) {
        dst = Buffer3.allocUnsafe(len);
      }
      for (let i = off[0]; i < this._bufs.length; i++) {
        const l = this._bufs[i].length - start;
        if (bytes > l) {
          this._bufs[i].copy(dst, bufoff, start);
          bufoff += l;
        } else {
          this._bufs[i].copy(dst, bufoff, start, start + bytes);
          bufoff += l;
          break;
        }
        bytes -= l;
        if (start) {
          start = 0;
        }
      }
      if (dst.length > bufoff)
        return dst.slice(0, bufoff);
      return dst;
    };
    BufferList3.prototype.shallowSlice = function shallowSlice(start, end) {
      start = start || 0;
      end = typeof end !== "number" ? this.length : end;
      if (start < 0) {
        start += this.length;
      }
      if (end < 0) {
        end += this.length;
      }
      if (start === end) {
        return this._new();
      }
      const startOffset = this._offset(start);
      const endOffset = this._offset(end);
      const buffers = this._bufs.slice(startOffset[0], endOffset[0] + 1);
      if (endOffset[1] === 0) {
        buffers.pop();
      } else {
        buffers[buffers.length - 1] = buffers[buffers.length - 1].slice(0, endOffset[1]);
      }
      if (startOffset[1] !== 0) {
        buffers[0] = buffers[0].slice(startOffset[1]);
      }
      return this._new(buffers);
    };
    BufferList3.prototype.toString = function toString3(encoding, start, end) {
      return this.slice(start, end).toString(encoding);
    };
    BufferList3.prototype.consume = function consume(bytes) {
      bytes = Math.trunc(bytes);
      if (Number.isNaN(bytes) || bytes <= 0)
        return this;
      while (this._bufs.length) {
        if (bytes >= this._bufs[0].length) {
          bytes -= this._bufs[0].length;
          this.length -= this._bufs[0].length;
          this._bufs.shift();
        } else {
          this._bufs[0] = this._bufs[0].slice(bytes);
          this.length -= bytes;
          break;
        }
      }
      return this;
    };
    BufferList3.prototype.duplicate = function duplicate() {
      const copy = this._new();
      for (let i = 0; i < this._bufs.length; i++) {
        copy.append(this._bufs[i]);
      }
      return copy;
    };
    BufferList3.prototype.append = function append(buf2) {
      if (buf2 == null) {
        return this;
      }
      if (buf2.buffer) {
        this._appendBuffer(Buffer3.from(buf2.buffer, buf2.byteOffset, buf2.byteLength));
      } else if (Array.isArray(buf2)) {
        for (let i = 0; i < buf2.length; i++) {
          this.append(buf2[i]);
        }
      } else if (this._isBufferList(buf2)) {
        for (let i = 0; i < buf2._bufs.length; i++) {
          this.append(buf2._bufs[i]);
        }
      } else {
        if (typeof buf2 === "number") {
          buf2 = buf2.toString();
        }
        this._appendBuffer(Buffer3.from(buf2));
      }
      return this;
    };
    BufferList3.prototype._appendBuffer = function appendBuffer(buf2) {
      this._bufs.push(buf2);
      this.length += buf2.length;
    };
    BufferList3.prototype.indexOf = function(search, offset, encoding) {
      if (encoding === void 0 && typeof offset === "string") {
        encoding = offset;
        offset = void 0;
      }
      if (typeof search === "function" || Array.isArray(search)) {
        throw new TypeError('The "value" argument must be one of type string, Buffer, BufferList, or Uint8Array.');
      } else if (typeof search === "number") {
        search = Buffer3.from([search]);
      } else if (typeof search === "string") {
        search = Buffer3.from(search, encoding);
      } else if (this._isBufferList(search)) {
        search = search.slice();
      } else if (Array.isArray(search.buffer)) {
        search = Buffer3.from(search.buffer, search.byteOffset, search.byteLength);
      } else if (!Buffer3.isBuffer(search)) {
        search = Buffer3.from(search);
      }
      offset = Number(offset || 0);
      if (isNaN(offset)) {
        offset = 0;
      }
      if (offset < 0) {
        offset = this.length + offset;
      }
      if (offset < 0) {
        offset = 0;
      }
      if (search.length === 0) {
        return offset > this.length ? this.length : offset;
      }
      const blOffset = this._offset(offset);
      let blIndex = blOffset[0];
      let buffOffset = blOffset[1];
      for (; blIndex < this._bufs.length; blIndex++) {
        const buff = this._bufs[blIndex];
        while (buffOffset < buff.length) {
          const availableWindow = buff.length - buffOffset;
          if (availableWindow >= search.length) {
            const nativeSearchResult = buff.indexOf(search, buffOffset);
            if (nativeSearchResult !== -1) {
              return this._reverseOffset([blIndex, nativeSearchResult]);
            }
            buffOffset = buff.length - search.length + 1;
          } else {
            const revOffset = this._reverseOffset([blIndex, buffOffset]);
            if (this._match(revOffset, search)) {
              return revOffset;
            }
            buffOffset++;
          }
        }
        buffOffset = 0;
      }
      return -1;
    };
    BufferList3.prototype._match = function(offset, search) {
      if (this.length - offset < search.length) {
        return false;
      }
      for (let searchOffset = 0; searchOffset < search.length; searchOffset++) {
        if (this.get(offset + searchOffset) !== search[searchOffset]) {
          return false;
        }
      }
      return true;
    };
    (function() {
      const methods = {
        readDoubleBE: 8,
        readDoubleLE: 8,
        readFloatBE: 4,
        readFloatLE: 4,
        readInt32BE: 4,
        readInt32LE: 4,
        readUInt32BE: 4,
        readUInt32LE: 4,
        readInt16BE: 2,
        readInt16LE: 2,
        readUInt16BE: 2,
        readUInt16LE: 2,
        readInt8: 1,
        readUInt8: 1,
        readIntBE: null,
        readIntLE: null,
        readUIntBE: null,
        readUIntLE: null
      };
      for (const m in methods) {
        (function(m2) {
          if (methods[m2] === null) {
            BufferList3.prototype[m2] = function(offset, byteLength) {
              return this.slice(offset, offset + byteLength)[m2](0, byteLength);
            };
          } else {
            BufferList3.prototype[m2] = function(offset = 0) {
              return this.slice(offset, offset + methods[m2])[m2](0);
            };
          }
        })(m);
      }
    })();
    BufferList3.prototype._isBufferList = function _isBufferList(b) {
      return b instanceof BufferList3 || BufferList3.isBufferList(b);
    };
    BufferList3.isBufferList = function isBufferList(b) {
      return b != null && b[symbol];
    };
    module2.exports = BufferList3;
  }
});

// ../../node_modules/.pnpm/rabin-wasm@0.1.5/node_modules/rabin-wasm/src/rabin.js
var require_rabin = __commonJS({
  "../../node_modules/.pnpm/rabin-wasm@0.1.5/node_modules/rabin-wasm/src/rabin.js"(exports2, module2) {
    "use strict";
    var Rabin = class {
      /**
       * Creates an instance of Rabin.
       * @param { import("./../dist/rabin-wasm") } asModule
       * @param {number} [bits=12]
       * @param {number} [min=8 * 1024]
       * @param {number} [max=32 * 1024]
       * @param {number} polynomial
       * @memberof Rabin
       */
      constructor(asModule, bits = 12, min = 8 * 1024, max = 32 * 1024, windowSize = 64, polynomial) {
        this.bits = bits;
        this.min = min;
        this.max = max;
        this.asModule = asModule;
        this.rabin = new asModule.Rabin(bits, min, max, windowSize, polynomial);
        this.polynomial = polynomial;
      }
      /**
       * Fingerprints the buffer
       *
       * @param {Uint8Array} buf
       * @returns {Array<number>}
       * @memberof Rabin
       */
      fingerprint(buf2) {
        const {
          __retain,
          __release,
          __allocArray,
          __getInt32Array,
          Int32Array_ID,
          Uint8Array_ID
        } = this.asModule;
        const lengths = new Int32Array(Math.ceil(buf2.length / this.min));
        const lengthsPtr = __retain(__allocArray(Int32Array_ID, lengths));
        const pointer = __retain(__allocArray(Uint8Array_ID, buf2));
        const out = this.rabin.fingerprint(pointer, lengthsPtr);
        const processed = __getInt32Array(out);
        __release(pointer);
        __release(lengthsPtr);
        const end = processed.indexOf(0);
        return end >= 0 ? processed.subarray(0, end) : processed;
      }
    };
    module2.exports = Rabin;
  }
});

// ../../node_modules/.pnpm/@assemblyscript+loader@0.9.4/node_modules/@assemblyscript/loader/index.js
var require_loader = __commonJS({
  "../../node_modules/.pnpm/@assemblyscript+loader@0.9.4/node_modules/@assemblyscript/loader/index.js"(exports2) {
    "use strict";
    var ID_OFFSET = -8;
    var SIZE_OFFSET = -4;
    var ARRAYBUFFER_ID = 0;
    var STRING_ID = 1;
    var ARRAYBUFFERVIEW = 1 << 0;
    var ARRAY = 1 << 1;
    var SET = 1 << 2;
    var MAP = 1 << 3;
    var VAL_ALIGN_OFFSET = 5;
    var VAL_ALIGN = 1 << VAL_ALIGN_OFFSET;
    var VAL_SIGNED = 1 << 10;
    var VAL_FLOAT = 1 << 11;
    var VAL_NULLABLE = 1 << 12;
    var VAL_MANAGED = 1 << 13;
    var KEY_ALIGN_OFFSET = 14;
    var KEY_ALIGN = 1 << KEY_ALIGN_OFFSET;
    var KEY_SIGNED = 1 << 19;
    var KEY_FLOAT = 1 << 20;
    var KEY_NULLABLE = 1 << 21;
    var KEY_MANAGED = 1 << 22;
    var ARRAYBUFFERVIEW_BUFFER_OFFSET = 0;
    var ARRAYBUFFERVIEW_DATASTART_OFFSET = 4;
    var ARRAYBUFFERVIEW_DATALENGTH_OFFSET = 8;
    var ARRAYBUFFERVIEW_SIZE = 12;
    var ARRAY_LENGTH_OFFSET = 12;
    var ARRAY_SIZE = 16;
    var BIGINT = typeof BigUint64Array !== "undefined";
    var THIS = Symbol();
    var CHUNKSIZE = 1024;
    function getStringImpl(buffer2, ptr) {
      const U32 = new Uint32Array(buffer2);
      const U16 = new Uint16Array(buffer2);
      var length2 = U32[ptr + SIZE_OFFSET >>> 2] >>> 1;
      var offset = ptr >>> 1;
      if (length2 <= CHUNKSIZE)
        return String.fromCharCode.apply(String, U16.subarray(offset, offset + length2));
      const parts = [];
      do {
        const last2 = U16[offset + CHUNKSIZE - 1];
        const size = last2 >= 55296 && last2 < 56320 ? CHUNKSIZE - 1 : CHUNKSIZE;
        parts.push(String.fromCharCode.apply(String, U16.subarray(offset, offset += size)));
        length2 -= size;
      } while (length2 > CHUNKSIZE);
      return parts.join("") + String.fromCharCode.apply(String, U16.subarray(offset, offset + length2));
    }
    function preInstantiate(imports) {
      const baseModule = {};
      function getString(memory, ptr) {
        if (!memory)
          return "<yet unknown>";
        return getStringImpl(memory.buffer, ptr);
      }
      const env = imports.env = imports.env || {};
      env.abort = env.abort || function abort(mesg, file, line, colm) {
        const memory = baseModule.memory || env.memory;
        throw Error("abort: " + getString(memory, mesg) + " at " + getString(memory, file) + ":" + line + ":" + colm);
      };
      env.trace = env.trace || function trace(mesg, n) {
        const memory = baseModule.memory || env.memory;
        console.log("trace: " + getString(memory, mesg) + (n ? " " : "") + Array.prototype.slice.call(arguments, 2, 2 + n).join(", "));
      };
      imports.Math = imports.Math || Math;
      imports.Date = imports.Date || Date;
      return baseModule;
    }
    function postInstantiate(baseModule, instance) {
      const rawExports = instance.exports;
      const memory = rawExports.memory;
      const table = rawExports.table;
      const alloc2 = rawExports["__alloc"];
      const retain = rawExports["__retain"];
      const rttiBase = rawExports["__rtti_base"] || ~0;
      function getInfo(id) {
        const U32 = new Uint32Array(memory.buffer);
        const count = U32[rttiBase >>> 2];
        if ((id >>>= 0) >= count)
          throw Error("invalid id: " + id);
        return U32[(rttiBase + 4 >>> 2) + id * 2];
      }
      function getBase(id) {
        const U32 = new Uint32Array(memory.buffer);
        const count = U32[rttiBase >>> 2];
        if ((id >>>= 0) >= count)
          throw Error("invalid id: " + id);
        return U32[(rttiBase + 4 >>> 2) + id * 2 + 1];
      }
      function getValueAlign(info) {
        return 31 - Math.clz32(info >>> VAL_ALIGN_OFFSET & 31);
      }
      function getKeyAlign(info) {
        return 31 - Math.clz32(info >>> KEY_ALIGN_OFFSET & 31);
      }
      function __allocString(str) {
        const length2 = str.length;
        const ptr = alloc2(length2 << 1, STRING_ID);
        const U16 = new Uint16Array(memory.buffer);
        for (var i = 0, p = ptr >>> 1; i < length2; ++i)
          U16[p + i] = str.charCodeAt(i);
        return ptr;
      }
      baseModule.__allocString = __allocString;
      function __getString(ptr) {
        const buffer2 = memory.buffer;
        const id = new Uint32Array(buffer2)[ptr + ID_OFFSET >>> 2];
        if (id !== STRING_ID)
          throw Error("not a string: " + ptr);
        return getStringImpl(buffer2, ptr);
      }
      baseModule.__getString = __getString;
      function getView(alignLog2, signed, float) {
        const buffer2 = memory.buffer;
        if (float) {
          switch (alignLog2) {
            case 2:
              return new Float32Array(buffer2);
            case 3:
              return new Float64Array(buffer2);
          }
        } else {
          switch (alignLog2) {
            case 0:
              return new (signed ? Int8Array : Uint8Array)(buffer2);
            case 1:
              return new (signed ? Int16Array : Uint16Array)(buffer2);
            case 2:
              return new (signed ? Int32Array : Uint32Array)(buffer2);
            case 3:
              return new (signed ? BigInt64Array : BigUint64Array)(buffer2);
          }
        }
        throw Error("unsupported align: " + alignLog2);
      }
      function __allocArray(id, values) {
        const info = getInfo(id);
        if (!(info & (ARRAYBUFFERVIEW | ARRAY)))
          throw Error("not an array: " + id + " @ " + info);
        const align = getValueAlign(info);
        const length2 = values.length;
        const buf2 = alloc2(length2 << align, ARRAYBUFFER_ID);
        const arr = alloc2(info & ARRAY ? ARRAY_SIZE : ARRAYBUFFERVIEW_SIZE, id);
        const U32 = new Uint32Array(memory.buffer);
        U32[arr + ARRAYBUFFERVIEW_BUFFER_OFFSET >>> 2] = retain(buf2);
        U32[arr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2] = buf2;
        U32[arr + ARRAYBUFFERVIEW_DATALENGTH_OFFSET >>> 2] = length2 << align;
        if (info & ARRAY)
          U32[arr + ARRAY_LENGTH_OFFSET >>> 2] = length2;
        const view = getView(align, info & VAL_SIGNED, info & VAL_FLOAT);
        if (info & VAL_MANAGED) {
          for (let i = 0; i < length2; ++i)
            view[(buf2 >>> align) + i] = retain(values[i]);
        } else {
          view.set(values, buf2 >>> align);
        }
        return arr;
      }
      baseModule.__allocArray = __allocArray;
      function __getArrayView(arr) {
        const U32 = new Uint32Array(memory.buffer);
        const id = U32[arr + ID_OFFSET >>> 2];
        const info = getInfo(id);
        if (!(info & ARRAYBUFFERVIEW))
          throw Error("not an array: " + id);
        const align = getValueAlign(info);
        var buf2 = U32[arr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2];
        const length2 = info & ARRAY ? U32[arr + ARRAY_LENGTH_OFFSET >>> 2] : U32[buf2 + SIZE_OFFSET >>> 2] >>> align;
        return getView(align, info & VAL_SIGNED, info & VAL_FLOAT).subarray(buf2 >>>= align, buf2 + length2);
      }
      baseModule.__getArrayView = __getArrayView;
      function __getArray(arr) {
        const input = __getArrayView(arr);
        const len = input.length;
        const out = new Array(len);
        for (let i = 0; i < len; i++)
          out[i] = input[i];
        return out;
      }
      baseModule.__getArray = __getArray;
      function __getArrayBuffer(ptr) {
        const buffer2 = memory.buffer;
        const length2 = new Uint32Array(buffer2)[ptr + SIZE_OFFSET >>> 2];
        return buffer2.slice(ptr, ptr + length2);
      }
      baseModule.__getArrayBuffer = __getArrayBuffer;
      function getTypedArray(Type2, alignLog2, ptr) {
        return new Type2(getTypedArrayView(Type2, alignLog2, ptr));
      }
      function getTypedArrayView(Type2, alignLog2, ptr) {
        const buffer2 = memory.buffer;
        const U32 = new Uint32Array(buffer2);
        const bufPtr = U32[ptr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2];
        return new Type2(buffer2, bufPtr, U32[bufPtr + SIZE_OFFSET >>> 2] >>> alignLog2);
      }
      baseModule.__getInt8Array = getTypedArray.bind(null, Int8Array, 0);
      baseModule.__getInt8ArrayView = getTypedArrayView.bind(null, Int8Array, 0);
      baseModule.__getUint8Array = getTypedArray.bind(null, Uint8Array, 0);
      baseModule.__getUint8ArrayView = getTypedArrayView.bind(null, Uint8Array, 0);
      baseModule.__getUint8ClampedArray = getTypedArray.bind(null, Uint8ClampedArray, 0);
      baseModule.__getUint8ClampedArrayView = getTypedArrayView.bind(null, Uint8ClampedArray, 0);
      baseModule.__getInt16Array = getTypedArray.bind(null, Int16Array, 1);
      baseModule.__getInt16ArrayView = getTypedArrayView.bind(null, Int16Array, 1);
      baseModule.__getUint16Array = getTypedArray.bind(null, Uint16Array, 1);
      baseModule.__getUint16ArrayView = getTypedArrayView.bind(null, Uint16Array, 1);
      baseModule.__getInt32Array = getTypedArray.bind(null, Int32Array, 2);
      baseModule.__getInt32ArrayView = getTypedArrayView.bind(null, Int32Array, 2);
      baseModule.__getUint32Array = getTypedArray.bind(null, Uint32Array, 2);
      baseModule.__getUint32ArrayView = getTypedArrayView.bind(null, Uint32Array, 2);
      if (BIGINT) {
        baseModule.__getInt64Array = getTypedArray.bind(null, BigInt64Array, 3);
        baseModule.__getInt64ArrayView = getTypedArrayView.bind(null, BigInt64Array, 3);
        baseModule.__getUint64Array = getTypedArray.bind(null, BigUint64Array, 3);
        baseModule.__getUint64ArrayView = getTypedArrayView.bind(null, BigUint64Array, 3);
      }
      baseModule.__getFloat32Array = getTypedArray.bind(null, Float32Array, 2);
      baseModule.__getFloat32ArrayView = getTypedArrayView.bind(null, Float32Array, 2);
      baseModule.__getFloat64Array = getTypedArray.bind(null, Float64Array, 3);
      baseModule.__getFloat64ArrayView = getTypedArrayView.bind(null, Float64Array, 3);
      function __instanceof(ptr, baseId) {
        const U32 = new Uint32Array(memory.buffer);
        var id = U32[ptr + ID_OFFSET >>> 2];
        if (id <= U32[rttiBase >>> 2]) {
          do
            if (id == baseId)
              return true;
          while (id = getBase(id));
        }
        return false;
      }
      baseModule.__instanceof = __instanceof;
      baseModule.memory = baseModule.memory || memory;
      baseModule.table = baseModule.table || table;
      return demangle(rawExports, baseModule);
    }
    function isResponse(o) {
      return typeof Response !== "undefined" && o instanceof Response;
    }
    function instantiate(source, imports) {
      return __async(this, null, function* () {
        if (isResponse(source = yield source))
          return instantiateStreaming(source, imports);
        return postInstantiate(
          preInstantiate(imports || (imports = {})),
          yield WebAssembly.instantiate(
            source instanceof WebAssembly.Module ? source : yield WebAssembly.compile(source),
            imports
          )
        );
      });
    }
    exports2.instantiate = instantiate;
    function instantiateSync(source, imports) {
      return postInstantiate(
        preInstantiate(imports || (imports = {})),
        new WebAssembly.Instance(
          source instanceof WebAssembly.Module ? source : new WebAssembly.Module(source),
          imports
        )
      );
    }
    exports2.instantiateSync = instantiateSync;
    function instantiateStreaming(source, imports) {
      return __async(this, null, function* () {
        if (!WebAssembly.instantiateStreaming) {
          return instantiate(
            isResponse(source = yield source) ? source.arrayBuffer() : source,
            imports
          );
        }
        return postInstantiate(
          preInstantiate(imports || (imports = {})),
          (yield WebAssembly.instantiateStreaming(source, imports)).instance
        );
      });
    }
    exports2.instantiateStreaming = instantiateStreaming;
    function demangle(exports3, baseModule) {
      var module3 = baseModule ? Object.create(baseModule) : {};
      var setArgumentsLength = exports3["__argumentsLength"] ? function(length2) {
        exports3["__argumentsLength"].value = length2;
      } : exports3["__setArgumentsLength"] || exports3["__setargc"] || function() {
      };
      for (let internalName in exports3) {
        if (!Object.prototype.hasOwnProperty.call(exports3, internalName))
          continue;
        const elem = exports3[internalName];
        let parts = internalName.split(".");
        let curr = module3;
        while (parts.length > 1) {
          let part = parts.shift();
          if (!Object.prototype.hasOwnProperty.call(curr, part))
            curr[part] = {};
          curr = curr[part];
        }
        let name5 = parts[0];
        let hash = name5.indexOf("#");
        if (hash >= 0) {
          let className = name5.substring(0, hash);
          let classElem = curr[className];
          if (typeof classElem === "undefined" || !classElem.prototype) {
            let ctor = function(...args) {
              return ctor.wrap(ctor.prototype.constructor(0, ...args));
            };
            ctor.prototype = {
              valueOf: function valueOf() {
                return this[THIS];
              }
            };
            ctor.wrap = function(thisValue) {
              return Object.create(ctor.prototype, { [THIS]: { value: thisValue, writable: false } });
            };
            if (classElem)
              Object.getOwnPropertyNames(classElem).forEach(
                (name6) => Object.defineProperty(ctor, name6, Object.getOwnPropertyDescriptor(classElem, name6))
              );
            curr[className] = ctor;
          }
          name5 = name5.substring(hash + 1);
          curr = curr[className].prototype;
          if (/^(get|set):/.test(name5)) {
            if (!Object.prototype.hasOwnProperty.call(curr, name5 = name5.substring(4))) {
              let getter = exports3[internalName.replace("set:", "get:")];
              let setter = exports3[internalName.replace("get:", "set:")];
              Object.defineProperty(curr, name5, {
                get: function() {
                  return getter(this[THIS]);
                },
                set: function(value) {
                  setter(this[THIS], value);
                },
                enumerable: true
              });
            }
          } else {
            if (name5 === "constructor") {
              (curr[name5] = (...args) => {
                setArgumentsLength(args.length);
                return elem(...args);
              }).original = elem;
            } else {
              (curr[name5] = function(...args) {
                setArgumentsLength(args.length);
                return elem(this[THIS], ...args);
              }).original = elem;
            }
          }
        } else {
          if (/^(get|set):/.test(name5)) {
            if (!Object.prototype.hasOwnProperty.call(curr, name5 = name5.substring(4))) {
              Object.defineProperty(curr, name5, {
                get: exports3[internalName.replace("set:", "get:")],
                set: exports3[internalName.replace("get:", "set:")],
                enumerable: true
              });
            }
          } else if (typeof elem === "function" && elem !== setArgumentsLength) {
            (curr[name5] = (...args) => {
              setArgumentsLength(args.length);
              return elem(...args);
            }).original = elem;
          } else {
            curr[name5] = elem;
          }
        }
      }
      return module3;
    }
    exports2.demangle = demangle;
  }
});

// ../../node_modules/.pnpm/rabin-wasm@0.1.5/node_modules/rabin-wasm/dist/rabin-wasm.node.js
var require_rabin_wasm_node = __commonJS({
  "../../node_modules/.pnpm/rabin-wasm@0.1.5/node_modules/rabin-wasm/dist/rabin-wasm.node.js"(exports2, module2) {
    "use strict";
    var { instantiateSync } = require_loader();
    var fs5 = __require("fs");
    loadWebAssembly.supported = typeof WebAssembly !== "undefined";
    function loadWebAssembly() {
      return __async(this, arguments, function* (imp = {}) {
        if (!loadWebAssembly.supported)
          return null;
        return instantiateSync(fs5.readFileSync(__dirname + "/../dist/rabin.wasm"), imp);
      });
    }
    module2.exports = loadWebAssembly;
  }
});

// ../../node_modules/.pnpm/rabin-wasm@0.1.5/node_modules/rabin-wasm/src/index.js
var require_src = __commonJS({
  "../../node_modules/.pnpm/rabin-wasm@0.1.5/node_modules/rabin-wasm/src/index.js"(exports2, module2) {
    "use strict";
    var Rabin = require_rabin();
    var getRabin = require_rabin_wasm_node();
    var create4 = (avg, min, max, windowSize, polynomial) => __async(exports2, null, function* () {
      const compiled = yield getRabin();
      return new Rabin(compiled, avg, min, max, windowSize, polynomial);
    });
    module2.exports = {
      Rabin,
      create: create4
    };
  }
});

// ../../node_modules/.pnpm/sparse-array@1.3.2/node_modules/sparse-array/index.js
var require_sparse_array = __commonJS({
  "../../node_modules/.pnpm/sparse-array@1.3.2/node_modules/sparse-array/index.js"(exports2, module2) {
    "use strict";
    var BITS_PER_BYTE = 7;
    module2.exports = class SparseArray {
      constructor() {
        this._bitArrays = [];
        this._data = [];
        this._length = 0;
        this._changedLength = false;
        this._changedData = false;
      }
      set(index, value) {
        let pos = this._internalPositionFor(index, false);
        if (value === void 0) {
          if (pos !== -1) {
            this._unsetInternalPos(pos);
            this._unsetBit(index);
            this._changedLength = true;
            this._changedData = true;
          }
        } else {
          let needsSort = false;
          if (pos === -1) {
            pos = this._data.length;
            this._setBit(index);
            this._changedData = true;
          } else {
            needsSort = true;
          }
          this._setInternalPos(pos, index, value, needsSort);
          this._changedLength = true;
        }
      }
      unset(index) {
        this.set(index, void 0);
      }
      get(index) {
        this._sortData();
        const pos = this._internalPositionFor(index, true);
        if (pos === -1) {
          return void 0;
        }
        return this._data[pos][1];
      }
      push(value) {
        this.set(this.length, value);
        return this.length;
      }
      get length() {
        this._sortData();
        if (this._changedLength) {
          const last2 = this._data[this._data.length - 1];
          this._length = last2 ? last2[0] + 1 : 0;
          this._changedLength = false;
        }
        return this._length;
      }
      forEach(iterator) {
        let i = 0;
        while (i < this.length) {
          iterator(this.get(i), i, this);
          i++;
        }
      }
      map(iterator) {
        let i = 0;
        let mapped = new Array(this.length);
        while (i < this.length) {
          mapped[i] = iterator(this.get(i), i, this);
          i++;
        }
        return mapped;
      }
      reduce(reducer, initialValue) {
        let i = 0;
        let acc = initialValue;
        while (i < this.length) {
          const value = this.get(i);
          acc = reducer(acc, value, i);
          i++;
        }
        return acc;
      }
      find(finder) {
        let i = 0, found, last2;
        while (i < this.length && !found) {
          last2 = this.get(i);
          found = finder(last2);
          i++;
        }
        return found ? last2 : void 0;
      }
      _internalPositionFor(index, noCreate) {
        const bytePos = this._bytePosFor(index, noCreate);
        if (bytePos >= this._bitArrays.length) {
          return -1;
        }
        const byte = this._bitArrays[bytePos];
        const bitPos = index - bytePos * BITS_PER_BYTE;
        const exists = (byte & 1 << bitPos) > 0;
        if (!exists) {
          return -1;
        }
        const previousPopCount = this._bitArrays.slice(0, bytePos).reduce(popCountReduce, 0);
        const mask = ~(4294967295 << bitPos + 1);
        const bytePopCount = popCount(byte & mask);
        const arrayPos = previousPopCount + bytePopCount - 1;
        return arrayPos;
      }
      _bytePosFor(index, noCreate) {
        const bytePos = Math.floor(index / BITS_PER_BYTE);
        const targetLength = bytePos + 1;
        while (!noCreate && this._bitArrays.length < targetLength) {
          this._bitArrays.push(0);
        }
        return bytePos;
      }
      _setBit(index) {
        const bytePos = this._bytePosFor(index, false);
        this._bitArrays[bytePos] |= 1 << index - bytePos * BITS_PER_BYTE;
      }
      _unsetBit(index) {
        const bytePos = this._bytePosFor(index, false);
        this._bitArrays[bytePos] &= ~(1 << index - bytePos * BITS_PER_BYTE);
      }
      _setInternalPos(pos, index, value, needsSort) {
        const data = this._data;
        const elem = [index, value];
        if (needsSort) {
          this._sortData();
          data[pos] = elem;
        } else {
          if (data.length) {
            if (data[data.length - 1][0] >= index) {
              data.push(elem);
            } else if (data[0][0] <= index) {
              data.unshift(elem);
            } else {
              const randomIndex = Math.round(data.length / 2);
              this._data = data.slice(0, randomIndex).concat(elem).concat(data.slice(randomIndex));
            }
          } else {
            this._data.push(elem);
          }
          this._changedData = true;
          this._changedLength = true;
        }
      }
      _unsetInternalPos(pos) {
        this._data.splice(pos, 1);
      }
      _sortData() {
        if (this._changedData) {
          this._data.sort(sortInternal);
        }
        this._changedData = false;
      }
      bitField() {
        const bytes = [];
        let pendingBitsForResultingByte = 8;
        let pendingBitsForNewByte = 0;
        let resultingByte = 0;
        let newByte;
        const pending = this._bitArrays.slice();
        while (pending.length || pendingBitsForNewByte) {
          if (pendingBitsForNewByte === 0) {
            newByte = pending.shift();
            pendingBitsForNewByte = 7;
          }
          const usingBits = Math.min(pendingBitsForNewByte, pendingBitsForResultingByte);
          const mask = ~(255 << usingBits);
          const masked = newByte & mask;
          resultingByte |= masked << 8 - pendingBitsForResultingByte;
          newByte = newByte >>> usingBits;
          pendingBitsForNewByte -= usingBits;
          pendingBitsForResultingByte -= usingBits;
          if (!pendingBitsForResultingByte || !pendingBitsForNewByte && !pending.length) {
            bytes.push(resultingByte);
            resultingByte = 0;
            pendingBitsForResultingByte = 8;
          }
        }
        for (var i = bytes.length - 1; i > 0; i--) {
          const value = bytes[i];
          if (value === 0) {
            bytes.pop();
          } else {
            break;
          }
        }
        return bytes;
      }
      compactArray() {
        this._sortData();
        return this._data.map(valueOnly);
      }
    };
    function popCountReduce(count, byte) {
      return count + popCount(byte);
    }
    function popCount(_v) {
      let v = _v;
      v = v - (v >> 1 & 1431655765);
      v = (v & 858993459) + (v >> 2 & 858993459);
      return (v + (v >> 4) & 252645135) * 16843009 >> 24;
    }
    function sortInternal(a, b) {
      return a[0] - b[0];
    }
    function valueOnly(elem) {
      return elem[1];
    }
  }
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/vendor/base-x.js
var require_base_x = __commonJS({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/vendor/base-x.js"(exports2, module2) {
    "use strict";
    function base3(ALPHABET, name5) {
      if (ALPHABET.length >= 255) {
        throw new TypeError("Alphabet too long");
      }
      var BASE_MAP = new Uint8Array(256);
      for (var j = 0; j < BASE_MAP.length; j++) {
        BASE_MAP[j] = 255;
      }
      for (var i = 0; i < ALPHABET.length; i++) {
        var x = ALPHABET.charAt(i);
        var xc = x.charCodeAt(0);
        if (BASE_MAP[xc] !== 255) {
          throw new TypeError(x + " is ambiguous");
        }
        BASE_MAP[xc] = i;
      }
      var BASE = ALPHABET.length;
      var LEADER = ALPHABET.charAt(0);
      var FACTOR = Math.log(BASE) / Math.log(256);
      var iFACTOR = Math.log(256) / Math.log(BASE);
      function encode12(source) {
        if (source instanceof Uint8Array)
          ;
        else if (ArrayBuffer.isView(source)) {
          source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
        } else if (Array.isArray(source)) {
          source = Uint8Array.from(source);
        }
        if (!(source instanceof Uint8Array)) {
          throw new TypeError("Expected Uint8Array");
        }
        if (source.length === 0) {
          return "";
        }
        var zeroes = 0;
        var length2 = 0;
        var pbegin = 0;
        var pend = source.length;
        while (pbegin !== pend && source[pbegin] === 0) {
          pbegin++;
          zeroes++;
        }
        var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
        var b58 = new Uint8Array(size);
        while (pbegin !== pend) {
          var carry = source[pbegin];
          var i2 = 0;
          for (var it1 = size - 1; (carry !== 0 || i2 < length2) && it1 !== -1; it1--, i2++) {
            carry += 256 * b58[it1] >>> 0;
            b58[it1] = carry % BASE >>> 0;
            carry = carry / BASE >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length2 = i2;
          pbegin++;
        }
        var it2 = size - length2;
        while (it2 !== size && b58[it2] === 0) {
          it2++;
        }
        var str = LEADER.repeat(zeroes);
        for (; it2 < size; ++it2) {
          str += ALPHABET.charAt(b58[it2]);
        }
        return str;
      }
      function decodeUnsafe(source) {
        if (typeof source !== "string") {
          throw new TypeError("Expected String");
        }
        if (source.length === 0) {
          return new Uint8Array();
        }
        var psz = 0;
        if (source[psz] === " ") {
          return;
        }
        var zeroes = 0;
        var length2 = 0;
        while (source[psz] === LEADER) {
          zeroes++;
          psz++;
        }
        var size = (source.length - psz) * FACTOR + 1 >>> 0;
        var b256 = new Uint8Array(size);
        while (source[psz]) {
          var carry = BASE_MAP[source.charCodeAt(psz)];
          if (carry === 255) {
            return;
          }
          var i2 = 0;
          for (var it3 = size - 1; (carry !== 0 || i2 < length2) && it3 !== -1; it3--, i2++) {
            carry += BASE * b256[it3] >>> 0;
            b256[it3] = carry % 256 >>> 0;
            carry = carry / 256 >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length2 = i2;
          psz++;
        }
        if (source[psz] === " ") {
          return;
        }
        var it4 = size - length2;
        while (it4 !== size && b256[it4] === 0) {
          it4++;
        }
        var vch = new Uint8Array(zeroes + (size - it4));
        var j2 = zeroes;
        while (it4 !== size) {
          vch[j2++] = b256[it4++];
        }
        return vch;
      }
      function decode12(string2) {
        var buffer2 = decodeUnsafe(string2);
        if (buffer2) {
          return buffer2;
        }
        throw new Error(`Non-${name5} character`);
      }
      return {
        encode: encode12,
        decodeUnsafe,
        decode: decode12
      };
    }
    var src2 = base3;
    var _brrp__multiformats_scope_baseX2 = src2;
    module2.exports = _brrp__multiformats_scope_baseX2;
  }
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/bytes.js
var require_bytes = __commonJS({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/bytes.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var empty2 = new Uint8Array(0);
    var toHex2 = (d) => d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, "0"), "");
    var fromHex2 = (hex) => {
      const hexes = hex.match(/../g);
      return hexes ? new Uint8Array(hexes.map((b) => parseInt(b, 16))) : empty2;
    };
    var equals3 = (aa, bb) => {
      if (aa === bb)
        return true;
      if (aa.byteLength !== bb.byteLength) {
        return false;
      }
      for (let ii = 0; ii < aa.byteLength; ii++) {
        if (aa[ii] !== bb[ii]) {
          return false;
        }
      }
      return true;
    };
    var coerce3 = (o) => {
      if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
        return o;
      if (o instanceof ArrayBuffer)
        return new Uint8Array(o);
      if (ArrayBuffer.isView(o)) {
        return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
      }
      throw new Error("Unknown type, must be binary type");
    };
    var isBinary2 = (o) => o instanceof ArrayBuffer || ArrayBuffer.isView(o);
    var fromString4 = (str) => new TextEncoder().encode(str);
    var toString3 = (b) => new TextDecoder().decode(b);
    exports2.coerce = coerce3;
    exports2.empty = empty2;
    exports2.equals = equals3;
    exports2.fromHex = fromHex2;
    exports2.fromString = fromString4;
    exports2.isBinary = isBinary2;
    exports2.toHex = toHex2;
    exports2.toString = toString3;
  }
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/bases/base.js
var require_base = __commonJS({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/bases/base.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var baseX$1 = require_base_x();
    var bytes = require_bytes();
    var Encoder3 = class {
      constructor(name5, prefix, baseEncode) {
        this.name = name5;
        this.prefix = prefix;
        this.baseEncode = baseEncode;
      }
      encode(bytes2) {
        if (bytes2 instanceof Uint8Array) {
          return `${this.prefix}${this.baseEncode(bytes2)}`;
        } else {
          throw Error("Unknown type, must be binary type");
        }
      }
    };
    var Decoder3 = class {
      constructor(name5, prefix, baseDecode) {
        this.name = name5;
        this.prefix = prefix;
        if (prefix.codePointAt(0) === void 0) {
          throw new Error("Invalid prefix character");
        }
        this.prefixCodePoint = prefix.codePointAt(0);
        this.baseDecode = baseDecode;
      }
      decode(text) {
        if (typeof text === "string") {
          if (text.codePointAt(0) !== this.prefixCodePoint) {
            throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
          }
          return this.baseDecode(text.slice(this.prefix.length));
        } else {
          throw Error("Can only multibase decode strings");
        }
      }
      or(decoder2) {
        return or2(this, decoder2);
      }
    };
    var ComposedDecoder2 = class {
      constructor(decoders) {
        this.decoders = decoders;
      }
      or(decoder2) {
        return or2(this, decoder2);
      }
      decode(input) {
        const prefix = input[0];
        const decoder2 = this.decoders[prefix];
        if (decoder2) {
          return decoder2.decode(input);
        } else {
          throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
        }
      }
    };
    var or2 = (left, right) => new ComposedDecoder2(__spreadValues(__spreadValues({}, left.decoders || { [left.prefix]: left }), right.decoders || { [right.prefix]: right }));
    var Codec2 = class {
      constructor(name5, prefix, baseEncode, baseDecode) {
        this.name = name5;
        this.prefix = prefix;
        this.baseEncode = baseEncode;
        this.baseDecode = baseDecode;
        this.encoder = new Encoder3(name5, prefix, baseEncode);
        this.decoder = new Decoder3(name5, prefix, baseDecode);
      }
      encode(input) {
        return this.encoder.encode(input);
      }
      decode(input) {
        return this.decoder.decode(input);
      }
    };
    var from3 = ({ name: name5, prefix, encode: encode13, decode: decode13 }) => new Codec2(name5, prefix, encode13, decode13);
    var baseX2 = ({ prefix, name: name5, alphabet: alphabet2 }) => {
      const { encode: encode13, decode: decode13 } = baseX$1(alphabet2, name5);
      return from3({
        prefix,
        name: name5,
        encode: encode13,
        decode: (text) => bytes.coerce(decode13(text))
      });
    };
    var decode12 = (string2, alphabet2, bitsPerChar, name5) => {
      const codes = {};
      for (let i = 0; i < alphabet2.length; ++i) {
        codes[alphabet2[i]] = i;
      }
      let end = string2.length;
      while (string2[end - 1] === "=") {
        --end;
      }
      const out = new Uint8Array(end * bitsPerChar / 8 | 0);
      let bits = 0;
      let buffer2 = 0;
      let written = 0;
      for (let i = 0; i < end; ++i) {
        const value = codes[string2[i]];
        if (value === void 0) {
          throw new SyntaxError(`Non-${name5} character`);
        }
        buffer2 = buffer2 << bitsPerChar | value;
        bits += bitsPerChar;
        if (bits >= 8) {
          bits -= 8;
          out[written++] = 255 & buffer2 >> bits;
        }
      }
      if (bits >= bitsPerChar || 255 & buffer2 << 8 - bits) {
        throw new SyntaxError("Unexpected end of data");
      }
      return out;
    };
    var encode12 = (data, alphabet2, bitsPerChar) => {
      const pad = alphabet2[alphabet2.length - 1] === "=";
      const mask = (1 << bitsPerChar) - 1;
      let out = "";
      let bits = 0;
      let buffer2 = 0;
      for (let i = 0; i < data.length; ++i) {
        buffer2 = buffer2 << 8 | data[i];
        bits += 8;
        while (bits > bitsPerChar) {
          bits -= bitsPerChar;
          out += alphabet2[mask & buffer2 >> bits];
        }
      }
      if (bits) {
        out += alphabet2[mask & buffer2 << bitsPerChar - bits];
      }
      if (pad) {
        while (out.length * bitsPerChar & 7) {
          out += "=";
        }
      }
      return out;
    };
    var rfc46482 = ({ name: name5, prefix, bitsPerChar, alphabet: alphabet2 }) => {
      return from3({
        prefix,
        name: name5,
        encode(input) {
          return encode12(input, alphabet2, bitsPerChar);
        },
        decode(input) {
          return decode12(input, alphabet2, bitsPerChar, name5);
        }
      });
    };
    exports2.Codec = Codec2;
    exports2.baseX = baseX2;
    exports2.from = from3;
    exports2.or = or2;
    exports2.rfc4648 = rfc46482;
  }
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/bases/identity.js
var require_identity = __commonJS({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/bases/identity.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var base3 = require_base();
    var bytes = require_bytes();
    var identity3 = base3.from({
      prefix: "\0",
      name: "identity",
      encode: (buf2) => bytes.toString(buf2),
      decode: (str) => bytes.fromString(str)
    });
    exports2.identity = identity3;
  }
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/bases/base2.js
var require_base2 = __commonJS({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/bases/base2.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var base3 = require_base();
    var base22 = base3.rfc4648({
      prefix: "0",
      name: "base2",
      alphabet: "01",
      bitsPerChar: 1
    });
    exports2.base2 = base22;
  }
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/bases/base8.js
var require_base8 = __commonJS({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/bases/base8.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var base3 = require_base();
    var base82 = base3.rfc4648({
      prefix: "7",
      name: "base8",
      alphabet: "01234567",
      bitsPerChar: 3
    });
    exports2.base8 = base82;
  }
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/bases/base10.js
var require_base10 = __commonJS({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/bases/base10.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var base3 = require_base();
    var base102 = base3.baseX({
      prefix: "9",
      name: "base10",
      alphabet: "0123456789"
    });
    exports2.base10 = base102;
  }
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/bases/base16.js
var require_base16 = __commonJS({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/bases/base16.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var base3 = require_base();
    var base162 = base3.rfc4648({
      prefix: "f",
      name: "base16",
      alphabet: "0123456789abcdef",
      bitsPerChar: 4
    });
    var base16upper2 = base3.rfc4648({
      prefix: "F",
      name: "base16upper",
      alphabet: "0123456789ABCDEF",
      bitsPerChar: 4
    });
    exports2.base16 = base162;
    exports2.base16upper = base16upper2;
  }
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/bases/base32.js
var require_base32 = __commonJS({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/bases/base32.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var base3 = require_base();
    var base322 = base3.rfc4648({
      prefix: "b",
      name: "base32",
      alphabet: "abcdefghijklmnopqrstuvwxyz234567",
      bitsPerChar: 5
    });
    var base32upper2 = base3.rfc4648({
      prefix: "B",
      name: "base32upper",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
      bitsPerChar: 5
    });
    var base32pad2 = base3.rfc4648({
      prefix: "c",
      name: "base32pad",
      alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
      bitsPerChar: 5
    });
    var base32padupper2 = base3.rfc4648({
      prefix: "C",
      name: "base32padupper",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
      bitsPerChar: 5
    });
    var base32hex2 = base3.rfc4648({
      prefix: "v",
      name: "base32hex",
      alphabet: "0123456789abcdefghijklmnopqrstuv",
      bitsPerChar: 5
    });
    var base32hexupper2 = base3.rfc4648({
      prefix: "V",
      name: "base32hexupper",
      alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
      bitsPerChar: 5
    });
    var base32hexpad2 = base3.rfc4648({
      prefix: "t",
      name: "base32hexpad",
      alphabet: "0123456789abcdefghijklmnopqrstuv=",
      bitsPerChar: 5
    });
    var base32hexpadupper2 = base3.rfc4648({
      prefix: "T",
      name: "base32hexpadupper",
      alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
      bitsPerChar: 5
    });
    var base32z2 = base3.rfc4648({
      prefix: "h",
      name: "base32z",
      alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
      bitsPerChar: 5
    });
    exports2.base32 = base322;
    exports2.base32hex = base32hex2;
    exports2.base32hexpad = base32hexpad2;
    exports2.base32hexpadupper = base32hexpadupper2;
    exports2.base32hexupper = base32hexupper2;
    exports2.base32pad = base32pad2;
    exports2.base32padupper = base32padupper2;
    exports2.base32upper = base32upper2;
    exports2.base32z = base32z2;
  }
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/bases/base36.js
var require_base36 = __commonJS({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/bases/base36.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var base3 = require_base();
    var base362 = base3.baseX({
      prefix: "k",
      name: "base36",
      alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
    });
    var base36upper2 = base3.baseX({
      prefix: "K",
      name: "base36upper",
      alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    });
    exports2.base36 = base362;
    exports2.base36upper = base36upper2;
  }
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/bases/base58.js
var require_base58 = __commonJS({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/bases/base58.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var base3 = require_base();
    var base58btc2 = base3.baseX({
      name: "base58btc",
      prefix: "z",
      alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
    });
    var base58flickr2 = base3.baseX({
      name: "base58flickr",
      prefix: "Z",
      alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
    });
    exports2.base58btc = base58btc2;
    exports2.base58flickr = base58flickr2;
  }
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/bases/base64.js
var require_base642 = __commonJS({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/bases/base64.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var base3 = require_base();
    var base642 = base3.rfc4648({
      prefix: "m",
      name: "base64",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
      bitsPerChar: 6
    });
    var base64pad2 = base3.rfc4648({
      prefix: "M",
      name: "base64pad",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
      bitsPerChar: 6
    });
    var base64url2 = base3.rfc4648({
      prefix: "u",
      name: "base64url",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
      bitsPerChar: 6
    });
    var base64urlpad2 = base3.rfc4648({
      prefix: "U",
      name: "base64urlpad",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
      bitsPerChar: 6
    });
    exports2.base64 = base642;
    exports2.base64pad = base64pad2;
    exports2.base64url = base64url2;
    exports2.base64urlpad = base64urlpad2;
  }
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/bases/base256emoji.js
var require_base256emoji = __commonJS({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/bases/base256emoji.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var base3 = require_base();
    var alphabet2 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
    var alphabetBytesToChars2 = alphabet2.reduce((p, c, i) => {
      p[i] = c;
      return p;
    }, []);
    var alphabetCharsToBytes2 = alphabet2.reduce((p, c, i) => {
      p[c.codePointAt(0)] = i;
      return p;
    }, []);
    function encode12(data) {
      return data.reduce((p, c) => {
        p += alphabetBytesToChars2[c];
        return p;
      }, "");
    }
    function decode12(str) {
      const byts = [];
      for (const char of str) {
        const byt = alphabetCharsToBytes2[char.codePointAt(0)];
        if (byt === void 0) {
          throw new Error(`Non-base256emoji character: ${char}`);
        }
        byts.push(byt);
      }
      return new Uint8Array(byts);
    }
    var base256emoji2 = base3.from({
      prefix: "\u{1F680}",
      name: "base256emoji",
      encode: encode12,
      decode: decode12
    });
    exports2.base256emoji = base256emoji2;
  }
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/vendor/varint.js
var require_varint2 = __commonJS({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/vendor/varint.js"(exports2, module2) {
    "use strict";
    var encode_12 = encode12;
    var MSB2 = 128;
    var REST2 = 127;
    var MSBALL2 = ~REST2;
    var INT2 = Math.pow(2, 31);
    function encode12(num, out, offset) {
      out = out || [];
      offset = offset || 0;
      var oldOffset = offset;
      while (num >= INT2) {
        out[offset++] = num & 255 | MSB2;
        num /= 128;
      }
      while (num & MSBALL2) {
        out[offset++] = num & 255 | MSB2;
        num >>>= 7;
      }
      out[offset] = num | 0;
      encode12.bytes = offset - oldOffset + 1;
      return out;
    }
    var decode12 = read2;
    var MSB$12 = 128;
    var REST$12 = 127;
    function read2(buf2, offset) {
      var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf2.length;
      do {
        if (counter >= l) {
          read2.bytes = 0;
          throw new RangeError("Could not decode varint");
        }
        b = buf2[counter++];
        res += shift < 28 ? (b & REST$12) << shift : (b & REST$12) * Math.pow(2, shift);
        shift += 7;
      } while (b >= MSB$12);
      read2.bytes = counter - offset;
      return res;
    }
    var N12 = Math.pow(2, 7);
    var N22 = Math.pow(2, 14);
    var N32 = Math.pow(2, 21);
    var N42 = Math.pow(2, 28);
    var N52 = Math.pow(2, 35);
    var N62 = Math.pow(2, 42);
    var N72 = Math.pow(2, 49);
    var N82 = Math.pow(2, 56);
    var N92 = Math.pow(2, 63);
    var length2 = function(value) {
      return value < N12 ? 1 : value < N22 ? 2 : value < N32 ? 3 : value < N42 ? 4 : value < N52 ? 5 : value < N62 ? 6 : value < N72 ? 7 : value < N82 ? 8 : value < N92 ? 9 : 10;
    };
    var varint4 = {
      encode: encode_12,
      decode: decode12,
      encodingLength: length2
    };
    var _brrp_varint2 = varint4;
    var varint$1 = _brrp_varint2;
    module2.exports = varint$1;
  }
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/varint.js
var require_varint3 = __commonJS({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/varint.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var varint$1 = require_varint2();
    var decode12 = (data, offset = 0) => {
      const code5 = varint$1.decode(data, offset);
      return [
        code5,
        varint$1.decode.bytes
      ];
    };
    var encodeTo2 = (int, target, offset = 0) => {
      varint$1.encode(int, target, offset);
      return target;
    };
    var encodingLength2 = (int) => {
      return varint$1.encodingLength(int);
    };
    exports2.decode = decode12;
    exports2.encodeTo = encodeTo2;
    exports2.encodingLength = encodingLength2;
  }
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/hashes/digest.js
var require_digest = __commonJS({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/hashes/digest.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var bytes = require_bytes();
    var varint4 = require_varint3();
    var create4 = (code5, digest2) => {
      const size = digest2.byteLength;
      const sizeOffset = varint4.encodingLength(code5);
      const digestOffset = sizeOffset + varint4.encodingLength(size);
      const bytes2 = new Uint8Array(digestOffset + size);
      varint4.encodeTo(code5, bytes2, 0);
      varint4.encodeTo(size, bytes2, sizeOffset);
      bytes2.set(digest2, digestOffset);
      return new Digest2(code5, size, digest2, bytes2);
    };
    var decode12 = (multihash) => {
      const bytes$1 = bytes.coerce(multihash);
      const [code5, sizeOffset] = varint4.decode(bytes$1);
      const [size, digestOffset] = varint4.decode(bytes$1.subarray(sizeOffset));
      const digest2 = bytes$1.subarray(sizeOffset + digestOffset);
      if (digest2.byteLength !== size) {
        throw new Error("Incorrect length");
      }
      return new Digest2(code5, size, digest2, bytes$1);
    };
    var equals3 = (a, b) => {
      if (a === b) {
        return true;
      } else {
        return a.code === b.code && a.size === b.size && bytes.equals(a.bytes, b.bytes);
      }
    };
    var Digest2 = class {
      constructor(code5, size, digest2, bytes2) {
        this.code = code5;
        this.size = size;
        this.digest = digest2;
        this.bytes = bytes2;
      }
    };
    exports2.Digest = Digest2;
    exports2.create = create4;
    exports2.decode = decode12;
    exports2.equals = equals3;
  }
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/hashes/hasher.js
var require_hasher = __commonJS({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/hashes/hasher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var digest2 = require_digest();
    var from3 = ({ name: name5, code: code5, encode: encode12 }) => new Hasher2(name5, code5, encode12);
    var Hasher2 = class {
      constructor(name5, code5, encode12) {
        this.name = name5;
        this.code = code5;
        this.encode = encode12;
      }
      digest(input) {
        if (input instanceof Uint8Array) {
          const result = this.encode(input);
          return result instanceof Uint8Array ? digest2.create(this.code, result) : result.then((digest$1) => digest2.create(this.code, digest$1));
        } else {
          throw Error("Unknown type, must be binary type");
        }
      }
    };
    exports2.Hasher = Hasher2;
    exports2.from = from3;
  }
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/hashes/sha2.js
var require_sha2 = __commonJS({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/hashes/sha2.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var crypto2 = __require("crypto");
    var hasher = require_hasher();
    var bytes = require_bytes();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var crypto__default = /* @__PURE__ */ _interopDefaultLegacy(crypto2);
    var sha2562 = hasher.from({
      name: "sha2-256",
      code: 18,
      encode: (input) => bytes.coerce(crypto__default["default"].createHash("sha256").update(input).digest())
    });
    var sha5122 = hasher.from({
      name: "sha2-512",
      code: 19,
      encode: (input) => bytes.coerce(crypto__default["default"].createHash("sha512").update(input).digest())
    });
    exports2.sha256 = sha2562;
    exports2.sha512 = sha5122;
  }
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/hashes/identity.js
var require_identity2 = __commonJS({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/hashes/identity.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var bytes = require_bytes();
    var digest$1 = require_digest();
    var code5 = 0;
    var name5 = "identity";
    var encode12 = bytes.coerce;
    var digest2 = (input) => digest$1.create(code5, encode12(input));
    var identity3 = {
      code: code5,
      name: name5,
      encode: encode12,
      digest: digest2
    };
    exports2.identity = identity3;
  }
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/codecs/raw.js
var require_raw = __commonJS({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/codecs/raw.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var bytes = require_bytes();
    var name5 = "raw";
    var code5 = 85;
    var encode12 = (node) => bytes.coerce(node);
    var decode12 = (data) => bytes.coerce(data);
    exports2.code = code5;
    exports2.decode = decode12;
    exports2.encode = encode12;
    exports2.name = name5;
  }
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/codecs/json.js
var require_json = __commonJS({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/codecs/json.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var textEncoder5 = new TextEncoder();
    var textDecoder4 = new TextDecoder();
    var name5 = "json";
    var code5 = 512;
    var encode12 = (node) => textEncoder5.encode(JSON.stringify(node));
    var decode12 = (data) => JSON.parse(textDecoder4.decode(data));
    exports2.code = code5;
    exports2.decode = decode12;
    exports2.encode = encode12;
    exports2.name = name5;
  }
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/cid.js
var require_cid = __commonJS({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/cid.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var varint4 = require_varint3();
    var digest2 = require_digest();
    var base58 = require_base58();
    var base322 = require_base32();
    var bytes = require_bytes();
    var CID2 = class _CID {
      constructor(version3, code5, multihash, bytes2) {
        this.code = code5;
        this.version = version3;
        this.multihash = multihash;
        this.bytes = bytes2;
        this.byteOffset = bytes2.byteOffset;
        this.byteLength = bytes2.byteLength;
        this.asCID = this;
        this._baseCache = /* @__PURE__ */ new Map();
        Object.defineProperties(this, {
          byteOffset: hidden2,
          byteLength: hidden2,
          code: readonly3,
          version: readonly3,
          multihash: readonly3,
          bytes: readonly3,
          _baseCache: hidden2,
          asCID: hidden2
        });
      }
      toV0() {
        switch (this.version) {
          case 0: {
            return this;
          }
          default: {
            const { code: code5, multihash } = this;
            if (code5 !== DAG_PB_CODE2) {
              throw new Error("Cannot convert a non dag-pb CID to CIDv0");
            }
            if (multihash.code !== SHA_256_CODE2) {
              throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
            }
            return _CID.createV0(multihash);
          }
        }
      }
      toV1() {
        switch (this.version) {
          case 0: {
            const { code: code5, digest: digest$1 } = this.multihash;
            const multihash = digest2.create(code5, digest$1);
            return _CID.createV1(this.code, multihash);
          }
          case 1: {
            return this;
          }
          default: {
            throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
          }
        }
      }
      equals(other) {
        return other && this.code === other.code && this.version === other.version && digest2.equals(this.multihash, other.multihash);
      }
      toString(base3) {
        const { bytes: bytes2, version: version3, _baseCache } = this;
        switch (version3) {
          case 0:
            return toStringV02(bytes2, _baseCache, base3 || base58.base58btc.encoder);
          default:
            return toStringV12(bytes2, _baseCache, base3 || base322.base32.encoder);
        }
      }
      toJSON() {
        return {
          code: this.code,
          version: this.version,
          hash: this.multihash.bytes
        };
      }
      get [Symbol.toStringTag]() {
        return "CID";
      }
      [Symbol.for("nodejs.util.inspect.custom")]() {
        return "CID(" + this.toString() + ")";
      }
      static isCID(value) {
        deprecate2(/^0\.0/, IS_CID_DEPRECATION2);
        return !!(value && (value[cidSymbol2] || value.asCID === value));
      }
      get toBaseEncodedString() {
        throw new Error("Deprecated, use .toString()");
      }
      get codec() {
        throw new Error('"codec" property is deprecated, use integer "code" property instead');
      }
      get buffer() {
        throw new Error("Deprecated .buffer property, use .bytes to get Uint8Array instead");
      }
      get multibaseName() {
        throw new Error('"multibaseName" property is deprecated');
      }
      get prefix() {
        throw new Error('"prefix" property is deprecated');
      }
      static asCID(value) {
        if (value instanceof _CID) {
          return value;
        } else if (value != null && value.asCID === value) {
          const { version: version3, code: code5, multihash, bytes: bytes2 } = value;
          return new _CID(version3, code5, multihash, bytes2 || encodeCID2(version3, code5, multihash.bytes));
        } else if (value != null && value[cidSymbol2] === true) {
          const { version: version3, multihash, code: code5 } = value;
          const digest$1 = digest2.decode(multihash);
          return _CID.create(version3, code5, digest$1);
        } else {
          return null;
        }
      }
      static create(version3, code5, digest3) {
        if (typeof code5 !== "number") {
          throw new Error("String codecs are no longer supported");
        }
        switch (version3) {
          case 0: {
            if (code5 !== DAG_PB_CODE2) {
              throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE2}) block encoding`);
            } else {
              return new _CID(version3, code5, digest3, digest3.bytes);
            }
          }
          case 1: {
            const bytes2 = encodeCID2(version3, code5, digest3.bytes);
            return new _CID(version3, code5, digest3, bytes2);
          }
          default: {
            throw new Error("Invalid version");
          }
        }
      }
      static createV0(digest3) {
        return _CID.create(0, DAG_PB_CODE2, digest3);
      }
      static createV1(code5, digest3) {
        return _CID.create(1, code5, digest3);
      }
      static decode(bytes2) {
        const [cid, remainder] = _CID.decodeFirst(bytes2);
        if (remainder.length) {
          throw new Error("Incorrect length");
        }
        return cid;
      }
      static decodeFirst(bytes$1) {
        const specs = _CID.inspectBytes(bytes$1);
        const prefixSize = specs.size - specs.multihashSize;
        const multihashBytes = bytes.coerce(bytes$1.subarray(prefixSize, prefixSize + specs.multihashSize));
        if (multihashBytes.byteLength !== specs.multihashSize) {
          throw new Error("Incorrect length");
        }
        const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
        const digest$1 = new digest2.Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
        const cid = specs.version === 0 ? _CID.createV0(digest$1) : _CID.createV1(specs.codec, digest$1);
        return [
          cid,
          bytes$1.subarray(specs.size)
        ];
      }
      static inspectBytes(initialBytes) {
        let offset = 0;
        const next = () => {
          const [i, length2] = varint4.decode(initialBytes.subarray(offset));
          offset += length2;
          return i;
        };
        let version3 = next();
        let codec = DAG_PB_CODE2;
        if (version3 === 18) {
          version3 = 0;
          offset = 0;
        } else if (version3 === 1) {
          codec = next();
        }
        if (version3 !== 0 && version3 !== 1) {
          throw new RangeError(`Invalid CID version ${version3}`);
        }
        const prefixSize = offset;
        const multihashCode = next();
        const digestSize = next();
        const size = offset + digestSize;
        const multihashSize = size - prefixSize;
        return {
          version: version3,
          codec,
          multihashCode,
          digestSize,
          multihashSize,
          size
        };
      }
      static parse(source, base3) {
        const [prefix, bytes2] = parseCIDtoBytes2(source, base3);
        const cid = _CID.decode(bytes2);
        cid._baseCache.set(prefix, source);
        return cid;
      }
    };
    var parseCIDtoBytes2 = (source, base3) => {
      switch (source[0]) {
        case "Q": {
          const decoder2 = base3 || base58.base58btc;
          return [
            base58.base58btc.prefix,
            decoder2.decode(`${base58.base58btc.prefix}${source}`)
          ];
        }
        case base58.base58btc.prefix: {
          const decoder2 = base3 || base58.base58btc;
          return [
            base58.base58btc.prefix,
            decoder2.decode(source)
          ];
        }
        case base322.base32.prefix: {
          const decoder2 = base3 || base322.base32;
          return [
            base322.base32.prefix,
            decoder2.decode(source)
          ];
        }
        default: {
          if (base3 == null) {
            throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
          }
          return [
            source[0],
            base3.decode(source)
          ];
        }
      }
    };
    var toStringV02 = (bytes2, cache, base3) => {
      const { prefix } = base3;
      if (prefix !== base58.base58btc.prefix) {
        throw Error(`Cannot string encode V0 in ${base3.name} encoding`);
      }
      const cid = cache.get(prefix);
      if (cid == null) {
        const cid2 = base3.encode(bytes2).slice(1);
        cache.set(prefix, cid2);
        return cid2;
      } else {
        return cid;
      }
    };
    var toStringV12 = (bytes2, cache, base3) => {
      const { prefix } = base3;
      const cid = cache.get(prefix);
      if (cid == null) {
        const cid2 = base3.encode(bytes2);
        cache.set(prefix, cid2);
        return cid2;
      } else {
        return cid;
      }
    };
    var DAG_PB_CODE2 = 112;
    var SHA_256_CODE2 = 18;
    var encodeCID2 = (version3, code5, multihash) => {
      const codeOffset = varint4.encodingLength(version3);
      const hashOffset = codeOffset + varint4.encodingLength(code5);
      const bytes2 = new Uint8Array(hashOffset + multihash.byteLength);
      varint4.encodeTo(version3, bytes2, 0);
      varint4.encodeTo(code5, bytes2, codeOffset);
      bytes2.set(multihash, hashOffset);
      return bytes2;
    };
    var cidSymbol2 = Symbol.for("@ipld/js-cid/CID");
    var readonly3 = {
      writable: false,
      configurable: false,
      enumerable: true
    };
    var hidden2 = {
      writable: false,
      enumerable: false,
      configurable: false
    };
    var version2 = "0.0.0-dev";
    var deprecate2 = (range, message) => {
      if (range.test(version2)) {
        console.warn(message);
      } else {
        throw new Error(message);
      }
    };
    var IS_CID_DEPRECATION2 = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`;
    exports2.CID = CID2;
  }
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/index.js
var require_src2 = __commonJS({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var cid = require_cid();
    var varint4 = require_varint3();
    var bytes = require_bytes();
    var hasher = require_hasher();
    var digest2 = require_digest();
    exports2.CID = cid.CID;
    exports2.varint = varint4;
    exports2.bytes = bytes;
    exports2.hasher = hasher;
    exports2.digest = digest2;
  }
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/basics.js
var require_basics = __commonJS({
  "../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/cjs/src/basics.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var identity3 = require_identity();
    var base22 = require_base2();
    var base82 = require_base8();
    var base102 = require_base10();
    var base162 = require_base16();
    var base322 = require_base32();
    var base362 = require_base36();
    var base58 = require_base58();
    var base642 = require_base642();
    var base256emoji2 = require_base256emoji();
    var sha2 = require_sha2();
    var identity$1 = require_identity2();
    var raw = require_raw();
    var json = require_json();
    require_src2();
    var cid = require_cid();
    var hasher = require_hasher();
    var digest2 = require_digest();
    var varint4 = require_varint3();
    var bytes = require_bytes();
    var bases2 = __spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({}, identity3), base22), base82), base102), base162), base322), base362), base58), base642), base256emoji2);
    var hashes2 = __spreadValues(__spreadValues({}, sha2), identity$1);
    var codecs = {
      raw,
      json
    };
    exports2.CID = cid.CID;
    exports2.hasher = hasher;
    exports2.digest = digest2;
    exports2.varint = varint4;
    exports2.bytes = bytes;
    exports2.bases = bases2;
    exports2.codecs = codecs;
    exports2.hashes = hashes2;
  }
});

// ../../node_modules/.pnpm/uint8arrays@3.1.1/node_modules/uint8arrays/cjs/src/util/as-uint8array.js
var require_as_uint8array = __commonJS({
  "../../node_modules/.pnpm/uint8arrays@3.1.1/node_modules/uint8arrays/cjs/src/util/as-uint8array.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function asUint8Array2(buf2) {
      if (globalThis.Buffer != null) {
        return new Uint8Array(buf2.buffer, buf2.byteOffset, buf2.byteLength);
      }
      return buf2;
    }
    exports2.asUint8Array = asUint8Array2;
  }
});

// ../../node_modules/.pnpm/uint8arrays@3.1.1/node_modules/uint8arrays/cjs/src/alloc.js
var require_alloc = __commonJS({
  "../../node_modules/.pnpm/uint8arrays@3.1.1/node_modules/uint8arrays/cjs/src/alloc.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var asUint8array = require_as_uint8array();
    function alloc2(size = 0) {
      if (globalThis.Buffer != null && globalThis.Buffer.alloc != null) {
        return asUint8array.asUint8Array(globalThis.Buffer.alloc(size));
      }
      return new Uint8Array(size);
    }
    function allocUnsafe2(size = 0) {
      if (globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null) {
        return asUint8array.asUint8Array(globalThis.Buffer.allocUnsafe(size));
      }
      return new Uint8Array(size);
    }
    exports2.alloc = alloc2;
    exports2.allocUnsafe = allocUnsafe2;
  }
});

// ../../node_modules/.pnpm/uint8arrays@3.1.1/node_modules/uint8arrays/cjs/src/util/bases.js
var require_bases = __commonJS({
  "../../node_modules/.pnpm/uint8arrays@3.1.1/node_modules/uint8arrays/cjs/src/util/bases.js"(exports2, module2) {
    "use strict";
    var basics = require_basics();
    var alloc2 = require_alloc();
    function createCodec2(name5, prefix, encode12, decode12) {
      return {
        name: name5,
        prefix,
        encoder: {
          name: name5,
          prefix,
          encode: encode12
        },
        decoder: { decode: decode12 }
      };
    }
    var string2 = createCodec2("utf8", "u", (buf2) => {
      const decoder2 = new TextDecoder("utf8");
      return "u" + decoder2.decode(buf2);
    }, (str) => {
      const encoder2 = new TextEncoder();
      return encoder2.encode(str.substring(1));
    });
    var ascii2 = createCodec2("ascii", "a", (buf2) => {
      let string3 = "a";
      for (let i = 0; i < buf2.length; i++) {
        string3 += String.fromCharCode(buf2[i]);
      }
      return string3;
    }, (str) => {
      str = str.substring(1);
      const buf2 = alloc2.allocUnsafe(str.length);
      for (let i = 0; i < str.length; i++) {
        buf2[i] = str.charCodeAt(i);
      }
      return buf2;
    });
    var BASES2 = __spreadValues({
      utf8: string2,
      "utf-8": string2,
      hex: basics.bases.base16,
      latin1: ascii2,
      ascii: ascii2,
      binary: ascii2
    }, basics.bases);
    module2.exports = BASES2;
  }
});

// ../../node_modules/.pnpm/uint8arrays@3.1.1/node_modules/uint8arrays/cjs/src/from-string.js
var require_from_string = __commonJS({
  "../../node_modules/.pnpm/uint8arrays@3.1.1/node_modules/uint8arrays/cjs/src/from-string.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var bases2 = require_bases();
    var asUint8array = require_as_uint8array();
    function fromString4(string2, encoding = "utf8") {
      const base3 = bases2[encoding];
      if (!base3) {
        throw new Error(`Unsupported encoding "${encoding}"`);
      }
      if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
        return asUint8array.asUint8Array(globalThis.Buffer.from(string2, "utf-8"));
      }
      return base3.decoder.decode(`${base3.prefix}${string2}`);
    }
    exports2.fromString = fromString4;
  }
});

// ../../node_modules/.pnpm/hamt-sharding@2.0.1/node_modules/hamt-sharding/src/bucket.js
var require_bucket = __commonJS({
  "../../node_modules/.pnpm/hamt-sharding@2.0.1/node_modules/hamt-sharding/src/bucket.js"(exports2, module2) {
    "use strict";
    var SparseArray = require_sparse_array();
    var { fromString: uint8ArrayFromString } = require_from_string();
    var Bucket2 = class _Bucket {
      /**
       * @param {BucketOptions} options
       * @param {Bucket<T>} [parent]
       * @param {number} [posAtParent=0]
       */
      constructor(options, parent, posAtParent = 0) {
        this._options = options;
        this._popCount = 0;
        this._parent = parent;
        this._posAtParent = posAtParent;
        this._children = new SparseArray();
        this.key = null;
      }
      /**
       * @param {string} key
       * @param {T} value
       */
      put(key, value) {
        return __async(this, null, function* () {
          const place = yield this._findNewBucketAndPos(key);
          yield place.bucket._putAt(place, key, value);
        });
      }
      /**
       * @param {string} key
       */
      get(key) {
        return __async(this, null, function* () {
          const child = yield this._findChild(key);
          if (child) {
            return child.value;
          }
        });
      }
      /**
       * @param {string} key
       */
      del(key) {
        return __async(this, null, function* () {
          const place = yield this._findPlace(key);
          const child = place.bucket._at(place.pos);
          if (child && child.key === key) {
            place.bucket._delAt(place.pos);
          }
        });
      }
      /**
       * @returns {number}
       */
      leafCount() {
        const children = this._children.compactArray();
        return children.reduce((acc, child) => {
          if (child instanceof _Bucket) {
            return acc + child.leafCount();
          }
          return acc + 1;
        }, 0);
      }
      childrenCount() {
        return this._children.length;
      }
      onlyChild() {
        return this._children.get(0);
      }
      /**
       * @returns {Iterable<BucketChild<T>>}
       */
      *eachLeafSeries() {
        const children = this._children.compactArray();
        for (const child of children) {
          if (child instanceof _Bucket) {
            yield* __yieldStar(child.eachLeafSeries());
          } else {
            yield child;
          }
        }
        return [];
      }
      /**
       * @param {(value: BucketChild<T>, index: number) => T} map
       * @param {(reduced: any) => any} reduce
       */
      serialize(map3, reduce2) {
        const acc = [];
        return reduce2(this._children.reduce((acc2, child, index) => {
          if (child) {
            if (child instanceof _Bucket) {
              acc2.push(child.serialize(map3, reduce2));
            } else {
              acc2.push(map3(child, index));
            }
          }
          return acc2;
        }, acc));
      }
      /**
       * @param {(value: BucketChild<T>) => Promise<T[]>} asyncMap
       * @param {(reduced: any) => Promise<any>} asyncReduce
       */
      asyncTransform(asyncMap, asyncReduce) {
        return asyncTransformBucket(this, asyncMap, asyncReduce);
      }
      toJSON() {
        return this.serialize(mapNode, reduceNodes);
      }
      prettyPrint() {
        return JSON.stringify(this.toJSON(), null, "  ");
      }
      tableSize() {
        return Math.pow(2, this._options.bits);
      }
      /**
       * @param {string} key
       * @returns {Promise<BucketChild<T> | undefined>}
       */
      _findChild(key) {
        return __async(this, null, function* () {
          const result = yield this._findPlace(key);
          const child = result.bucket._at(result.pos);
          if (child instanceof _Bucket) {
            return void 0;
          }
          if (child && child.key === key) {
            return child;
          }
        });
      }
      /**
       * @param {string | InfiniteHash} key
       * @returns {Promise<BucketPosition<T>>}
       */
      _findPlace(key) {
        return __async(this, null, function* () {
          const hashValue = this._options.hash(typeof key === "string" ? uint8ArrayFromString(key) : key);
          const index = yield hashValue.take(this._options.bits);
          const child = this._children.get(index);
          if (child instanceof _Bucket) {
            return child._findPlace(hashValue);
          }
          return {
            bucket: this,
            pos: index,
            hash: hashValue,
            existingChild: child
          };
        });
      }
      /**
       * @param {string | InfiniteHash} key
       * @returns {Promise<BucketPosition<T>>}
       */
      _findNewBucketAndPos(key) {
        return __async(this, null, function* () {
          const place = yield this._findPlace(key);
          if (place.existingChild && place.existingChild.key !== key) {
            const bucket = new _Bucket(this._options, place.bucket, place.pos);
            place.bucket._putObjectAt(place.pos, bucket);
            const newPlace = yield bucket._findPlace(place.existingChild.hash);
            newPlace.bucket._putAt(newPlace, place.existingChild.key, place.existingChild.value);
            return bucket._findNewBucketAndPos(place.hash);
          }
          return place;
        });
      }
      /**
       * @param {BucketPosition<T>} place
       * @param {string} key
       * @param {T} value
       */
      _putAt(place, key, value) {
        this._putObjectAt(place.pos, {
          key,
          value,
          hash: place.hash
        });
      }
      /**
       * @param {number} pos
       * @param {Bucket<T> | BucketChild<T>} object
       */
      _putObjectAt(pos, object) {
        if (!this._children.get(pos)) {
          this._popCount++;
        }
        this._children.set(pos, object);
      }
      /**
       * @param {number} pos
       */
      _delAt(pos) {
        if (pos === -1) {
          throw new Error("Invalid position");
        }
        if (this._children.get(pos)) {
          this._popCount--;
        }
        this._children.unset(pos);
        this._level();
      }
      _level() {
        if (this._parent && this._popCount <= 1) {
          if (this._popCount === 1) {
            const onlyChild = this._children.find(exists);
            if (onlyChild && !(onlyChild instanceof _Bucket)) {
              const hash = onlyChild.hash;
              hash.untake(this._options.bits);
              const place = {
                pos: this._posAtParent,
                hash,
                bucket: this._parent
              };
              this._parent._putAt(place, onlyChild.key, onlyChild.value);
            }
          } else {
            this._parent._delAt(this._posAtParent);
          }
        }
      }
      /**
       * @param {number} index
       * @returns {BucketChild<T> | Bucket<T> | undefined}
       */
      _at(index) {
        return this._children.get(index);
      }
    };
    function exists(o) {
      return Boolean(o);
    }
    function mapNode(node, index) {
      return node.key;
    }
    function reduceNodes(nodes) {
      return nodes;
    }
    function asyncTransformBucket(bucket, asyncMap, asyncReduce) {
      return __async(this, null, function* () {
        const output = [];
        for (const child of bucket._children.compactArray()) {
          if (child instanceof Bucket2) {
            yield asyncTransformBucket(child, asyncMap, asyncReduce);
          } else {
            const mappedChildren = yield asyncMap(child);
            output.push({
              bitField: bucket._children.bitField(),
              children: mappedChildren
            });
          }
        }
        return asyncReduce(output);
      });
    }
    module2.exports = Bucket2;
  }
});

// ../../node_modules/.pnpm/hamt-sharding@2.0.1/node_modules/hamt-sharding/src/consumable-buffer.js
var require_consumable_buffer = __commonJS({
  "../../node_modules/.pnpm/hamt-sharding@2.0.1/node_modules/hamt-sharding/src/consumable-buffer.js"(exports2, module2) {
    "use strict";
    var START_MASKS = [
      255,
      254,
      252,
      248,
      240,
      224,
      192,
      128
    ];
    var STOP_MASKS = [
      1,
      3,
      7,
      15,
      31,
      63,
      127,
      255
    ];
    module2.exports = class ConsumableBuffer {
      /**
       * @param {Uint8Array} value
       */
      constructor(value) {
        this._value = value;
        this._currentBytePos = value.length - 1;
        this._currentBitPos = 7;
      }
      availableBits() {
        return this._currentBitPos + 1 + this._currentBytePos * 8;
      }
      totalBits() {
        return this._value.length * 8;
      }
      /**
       * @param {number} bits
       */
      take(bits) {
        let pendingBits = bits;
        let result = 0;
        while (pendingBits && this._haveBits()) {
          const byte = this._value[this._currentBytePos];
          const availableBits = this._currentBitPos + 1;
          const taking = Math.min(availableBits, pendingBits);
          const value = byteBitsToInt(byte, availableBits - taking, taking);
          result = (result << taking) + value;
          pendingBits -= taking;
          this._currentBitPos -= taking;
          if (this._currentBitPos < 0) {
            this._currentBitPos = 7;
            this._currentBytePos--;
          }
        }
        return result;
      }
      /**
       * @param {number} bits
       */
      untake(bits) {
        this._currentBitPos += bits;
        while (this._currentBitPos > 7) {
          this._currentBitPos -= 8;
          this._currentBytePos += 1;
        }
      }
      _haveBits() {
        return this._currentBytePos >= 0;
      }
    };
    function byteBitsToInt(byte, start, length2) {
      const mask = maskFor(start, length2);
      return (byte & mask) >>> start;
    }
    function maskFor(start, length2) {
      return START_MASKS[start] & STOP_MASKS[Math.min(length2 + start - 1, 7)];
    }
  }
});

// ../../node_modules/.pnpm/uint8arrays@3.1.1/node_modules/uint8arrays/cjs/src/concat.js
var require_concat = __commonJS({
  "../../node_modules/.pnpm/uint8arrays@3.1.1/node_modules/uint8arrays/cjs/src/concat.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var alloc2 = require_alloc();
    var asUint8array = require_as_uint8array();
    function concat2(arrays, length2) {
      if (!length2) {
        length2 = arrays.reduce((acc, curr) => acc + curr.length, 0);
      }
      const output = alloc2.allocUnsafe(length2);
      let offset = 0;
      for (const arr of arrays) {
        output.set(arr, offset);
        offset += arr.length;
      }
      return asUint8array.asUint8Array(output);
    }
    exports2.concat = concat2;
  }
});

// ../../node_modules/.pnpm/hamt-sharding@2.0.1/node_modules/hamt-sharding/src/consumable-hash.js
var require_consumable_hash = __commonJS({
  "../../node_modules/.pnpm/hamt-sharding@2.0.1/node_modules/hamt-sharding/src/consumable-hash.js"(exports2, module2) {
    "use strict";
    var ConsumableBuffer = require_consumable_buffer();
    var { concat: uint8ArrayConcat } = require_concat();
    function wrapHash(hashFn) {
      function hashing(value) {
        if (value instanceof InfiniteHash) {
          return value;
        } else {
          return new InfiniteHash(value, hashFn);
        }
      }
      return hashing;
    }
    var InfiniteHash = class {
      /**
       *
       * @param {Uint8Array} value
       * @param {(value: Uint8Array) => Promise<Uint8Array>} hashFn
       */
      constructor(value, hashFn) {
        if (!(value instanceof Uint8Array)) {
          throw new Error("can only hash Uint8Arrays");
        }
        this._value = value;
        this._hashFn = hashFn;
        this._depth = -1;
        this._availableBits = 0;
        this._currentBufferIndex = 0;
        this._buffers = [];
      }
      /**
       * @param {number} bits
       */
      take(bits) {
        return __async(this, null, function* () {
          let pendingBits = bits;
          while (this._availableBits < pendingBits) {
            yield this._produceMoreBits();
          }
          let result = 0;
          while (pendingBits > 0) {
            const hash = this._buffers[this._currentBufferIndex];
            const available = Math.min(hash.availableBits(), pendingBits);
            const took = hash.take(available);
            result = (result << available) + took;
            pendingBits -= available;
            this._availableBits -= available;
            if (hash.availableBits() === 0) {
              this._currentBufferIndex++;
            }
          }
          return result;
        });
      }
      /**
       * @param {number} bits
       */
      untake(bits) {
        let pendingBits = bits;
        while (pendingBits > 0) {
          const hash = this._buffers[this._currentBufferIndex];
          const availableForUntake = Math.min(hash.totalBits() - hash.availableBits(), pendingBits);
          hash.untake(availableForUntake);
          pendingBits -= availableForUntake;
          this._availableBits += availableForUntake;
          if (this._currentBufferIndex > 0 && hash.totalBits() === hash.availableBits()) {
            this._depth--;
            this._currentBufferIndex--;
          }
        }
      }
      _produceMoreBits() {
        return __async(this, null, function* () {
          this._depth++;
          const value = this._depth ? uint8ArrayConcat([this._value, Uint8Array.from([this._depth])]) : this._value;
          const hashValue = yield this._hashFn(value);
          const buffer2 = new ConsumableBuffer(hashValue);
          this._buffers.push(buffer2);
          this._availableBits += buffer2.availableBits();
        });
      }
    };
    module2.exports = wrapHash;
    module2.exports.InfiniteHash = InfiniteHash;
  }
});

// ../../node_modules/.pnpm/hamt-sharding@2.0.1/node_modules/hamt-sharding/src/index.js
var require_src3 = __commonJS({
  "../../node_modules/.pnpm/hamt-sharding@2.0.1/node_modules/hamt-sharding/src/index.js"(exports2, module2) {
    "use strict";
    var Bucket2 = require_bucket();
    var wrapHash = require_consumable_hash();
    function createHAMT2(options) {
      if (!options || !options.hashFn) {
        throw new Error("please define an options.hashFn");
      }
      const bucketOptions = {
        bits: options.bits || 8,
        hash: wrapHash(options.hashFn)
      };
      return new Bucket2(bucketOptions);
    }
    module2.exports = {
      createHAMT: createHAMT2,
      Bucket: Bucket2
    };
  }
});

// ../../node_modules/.pnpm/browser-readablestream-to-it@1.0.3/node_modules/browser-readablestream-to-it/index.js
var require_browser_readablestream_to_it = __commonJS({
  "../../node_modules/.pnpm/browser-readablestream-to-it@1.0.3/node_modules/browser-readablestream-to-it/index.js"(exports2, module2) {
    "use strict";
    function browserReadableStreamToIt(_0) {
      return __asyncGenerator(this, arguments, function* (stream, options = {}) {
        const reader = stream.getReader();
        try {
          while (true) {
            const result = yield new __await(reader.read());
            if (result.done) {
              return;
            }
            yield result.value;
          }
        } finally {
          if (options.preventCancel !== true) {
            reader.cancel();
          }
          reader.releaseLock();
        }
      });
    }
    module2.exports = browserReadableStreamToIt;
  }
});

// ../../node_modules/.pnpm/blob-to-it@1.0.4/node_modules/blob-to-it/index.js
var require_blob_to_it = __commonJS({
  "../../node_modules/.pnpm/blob-to-it@1.0.4/node_modules/blob-to-it/index.js"(exports2, module2) {
    "use strict";
    var browserReadableStreamToIt = require_browser_readablestream_to_it();
    function blobToIt2(blob) {
      if (typeof blob.stream === "function") {
        return browserReadableStreamToIt(blob.stream());
      }
      return browserReadableStreamToIt(new Response(blob).body);
    }
    module2.exports = blobToIt2;
  }
});

// ../../node_modules/.pnpm/it-peekable@1.0.3/node_modules/it-peekable/index.js
var require_it_peekable = __commonJS({
  "../../node_modules/.pnpm/it-peekable@1.0.3/node_modules/it-peekable/index.js"(exports2, module2) {
    "use strict";
    function peekableIterator(iterable) {
      const [iterator, symbol] = iterable[Symbol.asyncIterator] ? [iterable[Symbol.asyncIterator](), Symbol.asyncIterator] : [iterable[Symbol.iterator](), Symbol.iterator];
      const queue = [];
      return {
        peek: () => {
          return iterator.next();
        },
        push: (value) => {
          queue.push(value);
        },
        next: () => {
          if (queue.length) {
            return {
              done: false,
              value: queue.shift()
            };
          }
          return iterator.next();
        },
        [symbol]() {
          return this;
        }
      };
    }
    module2.exports = peekableIterator;
  }
});

// ../../node_modules/.pnpm/it-map@1.0.6/node_modules/it-map/index.js
var require_it_map = __commonJS({
  "../../node_modules/.pnpm/it-map@1.0.6/node_modules/it-map/index.js"(exports2, module2) {
    "use strict";
    var map3 = function(source, func) {
      return __asyncGenerator(this, null, function* () {
        try {
          for (var iter = __forAwait(source), more, temp, error; more = !(temp = yield new __await(iter.next())).done; more = false) {
            const val = temp.value;
            yield func(val);
          }
        } catch (temp) {
          error = [temp];
        } finally {
          try {
            more && (temp = iter.return) && (yield new __await(temp.call(iter)));
          } finally {
            if (error)
              throw error[0];
          }
        }
      });
    };
    module2.exports = map3;
  }
});

// ../../node_modules/.pnpm/it-drain@1.0.5/node_modules/it-drain/index.js
var require_it_drain = __commonJS({
  "../../node_modules/.pnpm/it-drain@1.0.5/node_modules/it-drain/index.js"(exports2, module2) {
    "use strict";
    var drain2 = (source) => __async(exports2, null, function* () {
      try {
        for (var iter = __forAwait(source), more, temp, error; more = !(temp = yield iter.next()).done; more = false) {
          const _ = temp.value;
        }
      } catch (temp) {
        error = [temp];
      } finally {
        try {
          more && (temp = iter.return) && (yield temp.call(iter));
        } finally {
          if (error)
            throw error[0];
        }
      }
    });
    module2.exports = drain2;
  }
});

// ../../node_modules/.pnpm/it-filter@1.0.3/node_modules/it-filter/index.js
var require_it_filter = __commonJS({
  "../../node_modules/.pnpm/it-filter@1.0.3/node_modules/it-filter/index.js"(exports2, module2) {
    "use strict";
    var filter2 = function(source, fn) {
      return __asyncGenerator(this, null, function* () {
        try {
          for (var iter = __forAwait(source), more, temp, error; more = !(temp = yield new __await(iter.next())).done; more = false) {
            const entry = temp.value;
            if (yield new __await(fn(entry))) {
              yield entry;
            }
          }
        } catch (temp) {
          error = [temp];
        } finally {
          try {
            more && (temp = iter.return) && (yield new __await(temp.call(iter)));
          } finally {
            if (error)
              throw error[0];
          }
        }
      });
    };
    module2.exports = filter2;
  }
});

// ../../node_modules/.pnpm/it-take@1.0.2/node_modules/it-take/index.js
var require_it_take = __commonJS({
  "../../node_modules/.pnpm/it-take@1.0.2/node_modules/it-take/index.js"(exports2, module2) {
    "use strict";
    var take2 = function(source, limit) {
      return __asyncGenerator(this, null, function* () {
        let items = 0;
        if (limit < 1) {
          return;
        }
        try {
          for (var iter = __forAwait(source), more, temp, error; more = !(temp = yield new __await(iter.next())).done; more = false) {
            const entry = temp.value;
            yield entry;
            items++;
            if (items === limit) {
              return;
            }
          }
        } catch (temp) {
          error = [temp];
        } finally {
          try {
            more && (temp = iter.return) && (yield new __await(temp.call(iter)));
          } finally {
            if (error)
              throw error[0];
          }
        }
      });
    };
    module2.exports = take2;
  }
});

// ../../node_modules/.pnpm/throttled-queue@2.1.4/node_modules/throttled-queue/dist/throttledQueue.js
var require_throttledQueue = __commonJS({
  "../../node_modules/.pnpm/throttled-queue@2.1.4/node_modules/throttled-queue/dist/throttledQueue.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function throttledQueue2(maxRequestsPerInterval, interval, evenlySpaced) {
      if (evenlySpaced === void 0) {
        evenlySpaced = false;
      }
      if (evenlySpaced) {
        interval = interval / maxRequestsPerInterval;
        maxRequestsPerInterval = 1;
      }
      var queue = [];
      var lastIntervalStart = 0;
      var numRequestsPerInterval = 0;
      var timeout;
      var dequeue = function() {
        var intervalEnd = lastIntervalStart + interval;
        var now = Date.now();
        if (now < intervalEnd) {
          timeout !== void 0 && clearTimeout(timeout);
          timeout = setTimeout(dequeue, intervalEnd - now);
          return;
        }
        lastIntervalStart = now;
        numRequestsPerInterval = 0;
        for (var _i = 0, _a2 = queue.splice(0, maxRequestsPerInterval); _i < _a2.length; _i++) {
          var callback = _a2[_i];
          numRequestsPerInterval++;
          void callback();
        }
        if (queue.length) {
          timeout = setTimeout(dequeue, interval);
        } else {
          timeout = void 0;
        }
      };
      return function(fn) {
        return new Promise(function(resolve, reject) {
          var callback = function() {
            return Promise.resolve().then(fn).then(resolve).catch(reject);
          };
          var now = Date.now();
          if (timeout === void 0 && now - lastIntervalStart > interval) {
            lastIntervalStart = now;
            numRequestsPerInterval = 0;
          }
          if (numRequestsPerInterval++ < maxRequestsPerInterval) {
            void callback();
          } else {
            queue.push(callback);
            if (timeout === void 0) {
              timeout = setTimeout(dequeue, lastIntervalStart + interval - now);
            }
          }
        });
      };
    }
    module2.exports = throttledQueue2;
    exports2.default = throttledQueue2;
  }
});

// ../../node_modules/.pnpm/data-uri-to-buffer@3.0.1/node_modules/data-uri-to-buffer/dist/src/index.js
var require_src4 = __commonJS({
  "../../node_modules/.pnpm/data-uri-to-buffer@3.0.1/node_modules/data-uri-to-buffer/dist/src/index.js"(exports2, module2) {
    "use strict";
    function dataUriToBuffer2(uri) {
      if (!/^data:/i.test(uri)) {
        throw new TypeError('`uri` does not appear to be a Data URI (must begin with "data:")');
      }
      uri = uri.replace(/\r?\n/g, "");
      const firstComma = uri.indexOf(",");
      if (firstComma === -1 || firstComma <= 4) {
        throw new TypeError("malformed data: URI");
      }
      const meta = uri.substring(5, firstComma).split(";");
      let charset = "";
      let base642 = false;
      const type = meta[0] || "text/plain";
      let typeFull = type;
      for (let i = 1; i < meta.length; i++) {
        if (meta[i] === "base64") {
          base642 = true;
        } else {
          typeFull += `;${meta[i]}`;
          if (meta[i].indexOf("charset=") === 0) {
            charset = meta[i].substring(8);
          }
        }
      }
      if (!meta[0] && !charset.length) {
        typeFull += ";charset=US-ASCII";
        charset = "US-ASCII";
      }
      const encoding = base642 ? "base64" : "ascii";
      const data = unescape(uri.substring(firstComma + 1));
      const buffer2 = Buffer.from(data, encoding);
      buffer2.type = type;
      buffer2.typeFull = typeFull;
      buffer2.charset = charset;
      return buffer2;
    }
    module2.exports = dataUriToBuffer2;
  }
});

// ../../node_modules/.pnpm/web-streams-polyfill@3.2.1/node_modules/web-streams-polyfill/dist/ponyfill.mjs
var ponyfill_exports = {};
__export(ponyfill_exports, {
  ByteLengthQueuingStrategy: () => ByteLengthQueuingStrategy,
  CountQueuingStrategy: () => CountQueuingStrategy,
  ReadableByteStreamController: () => ReadableByteStreamController,
  ReadableStream: () => ReadableStream,
  ReadableStreamBYOBReader: () => ReadableStreamBYOBReader,
  ReadableStreamBYOBRequest: () => ReadableStreamBYOBRequest,
  ReadableStreamDefaultController: () => ReadableStreamDefaultController,
  ReadableStreamDefaultReader: () => ReadableStreamDefaultReader,
  TransformStream: () => TransformStream,
  TransformStreamDefaultController: () => TransformStreamDefaultController,
  WritableStream: () => WritableStream,
  WritableStreamDefaultController: () => WritableStreamDefaultController,
  WritableStreamDefaultWriter: () => WritableStreamDefaultWriter
});
function noop2() {
  return void 0;
}
function getGlobals() {
  if (typeof self !== "undefined") {
    return self;
  } else if (typeof window !== "undefined") {
    return window;
  } else if (typeof global !== "undefined") {
    return global;
  }
  return void 0;
}
function typeIsObject(x) {
  return typeof x === "object" && x !== null || typeof x === "function";
}
function newPromise(executor) {
  return new originalPromise(executor);
}
function promiseResolvedWith(value) {
  return originalPromiseResolve(value);
}
function promiseRejectedWith(reason) {
  return originalPromiseReject(reason);
}
function PerformPromiseThen(promise, onFulfilled, onRejected) {
  return originalPromiseThen.call(promise, onFulfilled, onRejected);
}
function uponPromise(promise, onFulfilled, onRejected) {
  PerformPromiseThen(PerformPromiseThen(promise, onFulfilled, onRejected), void 0, rethrowAssertionErrorRejection);
}
function uponFulfillment(promise, onFulfilled) {
  uponPromise(promise, onFulfilled);
}
function uponRejection(promise, onRejected) {
  uponPromise(promise, void 0, onRejected);
}
function transformPromiseWith(promise, fulfillmentHandler, rejectionHandler) {
  return PerformPromiseThen(promise, fulfillmentHandler, rejectionHandler);
}
function setPromiseIsHandledToTrue(promise) {
  PerformPromiseThen(promise, void 0, rethrowAssertionErrorRejection);
}
function reflectCall(F, V, args) {
  if (typeof F !== "function") {
    throw new TypeError("Argument is not a function");
  }
  return Function.prototype.apply.call(F, V, args);
}
function promiseCall(F, V, args) {
  try {
    return promiseResolvedWith(reflectCall(F, V, args));
  } catch (value) {
    return promiseRejectedWith(value);
  }
}
function ReadableStreamReaderGenericInitialize(reader, stream) {
  reader._ownerReadableStream = stream;
  stream._reader = reader;
  if (stream._state === "readable") {
    defaultReaderClosedPromiseInitialize(reader);
  } else if (stream._state === "closed") {
    defaultReaderClosedPromiseInitializeAsResolved(reader);
  } else {
    defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);
  }
}
function ReadableStreamReaderGenericCancel(reader, reason) {
  var stream = reader._ownerReadableStream;
  return ReadableStreamCancel(stream, reason);
}
function ReadableStreamReaderGenericRelease(reader) {
  if (reader._ownerReadableStream._state === "readable") {
    defaultReaderClosedPromiseReject(reader, new TypeError("Reader was released and can no longer be used to monitor the stream's closedness"));
  } else {
    defaultReaderClosedPromiseResetToRejected(reader, new TypeError("Reader was released and can no longer be used to monitor the stream's closedness"));
  }
  reader._ownerReadableStream._reader = void 0;
  reader._ownerReadableStream = void 0;
}
function readerLockException(name5) {
  return new TypeError("Cannot " + name5 + " a stream using a released reader");
}
function defaultReaderClosedPromiseInitialize(reader) {
  reader._closedPromise = newPromise(function(resolve, reject) {
    reader._closedPromise_resolve = resolve;
    reader._closedPromise_reject = reject;
  });
}
function defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {
  defaultReaderClosedPromiseInitialize(reader);
  defaultReaderClosedPromiseReject(reader, reason);
}
function defaultReaderClosedPromiseInitializeAsResolved(reader) {
  defaultReaderClosedPromiseInitialize(reader);
  defaultReaderClosedPromiseResolve(reader);
}
function defaultReaderClosedPromiseReject(reader, reason) {
  if (reader._closedPromise_reject === void 0) {
    return;
  }
  setPromiseIsHandledToTrue(reader._closedPromise);
  reader._closedPromise_reject(reason);
  reader._closedPromise_resolve = void 0;
  reader._closedPromise_reject = void 0;
}
function defaultReaderClosedPromiseResetToRejected(reader, reason) {
  defaultReaderClosedPromiseInitializeAsRejected(reader, reason);
}
function defaultReaderClosedPromiseResolve(reader) {
  if (reader._closedPromise_resolve === void 0) {
    return;
  }
  reader._closedPromise_resolve(void 0);
  reader._closedPromise_resolve = void 0;
  reader._closedPromise_reject = void 0;
}
function isDictionary(x) {
  return typeof x === "object" || typeof x === "function";
}
function assertDictionary(obj, context) {
  if (obj !== void 0 && !isDictionary(obj)) {
    throw new TypeError(context + " is not an object.");
  }
}
function assertFunction(x, context) {
  if (typeof x !== "function") {
    throw new TypeError(context + " is not a function.");
  }
}
function isObject(x) {
  return typeof x === "object" && x !== null || typeof x === "function";
}
function assertObject(x, context) {
  if (!isObject(x)) {
    throw new TypeError(context + " is not an object.");
  }
}
function assertRequiredArgument(x, position, context) {
  if (x === void 0) {
    throw new TypeError("Parameter " + position + " is required in '" + context + "'.");
  }
}
function assertRequiredField(x, field, context) {
  if (x === void 0) {
    throw new TypeError(field + " is required in '" + context + "'.");
  }
}
function convertUnrestrictedDouble(value) {
  return Number(value);
}
function censorNegativeZero(x) {
  return x === 0 ? 0 : x;
}
function integerPart(x) {
  return censorNegativeZero(MathTrunc(x));
}
function convertUnsignedLongLongWithEnforceRange(value, context) {
  var lowerBound = 0;
  var upperBound = Number.MAX_SAFE_INTEGER;
  var x = Number(value);
  x = censorNegativeZero(x);
  if (!NumberIsFinite(x)) {
    throw new TypeError(context + " is not a finite number");
  }
  x = integerPart(x);
  if (x < lowerBound || x > upperBound) {
    throw new TypeError(context + " is outside the accepted range of " + lowerBound + " to " + upperBound + ", inclusive");
  }
  if (!NumberIsFinite(x) || x === 0) {
    return 0;
  }
  return x;
}
function assertReadableStream(x, context) {
  if (!IsReadableStream(x)) {
    throw new TypeError(context + " is not a ReadableStream.");
  }
}
function AcquireReadableStreamDefaultReader(stream) {
  return new ReadableStreamDefaultReader(stream);
}
function ReadableStreamAddReadRequest(stream, readRequest) {
  stream._reader._readRequests.push(readRequest);
}
function ReadableStreamFulfillReadRequest(stream, chunk, done) {
  var reader = stream._reader;
  var readRequest = reader._readRequests.shift();
  if (done) {
    readRequest._closeSteps();
  } else {
    readRequest._chunkSteps(chunk);
  }
}
function ReadableStreamGetNumReadRequests(stream) {
  return stream._reader._readRequests.length;
}
function ReadableStreamHasDefaultReader(stream) {
  var reader = stream._reader;
  if (reader === void 0) {
    return false;
  }
  if (!IsReadableStreamDefaultReader(reader)) {
    return false;
  }
  return true;
}
function IsReadableStreamDefaultReader(x) {
  if (!typeIsObject(x)) {
    return false;
  }
  if (!Object.prototype.hasOwnProperty.call(x, "_readRequests")) {
    return false;
  }
  return x instanceof ReadableStreamDefaultReader;
}
function ReadableStreamDefaultReaderRead(reader, readRequest) {
  var stream = reader._ownerReadableStream;
  stream._disturbed = true;
  if (stream._state === "closed") {
    readRequest._closeSteps();
  } else if (stream._state === "errored") {
    readRequest._errorSteps(stream._storedError);
  } else {
    stream._readableStreamController[PullSteps](readRequest);
  }
}
function defaultReaderBrandCheckException(name5) {
  return new TypeError("ReadableStreamDefaultReader.prototype." + name5 + " can only be used on a ReadableStreamDefaultReader");
}
function AcquireReadableStreamAsyncIterator(stream, preventCancel) {
  var reader = AcquireReadableStreamDefaultReader(stream);
  var impl = new ReadableStreamAsyncIteratorImpl(reader, preventCancel);
  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype);
  iterator._asyncIteratorImpl = impl;
  return iterator;
}
function IsReadableStreamAsyncIterator(x) {
  if (!typeIsObject(x)) {
    return false;
  }
  if (!Object.prototype.hasOwnProperty.call(x, "_asyncIteratorImpl")) {
    return false;
  }
  try {
    return x._asyncIteratorImpl instanceof ReadableStreamAsyncIteratorImpl;
  } catch (_a2) {
    return false;
  }
}
function streamAsyncIteratorBrandCheckException(name5) {
  return new TypeError("ReadableStreamAsyncIterator." + name5 + " can only be used on a ReadableSteamAsyncIterator");
}
function CreateArrayFromList(elements) {
  return elements.slice();
}
function CopyDataBlockBytes(dest, destOffset, src2, srcOffset, n) {
  new Uint8Array(dest).set(new Uint8Array(src2, srcOffset, n), destOffset);
}
function TransferArrayBuffer(O) {
  return O;
}
function IsDetachedBuffer(O) {
  return false;
}
function ArrayBufferSlice(buffer2, begin, end) {
  if (buffer2.slice) {
    return buffer2.slice(begin, end);
  }
  var length2 = end - begin;
  var slice2 = new ArrayBuffer(length2);
  CopyDataBlockBytes(slice2, 0, buffer2, begin, length2);
  return slice2;
}
function IsNonNegativeNumber(v) {
  if (typeof v !== "number") {
    return false;
  }
  if (NumberIsNaN(v)) {
    return false;
  }
  if (v < 0) {
    return false;
  }
  return true;
}
function CloneAsUint8Array(O) {
  var buffer2 = ArrayBufferSlice(O.buffer, O.byteOffset, O.byteOffset + O.byteLength);
  return new Uint8Array(buffer2);
}
function DequeueValue(container) {
  var pair = container._queue.shift();
  container._queueTotalSize -= pair.size;
  if (container._queueTotalSize < 0) {
    container._queueTotalSize = 0;
  }
  return pair.value;
}
function EnqueueValueWithSize(container, value, size) {
  if (!IsNonNegativeNumber(size) || size === Infinity) {
    throw new RangeError("Size must be a finite, non-NaN, non-negative number.");
  }
  container._queue.push({ value, size });
  container._queueTotalSize += size;
}
function PeekQueueValue(container) {
  var pair = container._queue.peek();
  return pair.value;
}
function ResetQueue(container) {
  container._queue = new SimpleQueue();
  container._queueTotalSize = 0;
}
function IsReadableByteStreamController(x) {
  if (!typeIsObject(x)) {
    return false;
  }
  if (!Object.prototype.hasOwnProperty.call(x, "_controlledReadableByteStream")) {
    return false;
  }
  return x instanceof ReadableByteStreamController;
}
function IsReadableStreamBYOBRequest(x) {
  if (!typeIsObject(x)) {
    return false;
  }
  if (!Object.prototype.hasOwnProperty.call(x, "_associatedReadableByteStreamController")) {
    return false;
  }
  return x instanceof ReadableStreamBYOBRequest;
}
function ReadableByteStreamControllerCallPullIfNeeded(controller) {
  var shouldPull = ReadableByteStreamControllerShouldCallPull(controller);
  if (!shouldPull) {
    return;
  }
  if (controller._pulling) {
    controller._pullAgain = true;
    return;
  }
  controller._pulling = true;
  var pullPromise = controller._pullAlgorithm();
  uponPromise(pullPromise, function() {
    controller._pulling = false;
    if (controller._pullAgain) {
      controller._pullAgain = false;
      ReadableByteStreamControllerCallPullIfNeeded(controller);
    }
  }, function(e) {
    ReadableByteStreamControllerError(controller, e);
  });
}
function ReadableByteStreamControllerClearPendingPullIntos(controller) {
  ReadableByteStreamControllerInvalidateBYOBRequest(controller);
  controller._pendingPullIntos = new SimpleQueue();
}
function ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {
  var done = false;
  if (stream._state === "closed") {
    done = true;
  }
  var filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
  if (pullIntoDescriptor.readerType === "default") {
    ReadableStreamFulfillReadRequest(stream, filledView, done);
  } else {
    ReadableStreamFulfillReadIntoRequest(stream, filledView, done);
  }
}
function ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {
  var bytesFilled = pullIntoDescriptor.bytesFilled;
  var elementSize = pullIntoDescriptor.elementSize;
  return new pullIntoDescriptor.viewConstructor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);
}
function ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer2, byteOffset, byteLength) {
  controller._queue.push({ buffer: buffer2, byteOffset, byteLength });
  controller._queueTotalSize += byteLength;
}
function ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {
  var elementSize = pullIntoDescriptor.elementSize;
  var currentAlignedBytes = pullIntoDescriptor.bytesFilled - pullIntoDescriptor.bytesFilled % elementSize;
  var maxBytesToCopy = Math.min(controller._queueTotalSize, pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);
  var maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;
  var maxAlignedBytes = maxBytesFilled - maxBytesFilled % elementSize;
  var totalBytesToCopyRemaining = maxBytesToCopy;
  var ready = false;
  if (maxAlignedBytes > currentAlignedBytes) {
    totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;
    ready = true;
  }
  var queue = controller._queue;
  while (totalBytesToCopyRemaining > 0) {
    var headOfQueue = queue.peek();
    var bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);
    var destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
    CopyDataBlockBytes(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);
    if (headOfQueue.byteLength === bytesToCopy) {
      queue.shift();
    } else {
      headOfQueue.byteOffset += bytesToCopy;
      headOfQueue.byteLength -= bytesToCopy;
    }
    controller._queueTotalSize -= bytesToCopy;
    ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);
    totalBytesToCopyRemaining -= bytesToCopy;
  }
  return ready;
}
function ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {
  pullIntoDescriptor.bytesFilled += size;
}
function ReadableByteStreamControllerHandleQueueDrain(controller) {
  if (controller._queueTotalSize === 0 && controller._closeRequested) {
    ReadableByteStreamControllerClearAlgorithms(controller);
    ReadableStreamClose(controller._controlledReadableByteStream);
  } else {
    ReadableByteStreamControllerCallPullIfNeeded(controller);
  }
}
function ReadableByteStreamControllerInvalidateBYOBRequest(controller) {
  if (controller._byobRequest === null) {
    return;
  }
  controller._byobRequest._associatedReadableByteStreamController = void 0;
  controller._byobRequest._view = null;
  controller._byobRequest = null;
}
function ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {
  while (controller._pendingPullIntos.length > 0) {
    if (controller._queueTotalSize === 0) {
      return;
    }
    var pullIntoDescriptor = controller._pendingPullIntos.peek();
    if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
      ReadableByteStreamControllerShiftPendingPullInto(controller);
      ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
    }
  }
}
function ReadableByteStreamControllerPullInto(controller, view, readIntoRequest) {
  var stream = controller._controlledReadableByteStream;
  var elementSize = 1;
  if (view.constructor !== DataView) {
    elementSize = view.constructor.BYTES_PER_ELEMENT;
  }
  var ctor = view.constructor;
  var buffer2 = TransferArrayBuffer(view.buffer);
  var pullIntoDescriptor = {
    buffer: buffer2,
    bufferByteLength: buffer2.byteLength,
    byteOffset: view.byteOffset,
    byteLength: view.byteLength,
    bytesFilled: 0,
    elementSize,
    viewConstructor: ctor,
    readerType: "byob"
  };
  if (controller._pendingPullIntos.length > 0) {
    controller._pendingPullIntos.push(pullIntoDescriptor);
    ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
    return;
  }
  if (stream._state === "closed") {
    var emptyView = new ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);
    readIntoRequest._closeSteps(emptyView);
    return;
  }
  if (controller._queueTotalSize > 0) {
    if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
      var filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
      ReadableByteStreamControllerHandleQueueDrain(controller);
      readIntoRequest._chunkSteps(filledView);
      return;
    }
    if (controller._closeRequested) {
      var e = new TypeError("Insufficient bytes to fill elements in the given buffer");
      ReadableByteStreamControllerError(controller, e);
      readIntoRequest._errorSteps(e);
      return;
    }
  }
  controller._pendingPullIntos.push(pullIntoDescriptor);
  ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
  ReadableByteStreamControllerCallPullIfNeeded(controller);
}
function ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {
  var stream = controller._controlledReadableByteStream;
  if (ReadableStreamHasBYOBReader(stream)) {
    while (ReadableStreamGetNumReadIntoRequests(stream) > 0) {
      var pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);
      ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);
    }
  }
}
function ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {
  ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);
  if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize) {
    return;
  }
  ReadableByteStreamControllerShiftPendingPullInto(controller);
  var remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;
  if (remainderSize > 0) {
    var end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
    var remainder = ArrayBufferSlice(pullIntoDescriptor.buffer, end - remainderSize, end);
    ReadableByteStreamControllerEnqueueChunkToQueue(controller, remainder, 0, remainder.byteLength);
  }
  pullIntoDescriptor.bytesFilled -= remainderSize;
  ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
  ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
}
function ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {
  var firstDescriptor = controller._pendingPullIntos.peek();
  ReadableByteStreamControllerInvalidateBYOBRequest(controller);
  var state = controller._controlledReadableByteStream._state;
  if (state === "closed") {
    ReadableByteStreamControllerRespondInClosedState(controller);
  } else {
    ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);
  }
  ReadableByteStreamControllerCallPullIfNeeded(controller);
}
function ReadableByteStreamControllerShiftPendingPullInto(controller) {
  var descriptor = controller._pendingPullIntos.shift();
  return descriptor;
}
function ReadableByteStreamControllerShouldCallPull(controller) {
  var stream = controller._controlledReadableByteStream;
  if (stream._state !== "readable") {
    return false;
  }
  if (controller._closeRequested) {
    return false;
  }
  if (!controller._started) {
    return false;
  }
  if (ReadableStreamHasDefaultReader(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
    return true;
  }
  if (ReadableStreamHasBYOBReader(stream) && ReadableStreamGetNumReadIntoRequests(stream) > 0) {
    return true;
  }
  var desiredSize = ReadableByteStreamControllerGetDesiredSize(controller);
  if (desiredSize > 0) {
    return true;
  }
  return false;
}
function ReadableByteStreamControllerClearAlgorithms(controller) {
  controller._pullAlgorithm = void 0;
  controller._cancelAlgorithm = void 0;
}
function ReadableByteStreamControllerClose(controller) {
  var stream = controller._controlledReadableByteStream;
  if (controller._closeRequested || stream._state !== "readable") {
    return;
  }
  if (controller._queueTotalSize > 0) {
    controller._closeRequested = true;
    return;
  }
  if (controller._pendingPullIntos.length > 0) {
    var firstPendingPullInto = controller._pendingPullIntos.peek();
    if (firstPendingPullInto.bytesFilled > 0) {
      var e = new TypeError("Insufficient bytes to fill elements in the given buffer");
      ReadableByteStreamControllerError(controller, e);
      throw e;
    }
  }
  ReadableByteStreamControllerClearAlgorithms(controller);
  ReadableStreamClose(stream);
}
function ReadableByteStreamControllerEnqueue(controller, chunk) {
  var stream = controller._controlledReadableByteStream;
  if (controller._closeRequested || stream._state !== "readable") {
    return;
  }
  var buffer2 = chunk.buffer;
  var byteOffset = chunk.byteOffset;
  var byteLength = chunk.byteLength;
  var transferredBuffer = TransferArrayBuffer(buffer2);
  if (controller._pendingPullIntos.length > 0) {
    var firstPendingPullInto = controller._pendingPullIntos.peek();
    if (IsDetachedBuffer(firstPendingPullInto.buffer))
      ;
    firstPendingPullInto.buffer = TransferArrayBuffer(firstPendingPullInto.buffer);
  }
  ReadableByteStreamControllerInvalidateBYOBRequest(controller);
  if (ReadableStreamHasDefaultReader(stream)) {
    if (ReadableStreamGetNumReadRequests(stream) === 0) {
      ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
    } else {
      if (controller._pendingPullIntos.length > 0) {
        ReadableByteStreamControllerShiftPendingPullInto(controller);
      }
      var transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);
      ReadableStreamFulfillReadRequest(stream, transferredView, false);
    }
  } else if (ReadableStreamHasBYOBReader(stream)) {
    ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
    ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
  } else {
    ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
  }
  ReadableByteStreamControllerCallPullIfNeeded(controller);
}
function ReadableByteStreamControllerError(controller, e) {
  var stream = controller._controlledReadableByteStream;
  if (stream._state !== "readable") {
    return;
  }
  ReadableByteStreamControllerClearPendingPullIntos(controller);
  ResetQueue(controller);
  ReadableByteStreamControllerClearAlgorithms(controller);
  ReadableStreamError(stream, e);
}
function ReadableByteStreamControllerGetBYOBRequest(controller) {
  if (controller._byobRequest === null && controller._pendingPullIntos.length > 0) {
    var firstDescriptor = controller._pendingPullIntos.peek();
    var view = new Uint8Array(firstDescriptor.buffer, firstDescriptor.byteOffset + firstDescriptor.bytesFilled, firstDescriptor.byteLength - firstDescriptor.bytesFilled);
    var byobRequest = Object.create(ReadableStreamBYOBRequest.prototype);
    SetUpReadableStreamBYOBRequest(byobRequest, controller, view);
    controller._byobRequest = byobRequest;
  }
  return controller._byobRequest;
}
function ReadableByteStreamControllerGetDesiredSize(controller) {
  var state = controller._controlledReadableByteStream._state;
  if (state === "errored") {
    return null;
  }
  if (state === "closed") {
    return 0;
  }
  return controller._strategyHWM - controller._queueTotalSize;
}
function ReadableByteStreamControllerRespond(controller, bytesWritten) {
  var firstDescriptor = controller._pendingPullIntos.peek();
  var state = controller._controlledReadableByteStream._state;
  if (state === "closed") {
    if (bytesWritten !== 0) {
      throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream");
    }
  } else {
    if (bytesWritten === 0) {
      throw new TypeError("bytesWritten must be greater than 0 when calling respond() on a readable stream");
    }
    if (firstDescriptor.bytesFilled + bytesWritten > firstDescriptor.byteLength) {
      throw new RangeError("bytesWritten out of range");
    }
  }
  firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);
  ReadableByteStreamControllerRespondInternal(controller, bytesWritten);
}
function ReadableByteStreamControllerRespondWithNewView(controller, view) {
  var firstDescriptor = controller._pendingPullIntos.peek();
  var state = controller._controlledReadableByteStream._state;
  if (state === "closed") {
    if (view.byteLength !== 0) {
      throw new TypeError("The view's length must be 0 when calling respondWithNewView() on a closed stream");
    }
  } else {
    if (view.byteLength === 0) {
      throw new TypeError("The view's length must be greater than 0 when calling respondWithNewView() on a readable stream");
    }
  }
  if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {
    throw new RangeError("The region specified by view does not match byobRequest");
  }
  if (firstDescriptor.bufferByteLength !== view.buffer.byteLength) {
    throw new RangeError("The buffer of view has different capacity than byobRequest");
  }
  if (firstDescriptor.bytesFilled + view.byteLength > firstDescriptor.byteLength) {
    throw new RangeError("The region specified by view is larger than byobRequest");
  }
  var viewByteLength = view.byteLength;
  firstDescriptor.buffer = TransferArrayBuffer(view.buffer);
  ReadableByteStreamControllerRespondInternal(controller, viewByteLength);
}
function SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize) {
  controller._controlledReadableByteStream = stream;
  controller._pullAgain = false;
  controller._pulling = false;
  controller._byobRequest = null;
  controller._queue = controller._queueTotalSize = void 0;
  ResetQueue(controller);
  controller._closeRequested = false;
  controller._started = false;
  controller._strategyHWM = highWaterMark;
  controller._pullAlgorithm = pullAlgorithm;
  controller._cancelAlgorithm = cancelAlgorithm;
  controller._autoAllocateChunkSize = autoAllocateChunkSize;
  controller._pendingPullIntos = new SimpleQueue();
  stream._readableStreamController = controller;
  var startResult = startAlgorithm();
  uponPromise(promiseResolvedWith(startResult), function() {
    controller._started = true;
    ReadableByteStreamControllerCallPullIfNeeded(controller);
  }, function(r) {
    ReadableByteStreamControllerError(controller, r);
  });
}
function SetUpReadableByteStreamControllerFromUnderlyingSource(stream, underlyingByteSource, highWaterMark) {
  var controller = Object.create(ReadableByteStreamController.prototype);
  var startAlgorithm = function() {
    return void 0;
  };
  var pullAlgorithm = function() {
    return promiseResolvedWith(void 0);
  };
  var cancelAlgorithm = function() {
    return promiseResolvedWith(void 0);
  };
  if (underlyingByteSource.start !== void 0) {
    startAlgorithm = function() {
      return underlyingByteSource.start(controller);
    };
  }
  if (underlyingByteSource.pull !== void 0) {
    pullAlgorithm = function() {
      return underlyingByteSource.pull(controller);
    };
  }
  if (underlyingByteSource.cancel !== void 0) {
    cancelAlgorithm = function(reason) {
      return underlyingByteSource.cancel(reason);
    };
  }
  var autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;
  if (autoAllocateChunkSize === 0) {
    throw new TypeError("autoAllocateChunkSize must be greater than 0");
  }
  SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize);
}
function SetUpReadableStreamBYOBRequest(request, controller, view) {
  request._associatedReadableByteStreamController = controller;
  request._view = view;
}
function byobRequestBrandCheckException(name5) {
  return new TypeError("ReadableStreamBYOBRequest.prototype." + name5 + " can only be used on a ReadableStreamBYOBRequest");
}
function byteStreamControllerBrandCheckException(name5) {
  return new TypeError("ReadableByteStreamController.prototype." + name5 + " can only be used on a ReadableByteStreamController");
}
function AcquireReadableStreamBYOBReader(stream) {
  return new ReadableStreamBYOBReader(stream);
}
function ReadableStreamAddReadIntoRequest(stream, readIntoRequest) {
  stream._reader._readIntoRequests.push(readIntoRequest);
}
function ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {
  var reader = stream._reader;
  var readIntoRequest = reader._readIntoRequests.shift();
  if (done) {
    readIntoRequest._closeSteps(chunk);
  } else {
    readIntoRequest._chunkSteps(chunk);
  }
}
function ReadableStreamGetNumReadIntoRequests(stream) {
  return stream._reader._readIntoRequests.length;
}
function ReadableStreamHasBYOBReader(stream) {
  var reader = stream._reader;
  if (reader === void 0) {
    return false;
  }
  if (!IsReadableStreamBYOBReader(reader)) {
    return false;
  }
  return true;
}
function IsReadableStreamBYOBReader(x) {
  if (!typeIsObject(x)) {
    return false;
  }
  if (!Object.prototype.hasOwnProperty.call(x, "_readIntoRequests")) {
    return false;
  }
  return x instanceof ReadableStreamBYOBReader;
}
function ReadableStreamBYOBReaderRead(reader, view, readIntoRequest) {
  var stream = reader._ownerReadableStream;
  stream._disturbed = true;
  if (stream._state === "errored") {
    readIntoRequest._errorSteps(stream._storedError);
  } else {
    ReadableByteStreamControllerPullInto(stream._readableStreamController, view, readIntoRequest);
  }
}
function byobReaderBrandCheckException(name5) {
  return new TypeError("ReadableStreamBYOBReader.prototype." + name5 + " can only be used on a ReadableStreamBYOBReader");
}
function ExtractHighWaterMark(strategy, defaultHWM) {
  var highWaterMark = strategy.highWaterMark;
  if (highWaterMark === void 0) {
    return defaultHWM;
  }
  if (NumberIsNaN(highWaterMark) || highWaterMark < 0) {
    throw new RangeError("Invalid highWaterMark");
  }
  return highWaterMark;
}
function ExtractSizeAlgorithm(strategy) {
  var size = strategy.size;
  if (!size) {
    return function() {
      return 1;
    };
  }
  return size;
}
function convertQueuingStrategy(init, context) {
  assertDictionary(init, context);
  var highWaterMark = init === null || init === void 0 ? void 0 : init.highWaterMark;
  var size = init === null || init === void 0 ? void 0 : init.size;
  return {
    highWaterMark: highWaterMark === void 0 ? void 0 : convertUnrestrictedDouble(highWaterMark),
    size: size === void 0 ? void 0 : convertQueuingStrategySize(size, context + " has member 'size' that")
  };
}
function convertQueuingStrategySize(fn, context) {
  assertFunction(fn, context);
  return function(chunk) {
    return convertUnrestrictedDouble(fn(chunk));
  };
}
function convertUnderlyingSink(original, context) {
  assertDictionary(original, context);
  var abort = original === null || original === void 0 ? void 0 : original.abort;
  var close = original === null || original === void 0 ? void 0 : original.close;
  var start = original === null || original === void 0 ? void 0 : original.start;
  var type = original === null || original === void 0 ? void 0 : original.type;
  var write = original === null || original === void 0 ? void 0 : original.write;
  return {
    abort: abort === void 0 ? void 0 : convertUnderlyingSinkAbortCallback(abort, original, context + " has member 'abort' that"),
    close: close === void 0 ? void 0 : convertUnderlyingSinkCloseCallback(close, original, context + " has member 'close' that"),
    start: start === void 0 ? void 0 : convertUnderlyingSinkStartCallback(start, original, context + " has member 'start' that"),
    write: write === void 0 ? void 0 : convertUnderlyingSinkWriteCallback(write, original, context + " has member 'write' that"),
    type
  };
}
function convertUnderlyingSinkAbortCallback(fn, original, context) {
  assertFunction(fn, context);
  return function(reason) {
    return promiseCall(fn, original, [reason]);
  };
}
function convertUnderlyingSinkCloseCallback(fn, original, context) {
  assertFunction(fn, context);
  return function() {
    return promiseCall(fn, original, []);
  };
}
function convertUnderlyingSinkStartCallback(fn, original, context) {
  assertFunction(fn, context);
  return function(controller) {
    return reflectCall(fn, original, [controller]);
  };
}
function convertUnderlyingSinkWriteCallback(fn, original, context) {
  assertFunction(fn, context);
  return function(chunk, controller) {
    return promiseCall(fn, original, [chunk, controller]);
  };
}
function assertWritableStream(x, context) {
  if (!IsWritableStream(x)) {
    throw new TypeError(context + " is not a WritableStream.");
  }
}
function isAbortSignal(value) {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  try {
    return typeof value.aborted === "boolean";
  } catch (_a2) {
    return false;
  }
}
function createAbortController() {
  if (supportsAbortController) {
    return new AbortController();
  }
  return void 0;
}
function AcquireWritableStreamDefaultWriter(stream) {
  return new WritableStreamDefaultWriter(stream);
}
function CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {
  if (highWaterMark === void 0) {
    highWaterMark = 1;
  }
  if (sizeAlgorithm === void 0) {
    sizeAlgorithm = function() {
      return 1;
    };
  }
  var stream = Object.create(WritableStream.prototype);
  InitializeWritableStream(stream);
  var controller = Object.create(WritableStreamDefaultController.prototype);
  SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
  return stream;
}
function InitializeWritableStream(stream) {
  stream._state = "writable";
  stream._storedError = void 0;
  stream._writer = void 0;
  stream._writableStreamController = void 0;
  stream._writeRequests = new SimpleQueue();
  stream._inFlightWriteRequest = void 0;
  stream._closeRequest = void 0;
  stream._inFlightCloseRequest = void 0;
  stream._pendingAbortRequest = void 0;
  stream._backpressure = false;
}
function IsWritableStream(x) {
  if (!typeIsObject(x)) {
    return false;
  }
  if (!Object.prototype.hasOwnProperty.call(x, "_writableStreamController")) {
    return false;
  }
  return x instanceof WritableStream;
}
function IsWritableStreamLocked(stream) {
  if (stream._writer === void 0) {
    return false;
  }
  return true;
}
function WritableStreamAbort(stream, reason) {
  var _a2;
  if (stream._state === "closed" || stream._state === "errored") {
    return promiseResolvedWith(void 0);
  }
  stream._writableStreamController._abortReason = reason;
  (_a2 = stream._writableStreamController._abortController) === null || _a2 === void 0 ? void 0 : _a2.abort();
  var state = stream._state;
  if (state === "closed" || state === "errored") {
    return promiseResolvedWith(void 0);
  }
  if (stream._pendingAbortRequest !== void 0) {
    return stream._pendingAbortRequest._promise;
  }
  var wasAlreadyErroring = false;
  if (state === "erroring") {
    wasAlreadyErroring = true;
    reason = void 0;
  }
  var promise = newPromise(function(resolve, reject) {
    stream._pendingAbortRequest = {
      _promise: void 0,
      _resolve: resolve,
      _reject: reject,
      _reason: reason,
      _wasAlreadyErroring: wasAlreadyErroring
    };
  });
  stream._pendingAbortRequest._promise = promise;
  if (!wasAlreadyErroring) {
    WritableStreamStartErroring(stream, reason);
  }
  return promise;
}
function WritableStreamClose(stream) {
  var state = stream._state;
  if (state === "closed" || state === "errored") {
    return promiseRejectedWith(new TypeError("The stream (in " + state + " state) is not in the writable state and cannot be closed"));
  }
  var promise = newPromise(function(resolve, reject) {
    var closeRequest = {
      _resolve: resolve,
      _reject: reject
    };
    stream._closeRequest = closeRequest;
  });
  var writer = stream._writer;
  if (writer !== void 0 && stream._backpressure && state === "writable") {
    defaultWriterReadyPromiseResolve(writer);
  }
  WritableStreamDefaultControllerClose(stream._writableStreamController);
  return promise;
}
function WritableStreamAddWriteRequest(stream) {
  var promise = newPromise(function(resolve, reject) {
    var writeRequest = {
      _resolve: resolve,
      _reject: reject
    };
    stream._writeRequests.push(writeRequest);
  });
  return promise;
}
function WritableStreamDealWithRejection(stream, error) {
  var state = stream._state;
  if (state === "writable") {
    WritableStreamStartErroring(stream, error);
    return;
  }
  WritableStreamFinishErroring(stream);
}
function WritableStreamStartErroring(stream, reason) {
  var controller = stream._writableStreamController;
  stream._state = "erroring";
  stream._storedError = reason;
  var writer = stream._writer;
  if (writer !== void 0) {
    WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);
  }
  if (!WritableStreamHasOperationMarkedInFlight(stream) && controller._started) {
    WritableStreamFinishErroring(stream);
  }
}
function WritableStreamFinishErroring(stream) {
  stream._state = "errored";
  stream._writableStreamController[ErrorSteps]();
  var storedError = stream._storedError;
  stream._writeRequests.forEach(function(writeRequest) {
    writeRequest._reject(storedError);
  });
  stream._writeRequests = new SimpleQueue();
  if (stream._pendingAbortRequest === void 0) {
    WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
    return;
  }
  var abortRequest = stream._pendingAbortRequest;
  stream._pendingAbortRequest = void 0;
  if (abortRequest._wasAlreadyErroring) {
    abortRequest._reject(storedError);
    WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
    return;
  }
  var promise = stream._writableStreamController[AbortSteps](abortRequest._reason);
  uponPromise(promise, function() {
    abortRequest._resolve();
    WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
  }, function(reason) {
    abortRequest._reject(reason);
    WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
  });
}
function WritableStreamFinishInFlightWrite(stream) {
  stream._inFlightWriteRequest._resolve(void 0);
  stream._inFlightWriteRequest = void 0;
}
function WritableStreamFinishInFlightWriteWithError(stream, error) {
  stream._inFlightWriteRequest._reject(error);
  stream._inFlightWriteRequest = void 0;
  WritableStreamDealWithRejection(stream, error);
}
function WritableStreamFinishInFlightClose(stream) {
  stream._inFlightCloseRequest._resolve(void 0);
  stream._inFlightCloseRequest = void 0;
  var state = stream._state;
  if (state === "erroring") {
    stream._storedError = void 0;
    if (stream._pendingAbortRequest !== void 0) {
      stream._pendingAbortRequest._resolve();
      stream._pendingAbortRequest = void 0;
    }
  }
  stream._state = "closed";
  var writer = stream._writer;
  if (writer !== void 0) {
    defaultWriterClosedPromiseResolve(writer);
  }
}
function WritableStreamFinishInFlightCloseWithError(stream, error) {
  stream._inFlightCloseRequest._reject(error);
  stream._inFlightCloseRequest = void 0;
  if (stream._pendingAbortRequest !== void 0) {
    stream._pendingAbortRequest._reject(error);
    stream._pendingAbortRequest = void 0;
  }
  WritableStreamDealWithRejection(stream, error);
}
function WritableStreamCloseQueuedOrInFlight(stream) {
  if (stream._closeRequest === void 0 && stream._inFlightCloseRequest === void 0) {
    return false;
  }
  return true;
}
function WritableStreamHasOperationMarkedInFlight(stream) {
  if (stream._inFlightWriteRequest === void 0 && stream._inFlightCloseRequest === void 0) {
    return false;
  }
  return true;
}
function WritableStreamMarkCloseRequestInFlight(stream) {
  stream._inFlightCloseRequest = stream._closeRequest;
  stream._closeRequest = void 0;
}
function WritableStreamMarkFirstWriteRequestInFlight(stream) {
  stream._inFlightWriteRequest = stream._writeRequests.shift();
}
function WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {
  if (stream._closeRequest !== void 0) {
    stream._closeRequest._reject(stream._storedError);
    stream._closeRequest = void 0;
  }
  var writer = stream._writer;
  if (writer !== void 0) {
    defaultWriterClosedPromiseReject(writer, stream._storedError);
  }
}
function WritableStreamUpdateBackpressure(stream, backpressure) {
  var writer = stream._writer;
  if (writer !== void 0 && backpressure !== stream._backpressure) {
    if (backpressure) {
      defaultWriterReadyPromiseReset(writer);
    } else {
      defaultWriterReadyPromiseResolve(writer);
    }
  }
  stream._backpressure = backpressure;
}
function IsWritableStreamDefaultWriter(x) {
  if (!typeIsObject(x)) {
    return false;
  }
  if (!Object.prototype.hasOwnProperty.call(x, "_ownerWritableStream")) {
    return false;
  }
  return x instanceof WritableStreamDefaultWriter;
}
function WritableStreamDefaultWriterAbort(writer, reason) {
  var stream = writer._ownerWritableStream;
  return WritableStreamAbort(stream, reason);
}
function WritableStreamDefaultWriterClose(writer) {
  var stream = writer._ownerWritableStream;
  return WritableStreamClose(stream);
}
function WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {
  var stream = writer._ownerWritableStream;
  var state = stream._state;
  if (WritableStreamCloseQueuedOrInFlight(stream) || state === "closed") {
    return promiseResolvedWith(void 0);
  }
  if (state === "errored") {
    return promiseRejectedWith(stream._storedError);
  }
  return WritableStreamDefaultWriterClose(writer);
}
function WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error) {
  if (writer._closedPromiseState === "pending") {
    defaultWriterClosedPromiseReject(writer, error);
  } else {
    defaultWriterClosedPromiseResetToRejected(writer, error);
  }
}
function WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error) {
  if (writer._readyPromiseState === "pending") {
    defaultWriterReadyPromiseReject(writer, error);
  } else {
    defaultWriterReadyPromiseResetToRejected(writer, error);
  }
}
function WritableStreamDefaultWriterGetDesiredSize(writer) {
  var stream = writer._ownerWritableStream;
  var state = stream._state;
  if (state === "errored" || state === "erroring") {
    return null;
  }
  if (state === "closed") {
    return 0;
  }
  return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);
}
function WritableStreamDefaultWriterRelease(writer) {
  var stream = writer._ownerWritableStream;
  var releasedError = new TypeError("Writer was released and can no longer be used to monitor the stream's closedness");
  WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);
  WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);
  stream._writer = void 0;
  writer._ownerWritableStream = void 0;
}
function WritableStreamDefaultWriterWrite(writer, chunk) {
  var stream = writer._ownerWritableStream;
  var controller = stream._writableStreamController;
  var chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);
  if (stream !== writer._ownerWritableStream) {
    return promiseRejectedWith(defaultWriterLockException("write to"));
  }
  var state = stream._state;
  if (state === "errored") {
    return promiseRejectedWith(stream._storedError);
  }
  if (WritableStreamCloseQueuedOrInFlight(stream) || state === "closed") {
    return promiseRejectedWith(new TypeError("The stream is closing or closed and cannot be written to"));
  }
  if (state === "erroring") {
    return promiseRejectedWith(stream._storedError);
  }
  var promise = WritableStreamAddWriteRequest(stream);
  WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);
  return promise;
}
function IsWritableStreamDefaultController(x) {
  if (!typeIsObject(x)) {
    return false;
  }
  if (!Object.prototype.hasOwnProperty.call(x, "_controlledWritableStream")) {
    return false;
  }
  return x instanceof WritableStreamDefaultController;
}
function SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {
  controller._controlledWritableStream = stream;
  stream._writableStreamController = controller;
  controller._queue = void 0;
  controller._queueTotalSize = void 0;
  ResetQueue(controller);
  controller._abortReason = void 0;
  controller._abortController = createAbortController();
  controller._started = false;
  controller._strategySizeAlgorithm = sizeAlgorithm;
  controller._strategyHWM = highWaterMark;
  controller._writeAlgorithm = writeAlgorithm;
  controller._closeAlgorithm = closeAlgorithm;
  controller._abortAlgorithm = abortAlgorithm;
  var backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
  WritableStreamUpdateBackpressure(stream, backpressure);
  var startResult = startAlgorithm();
  var startPromise = promiseResolvedWith(startResult);
  uponPromise(startPromise, function() {
    controller._started = true;
    WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
  }, function(r) {
    controller._started = true;
    WritableStreamDealWithRejection(stream, r);
  });
}
function SetUpWritableStreamDefaultControllerFromUnderlyingSink(stream, underlyingSink, highWaterMark, sizeAlgorithm) {
  var controller = Object.create(WritableStreamDefaultController.prototype);
  var startAlgorithm = function() {
    return void 0;
  };
  var writeAlgorithm = function() {
    return promiseResolvedWith(void 0);
  };
  var closeAlgorithm = function() {
    return promiseResolvedWith(void 0);
  };
  var abortAlgorithm = function() {
    return promiseResolvedWith(void 0);
  };
  if (underlyingSink.start !== void 0) {
    startAlgorithm = function() {
      return underlyingSink.start(controller);
    };
  }
  if (underlyingSink.write !== void 0) {
    writeAlgorithm = function(chunk) {
      return underlyingSink.write(chunk, controller);
    };
  }
  if (underlyingSink.close !== void 0) {
    closeAlgorithm = function() {
      return underlyingSink.close();
    };
  }
  if (underlyingSink.abort !== void 0) {
    abortAlgorithm = function(reason) {
      return underlyingSink.abort(reason);
    };
  }
  SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
}
function WritableStreamDefaultControllerClearAlgorithms(controller) {
  controller._writeAlgorithm = void 0;
  controller._closeAlgorithm = void 0;
  controller._abortAlgorithm = void 0;
  controller._strategySizeAlgorithm = void 0;
}
function WritableStreamDefaultControllerClose(controller) {
  EnqueueValueWithSize(controller, closeSentinel, 0);
  WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
}
function WritableStreamDefaultControllerGetChunkSize(controller, chunk) {
  try {
    return controller._strategySizeAlgorithm(chunk);
  } catch (chunkSizeE) {
    WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);
    return 1;
  }
}
function WritableStreamDefaultControllerGetDesiredSize(controller) {
  return controller._strategyHWM - controller._queueTotalSize;
}
function WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {
  try {
    EnqueueValueWithSize(controller, chunk, chunkSize);
  } catch (enqueueE) {
    WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);
    return;
  }
  var stream = controller._controlledWritableStream;
  if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._state === "writable") {
    var backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
    WritableStreamUpdateBackpressure(stream, backpressure);
  }
  WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
}
function WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {
  var stream = controller._controlledWritableStream;
  if (!controller._started) {
    return;
  }
  if (stream._inFlightWriteRequest !== void 0) {
    return;
  }
  var state = stream._state;
  if (state === "erroring") {
    WritableStreamFinishErroring(stream);
    return;
  }
  if (controller._queue.length === 0) {
    return;
  }
  var value = PeekQueueValue(controller);
  if (value === closeSentinel) {
    WritableStreamDefaultControllerProcessClose(controller);
  } else {
    WritableStreamDefaultControllerProcessWrite(controller, value);
  }
}
function WritableStreamDefaultControllerErrorIfNeeded(controller, error) {
  if (controller._controlledWritableStream._state === "writable") {
    WritableStreamDefaultControllerError(controller, error);
  }
}
function WritableStreamDefaultControllerProcessClose(controller) {
  var stream = controller._controlledWritableStream;
  WritableStreamMarkCloseRequestInFlight(stream);
  DequeueValue(controller);
  var sinkClosePromise = controller._closeAlgorithm();
  WritableStreamDefaultControllerClearAlgorithms(controller);
  uponPromise(sinkClosePromise, function() {
    WritableStreamFinishInFlightClose(stream);
  }, function(reason) {
    WritableStreamFinishInFlightCloseWithError(stream, reason);
  });
}
function WritableStreamDefaultControllerProcessWrite(controller, chunk) {
  var stream = controller._controlledWritableStream;
  WritableStreamMarkFirstWriteRequestInFlight(stream);
  var sinkWritePromise = controller._writeAlgorithm(chunk);
  uponPromise(sinkWritePromise, function() {
    WritableStreamFinishInFlightWrite(stream);
    var state = stream._state;
    DequeueValue(controller);
    if (!WritableStreamCloseQueuedOrInFlight(stream) && state === "writable") {
      var backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
      WritableStreamUpdateBackpressure(stream, backpressure);
    }
    WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
  }, function(reason) {
    if (stream._state === "writable") {
      WritableStreamDefaultControllerClearAlgorithms(controller);
    }
    WritableStreamFinishInFlightWriteWithError(stream, reason);
  });
}
function WritableStreamDefaultControllerGetBackpressure(controller) {
  var desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);
  return desiredSize <= 0;
}
function WritableStreamDefaultControllerError(controller, error) {
  var stream = controller._controlledWritableStream;
  WritableStreamDefaultControllerClearAlgorithms(controller);
  WritableStreamStartErroring(stream, error);
}
function streamBrandCheckException$2(name5) {
  return new TypeError("WritableStream.prototype." + name5 + " can only be used on a WritableStream");
}
function defaultControllerBrandCheckException$2(name5) {
  return new TypeError("WritableStreamDefaultController.prototype." + name5 + " can only be used on a WritableStreamDefaultController");
}
function defaultWriterBrandCheckException(name5) {
  return new TypeError("WritableStreamDefaultWriter.prototype." + name5 + " can only be used on a WritableStreamDefaultWriter");
}
function defaultWriterLockException(name5) {
  return new TypeError("Cannot " + name5 + " a stream using a released writer");
}
function defaultWriterClosedPromiseInitialize(writer) {
  writer._closedPromise = newPromise(function(resolve, reject) {
    writer._closedPromise_resolve = resolve;
    writer._closedPromise_reject = reject;
    writer._closedPromiseState = "pending";
  });
}
function defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {
  defaultWriterClosedPromiseInitialize(writer);
  defaultWriterClosedPromiseReject(writer, reason);
}
function defaultWriterClosedPromiseInitializeAsResolved(writer) {
  defaultWriterClosedPromiseInitialize(writer);
  defaultWriterClosedPromiseResolve(writer);
}
function defaultWriterClosedPromiseReject(writer, reason) {
  if (writer._closedPromise_reject === void 0) {
    return;
  }
  setPromiseIsHandledToTrue(writer._closedPromise);
  writer._closedPromise_reject(reason);
  writer._closedPromise_resolve = void 0;
  writer._closedPromise_reject = void 0;
  writer._closedPromiseState = "rejected";
}
function defaultWriterClosedPromiseResetToRejected(writer, reason) {
  defaultWriterClosedPromiseInitializeAsRejected(writer, reason);
}
function defaultWriterClosedPromiseResolve(writer) {
  if (writer._closedPromise_resolve === void 0) {
    return;
  }
  writer._closedPromise_resolve(void 0);
  writer._closedPromise_resolve = void 0;
  writer._closedPromise_reject = void 0;
  writer._closedPromiseState = "resolved";
}
function defaultWriterReadyPromiseInitialize(writer) {
  writer._readyPromise = newPromise(function(resolve, reject) {
    writer._readyPromise_resolve = resolve;
    writer._readyPromise_reject = reject;
  });
  writer._readyPromiseState = "pending";
}
function defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {
  defaultWriterReadyPromiseInitialize(writer);
  defaultWriterReadyPromiseReject(writer, reason);
}
function defaultWriterReadyPromiseInitializeAsResolved(writer) {
  defaultWriterReadyPromiseInitialize(writer);
  defaultWriterReadyPromiseResolve(writer);
}
function defaultWriterReadyPromiseReject(writer, reason) {
  if (writer._readyPromise_reject === void 0) {
    return;
  }
  setPromiseIsHandledToTrue(writer._readyPromise);
  writer._readyPromise_reject(reason);
  writer._readyPromise_resolve = void 0;
  writer._readyPromise_reject = void 0;
  writer._readyPromiseState = "rejected";
}
function defaultWriterReadyPromiseReset(writer) {
  defaultWriterReadyPromiseInitialize(writer);
}
function defaultWriterReadyPromiseResetToRejected(writer, reason) {
  defaultWriterReadyPromiseInitializeAsRejected(writer, reason);
}
function defaultWriterReadyPromiseResolve(writer) {
  if (writer._readyPromise_resolve === void 0) {
    return;
  }
  writer._readyPromise_resolve(void 0);
  writer._readyPromise_resolve = void 0;
  writer._readyPromise_reject = void 0;
  writer._readyPromiseState = "fulfilled";
}
function isDOMExceptionConstructor(ctor) {
  if (!(typeof ctor === "function" || typeof ctor === "object")) {
    return false;
  }
  try {
    new ctor();
    return true;
  } catch (_a2) {
    return false;
  }
}
function createDOMExceptionPolyfill() {
  var ctor = function DOMException2(message, name5) {
    this.message = message || "";
    this.name = name5 || "Error";
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
  };
  ctor.prototype = Object.create(Error.prototype);
  Object.defineProperty(ctor.prototype, "constructor", { value: ctor, writable: true, configurable: true });
  return ctor;
}
function ReadableStreamPipeTo(source, dest, preventClose, preventAbort, preventCancel, signal) {
  var reader = AcquireReadableStreamDefaultReader(source);
  var writer = AcquireWritableStreamDefaultWriter(dest);
  source._disturbed = true;
  var shuttingDown = false;
  var currentWrite = promiseResolvedWith(void 0);
  return newPromise(function(resolve, reject) {
    var abortAlgorithm;
    if (signal !== void 0) {
      abortAlgorithm = function() {
        var error = new DOMException$1("Aborted", "AbortError");
        var actions = [];
        if (!preventAbort) {
          actions.push(function() {
            if (dest._state === "writable") {
              return WritableStreamAbort(dest, error);
            }
            return promiseResolvedWith(void 0);
          });
        }
        if (!preventCancel) {
          actions.push(function() {
            if (source._state === "readable") {
              return ReadableStreamCancel(source, error);
            }
            return promiseResolvedWith(void 0);
          });
        }
        shutdownWithAction(function() {
          return Promise.all(actions.map(function(action) {
            return action();
          }));
        }, true, error);
      };
      if (signal.aborted) {
        abortAlgorithm();
        return;
      }
      signal.addEventListener("abort", abortAlgorithm);
    }
    function pipeLoop() {
      return newPromise(function(resolveLoop, rejectLoop) {
        function next(done) {
          if (done) {
            resolveLoop();
          } else {
            PerformPromiseThen(pipeStep(), next, rejectLoop);
          }
        }
        next(false);
      });
    }
    function pipeStep() {
      if (shuttingDown) {
        return promiseResolvedWith(true);
      }
      return PerformPromiseThen(writer._readyPromise, function() {
        return newPromise(function(resolveRead, rejectRead) {
          ReadableStreamDefaultReaderRead(reader, {
            _chunkSteps: function(chunk) {
              currentWrite = PerformPromiseThen(WritableStreamDefaultWriterWrite(writer, chunk), void 0, noop2);
              resolveRead(false);
            },
            _closeSteps: function() {
              return resolveRead(true);
            },
            _errorSteps: rejectRead
          });
        });
      });
    }
    isOrBecomesErrored(source, reader._closedPromise, function(storedError) {
      if (!preventAbort) {
        shutdownWithAction(function() {
          return WritableStreamAbort(dest, storedError);
        }, true, storedError);
      } else {
        shutdown(true, storedError);
      }
    });
    isOrBecomesErrored(dest, writer._closedPromise, function(storedError) {
      if (!preventCancel) {
        shutdownWithAction(function() {
          return ReadableStreamCancel(source, storedError);
        }, true, storedError);
      } else {
        shutdown(true, storedError);
      }
    });
    isOrBecomesClosed(source, reader._closedPromise, function() {
      if (!preventClose) {
        shutdownWithAction(function() {
          return WritableStreamDefaultWriterCloseWithErrorPropagation(writer);
        });
      } else {
        shutdown();
      }
    });
    if (WritableStreamCloseQueuedOrInFlight(dest) || dest._state === "closed") {
      var destClosed_1 = new TypeError("the destination writable stream closed before all data could be piped to it");
      if (!preventCancel) {
        shutdownWithAction(function() {
          return ReadableStreamCancel(source, destClosed_1);
        }, true, destClosed_1);
      } else {
        shutdown(true, destClosed_1);
      }
    }
    setPromiseIsHandledToTrue(pipeLoop());
    function waitForWritesToFinish() {
      var oldCurrentWrite = currentWrite;
      return PerformPromiseThen(currentWrite, function() {
        return oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : void 0;
      });
    }
    function isOrBecomesErrored(stream, promise, action) {
      if (stream._state === "errored") {
        action(stream._storedError);
      } else {
        uponRejection(promise, action);
      }
    }
    function isOrBecomesClosed(stream, promise, action) {
      if (stream._state === "closed") {
        action();
      } else {
        uponFulfillment(promise, action);
      }
    }
    function shutdownWithAction(action, originalIsError, originalError) {
      if (shuttingDown) {
        return;
      }
      shuttingDown = true;
      if (dest._state === "writable" && !WritableStreamCloseQueuedOrInFlight(dest)) {
        uponFulfillment(waitForWritesToFinish(), doTheRest);
      } else {
        doTheRest();
      }
      function doTheRest() {
        uponPromise(action(), function() {
          return finalize(originalIsError, originalError);
        }, function(newError) {
          return finalize(true, newError);
        });
      }
    }
    function shutdown(isError, error) {
      if (shuttingDown) {
        return;
      }
      shuttingDown = true;
      if (dest._state === "writable" && !WritableStreamCloseQueuedOrInFlight(dest)) {
        uponFulfillment(waitForWritesToFinish(), function() {
          return finalize(isError, error);
        });
      } else {
        finalize(isError, error);
      }
    }
    function finalize(isError, error) {
      WritableStreamDefaultWriterRelease(writer);
      ReadableStreamReaderGenericRelease(reader);
      if (signal !== void 0) {
        signal.removeEventListener("abort", abortAlgorithm);
      }
      if (isError) {
        reject(error);
      } else {
        resolve(void 0);
      }
    }
  });
}
function IsReadableStreamDefaultController(x) {
  if (!typeIsObject(x)) {
    return false;
  }
  if (!Object.prototype.hasOwnProperty.call(x, "_controlledReadableStream")) {
    return false;
  }
  return x instanceof ReadableStreamDefaultController;
}
function ReadableStreamDefaultControllerCallPullIfNeeded(controller) {
  var shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);
  if (!shouldPull) {
    return;
  }
  if (controller._pulling) {
    controller._pullAgain = true;
    return;
  }
  controller._pulling = true;
  var pullPromise = controller._pullAlgorithm();
  uponPromise(pullPromise, function() {
    controller._pulling = false;
    if (controller._pullAgain) {
      controller._pullAgain = false;
      ReadableStreamDefaultControllerCallPullIfNeeded(controller);
    }
  }, function(e) {
    ReadableStreamDefaultControllerError(controller, e);
  });
}
function ReadableStreamDefaultControllerShouldCallPull(controller) {
  var stream = controller._controlledReadableStream;
  if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
    return false;
  }
  if (!controller._started) {
    return false;
  }
  if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
    return true;
  }
  var desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);
  if (desiredSize > 0) {
    return true;
  }
  return false;
}
function ReadableStreamDefaultControllerClearAlgorithms(controller) {
  controller._pullAlgorithm = void 0;
  controller._cancelAlgorithm = void 0;
  controller._strategySizeAlgorithm = void 0;
}
function ReadableStreamDefaultControllerClose(controller) {
  if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
    return;
  }
  var stream = controller._controlledReadableStream;
  controller._closeRequested = true;
  if (controller._queue.length === 0) {
    ReadableStreamDefaultControllerClearAlgorithms(controller);
    ReadableStreamClose(stream);
  }
}
function ReadableStreamDefaultControllerEnqueue(controller, chunk) {
  if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
    return;
  }
  var stream = controller._controlledReadableStream;
  if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
    ReadableStreamFulfillReadRequest(stream, chunk, false);
  } else {
    var chunkSize = void 0;
    try {
      chunkSize = controller._strategySizeAlgorithm(chunk);
    } catch (chunkSizeE) {
      ReadableStreamDefaultControllerError(controller, chunkSizeE);
      throw chunkSizeE;
    }
    try {
      EnqueueValueWithSize(controller, chunk, chunkSize);
    } catch (enqueueE) {
      ReadableStreamDefaultControllerError(controller, enqueueE);
      throw enqueueE;
    }
  }
  ReadableStreamDefaultControllerCallPullIfNeeded(controller);
}
function ReadableStreamDefaultControllerError(controller, e) {
  var stream = controller._controlledReadableStream;
  if (stream._state !== "readable") {
    return;
  }
  ResetQueue(controller);
  ReadableStreamDefaultControllerClearAlgorithms(controller);
  ReadableStreamError(stream, e);
}
function ReadableStreamDefaultControllerGetDesiredSize(controller) {
  var state = controller._controlledReadableStream._state;
  if (state === "errored") {
    return null;
  }
  if (state === "closed") {
    return 0;
  }
  return controller._strategyHWM - controller._queueTotalSize;
}
function ReadableStreamDefaultControllerHasBackpressure(controller) {
  if (ReadableStreamDefaultControllerShouldCallPull(controller)) {
    return false;
  }
  return true;
}
function ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {
  var state = controller._controlledReadableStream._state;
  if (!controller._closeRequested && state === "readable") {
    return true;
  }
  return false;
}
function SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {
  controller._controlledReadableStream = stream;
  controller._queue = void 0;
  controller._queueTotalSize = void 0;
  ResetQueue(controller);
  controller._started = false;
  controller._closeRequested = false;
  controller._pullAgain = false;
  controller._pulling = false;
  controller._strategySizeAlgorithm = sizeAlgorithm;
  controller._strategyHWM = highWaterMark;
  controller._pullAlgorithm = pullAlgorithm;
  controller._cancelAlgorithm = cancelAlgorithm;
  stream._readableStreamController = controller;
  var startResult = startAlgorithm();
  uponPromise(promiseResolvedWith(startResult), function() {
    controller._started = true;
    ReadableStreamDefaultControllerCallPullIfNeeded(controller);
  }, function(r) {
    ReadableStreamDefaultControllerError(controller, r);
  });
}
function SetUpReadableStreamDefaultControllerFromUnderlyingSource(stream, underlyingSource, highWaterMark, sizeAlgorithm) {
  var controller = Object.create(ReadableStreamDefaultController.prototype);
  var startAlgorithm = function() {
    return void 0;
  };
  var pullAlgorithm = function() {
    return promiseResolvedWith(void 0);
  };
  var cancelAlgorithm = function() {
    return promiseResolvedWith(void 0);
  };
  if (underlyingSource.start !== void 0) {
    startAlgorithm = function() {
      return underlyingSource.start(controller);
    };
  }
  if (underlyingSource.pull !== void 0) {
    pullAlgorithm = function() {
      return underlyingSource.pull(controller);
    };
  }
  if (underlyingSource.cancel !== void 0) {
    cancelAlgorithm = function(reason) {
      return underlyingSource.cancel(reason);
    };
  }
  SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
}
function defaultControllerBrandCheckException$1(name5) {
  return new TypeError("ReadableStreamDefaultController.prototype." + name5 + " can only be used on a ReadableStreamDefaultController");
}
function ReadableStreamTee(stream, cloneForBranch2) {
  if (IsReadableByteStreamController(stream._readableStreamController)) {
    return ReadableByteStreamTee(stream);
  }
  return ReadableStreamDefaultTee(stream);
}
function ReadableStreamDefaultTee(stream, cloneForBranch2) {
  var reader = AcquireReadableStreamDefaultReader(stream);
  var reading = false;
  var readAgain = false;
  var canceled1 = false;
  var canceled2 = false;
  var reason1;
  var reason2;
  var branch1;
  var branch2;
  var resolveCancelPromise;
  var cancelPromise = newPromise(function(resolve) {
    resolveCancelPromise = resolve;
  });
  function pullAlgorithm() {
    if (reading) {
      readAgain = true;
      return promiseResolvedWith(void 0);
    }
    reading = true;
    var readRequest = {
      _chunkSteps: function(chunk) {
        queueMicrotask(function() {
          readAgain = false;
          var chunk1 = chunk;
          var chunk2 = chunk;
          if (!canceled1) {
            ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, chunk1);
          }
          if (!canceled2) {
            ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, chunk2);
          }
          reading = false;
          if (readAgain) {
            pullAlgorithm();
          }
        });
      },
      _closeSteps: function() {
        reading = false;
        if (!canceled1) {
          ReadableStreamDefaultControllerClose(branch1._readableStreamController);
        }
        if (!canceled2) {
          ReadableStreamDefaultControllerClose(branch2._readableStreamController);
        }
        if (!canceled1 || !canceled2) {
          resolveCancelPromise(void 0);
        }
      },
      _errorSteps: function() {
        reading = false;
      }
    };
    ReadableStreamDefaultReaderRead(reader, readRequest);
    return promiseResolvedWith(void 0);
  }
  function cancel1Algorithm(reason) {
    canceled1 = true;
    reason1 = reason;
    if (canceled2) {
      var compositeReason = CreateArrayFromList([reason1, reason2]);
      var cancelResult = ReadableStreamCancel(stream, compositeReason);
      resolveCancelPromise(cancelResult);
    }
    return cancelPromise;
  }
  function cancel2Algorithm(reason) {
    canceled2 = true;
    reason2 = reason;
    if (canceled1) {
      var compositeReason = CreateArrayFromList([reason1, reason2]);
      var cancelResult = ReadableStreamCancel(stream, compositeReason);
      resolveCancelPromise(cancelResult);
    }
    return cancelPromise;
  }
  function startAlgorithm() {
  }
  branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);
  branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);
  uponRejection(reader._closedPromise, function(r) {
    ReadableStreamDefaultControllerError(branch1._readableStreamController, r);
    ReadableStreamDefaultControllerError(branch2._readableStreamController, r);
    if (!canceled1 || !canceled2) {
      resolveCancelPromise(void 0);
    }
  });
  return [branch1, branch2];
}
function ReadableByteStreamTee(stream) {
  var reader = AcquireReadableStreamDefaultReader(stream);
  var reading = false;
  var readAgainForBranch1 = false;
  var readAgainForBranch2 = false;
  var canceled1 = false;
  var canceled2 = false;
  var reason1;
  var reason2;
  var branch1;
  var branch2;
  var resolveCancelPromise;
  var cancelPromise = newPromise(function(resolve) {
    resolveCancelPromise = resolve;
  });
  function forwardReaderError(thisReader) {
    uponRejection(thisReader._closedPromise, function(r) {
      if (thisReader !== reader) {
        return;
      }
      ReadableByteStreamControllerError(branch1._readableStreamController, r);
      ReadableByteStreamControllerError(branch2._readableStreamController, r);
      if (!canceled1 || !canceled2) {
        resolveCancelPromise(void 0);
      }
    });
  }
  function pullWithDefaultReader() {
    if (IsReadableStreamBYOBReader(reader)) {
      ReadableStreamReaderGenericRelease(reader);
      reader = AcquireReadableStreamDefaultReader(stream);
      forwardReaderError(reader);
    }
    var readRequest = {
      _chunkSteps: function(chunk) {
        queueMicrotask(function() {
          readAgainForBranch1 = false;
          readAgainForBranch2 = false;
          var chunk1 = chunk;
          var chunk2 = chunk;
          if (!canceled1 && !canceled2) {
            try {
              chunk2 = CloneAsUint8Array(chunk);
            } catch (cloneE) {
              ReadableByteStreamControllerError(branch1._readableStreamController, cloneE);
              ReadableByteStreamControllerError(branch2._readableStreamController, cloneE);
              resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
              return;
            }
          }
          if (!canceled1) {
            ReadableByteStreamControllerEnqueue(branch1._readableStreamController, chunk1);
          }
          if (!canceled2) {
            ReadableByteStreamControllerEnqueue(branch2._readableStreamController, chunk2);
          }
          reading = false;
          if (readAgainForBranch1) {
            pull1Algorithm();
          } else if (readAgainForBranch2) {
            pull2Algorithm();
          }
        });
      },
      _closeSteps: function() {
        reading = false;
        if (!canceled1) {
          ReadableByteStreamControllerClose(branch1._readableStreamController);
        }
        if (!canceled2) {
          ReadableByteStreamControllerClose(branch2._readableStreamController);
        }
        if (branch1._readableStreamController._pendingPullIntos.length > 0) {
          ReadableByteStreamControllerRespond(branch1._readableStreamController, 0);
        }
        if (branch2._readableStreamController._pendingPullIntos.length > 0) {
          ReadableByteStreamControllerRespond(branch2._readableStreamController, 0);
        }
        if (!canceled1 || !canceled2) {
          resolveCancelPromise(void 0);
        }
      },
      _errorSteps: function() {
        reading = false;
      }
    };
    ReadableStreamDefaultReaderRead(reader, readRequest);
  }
  function pullWithBYOBReader(view, forBranch2) {
    if (IsReadableStreamDefaultReader(reader)) {
      ReadableStreamReaderGenericRelease(reader);
      reader = AcquireReadableStreamBYOBReader(stream);
      forwardReaderError(reader);
    }
    var byobBranch = forBranch2 ? branch2 : branch1;
    var otherBranch = forBranch2 ? branch1 : branch2;
    var readIntoRequest = {
      _chunkSteps: function(chunk) {
        queueMicrotask(function() {
          readAgainForBranch1 = false;
          readAgainForBranch2 = false;
          var byobCanceled = forBranch2 ? canceled2 : canceled1;
          var otherCanceled = forBranch2 ? canceled1 : canceled2;
          if (!otherCanceled) {
            var clonedChunk = void 0;
            try {
              clonedChunk = CloneAsUint8Array(chunk);
            } catch (cloneE) {
              ReadableByteStreamControllerError(byobBranch._readableStreamController, cloneE);
              ReadableByteStreamControllerError(otherBranch._readableStreamController, cloneE);
              resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
              return;
            }
            if (!byobCanceled) {
              ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
            }
            ReadableByteStreamControllerEnqueue(otherBranch._readableStreamController, clonedChunk);
          } else if (!byobCanceled) {
            ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
          }
          reading = false;
          if (readAgainForBranch1) {
            pull1Algorithm();
          } else if (readAgainForBranch2) {
            pull2Algorithm();
          }
        });
      },
      _closeSteps: function(chunk) {
        reading = false;
        var byobCanceled = forBranch2 ? canceled2 : canceled1;
        var otherCanceled = forBranch2 ? canceled1 : canceled2;
        if (!byobCanceled) {
          ReadableByteStreamControllerClose(byobBranch._readableStreamController);
        }
        if (!otherCanceled) {
          ReadableByteStreamControllerClose(otherBranch._readableStreamController);
        }
        if (chunk !== void 0) {
          if (!byobCanceled) {
            ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
          }
          if (!otherCanceled && otherBranch._readableStreamController._pendingPullIntos.length > 0) {
            ReadableByteStreamControllerRespond(otherBranch._readableStreamController, 0);
          }
        }
        if (!byobCanceled || !otherCanceled) {
          resolveCancelPromise(void 0);
        }
      },
      _errorSteps: function() {
        reading = false;
      }
    };
    ReadableStreamBYOBReaderRead(reader, view, readIntoRequest);
  }
  function pull1Algorithm() {
    if (reading) {
      readAgainForBranch1 = true;
      return promiseResolvedWith(void 0);
    }
    reading = true;
    var byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch1._readableStreamController);
    if (byobRequest === null) {
      pullWithDefaultReader();
    } else {
      pullWithBYOBReader(byobRequest._view, false);
    }
    return promiseResolvedWith(void 0);
  }
  function pull2Algorithm() {
    if (reading) {
      readAgainForBranch2 = true;
      return promiseResolvedWith(void 0);
    }
    reading = true;
    var byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch2._readableStreamController);
    if (byobRequest === null) {
      pullWithDefaultReader();
    } else {
      pullWithBYOBReader(byobRequest._view, true);
    }
    return promiseResolvedWith(void 0);
  }
  function cancel1Algorithm(reason) {
    canceled1 = true;
    reason1 = reason;
    if (canceled2) {
      var compositeReason = CreateArrayFromList([reason1, reason2]);
      var cancelResult = ReadableStreamCancel(stream, compositeReason);
      resolveCancelPromise(cancelResult);
    }
    return cancelPromise;
  }
  function cancel2Algorithm(reason) {
    canceled2 = true;
    reason2 = reason;
    if (canceled1) {
      var compositeReason = CreateArrayFromList([reason1, reason2]);
      var cancelResult = ReadableStreamCancel(stream, compositeReason);
      resolveCancelPromise(cancelResult);
    }
    return cancelPromise;
  }
  function startAlgorithm() {
    return;
  }
  branch1 = CreateReadableByteStream(startAlgorithm, pull1Algorithm, cancel1Algorithm);
  branch2 = CreateReadableByteStream(startAlgorithm, pull2Algorithm, cancel2Algorithm);
  forwardReaderError(reader);
  return [branch1, branch2];
}
function convertUnderlyingDefaultOrByteSource(source, context) {
  assertDictionary(source, context);
  var original = source;
  var autoAllocateChunkSize = original === null || original === void 0 ? void 0 : original.autoAllocateChunkSize;
  var cancel = original === null || original === void 0 ? void 0 : original.cancel;
  var pull = original === null || original === void 0 ? void 0 : original.pull;
  var start = original === null || original === void 0 ? void 0 : original.start;
  var type = original === null || original === void 0 ? void 0 : original.type;
  return {
    autoAllocateChunkSize: autoAllocateChunkSize === void 0 ? void 0 : convertUnsignedLongLongWithEnforceRange(autoAllocateChunkSize, context + " has member 'autoAllocateChunkSize' that"),
    cancel: cancel === void 0 ? void 0 : convertUnderlyingSourceCancelCallback(cancel, original, context + " has member 'cancel' that"),
    pull: pull === void 0 ? void 0 : convertUnderlyingSourcePullCallback(pull, original, context + " has member 'pull' that"),
    start: start === void 0 ? void 0 : convertUnderlyingSourceStartCallback(start, original, context + " has member 'start' that"),
    type: type === void 0 ? void 0 : convertReadableStreamType(type, context + " has member 'type' that")
  };
}
function convertUnderlyingSourceCancelCallback(fn, original, context) {
  assertFunction(fn, context);
  return function(reason) {
    return promiseCall(fn, original, [reason]);
  };
}
function convertUnderlyingSourcePullCallback(fn, original, context) {
  assertFunction(fn, context);
  return function(controller) {
    return promiseCall(fn, original, [controller]);
  };
}
function convertUnderlyingSourceStartCallback(fn, original, context) {
  assertFunction(fn, context);
  return function(controller) {
    return reflectCall(fn, original, [controller]);
  };
}
function convertReadableStreamType(type, context) {
  type = "" + type;
  if (type !== "bytes") {
    throw new TypeError(context + " '" + type + "' is not a valid enumeration value for ReadableStreamType");
  }
  return type;
}
function convertReaderOptions(options, context) {
  assertDictionary(options, context);
  var mode = options === null || options === void 0 ? void 0 : options.mode;
  return {
    mode: mode === void 0 ? void 0 : convertReadableStreamReaderMode(mode, context + " has member 'mode' that")
  };
}
function convertReadableStreamReaderMode(mode, context) {
  mode = "" + mode;
  if (mode !== "byob") {
    throw new TypeError(context + " '" + mode + "' is not a valid enumeration value for ReadableStreamReaderMode");
  }
  return mode;
}
function convertIteratorOptions(options, context) {
  assertDictionary(options, context);
  var preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;
  return { preventCancel: Boolean(preventCancel) };
}
function convertPipeOptions(options, context) {
  assertDictionary(options, context);
  var preventAbort = options === null || options === void 0 ? void 0 : options.preventAbort;
  var preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;
  var preventClose = options === null || options === void 0 ? void 0 : options.preventClose;
  var signal = options === null || options === void 0 ? void 0 : options.signal;
  if (signal !== void 0) {
    assertAbortSignal(signal, context + " has member 'signal' that");
  }
  return {
    preventAbort: Boolean(preventAbort),
    preventCancel: Boolean(preventCancel),
    preventClose: Boolean(preventClose),
    signal
  };
}
function assertAbortSignal(signal, context) {
  if (!isAbortSignal(signal)) {
    throw new TypeError(context + " is not an AbortSignal.");
  }
}
function convertReadableWritablePair(pair, context) {
  assertDictionary(pair, context);
  var readable = pair === null || pair === void 0 ? void 0 : pair.readable;
  assertRequiredField(readable, "readable", "ReadableWritablePair");
  assertReadableStream(readable, context + " has member 'readable' that");
  var writable = pair === null || pair === void 0 ? void 0 : pair.writable;
  assertRequiredField(writable, "writable", "ReadableWritablePair");
  assertWritableStream(writable, context + " has member 'writable' that");
  return { readable, writable };
}
function CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {
  if (highWaterMark === void 0) {
    highWaterMark = 1;
  }
  if (sizeAlgorithm === void 0) {
    sizeAlgorithm = function() {
      return 1;
    };
  }
  var stream = Object.create(ReadableStream.prototype);
  InitializeReadableStream(stream);
  var controller = Object.create(ReadableStreamDefaultController.prototype);
  SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
  return stream;
}
function CreateReadableByteStream(startAlgorithm, pullAlgorithm, cancelAlgorithm) {
  var stream = Object.create(ReadableStream.prototype);
  InitializeReadableStream(stream);
  var controller = Object.create(ReadableByteStreamController.prototype);
  SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, 0, void 0);
  return stream;
}
function InitializeReadableStream(stream) {
  stream._state = "readable";
  stream._reader = void 0;
  stream._storedError = void 0;
  stream._disturbed = false;
}
function IsReadableStream(x) {
  if (!typeIsObject(x)) {
    return false;
  }
  if (!Object.prototype.hasOwnProperty.call(x, "_readableStreamController")) {
    return false;
  }
  return x instanceof ReadableStream;
}
function IsReadableStreamLocked(stream) {
  if (stream._reader === void 0) {
    return false;
  }
  return true;
}
function ReadableStreamCancel(stream, reason) {
  stream._disturbed = true;
  if (stream._state === "closed") {
    return promiseResolvedWith(void 0);
  }
  if (stream._state === "errored") {
    return promiseRejectedWith(stream._storedError);
  }
  ReadableStreamClose(stream);
  var reader = stream._reader;
  if (reader !== void 0 && IsReadableStreamBYOBReader(reader)) {
    reader._readIntoRequests.forEach(function(readIntoRequest) {
      readIntoRequest._closeSteps(void 0);
    });
    reader._readIntoRequests = new SimpleQueue();
  }
  var sourceCancelPromise = stream._readableStreamController[CancelSteps](reason);
  return transformPromiseWith(sourceCancelPromise, noop2);
}
function ReadableStreamClose(stream) {
  stream._state = "closed";
  var reader = stream._reader;
  if (reader === void 0) {
    return;
  }
  defaultReaderClosedPromiseResolve(reader);
  if (IsReadableStreamDefaultReader(reader)) {
    reader._readRequests.forEach(function(readRequest) {
      readRequest._closeSteps();
    });
    reader._readRequests = new SimpleQueue();
  }
}
function ReadableStreamError(stream, e) {
  stream._state = "errored";
  stream._storedError = e;
  var reader = stream._reader;
  if (reader === void 0) {
    return;
  }
  defaultReaderClosedPromiseReject(reader, e);
  if (IsReadableStreamDefaultReader(reader)) {
    reader._readRequests.forEach(function(readRequest) {
      readRequest._errorSteps(e);
    });
    reader._readRequests = new SimpleQueue();
  } else {
    reader._readIntoRequests.forEach(function(readIntoRequest) {
      readIntoRequest._errorSteps(e);
    });
    reader._readIntoRequests = new SimpleQueue();
  }
}
function streamBrandCheckException$1(name5) {
  return new TypeError("ReadableStream.prototype." + name5 + " can only be used on a ReadableStream");
}
function convertQueuingStrategyInit(init, context) {
  assertDictionary(init, context);
  var highWaterMark = init === null || init === void 0 ? void 0 : init.highWaterMark;
  assertRequiredField(highWaterMark, "highWaterMark", "QueuingStrategyInit");
  return {
    highWaterMark: convertUnrestrictedDouble(highWaterMark)
  };
}
function byteLengthBrandCheckException(name5) {
  return new TypeError("ByteLengthQueuingStrategy.prototype." + name5 + " can only be used on a ByteLengthQueuingStrategy");
}
function IsByteLengthQueuingStrategy(x) {
  if (!typeIsObject(x)) {
    return false;
  }
  if (!Object.prototype.hasOwnProperty.call(x, "_byteLengthQueuingStrategyHighWaterMark")) {
    return false;
  }
  return x instanceof ByteLengthQueuingStrategy;
}
function countBrandCheckException(name5) {
  return new TypeError("CountQueuingStrategy.prototype." + name5 + " can only be used on a CountQueuingStrategy");
}
function IsCountQueuingStrategy(x) {
  if (!typeIsObject(x)) {
    return false;
  }
  if (!Object.prototype.hasOwnProperty.call(x, "_countQueuingStrategyHighWaterMark")) {
    return false;
  }
  return x instanceof CountQueuingStrategy;
}
function convertTransformer(original, context) {
  assertDictionary(original, context);
  var flush2 = original === null || original === void 0 ? void 0 : original.flush;
  var readableType = original === null || original === void 0 ? void 0 : original.readableType;
  var start = original === null || original === void 0 ? void 0 : original.start;
  var transform2 = original === null || original === void 0 ? void 0 : original.transform;
  var writableType = original === null || original === void 0 ? void 0 : original.writableType;
  return {
    flush: flush2 === void 0 ? void 0 : convertTransformerFlushCallback(flush2, original, context + " has member 'flush' that"),
    readableType,
    start: start === void 0 ? void 0 : convertTransformerStartCallback(start, original, context + " has member 'start' that"),
    transform: transform2 === void 0 ? void 0 : convertTransformerTransformCallback(transform2, original, context + " has member 'transform' that"),
    writableType
  };
}
function convertTransformerFlushCallback(fn, original, context) {
  assertFunction(fn, context);
  return function(controller) {
    return promiseCall(fn, original, [controller]);
  };
}
function convertTransformerStartCallback(fn, original, context) {
  assertFunction(fn, context);
  return function(controller) {
    return reflectCall(fn, original, [controller]);
  };
}
function convertTransformerTransformCallback(fn, original, context) {
  assertFunction(fn, context);
  return function(chunk, controller) {
    return promiseCall(fn, original, [chunk, controller]);
  };
}
function InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark2, readableSizeAlgorithm) {
  function startAlgorithm() {
    return startPromise;
  }
  function writeAlgorithm(chunk) {
    return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);
  }
  function abortAlgorithm(reason) {
    return TransformStreamDefaultSinkAbortAlgorithm(stream, reason);
  }
  function closeAlgorithm() {
    return TransformStreamDefaultSinkCloseAlgorithm(stream);
  }
  stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, writableHighWaterMark, writableSizeAlgorithm);
  function pullAlgorithm() {
    return TransformStreamDefaultSourcePullAlgorithm(stream);
  }
  function cancelAlgorithm(reason) {
    TransformStreamErrorWritableAndUnblockWrite(stream, reason);
    return promiseResolvedWith(void 0);
  }
  stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark2, readableSizeAlgorithm);
  stream._backpressure = void 0;
  stream._backpressureChangePromise = void 0;
  stream._backpressureChangePromise_resolve = void 0;
  TransformStreamSetBackpressure(stream, true);
  stream._transformStreamController = void 0;
}
function IsTransformStream(x) {
  if (!typeIsObject(x)) {
    return false;
  }
  if (!Object.prototype.hasOwnProperty.call(x, "_transformStreamController")) {
    return false;
  }
  return x instanceof TransformStream;
}
function TransformStreamError(stream, e) {
  ReadableStreamDefaultControllerError(stream._readable._readableStreamController, e);
  TransformStreamErrorWritableAndUnblockWrite(stream, e);
}
function TransformStreamErrorWritableAndUnblockWrite(stream, e) {
  TransformStreamDefaultControllerClearAlgorithms(stream._transformStreamController);
  WritableStreamDefaultControllerErrorIfNeeded(stream._writable._writableStreamController, e);
  if (stream._backpressure) {
    TransformStreamSetBackpressure(stream, false);
  }
}
function TransformStreamSetBackpressure(stream, backpressure) {
  if (stream._backpressureChangePromise !== void 0) {
    stream._backpressureChangePromise_resolve();
  }
  stream._backpressureChangePromise = newPromise(function(resolve) {
    stream._backpressureChangePromise_resolve = resolve;
  });
  stream._backpressure = backpressure;
}
function IsTransformStreamDefaultController(x) {
  if (!typeIsObject(x)) {
    return false;
  }
  if (!Object.prototype.hasOwnProperty.call(x, "_controlledTransformStream")) {
    return false;
  }
  return x instanceof TransformStreamDefaultController;
}
function SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm) {
  controller._controlledTransformStream = stream;
  stream._transformStreamController = controller;
  controller._transformAlgorithm = transformAlgorithm;
  controller._flushAlgorithm = flushAlgorithm;
}
function SetUpTransformStreamDefaultControllerFromTransformer(stream, transformer) {
  var controller = Object.create(TransformStreamDefaultController.prototype);
  var transformAlgorithm = function(chunk) {
    try {
      TransformStreamDefaultControllerEnqueue(controller, chunk);
      return promiseResolvedWith(void 0);
    } catch (transformResultE) {
      return promiseRejectedWith(transformResultE);
    }
  };
  var flushAlgorithm = function() {
    return promiseResolvedWith(void 0);
  };
  if (transformer.transform !== void 0) {
    transformAlgorithm = function(chunk) {
      return transformer.transform(chunk, controller);
    };
  }
  if (transformer.flush !== void 0) {
    flushAlgorithm = function() {
      return transformer.flush(controller);
    };
  }
  SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm);
}
function TransformStreamDefaultControllerClearAlgorithms(controller) {
  controller._transformAlgorithm = void 0;
  controller._flushAlgorithm = void 0;
}
function TransformStreamDefaultControllerEnqueue(controller, chunk) {
  var stream = controller._controlledTransformStream;
  var readableController = stream._readable._readableStreamController;
  if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController)) {
    throw new TypeError("Readable side is not in a state that permits enqueue");
  }
  try {
    ReadableStreamDefaultControllerEnqueue(readableController, chunk);
  } catch (e) {
    TransformStreamErrorWritableAndUnblockWrite(stream, e);
    throw stream._readable._storedError;
  }
  var backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);
  if (backpressure !== stream._backpressure) {
    TransformStreamSetBackpressure(stream, true);
  }
}
function TransformStreamDefaultControllerError(controller, e) {
  TransformStreamError(controller._controlledTransformStream, e);
}
function TransformStreamDefaultControllerPerformTransform(controller, chunk) {
  var transformPromise = controller._transformAlgorithm(chunk);
  return transformPromiseWith(transformPromise, void 0, function(r) {
    TransformStreamError(controller._controlledTransformStream, r);
    throw r;
  });
}
function TransformStreamDefaultControllerTerminate(controller) {
  var stream = controller._controlledTransformStream;
  var readableController = stream._readable._readableStreamController;
  ReadableStreamDefaultControllerClose(readableController);
  var error = new TypeError("TransformStream terminated");
  TransformStreamErrorWritableAndUnblockWrite(stream, error);
}
function TransformStreamDefaultSinkWriteAlgorithm(stream, chunk) {
  var controller = stream._transformStreamController;
  if (stream._backpressure) {
    var backpressureChangePromise = stream._backpressureChangePromise;
    return transformPromiseWith(backpressureChangePromise, function() {
      var writable = stream._writable;
      var state = writable._state;
      if (state === "erroring") {
        throw writable._storedError;
      }
      return TransformStreamDefaultControllerPerformTransform(controller, chunk);
    });
  }
  return TransformStreamDefaultControllerPerformTransform(controller, chunk);
}
function TransformStreamDefaultSinkAbortAlgorithm(stream, reason) {
  TransformStreamError(stream, reason);
  return promiseResolvedWith(void 0);
}
function TransformStreamDefaultSinkCloseAlgorithm(stream) {
  var readable = stream._readable;
  var controller = stream._transformStreamController;
  var flushPromise = controller._flushAlgorithm();
  TransformStreamDefaultControllerClearAlgorithms(controller);
  return transformPromiseWith(flushPromise, function() {
    if (readable._state === "errored") {
      throw readable._storedError;
    }
    ReadableStreamDefaultControllerClose(readable._readableStreamController);
  }, function(r) {
    TransformStreamError(stream, r);
    throw readable._storedError;
  });
}
function TransformStreamDefaultSourcePullAlgorithm(stream) {
  TransformStreamSetBackpressure(stream, false);
  return stream._backpressureChangePromise;
}
function defaultControllerBrandCheckException(name5) {
  return new TypeError("TransformStreamDefaultController.prototype." + name5 + " can only be used on a TransformStreamDefaultController");
}
function streamBrandCheckException(name5) {
  return new TypeError("TransformStream.prototype." + name5 + " can only be used on a TransformStream");
}
var SymbolPolyfill, globals, rethrowAssertionErrorRejection, originalPromise, originalPromiseThen, originalPromiseResolve, originalPromiseReject, queueMicrotask, QUEUE_MAX_ARRAY_SIZE, SimpleQueue, AbortSteps, ErrorSteps, CancelSteps, PullSteps, NumberIsFinite, MathTrunc, ReadableStreamDefaultReader, _a, AsyncIteratorPrototype, ReadableStreamAsyncIteratorImpl, ReadableStreamAsyncIteratorPrototype, NumberIsNaN, ReadableStreamBYOBRequest, ReadableByteStreamController, ReadableStreamBYOBReader, supportsAbortController, WritableStream, WritableStreamDefaultWriter, closeSentinel, WritableStreamDefaultController, NativeDOMException, DOMException$1, ReadableStreamDefaultController, ReadableStream, byteLengthSizeFunction, ByteLengthQueuingStrategy, countSizeFunction, CountQueuingStrategy, TransformStream, TransformStreamDefaultController;
var init_ponyfill = __esm({
  "../../node_modules/.pnpm/web-streams-polyfill@3.2.1/node_modules/web-streams-polyfill/dist/ponyfill.mjs"() {
    "use strict";
    SymbolPolyfill = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol : function(description) {
      return "Symbol(" + description + ")";
    };
    globals = getGlobals();
    rethrowAssertionErrorRejection = noop2;
    originalPromise = Promise;
    originalPromiseThen = Promise.prototype.then;
    originalPromiseResolve = Promise.resolve.bind(originalPromise);
    originalPromiseReject = Promise.reject.bind(originalPromise);
    queueMicrotask = function() {
      var globalQueueMicrotask = globals && globals.queueMicrotask;
      if (typeof globalQueueMicrotask === "function") {
        return globalQueueMicrotask;
      }
      var resolvedPromise = promiseResolvedWith(void 0);
      return function(fn) {
        return PerformPromiseThen(resolvedPromise, fn);
      };
    }();
    QUEUE_MAX_ARRAY_SIZE = 16384;
    SimpleQueue = /** @class */
    function() {
      function SimpleQueue2() {
        this._cursor = 0;
        this._size = 0;
        this._front = {
          _elements: [],
          _next: void 0
        };
        this._back = this._front;
        this._cursor = 0;
        this._size = 0;
      }
      Object.defineProperty(SimpleQueue2.prototype, "length", {
        get: function() {
          return this._size;
        },
        enumerable: false,
        configurable: true
      });
      SimpleQueue2.prototype.push = function(element) {
        var oldBack = this._back;
        var newBack = oldBack;
        if (oldBack._elements.length === QUEUE_MAX_ARRAY_SIZE - 1) {
          newBack = {
            _elements: [],
            _next: void 0
          };
        }
        oldBack._elements.push(element);
        if (newBack !== oldBack) {
          this._back = newBack;
          oldBack._next = newBack;
        }
        ++this._size;
      };
      SimpleQueue2.prototype.shift = function() {
        var oldFront = this._front;
        var newFront = oldFront;
        var oldCursor = this._cursor;
        var newCursor = oldCursor + 1;
        var elements = oldFront._elements;
        var element = elements[oldCursor];
        if (newCursor === QUEUE_MAX_ARRAY_SIZE) {
          newFront = oldFront._next;
          newCursor = 0;
        }
        --this._size;
        this._cursor = newCursor;
        if (oldFront !== newFront) {
          this._front = newFront;
        }
        elements[oldCursor] = void 0;
        return element;
      };
      SimpleQueue2.prototype.forEach = function(callback) {
        var i = this._cursor;
        var node = this._front;
        var elements = node._elements;
        while (i !== elements.length || node._next !== void 0) {
          if (i === elements.length) {
            node = node._next;
            elements = node._elements;
            i = 0;
            if (elements.length === 0) {
              break;
            }
          }
          callback(elements[i]);
          ++i;
        }
      };
      SimpleQueue2.prototype.peek = function() {
        var front = this._front;
        var cursor = this._cursor;
        return front._elements[cursor];
      };
      return SimpleQueue2;
    }();
    AbortSteps = SymbolPolyfill("[[AbortSteps]]");
    ErrorSteps = SymbolPolyfill("[[ErrorSteps]]");
    CancelSteps = SymbolPolyfill("[[CancelSteps]]");
    PullSteps = SymbolPolyfill("[[PullSteps]]");
    NumberIsFinite = Number.isFinite || function(x) {
      return typeof x === "number" && isFinite(x);
    };
    MathTrunc = Math.trunc || function(v) {
      return v < 0 ? Math.ceil(v) : Math.floor(v);
    };
    ReadableStreamDefaultReader = /** @class */
    function() {
      function ReadableStreamDefaultReader3(stream) {
        assertRequiredArgument(stream, 1, "ReadableStreamDefaultReader");
        assertReadableStream(stream, "First parameter");
        if (IsReadableStreamLocked(stream)) {
          throw new TypeError("This stream has already been locked for exclusive reading by another reader");
        }
        ReadableStreamReaderGenericInitialize(this, stream);
        this._readRequests = new SimpleQueue();
      }
      Object.defineProperty(ReadableStreamDefaultReader3.prototype, "closed", {
        /**
         * Returns a promise that will be fulfilled when the stream becomes closed,
         * or rejected if the stream ever errors or the reader's lock is released before the stream finishes closing.
         */
        get: function() {
          if (!IsReadableStreamDefaultReader(this)) {
            return promiseRejectedWith(defaultReaderBrandCheckException("closed"));
          }
          return this._closedPromise;
        },
        enumerable: false,
        configurable: true
      });
      ReadableStreamDefaultReader3.prototype.cancel = function(reason) {
        if (reason === void 0) {
          reason = void 0;
        }
        if (!IsReadableStreamDefaultReader(this)) {
          return promiseRejectedWith(defaultReaderBrandCheckException("cancel"));
        }
        if (this._ownerReadableStream === void 0) {
          return promiseRejectedWith(readerLockException("cancel"));
        }
        return ReadableStreamReaderGenericCancel(this, reason);
      };
      ReadableStreamDefaultReader3.prototype.read = function() {
        if (!IsReadableStreamDefaultReader(this)) {
          return promiseRejectedWith(defaultReaderBrandCheckException("read"));
        }
        if (this._ownerReadableStream === void 0) {
          return promiseRejectedWith(readerLockException("read from"));
        }
        var resolvePromise;
        var rejectPromise;
        var promise = newPromise(function(resolve, reject) {
          resolvePromise = resolve;
          rejectPromise = reject;
        });
        var readRequest = {
          _chunkSteps: function(chunk) {
            return resolvePromise({ value: chunk, done: false });
          },
          _closeSteps: function() {
            return resolvePromise({ value: void 0, done: true });
          },
          _errorSteps: function(e) {
            return rejectPromise(e);
          }
        };
        ReadableStreamDefaultReaderRead(this, readRequest);
        return promise;
      };
      ReadableStreamDefaultReader3.prototype.releaseLock = function() {
        if (!IsReadableStreamDefaultReader(this)) {
          throw defaultReaderBrandCheckException("releaseLock");
        }
        if (this._ownerReadableStream === void 0) {
          return;
        }
        if (this._readRequests.length > 0) {
          throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");
        }
        ReadableStreamReaderGenericRelease(this);
      };
      return ReadableStreamDefaultReader3;
    }();
    Object.defineProperties(ReadableStreamDefaultReader.prototype, {
      cancel: { enumerable: true },
      read: { enumerable: true },
      releaseLock: { enumerable: true },
      closed: { enumerable: true }
    });
    if (typeof SymbolPolyfill.toStringTag === "symbol") {
      Object.defineProperty(ReadableStreamDefaultReader.prototype, SymbolPolyfill.toStringTag, {
        value: "ReadableStreamDefaultReader",
        configurable: true
      });
    }
    if (typeof SymbolPolyfill.asyncIterator === "symbol") {
      AsyncIteratorPrototype = (_a = {}, // 25.1.3.1 %AsyncIteratorPrototype% [ @@asyncIterator ] ( )
      // https://tc39.github.io/ecma262/#sec-asynciteratorprototype-asynciterator
      _a[SymbolPolyfill.asyncIterator] = function() {
        return this;
      }, _a);
      Object.defineProperty(AsyncIteratorPrototype, SymbolPolyfill.asyncIterator, { enumerable: false });
    }
    ReadableStreamAsyncIteratorImpl = /** @class */
    function() {
      function ReadableStreamAsyncIteratorImpl2(reader, preventCancel) {
        this._ongoingPromise = void 0;
        this._isFinished = false;
        this._reader = reader;
        this._preventCancel = preventCancel;
      }
      ReadableStreamAsyncIteratorImpl2.prototype.next = function() {
        var _this = this;
        var nextSteps = function() {
          return _this._nextSteps();
        };
        this._ongoingPromise = this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, nextSteps, nextSteps) : nextSteps();
        return this._ongoingPromise;
      };
      ReadableStreamAsyncIteratorImpl2.prototype.return = function(value) {
        var _this = this;
        var returnSteps = function() {
          return _this._returnSteps(value);
        };
        return this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, returnSteps, returnSteps) : returnSteps();
      };
      ReadableStreamAsyncIteratorImpl2.prototype._nextSteps = function() {
        var _this = this;
        if (this._isFinished) {
          return Promise.resolve({ value: void 0, done: true });
        }
        var reader = this._reader;
        if (reader._ownerReadableStream === void 0) {
          return promiseRejectedWith(readerLockException("iterate"));
        }
        var resolvePromise;
        var rejectPromise;
        var promise = newPromise(function(resolve, reject) {
          resolvePromise = resolve;
          rejectPromise = reject;
        });
        var readRequest = {
          _chunkSteps: function(chunk) {
            _this._ongoingPromise = void 0;
            queueMicrotask(function() {
              return resolvePromise({ value: chunk, done: false });
            });
          },
          _closeSteps: function() {
            _this._ongoingPromise = void 0;
            _this._isFinished = true;
            ReadableStreamReaderGenericRelease(reader);
            resolvePromise({ value: void 0, done: true });
          },
          _errorSteps: function(reason) {
            _this._ongoingPromise = void 0;
            _this._isFinished = true;
            ReadableStreamReaderGenericRelease(reader);
            rejectPromise(reason);
          }
        };
        ReadableStreamDefaultReaderRead(reader, readRequest);
        return promise;
      };
      ReadableStreamAsyncIteratorImpl2.prototype._returnSteps = function(value) {
        if (this._isFinished) {
          return Promise.resolve({ value, done: true });
        }
        this._isFinished = true;
        var reader = this._reader;
        if (reader._ownerReadableStream === void 0) {
          return promiseRejectedWith(readerLockException("finish iterating"));
        }
        if (!this._preventCancel) {
          var result = ReadableStreamReaderGenericCancel(reader, value);
          ReadableStreamReaderGenericRelease(reader);
          return transformPromiseWith(result, function() {
            return { value, done: true };
          });
        }
        ReadableStreamReaderGenericRelease(reader);
        return promiseResolvedWith({ value, done: true });
      };
      return ReadableStreamAsyncIteratorImpl2;
    }();
    ReadableStreamAsyncIteratorPrototype = {
      next: function() {
        if (!IsReadableStreamAsyncIterator(this)) {
          return promiseRejectedWith(streamAsyncIteratorBrandCheckException("next"));
        }
        return this._asyncIteratorImpl.next();
      },
      return: function(value) {
        if (!IsReadableStreamAsyncIterator(this)) {
          return promiseRejectedWith(streamAsyncIteratorBrandCheckException("return"));
        }
        return this._asyncIteratorImpl.return(value);
      }
    };
    if (AsyncIteratorPrototype !== void 0) {
      Object.setPrototypeOf(ReadableStreamAsyncIteratorPrototype, AsyncIteratorPrototype);
    }
    NumberIsNaN = Number.isNaN || function(x) {
      return x !== x;
    };
    ReadableStreamBYOBRequest = /** @class */
    function() {
      function ReadableStreamBYOBRequest3() {
        throw new TypeError("Illegal constructor");
      }
      Object.defineProperty(ReadableStreamBYOBRequest3.prototype, "view", {
        /**
         * Returns the view for writing in to, or `null` if the BYOB request has already been responded to.
         */
        get: function() {
          if (!IsReadableStreamBYOBRequest(this)) {
            throw byobRequestBrandCheckException("view");
          }
          return this._view;
        },
        enumerable: false,
        configurable: true
      });
      ReadableStreamBYOBRequest3.prototype.respond = function(bytesWritten) {
        if (!IsReadableStreamBYOBRequest(this)) {
          throw byobRequestBrandCheckException("respond");
        }
        assertRequiredArgument(bytesWritten, 1, "respond");
        bytesWritten = convertUnsignedLongLongWithEnforceRange(bytesWritten, "First parameter");
        if (this._associatedReadableByteStreamController === void 0) {
          throw new TypeError("This BYOB request has been invalidated");
        }
        if (IsDetachedBuffer(this._view.buffer))
          ;
        ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);
      };
      ReadableStreamBYOBRequest3.prototype.respondWithNewView = function(view) {
        if (!IsReadableStreamBYOBRequest(this)) {
          throw byobRequestBrandCheckException("respondWithNewView");
        }
        assertRequiredArgument(view, 1, "respondWithNewView");
        if (!ArrayBuffer.isView(view)) {
          throw new TypeError("You can only respond with array buffer views");
        }
        if (this._associatedReadableByteStreamController === void 0) {
          throw new TypeError("This BYOB request has been invalidated");
        }
        if (IsDetachedBuffer(view.buffer))
          ;
        ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);
      };
      return ReadableStreamBYOBRequest3;
    }();
    Object.defineProperties(ReadableStreamBYOBRequest.prototype, {
      respond: { enumerable: true },
      respondWithNewView: { enumerable: true },
      view: { enumerable: true }
    });
    if (typeof SymbolPolyfill.toStringTag === "symbol") {
      Object.defineProperty(ReadableStreamBYOBRequest.prototype, SymbolPolyfill.toStringTag, {
        value: "ReadableStreamBYOBRequest",
        configurable: true
      });
    }
    ReadableByteStreamController = /** @class */
    function() {
      function ReadableByteStreamController3() {
        throw new TypeError("Illegal constructor");
      }
      Object.defineProperty(ReadableByteStreamController3.prototype, "byobRequest", {
        /**
         * Returns the current BYOB pull request, or `null` if there isn't one.
         */
        get: function() {
          if (!IsReadableByteStreamController(this)) {
            throw byteStreamControllerBrandCheckException("byobRequest");
          }
          return ReadableByteStreamControllerGetBYOBRequest(this);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ReadableByteStreamController3.prototype, "desiredSize", {
        /**
         * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is
         * over-full. An underlying byte source ought to use this information to determine when and how to apply backpressure.
         */
        get: function() {
          if (!IsReadableByteStreamController(this)) {
            throw byteStreamControllerBrandCheckException("desiredSize");
          }
          return ReadableByteStreamControllerGetDesiredSize(this);
        },
        enumerable: false,
        configurable: true
      });
      ReadableByteStreamController3.prototype.close = function() {
        if (!IsReadableByteStreamController(this)) {
          throw byteStreamControllerBrandCheckException("close");
        }
        if (this._closeRequested) {
          throw new TypeError("The stream has already been closed; do not close it again!");
        }
        var state = this._controlledReadableByteStream._state;
        if (state !== "readable") {
          throw new TypeError("The stream (in " + state + " state) is not in the readable state and cannot be closed");
        }
        ReadableByteStreamControllerClose(this);
      };
      ReadableByteStreamController3.prototype.enqueue = function(chunk) {
        if (!IsReadableByteStreamController(this)) {
          throw byteStreamControllerBrandCheckException("enqueue");
        }
        assertRequiredArgument(chunk, 1, "enqueue");
        if (!ArrayBuffer.isView(chunk)) {
          throw new TypeError("chunk must be an array buffer view");
        }
        if (chunk.byteLength === 0) {
          throw new TypeError("chunk must have non-zero byteLength");
        }
        if (chunk.buffer.byteLength === 0) {
          throw new TypeError("chunk's buffer must have non-zero byteLength");
        }
        if (this._closeRequested) {
          throw new TypeError("stream is closed or draining");
        }
        var state = this._controlledReadableByteStream._state;
        if (state !== "readable") {
          throw new TypeError("The stream (in " + state + " state) is not in the readable state and cannot be enqueued to");
        }
        ReadableByteStreamControllerEnqueue(this, chunk);
      };
      ReadableByteStreamController3.prototype.error = function(e) {
        if (e === void 0) {
          e = void 0;
        }
        if (!IsReadableByteStreamController(this)) {
          throw byteStreamControllerBrandCheckException("error");
        }
        ReadableByteStreamControllerError(this, e);
      };
      ReadableByteStreamController3.prototype[CancelSteps] = function(reason) {
        ReadableByteStreamControllerClearPendingPullIntos(this);
        ResetQueue(this);
        var result = this._cancelAlgorithm(reason);
        ReadableByteStreamControllerClearAlgorithms(this);
        return result;
      };
      ReadableByteStreamController3.prototype[PullSteps] = function(readRequest) {
        var stream = this._controlledReadableByteStream;
        if (this._queueTotalSize > 0) {
          var entry = this._queue.shift();
          this._queueTotalSize -= entry.byteLength;
          ReadableByteStreamControllerHandleQueueDrain(this);
          var view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);
          readRequest._chunkSteps(view);
          return;
        }
        var autoAllocateChunkSize = this._autoAllocateChunkSize;
        if (autoAllocateChunkSize !== void 0) {
          var buffer2 = void 0;
          try {
            buffer2 = new ArrayBuffer(autoAllocateChunkSize);
          } catch (bufferE) {
            readRequest._errorSteps(bufferE);
            return;
          }
          var pullIntoDescriptor = {
            buffer: buffer2,
            bufferByteLength: autoAllocateChunkSize,
            byteOffset: 0,
            byteLength: autoAllocateChunkSize,
            bytesFilled: 0,
            elementSize: 1,
            viewConstructor: Uint8Array,
            readerType: "default"
          };
          this._pendingPullIntos.push(pullIntoDescriptor);
        }
        ReadableStreamAddReadRequest(stream, readRequest);
        ReadableByteStreamControllerCallPullIfNeeded(this);
      };
      return ReadableByteStreamController3;
    }();
    Object.defineProperties(ReadableByteStreamController.prototype, {
      close: { enumerable: true },
      enqueue: { enumerable: true },
      error: { enumerable: true },
      byobRequest: { enumerable: true },
      desiredSize: { enumerable: true }
    });
    if (typeof SymbolPolyfill.toStringTag === "symbol") {
      Object.defineProperty(ReadableByteStreamController.prototype, SymbolPolyfill.toStringTag, {
        value: "ReadableByteStreamController",
        configurable: true
      });
    }
    ReadableStreamBYOBReader = /** @class */
    function() {
      function ReadableStreamBYOBReader3(stream) {
        assertRequiredArgument(stream, 1, "ReadableStreamBYOBReader");
        assertReadableStream(stream, "First parameter");
        if (IsReadableStreamLocked(stream)) {
          throw new TypeError("This stream has already been locked for exclusive reading by another reader");
        }
        if (!IsReadableByteStreamController(stream._readableStreamController)) {
          throw new TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source");
        }
        ReadableStreamReaderGenericInitialize(this, stream);
        this._readIntoRequests = new SimpleQueue();
      }
      Object.defineProperty(ReadableStreamBYOBReader3.prototype, "closed", {
        /**
         * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or
         * the reader's lock is released before the stream finishes closing.
         */
        get: function() {
          if (!IsReadableStreamBYOBReader(this)) {
            return promiseRejectedWith(byobReaderBrandCheckException("closed"));
          }
          return this._closedPromise;
        },
        enumerable: false,
        configurable: true
      });
      ReadableStreamBYOBReader3.prototype.cancel = function(reason) {
        if (reason === void 0) {
          reason = void 0;
        }
        if (!IsReadableStreamBYOBReader(this)) {
          return promiseRejectedWith(byobReaderBrandCheckException("cancel"));
        }
        if (this._ownerReadableStream === void 0) {
          return promiseRejectedWith(readerLockException("cancel"));
        }
        return ReadableStreamReaderGenericCancel(this, reason);
      };
      ReadableStreamBYOBReader3.prototype.read = function(view) {
        if (!IsReadableStreamBYOBReader(this)) {
          return promiseRejectedWith(byobReaderBrandCheckException("read"));
        }
        if (!ArrayBuffer.isView(view)) {
          return promiseRejectedWith(new TypeError("view must be an array buffer view"));
        }
        if (view.byteLength === 0) {
          return promiseRejectedWith(new TypeError("view must have non-zero byteLength"));
        }
        if (view.buffer.byteLength === 0) {
          return promiseRejectedWith(new TypeError("view's buffer must have non-zero byteLength"));
        }
        if (IsDetachedBuffer(view.buffer))
          ;
        if (this._ownerReadableStream === void 0) {
          return promiseRejectedWith(readerLockException("read from"));
        }
        var resolvePromise;
        var rejectPromise;
        var promise = newPromise(function(resolve, reject) {
          resolvePromise = resolve;
          rejectPromise = reject;
        });
        var readIntoRequest = {
          _chunkSteps: function(chunk) {
            return resolvePromise({ value: chunk, done: false });
          },
          _closeSteps: function(chunk) {
            return resolvePromise({ value: chunk, done: true });
          },
          _errorSteps: function(e) {
            return rejectPromise(e);
          }
        };
        ReadableStreamBYOBReaderRead(this, view, readIntoRequest);
        return promise;
      };
      ReadableStreamBYOBReader3.prototype.releaseLock = function() {
        if (!IsReadableStreamBYOBReader(this)) {
          throw byobReaderBrandCheckException("releaseLock");
        }
        if (this._ownerReadableStream === void 0) {
          return;
        }
        if (this._readIntoRequests.length > 0) {
          throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");
        }
        ReadableStreamReaderGenericRelease(this);
      };
      return ReadableStreamBYOBReader3;
    }();
    Object.defineProperties(ReadableStreamBYOBReader.prototype, {
      cancel: { enumerable: true },
      read: { enumerable: true },
      releaseLock: { enumerable: true },
      closed: { enumerable: true }
    });
    if (typeof SymbolPolyfill.toStringTag === "symbol") {
      Object.defineProperty(ReadableStreamBYOBReader.prototype, SymbolPolyfill.toStringTag, {
        value: "ReadableStreamBYOBReader",
        configurable: true
      });
    }
    supportsAbortController = typeof AbortController === "function";
    WritableStream = /** @class */
    function() {
      function WritableStream3(rawUnderlyingSink, rawStrategy) {
        if (rawUnderlyingSink === void 0) {
          rawUnderlyingSink = {};
        }
        if (rawStrategy === void 0) {
          rawStrategy = {};
        }
        if (rawUnderlyingSink === void 0) {
          rawUnderlyingSink = null;
        } else {
          assertObject(rawUnderlyingSink, "First parameter");
        }
        var strategy = convertQueuingStrategy(rawStrategy, "Second parameter");
        var underlyingSink = convertUnderlyingSink(rawUnderlyingSink, "First parameter");
        InitializeWritableStream(this);
        var type = underlyingSink.type;
        if (type !== void 0) {
          throw new RangeError("Invalid type is specified");
        }
        var sizeAlgorithm = ExtractSizeAlgorithm(strategy);
        var highWaterMark = ExtractHighWaterMark(strategy, 1);
        SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);
      }
      Object.defineProperty(WritableStream3.prototype, "locked", {
        /**
         * Returns whether or not the writable stream is locked to a writer.
         */
        get: function() {
          if (!IsWritableStream(this)) {
            throw streamBrandCheckException$2("locked");
          }
          return IsWritableStreamLocked(this);
        },
        enumerable: false,
        configurable: true
      });
      WritableStream3.prototype.abort = function(reason) {
        if (reason === void 0) {
          reason = void 0;
        }
        if (!IsWritableStream(this)) {
          return promiseRejectedWith(streamBrandCheckException$2("abort"));
        }
        if (IsWritableStreamLocked(this)) {
          return promiseRejectedWith(new TypeError("Cannot abort a stream that already has a writer"));
        }
        return WritableStreamAbort(this, reason);
      };
      WritableStream3.prototype.close = function() {
        if (!IsWritableStream(this)) {
          return promiseRejectedWith(streamBrandCheckException$2("close"));
        }
        if (IsWritableStreamLocked(this)) {
          return promiseRejectedWith(new TypeError("Cannot close a stream that already has a writer"));
        }
        if (WritableStreamCloseQueuedOrInFlight(this)) {
          return promiseRejectedWith(new TypeError("Cannot close an already-closing stream"));
        }
        return WritableStreamClose(this);
      };
      WritableStream3.prototype.getWriter = function() {
        if (!IsWritableStream(this)) {
          throw streamBrandCheckException$2("getWriter");
        }
        return AcquireWritableStreamDefaultWriter(this);
      };
      return WritableStream3;
    }();
    Object.defineProperties(WritableStream.prototype, {
      abort: { enumerable: true },
      close: { enumerable: true },
      getWriter: { enumerable: true },
      locked: { enumerable: true }
    });
    if (typeof SymbolPolyfill.toStringTag === "symbol") {
      Object.defineProperty(WritableStream.prototype, SymbolPolyfill.toStringTag, {
        value: "WritableStream",
        configurable: true
      });
    }
    WritableStreamDefaultWriter = /** @class */
    function() {
      function WritableStreamDefaultWriter3(stream) {
        assertRequiredArgument(stream, 1, "WritableStreamDefaultWriter");
        assertWritableStream(stream, "First parameter");
        if (IsWritableStreamLocked(stream)) {
          throw new TypeError("This stream has already been locked for exclusive writing by another writer");
        }
        this._ownerWritableStream = stream;
        stream._writer = this;
        var state = stream._state;
        if (state === "writable") {
          if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._backpressure) {
            defaultWriterReadyPromiseInitialize(this);
          } else {
            defaultWriterReadyPromiseInitializeAsResolved(this);
          }
          defaultWriterClosedPromiseInitialize(this);
        } else if (state === "erroring") {
          defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError);
          defaultWriterClosedPromiseInitialize(this);
        } else if (state === "closed") {
          defaultWriterReadyPromiseInitializeAsResolved(this);
          defaultWriterClosedPromiseInitializeAsResolved(this);
        } else {
          var storedError = stream._storedError;
          defaultWriterReadyPromiseInitializeAsRejected(this, storedError);
          defaultWriterClosedPromiseInitializeAsRejected(this, storedError);
        }
      }
      Object.defineProperty(WritableStreamDefaultWriter3.prototype, "closed", {
        /**
         * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or
         * the writer’s lock is released before the stream finishes closing.
         */
        get: function() {
          if (!IsWritableStreamDefaultWriter(this)) {
            return promiseRejectedWith(defaultWriterBrandCheckException("closed"));
          }
          return this._closedPromise;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(WritableStreamDefaultWriter3.prototype, "desiredSize", {
        /**
         * Returns the desired size to fill the stream’s internal queue. It can be negative, if the queue is over-full.
         * A producer can use this information to determine the right amount of data to write.
         *
         * It will be `null` if the stream cannot be successfully written to (due to either being errored, or having an abort
         * queued up). It will return zero if the stream is closed. And the getter will throw an exception if invoked when
         * the writer’s lock is released.
         */
        get: function() {
          if (!IsWritableStreamDefaultWriter(this)) {
            throw defaultWriterBrandCheckException("desiredSize");
          }
          if (this._ownerWritableStream === void 0) {
            throw defaultWriterLockException("desiredSize");
          }
          return WritableStreamDefaultWriterGetDesiredSize(this);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(WritableStreamDefaultWriter3.prototype, "ready", {
        /**
         * Returns a promise that will be fulfilled when the desired size to fill the stream’s internal queue transitions
         * from non-positive to positive, signaling that it is no longer applying backpressure. Once the desired size dips
         * back to zero or below, the getter will return a new promise that stays pending until the next transition.
         *
         * If the stream becomes errored or aborted, or the writer’s lock is released, the returned promise will become
         * rejected.
         */
        get: function() {
          if (!IsWritableStreamDefaultWriter(this)) {
            return promiseRejectedWith(defaultWriterBrandCheckException("ready"));
          }
          return this._readyPromise;
        },
        enumerable: false,
        configurable: true
      });
      WritableStreamDefaultWriter3.prototype.abort = function(reason) {
        if (reason === void 0) {
          reason = void 0;
        }
        if (!IsWritableStreamDefaultWriter(this)) {
          return promiseRejectedWith(defaultWriterBrandCheckException("abort"));
        }
        if (this._ownerWritableStream === void 0) {
          return promiseRejectedWith(defaultWriterLockException("abort"));
        }
        return WritableStreamDefaultWriterAbort(this, reason);
      };
      WritableStreamDefaultWriter3.prototype.close = function() {
        if (!IsWritableStreamDefaultWriter(this)) {
          return promiseRejectedWith(defaultWriterBrandCheckException("close"));
        }
        var stream = this._ownerWritableStream;
        if (stream === void 0) {
          return promiseRejectedWith(defaultWriterLockException("close"));
        }
        if (WritableStreamCloseQueuedOrInFlight(stream)) {
          return promiseRejectedWith(new TypeError("Cannot close an already-closing stream"));
        }
        return WritableStreamDefaultWriterClose(this);
      };
      WritableStreamDefaultWriter3.prototype.releaseLock = function() {
        if (!IsWritableStreamDefaultWriter(this)) {
          throw defaultWriterBrandCheckException("releaseLock");
        }
        var stream = this._ownerWritableStream;
        if (stream === void 0) {
          return;
        }
        WritableStreamDefaultWriterRelease(this);
      };
      WritableStreamDefaultWriter3.prototype.write = function(chunk) {
        if (chunk === void 0) {
          chunk = void 0;
        }
        if (!IsWritableStreamDefaultWriter(this)) {
          return promiseRejectedWith(defaultWriterBrandCheckException("write"));
        }
        if (this._ownerWritableStream === void 0) {
          return promiseRejectedWith(defaultWriterLockException("write to"));
        }
        return WritableStreamDefaultWriterWrite(this, chunk);
      };
      return WritableStreamDefaultWriter3;
    }();
    Object.defineProperties(WritableStreamDefaultWriter.prototype, {
      abort: { enumerable: true },
      close: { enumerable: true },
      releaseLock: { enumerable: true },
      write: { enumerable: true },
      closed: { enumerable: true },
      desiredSize: { enumerable: true },
      ready: { enumerable: true }
    });
    if (typeof SymbolPolyfill.toStringTag === "symbol") {
      Object.defineProperty(WritableStreamDefaultWriter.prototype, SymbolPolyfill.toStringTag, {
        value: "WritableStreamDefaultWriter",
        configurable: true
      });
    }
    closeSentinel = {};
    WritableStreamDefaultController = /** @class */
    function() {
      function WritableStreamDefaultController3() {
        throw new TypeError("Illegal constructor");
      }
      Object.defineProperty(WritableStreamDefaultController3.prototype, "abortReason", {
        /**
         * The reason which was passed to `WritableStream.abort(reason)` when the stream was aborted.
         *
         * @deprecated
         *  This property has been removed from the specification, see https://github.com/whatwg/streams/pull/1177.
         *  Use {@link WritableStreamDefaultController.signal}'s `reason` instead.
         */
        get: function() {
          if (!IsWritableStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException$2("abortReason");
          }
          return this._abortReason;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(WritableStreamDefaultController3.prototype, "signal", {
        /**
         * An `AbortSignal` that can be used to abort the pending write or close operation when the stream is aborted.
         */
        get: function() {
          if (!IsWritableStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException$2("signal");
          }
          if (this._abortController === void 0) {
            throw new TypeError("WritableStreamDefaultController.prototype.signal is not supported");
          }
          return this._abortController.signal;
        },
        enumerable: false,
        configurable: true
      });
      WritableStreamDefaultController3.prototype.error = function(e) {
        if (e === void 0) {
          e = void 0;
        }
        if (!IsWritableStreamDefaultController(this)) {
          throw defaultControllerBrandCheckException$2("error");
        }
        var state = this._controlledWritableStream._state;
        if (state !== "writable") {
          return;
        }
        WritableStreamDefaultControllerError(this, e);
      };
      WritableStreamDefaultController3.prototype[AbortSteps] = function(reason) {
        var result = this._abortAlgorithm(reason);
        WritableStreamDefaultControllerClearAlgorithms(this);
        return result;
      };
      WritableStreamDefaultController3.prototype[ErrorSteps] = function() {
        ResetQueue(this);
      };
      return WritableStreamDefaultController3;
    }();
    Object.defineProperties(WritableStreamDefaultController.prototype, {
      abortReason: { enumerable: true },
      signal: { enumerable: true },
      error: { enumerable: true }
    });
    if (typeof SymbolPolyfill.toStringTag === "symbol") {
      Object.defineProperty(WritableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
        value: "WritableStreamDefaultController",
        configurable: true
      });
    }
    NativeDOMException = typeof DOMException !== "undefined" ? DOMException : void 0;
    DOMException$1 = isDOMExceptionConstructor(NativeDOMException) ? NativeDOMException : createDOMExceptionPolyfill();
    ReadableStreamDefaultController = /** @class */
    function() {
      function ReadableStreamDefaultController3() {
        throw new TypeError("Illegal constructor");
      }
      Object.defineProperty(ReadableStreamDefaultController3.prototype, "desiredSize", {
        /**
         * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is
         * over-full. An underlying source ought to use this information to determine when and how to apply backpressure.
         */
        get: function() {
          if (!IsReadableStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException$1("desiredSize");
          }
          return ReadableStreamDefaultControllerGetDesiredSize(this);
        },
        enumerable: false,
        configurable: true
      });
      ReadableStreamDefaultController3.prototype.close = function() {
        if (!IsReadableStreamDefaultController(this)) {
          throw defaultControllerBrandCheckException$1("close");
        }
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
          throw new TypeError("The stream is not in a state that permits close");
        }
        ReadableStreamDefaultControllerClose(this);
      };
      ReadableStreamDefaultController3.prototype.enqueue = function(chunk) {
        if (chunk === void 0) {
          chunk = void 0;
        }
        if (!IsReadableStreamDefaultController(this)) {
          throw defaultControllerBrandCheckException$1("enqueue");
        }
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
          throw new TypeError("The stream is not in a state that permits enqueue");
        }
        return ReadableStreamDefaultControllerEnqueue(this, chunk);
      };
      ReadableStreamDefaultController3.prototype.error = function(e) {
        if (e === void 0) {
          e = void 0;
        }
        if (!IsReadableStreamDefaultController(this)) {
          throw defaultControllerBrandCheckException$1("error");
        }
        ReadableStreamDefaultControllerError(this, e);
      };
      ReadableStreamDefaultController3.prototype[CancelSteps] = function(reason) {
        ResetQueue(this);
        var result = this._cancelAlgorithm(reason);
        ReadableStreamDefaultControllerClearAlgorithms(this);
        return result;
      };
      ReadableStreamDefaultController3.prototype[PullSteps] = function(readRequest) {
        var stream = this._controlledReadableStream;
        if (this._queue.length > 0) {
          var chunk = DequeueValue(this);
          if (this._closeRequested && this._queue.length === 0) {
            ReadableStreamDefaultControllerClearAlgorithms(this);
            ReadableStreamClose(stream);
          } else {
            ReadableStreamDefaultControllerCallPullIfNeeded(this);
          }
          readRequest._chunkSteps(chunk);
        } else {
          ReadableStreamAddReadRequest(stream, readRequest);
          ReadableStreamDefaultControllerCallPullIfNeeded(this);
        }
      };
      return ReadableStreamDefaultController3;
    }();
    Object.defineProperties(ReadableStreamDefaultController.prototype, {
      close: { enumerable: true },
      enqueue: { enumerable: true },
      error: { enumerable: true },
      desiredSize: { enumerable: true }
    });
    if (typeof SymbolPolyfill.toStringTag === "symbol") {
      Object.defineProperty(ReadableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
        value: "ReadableStreamDefaultController",
        configurable: true
      });
    }
    ReadableStream = /** @class */
    function() {
      function ReadableStream3(rawUnderlyingSource, rawStrategy) {
        if (rawUnderlyingSource === void 0) {
          rawUnderlyingSource = {};
        }
        if (rawStrategy === void 0) {
          rawStrategy = {};
        }
        if (rawUnderlyingSource === void 0) {
          rawUnderlyingSource = null;
        } else {
          assertObject(rawUnderlyingSource, "First parameter");
        }
        var strategy = convertQueuingStrategy(rawStrategy, "Second parameter");
        var underlyingSource = convertUnderlyingDefaultOrByteSource(rawUnderlyingSource, "First parameter");
        InitializeReadableStream(this);
        if (underlyingSource.type === "bytes") {
          if (strategy.size !== void 0) {
            throw new RangeError("The strategy for a byte stream cannot have a size function");
          }
          var highWaterMark = ExtractHighWaterMark(strategy, 0);
          SetUpReadableByteStreamControllerFromUnderlyingSource(this, underlyingSource, highWaterMark);
        } else {
          var sizeAlgorithm = ExtractSizeAlgorithm(strategy);
          var highWaterMark = ExtractHighWaterMark(strategy, 1);
          SetUpReadableStreamDefaultControllerFromUnderlyingSource(this, underlyingSource, highWaterMark, sizeAlgorithm);
        }
      }
      Object.defineProperty(ReadableStream3.prototype, "locked", {
        /**
         * Whether or not the readable stream is locked to a {@link ReadableStreamDefaultReader | reader}.
         */
        get: function() {
          if (!IsReadableStream(this)) {
            throw streamBrandCheckException$1("locked");
          }
          return IsReadableStreamLocked(this);
        },
        enumerable: false,
        configurable: true
      });
      ReadableStream3.prototype.cancel = function(reason) {
        if (reason === void 0) {
          reason = void 0;
        }
        if (!IsReadableStream(this)) {
          return promiseRejectedWith(streamBrandCheckException$1("cancel"));
        }
        if (IsReadableStreamLocked(this)) {
          return promiseRejectedWith(new TypeError("Cannot cancel a stream that already has a reader"));
        }
        return ReadableStreamCancel(this, reason);
      };
      ReadableStream3.prototype.getReader = function(rawOptions) {
        if (rawOptions === void 0) {
          rawOptions = void 0;
        }
        if (!IsReadableStream(this)) {
          throw streamBrandCheckException$1("getReader");
        }
        var options = convertReaderOptions(rawOptions, "First parameter");
        if (options.mode === void 0) {
          return AcquireReadableStreamDefaultReader(this);
        }
        return AcquireReadableStreamBYOBReader(this);
      };
      ReadableStream3.prototype.pipeThrough = function(rawTransform, rawOptions) {
        if (rawOptions === void 0) {
          rawOptions = {};
        }
        if (!IsReadableStream(this)) {
          throw streamBrandCheckException$1("pipeThrough");
        }
        assertRequiredArgument(rawTransform, 1, "pipeThrough");
        var transform2 = convertReadableWritablePair(rawTransform, "First parameter");
        var options = convertPipeOptions(rawOptions, "Second parameter");
        if (IsReadableStreamLocked(this)) {
          throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream");
        }
        if (IsWritableStreamLocked(transform2.writable)) {
          throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream");
        }
        var promise = ReadableStreamPipeTo(this, transform2.writable, options.preventClose, options.preventAbort, options.preventCancel, options.signal);
        setPromiseIsHandledToTrue(promise);
        return transform2.readable;
      };
      ReadableStream3.prototype.pipeTo = function(destination, rawOptions) {
        if (rawOptions === void 0) {
          rawOptions = {};
        }
        if (!IsReadableStream(this)) {
          return promiseRejectedWith(streamBrandCheckException$1("pipeTo"));
        }
        if (destination === void 0) {
          return promiseRejectedWith("Parameter 1 is required in 'pipeTo'.");
        }
        if (!IsWritableStream(destination)) {
          return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo's first argument must be a WritableStream"));
        }
        var options;
        try {
          options = convertPipeOptions(rawOptions, "Second parameter");
        } catch (e) {
          return promiseRejectedWith(e);
        }
        if (IsReadableStreamLocked(this)) {
          return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream"));
        }
        if (IsWritableStreamLocked(destination)) {
          return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream"));
        }
        return ReadableStreamPipeTo(this, destination, options.preventClose, options.preventAbort, options.preventCancel, options.signal);
      };
      ReadableStream3.prototype.tee = function() {
        if (!IsReadableStream(this)) {
          throw streamBrandCheckException$1("tee");
        }
        var branches = ReadableStreamTee(this);
        return CreateArrayFromList(branches);
      };
      ReadableStream3.prototype.values = function(rawOptions) {
        if (rawOptions === void 0) {
          rawOptions = void 0;
        }
        if (!IsReadableStream(this)) {
          throw streamBrandCheckException$1("values");
        }
        var options = convertIteratorOptions(rawOptions, "First parameter");
        return AcquireReadableStreamAsyncIterator(this, options.preventCancel);
      };
      return ReadableStream3;
    }();
    Object.defineProperties(ReadableStream.prototype, {
      cancel: { enumerable: true },
      getReader: { enumerable: true },
      pipeThrough: { enumerable: true },
      pipeTo: { enumerable: true },
      tee: { enumerable: true },
      values: { enumerable: true },
      locked: { enumerable: true }
    });
    if (typeof SymbolPolyfill.toStringTag === "symbol") {
      Object.defineProperty(ReadableStream.prototype, SymbolPolyfill.toStringTag, {
        value: "ReadableStream",
        configurable: true
      });
    }
    if (typeof SymbolPolyfill.asyncIterator === "symbol") {
      Object.defineProperty(ReadableStream.prototype, SymbolPolyfill.asyncIterator, {
        value: ReadableStream.prototype.values,
        writable: true,
        configurable: true
      });
    }
    byteLengthSizeFunction = function(chunk) {
      return chunk.byteLength;
    };
    try {
      Object.defineProperty(byteLengthSizeFunction, "name", {
        value: "size",
        configurable: true
      });
    } catch (_a2) {
    }
    ByteLengthQueuingStrategy = /** @class */
    function() {
      function ByteLengthQueuingStrategy3(options) {
        assertRequiredArgument(options, 1, "ByteLengthQueuingStrategy");
        options = convertQueuingStrategyInit(options, "First parameter");
        this._byteLengthQueuingStrategyHighWaterMark = options.highWaterMark;
      }
      Object.defineProperty(ByteLengthQueuingStrategy3.prototype, "highWaterMark", {
        /**
         * Returns the high water mark provided to the constructor.
         */
        get: function() {
          if (!IsByteLengthQueuingStrategy(this)) {
            throw byteLengthBrandCheckException("highWaterMark");
          }
          return this._byteLengthQueuingStrategyHighWaterMark;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ByteLengthQueuingStrategy3.prototype, "size", {
        /**
         * Measures the size of `chunk` by returning the value of its `byteLength` property.
         */
        get: function() {
          if (!IsByteLengthQueuingStrategy(this)) {
            throw byteLengthBrandCheckException("size");
          }
          return byteLengthSizeFunction;
        },
        enumerable: false,
        configurable: true
      });
      return ByteLengthQueuingStrategy3;
    }();
    Object.defineProperties(ByteLengthQueuingStrategy.prototype, {
      highWaterMark: { enumerable: true },
      size: { enumerable: true }
    });
    if (typeof SymbolPolyfill.toStringTag === "symbol") {
      Object.defineProperty(ByteLengthQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {
        value: "ByteLengthQueuingStrategy",
        configurable: true
      });
    }
    countSizeFunction = function() {
      return 1;
    };
    try {
      Object.defineProperty(countSizeFunction, "name", {
        value: "size",
        configurable: true
      });
    } catch (_a2) {
    }
    CountQueuingStrategy = /** @class */
    function() {
      function CountQueuingStrategy3(options) {
        assertRequiredArgument(options, 1, "CountQueuingStrategy");
        options = convertQueuingStrategyInit(options, "First parameter");
        this._countQueuingStrategyHighWaterMark = options.highWaterMark;
      }
      Object.defineProperty(CountQueuingStrategy3.prototype, "highWaterMark", {
        /**
         * Returns the high water mark provided to the constructor.
         */
        get: function() {
          if (!IsCountQueuingStrategy(this)) {
            throw countBrandCheckException("highWaterMark");
          }
          return this._countQueuingStrategyHighWaterMark;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(CountQueuingStrategy3.prototype, "size", {
        /**
         * Measures the size of `chunk` by always returning 1.
         * This ensures that the total queue size is a count of the number of chunks in the queue.
         */
        get: function() {
          if (!IsCountQueuingStrategy(this)) {
            throw countBrandCheckException("size");
          }
          return countSizeFunction;
        },
        enumerable: false,
        configurable: true
      });
      return CountQueuingStrategy3;
    }();
    Object.defineProperties(CountQueuingStrategy.prototype, {
      highWaterMark: { enumerable: true },
      size: { enumerable: true }
    });
    if (typeof SymbolPolyfill.toStringTag === "symbol") {
      Object.defineProperty(CountQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {
        value: "CountQueuingStrategy",
        configurable: true
      });
    }
    TransformStream = /** @class */
    function() {
      function TransformStream3(rawTransformer, rawWritableStrategy, rawReadableStrategy) {
        if (rawTransformer === void 0) {
          rawTransformer = {};
        }
        if (rawWritableStrategy === void 0) {
          rawWritableStrategy = {};
        }
        if (rawReadableStrategy === void 0) {
          rawReadableStrategy = {};
        }
        if (rawTransformer === void 0) {
          rawTransformer = null;
        }
        var writableStrategy = convertQueuingStrategy(rawWritableStrategy, "Second parameter");
        var readableStrategy = convertQueuingStrategy(rawReadableStrategy, "Third parameter");
        var transformer = convertTransformer(rawTransformer, "First parameter");
        if (transformer.readableType !== void 0) {
          throw new RangeError("Invalid readableType specified");
        }
        if (transformer.writableType !== void 0) {
          throw new RangeError("Invalid writableType specified");
        }
        var readableHighWaterMark2 = ExtractHighWaterMark(readableStrategy, 0);
        var readableSizeAlgorithm = ExtractSizeAlgorithm(readableStrategy);
        var writableHighWaterMark = ExtractHighWaterMark(writableStrategy, 1);
        var writableSizeAlgorithm = ExtractSizeAlgorithm(writableStrategy);
        var startPromise_resolve;
        var startPromise = newPromise(function(resolve) {
          startPromise_resolve = resolve;
        });
        InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark2, readableSizeAlgorithm);
        SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);
        if (transformer.start !== void 0) {
          startPromise_resolve(transformer.start(this._transformStreamController));
        } else {
          startPromise_resolve(void 0);
        }
      }
      Object.defineProperty(TransformStream3.prototype, "readable", {
        /**
         * The readable side of the transform stream.
         */
        get: function() {
          if (!IsTransformStream(this)) {
            throw streamBrandCheckException("readable");
          }
          return this._readable;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TransformStream3.prototype, "writable", {
        /**
         * The writable side of the transform stream.
         */
        get: function() {
          if (!IsTransformStream(this)) {
            throw streamBrandCheckException("writable");
          }
          return this._writable;
        },
        enumerable: false,
        configurable: true
      });
      return TransformStream3;
    }();
    Object.defineProperties(TransformStream.prototype, {
      readable: { enumerable: true },
      writable: { enumerable: true }
    });
    if (typeof SymbolPolyfill.toStringTag === "symbol") {
      Object.defineProperty(TransformStream.prototype, SymbolPolyfill.toStringTag, {
        value: "TransformStream",
        configurable: true
      });
    }
    TransformStreamDefaultController = /** @class */
    function() {
      function TransformStreamDefaultController3() {
        throw new TypeError("Illegal constructor");
      }
      Object.defineProperty(TransformStreamDefaultController3.prototype, "desiredSize", {
        /**
         * Returns the desired size to fill the readable side’s internal queue. It can be negative, if the queue is over-full.
         */
        get: function() {
          if (!IsTransformStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException("desiredSize");
          }
          var readableController = this._controlledTransformStream._readable._readableStreamController;
          return ReadableStreamDefaultControllerGetDesiredSize(readableController);
        },
        enumerable: false,
        configurable: true
      });
      TransformStreamDefaultController3.prototype.enqueue = function(chunk) {
        if (chunk === void 0) {
          chunk = void 0;
        }
        if (!IsTransformStreamDefaultController(this)) {
          throw defaultControllerBrandCheckException("enqueue");
        }
        TransformStreamDefaultControllerEnqueue(this, chunk);
      };
      TransformStreamDefaultController3.prototype.error = function(reason) {
        if (reason === void 0) {
          reason = void 0;
        }
        if (!IsTransformStreamDefaultController(this)) {
          throw defaultControllerBrandCheckException("error");
        }
        TransformStreamDefaultControllerError(this, reason);
      };
      TransformStreamDefaultController3.prototype.terminate = function() {
        if (!IsTransformStreamDefaultController(this)) {
          throw defaultControllerBrandCheckException("terminate");
        }
        TransformStreamDefaultControllerTerminate(this);
      };
      return TransformStreamDefaultController3;
    }();
    Object.defineProperties(TransformStreamDefaultController.prototype, {
      enqueue: { enumerable: true },
      error: { enumerable: true },
      terminate: { enumerable: true },
      desiredSize: { enumerable: true }
    });
    if (typeof SymbolPolyfill.toStringTag === "symbol") {
      Object.defineProperty(TransformStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
        value: "TransformStreamDefaultController",
        configurable: true
      });
    }
  }
});

// ../../node_modules/.pnpm/@web-std+stream@1.0.0/node_modules/@web-std/stream/src/stream.cjs
var require_stream = __commonJS({
  "../../node_modules/.pnpm/@web-std+stream@1.0.0/node_modules/@web-std/stream/src/stream.cjs"(exports2, module2) {
    "use strict";
    try {
      module2.exports = __require("stream/web");
    } catch (error) {
      module2.exports = (init_ponyfill(), __toCommonJS(ponyfill_exports));
    }
  }
});

// ../../node_modules/.pnpm/event-target-shim@5.0.1/node_modules/event-target-shim/dist/event-target-shim.js
var require_event_target_shim = __commonJS({
  "../../node_modules/.pnpm/event-target-shim@5.0.1/node_modules/event-target-shim/dist/event-target-shim.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var privateData = /* @__PURE__ */ new WeakMap();
    var wrappers = /* @__PURE__ */ new WeakMap();
    function pd(event) {
      const retv = privateData.get(event);
      console.assert(
        retv != null,
        "'this' is expected an Event object, but got",
        event
      );
      return retv;
    }
    function setCancelFlag(data) {
      if (data.passiveListener != null) {
        if (typeof console !== "undefined" && typeof console.error === "function") {
          console.error(
            "Unable to preventDefault inside passive event listener invocation.",
            data.passiveListener
          );
        }
        return;
      }
      if (!data.event.cancelable) {
        return;
      }
      data.canceled = true;
      if (typeof data.event.preventDefault === "function") {
        data.event.preventDefault();
      }
    }
    function Event(eventTarget, event) {
      privateData.set(this, {
        eventTarget,
        event,
        eventPhase: 2,
        currentTarget: eventTarget,
        canceled: false,
        stopped: false,
        immediateStopped: false,
        passiveListener: null,
        timeStamp: event.timeStamp || Date.now()
      });
      Object.defineProperty(this, "isTrusted", { value: false, enumerable: true });
      const keys = Object.keys(event);
      for (let i = 0; i < keys.length; ++i) {
        const key = keys[i];
        if (!(key in this)) {
          Object.defineProperty(this, key, defineRedirectDescriptor(key));
        }
      }
    }
    Event.prototype = {
      /**
       * The type of this event.
       * @type {string}
       */
      get type() {
        return pd(this).event.type;
      },
      /**
       * The target of this event.
       * @type {EventTarget}
       */
      get target() {
        return pd(this).eventTarget;
      },
      /**
       * The target of this event.
       * @type {EventTarget}
       */
      get currentTarget() {
        return pd(this).currentTarget;
      },
      /**
       * @returns {EventTarget[]} The composed path of this event.
       */
      composedPath() {
        const currentTarget = pd(this).currentTarget;
        if (currentTarget == null) {
          return [];
        }
        return [currentTarget];
      },
      /**
       * Constant of NONE.
       * @type {number}
       */
      get NONE() {
        return 0;
      },
      /**
       * Constant of CAPTURING_PHASE.
       * @type {number}
       */
      get CAPTURING_PHASE() {
        return 1;
      },
      /**
       * Constant of AT_TARGET.
       * @type {number}
       */
      get AT_TARGET() {
        return 2;
      },
      /**
       * Constant of BUBBLING_PHASE.
       * @type {number}
       */
      get BUBBLING_PHASE() {
        return 3;
      },
      /**
       * The target of this event.
       * @type {number}
       */
      get eventPhase() {
        return pd(this).eventPhase;
      },
      /**
       * Stop event bubbling.
       * @returns {void}
       */
      stopPropagation() {
        const data = pd(this);
        data.stopped = true;
        if (typeof data.event.stopPropagation === "function") {
          data.event.stopPropagation();
        }
      },
      /**
       * Stop event bubbling.
       * @returns {void}
       */
      stopImmediatePropagation() {
        const data = pd(this);
        data.stopped = true;
        data.immediateStopped = true;
        if (typeof data.event.stopImmediatePropagation === "function") {
          data.event.stopImmediatePropagation();
        }
      },
      /**
       * The flag to be bubbling.
       * @type {boolean}
       */
      get bubbles() {
        return Boolean(pd(this).event.bubbles);
      },
      /**
       * The flag to be cancelable.
       * @type {boolean}
       */
      get cancelable() {
        return Boolean(pd(this).event.cancelable);
      },
      /**
       * Cancel this event.
       * @returns {void}
       */
      preventDefault() {
        setCancelFlag(pd(this));
      },
      /**
       * The flag to indicate cancellation state.
       * @type {boolean}
       */
      get defaultPrevented() {
        return pd(this).canceled;
      },
      /**
       * The flag to be composed.
       * @type {boolean}
       */
      get composed() {
        return Boolean(pd(this).event.composed);
      },
      /**
       * The unix time of this event.
       * @type {number}
       */
      get timeStamp() {
        return pd(this).timeStamp;
      },
      /**
       * The target of this event.
       * @type {EventTarget}
       * @deprecated
       */
      get srcElement() {
        return pd(this).eventTarget;
      },
      /**
       * The flag to stop event bubbling.
       * @type {boolean}
       * @deprecated
       */
      get cancelBubble() {
        return pd(this).stopped;
      },
      set cancelBubble(value) {
        if (!value) {
          return;
        }
        const data = pd(this);
        data.stopped = true;
        if (typeof data.event.cancelBubble === "boolean") {
          data.event.cancelBubble = true;
        }
      },
      /**
       * The flag to indicate cancellation state.
       * @type {boolean}
       * @deprecated
       */
      get returnValue() {
        return !pd(this).canceled;
      },
      set returnValue(value) {
        if (!value) {
          setCancelFlag(pd(this));
        }
      },
      /**
       * Initialize this event object. But do nothing under event dispatching.
       * @param {string} type The event type.
       * @param {boolean} [bubbles=false] The flag to be possible to bubble up.
       * @param {boolean} [cancelable=false] The flag to be possible to cancel.
       * @deprecated
       */
      initEvent() {
      }
    };
    Object.defineProperty(Event.prototype, "constructor", {
      value: Event,
      configurable: true,
      writable: true
    });
    if (typeof window !== "undefined" && typeof window.Event !== "undefined") {
      Object.setPrototypeOf(Event.prototype, window.Event.prototype);
      wrappers.set(window.Event.prototype, Event);
    }
    function defineRedirectDescriptor(key) {
      return {
        get() {
          return pd(this).event[key];
        },
        set(value) {
          pd(this).event[key] = value;
        },
        configurable: true,
        enumerable: true
      };
    }
    function defineCallDescriptor(key) {
      return {
        value() {
          const event = pd(this).event;
          return event[key].apply(event, arguments);
        },
        configurable: true,
        enumerable: true
      };
    }
    function defineWrapper(BaseEvent, proto) {
      const keys = Object.keys(proto);
      if (keys.length === 0) {
        return BaseEvent;
      }
      function CustomEvent(eventTarget, event) {
        BaseEvent.call(this, eventTarget, event);
      }
      CustomEvent.prototype = Object.create(BaseEvent.prototype, {
        constructor: { value: CustomEvent, configurable: true, writable: true }
      });
      for (let i = 0; i < keys.length; ++i) {
        const key = keys[i];
        if (!(key in BaseEvent.prototype)) {
          const descriptor = Object.getOwnPropertyDescriptor(proto, key);
          const isFunc = typeof descriptor.value === "function";
          Object.defineProperty(
            CustomEvent.prototype,
            key,
            isFunc ? defineCallDescriptor(key) : defineRedirectDescriptor(key)
          );
        }
      }
      return CustomEvent;
    }
    function getWrapper(proto) {
      if (proto == null || proto === Object.prototype) {
        return Event;
      }
      let wrapper = wrappers.get(proto);
      if (wrapper == null) {
        wrapper = defineWrapper(getWrapper(Object.getPrototypeOf(proto)), proto);
        wrappers.set(proto, wrapper);
      }
      return wrapper;
    }
    function wrapEvent(eventTarget, event) {
      const Wrapper = getWrapper(Object.getPrototypeOf(event));
      return new Wrapper(eventTarget, event);
    }
    function isStopped(event) {
      return pd(event).immediateStopped;
    }
    function setEventPhase(event, eventPhase) {
      pd(event).eventPhase = eventPhase;
    }
    function setCurrentTarget(event, currentTarget) {
      pd(event).currentTarget = currentTarget;
    }
    function setPassiveListener(event, passiveListener) {
      pd(event).passiveListener = passiveListener;
    }
    var listenersMap = /* @__PURE__ */ new WeakMap();
    var CAPTURE = 1;
    var BUBBLE = 2;
    var ATTRIBUTE = 3;
    function isObject3(x) {
      return x !== null && typeof x === "object";
    }
    function getListeners(eventTarget) {
      const listeners = listenersMap.get(eventTarget);
      if (listeners == null) {
        throw new TypeError(
          "'this' is expected an EventTarget object, but got another value."
        );
      }
      return listeners;
    }
    function defineEventAttributeDescriptor(eventName) {
      return {
        get() {
          const listeners = getListeners(this);
          let node = listeners.get(eventName);
          while (node != null) {
            if (node.listenerType === ATTRIBUTE) {
              return node.listener;
            }
            node = node.next;
          }
          return null;
        },
        set(listener) {
          if (typeof listener !== "function" && !isObject3(listener)) {
            listener = null;
          }
          const listeners = getListeners(this);
          let prev = null;
          let node = listeners.get(eventName);
          while (node != null) {
            if (node.listenerType === ATTRIBUTE) {
              if (prev !== null) {
                prev.next = node.next;
              } else if (node.next !== null) {
                listeners.set(eventName, node.next);
              } else {
                listeners.delete(eventName);
              }
            } else {
              prev = node;
            }
            node = node.next;
          }
          if (listener !== null) {
            const newNode = {
              listener,
              listenerType: ATTRIBUTE,
              passive: false,
              once: false,
              next: null
            };
            if (prev === null) {
              listeners.set(eventName, newNode);
            } else {
              prev.next = newNode;
            }
          }
        },
        configurable: true,
        enumerable: true
      };
    }
    function defineEventAttribute(eventTargetPrototype, eventName) {
      Object.defineProperty(
        eventTargetPrototype,
        `on${eventName}`,
        defineEventAttributeDescriptor(eventName)
      );
    }
    function defineCustomEventTarget(eventNames) {
      function CustomEventTarget() {
        EventTarget.call(this);
      }
      CustomEventTarget.prototype = Object.create(EventTarget.prototype, {
        constructor: {
          value: CustomEventTarget,
          configurable: true,
          writable: true
        }
      });
      for (let i = 0; i < eventNames.length; ++i) {
        defineEventAttribute(CustomEventTarget.prototype, eventNames[i]);
      }
      return CustomEventTarget;
    }
    function EventTarget() {
      if (this instanceof EventTarget) {
        listenersMap.set(this, /* @__PURE__ */ new Map());
        return;
      }
      if (arguments.length === 1 && Array.isArray(arguments[0])) {
        return defineCustomEventTarget(arguments[0]);
      }
      if (arguments.length > 0) {
        const types4 = new Array(arguments.length);
        for (let i = 0; i < arguments.length; ++i) {
          types4[i] = arguments[i];
        }
        return defineCustomEventTarget(types4);
      }
      throw new TypeError("Cannot call a class as a function");
    }
    EventTarget.prototype = {
      /**
       * Add a given listener to this event target.
       * @param {string} eventName The event name to add.
       * @param {Function} listener The listener to add.
       * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.
       * @returns {void}
       */
      addEventListener(eventName, listener, options) {
        if (listener == null) {
          return;
        }
        if (typeof listener !== "function" && !isObject3(listener)) {
          throw new TypeError("'listener' should be a function or an object.");
        }
        const listeners = getListeners(this);
        const optionsIsObj = isObject3(options);
        const capture = optionsIsObj ? Boolean(options.capture) : Boolean(options);
        const listenerType = capture ? CAPTURE : BUBBLE;
        const newNode = {
          listener,
          listenerType,
          passive: optionsIsObj && Boolean(options.passive),
          once: optionsIsObj && Boolean(options.once),
          next: null
        };
        let node = listeners.get(eventName);
        if (node === void 0) {
          listeners.set(eventName, newNode);
          return;
        }
        let prev = null;
        while (node != null) {
          if (node.listener === listener && node.listenerType === listenerType) {
            return;
          }
          prev = node;
          node = node.next;
        }
        prev.next = newNode;
      },
      /**
       * Remove a given listener from this event target.
       * @param {string} eventName The event name to remove.
       * @param {Function} listener The listener to remove.
       * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.
       * @returns {void}
       */
      removeEventListener(eventName, listener, options) {
        if (listener == null) {
          return;
        }
        const listeners = getListeners(this);
        const capture = isObject3(options) ? Boolean(options.capture) : Boolean(options);
        const listenerType = capture ? CAPTURE : BUBBLE;
        let prev = null;
        let node = listeners.get(eventName);
        while (node != null) {
          if (node.listener === listener && node.listenerType === listenerType) {
            if (prev !== null) {
              prev.next = node.next;
            } else if (node.next !== null) {
              listeners.set(eventName, node.next);
            } else {
              listeners.delete(eventName);
            }
            return;
          }
          prev = node;
          node = node.next;
        }
      },
      /**
       * Dispatch a given event.
       * @param {Event|{type:string}} event The event to dispatch.
       * @returns {boolean} `false` if canceled.
       */
      dispatchEvent(event) {
        if (event == null || typeof event.type !== "string") {
          throw new TypeError('"event.type" should be a string.');
        }
        const listeners = getListeners(this);
        const eventName = event.type;
        let node = listeners.get(eventName);
        if (node == null) {
          return true;
        }
        const wrappedEvent = wrapEvent(this, event);
        let prev = null;
        while (node != null) {
          if (node.once) {
            if (prev !== null) {
              prev.next = node.next;
            } else if (node.next !== null) {
              listeners.set(eventName, node.next);
            } else {
              listeners.delete(eventName);
            }
          } else {
            prev = node;
          }
          setPassiveListener(
            wrappedEvent,
            node.passive ? node.listener : null
          );
          if (typeof node.listener === "function") {
            try {
              node.listener.call(this, wrappedEvent);
            } catch (err) {
              if (typeof console !== "undefined" && typeof console.error === "function") {
                console.error(err);
              }
            }
          } else if (node.listenerType !== ATTRIBUTE && typeof node.listener.handleEvent === "function") {
            node.listener.handleEvent(wrappedEvent);
          }
          if (isStopped(wrappedEvent)) {
            break;
          }
          node = node.next;
        }
        setPassiveListener(wrappedEvent, null);
        setEventPhase(wrappedEvent, 0);
        setCurrentTarget(wrappedEvent, null);
        return !wrappedEvent.defaultPrevented;
      }
    };
    Object.defineProperty(EventTarget.prototype, "constructor", {
      value: EventTarget,
      configurable: true,
      writable: true
    });
    if (typeof window !== "undefined" && typeof window.EventTarget !== "undefined") {
      Object.setPrototypeOf(EventTarget.prototype, window.EventTarget.prototype);
    }
    exports2.defineEventAttribute = defineEventAttribute;
    exports2.EventTarget = EventTarget;
    exports2.default = EventTarget;
    module2.exports = EventTarget;
    module2.exports.EventTarget = module2.exports["default"] = EventTarget;
    module2.exports.defineEventAttribute = defineEventAttribute;
  }
});

// ../../node_modules/.pnpm/abort-controller@3.0.0/node_modules/abort-controller/dist/abort-controller.js
var require_abort_controller = __commonJS({
  "../../node_modules/.pnpm/abort-controller@3.0.0/node_modules/abort-controller/dist/abort-controller.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var eventTargetShim = require_event_target_shim();
    var AbortSignal = class extends eventTargetShim.EventTarget {
      /**
       * AbortSignal cannot be constructed directly.
       */
      constructor() {
        super();
        throw new TypeError("AbortSignal cannot be constructed directly");
      }
      /**
       * Returns `true` if this `AbortSignal`'s `AbortController` has signaled to abort, and `false` otherwise.
       */
      get aborted() {
        const aborted = abortedFlags.get(this);
        if (typeof aborted !== "boolean") {
          throw new TypeError(`Expected 'this' to be an 'AbortSignal' object, but got ${this === null ? "null" : typeof this}`);
        }
        return aborted;
      }
    };
    eventTargetShim.defineEventAttribute(AbortSignal.prototype, "abort");
    function createAbortSignal() {
      const signal = Object.create(AbortSignal.prototype);
      eventTargetShim.EventTarget.call(signal);
      abortedFlags.set(signal, false);
      return signal;
    }
    function abortSignal(signal) {
      if (abortedFlags.get(signal) !== false) {
        return;
      }
      abortedFlags.set(signal, true);
      signal.dispatchEvent({ type: "abort" });
    }
    var abortedFlags = /* @__PURE__ */ new WeakMap();
    Object.defineProperties(AbortSignal.prototype, {
      aborted: { enumerable: true }
    });
    if (typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol") {
      Object.defineProperty(AbortSignal.prototype, Symbol.toStringTag, {
        configurable: true,
        value: "AbortSignal"
      });
    }
    var AbortController2 = class {
      /**
       * Initialize this controller.
       */
      constructor() {
        signals.set(this, createAbortSignal());
      }
      /**
       * Returns the `AbortSignal` object associated with this object.
       */
      get signal() {
        return getSignal(this);
      }
      /**
       * Abort and signal to any observers that the associated activity is to be aborted.
       */
      abort() {
        abortSignal(getSignal(this));
      }
    };
    var signals = /* @__PURE__ */ new WeakMap();
    function getSignal(controller) {
      const signal = signals.get(controller);
      if (signal == null) {
        throw new TypeError(`Expected 'this' to be an 'AbortController' object, but got ${controller === null ? "null" : typeof controller}`);
      }
      return signal;
    }
    Object.defineProperties(AbortController2.prototype, {
      signal: { enumerable: true },
      abort: { enumerable: true }
    });
    if (typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol") {
      Object.defineProperty(AbortController2.prototype, Symbol.toStringTag, {
        configurable: true,
        value: "AbortController"
      });
    }
    exports2.AbortController = AbortController2;
    exports2.AbortSignal = AbortSignal;
    exports2.default = AbortController2;
    module2.exports = AbortController2;
    module2.exports.AbortController = module2.exports["default"] = AbortController2;
    module2.exports.AbortSignal = AbortSignal;
  }
});

// src/metaplex/burn.ts
import { SplToken } from "@solana-suite/core";
var Metaplex;
((Metaplex10) => {
  const NFT_AMOUNT2 = 1;
  const NFT_DECIMALS = 0;
  Metaplex10.burn = (mint, owner, signer, feePayer) => {
    return SplToken.burn(
      mint,
      owner,
      [signer],
      NFT_AMOUNT2,
      NFT_DECIMALS,
      feePayer
    );
  };
})(Metaplex || (Metaplex = {}));

// ../internal/shared-metaplex/dist/index.mjs
import { convertTimestampToDateTime } from "@solana-suite/shared";
import { convertTimestampToDateTime as convertTimestampToDateTime2 } from "@solana-suite/shared";
import { overwriteObject } from "@solana-suite/shared";
import { PublicKey } from "@solana/web3.js";
import { PROGRAM_ID } from "@metaplex-foundation/mpl-token-metadata";
import { Try } from "@solana-suite/shared";
var __defProp2 = Object.defineProperty;
var __defProps2 = Object.defineProperties;
var __getOwnPropDescs2 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols2 = Object.getOwnPropertySymbols;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __propIsEnum2 = Object.prototype.propertyIsEnumerable;
var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues2 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp2.call(b, prop))
      __defNormalProp2(a, prop, b[prop]);
  if (__getOwnPropSymbols2)
    for (var prop of __getOwnPropSymbols2(b)) {
      if (__propIsEnum2.call(b, prop))
        __defNormalProp2(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps2 = (a, b) => __defProps2(a, __getOwnPropDescs2(b));
var __async2 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var Convert;
((Convert8) => {
  let Collection;
  ((Collection2) => {
    Collection2.intoInfraSide = (input) => {
      if (!input) {
        return null;
      }
      return {
        key: input.toPublicKey(),
        verified: false
      };
    };
    Collection2.intoUserSide = (output) => {
      if (!output) {
        return void 0;
      }
      return {
        address: output.key.toString(),
        verified: output.verified
      };
    };
  })(Collection = Convert8.Collection || (Convert8.Collection = {}));
})(Convert || (Convert = {}));
var Convert2;
((Convert8) => {
  let Creators;
  ((Creators2) => {
    Creators2.intoInfraSide = (input) => {
      if (!input) {
        return null;
      }
      return input.map((data) => {
        let modify = null;
        modify = {
          address: data.address.toPublicKey(),
          share: data.share,
          verified: data.verified
        };
        return modify;
      });
    };
    Creators2.intoUserSide = (output) => {
      if (!output) {
        return void 0;
      }
      return output.map((data) => {
        const modify = {
          address: data.address.toString(),
          share: data.share,
          verified: data.verified
        };
        return modify;
      });
    };
  })(Creators = Convert8.Creators || (Convert8.Creators = {}));
})(Convert2 || (Convert2 = {}));
var Convert3;
((Convert8) => {
  let Uses;
  ((Uses2) => {
    Uses2.intoUserSide = (output) => {
      if (!output) {
        return void 0;
      }
      return output;
    };
  })(Uses = Convert8.Uses || (Convert8.Uses = {}));
})(Convert3 || (Convert3 = {}));
var Convert4;
((Convert8) => {
  let TokenMetadata;
  ((TokenMetadata2) => {
    TokenMetadata2.intoInfraSide = (input, uri, sellerFeeBasisPoints) => {
      return {
        name: input.name,
        symbol: input.symbol,
        uri,
        sellerFeeBasisPoints,
        creators: Convert2.Creators.intoInfraSide(input.creators),
        collection: null,
        uses: input.uses || null
      };
    };
    TokenMetadata2.intoUserSide = (output, tokenAmount) => {
      return {
        mint: output.onchain.mint.toString(),
        royalty: output.onchain.data.sellerFeeBasisPoints,
        name: (0, TokenMetadata2.deleteNullStrings)(output.onchain.data.name),
        symbol: (0, TokenMetadata2.deleteNullStrings)(output.onchain.data.symbol),
        tokenAmount,
        uri: (0, TokenMetadata2.deleteNullStrings)(output.onchain.data.uri),
        creators: Convert2.Creators.intoUserSide(output.onchain.data.creators),
        uses: Convert3.Uses.intoUserSide(output.onchain.uses),
        dateTime: convertTimestampToDateTime(output.offchain.created_at),
        offchain: output.offchain
      };
    };
    TokenMetadata2.deleteNullStrings = (str) => {
      return str.replace(/\0/g, "");
    };
  })(TokenMetadata = Convert8.TokenMetadata || (Convert8.TokenMetadata = {}));
})(Convert4 || (Convert4 = {}));
var Convert5;
((Convert8) => {
  let NftMetadata;
  ((NftMetadata2) => {
    NftMetadata2.intoInfraSide = (input, uri, sellerFeeBasisPoints) => {
      return {
        name: input.name,
        symbol: input.symbol,
        uri,
        sellerFeeBasisPoints,
        creators: Convert2.Creators.intoInfraSide(input.creators),
        collection: Convert.Collection.intoInfraSide(input.collection),
        uses: input.uses || null
      };
    };
    NftMetadata2.intoUserSide = (output, tokenAmount) => {
      return {
        mint: output.onchain.mint.toString(),
        updateAuthority: output.onchain.updateAuthority.toString(),
        royalty: output.onchain.data.sellerFeeBasisPoints,
        name: Convert4.TokenMetadata.deleteNullStrings(output.onchain.data.name),
        symbol: Convert4.TokenMetadata.deleteNullStrings(
          output.onchain.data.symbol
        ),
        tokenAmount,
        uri: Convert4.TokenMetadata.deleteNullStrings(output.onchain.data.uri),
        isMutable: output.onchain.isMutable,
        primarySaleHappened: output.onchain.primarySaleHappened,
        creators: Convert2.Creators.intoUserSide(output.onchain.data.creators),
        editionNonce: output.onchain.editionNonce,
        collection: Convert.Collection.intoUserSide(
          output.onchain.collection
        ),
        uses: Convert3.Uses.intoUserSide(output.onchain.uses),
        dateTime: convertTimestampToDateTime2(output.offchain.created_at),
        offchain: output.offchain
      };
    };
  })(NftMetadata = Convert8.NftMetadata || (Convert8.NftMetadata = {}));
})(Convert5 || (Convert5 = {}));
var Convert6;
((Convert8) => {
  let Properties;
  ((Properties2) => {
    Properties2.intoInfraSide = (input, storageFunc, storageType, feePayer) => __async2(void 0, null, function* () {
      if (!input || !input.files) {
        return {};
      }
      const files = yield Promise.all(
        input.files.map((file) => __async2(void 0, null, function* () {
          if (!file.filePath) {
            return {};
          }
          const res = yield storageFunc(file.filePath, storageType, feePayer);
          if (res.isErr) {
            throw Error(res.error.message);
          }
          return overwriteObject(file, [
            {
              existsKey: "filePath",
              will: { key: "uri", value: res.value }
            }
          ]);
        }))
      );
      return __spreadProps2(__spreadValues2({}, input), { files });
    });
  })(Properties = Convert8.Properties || (Convert8.Properties = {}));
})(Convert6 || (Convert6 = {}));
var Convert7 = __spreadValues2(__spreadValues2(__spreadValues2(__spreadValues2(__spreadValues2(__spreadValues2({}, Convert), Convert2), Convert5), Convert6), Convert4), Convert3);
var UserSideInput;
((UserSideInput22) => {
  let TokenStandard;
  ((TokenStandard2) => {
    TokenStandard2[TokenStandard2["NonFungible"] = 0] = "NonFungible";
    TokenStandard2[TokenStandard2["FungibleAsset"] = 1] = "FungibleAsset";
    TokenStandard2[TokenStandard2["Fungible"] = 2] = "Fungible";
    TokenStandard2[TokenStandard2["NonFungibleEdition"] = 3] = "NonFungibleEdition";
    TokenStandard2[TokenStandard2["ProgrammableNonFungible"] = 4] = "ProgrammableNonFungible";
  })(TokenStandard = UserSideInput22.TokenStandard || (UserSideInput22.TokenStandard = {}));
})(UserSideInput || (UserSideInput = {}));
var _Shared;
((_Shared2) => {
  let UseMethod;
  ((UseMethod2) => {
    UseMethod2[UseMethod2["Burn"] = 0] = "Burn";
    UseMethod2[UseMethod2["Multiple"] = 1] = "Multiple";
    UseMethod2[UseMethod2["Single"] = 2] = "Single";
  })(UseMethod = _Shared2.UseMethod || (_Shared2.UseMethod = {}));
})(_Shared || (_Shared = {}));
var Pda;
((Pda2) => {
  Pda2.getMetadata = (mint) => {
    const [publicKey] = PublicKey.findProgramAddressSync(
      [Buffer.from("metadata"), PROGRAM_ID.toBuffer(), mint.toPublicKey().toBuffer()],
      PROGRAM_ID
    );
    return publicKey;
  };
  Pda2.getMasterEdition = (mint) => {
    const [publicKey] = PublicKey.findProgramAddressSync(
      [
        Buffer.from("metadata"),
        PROGRAM_ID.toBuffer(),
        mint.toPublicKey().toBuffer(),
        Buffer.from("edition")
      ],
      PROGRAM_ID
    );
    return publicKey;
  };
})(Pda || (Pda = {}));
var Royalty;
((Royalty2) => {
  Royalty2.THRESHOLD = 100;
  Royalty2.convert = (percentage) => {
    return percentage * Royalty2.THRESHOLD;
  };
})(Royalty || (Royalty = {}));
var Validator;
((Validator2) => {
  let Message;
  ((Message2) => {
    Message2.SUCCESS = "success";
    Message2.SMALL_NUMBER = "too small";
    Message2.BIG_NUMBER = "too big";
    Message2.LONG_LENGTH = "too long";
    Message2.EMPTY = "invalid empty value";
    Message2.INVALID_URL = "invalid url";
    Message2.ONLY_NODE_JS = "`string` type is only Node.js";
  })(Message = Validator2.Message || (Validator2.Message = {}));
  Validator2.NAME_LENGTH = 32;
  Validator2.SYMBOL_LENGTH = 10;
  Validator2.URL_LENGTH = 200;
  Validator2.ROYALTY_MAX = 100;
  Validator2.SELLER_FEE_BASIS_POINTS_MAX = 1e4;
  Validator2.ROYALTY_MIN = -1;
  Validator2.isRoyalty = (royalty) => {
    return Try(() => {
      const key = "royalty";
      if (royalty !== 0 && !royalty) {
        throw createError(key, Message.EMPTY, royalty);
      }
      if (royalty < Validator2.ROYALTY_MIN) {
        throw createError(key, Message.SMALL_NUMBER, royalty, {
          threshold: Validator2.ROYALTY_MIN,
          condition: "underMin"
        });
      } else if (royalty > Validator2.ROYALTY_MAX) {
        throw createError(key, Message.BIG_NUMBER, royalty, {
          threshold: Validator2.ROYALTY_MAX,
          condition: "overMax"
        });
      }
      return Message.SUCCESS;
    });
  };
  Validator2.isSellerFeeBasisPoints = (royalty) => {
    return Try(() => {
      const key = "sellerFeeBasisPoints/seller_fee_basis_points";
      if (royalty !== 0 && !royalty) {
        throw createError(key, Message.EMPTY, royalty);
      }
      if (royalty < Validator2.ROYALTY_MIN) {
        throw createError(key, Message.SMALL_NUMBER, royalty, {
          threshold: Validator2.ROYALTY_MIN,
          condition: "underMin"
        });
      } else if (royalty > Validator2.ROYALTY_MAX * Royalty.THRESHOLD) {
        throw createError(key, Message.BIG_NUMBER, royalty, {
          threshold: Validator2.SELLER_FEE_BASIS_POINTS_MAX,
          condition: "overMax"
        });
      }
      return Message.SUCCESS;
    });
  };
  Validator2.isName = (name5) => {
    return Try(() => {
      const key = "name";
      if (!name5) {
        throw createError(key, Message.EMPTY, name5);
      }
      if (byteLength(name5) > Validator2.NAME_LENGTH) {
        throw createError(key, Message.LONG_LENGTH, name5, {
          threshold: Validator2.NAME_LENGTH,
          condition: "overMax"
        });
      }
      return Message.SUCCESS;
    });
  };
  Validator2.isSymbol = (symbol) => {
    return Try(() => {
      const key = "symbol";
      if (!symbol) {
        throw createError(key, Message.EMPTY, symbol);
      }
      if (byteLength(symbol) > Validator2.SYMBOL_LENGTH) {
        throw createError(key, Message.LONG_LENGTH, symbol, {
          threshold: Validator2.SYMBOL_LENGTH,
          condition: "overMax"
        });
      }
      return Message.SUCCESS;
    });
  };
  Validator2.isImageUrl = (image) => isUriOrImage(image, "image");
  Validator2.checkAll = (metadata) => {
    return Try(() => {
      const keys = Object.keys(metadata);
      const results = [];
      keys.map((key) => {
        let res;
        switch (key) {
          case "image":
            if (key in metadata && metadata.image) {
              res = (0, Validator2.isImageUrl)(metadata.image);
            }
            break;
          case "royalty":
            if (key in metadata) {
              res = (0, Validator2.isRoyalty)(metadata.royalty);
            }
            break;
          case "seller_fee_basis_points":
            if (key in metadata && metadata.seller_fee_basis_points) {
              res = (0, Validator2.isSellerFeeBasisPoints)(metadata.seller_fee_basis_points);
            }
            break;
          case "sellerFeeBasisPoints":
            if (key in metadata) {
              res = (0, Validator2.isSellerFeeBasisPoints)(metadata.sellerFeeBasisPoints);
            }
            break;
          case "name":
            if (metadata.name) {
              res = (0, Validator2.isName)(metadata.name);
            }
            break;
          case "symbol":
            if (metadata.symbol) {
              res = (0, Validator2.isSymbol)(metadata.symbol);
            }
            break;
        }
        if (res && res.isErr) {
          results.push(...res.error.details);
        }
      });
      if (results.length > 0) {
        const message = "Caught in the validation errors. see information e.g: err<ValidatorError>.details";
        throw new ValidatorError(message, results);
      }
      return Message.SUCCESS;
    });
  };
  const byteLength = (value) => {
    const text = new TextEncoder();
    return text.encode(value).length;
  };
  const createError = (key, message, actual, limit) => {
    let error;
    if (limit) {
      error = new ValidatorError(message, [{ key, message, actual, limit }]);
    } else {
      error = new ValidatorError(message, [{ key, message, actual }]);
    }
    return error;
  };
  const isUriOrImage = (imageOrUri, key) => {
    return Try(() => {
      if (!imageOrUri) {
        throw createError(key, Message.EMPTY, imageOrUri);
      }
      if (byteLength(imageOrUri) > Validator2.URL_LENGTH) {
        throw createError(key, Message.LONG_LENGTH, imageOrUri, {
          threshold: Validator2.URL_LENGTH,
          condition: "overMax"
        });
      }
      if (!/https?:\/\/[-_.!~*\\()a-zA-Z0-9;?:&=+,%#]+/g.test(imageOrUri)) {
        throw createError(key, Message.INVALID_URL, imageOrUri);
      }
      return Message.SUCCESS;
    });
  };
})(Validator || (Validator = {}));
var ValidatorError = class extends Error {
  constructor(message, details) {
    super(message);
    this.details = details;
  }
};

// src/metaplex/find.ts
import { Sortable, SplToken as SplToken2 } from "@solana-suite/core";
var Metaplex2;
((Metaplex10) => {
  Metaplex10.findByOwner = (owner, onOk, onErr, options) => __async(void 0, null, function* () {
    const sortable = !(options == null ? void 0 : options.sortable) ? Sortable.Desc : options == null ? void 0 : options.sortable;
    const isHolder = !(options == null ? void 0 : options.isHolder) ? true : false;
    yield SplToken2.genericFindByOwner(
      owner,
      (result) => result.match(onOk, onErr),
      UserSideInput.TokenStandard.NonFungible,
      sortable,
      isHolder
    );
  });
  Metaplex10.findByMint = (mint) => __async(void 0, null, function* () {
    return yield SplToken2.genericFindByMint(
      mint,
      UserSideInput.TokenStandard.NonFungible
    );
  });
})(Metaplex2 || (Metaplex2 = {}));

// src/metaplex/freeze.ts
import {
  Instruction,
  KeypairAccount,
  Try as Try2
} from "@solana-suite/shared";
import { getAssociatedTokenAddressSync } from "@solana/spl-token";
import { createFreezeDelegatedAccountInstruction } from "@metaplex-foundation/mpl-token-metadata";
var Metaplex3;
((Metaplex10) => {
  Metaplex10.freeze = (mint, owner, freezeAuthority, feePayer) => {
    const payer = feePayer ? feePayer : freezeAuthority;
    return Try2(() => {
      const tokenAccount = getAssociatedTokenAddressSync(
        mint.toPublicKey(),
        owner.toPublicKey()
      );
      const editionAddress = Pda.getMasterEdition(mint);
      const inst = createFreezeDelegatedAccountInstruction({
        delegate: new KeypairAccount({ secret: freezeAuthority }).toPublicKey(),
        tokenAccount,
        edition: editionAddress,
        mint: mint.toPublicKey()
      });
      return new Instruction(
        [inst],
        [freezeAuthority.toKeypair()],
        payer.toKeypair()
      );
    });
  };
})(Metaplex3 || (Metaplex3 = {}));

// src/metaplex/fee-payer-partial-sign-mint.ts
import {
  debugLog as debugLog4,
  KeypairAccount as KeypairAccount3,
  Node as Node3,
  PartialSignInstruction,
  Try as Try5
} from "@solana-suite/shared";
import { Transaction } from "@solana/web3.js";

// ../internal/storage/dist/index.mjs
import {
  toMetaplexFile
} from "@metaplex-foundation/js";
import {
  debugLog,
  isBrowser,
  isNode,
  Try as Try3
} from "@solana-suite/shared";
import {
  Metaplex as MetaplexFoundation,
  keypairIdentity,
  bundlrStorage,
  walletAdapterIdentity
} from "@metaplex-foundation/js";
import { Node, Constants } from "@solana-suite/shared";

// ../../node_modules/.pnpm/streaming-iterables@6.2.0/node_modules/streaming-iterables/dist/index.mjs
var TIMEOUT = Symbol("TIMEOUT");
function getIterator(iterable) {
  if (typeof iterable.next === "function") {
    return iterable;
  }
  if (typeof iterable[Symbol.iterator] === "function") {
    return iterable[Symbol.iterator]();
  }
  if (typeof iterable[Symbol.asyncIterator] === "function") {
    return iterable[Symbol.asyncIterator]();
  }
  throw new TypeError('"values" does not to conform to any of the iterator or iterable protocols');
}
function defer() {
  let reject;
  let resolve;
  const promise = new Promise((resolveFunc, rejectFunc) => {
    resolve = resolveFunc;
    reject = rejectFunc;
  });
  return {
    promise,
    reject,
    resolve
  };
}
function _transform(concurrency, func, iterable) {
  const iterator = getIterator(iterable);
  const resultQueue = [];
  const readQueue = [];
  let ended = false;
  let reading = false;
  let inflightCount = 0;
  let lastError = null;
  function fulfillReadQueue() {
    while (readQueue.length > 0 && resultQueue.length > 0) {
      const { resolve } = readQueue.shift();
      const value = resultQueue.shift();
      resolve({ done: false, value });
    }
    while (readQueue.length > 0 && inflightCount === 0 && ended) {
      const { resolve, reject } = readQueue.shift();
      if (lastError) {
        reject(lastError);
        lastError = null;
      } else {
        resolve({ done: true, value: void 0 });
      }
    }
  }
  function fillQueue() {
    return __async(this, null, function* () {
      if (ended) {
        fulfillReadQueue();
        return;
      }
      if (reading) {
        return;
      }
      if (inflightCount + resultQueue.length >= concurrency) {
        return;
      }
      reading = true;
      inflightCount++;
      try {
        const { done, value } = yield iterator.next();
        if (done) {
          ended = true;
          inflightCount--;
          fulfillReadQueue();
        } else {
          mapAndQueue(value);
        }
      } catch (error) {
        ended = true;
        inflightCount--;
        lastError = error;
        fulfillReadQueue();
      }
      reading = false;
      fillQueue();
    });
  }
  function mapAndQueue(itrValue) {
    return __async(this, null, function* () {
      try {
        const value = yield func(itrValue);
        resultQueue.push(value);
      } catch (error) {
        ended = true;
        lastError = error;
      }
      inflightCount--;
      fulfillReadQueue();
      fillQueue();
    });
  }
  function next() {
    return __async(this, null, function* () {
      if (resultQueue.length === 0) {
        const deferred = defer();
        readQueue.push(deferred);
        fillQueue();
        return deferred.promise;
      }
      const value = resultQueue.shift();
      fillQueue();
      return { done: false, value };
    });
  }
  const asyncIterableIterator = {
    next,
    [Symbol.asyncIterator]: () => asyncIterableIterator
  };
  return asyncIterableIterator;
}
function transform(concurrency, func, iterable) {
  if (func === void 0) {
    return (curriedFunc, curriedIterable) => curriedIterable ? transform(concurrency, curriedFunc, curriedIterable) : transform(concurrency, curriedFunc);
  }
  if (iterable === void 0) {
    return (curriedIterable) => transform(concurrency, func, curriedIterable);
  }
  return _transform(concurrency, func, iterable);
}

// ../../node_modules/.pnpm/nft.storage@7.1.1_node-fetch@3.3.2/node_modules/nft.storage/src/lib.js
var import_p_retry = __toESM(require_p_retry(), 1);

// ../../node_modules/.pnpm/@ipld+car@3.2.4/node_modules/@ipld/car/esm/lib/reader.js
import fs from "fs";
import { promisify } from "util";

// ../../node_modules/.pnpm/@ipld+car@3.2.4/node_modules/@ipld/car/esm/lib/decoder.js
var import_varint2 = __toESM(require_varint(), 1);

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/vendor/varint.js
var encode_1 = encode;
var MSB = 128;
var REST = 127;
var MSBALL = ~REST;
var INT = Math.pow(2, 31);
function encode(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT) {
    out[offset++] = num & 255 | MSB;
    num /= 128;
  }
  while (num & MSBALL) {
    out[offset++] = num & 255 | MSB;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode.bytes = offset - oldOffset + 1;
  return out;
}
var decode = read;
var MSB$1 = 128;
var REST$1 = 127;
function read(buf2, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf2.length;
  do {
    if (counter >= l) {
      read.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf2[counter++];
    res += shift < 28 ? (b & REST$1) << shift : (b & REST$1) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$1);
  read.bytes = counter - offset;
  return res;
}
var N1 = Math.pow(2, 7);
var N2 = Math.pow(2, 14);
var N3 = Math.pow(2, 21);
var N4 = Math.pow(2, 28);
var N5 = Math.pow(2, 35);
var N6 = Math.pow(2, 42);
var N7 = Math.pow(2, 49);
var N8 = Math.pow(2, 56);
var N9 = Math.pow(2, 63);
var length = function(value) {
  return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
};
var varint = {
  encode: encode_1,
  decode,
  encodingLength: length
};
var _brrp_varint = varint;
var varint_default = _brrp_varint;

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/varint.js
var decode2 = (data, offset = 0) => {
  const code5 = varint_default.decode(data, offset);
  return [
    code5,
    varint_default.decode.bytes
  ];
};
var encodeTo = (int, target, offset = 0) => {
  varint_default.encode(int, target, offset);
  return target;
};
var encodingLength = (int) => {
  return varint_default.encodingLength(int);
};

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bytes.js
var bytes_exports = {};
__export(bytes_exports, {
  coerce: () => coerce,
  empty: () => empty,
  equals: () => equals,
  fromHex: () => fromHex,
  fromString: () => fromString,
  isBinary: () => isBinary,
  toHex: () => toHex,
  toString: () => toString
});
var empty = new Uint8Array(0);
var toHex = (d) => d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, "0"), "");
var fromHex = (hex) => {
  const hexes = hex.match(/../g);
  return hexes ? new Uint8Array(hexes.map((b) => parseInt(b, 16))) : empty;
};
var equals = (aa, bb) => {
  if (aa === bb)
    return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
};
var coerce = (o) => {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
};
var isBinary = (o) => o instanceof ArrayBuffer || ArrayBuffer.isView(o);
var fromString = (str) => new TextEncoder().encode(str);
var toString = (b) => new TextDecoder().decode(b);

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/hashes/digest.js
var create = (code5, digest2) => {
  const size = digest2.byteLength;
  const sizeOffset = encodingLength(code5);
  const digestOffset = sizeOffset + encodingLength(size);
  const bytes = new Uint8Array(digestOffset + size);
  encodeTo(code5, bytes, 0);
  encodeTo(size, bytes, sizeOffset);
  bytes.set(digest2, digestOffset);
  return new Digest(code5, size, digest2, bytes);
};
var decode3 = (multihash) => {
  const bytes = coerce(multihash);
  const [code5, sizeOffset] = decode2(bytes);
  const [size, digestOffset] = decode2(bytes.subarray(sizeOffset));
  const digest2 = bytes.subarray(sizeOffset + digestOffset);
  if (digest2.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest(code5, size, digest2, bytes);
};
var equals2 = (a, b) => {
  if (a === b) {
    return true;
  } else {
    return a.code === b.code && a.size === b.size && equals(a.bytes, b.bytes);
  }
};
var Digest = class {
  constructor(code5, size, digest2, bytes) {
    this.code = code5;
    this.size = size;
    this.digest = digest2;
    this.bytes = bytes;
  }
};

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base58.js
var base58_exports = {};
__export(base58_exports, {
  base58btc: () => base58btc,
  base58flickr: () => base58flickr
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/vendor/base-x.js
function base(ALPHABET, name5) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode12(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length2 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length2) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length2 = i2;
      pbegin++;
    }
    var it2 = size - length2;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length2 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length2) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length2 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length2;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode12(string2) {
    var buffer2 = decodeUnsafe(string2);
    if (buffer2) {
      return buffer2;
    }
    throw new Error(`Non-${name5} character`);
  }
  return {
    encode: encode12,
    decodeUnsafe,
    decode: decode12
  };
}
var src = base;
var _brrp__multiformats_scope_baseX = src;
var base_x_default = _brrp__multiformats_scope_baseX;

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base.js
var Encoder = class {
  constructor(name5, prefix, baseEncode) {
    this.name = name5;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes) {
    if (bytes instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder = class {
  constructor(name5, prefix, baseDecode) {
    this.name = name5;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder2) {
    return or(this, decoder2);
  }
};
var ComposedDecoder = class {
  constructor(decoders) {
    this.decoders = decoders;
  }
  or(decoder2) {
    return or(this, decoder2);
  }
  decode(input) {
    const prefix = input[0];
    const decoder2 = this.decoders[prefix];
    if (decoder2) {
      return decoder2.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
var or = (left, right) => new ComposedDecoder(__spreadValues(__spreadValues({}, left.decoders || { [left.prefix]: left }), right.decoders || { [right.prefix]: right }));
var Codec = class {
  constructor(name5, prefix, baseEncode, baseDecode) {
    this.name = name5;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder(name5, prefix, baseEncode);
    this.decoder = new Decoder(name5, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
};
var from = ({ name: name5, prefix, encode: encode12, decode: decode12 }) => new Codec(name5, prefix, encode12, decode12);
var baseX = ({ prefix, name: name5, alphabet: alphabet2 }) => {
  const { encode: encode12, decode: decode12 } = base_x_default(alphabet2, name5);
  return from({
    prefix,
    name: name5,
    encode: encode12,
    decode: (text) => coerce(decode12(text))
  });
};
var decode4 = (string2, alphabet2, bitsPerChar, name5) => {
  const codes = {};
  for (let i = 0; i < alphabet2.length; ++i) {
    codes[alphabet2[i]] = i;
  }
  let end = string2.length;
  while (string2[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits = 0;
  let buffer2 = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value = codes[string2[i]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name5} character`);
    }
    buffer2 = buffer2 << bitsPerChar | value;
    bits += bitsPerChar;
    if (bits >= 8) {
      bits -= 8;
      out[written++] = 255 & buffer2 >> bits;
    }
  }
  if (bits >= bitsPerChar || 255 & buffer2 << 8 - bits) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
};
var encode2 = (data, alphabet2, bitsPerChar) => {
  const pad = alphabet2[alphabet2.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits = 0;
  let buffer2 = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer2 = buffer2 << 8 | data[i];
    bits += 8;
    while (bits > bitsPerChar) {
      bits -= bitsPerChar;
      out += alphabet2[mask & buffer2 >> bits];
    }
  }
  if (bits) {
    out += alphabet2[mask & buffer2 << bitsPerChar - bits];
  }
  if (pad) {
    while (out.length * bitsPerChar & 7) {
      out += "=";
    }
  }
  return out;
};
var rfc4648 = ({ name: name5, prefix, bitsPerChar, alphabet: alphabet2 }) => {
  return from({
    prefix,
    name: name5,
    encode(input) {
      return encode2(input, alphabet2, bitsPerChar);
    },
    decode(input) {
      return decode4(input, alphabet2, bitsPerChar, name5);
    }
  });
};

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base58.js
var base58btc = baseX({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr = baseX({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base32.js
var base32_exports = {};
__export(base32_exports, {
  base32: () => base32,
  base32hex: () => base32hex,
  base32hexpad: () => base32hexpad,
  base32hexpadupper: () => base32hexpadupper,
  base32hexupper: () => base32hexupper,
  base32pad: () => base32pad,
  base32padupper: () => base32padupper,
  base32upper: () => base32upper,
  base32z: () => base32z
});
var base32 = rfc4648({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper = rfc4648({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad = rfc4648({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper = rfc4648({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex = rfc4648({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper = rfc4648({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad = rfc4648({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper = rfc4648({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z = rfc4648({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/cid.js
var CID = class _CID {
  constructor(version2, code5, multihash, bytes) {
    this.code = code5;
    this.version = version2;
    this.multihash = multihash;
    this.bytes = bytes;
    this.byteOffset = bytes.byteOffset;
    this.byteLength = bytes.byteLength;
    this.asCID = this;
    this._baseCache = /* @__PURE__ */ new Map();
    Object.defineProperties(this, {
      byteOffset: hidden,
      byteLength: hidden,
      code: readonly,
      version: readonly,
      multihash: readonly,
      bytes: readonly,
      _baseCache: hidden,
      asCID: hidden
    });
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      default: {
        const { code: code5, multihash } = this;
        if (code5 !== DAG_PB_CODE) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return _CID.createV0(multihash);
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code5, digest: digest2 } = this.multihash;
        const multihash = create(code5, digest2);
        return _CID.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
      }
    }
  }
  equals(other) {
    return other && this.code === other.code && this.version === other.version && equals2(this.multihash, other.multihash);
  }
  toString(base3) {
    const { bytes, version: version2, _baseCache } = this;
    switch (version2) {
      case 0:
        return toStringV0(bytes, _baseCache, base3 || base58btc.encoder);
      default:
        return toStringV1(bytes, _baseCache, base3 || base32.encoder);
    }
  }
  toJSON() {
    return {
      code: this.code,
      version: this.version,
      hash: this.multihash.bytes
    };
  }
  get [Symbol.toStringTag]() {
    return "CID";
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return "CID(" + this.toString() + ")";
  }
  static isCID(value) {
    deprecate(/^0\.0/, IS_CID_DEPRECATION);
    return !!(value && (value[cidSymbol] || value.asCID === value));
  }
  get toBaseEncodedString() {
    throw new Error("Deprecated, use .toString()");
  }
  get codec() {
    throw new Error('"codec" property is deprecated, use integer "code" property instead');
  }
  get buffer() {
    throw new Error("Deprecated .buffer property, use .bytes to get Uint8Array instead");
  }
  get multibaseName() {
    throw new Error('"multibaseName" property is deprecated');
  }
  get prefix() {
    throw new Error('"prefix" property is deprecated');
  }
  static asCID(value) {
    if (value instanceof _CID) {
      return value;
    } else if (value != null && value.asCID === value) {
      const { version: version2, code: code5, multihash, bytes } = value;
      return new _CID(version2, code5, multihash, bytes || encodeCID(version2, code5, multihash.bytes));
    } else if (value != null && value[cidSymbol] === true) {
      const { version: version2, multihash, code: code5 } = value;
      const digest2 = decode3(multihash);
      return _CID.create(version2, code5, digest2);
    } else {
      return null;
    }
  }
  static create(version2, code5, digest2) {
    if (typeof code5 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    switch (version2) {
      case 0: {
        if (code5 !== DAG_PB_CODE) {
          throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`);
        } else {
          return new _CID(version2, code5, digest2, digest2.bytes);
        }
      }
      case 1: {
        const bytes = encodeCID(version2, code5, digest2.bytes);
        return new _CID(version2, code5, digest2, bytes);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  static createV0(digest2) {
    return _CID.create(0, DAG_PB_CODE, digest2);
  }
  static createV1(code5, digest2) {
    return _CID.create(1, code5, digest2);
  }
  static decode(bytes) {
    const [cid, remainder] = _CID.decodeFirst(bytes);
    if (remainder.length) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  static decodeFirst(bytes) {
    const specs = _CID.inspectBytes(bytes);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce(bytes.subarray(prefixSize, prefixSize + specs.multihashSize));
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
    const digest2 = new Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
    const cid = specs.version === 0 ? _CID.createV0(digest2) : _CID.createV1(specs.codec, digest2);
    return [
      cid,
      bytes.subarray(specs.size)
    ];
  }
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i, length2] = decode2(initialBytes.subarray(offset));
      offset += length2;
      return i;
    };
    let version2 = next();
    let codec = DAG_PB_CODE;
    if (version2 === 18) {
      version2 = 0;
      offset = 0;
    } else if (version2 === 1) {
      codec = next();
    }
    if (version2 !== 0 && version2 !== 1) {
      throw new RangeError(`Invalid CID version ${version2}`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return {
      version: version2,
      codec,
      multihashCode,
      digestSize,
      multihashSize,
      size
    };
  }
  static parse(source, base3) {
    const [prefix, bytes] = parseCIDtoBytes(source, base3);
    const cid = _CID.decode(bytes);
    cid._baseCache.set(prefix, source);
    return cid;
  }
};
var parseCIDtoBytes = (source, base3) => {
  switch (source[0]) {
    case "Q": {
      const decoder2 = base3 || base58btc;
      return [
        base58btc.prefix,
        decoder2.decode(`${base58btc.prefix}${source}`)
      ];
    }
    case base58btc.prefix: {
      const decoder2 = base3 || base58btc;
      return [
        base58btc.prefix,
        decoder2.decode(source)
      ];
    }
    case base32.prefix: {
      const decoder2 = base3 || base32;
      return [
        base32.prefix,
        decoder2.decode(source)
      ];
    }
    default: {
      if (base3 == null) {
        throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
      }
      return [
        source[0],
        base3.decode(source)
      ];
    }
  }
};
var toStringV0 = (bytes, cache, base3) => {
  const { prefix } = base3;
  if (prefix !== base58btc.prefix) {
    throw Error(`Cannot string encode V0 in ${base3.name} encoding`);
  }
  const cid = cache.get(prefix);
  if (cid == null) {
    const cid2 = base3.encode(bytes).slice(1);
    cache.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
var toStringV1 = (bytes, cache, base3) => {
  const { prefix } = base3;
  const cid = cache.get(prefix);
  if (cid == null) {
    const cid2 = base3.encode(bytes);
    cache.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
var DAG_PB_CODE = 112;
var SHA_256_CODE = 18;
var encodeCID = (version2, code5, multihash) => {
  const codeOffset = encodingLength(version2);
  const hashOffset = codeOffset + encodingLength(code5);
  const bytes = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo(version2, bytes, 0);
  encodeTo(code5, bytes, codeOffset);
  bytes.set(multihash, hashOffset);
  return bytes;
};
var cidSymbol = Symbol.for("@ipld/js-cid/CID");
var readonly = {
  writable: false,
  configurable: false,
  enumerable: true
};
var hidden = {
  writable: false,
  enumerable: false,
  configurable: false
};
var version = "0.0.0-dev";
var deprecate = (range, message) => {
  if (range.test(version)) {
    console.warn(message);
  } else {
    throw new Error(message);
  }
};
var IS_CID_DEPRECATION = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`;

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/is.js
var typeofs = [
  "string",
  "number",
  "bigint",
  "symbol"
];
var objectTypeNames = [
  "Function",
  "Generator",
  "AsyncGenerator",
  "GeneratorFunction",
  "AsyncGeneratorFunction",
  "AsyncFunction",
  "Observable",
  "Array",
  "Buffer",
  "Object",
  "RegExp",
  "Date",
  "Error",
  "Map",
  "Set",
  "WeakMap",
  "WeakSet",
  "ArrayBuffer",
  "SharedArrayBuffer",
  "DataView",
  "Promise",
  "URL",
  "HTMLElement",
  "Int8Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "Int16Array",
  "Uint16Array",
  "Int32Array",
  "Uint32Array",
  "Float32Array",
  "Float64Array",
  "BigInt64Array",
  "BigUint64Array"
];
function is(value) {
  if (value === null) {
    return "null";
  }
  if (value === void 0) {
    return "undefined";
  }
  if (value === true || value === false) {
    return "boolean";
  }
  const typeOf = typeof value;
  if (typeofs.includes(typeOf)) {
    return typeOf;
  }
  if (typeOf === "function") {
    return "Function";
  }
  if (Array.isArray(value)) {
    return "Array";
  }
  if (isBuffer(value)) {
    return "Buffer";
  }
  const objectType = getObjectType(value);
  if (objectType) {
    return objectType;
  }
  return "Object";
}
function isBuffer(value) {
  return value && value.constructor && value.constructor.isBuffer && value.constructor.isBuffer.call(null, value);
}
function getObjectType(value) {
  const objectTypeName = Object.prototype.toString.call(value).slice(8, -1);
  if (objectTypeNames.includes(objectTypeName)) {
    return objectTypeName;
  }
  return void 0;
}

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/token.js
var Type = class {
  constructor(major, name5, terminal) {
    this.major = major;
    this.majorEncoded = major << 5;
    this.name = name5;
    this.terminal = terminal;
  }
  toString() {
    return `Type[${this.major}].${this.name}`;
  }
  compare(typ) {
    return this.major < typ.major ? -1 : this.major > typ.major ? 1 : 0;
  }
};
Type.uint = new Type(0, "uint", true);
Type.negint = new Type(1, "negint", true);
Type.bytes = new Type(2, "bytes", true);
Type.string = new Type(3, "string", true);
Type.array = new Type(4, "array", false);
Type.map = new Type(5, "map", false);
Type.tag = new Type(6, "tag", false);
Type.float = new Type(7, "float", true);
Type.false = new Type(7, "false", true);
Type.true = new Type(7, "true", true);
Type.null = new Type(7, "null", true);
Type.undefined = new Type(7, "undefined", true);
Type.break = new Type(7, "break", true);
var Token = class {
  constructor(type, value, encodedLength) {
    this.type = type;
    this.value = value;
    this.encodedLength = encodedLength;
    this.encodedBytes = void 0;
    this.byteValue = void 0;
  }
  toString() {
    return `Token[${this.type}].${this.value}`;
  }
};

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/byte-utils.js
var useBuffer = globalThis.process && !globalThis.process.browser && globalThis.Buffer && typeof globalThis.Buffer.isBuffer === "function";
var textDecoder = new TextDecoder();
var textEncoder = new TextEncoder();
function isBuffer2(buf2) {
  return useBuffer && globalThis.Buffer.isBuffer(buf2);
}
function asU8A(buf2) {
  if (!(buf2 instanceof Uint8Array)) {
    return Uint8Array.from(buf2);
  }
  return isBuffer2(buf2) ? new Uint8Array(buf2.buffer, buf2.byteOffset, buf2.byteLength) : buf2;
}
var toString2 = useBuffer ? (bytes, start, end) => {
  return end - start > 64 ? globalThis.Buffer.from(bytes.subarray(start, end)).toString("utf8") : utf8Slice(bytes, start, end);
} : (bytes, start, end) => {
  return end - start > 64 ? textDecoder.decode(bytes.subarray(start, end)) : utf8Slice(bytes, start, end);
};
var fromString2 = useBuffer ? (string2) => {
  return string2.length > 64 ? globalThis.Buffer.from(string2) : utf8ToBytes(string2);
} : (string2) => {
  return string2.length > 64 ? textEncoder.encode(string2) : utf8ToBytes(string2);
};
var fromArray = (arr) => {
  return Uint8Array.from(arr);
};
var slice = useBuffer ? (bytes, start, end) => {
  if (isBuffer2(bytes)) {
    return new Uint8Array(bytes.subarray(start, end));
  }
  return bytes.slice(start, end);
} : (bytes, start, end) => {
  return bytes.slice(start, end);
};
var concat = useBuffer ? (chunks, length2) => {
  chunks = chunks.map((c) => c instanceof Uint8Array ? c : globalThis.Buffer.from(c));
  return asU8A(globalThis.Buffer.concat(chunks, length2));
} : (chunks, length2) => {
  const out = new Uint8Array(length2);
  let off = 0;
  for (let b of chunks) {
    if (off + b.length > out.length) {
      b = b.subarray(0, out.length - off);
    }
    out.set(b, off);
    off += b.length;
  }
  return out;
};
var alloc = useBuffer ? (size) => {
  return globalThis.Buffer.allocUnsafe(size);
} : (size) => {
  return new Uint8Array(size);
};
function compare(b1, b2) {
  if (isBuffer2(b1) && isBuffer2(b2)) {
    return b1.compare(b2);
  }
  for (let i = 0; i < b1.length; i++) {
    if (b1[i] === b2[i]) {
      continue;
    }
    return b1[i] < b2[i] ? -1 : 1;
  }
  return 0;
}
function utf8ToBytes(string2, units = Infinity) {
  let codePoint;
  const length2 = string2.length;
  let leadSurrogate = null;
  const bytes = [];
  for (let i = 0; i < length2; ++i) {
    codePoint = string2.charCodeAt(i);
    if (codePoint > 55295 && codePoint < 57344) {
      if (!leadSurrogate) {
        if (codePoint > 56319) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          continue;
        } else if (i + 1 === length2) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          continue;
        }
        leadSurrogate = codePoint;
        continue;
      }
      if (codePoint < 56320) {
        if ((units -= 3) > -1)
          bytes.push(239, 191, 189);
        leadSurrogate = codePoint;
        continue;
      }
      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
    } else if (leadSurrogate) {
      if ((units -= 3) > -1)
        bytes.push(239, 191, 189);
    }
    leadSurrogate = null;
    if (codePoint < 128) {
      if ((units -= 1) < 0)
        break;
      bytes.push(codePoint);
    } else if (codePoint < 2048) {
      if ((units -= 2) < 0)
        break;
      bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
    } else if (codePoint < 65536) {
      if ((units -= 3) < 0)
        break;
      bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else if (codePoint < 1114112) {
      if ((units -= 4) < 0)
        break;
      bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else {
      throw new Error("Invalid code point");
    }
  }
  return bytes;
}
function utf8Slice(buf2, offset, end) {
  const res = [];
  while (offset < end) {
    const firstByte = buf2[offset];
    let codePoint = null;
    let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (offset + bytesPerSequence <= end) {
      let secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf2[offset + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf2[offset + 1];
          thirdByte = buf2[offset + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf2[offset + 1];
          thirdByte = buf2[offset + 2];
          fourthByte = buf2[offset + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      codePoint = 65533;
      bytesPerSequence = 1;
    } else if (codePoint > 65535) {
      codePoint -= 65536;
      res.push(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    res.push(codePoint);
    offset += bytesPerSequence;
  }
  return decodeCodePointsArray(res);
}
var MAX_ARGUMENTS_LENGTH = 4096;
function decodeCodePointsArray(codePoints) {
  const len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints);
  }
  let res = "";
  let i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
  }
  return res;
}

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/bl.js
var defaultChunkSize = 256;
var Bl = class {
  constructor(chunkSize = defaultChunkSize) {
    this.chunkSize = chunkSize;
    this.cursor = 0;
    this.maxCursor = -1;
    this.chunks = [];
    this._initReuseChunk = null;
  }
  reset() {
    this.cursor = 0;
    this.maxCursor = -1;
    if (this.chunks.length) {
      this.chunks = [];
    }
    if (this._initReuseChunk !== null) {
      this.chunks.push(this._initReuseChunk);
      this.maxCursor = this._initReuseChunk.length - 1;
    }
  }
  push(bytes) {
    let topChunk = this.chunks[this.chunks.length - 1];
    const newMax = this.cursor + bytes.length;
    if (newMax <= this.maxCursor + 1) {
      const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;
      topChunk.set(bytes, chunkPos);
    } else {
      if (topChunk) {
        const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;
        if (chunkPos < topChunk.length) {
          this.chunks[this.chunks.length - 1] = topChunk.subarray(0, chunkPos);
          this.maxCursor = this.cursor - 1;
        }
      }
      if (bytes.length < 64 && bytes.length < this.chunkSize) {
        topChunk = alloc(this.chunkSize);
        this.chunks.push(topChunk);
        this.maxCursor += topChunk.length;
        if (this._initReuseChunk === null) {
          this._initReuseChunk = topChunk;
        }
        topChunk.set(bytes, 0);
      } else {
        this.chunks.push(bytes);
        this.maxCursor += bytes.length;
      }
    }
    this.cursor += bytes.length;
  }
  toBytes(reset = false) {
    let byts;
    if (this.chunks.length === 1) {
      const chunk = this.chunks[0];
      if (reset && this.cursor > chunk.length / 2) {
        byts = this.cursor === chunk.length ? chunk : chunk.subarray(0, this.cursor);
        this._initReuseChunk = null;
        this.chunks = [];
      } else {
        byts = slice(chunk, 0, this.cursor);
      }
    } else {
      byts = concat(this.chunks, this.cursor);
    }
    if (reset) {
      this.reset();
    }
    return byts;
  }
};

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/common.js
var decodeErrPrefix = "CBOR decode error:";
var encodeErrPrefix = "CBOR encode error:";
var uintMinorPrefixBytes = [];
uintMinorPrefixBytes[23] = 1;
uintMinorPrefixBytes[24] = 2;
uintMinorPrefixBytes[25] = 3;
uintMinorPrefixBytes[26] = 5;
uintMinorPrefixBytes[27] = 9;
function assertEnoughData(data, pos, need) {
  if (data.length - pos < need) {
    throw new Error(`${decodeErrPrefix} not enough data for type`);
  }
}

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/0uint.js
var uintBoundaries = [
  24,
  256,
  65536,
  4294967296,
  BigInt("18446744073709551616")
];
function readUint8(data, offset, options) {
  assertEnoughData(data, offset, 1);
  const value = data[offset];
  if (options.strict === true && value < uintBoundaries[0]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value;
}
function readUint16(data, offset, options) {
  assertEnoughData(data, offset, 2);
  const value = data[offset] << 8 | data[offset + 1];
  if (options.strict === true && value < uintBoundaries[1]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value;
}
function readUint32(data, offset, options) {
  assertEnoughData(data, offset, 4);
  const value = data[offset] * 16777216 + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3];
  if (options.strict === true && value < uintBoundaries[2]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value;
}
function readUint64(data, offset, options) {
  assertEnoughData(data, offset, 8);
  const hi = data[offset] * 16777216 + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3];
  const lo = data[offset + 4] * 16777216 + (data[offset + 5] << 16) + (data[offset + 6] << 8) + data[offset + 7];
  const value = (BigInt(hi) << BigInt(32)) + BigInt(lo);
  if (options.strict === true && value < uintBoundaries[3]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  if (value <= Number.MAX_SAFE_INTEGER) {
    return Number(value);
  }
  if (options.allowBigInt === true) {
    return value;
  }
  throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`);
}
function decodeUint8(data, pos, _minor, options) {
  return new Token(Type.uint, readUint8(data, pos + 1, options), 2);
}
function decodeUint16(data, pos, _minor, options) {
  return new Token(Type.uint, readUint16(data, pos + 1, options), 3);
}
function decodeUint32(data, pos, _minor, options) {
  return new Token(Type.uint, readUint32(data, pos + 1, options), 5);
}
function decodeUint64(data, pos, _minor, options) {
  return new Token(Type.uint, readUint64(data, pos + 1, options), 9);
}
function encodeUint(buf2, token) {
  return encodeUintValue(buf2, 0, token.value);
}
function encodeUintValue(buf2, major, uint) {
  if (uint < uintBoundaries[0]) {
    const nuint = Number(uint);
    buf2.push([major | nuint]);
  } else if (uint < uintBoundaries[1]) {
    const nuint = Number(uint);
    buf2.push([
      major | 24,
      nuint
    ]);
  } else if (uint < uintBoundaries[2]) {
    const nuint = Number(uint);
    buf2.push([
      major | 25,
      nuint >>> 8,
      nuint & 255
    ]);
  } else if (uint < uintBoundaries[3]) {
    const nuint = Number(uint);
    buf2.push([
      major | 26,
      nuint >>> 24 & 255,
      nuint >>> 16 & 255,
      nuint >>> 8 & 255,
      nuint & 255
    ]);
  } else {
    const buint = BigInt(uint);
    if (buint < uintBoundaries[4]) {
      const set = [
        major | 27,
        0,
        0,
        0,
        0,
        0,
        0,
        0
      ];
      let lo = Number(buint & BigInt(4294967295));
      let hi = Number(buint >> BigInt(32) & BigInt(4294967295));
      set[8] = lo & 255;
      lo = lo >> 8;
      set[7] = lo & 255;
      lo = lo >> 8;
      set[6] = lo & 255;
      lo = lo >> 8;
      set[5] = lo & 255;
      set[4] = hi & 255;
      hi = hi >> 8;
      set[3] = hi & 255;
      hi = hi >> 8;
      set[2] = hi & 255;
      hi = hi >> 8;
      set[1] = hi & 255;
      buf2.push(set);
    } else {
      throw new Error(`${decodeErrPrefix} encountered BigInt larger than allowable range`);
    }
  }
}
encodeUint.encodedSize = function encodedSize(token) {
  return encodeUintValue.encodedSize(token.value);
};
encodeUintValue.encodedSize = function encodedSize2(uint) {
  if (uint < uintBoundaries[0]) {
    return 1;
  }
  if (uint < uintBoundaries[1]) {
    return 2;
  }
  if (uint < uintBoundaries[2]) {
    return 3;
  }
  if (uint < uintBoundaries[3]) {
    return 5;
  }
  return 9;
};
encodeUint.compareTokens = function compareTokens(tok1, tok2) {
  return tok1.value < tok2.value ? -1 : tok1.value > tok2.value ? 1 : 0;
};

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/1negint.js
function decodeNegint8(data, pos, _minor, options) {
  return new Token(Type.negint, -1 - readUint8(data, pos + 1, options), 2);
}
function decodeNegint16(data, pos, _minor, options) {
  return new Token(Type.negint, -1 - readUint16(data, pos + 1, options), 3);
}
function decodeNegint32(data, pos, _minor, options) {
  return new Token(Type.negint, -1 - readUint32(data, pos + 1, options), 5);
}
var neg1b = BigInt(-1);
var pos1b = BigInt(1);
function decodeNegint64(data, pos, _minor, options) {
  const int = readUint64(data, pos + 1, options);
  if (typeof int !== "bigint") {
    const value = -1 - int;
    if (value >= Number.MIN_SAFE_INTEGER) {
      return new Token(Type.negint, value, 9);
    }
  }
  if (options.allowBigInt !== true) {
    throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`);
  }
  return new Token(Type.negint, neg1b - BigInt(int), 9);
}
function encodeNegint(buf2, token) {
  const negint = token.value;
  const unsigned = typeof negint === "bigint" ? negint * neg1b - pos1b : negint * -1 - 1;
  encodeUintValue(buf2, token.type.majorEncoded, unsigned);
}
encodeNegint.encodedSize = function encodedSize3(token) {
  const negint = token.value;
  const unsigned = typeof negint === "bigint" ? negint * neg1b - pos1b : negint * -1 - 1;
  if (unsigned < uintBoundaries[0]) {
    return 1;
  }
  if (unsigned < uintBoundaries[1]) {
    return 2;
  }
  if (unsigned < uintBoundaries[2]) {
    return 3;
  }
  if (unsigned < uintBoundaries[3]) {
    return 5;
  }
  return 9;
};
encodeNegint.compareTokens = function compareTokens2(tok1, tok2) {
  return tok1.value < tok2.value ? 1 : tok1.value > tok2.value ? -1 : 0;
};

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/2bytes.js
function toToken(data, pos, prefix, length2) {
  assertEnoughData(data, pos, prefix + length2);
  const buf2 = slice(data, pos + prefix, pos + prefix + length2);
  return new Token(Type.bytes, buf2, prefix + length2);
}
function decodeBytesCompact(data, pos, minor, _options) {
  return toToken(data, pos, 1, minor);
}
function decodeBytes8(data, pos, _minor, options) {
  return toToken(data, pos, 2, readUint8(data, pos + 1, options));
}
function decodeBytes16(data, pos, _minor, options) {
  return toToken(data, pos, 3, readUint16(data, pos + 1, options));
}
function decodeBytes32(data, pos, _minor, options) {
  return toToken(data, pos, 5, readUint32(data, pos + 1, options));
}
function decodeBytes64(data, pos, _minor, options) {
  const l = readUint64(data, pos + 1, options);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer bytes lengths not supported`);
  }
  return toToken(data, pos, 9, l);
}
function tokenBytes(token) {
  if (token.encodedBytes === void 0) {
    token.encodedBytes = token.type === Type.string ? fromString2(token.value) : token.value;
  }
  return token.encodedBytes;
}
function encodeBytes(buf2, token) {
  const bytes = tokenBytes(token);
  encodeUintValue(buf2, token.type.majorEncoded, bytes.length);
  buf2.push(bytes);
}
encodeBytes.encodedSize = function encodedSize4(token) {
  const bytes = tokenBytes(token);
  return encodeUintValue.encodedSize(bytes.length) + bytes.length;
};
encodeBytes.compareTokens = function compareTokens3(tok1, tok2) {
  return compareBytes(tokenBytes(tok1), tokenBytes(tok2));
};
function compareBytes(b1, b2) {
  return b1.length < b2.length ? -1 : b1.length > b2.length ? 1 : compare(b1, b2);
}

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/3string.js
function toToken2(data, pos, prefix, length2, options) {
  const totLength = prefix + length2;
  assertEnoughData(data, pos, totLength);
  const tok = new Token(Type.string, toString2(data, pos + prefix, pos + totLength), totLength);
  if (options.retainStringBytes === true) {
    tok.byteValue = slice(data, pos + prefix, pos + totLength);
  }
  return tok;
}
function decodeStringCompact(data, pos, minor, options) {
  return toToken2(data, pos, 1, minor, options);
}
function decodeString8(data, pos, _minor, options) {
  return toToken2(data, pos, 2, readUint8(data, pos + 1, options), options);
}
function decodeString16(data, pos, _minor, options) {
  return toToken2(data, pos, 3, readUint16(data, pos + 1, options), options);
}
function decodeString32(data, pos, _minor, options) {
  return toToken2(data, pos, 5, readUint32(data, pos + 1, options), options);
}
function decodeString64(data, pos, _minor, options) {
  const l = readUint64(data, pos + 1, options);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer string lengths not supported`);
  }
  return toToken2(data, pos, 9, l, options);
}
var encodeString = encodeBytes;

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/4array.js
function toToken3(_data, _pos, prefix, length2) {
  return new Token(Type.array, length2, prefix);
}
function decodeArrayCompact(data, pos, minor, _options) {
  return toToken3(data, pos, 1, minor);
}
function decodeArray8(data, pos, _minor, options) {
  return toToken3(data, pos, 2, readUint8(data, pos + 1, options));
}
function decodeArray16(data, pos, _minor, options) {
  return toToken3(data, pos, 3, readUint16(data, pos + 1, options));
}
function decodeArray32(data, pos, _minor, options) {
  return toToken3(data, pos, 5, readUint32(data, pos + 1, options));
}
function decodeArray64(data, pos, _minor, options) {
  const l = readUint64(data, pos + 1, options);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer array lengths not supported`);
  }
  return toToken3(data, pos, 9, l);
}
function decodeArrayIndefinite(data, pos, _minor, options) {
  if (options.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
  }
  return toToken3(data, pos, 1, Infinity);
}
function encodeArray(buf2, token) {
  encodeUintValue(buf2, Type.array.majorEncoded, token.value);
}
encodeArray.compareTokens = encodeUint.compareTokens;
encodeArray.encodedSize = function encodedSize5(token) {
  return encodeUintValue.encodedSize(token.value);
};

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/5map.js
function toToken4(_data, _pos, prefix, length2) {
  return new Token(Type.map, length2, prefix);
}
function decodeMapCompact(data, pos, minor, _options) {
  return toToken4(data, pos, 1, minor);
}
function decodeMap8(data, pos, _minor, options) {
  return toToken4(data, pos, 2, readUint8(data, pos + 1, options));
}
function decodeMap16(data, pos, _minor, options) {
  return toToken4(data, pos, 3, readUint16(data, pos + 1, options));
}
function decodeMap32(data, pos, _minor, options) {
  return toToken4(data, pos, 5, readUint32(data, pos + 1, options));
}
function decodeMap64(data, pos, _minor, options) {
  const l = readUint64(data, pos + 1, options);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer map lengths not supported`);
  }
  return toToken4(data, pos, 9, l);
}
function decodeMapIndefinite(data, pos, _minor, options) {
  if (options.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
  }
  return toToken4(data, pos, 1, Infinity);
}
function encodeMap(buf2, token) {
  encodeUintValue(buf2, Type.map.majorEncoded, token.value);
}
encodeMap.compareTokens = encodeUint.compareTokens;
encodeMap.encodedSize = function encodedSize6(token) {
  return encodeUintValue.encodedSize(token.value);
};

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/6tag.js
function decodeTagCompact(_data, _pos, minor, _options) {
  return new Token(Type.tag, minor, 1);
}
function decodeTag8(data, pos, _minor, options) {
  return new Token(Type.tag, readUint8(data, pos + 1, options), 2);
}
function decodeTag16(data, pos, _minor, options) {
  return new Token(Type.tag, readUint16(data, pos + 1, options), 3);
}
function decodeTag32(data, pos, _minor, options) {
  return new Token(Type.tag, readUint32(data, pos + 1, options), 5);
}
function decodeTag64(data, pos, _minor, options) {
  return new Token(Type.tag, readUint64(data, pos + 1, options), 9);
}
function encodeTag(buf2, token) {
  encodeUintValue(buf2, Type.tag.majorEncoded, token.value);
}
encodeTag.compareTokens = encodeUint.compareTokens;
encodeTag.encodedSize = function encodedSize7(token) {
  return encodeUintValue.encodedSize(token.value);
};

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/7float.js
var MINOR_FALSE = 20;
var MINOR_TRUE = 21;
var MINOR_NULL = 22;
var MINOR_UNDEFINED = 23;
function decodeUndefined(_data, _pos, _minor, options) {
  if (options.allowUndefined === false) {
    throw new Error(`${decodeErrPrefix} undefined values are not supported`);
  } else if (options.coerceUndefinedToNull === true) {
    return new Token(Type.null, null, 1);
  }
  return new Token(Type.undefined, void 0, 1);
}
function decodeBreak(_data, _pos, _minor, options) {
  if (options.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
  }
  return new Token(Type.break, void 0, 1);
}
function createToken(value, bytes, options) {
  if (options) {
    if (options.allowNaN === false && Number.isNaN(value)) {
      throw new Error(`${decodeErrPrefix} NaN values are not supported`);
    }
    if (options.allowInfinity === false && (value === Infinity || value === -Infinity)) {
      throw new Error(`${decodeErrPrefix} Infinity values are not supported`);
    }
  }
  return new Token(Type.float, value, bytes);
}
function decodeFloat16(data, pos, _minor, options) {
  return createToken(readFloat16(data, pos + 1), 3, options);
}
function decodeFloat32(data, pos, _minor, options) {
  return createToken(readFloat32(data, pos + 1), 5, options);
}
function decodeFloat64(data, pos, _minor, options) {
  return createToken(readFloat64(data, pos + 1), 9, options);
}
function encodeFloat(buf2, token, options) {
  const float = token.value;
  if (float === false) {
    buf2.push([Type.float.majorEncoded | MINOR_FALSE]);
  } else if (float === true) {
    buf2.push([Type.float.majorEncoded | MINOR_TRUE]);
  } else if (float === null) {
    buf2.push([Type.float.majorEncoded | MINOR_NULL]);
  } else if (float === void 0) {
    buf2.push([Type.float.majorEncoded | MINOR_UNDEFINED]);
  } else {
    let decoded;
    let success = false;
    if (!options || options.float64 !== true) {
      encodeFloat16(float);
      decoded = readFloat16(ui8a, 1);
      if (float === decoded || Number.isNaN(float)) {
        ui8a[0] = 249;
        buf2.push(ui8a.slice(0, 3));
        success = true;
      } else {
        encodeFloat32(float);
        decoded = readFloat32(ui8a, 1);
        if (float === decoded) {
          ui8a[0] = 250;
          buf2.push(ui8a.slice(0, 5));
          success = true;
        }
      }
    }
    if (!success) {
      encodeFloat64(float);
      decoded = readFloat64(ui8a, 1);
      ui8a[0] = 251;
      buf2.push(ui8a.slice(0, 9));
    }
  }
}
encodeFloat.encodedSize = function encodedSize8(token, options) {
  const float = token.value;
  if (float === false || float === true || float === null || float === void 0) {
    return 1;
  }
  if (!options || options.float64 !== true) {
    encodeFloat16(float);
    let decoded = readFloat16(ui8a, 1);
    if (float === decoded || Number.isNaN(float)) {
      return 3;
    }
    encodeFloat32(float);
    decoded = readFloat32(ui8a, 1);
    if (float === decoded) {
      return 5;
    }
  }
  return 9;
};
var buffer = new ArrayBuffer(9);
var dataView = new DataView(buffer, 1);
var ui8a = new Uint8Array(buffer, 0);
function encodeFloat16(inp) {
  if (inp === Infinity) {
    dataView.setUint16(0, 31744, false);
  } else if (inp === -Infinity) {
    dataView.setUint16(0, 64512, false);
  } else if (Number.isNaN(inp)) {
    dataView.setUint16(0, 32256, false);
  } else {
    dataView.setFloat32(0, inp);
    const valu32 = dataView.getUint32(0);
    const exponent = (valu32 & 2139095040) >> 23;
    const mantissa = valu32 & 8388607;
    if (exponent === 255) {
      dataView.setUint16(0, 31744, false);
    } else if (exponent === 0) {
      dataView.setUint16(0, (inp & 2147483648) >> 16 | mantissa >> 13, false);
    } else {
      const logicalExponent = exponent - 127;
      if (logicalExponent < -24) {
        dataView.setUint16(0, 0);
      } else if (logicalExponent < -14) {
        dataView.setUint16(0, (valu32 & 2147483648) >> 16 | 1 << 24 + logicalExponent, false);
      } else {
        dataView.setUint16(0, (valu32 & 2147483648) >> 16 | logicalExponent + 15 << 10 | mantissa >> 13, false);
      }
    }
  }
}
function readFloat16(ui8a2, pos) {
  if (ui8a2.length - pos < 2) {
    throw new Error(`${decodeErrPrefix} not enough data for float16`);
  }
  const half = (ui8a2[pos] << 8) + ui8a2[pos + 1];
  if (half === 31744) {
    return Infinity;
  }
  if (half === 64512) {
    return -Infinity;
  }
  if (half === 32256) {
    return NaN;
  }
  const exp = half >> 10 & 31;
  const mant = half & 1023;
  let val;
  if (exp === 0) {
    val = mant * 2 ** -24;
  } else if (exp !== 31) {
    val = (mant + 1024) * 2 ** (exp - 25);
  } else {
    val = mant === 0 ? Infinity : NaN;
  }
  return half & 32768 ? -val : val;
}
function encodeFloat32(inp) {
  dataView.setFloat32(0, inp, false);
}
function readFloat32(ui8a2, pos) {
  if (ui8a2.length - pos < 4) {
    throw new Error(`${decodeErrPrefix} not enough data for float32`);
  }
  const offset = (ui8a2.byteOffset || 0) + pos;
  return new DataView(ui8a2.buffer, offset, 4).getFloat32(0, false);
}
function encodeFloat64(inp) {
  dataView.setFloat64(0, inp, false);
}
function readFloat64(ui8a2, pos) {
  if (ui8a2.length - pos < 8) {
    throw new Error(`${decodeErrPrefix} not enough data for float64`);
  }
  const offset = (ui8a2.byteOffset || 0) + pos;
  return new DataView(ui8a2.buffer, offset, 8).getFloat64(0, false);
}
encodeFloat.compareTokens = encodeUint.compareTokens;

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/jump.js
function invalidMinor(data, pos, minor) {
  throw new Error(`${decodeErrPrefix} encountered invalid minor (${minor}) for major ${data[pos] >>> 5}`);
}
function errorer(msg) {
  return () => {
    throw new Error(`${decodeErrPrefix} ${msg}`);
  };
}
var jump = [];
for (let i = 0; i <= 23; i++) {
  jump[i] = invalidMinor;
}
jump[24] = decodeUint8;
jump[25] = decodeUint16;
jump[26] = decodeUint32;
jump[27] = decodeUint64;
jump[28] = invalidMinor;
jump[29] = invalidMinor;
jump[30] = invalidMinor;
jump[31] = invalidMinor;
for (let i = 32; i <= 55; i++) {
  jump[i] = invalidMinor;
}
jump[56] = decodeNegint8;
jump[57] = decodeNegint16;
jump[58] = decodeNegint32;
jump[59] = decodeNegint64;
jump[60] = invalidMinor;
jump[61] = invalidMinor;
jump[62] = invalidMinor;
jump[63] = invalidMinor;
for (let i = 64; i <= 87; i++) {
  jump[i] = decodeBytesCompact;
}
jump[88] = decodeBytes8;
jump[89] = decodeBytes16;
jump[90] = decodeBytes32;
jump[91] = decodeBytes64;
jump[92] = invalidMinor;
jump[93] = invalidMinor;
jump[94] = invalidMinor;
jump[95] = errorer("indefinite length bytes/strings are not supported");
for (let i = 96; i <= 119; i++) {
  jump[i] = decodeStringCompact;
}
jump[120] = decodeString8;
jump[121] = decodeString16;
jump[122] = decodeString32;
jump[123] = decodeString64;
jump[124] = invalidMinor;
jump[125] = invalidMinor;
jump[126] = invalidMinor;
jump[127] = errorer("indefinite length bytes/strings are not supported");
for (let i = 128; i <= 151; i++) {
  jump[i] = decodeArrayCompact;
}
jump[152] = decodeArray8;
jump[153] = decodeArray16;
jump[154] = decodeArray32;
jump[155] = decodeArray64;
jump[156] = invalidMinor;
jump[157] = invalidMinor;
jump[158] = invalidMinor;
jump[159] = decodeArrayIndefinite;
for (let i = 160; i <= 183; i++) {
  jump[i] = decodeMapCompact;
}
jump[184] = decodeMap8;
jump[185] = decodeMap16;
jump[186] = decodeMap32;
jump[187] = decodeMap64;
jump[188] = invalidMinor;
jump[189] = invalidMinor;
jump[190] = invalidMinor;
jump[191] = decodeMapIndefinite;
for (let i = 192; i <= 215; i++) {
  jump[i] = decodeTagCompact;
}
jump[216] = decodeTag8;
jump[217] = decodeTag16;
jump[218] = decodeTag32;
jump[219] = decodeTag64;
jump[220] = invalidMinor;
jump[221] = invalidMinor;
jump[222] = invalidMinor;
jump[223] = invalidMinor;
for (let i = 224; i <= 243; i++) {
  jump[i] = errorer("simple values are not supported");
}
jump[244] = invalidMinor;
jump[245] = invalidMinor;
jump[246] = invalidMinor;
jump[247] = decodeUndefined;
jump[248] = errorer("simple values are not supported");
jump[249] = decodeFloat16;
jump[250] = decodeFloat32;
jump[251] = decodeFloat64;
jump[252] = invalidMinor;
jump[253] = invalidMinor;
jump[254] = invalidMinor;
jump[255] = decodeBreak;
var quick = [];
for (let i = 0; i < 24; i++) {
  quick[i] = new Token(Type.uint, i, 1);
}
for (let i = -1; i >= -24; i--) {
  quick[31 - i] = new Token(Type.negint, i, 1);
}
quick[64] = new Token(Type.bytes, new Uint8Array(0), 1);
quick[96] = new Token(Type.string, "", 1);
quick[128] = new Token(Type.array, 0, 1);
quick[160] = new Token(Type.map, 0, 1);
quick[244] = new Token(Type.false, false, 1);
quick[245] = new Token(Type.true, true, 1);
quick[246] = new Token(Type.null, null, 1);
function quickEncodeToken(token) {
  switch (token.type) {
    case Type.false:
      return fromArray([244]);
    case Type.true:
      return fromArray([245]);
    case Type.null:
      return fromArray([246]);
    case Type.bytes:
      if (!token.value.length) {
        return fromArray([64]);
      }
      return;
    case Type.string:
      if (token.value === "") {
        return fromArray([96]);
      }
      return;
    case Type.array:
      if (token.value === 0) {
        return fromArray([128]);
      }
      return;
    case Type.map:
      if (token.value === 0) {
        return fromArray([160]);
      }
      return;
    case Type.uint:
      if (token.value < 24) {
        return fromArray([Number(token.value)]);
      }
      return;
    case Type.negint:
      if (token.value >= -24) {
        return fromArray([31 - Number(token.value)]);
      }
  }
}

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/encode.js
var defaultEncodeOptions = {
  float64: false,
  mapSorter,
  quickEncodeToken
};
function makeCborEncoders() {
  const encoders = [];
  encoders[Type.uint.major] = encodeUint;
  encoders[Type.negint.major] = encodeNegint;
  encoders[Type.bytes.major] = encodeBytes;
  encoders[Type.string.major] = encodeString;
  encoders[Type.array.major] = encodeArray;
  encoders[Type.map.major] = encodeMap;
  encoders[Type.tag.major] = encodeTag;
  encoders[Type.float.major] = encodeFloat;
  return encoders;
}
var cborEncoders = makeCborEncoders();
var buf = new Bl();
var Ref = class _Ref {
  constructor(obj, parent) {
    this.obj = obj;
    this.parent = parent;
  }
  includes(obj) {
    let p = this;
    do {
      if (p.obj === obj) {
        return true;
      }
    } while (p = p.parent);
    return false;
  }
  static createCheck(stack, obj) {
    if (stack && stack.includes(obj)) {
      throw new Error(`${encodeErrPrefix} object contains circular references`);
    }
    return new _Ref(obj, stack);
  }
};
var simpleTokens = {
  null: new Token(Type.null, null),
  undefined: new Token(Type.undefined, void 0),
  true: new Token(Type.true, true),
  false: new Token(Type.false, false),
  emptyArray: new Token(Type.array, 0),
  emptyMap: new Token(Type.map, 0)
};
var typeEncoders = {
  number(obj, _typ, _options, _refStack) {
    if (!Number.isInteger(obj) || !Number.isSafeInteger(obj)) {
      return new Token(Type.float, obj);
    } else if (obj >= 0) {
      return new Token(Type.uint, obj);
    } else {
      return new Token(Type.negint, obj);
    }
  },
  bigint(obj, _typ, _options, _refStack) {
    if (obj >= BigInt(0)) {
      return new Token(Type.uint, obj);
    } else {
      return new Token(Type.negint, obj);
    }
  },
  Uint8Array(obj, _typ, _options, _refStack) {
    return new Token(Type.bytes, obj);
  },
  string(obj, _typ, _options, _refStack) {
    return new Token(Type.string, obj);
  },
  boolean(obj, _typ, _options, _refStack) {
    return obj ? simpleTokens.true : simpleTokens.false;
  },
  null(_obj, _typ, _options, _refStack) {
    return simpleTokens.null;
  },
  undefined(_obj, _typ, _options, _refStack) {
    return simpleTokens.undefined;
  },
  ArrayBuffer(obj, _typ, _options, _refStack) {
    return new Token(Type.bytes, new Uint8Array(obj));
  },
  DataView(obj, _typ, _options, _refStack) {
    return new Token(Type.bytes, new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength));
  },
  Array(obj, _typ, options, refStack) {
    if (!obj.length) {
      if (options.addBreakTokens === true) {
        return [
          simpleTokens.emptyArray,
          new Token(Type.break)
        ];
      }
      return simpleTokens.emptyArray;
    }
    refStack = Ref.createCheck(refStack, obj);
    const entries = [];
    let i = 0;
    for (const e of obj) {
      entries[i++] = objectToTokens(e, options, refStack);
    }
    if (options.addBreakTokens) {
      return [
        new Token(Type.array, obj.length),
        entries,
        new Token(Type.break)
      ];
    }
    return [
      new Token(Type.array, obj.length),
      entries
    ];
  },
  Object(obj, typ, options, refStack) {
    const isMap = typ !== "Object";
    const keys = isMap ? obj.keys() : Object.keys(obj);
    const length2 = isMap ? obj.size : keys.length;
    if (!length2) {
      if (options.addBreakTokens === true) {
        return [
          simpleTokens.emptyMap,
          new Token(Type.break)
        ];
      }
      return simpleTokens.emptyMap;
    }
    refStack = Ref.createCheck(refStack, obj);
    const entries = [];
    let i = 0;
    for (const key of keys) {
      entries[i++] = [
        objectToTokens(key, options, refStack),
        objectToTokens(isMap ? obj.get(key) : obj[key], options, refStack)
      ];
    }
    sortMapEntries(entries, options);
    if (options.addBreakTokens) {
      return [
        new Token(Type.map, length2),
        entries,
        new Token(Type.break)
      ];
    }
    return [
      new Token(Type.map, length2),
      entries
    ];
  }
};
typeEncoders.Map = typeEncoders.Object;
typeEncoders.Buffer = typeEncoders.Uint8Array;
for (const typ of "Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64".split(" ")) {
  typeEncoders[`${typ}Array`] = typeEncoders.DataView;
}
function objectToTokens(obj, options = {}, refStack) {
  const typ = is(obj);
  const customTypeEncoder = options && options.typeEncoders && options.typeEncoders[typ] || typeEncoders[typ];
  if (typeof customTypeEncoder === "function") {
    const tokens = customTypeEncoder(obj, typ, options, refStack);
    if (tokens != null) {
      return tokens;
    }
  }
  const typeEncoder = typeEncoders[typ];
  if (!typeEncoder) {
    throw new Error(`${encodeErrPrefix} unsupported type: ${typ}`);
  }
  return typeEncoder(obj, typ, options, refStack);
}
function sortMapEntries(entries, options) {
  if (options.mapSorter) {
    entries.sort(options.mapSorter);
  }
}
function mapSorter(e1, e2) {
  const keyToken1 = Array.isArray(e1[0]) ? e1[0][0] : e1[0];
  const keyToken2 = Array.isArray(e2[0]) ? e2[0][0] : e2[0];
  if (keyToken1.type !== keyToken2.type) {
    return keyToken1.type.compare(keyToken2.type);
  }
  const major = keyToken1.type.major;
  const tcmp = cborEncoders[major].compareTokens(keyToken1, keyToken2);
  if (tcmp === 0) {
    console.warn("WARNING: complex key types used, CBOR key sorting guarantees are gone");
  }
  return tcmp;
}
function tokensToEncoded(buf2, tokens, encoders, options) {
  if (Array.isArray(tokens)) {
    for (const token of tokens) {
      tokensToEncoded(buf2, token, encoders, options);
    }
  } else {
    encoders[tokens.type.major](buf2, tokens, options);
  }
}
function encodeCustom(data, encoders, options) {
  const tokens = objectToTokens(data, options);
  if (!Array.isArray(tokens) && options.quickEncodeToken) {
    const quickBytes = options.quickEncodeToken(tokens);
    if (quickBytes) {
      return quickBytes;
    }
    const encoder2 = encoders[tokens.type.major];
    if (encoder2.encodedSize) {
      const size = encoder2.encodedSize(tokens, options);
      const buf2 = new Bl(size);
      encoder2(buf2, tokens, options);
      if (buf2.chunks.length !== 1) {
        throw new Error(`Unexpected error: pre-calculated length for ${tokens} was wrong`);
      }
      return asU8A(buf2.chunks[0]);
    }
  }
  buf.reset();
  tokensToEncoded(buf, tokens, encoders, options);
  return buf.toBytes(true);
}
function encode3(data, options) {
  options = Object.assign({}, defaultEncodeOptions, options);
  return encodeCustom(data, cborEncoders, options);
}

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/decode.js
var defaultDecodeOptions = {
  strict: false,
  allowIndefinite: true,
  allowUndefined: true,
  allowBigInt: true
};
var Tokeniser = class {
  constructor(data, options = {}) {
    this.pos = 0;
    this.data = data;
    this.options = options;
  }
  done() {
    return this.pos >= this.data.length;
  }
  next() {
    const byt = this.data[this.pos];
    let token = quick[byt];
    if (token === void 0) {
      const decoder2 = jump[byt];
      if (!decoder2) {
        throw new Error(`${decodeErrPrefix} no decoder for major type ${byt >>> 5} (byte 0x${byt.toString(16).padStart(2, "0")})`);
      }
      const minor = byt & 31;
      token = decoder2(this.data, this.pos, minor, this.options);
    }
    this.pos += token.encodedLength;
    return token;
  }
};
var DONE = Symbol.for("DONE");
var BREAK = Symbol.for("BREAK");
function tokenToArray(token, tokeniser, options) {
  const arr = [];
  for (let i = 0; i < token.value; i++) {
    const value = tokensToObject(tokeniser, options);
    if (value === BREAK) {
      if (token.value === Infinity) {
        break;
      }
      throw new Error(`${decodeErrPrefix} got unexpected break to lengthed array`);
    }
    if (value === DONE) {
      throw new Error(`${decodeErrPrefix} found array but not enough entries (got ${i}, expected ${token.value})`);
    }
    arr[i] = value;
  }
  return arr;
}
function tokenToMap(token, tokeniser, options) {
  const useMaps = options.useMaps === true;
  const obj = useMaps ? void 0 : {};
  const m = useMaps ? /* @__PURE__ */ new Map() : void 0;
  for (let i = 0; i < token.value; i++) {
    const key = tokensToObject(tokeniser, options);
    if (key === BREAK) {
      if (token.value === Infinity) {
        break;
      }
      throw new Error(`${decodeErrPrefix} got unexpected break to lengthed map`);
    }
    if (key === DONE) {
      throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${i} [no key], expected ${token.value})`);
    }
    if (useMaps !== true && typeof key !== "string") {
      throw new Error(`${decodeErrPrefix} non-string keys not supported (got ${typeof key})`);
    }
    if (options.rejectDuplicateMapKeys === true) {
      if (useMaps && m.has(key) || !useMaps && key in obj) {
        throw new Error(`${decodeErrPrefix} found repeat map key "${key}"`);
      }
    }
    const value = tokensToObject(tokeniser, options);
    if (value === DONE) {
      throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${i} [no value], expected ${token.value})`);
    }
    if (useMaps) {
      m.set(key, value);
    } else {
      obj[key] = value;
    }
  }
  return useMaps ? m : obj;
}
function tokensToObject(tokeniser, options) {
  if (tokeniser.done()) {
    return DONE;
  }
  const token = tokeniser.next();
  if (token.type === Type.break) {
    return BREAK;
  }
  if (token.type.terminal) {
    return token.value;
  }
  if (token.type === Type.array) {
    return tokenToArray(token, tokeniser, options);
  }
  if (token.type === Type.map) {
    return tokenToMap(token, tokeniser, options);
  }
  if (token.type === Type.tag) {
    if (options.tags && typeof options.tags[token.value] === "function") {
      const tagged = tokensToObject(tokeniser, options);
      return options.tags[token.value](tagged);
    }
    throw new Error(`${decodeErrPrefix} tag not supported (${token.value})`);
  }
  throw new Error("unsupported");
}
function decode5(data, options) {
  if (!(data instanceof Uint8Array)) {
    throw new Error(`${decodeErrPrefix} data to decode must be a Uint8Array`);
  }
  options = Object.assign({}, defaultDecodeOptions, options);
  const tokeniser = options.tokenizer || new Tokeniser(data, options);
  const decoded = tokensToObject(tokeniser, options);
  if (decoded === DONE) {
    throw new Error(`${decodeErrPrefix} did not find any content to decode`);
  }
  if (decoded === BREAK) {
    throw new Error(`${decodeErrPrefix} got unexpected break`);
  }
  if (!tokeniser.done()) {
    throw new Error(`${decodeErrPrefix} too many terminals, data makes no sense`);
  }
  return decoded;
}

// ../../node_modules/.pnpm/@ipld+dag-cbor@7.0.3/node_modules/@ipld/dag-cbor/esm/index.js
var CID_CBOR_TAG = 42;
function cidEncoder(obj) {
  if (obj.asCID !== obj) {
    return null;
  }
  const cid = CID.asCID(obj);
  if (!cid) {
    return null;
  }
  const bytes = new Uint8Array(cid.bytes.byteLength + 1);
  bytes.set(cid.bytes, 1);
  return [
    new Token(Type.tag, CID_CBOR_TAG),
    new Token(Type.bytes, bytes)
  ];
}
function undefinedEncoder() {
  throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded");
}
function numberEncoder(num) {
  if (Number.isNaN(num)) {
    throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded");
  }
  if (num === Infinity || num === -Infinity) {
    throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded");
  }
  return null;
}
var encodeOptions = {
  float64: true,
  typeEncoders: {
    Object: cidEncoder,
    undefined: undefinedEncoder,
    number: numberEncoder
  }
};
function cidDecoder(bytes) {
  if (bytes[0] !== 0) {
    throw new Error("Invalid CID for CBOR tag 42; expected leading 0x00");
  }
  return CID.decode(bytes.subarray(1));
}
var decodeOptions = {
  allowIndefinite: false,
  coerceUndefinedToNull: true,
  allowNaN: false,
  allowInfinity: false,
  allowBigInt: true,
  strict: true,
  useMaps: false,
  tags: []
};
decodeOptions.tags[CID_CBOR_TAG] = cidDecoder;
var encode4 = (node) => encode3(node, encodeOptions);
var decode6 = (data) => decode5(data, decodeOptions);

// ../../node_modules/.pnpm/@ipld+car@3.2.4/node_modules/@ipld/car/esm/lib/decoder.js
var CIDV0_BYTES = {
  SHA2_256: 18,
  LENGTH: 32,
  DAG_PB: 112
};
function readVarint(reader) {
  return __async(this, null, function* () {
    const bytes = yield reader.upTo(8);
    const i = import_varint2.default.decode(bytes);
    reader.seek(import_varint2.default.decode.bytes);
    return i;
  });
}
function readHeader(reader) {
  return __async(this, null, function* () {
    const length2 = yield readVarint(reader);
    if (length2 === 0) {
      throw new Error("Invalid CAR header (zero length)");
    }
    const header = yield reader.exactly(length2);
    reader.seek(length2);
    const block = decode6(header);
    if (block == null || Array.isArray(block) || typeof block !== "object") {
      throw new Error("Invalid CAR header format");
    }
    if (block.version !== 1) {
      if (typeof block.version === "string") {
        throw new Error(`Invalid CAR version: "${block.version}"`);
      }
      throw new Error(`Invalid CAR version: ${block.version}`);
    }
    if (!Array.isArray(block.roots)) {
      throw new Error("Invalid CAR header format");
    }
    if (Object.keys(block).filter((p) => p !== "roots" && p !== "version").length) {
      throw new Error("Invalid CAR header format");
    }
    return block;
  });
}
function readMultihash(reader) {
  return __async(this, null, function* () {
    const bytes = yield reader.upTo(8);
    import_varint2.default.decode(bytes);
    const codeLength = import_varint2.default.decode.bytes;
    const length2 = import_varint2.default.decode(bytes.subarray(import_varint2.default.decode.bytes));
    const lengthLength = import_varint2.default.decode.bytes;
    const mhLength = codeLength + lengthLength + length2;
    const multihash = yield reader.exactly(mhLength);
    reader.seek(mhLength);
    return multihash;
  });
}
function readCid(reader) {
  return __async(this, null, function* () {
    const first = yield reader.exactly(2);
    if (first[0] === CIDV0_BYTES.SHA2_256 && first[1] === CIDV0_BYTES.LENGTH) {
      const bytes2 = yield reader.exactly(34);
      reader.seek(34);
      const multihash2 = decode3(bytes2);
      return CID.create(0, CIDV0_BYTES.DAG_PB, multihash2);
    }
    const version2 = yield readVarint(reader);
    if (version2 !== 1) {
      throw new Error(`Unexpected CID version (${version2})`);
    }
    const codec = yield readVarint(reader);
    const bytes = yield readMultihash(reader);
    const multihash = decode3(bytes);
    return CID.create(version2, codec, multihash);
  });
}
function readBlockHead(reader) {
  return __async(this, null, function* () {
    const start = reader.pos;
    let length2 = yield readVarint(reader);
    if (length2 === 0) {
      throw new Error("Invalid CAR section (zero length)");
    }
    length2 += reader.pos - start;
    const cid = yield readCid(reader);
    const blockLength = length2 - (reader.pos - start);
    return {
      cid,
      length: length2,
      blockLength
    };
  });
}
function readBlock(reader) {
  return __async(this, null, function* () {
    const { cid, blockLength } = yield readBlockHead(reader);
    const bytes = yield reader.exactly(blockLength);
    reader.seek(blockLength);
    return {
      bytes,
      cid
    };
  });
}
function readBlockIndex(reader) {
  return __async(this, null, function* () {
    const offset = reader.pos;
    const { cid, length: length2, blockLength } = yield readBlockHead(reader);
    const index = {
      cid,
      length: length2,
      blockLength,
      offset,
      blockOffset: reader.pos
    };
    reader.seek(index.blockLength);
    return index;
  });
}
function createDecoder(reader) {
  const headerPromise = readHeader(reader);
  return {
    header: () => headerPromise,
    blocks() {
      return __asyncGenerator(this, null, function* () {
        yield new __await(headerPromise);
        while ((yield new __await(reader.upTo(8))).length > 0) {
          yield yield new __await(readBlock(reader));
        }
      });
    },
    blocksIndex() {
      return __asyncGenerator(this, null, function* () {
        yield new __await(headerPromise);
        while ((yield new __await(reader.upTo(8))).length > 0) {
          yield yield new __await(readBlockIndex(reader));
        }
      });
    }
  };
}
function bytesReader(bytes) {
  let pos = 0;
  return {
    upTo(length2) {
      return __async(this, null, function* () {
        return bytes.subarray(pos, pos + Math.min(length2, bytes.length - pos));
      });
    },
    exactly(length2) {
      return __async(this, null, function* () {
        if (length2 > bytes.length - pos) {
          throw new Error("Unexpected end of data");
        }
        return bytes.subarray(pos, pos + length2);
      });
    },
    seek(length2) {
      pos += length2;
    },
    get pos() {
      return pos;
    }
  };
}
function chunkReader(readChunk) {
  let pos = 0;
  let have = 0;
  let offset = 0;
  let currentChunk = new Uint8Array(0);
  const read2 = (length2) => __async(this, null, function* () {
    have = currentChunk.length - offset;
    const bufa = [currentChunk.subarray(offset)];
    while (have < length2) {
      const chunk = yield readChunk();
      if (chunk == null) {
        break;
      }
      if (have < 0) {
        if (chunk.length > have) {
          bufa.push(chunk.subarray(-have));
        }
      } else {
        bufa.push(chunk);
      }
      have += chunk.length;
    }
    currentChunk = new Uint8Array(bufa.reduce((p, c) => p + c.length, 0));
    let off = 0;
    for (const b of bufa) {
      currentChunk.set(b, off);
      off += b.length;
    }
    offset = 0;
  });
  return {
    upTo(length2) {
      return __async(this, null, function* () {
        if (currentChunk.length - offset < length2) {
          yield read2(length2);
        }
        return currentChunk.subarray(offset, offset + Math.min(currentChunk.length - offset, length2));
      });
    },
    exactly(length2) {
      return __async(this, null, function* () {
        if (currentChunk.length - offset < length2) {
          yield read2(length2);
        }
        if (currentChunk.length - offset < length2) {
          throw new Error("Unexpected end of data");
        }
        return currentChunk.subarray(offset, offset + length2);
      });
    },
    seek(length2) {
      pos += length2;
      offset += length2;
    },
    get pos() {
      return pos;
    }
  };
}
function asyncIterableReader(asyncIterable) {
  const iterator = asyncIterable[Symbol.asyncIterator]();
  function readChunk() {
    return __async(this, null, function* () {
      const next = yield iterator.next();
      if (next.done) {
        return null;
      }
      return next.value;
    });
  }
  return chunkReader(readChunk);
}

// ../../node_modules/.pnpm/@ipld+car@3.2.4/node_modules/@ipld/car/esm/lib/reader-browser.js
var CarReader = class {
  constructor(version2, roots, blocks) {
    this._version = version2;
    this._roots = roots;
    this._blocks = blocks;
    this._keys = blocks.map((b) => b.cid.toString());
  }
  get version() {
    return this._version;
  }
  getRoots() {
    return __async(this, null, function* () {
      return this._roots;
    });
  }
  has(key) {
    return __async(this, null, function* () {
      return this._keys.indexOf(key.toString()) > -1;
    });
  }
  get(key) {
    return __async(this, null, function* () {
      const index = this._keys.indexOf(key.toString());
      return index > -1 ? this._blocks[index] : void 0;
    });
  }
  blocks() {
    return __asyncGenerator(this, null, function* () {
      for (const block of this._blocks) {
        yield block;
      }
    });
  }
  cids() {
    return __asyncGenerator(this, null, function* () {
      for (const block of this._blocks) {
        yield block.cid;
      }
    });
  }
  static fromBytes(bytes) {
    return __async(this, null, function* () {
      if (!(bytes instanceof Uint8Array)) {
        throw new TypeError("fromBytes() requires a Uint8Array");
      }
      return decodeReaderComplete(bytesReader(bytes));
    });
  }
  static fromIterable(asyncIterable) {
    return __async(this, null, function* () {
      if (!asyncIterable || !(typeof asyncIterable[Symbol.asyncIterator] === "function")) {
        throw new TypeError("fromIterable() requires an async iterable");
      }
      return decodeReaderComplete(asyncIterableReader(asyncIterable));
    });
  }
};
function decodeReaderComplete(reader) {
  return __async(this, null, function* () {
    const decoder2 = createDecoder(reader);
    const { version: version2, roots } = yield decoder2.header();
    const blocks = [];
    try {
      for (var iter = __forAwait(decoder2.blocks()), more, temp, error; more = !(temp = yield iter.next()).done; more = false) {
        const block = temp.value;
        blocks.push(block);
      }
    } catch (temp) {
      error = [temp];
    } finally {
      try {
        more && (temp = iter.return) && (yield temp.call(iter));
      } finally {
        if (error)
          throw error[0];
      }
    }
    return new CarReader(version2, roots, blocks);
  });
}

// ../../node_modules/.pnpm/@ipld+car@3.2.4/node_modules/@ipld/car/esm/lib/reader.js
var fsread = promisify(fs.read);
var CarReader2 = class extends CarReader {
  static readRaw(fd, blockIndex) {
    return __async(this, null, function* () {
      const { cid, blockLength, blockOffset } = blockIndex;
      const bytes = new Uint8Array(blockLength);
      let read2;
      if (typeof fd === "number") {
        read2 = (yield fsread(fd, bytes, 0, blockLength, blockOffset)).bytesRead;
      } else if (typeof fd === "object" && typeof fd.read === "function") {
        read2 = (yield fd.read(bytes, 0, blockLength, blockOffset)).bytesRead;
      } else {
        throw new TypeError("Bad fd");
      }
      if (read2 !== blockLength) {
        throw new Error(`Failed to read entire block (${read2} instead of ${blockLength})`);
      }
      return {
        cid,
        bytes
      };
    });
  }
};

// ../../node_modules/.pnpm/@ipld+car@3.2.4/node_modules/@ipld/car/esm/lib/indexer.js
var CarIndexer = class {
  constructor(version2, roots, iterator) {
    this._version = version2;
    this._roots = roots;
    this._iterator = iterator;
  }
  get version() {
    return this._version;
  }
  getRoots() {
    return __async(this, null, function* () {
      return this._roots;
    });
  }
  [Symbol.asyncIterator]() {
    return this._iterator;
  }
  static fromBytes(bytes) {
    return __async(this, null, function* () {
      if (!(bytes instanceof Uint8Array)) {
        throw new TypeError("fromBytes() requires a Uint8Array");
      }
      return decodeIndexerComplete(bytesReader(bytes));
    });
  }
  static fromIterable(asyncIterable) {
    return __async(this, null, function* () {
      if (!asyncIterable || !(typeof asyncIterable[Symbol.asyncIterator] === "function")) {
        throw new TypeError("fromIterable() requires an async iterable");
      }
      return decodeIndexerComplete(asyncIterableReader(asyncIterable));
    });
  }
};
function decodeIndexerComplete(reader) {
  return __async(this, null, function* () {
    const decoder2 = createDecoder(reader);
    const { version: version2, roots } = yield decoder2.header();
    return new CarIndexer(version2, roots, decoder2.blocksIndex());
  });
}

// ../../node_modules/.pnpm/@ipld+car@3.2.4/node_modules/@ipld/car/esm/lib/iterator.js
var CarIteratorBase = class {
  constructor(version2, roots, iterable) {
    this._version = version2;
    this._roots = roots;
    this._iterable = iterable;
    this._decoded = false;
  }
  get version() {
    return this._version;
  }
  getRoots() {
    return __async(this, null, function* () {
      return this._roots;
    });
  }
};
var CarBlockIterator = class _CarBlockIterator extends CarIteratorBase {
  [Symbol.asyncIterator]() {
    if (this._decoded) {
      throw new Error("Cannot decode more than once");
    }
    if (!this._iterable) {
      throw new Error("Block iterable not found");
    }
    this._decoded = true;
    return this._iterable[Symbol.asyncIterator]();
  }
  static fromBytes(bytes) {
    return __async(this, null, function* () {
      const { version: version2, roots, iterator } = yield fromBytes(bytes);
      return new _CarBlockIterator(version2, roots, iterator);
    });
  }
  static fromIterable(asyncIterable) {
    return __async(this, null, function* () {
      const { version: version2, roots, iterator } = yield fromIterable(asyncIterable);
      return new _CarBlockIterator(version2, roots, iterator);
    });
  }
};
var CarCIDIterator = class _CarCIDIterator extends CarIteratorBase {
  [Symbol.asyncIterator]() {
    if (this._decoded) {
      throw new Error("Cannot decode more than once");
    }
    if (!this._iterable) {
      throw new Error("Block iterable not found");
    }
    this._decoded = true;
    const iterable = this._iterable[Symbol.asyncIterator]();
    return {
      next() {
        return __async(this, null, function* () {
          const next = yield iterable.next();
          if (next.done) {
            return next;
          }
          return {
            done: false,
            value: next.value.cid
          };
        });
      }
    };
  }
  static fromBytes(bytes) {
    return __async(this, null, function* () {
      const { version: version2, roots, iterator } = yield fromBytes(bytes);
      return new _CarCIDIterator(version2, roots, iterator);
    });
  }
  static fromIterable(asyncIterable) {
    return __async(this, null, function* () {
      const { version: version2, roots, iterator } = yield fromIterable(asyncIterable);
      return new _CarCIDIterator(version2, roots, iterator);
    });
  }
};
function fromBytes(bytes) {
  return __async(this, null, function* () {
    if (!(bytes instanceof Uint8Array)) {
      throw new TypeError("fromBytes() requires a Uint8Array");
    }
    return decodeIterator(bytesReader(bytes));
  });
}
function fromIterable(asyncIterable) {
  return __async(this, null, function* () {
    if (!asyncIterable || !(typeof asyncIterable[Symbol.asyncIterator] === "function")) {
      throw new TypeError("fromIterable() requires an async iterable");
    }
    return decodeIterator(asyncIterableReader(asyncIterable));
  });
}
function decodeIterator(reader) {
  return __async(this, null, function* () {
    const decoder2 = createDecoder(reader);
    const { version: version2, roots } = yield decoder2.header();
    return {
      version: version2,
      roots,
      iterator: decoder2.blocks()
    };
  });
}

// ../../node_modules/.pnpm/@ipld+car@3.2.4/node_modules/@ipld/car/esm/lib/writer.js
import fs2 from "fs";
import { promisify as promisify2 } from "util";

// ../../node_modules/.pnpm/@ipld+car@3.2.4/node_modules/@ipld/car/esm/lib/encoder.js
var import_varint3 = __toESM(require_varint(), 1);
function createHeader(roots) {
  const headerBytes = encode4({
    version: 1,
    roots
  });
  const varintBytes = import_varint3.default.encode(headerBytes.length);
  const header = new Uint8Array(varintBytes.length + headerBytes.length);
  header.set(varintBytes, 0);
  header.set(headerBytes, varintBytes.length);
  return header;
}
function createEncoder(writer) {
  return {
    setRoots(roots) {
      return __async(this, null, function* () {
        const bytes = createHeader(roots);
        yield writer.write(bytes);
      });
    },
    writeBlock(block) {
      return __async(this, null, function* () {
        const { cid, bytes } = block;
        yield writer.write(new Uint8Array(import_varint3.default.encode(cid.bytes.length + bytes.length)));
        yield writer.write(cid.bytes);
        if (bytes.length) {
          yield writer.write(bytes);
        }
      });
    },
    close() {
      return __async(this, null, function* () {
        return writer.end();
      });
    }
  };
}

// ../../node_modules/.pnpm/@ipld+car@3.2.4/node_modules/@ipld/car/esm/lib/iterator-channel.js
function noop() {
}
function create2() {
  const chunkQueue = [];
  let drainer = null;
  let drainerResolver = noop;
  let ended = false;
  let outWait = null;
  let outWaitResolver = noop;
  const makeDrainer = () => {
    if (!drainer) {
      drainer = new Promise((resolve) => {
        drainerResolver = () => {
          drainer = null;
          drainerResolver = noop;
          resolve();
        };
      });
    }
    return drainer;
  };
  const writer = {
    write(chunk) {
      chunkQueue.push(chunk);
      const drainer2 = makeDrainer();
      outWaitResolver();
      return drainer2;
    },
    end() {
      return __async(this, null, function* () {
        ended = true;
        const drainer2 = makeDrainer();
        outWaitResolver();
        return drainer2;
      });
    }
  };
  const iterator = {
    next() {
      return __async(this, null, function* () {
        const chunk = chunkQueue.shift();
        if (chunk) {
          if (chunkQueue.length === 0) {
            drainerResolver();
          }
          return {
            done: false,
            value: chunk
          };
        }
        if (ended) {
          drainerResolver();
          return {
            done: true,
            value: void 0
          };
        }
        if (!outWait) {
          outWait = new Promise((resolve) => {
            outWaitResolver = () => {
              outWait = null;
              outWaitResolver = noop;
              return resolve(iterator.next());
            };
          });
        }
        return outWait;
      });
    }
  };
  return {
    writer,
    iterator
  };
}

// ../../node_modules/.pnpm/@ipld+car@3.2.4/node_modules/@ipld/car/esm/lib/writer-browser.js
var CarWriter = class _CarWriter {
  constructor(roots, encoder2) {
    this._encoder = encoder2;
    this._mutex = encoder2.setRoots(roots);
    this._ended = false;
  }
  put(block) {
    return __async(this, null, function* () {
      if (!(block.bytes instanceof Uint8Array) || !block.cid) {
        throw new TypeError("Can only write {cid, bytes} objects");
      }
      if (this._ended) {
        throw new Error("Already closed");
      }
      const cid = CID.asCID(block.cid);
      if (!cid) {
        throw new TypeError("Can only write {cid, bytes} objects");
      }
      this._mutex = this._mutex.then(() => this._encoder.writeBlock({
        cid,
        bytes: block.bytes
      }));
      return this._mutex;
    });
  }
  close() {
    return __async(this, null, function* () {
      if (this._ended) {
        throw new Error("Already closed");
      }
      yield this._mutex;
      this._ended = true;
      return this._encoder.close();
    });
  }
  static create(roots) {
    roots = toRoots(roots);
    const { encoder: encoder2, iterator } = encodeWriter();
    const writer = new _CarWriter(roots, encoder2);
    const out = new CarWriterOut(iterator);
    return {
      writer,
      out
    };
  }
  static createAppender() {
    const { encoder: encoder2, iterator } = encodeWriter();
    encoder2.setRoots = () => Promise.resolve();
    const writer = new _CarWriter([], encoder2);
    const out = new CarWriterOut(iterator);
    return {
      writer,
      out
    };
  }
  static updateRootsInBytes(bytes, roots) {
    return __async(this, null, function* () {
      const reader = bytesReader(bytes);
      yield readHeader(reader);
      const newHeader = createHeader(roots);
      if (reader.pos !== newHeader.length) {
        throw new Error(`updateRoots() can only overwrite a header of the same length (old header is ${reader.pos} bytes, new header is ${newHeader.length} bytes)`);
      }
      bytes.set(newHeader, 0);
      return bytes;
    });
  }
};
var CarWriterOut = class {
  constructor(iterator) {
    this._iterator = iterator;
  }
  [Symbol.asyncIterator]() {
    if (this._iterating) {
      throw new Error("Multiple iterator not supported");
    }
    this._iterating = true;
    return this._iterator;
  }
};
function encodeWriter() {
  const iw = create2();
  const { writer, iterator } = iw;
  const encoder2 = createEncoder(writer);
  return {
    encoder: encoder2,
    iterator
  };
}
function toRoots(roots) {
  if (roots === void 0) {
    return [];
  }
  if (!Array.isArray(roots)) {
    const cid = CID.asCID(roots);
    if (!cid) {
      throw new TypeError("roots must be a single CID or an array of CIDs");
    }
    return [cid];
  }
  const _roots = [];
  for (const root of roots) {
    const _root = CID.asCID(root);
    if (!_root) {
      throw new TypeError("roots must be a single CID or an array of CIDs");
    }
    _roots.push(_root);
  }
  return _roots;
}

// ../../node_modules/.pnpm/@ipld+car@3.2.4/node_modules/@ipld/car/esm/lib/writer.js
var fsread2 = promisify2(fs2.read);
var fswrite = promisify2(fs2.write);
var CarWriter2 = class extends CarWriter {
  static updateRootsInFile(fd, roots) {
    return __async(this, null, function* () {
      const chunkSize = 256;
      let bytes;
      let offset = 0;
      let readChunk;
      if (typeof fd === "number") {
        readChunk = () => __async(this, null, function* () {
          return (yield fsread2(fd, bytes, 0, chunkSize, offset)).bytesRead;
        });
      } else if (typeof fd === "object" && typeof fd.read === "function") {
        readChunk = () => __async(this, null, function* () {
          return (yield fd.read(bytes, 0, chunkSize, offset)).bytesRead;
        });
      } else {
        throw new TypeError("Bad fd");
      }
      const fdReader = chunkReader(() => __async(this, null, function* () {
        bytes = new Uint8Array(chunkSize);
        const read2 = yield readChunk();
        offset += read2;
        return read2 < chunkSize ? bytes.subarray(0, read2) : bytes;
      }));
      yield readHeader(fdReader);
      const newHeader = createHeader(roots);
      if (fdReader.pos !== newHeader.length) {
        throw new Error(`updateRoots() can only overwrite a header of the same length (old header is ${fdReader.pos} bytes, new header is ${newHeader.length} bytes)`);
      }
      if (typeof fd === "number") {
        yield fswrite(fd, newHeader, 0, newHeader.length, 0);
      } else if (typeof fd === "object" && typeof fd.read === "function") {
        yield fd.write(newHeader, 0, newHeader.length, 0);
      }
    });
  }
};

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/hashes/hasher.js
var from2 = ({ name: name5, code: code5, encode: encode12 }) => new Hasher(name5, code5, encode12);
var Hasher = class {
  constructor(name5, code5, encode12) {
    this.name = name5;
    this.code = code5;
    this.encode = encode12;
  }
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create(this.code, result) : result.then((digest2) => create(this.code, digest2));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/block.js
var readonly2 = ({ enumerable = true, configurable = false } = {}) => ({
  enumerable,
  configurable,
  writable: false
});
var links = function* (source, base3) {
  if (source == null)
    return;
  if (source instanceof Uint8Array)
    return;
  for (const [key, value] of Object.entries(source)) {
    const path = [
      ...base3,
      key
    ];
    if (value != null && typeof value === "object") {
      if (Array.isArray(value)) {
        for (const [index, element] of value.entries()) {
          const elementPath = [
            ...path,
            index
          ];
          const cid = CID.asCID(element);
          if (cid) {
            yield [
              elementPath.join("/"),
              cid
            ];
          } else if (typeof element === "object") {
            yield* __yieldStar(links(element, elementPath));
          }
        }
      } else {
        const cid = CID.asCID(value);
        if (cid) {
          yield [
            path.join("/"),
            cid
          ];
        } else {
          yield* __yieldStar(links(value, path));
        }
      }
    }
  }
};
var tree = function* (source, base3) {
  if (source == null)
    return;
  for (const [key, value] of Object.entries(source)) {
    const path = [
      ...base3,
      key
    ];
    yield path.join("/");
    if (value != null && !(value instanceof Uint8Array) && typeof value === "object" && !CID.asCID(value)) {
      if (Array.isArray(value)) {
        for (const [index, element] of value.entries()) {
          const elementPath = [
            ...path,
            index
          ];
          yield elementPath.join("/");
          if (typeof element === "object" && !CID.asCID(element)) {
            yield* __yieldStar(tree(element, elementPath));
          }
        }
      } else {
        yield* __yieldStar(tree(value, path));
      }
    }
  }
};
var get = (source, path) => {
  let node = source;
  for (const [index, key] of path.entries()) {
    node = node[key];
    if (node == null) {
      throw new Error(`Object has no property at ${path.slice(0, index + 1).map((part) => `[${JSON.stringify(part)}]`).join("")}`);
    }
    const cid = CID.asCID(node);
    if (cid) {
      return {
        value: cid,
        remaining: path.slice(index + 1).join("/")
      };
    }
  }
  return { value: node };
};
var Block = class {
  constructor({ cid, bytes, value }) {
    if (!cid || !bytes || typeof value === "undefined")
      throw new Error("Missing required argument");
    this.cid = cid;
    this.bytes = bytes;
    this.value = value;
    this.asBlock = this;
    Object.defineProperties(this, {
      cid: readonly2(),
      bytes: readonly2(),
      value: readonly2(),
      asBlock: readonly2()
    });
  }
  links() {
    return links(this.value, []);
  }
  tree() {
    return tree(this.value, []);
  }
  get(path = "/") {
    return get(this.value, path.split("/").filter(Boolean));
  }
};
var encode5 = (_0) => __async(void 0, [_0], function* ({ value, codec, hasher }) {
  if (typeof value === "undefined")
    throw new Error('Missing required argument "value"');
  if (!codec || !hasher)
    throw new Error("Missing required argument: codec or hasher");
  const bytes = codec.encode(value);
  const hash = yield hasher.digest(bytes);
  const cid = CID.create(1, codec.code, hash);
  return new Block({
    value,
    bytes,
    cid
  });
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/codecs/raw.js
var raw_exports = {};
__export(raw_exports, {
  code: () => code,
  decode: () => decode7,
  encode: () => encode6,
  name: () => name
});
var name = "raw";
var code = 85;
var encode6 = (node) => coerce(node);
var decode7 = (data) => coerce(data);

// ../../node_modules/.pnpm/@ipld+dag-cbor@6.0.15/node_modules/@ipld/dag-cbor/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  code: () => code2,
  decode: () => decode8,
  encode: () => encode7,
  name: () => name2
});
var CID_CBOR_TAG2 = 42;
function cidEncoder2(obj) {
  if (obj.asCID !== obj) {
    return null;
  }
  const cid = CID.asCID(obj);
  if (!cid) {
    return null;
  }
  const bytes = new Uint8Array(cid.bytes.byteLength + 1);
  bytes.set(cid.bytes, 1);
  return [
    new Token(Type.tag, CID_CBOR_TAG2),
    new Token(Type.bytes, bytes)
  ];
}
function undefinedEncoder2() {
  throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded");
}
function numberEncoder2(num) {
  if (Number.isNaN(num)) {
    throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded");
  }
  if (num === Infinity || num === -Infinity) {
    throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded");
  }
  return null;
}
var encodeOptions2 = {
  float64: true,
  typeEncoders: {
    Object: cidEncoder2,
    undefined: undefinedEncoder2,
    number: numberEncoder2
  }
};
function cidDecoder2(bytes) {
  if (bytes[0] !== 0) {
    throw new Error("Invalid CID for CBOR tag 42; expected leading 0x00");
  }
  return CID.decode(bytes.subarray(1));
}
var decodeOptions2 = {
  allowIndefinite: false,
  allowUndefined: false,
  allowNaN: false,
  allowInfinity: false,
  allowBigInt: true,
  strict: true,
  useMaps: false,
  tags: []
};
decodeOptions2.tags[CID_CBOR_TAG2] = cidDecoder2;
var name2 = "dag-cbor";
var code2 = 113;
var encode7 = (node) => encode3(node, encodeOptions2);
var decode8 = (data) => decode5(data, decodeOptions2);

// ../../node_modules/.pnpm/@ipld+dag-pb@2.1.18/node_modules/@ipld/dag-pb/esm/src/index.js
var src_exports = {};
__export(src_exports, {
  code: () => code3,
  createLink: () => createLink,
  createNode: () => createNode,
  decode: () => decode9,
  encode: () => encode8,
  name: () => name3,
  prepare: () => prepare,
  validate: () => validate
});

// ../../node_modules/.pnpm/@ipld+dag-pb@2.1.18/node_modules/@ipld/dag-pb/esm/src/pb-decode.js
var textDecoder2 = new TextDecoder();
function decodeVarint(bytes, offset) {
  let v = 0;
  for (let shift = 0; ; shift += 7) {
    if (shift >= 64) {
      throw new Error("protobuf: varint overflow");
    }
    if (offset >= bytes.length) {
      throw new Error("protobuf: unexpected end of data");
    }
    const b = bytes[offset++];
    v += shift < 28 ? (b & 127) << shift : (b & 127) * 2 ** shift;
    if (b < 128) {
      break;
    }
  }
  return [
    v,
    offset
  ];
}
function decodeBytes(bytes, offset) {
  let byteLen;
  [byteLen, offset] = decodeVarint(bytes, offset);
  const postOffset = offset + byteLen;
  if (byteLen < 0 || postOffset < 0) {
    throw new Error("protobuf: invalid length");
  }
  if (postOffset > bytes.length) {
    throw new Error("protobuf: unexpected end of data");
  }
  return [
    bytes.subarray(offset, postOffset),
    postOffset
  ];
}
function decodeKey(bytes, index) {
  let wire;
  [wire, index] = decodeVarint(bytes, index);
  return [
    wire & 7,
    wire >> 3,
    index
  ];
}
function decodeLink(bytes) {
  const link = {};
  const l = bytes.length;
  let index = 0;
  while (index < l) {
    let wireType, fieldNum;
    [wireType, fieldNum, index] = decodeKey(bytes, index);
    if (fieldNum === 1) {
      if (link.Hash) {
        throw new Error("protobuf: (PBLink) duplicate Hash section");
      }
      if (wireType !== 2) {
        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Hash`);
      }
      if (link.Name !== void 0) {
        throw new Error("protobuf: (PBLink) invalid order, found Name before Hash");
      }
      if (link.Tsize !== void 0) {
        throw new Error("protobuf: (PBLink) invalid order, found Tsize before Hash");
      }
      ;
      [link.Hash, index] = decodeBytes(bytes, index);
    } else if (fieldNum === 2) {
      if (link.Name !== void 0) {
        throw new Error("protobuf: (PBLink) duplicate Name section");
      }
      if (wireType !== 2) {
        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Name`);
      }
      if (link.Tsize !== void 0) {
        throw new Error("protobuf: (PBLink) invalid order, found Tsize before Name");
      }
      let byts;
      [byts, index] = decodeBytes(bytes, index);
      link.Name = textDecoder2.decode(byts);
    } else if (fieldNum === 3) {
      if (link.Tsize !== void 0) {
        throw new Error("protobuf: (PBLink) duplicate Tsize section");
      }
      if (wireType !== 0) {
        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Tsize`);
      }
      ;
      [link.Tsize, index] = decodeVarint(bytes, index);
    } else {
      throw new Error(`protobuf: (PBLink) invalid fieldNumber, expected 1, 2 or 3, got ${fieldNum}`);
    }
  }
  if (index > l) {
    throw new Error("protobuf: (PBLink) unexpected end of data");
  }
  return link;
}
function decodeNode(bytes) {
  const l = bytes.length;
  let index = 0;
  let links2;
  let linksBeforeData = false;
  let data;
  while (index < l) {
    let wireType, fieldNum;
    [wireType, fieldNum, index] = decodeKey(bytes, index);
    if (wireType !== 2) {
      throw new Error(`protobuf: (PBNode) invalid wireType, expected 2, got ${wireType}`);
    }
    if (fieldNum === 1) {
      if (data) {
        throw new Error("protobuf: (PBNode) duplicate Data section");
      }
      ;
      [data, index] = decodeBytes(bytes, index);
      if (links2) {
        linksBeforeData = true;
      }
    } else if (fieldNum === 2) {
      if (linksBeforeData) {
        throw new Error("protobuf: (PBNode) duplicate Links section");
      } else if (!links2) {
        links2 = [];
      }
      let byts;
      [byts, index] = decodeBytes(bytes, index);
      links2.push(decodeLink(byts));
    } else {
      throw new Error(`protobuf: (PBNode) invalid fieldNumber, expected 1 or 2, got ${fieldNum}`);
    }
  }
  if (index > l) {
    throw new Error("protobuf: (PBNode) unexpected end of data");
  }
  const node = {};
  if (data) {
    node.Data = data;
  }
  node.Links = links2 || [];
  return node;
}

// ../../node_modules/.pnpm/@ipld+dag-pb@2.1.18/node_modules/@ipld/dag-pb/esm/src/pb-encode.js
var textEncoder2 = new TextEncoder();
var maxInt32 = 2 ** 32;
var maxUInt32 = 2 ** 31;
function encodeLink(link, bytes) {
  let i = bytes.length;
  if (typeof link.Tsize === "number") {
    if (link.Tsize < 0) {
      throw new Error("Tsize cannot be negative");
    }
    if (!Number.isSafeInteger(link.Tsize)) {
      throw new Error("Tsize too large for encoding");
    }
    i = encodeVarint(bytes, i, link.Tsize) - 1;
    bytes[i] = 24;
  }
  if (typeof link.Name === "string") {
    const nameBytes = textEncoder2.encode(link.Name);
    i -= nameBytes.length;
    bytes.set(nameBytes, i);
    i = encodeVarint(bytes, i, nameBytes.length) - 1;
    bytes[i] = 18;
  }
  if (link.Hash) {
    i -= link.Hash.length;
    bytes.set(link.Hash, i);
    i = encodeVarint(bytes, i, link.Hash.length) - 1;
    bytes[i] = 10;
  }
  return bytes.length - i;
}
function encodeNode(node) {
  const size = sizeNode(node);
  const bytes = new Uint8Array(size);
  let i = size;
  if (node.Data) {
    i -= node.Data.length;
    bytes.set(node.Data, i);
    i = encodeVarint(bytes, i, node.Data.length) - 1;
    bytes[i] = 10;
  }
  if (node.Links) {
    for (let index = node.Links.length - 1; index >= 0; index--) {
      const size2 = encodeLink(node.Links[index], bytes.subarray(0, i));
      i -= size2;
      i = encodeVarint(bytes, i, size2) - 1;
      bytes[i] = 18;
    }
  }
  return bytes;
}
function sizeLink(link) {
  let n = 0;
  if (link.Hash) {
    const l = link.Hash.length;
    n += 1 + l + sov(l);
  }
  if (typeof link.Name === "string") {
    const l = textEncoder2.encode(link.Name).length;
    n += 1 + l + sov(l);
  }
  if (typeof link.Tsize === "number") {
    n += 1 + sov(link.Tsize);
  }
  return n;
}
function sizeNode(node) {
  let n = 0;
  if (node.Data) {
    const l = node.Data.length;
    n += 1 + l + sov(l);
  }
  if (node.Links) {
    for (const link of node.Links) {
      const l = sizeLink(link);
      n += 1 + l + sov(l);
    }
  }
  return n;
}
function encodeVarint(bytes, offset, v) {
  offset -= sov(v);
  const base3 = offset;
  while (v >= maxUInt32) {
    bytes[offset++] = v & 127 | 128;
    v /= 128;
  }
  while (v >= 128) {
    bytes[offset++] = v & 127 | 128;
    v >>>= 7;
  }
  bytes[offset] = v;
  return base3;
}
function sov(x) {
  if (x % 2 === 0) {
    x++;
  }
  return Math.floor((len64(x) + 6) / 7);
}
function len64(x) {
  let n = 0;
  if (x >= maxInt32) {
    x = Math.floor(x / maxInt32);
    n = 32;
  }
  if (x >= 1 << 16) {
    x >>>= 16;
    n += 16;
  }
  if (x >= 1 << 8) {
    x >>>= 8;
    n += 8;
  }
  return n + len8tab[x];
}
var len8tab = [
  0,
  1,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8
];

// ../../node_modules/.pnpm/@ipld+dag-pb@2.1.18/node_modules/@ipld/dag-pb/esm/src/util.js
var pbNodeProperties = [
  "Data",
  "Links"
];
var pbLinkProperties = [
  "Hash",
  "Name",
  "Tsize"
];
var textEncoder3 = new TextEncoder();
function linkComparator(a, b) {
  if (a === b) {
    return 0;
  }
  const abuf = a.Name ? textEncoder3.encode(a.Name) : [];
  const bbuf = b.Name ? textEncoder3.encode(b.Name) : [];
  let x = abuf.length;
  let y = bbuf.length;
  for (let i = 0, len = Math.min(x, y); i < len; ++i) {
    if (abuf[i] !== bbuf[i]) {
      x = abuf[i];
      y = bbuf[i];
      break;
    }
  }
  return x < y ? -1 : y < x ? 1 : 0;
}
function hasOnlyProperties(node, properties) {
  return !Object.keys(node).some((p) => !properties.includes(p));
}
function asLink(link) {
  if (typeof link.asCID === "object") {
    const Hash = CID.asCID(link);
    if (!Hash) {
      throw new TypeError("Invalid DAG-PB form");
    }
    return { Hash };
  }
  if (typeof link !== "object" || Array.isArray(link)) {
    throw new TypeError("Invalid DAG-PB form");
  }
  const pbl = {};
  if (link.Hash) {
    let cid = CID.asCID(link.Hash);
    try {
      if (!cid) {
        if (typeof link.Hash === "string") {
          cid = CID.parse(link.Hash);
        } else if (link.Hash instanceof Uint8Array) {
          cid = CID.decode(link.Hash);
        }
      }
    } catch (e) {
      throw new TypeError(`Invalid DAG-PB form: ${e.message}`);
    }
    if (cid) {
      pbl.Hash = cid;
    }
  }
  if (!pbl.Hash) {
    throw new TypeError("Invalid DAG-PB form");
  }
  if (typeof link.Name === "string") {
    pbl.Name = link.Name;
  }
  if (typeof link.Tsize === "number") {
    pbl.Tsize = link.Tsize;
  }
  return pbl;
}
function prepare(node) {
  if (node instanceof Uint8Array || typeof node === "string") {
    node = { Data: node };
  }
  if (typeof node !== "object" || Array.isArray(node)) {
    throw new TypeError("Invalid DAG-PB form");
  }
  const pbn = {};
  if (node.Data !== void 0) {
    if (typeof node.Data === "string") {
      pbn.Data = textEncoder3.encode(node.Data);
    } else if (node.Data instanceof Uint8Array) {
      pbn.Data = node.Data;
    } else {
      throw new TypeError("Invalid DAG-PB form");
    }
  }
  if (node.Links !== void 0) {
    if (Array.isArray(node.Links)) {
      pbn.Links = node.Links.map(asLink);
      pbn.Links.sort(linkComparator);
    } else {
      throw new TypeError("Invalid DAG-PB form");
    }
  } else {
    pbn.Links = [];
  }
  return pbn;
}
function validate(node) {
  if (!node || typeof node !== "object" || Array.isArray(node)) {
    throw new TypeError("Invalid DAG-PB form");
  }
  if (!hasOnlyProperties(node, pbNodeProperties)) {
    throw new TypeError("Invalid DAG-PB form (extraneous properties)");
  }
  if (node.Data !== void 0 && !(node.Data instanceof Uint8Array)) {
    throw new TypeError("Invalid DAG-PB form (Data must be a Uint8Array)");
  }
  if (!Array.isArray(node.Links)) {
    throw new TypeError("Invalid DAG-PB form (Links must be an array)");
  }
  for (let i = 0; i < node.Links.length; i++) {
    const link = node.Links[i];
    if (!link || typeof link !== "object" || Array.isArray(link)) {
      throw new TypeError("Invalid DAG-PB form (bad link object)");
    }
    if (!hasOnlyProperties(link, pbLinkProperties)) {
      throw new TypeError("Invalid DAG-PB form (extraneous properties on link object)");
    }
    if (!link.Hash) {
      throw new TypeError("Invalid DAG-PB form (link must have a Hash)");
    }
    if (link.Hash.asCID !== link.Hash) {
      throw new TypeError("Invalid DAG-PB form (link Hash must be a CID)");
    }
    if (link.Name !== void 0 && typeof link.Name !== "string") {
      throw new TypeError("Invalid DAG-PB form (link Name must be a string)");
    }
    if (link.Tsize !== void 0 && (typeof link.Tsize !== "number" || link.Tsize % 1 !== 0)) {
      throw new TypeError("Invalid DAG-PB form (link Tsize must be an integer)");
    }
    if (i > 0 && linkComparator(link, node.Links[i - 1]) === -1) {
      throw new TypeError("Invalid DAG-PB form (links must be sorted by Name bytes)");
    }
  }
}
function createNode(data, links2 = []) {
  return prepare({
    Data: data,
    Links: links2
  });
}
function createLink(name5, size, cid) {
  return asLink({
    Hash: cid,
    Name: name5,
    Tsize: size
  });
}

// ../../node_modules/.pnpm/@ipld+dag-pb@2.1.18/node_modules/@ipld/dag-pb/esm/src/index.js
var name3 = "dag-pb";
var code3 = 112;
function encode8(node) {
  validate(node);
  const pbn = {};
  if (node.Links) {
    pbn.Links = node.Links.map((l) => {
      const link = {};
      if (l.Hash) {
        link.Hash = l.Hash.bytes;
      }
      if (l.Name !== void 0) {
        link.Name = l.Name;
      }
      if (l.Tsize !== void 0) {
        link.Tsize = l.Tsize;
      }
      return link;
    });
  }
  if (node.Data) {
    pbn.Data = node.Data;
  }
  return encodeNode(pbn);
}
function decode9(bytes) {
  const pbn = decodeNode(bytes);
  const node = {};
  if (pbn.Data) {
    node.Data = pbn.Data;
  }
  if (pbn.Links) {
    node.Links = pbn.Links.map((l) => {
      const link = {};
      try {
        link.Hash = CID.decode(l.Hash);
      } catch (e) {
      }
      if (!link.Hash) {
        throw new Error("Invalid Hash field found in link, expected CID");
      }
      if (l.Name !== void 0) {
        link.Name = l.Name;
      }
      if (l.Tsize !== void 0) {
        link.Tsize = l.Tsize;
      }
      return link;
    });
  }
  return node;
}

// ../../node_modules/.pnpm/carbites@1.0.6/node_modules/carbites/esm/lib/treewalk/splitter.js
var TreewalkCarSplitter = class _TreewalkCarSplitter {
  constructor(reader, targetSize, options = {}) {
    if (typeof targetSize !== "number" || targetSize <= 0) {
      throw new Error("invalid target chunk size");
    }
    this._reader = reader;
    this._targetSize = targetSize;
    this._decoders = [
      src_exports,
      raw_exports,
      esm_exports,
      ...options.decoders || []
    ];
  }
  cars() {
    return __asyncGenerator(this, null, function* () {
      const roots = yield new __await(this._reader.getRoots());
      if (roots.length !== 1)
        throw new Error(`unexpected number of roots: ${roots.length}`);
      let channel;
      try {
        for (var iter = __forAwait(this._cars(roots[0])), more, temp, error; more = !(temp = yield new __await(iter.next())).done; more = false) {
          const val = temp.value;
          channel = val.channel;
          if (val.out)
            yield val.out;
        }
      } catch (temp) {
        error = [temp];
      } finally {
        try {
          more && (temp = iter.return) && (yield new __await(temp.call(iter)));
        } finally {
          if (error)
            throw error[0];
        }
      }
      if (!channel) {
        throw new Error("missing CAR writer channel");
      }
      channel.writer.close();
      yield channel.out;
    });
  }
  _get(cid) {
    return __async(this, null, function* () {
      const rawBlock = yield this._reader.get(cid);
      if (!rawBlock)
        throw new Error(`missing block for ${cid}`);
      const { bytes } = rawBlock;
      const decoder2 = this._decoders.find((d) => d.code === cid.code);
      if (!decoder2)
        throw new Error(`missing decoder for ${cid.code}`);
      return new Block({
        cid,
        bytes,
        value: decoder2.decode(bytes)
      });
    });
  }
  _cars(_0) {
    return __asyncGenerator(this, arguments, function* (cid, parents = [], channel = void 0) {
      const block = yield new __await(this._get(cid));
      channel = channel || Object.assign(CarWriter2.create(cid), { size: 0 });
      if (channel.size > 0 && channel.size + block.bytes.byteLength >= this._targetSize) {
        channel.writer.close();
        const { out } = channel;
        channel = newCar(parents);
        yield {
          channel,
          out
        };
      }
      parents = parents.concat(block);
      channel.size += block.bytes.byteLength;
      channel.writer.put(block);
      for (const [, cid2] of block.links()) {
        try {
          for (var iter = __forAwait(this._cars(cid2, parents, channel)), more, temp, error; more = !(temp = yield new __await(iter.next())).done; more = false) {
            const val = temp.value;
            channel = val.channel;
            yield val;
          }
        } catch (temp) {
          error = [temp];
        } finally {
          try {
            more && (temp = iter.return) && (yield new __await(temp.call(iter)));
          } finally {
            if (error)
              throw error[0];
          }
        }
      }
      if (!channel) {
        throw new Error("missing CAR writer channel");
      }
      yield { channel };
    });
  }
  static fromIterable(iterable, targetSize, options) {
    return __async(this, null, function* () {
      const reader = yield CarReader2.fromIterable(iterable);
      return new _TreewalkCarSplitter(reader, targetSize, options);
    });
  }
  static fromBlob(blob, targetSize, options) {
    return __async(this, null, function* () {
      const buffer2 = yield blob.arrayBuffer();
      const reader = yield CarReader2.fromBytes(new Uint8Array(buffer2));
      return new _TreewalkCarSplitter(reader, targetSize, options);
    });
  }
};
function newCar(parents) {
  const ch = Object.assign(CarWriter2.create(parents[0].cid), { size: parents.reduce((size, b) => size + b.bytes.byteLength, 0) });
  for (const b of parents) {
    ch.writer.put(b);
  }
  return ch;
}

// ../../node_modules/.pnpm/ipfs-car@0.6.2_node-fetch@3.3.2/node_modules/ipfs-car/dist/esm/pack/index.js
var import_it_last = __toESM(require_it_last(), 1);
var import_it_pipe = __toESM(require_it_pipe(), 1);

// ../../node_modules/.pnpm/ipfs-unixfs-importer@9.0.10/node_modules/ipfs-unixfs-importer/esm/src/index.js
var import_it_parallel_batch2 = __toESM(require_it_parallel_batch(), 1);

// ../../node_modules/.pnpm/merge-options@3.0.4/node_modules/merge-options/index.mjs
var import_index2 = __toESM(require_merge_options(), 1);
var merge_options_default = import_index2.default;

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/hashes/sha2.js
var sha2_exports = {};
__export(sha2_exports, {
  sha256: () => sha256,
  sha512: () => sha512
});
import crypto from "crypto";
var sha256 = from2({
  name: "sha2-256",
  code: 18,
  encode: (input) => coerce(crypto.createHash("sha256").update(input).digest())
});
var sha512 = from2({
  name: "sha2-512",
  code: 19,
  encode: (input) => coerce(crypto.createHash("sha512").update(input).digest())
});

// ../../node_modules/.pnpm/@multiformats+murmur3@1.1.3/node_modules/@multiformats/murmur3/esm/index.js
var import_murmurhash3js_revisited = __toESM(require_murmurhash3js_revisited(), 1);
function fromNumberTo32BitBuf(number) {
  const bytes = new Array(4);
  for (let i = 0; i < 4; i++) {
    bytes[i] = number & 255;
    number = number >> 8;
  }
  return new Uint8Array(bytes);
}
var murmur332 = from2({
  name: "murmur3-32",
  code: 35,
  encode: (input) => fromNumberTo32BitBuf(import_murmurhash3js_revisited.default.x86.hash32(input))
});
var murmur3128 = from2({
  name: "murmur3-128",
  code: 34,
  encode: (input) => bytes_exports.fromHex(import_murmurhash3js_revisited.default.x64.hash128(input))
});

// ../../node_modules/.pnpm/ipfs-unixfs-importer@9.0.10/node_modules/ipfs-unixfs-importer/esm/src/options.js
function hamtHashFn(buf2) {
  return __async(this, null, function* () {
    return (yield murmur3128.encode(buf2)).slice(0, 8).reverse();
  });
}
var defaultOptions = {
  chunker: "fixed",
  strategy: "balanced",
  rawLeaves: false,
  onlyHash: false,
  reduceSingleLeafToSelf: true,
  hasher: sha256,
  leafType: "file",
  cidVersion: 0,
  progress: () => () => {
  },
  shardSplitThreshold: 1e3,
  fileImportConcurrency: 50,
  blockWriteConcurrency: 10,
  minChunkSize: 262144,
  maxChunkSize: 262144,
  avgChunkSize: 262144,
  window: 16,
  polynomial: 17437180132763652,
  maxChildrenPerNode: 174,
  layerRepeat: 4,
  wrapWithDirectory: false,
  recursive: false,
  hidden: false,
  timeout: void 0,
  hamtHashFn,
  hamtHashCode: 34,
  hamtBucketBits: 8
};
var options_default = (options = {}) => {
  const defaults = merge_options_default.bind({ ignoreUndefined: true });
  return defaults(defaultOptions, options);
};

// ../../node_modules/.pnpm/ipfs-unixfs@6.0.9/node_modules/ipfs-unixfs/esm/src/index.js
var import_err_code = __toESM(require_err_code(), 1);

// ../../node_modules/.pnpm/ipfs-unixfs@6.0.9/node_modules/ipfs-unixfs/esm/src/unixfs.js
var import_minimal = __toESM(require_minimal2(), 1);
var $Reader = import_minimal.default.Reader;
var $Writer = import_minimal.default.Writer;
var $util = import_minimal.default.util;
var $root = import_minimal.default.roots["ipfs-unixfs"] || (import_minimal.default.roots["ipfs-unixfs"] = {});
var Data = $root.Data = (() => {
  function Data2(p) {
    this.blocksizes = [];
    if (p) {
      for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
        if (p[ks[i]] != null)
          this[ks[i]] = p[ks[i]];
    }
  }
  Data2.prototype.Type = 0;
  Data2.prototype.Data = $util.newBuffer([]);
  Data2.prototype.filesize = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
  Data2.prototype.blocksizes = $util.emptyArray;
  Data2.prototype.hashType = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
  Data2.prototype.fanout = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
  Data2.prototype.mode = 0;
  Data2.prototype.mtime = null;
  Data2.encode = function encode12(m, w) {
    if (!w)
      w = $Writer.create();
    w.uint32(8).int32(m.Type);
    if (m.Data != null && Object.hasOwnProperty.call(m, "Data"))
      w.uint32(18).bytes(m.Data);
    if (m.filesize != null && Object.hasOwnProperty.call(m, "filesize"))
      w.uint32(24).uint64(m.filesize);
    if (m.blocksizes != null && m.blocksizes.length) {
      for (var i = 0; i < m.blocksizes.length; ++i)
        w.uint32(32).uint64(m.blocksizes[i]);
    }
    if (m.hashType != null && Object.hasOwnProperty.call(m, "hashType"))
      w.uint32(40).uint64(m.hashType);
    if (m.fanout != null && Object.hasOwnProperty.call(m, "fanout"))
      w.uint32(48).uint64(m.fanout);
    if (m.mode != null && Object.hasOwnProperty.call(m, "mode"))
      w.uint32(56).uint32(m.mode);
    if (m.mtime != null && Object.hasOwnProperty.call(m, "mtime"))
      $root.UnixTime.encode(m.mtime, w.uint32(66).fork()).ldelim();
    return w;
  };
  Data2.decode = function decode12(r, l) {
    if (!(r instanceof $Reader))
      r = $Reader.create(r);
    var c = l === void 0 ? r.len : r.pos + l, m = new $root.Data();
    while (r.pos < c) {
      var t = r.uint32();
      switch (t >>> 3) {
        case 1:
          m.Type = r.int32();
          break;
        case 2:
          m.Data = r.bytes();
          break;
        case 3:
          m.filesize = r.uint64();
          break;
        case 4:
          if (!(m.blocksizes && m.blocksizes.length))
            m.blocksizes = [];
          if ((t & 7) === 2) {
            var c2 = r.uint32() + r.pos;
            while (r.pos < c2)
              m.blocksizes.push(r.uint64());
          } else
            m.blocksizes.push(r.uint64());
          break;
        case 5:
          m.hashType = r.uint64();
          break;
        case 6:
          m.fanout = r.uint64();
          break;
        case 7:
          m.mode = r.uint32();
          break;
        case 8:
          m.mtime = $root.UnixTime.decode(r, r.uint32());
          break;
        default:
          r.skipType(t & 7);
          break;
      }
    }
    if (!m.hasOwnProperty("Type"))
      throw $util.ProtocolError("missing required 'Type'", { instance: m });
    return m;
  };
  Data2.fromObject = function fromObject(d) {
    if (d instanceof $root.Data)
      return d;
    var m = new $root.Data();
    switch (d.Type) {
      case "Raw":
      case 0:
        m.Type = 0;
        break;
      case "Directory":
      case 1:
        m.Type = 1;
        break;
      case "File":
      case 2:
        m.Type = 2;
        break;
      case "Metadata":
      case 3:
        m.Type = 3;
        break;
      case "Symlink":
      case 4:
        m.Type = 4;
        break;
      case "HAMTShard":
      case 5:
        m.Type = 5;
        break;
    }
    if (d.Data != null) {
      if (typeof d.Data === "string")
        $util.base64.decode(d.Data, m.Data = $util.newBuffer($util.base64.length(d.Data)), 0);
      else if (d.Data.length)
        m.Data = d.Data;
    }
    if (d.filesize != null) {
      if ($util.Long)
        (m.filesize = $util.Long.fromValue(d.filesize)).unsigned = true;
      else if (typeof d.filesize === "string")
        m.filesize = parseInt(d.filesize, 10);
      else if (typeof d.filesize === "number")
        m.filesize = d.filesize;
      else if (typeof d.filesize === "object")
        m.filesize = new $util.LongBits(d.filesize.low >>> 0, d.filesize.high >>> 0).toNumber(true);
    }
    if (d.blocksizes) {
      if (!Array.isArray(d.blocksizes))
        throw TypeError(".Data.blocksizes: array expected");
      m.blocksizes = [];
      for (var i = 0; i < d.blocksizes.length; ++i) {
        if ($util.Long)
          (m.blocksizes[i] = $util.Long.fromValue(d.blocksizes[i])).unsigned = true;
        else if (typeof d.blocksizes[i] === "string")
          m.blocksizes[i] = parseInt(d.blocksizes[i], 10);
        else if (typeof d.blocksizes[i] === "number")
          m.blocksizes[i] = d.blocksizes[i];
        else if (typeof d.blocksizes[i] === "object")
          m.blocksizes[i] = new $util.LongBits(d.blocksizes[i].low >>> 0, d.blocksizes[i].high >>> 0).toNumber(true);
      }
    }
    if (d.hashType != null) {
      if ($util.Long)
        (m.hashType = $util.Long.fromValue(d.hashType)).unsigned = true;
      else if (typeof d.hashType === "string")
        m.hashType = parseInt(d.hashType, 10);
      else if (typeof d.hashType === "number")
        m.hashType = d.hashType;
      else if (typeof d.hashType === "object")
        m.hashType = new $util.LongBits(d.hashType.low >>> 0, d.hashType.high >>> 0).toNumber(true);
    }
    if (d.fanout != null) {
      if ($util.Long)
        (m.fanout = $util.Long.fromValue(d.fanout)).unsigned = true;
      else if (typeof d.fanout === "string")
        m.fanout = parseInt(d.fanout, 10);
      else if (typeof d.fanout === "number")
        m.fanout = d.fanout;
      else if (typeof d.fanout === "object")
        m.fanout = new $util.LongBits(d.fanout.low >>> 0, d.fanout.high >>> 0).toNumber(true);
    }
    if (d.mode != null) {
      m.mode = d.mode >>> 0;
    }
    if (d.mtime != null) {
      if (typeof d.mtime !== "object")
        throw TypeError(".Data.mtime: object expected");
      m.mtime = $root.UnixTime.fromObject(d.mtime);
    }
    return m;
  };
  Data2.toObject = function toObject(m, o) {
    if (!o)
      o = {};
    var d = {};
    if (o.arrays || o.defaults) {
      d.blocksizes = [];
    }
    if (o.defaults) {
      d.Type = o.enums === String ? "Raw" : 0;
      if (o.bytes === String)
        d.Data = "";
      else {
        d.Data = [];
        if (o.bytes !== Array)
          d.Data = $util.newBuffer(d.Data);
      }
      if ($util.Long) {
        var n = new $util.Long(0, 0, true);
        d.filesize = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
      } else
        d.filesize = o.longs === String ? "0" : 0;
      if ($util.Long) {
        var n = new $util.Long(0, 0, true);
        d.hashType = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
      } else
        d.hashType = o.longs === String ? "0" : 0;
      if ($util.Long) {
        var n = new $util.Long(0, 0, true);
        d.fanout = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
      } else
        d.fanout = o.longs === String ? "0" : 0;
      d.mode = 0;
      d.mtime = null;
    }
    if (m.Type != null && m.hasOwnProperty("Type")) {
      d.Type = o.enums === String ? $root.Data.DataType[m.Type] : m.Type;
    }
    if (m.Data != null && m.hasOwnProperty("Data")) {
      d.Data = o.bytes === String ? $util.base64.encode(m.Data, 0, m.Data.length) : o.bytes === Array ? Array.prototype.slice.call(m.Data) : m.Data;
    }
    if (m.filesize != null && m.hasOwnProperty("filesize")) {
      if (typeof m.filesize === "number")
        d.filesize = o.longs === String ? String(m.filesize) : m.filesize;
      else
        d.filesize = o.longs === String ? $util.Long.prototype.toString.call(m.filesize) : o.longs === Number ? new $util.LongBits(m.filesize.low >>> 0, m.filesize.high >>> 0).toNumber(true) : m.filesize;
    }
    if (m.blocksizes && m.blocksizes.length) {
      d.blocksizes = [];
      for (var j = 0; j < m.blocksizes.length; ++j) {
        if (typeof m.blocksizes[j] === "number")
          d.blocksizes[j] = o.longs === String ? String(m.blocksizes[j]) : m.blocksizes[j];
        else
          d.blocksizes[j] = o.longs === String ? $util.Long.prototype.toString.call(m.blocksizes[j]) : o.longs === Number ? new $util.LongBits(m.blocksizes[j].low >>> 0, m.blocksizes[j].high >>> 0).toNumber(true) : m.blocksizes[j];
      }
    }
    if (m.hashType != null && m.hasOwnProperty("hashType")) {
      if (typeof m.hashType === "number")
        d.hashType = o.longs === String ? String(m.hashType) : m.hashType;
      else
        d.hashType = o.longs === String ? $util.Long.prototype.toString.call(m.hashType) : o.longs === Number ? new $util.LongBits(m.hashType.low >>> 0, m.hashType.high >>> 0).toNumber(true) : m.hashType;
    }
    if (m.fanout != null && m.hasOwnProperty("fanout")) {
      if (typeof m.fanout === "number")
        d.fanout = o.longs === String ? String(m.fanout) : m.fanout;
      else
        d.fanout = o.longs === String ? $util.Long.prototype.toString.call(m.fanout) : o.longs === Number ? new $util.LongBits(m.fanout.low >>> 0, m.fanout.high >>> 0).toNumber(true) : m.fanout;
    }
    if (m.mode != null && m.hasOwnProperty("mode")) {
      d.mode = m.mode;
    }
    if (m.mtime != null && m.hasOwnProperty("mtime")) {
      d.mtime = $root.UnixTime.toObject(m.mtime, o);
    }
    return d;
  };
  Data2.prototype.toJSON = function toJSON() {
    return this.constructor.toObject(this, import_minimal.default.util.toJSONOptions);
  };
  Data2.DataType = function() {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = "Raw"] = 0;
    values[valuesById[1] = "Directory"] = 1;
    values[valuesById[2] = "File"] = 2;
    values[valuesById[3] = "Metadata"] = 3;
    values[valuesById[4] = "Symlink"] = 4;
    values[valuesById[5] = "HAMTShard"] = 5;
    return values;
  }();
  return Data2;
})();
var UnixTime = $root.UnixTime = (() => {
  function UnixTime2(p) {
    if (p) {
      for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
        if (p[ks[i]] != null)
          this[ks[i]] = p[ks[i]];
    }
  }
  UnixTime2.prototype.Seconds = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
  UnixTime2.prototype.FractionalNanoseconds = 0;
  UnixTime2.encode = function encode12(m, w) {
    if (!w)
      w = $Writer.create();
    w.uint32(8).int64(m.Seconds);
    if (m.FractionalNanoseconds != null && Object.hasOwnProperty.call(m, "FractionalNanoseconds"))
      w.uint32(21).fixed32(m.FractionalNanoseconds);
    return w;
  };
  UnixTime2.decode = function decode12(r, l) {
    if (!(r instanceof $Reader))
      r = $Reader.create(r);
    var c = l === void 0 ? r.len : r.pos + l, m = new $root.UnixTime();
    while (r.pos < c) {
      var t = r.uint32();
      switch (t >>> 3) {
        case 1:
          m.Seconds = r.int64();
          break;
        case 2:
          m.FractionalNanoseconds = r.fixed32();
          break;
        default:
          r.skipType(t & 7);
          break;
      }
    }
    if (!m.hasOwnProperty("Seconds"))
      throw $util.ProtocolError("missing required 'Seconds'", { instance: m });
    return m;
  };
  UnixTime2.fromObject = function fromObject(d) {
    if (d instanceof $root.UnixTime)
      return d;
    var m = new $root.UnixTime();
    if (d.Seconds != null) {
      if ($util.Long)
        (m.Seconds = $util.Long.fromValue(d.Seconds)).unsigned = false;
      else if (typeof d.Seconds === "string")
        m.Seconds = parseInt(d.Seconds, 10);
      else if (typeof d.Seconds === "number")
        m.Seconds = d.Seconds;
      else if (typeof d.Seconds === "object")
        m.Seconds = new $util.LongBits(d.Seconds.low >>> 0, d.Seconds.high >>> 0).toNumber();
    }
    if (d.FractionalNanoseconds != null) {
      m.FractionalNanoseconds = d.FractionalNanoseconds >>> 0;
    }
    return m;
  };
  UnixTime2.toObject = function toObject(m, o) {
    if (!o)
      o = {};
    var d = {};
    if (o.defaults) {
      if ($util.Long) {
        var n = new $util.Long(0, 0, false);
        d.Seconds = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
      } else
        d.Seconds = o.longs === String ? "0" : 0;
      d.FractionalNanoseconds = 0;
    }
    if (m.Seconds != null && m.hasOwnProperty("Seconds")) {
      if (typeof m.Seconds === "number")
        d.Seconds = o.longs === String ? String(m.Seconds) : m.Seconds;
      else
        d.Seconds = o.longs === String ? $util.Long.prototype.toString.call(m.Seconds) : o.longs === Number ? new $util.LongBits(m.Seconds.low >>> 0, m.Seconds.high >>> 0).toNumber() : m.Seconds;
    }
    if (m.FractionalNanoseconds != null && m.hasOwnProperty("FractionalNanoseconds")) {
      d.FractionalNanoseconds = m.FractionalNanoseconds;
    }
    return d;
  };
  UnixTime2.prototype.toJSON = function toJSON() {
    return this.constructor.toObject(this, import_minimal.default.util.toJSONOptions);
  };
  return UnixTime2;
})();
var Metadata = $root.Metadata = (() => {
  function Metadata2(p) {
    if (p) {
      for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
        if (p[ks[i]] != null)
          this[ks[i]] = p[ks[i]];
    }
  }
  Metadata2.prototype.MimeType = "";
  Metadata2.encode = function encode12(m, w) {
    if (!w)
      w = $Writer.create();
    if (m.MimeType != null && Object.hasOwnProperty.call(m, "MimeType"))
      w.uint32(10).string(m.MimeType);
    return w;
  };
  Metadata2.decode = function decode12(r, l) {
    if (!(r instanceof $Reader))
      r = $Reader.create(r);
    var c = l === void 0 ? r.len : r.pos + l, m = new $root.Metadata();
    while (r.pos < c) {
      var t = r.uint32();
      switch (t >>> 3) {
        case 1:
          m.MimeType = r.string();
          break;
        default:
          r.skipType(t & 7);
          break;
      }
    }
    return m;
  };
  Metadata2.fromObject = function fromObject(d) {
    if (d instanceof $root.Metadata)
      return d;
    var m = new $root.Metadata();
    if (d.MimeType != null) {
      m.MimeType = String(d.MimeType);
    }
    return m;
  };
  Metadata2.toObject = function toObject(m, o) {
    if (!o)
      o = {};
    var d = {};
    if (o.defaults) {
      d.MimeType = "";
    }
    if (m.MimeType != null && m.hasOwnProperty("MimeType")) {
      d.MimeType = m.MimeType;
    }
    return d;
  };
  Metadata2.prototype.toJSON = function toJSON() {
    return this.constructor.toObject(this, import_minimal.default.util.toJSONOptions);
  };
  return Metadata2;
})();

// ../../node_modules/.pnpm/ipfs-unixfs@6.0.9/node_modules/ipfs-unixfs/esm/src/index.js
var PBData = Data;
var types = [
  "raw",
  "directory",
  "file",
  "metadata",
  "symlink",
  "hamt-sharded-directory"
];
var dirTypes = [
  "directory",
  "hamt-sharded-directory"
];
var DEFAULT_FILE_MODE = parseInt("0644", 8);
var DEFAULT_DIRECTORY_MODE = parseInt("0755", 8);
function parseMode(mode) {
  if (mode == null) {
    return void 0;
  }
  if (typeof mode === "number") {
    return mode & 4095;
  }
  mode = mode.toString();
  if (mode.substring(0, 1) === "0") {
    return parseInt(mode, 8) & 4095;
  }
  return parseInt(mode, 10) & 4095;
}
function parseMtime(input) {
  if (input == null) {
    return void 0;
  }
  let mtime;
  if (input.secs != null) {
    mtime = {
      secs: input.secs,
      nsecs: input.nsecs
    };
  }
  if (input.Seconds != null) {
    mtime = {
      secs: input.Seconds,
      nsecs: input.FractionalNanoseconds
    };
  }
  if (Array.isArray(input)) {
    mtime = {
      secs: input[0],
      nsecs: input[1]
    };
  }
  if (input instanceof Date) {
    const ms = input.getTime();
    const secs = Math.floor(ms / 1e3);
    mtime = {
      secs,
      nsecs: (ms - secs * 1e3) * 1e3
    };
  }
  if (!Object.prototype.hasOwnProperty.call(mtime, "secs")) {
    return void 0;
  }
  if (mtime != null && mtime.nsecs != null && (mtime.nsecs < 0 || mtime.nsecs > 999999999)) {
    throw (0, import_err_code.default)(new Error("mtime-nsecs must be within the range [0,999999999]"), "ERR_INVALID_MTIME_NSECS");
  }
  return mtime;
}
var UnixFS = class _UnixFS {
  static unmarshal(marshaled) {
    const message = PBData.decode(marshaled);
    const decoded = PBData.toObject(message, {
      defaults: false,
      arrays: true,
      longs: Number,
      objects: false
    });
    const data = new _UnixFS({
      type: types[decoded.Type],
      data: decoded.Data,
      blockSizes: decoded.blocksizes,
      mode: decoded.mode,
      mtime: decoded.mtime ? {
        secs: decoded.mtime.Seconds,
        nsecs: decoded.mtime.FractionalNanoseconds
      } : void 0
    });
    data._originalMode = decoded.mode || 0;
    return data;
  }
  constructor(options = { type: "file" }) {
    const { type, data, blockSizes, hashType, fanout, mtime, mode } = options;
    if (type && !types.includes(type)) {
      throw (0, import_err_code.default)(new Error("Type: " + type + " is not valid"), "ERR_INVALID_TYPE");
    }
    this.type = type || "file";
    this.data = data;
    this.hashType = hashType;
    this.fanout = fanout;
    this.blockSizes = blockSizes || [];
    this._originalMode = 0;
    this.mode = parseMode(mode);
    if (mtime) {
      this.mtime = parseMtime(mtime);
      if (this.mtime && !this.mtime.nsecs) {
        this.mtime.nsecs = 0;
      }
    }
  }
  set mode(mode) {
    this._mode = this.isDirectory() ? DEFAULT_DIRECTORY_MODE : DEFAULT_FILE_MODE;
    const parsedMode = parseMode(mode);
    if (parsedMode !== void 0) {
      this._mode = parsedMode;
    }
  }
  get mode() {
    return this._mode;
  }
  isDirectory() {
    return Boolean(this.type && dirTypes.includes(this.type));
  }
  addBlockSize(size) {
    this.blockSizes.push(size);
  }
  removeBlockSize(index) {
    this.blockSizes.splice(index, 1);
  }
  fileSize() {
    if (this.isDirectory()) {
      return 0;
    }
    let sum = 0;
    this.blockSizes.forEach((size) => {
      sum += size;
    });
    if (this.data) {
      sum += this.data.length;
    }
    return sum;
  }
  marshal() {
    let type;
    switch (this.type) {
      case "raw":
        type = PBData.DataType.Raw;
        break;
      case "directory":
        type = PBData.DataType.Directory;
        break;
      case "file":
        type = PBData.DataType.File;
        break;
      case "metadata":
        type = PBData.DataType.Metadata;
        break;
      case "symlink":
        type = PBData.DataType.Symlink;
        break;
      case "hamt-sharded-directory":
        type = PBData.DataType.HAMTShard;
        break;
      default:
        throw (0, import_err_code.default)(new Error("Type: " + type + " is not valid"), "ERR_INVALID_TYPE");
    }
    let data = this.data;
    if (!this.data || !this.data.length) {
      data = void 0;
    }
    let mode;
    if (this.mode != null) {
      mode = this._originalMode & 4294963200 | (parseMode(this.mode) || 0);
      if (mode === DEFAULT_FILE_MODE && !this.isDirectory()) {
        mode = void 0;
      }
      if (mode === DEFAULT_DIRECTORY_MODE && this.isDirectory()) {
        mode = void 0;
      }
    }
    let mtime;
    if (this.mtime != null) {
      const parsed = parseMtime(this.mtime);
      if (parsed) {
        mtime = {
          Seconds: parsed.secs,
          FractionalNanoseconds: parsed.nsecs
        };
        if (mtime.FractionalNanoseconds === 0) {
          delete mtime.FractionalNanoseconds;
        }
      }
    }
    const pbData = {
      Type: type,
      Data: data,
      filesize: this.isDirectory() ? void 0 : this.fileSize(),
      blocksizes: this.blockSizes,
      hashType: this.hashType,
      fanout: this.fanout,
      mode,
      mtime
    };
    return PBData.encode(pbData).finish();
  }
};

// ../../node_modules/.pnpm/ipfs-unixfs-importer@9.0.10/node_modules/ipfs-unixfs-importer/esm/src/utils/persist.js
var persist = (buffer2, blockstore, options) => __async(void 0, null, function* () {
  if (!options.codec) {
    options.codec = src_exports;
  }
  if (!options.hasher) {
    options.hasher = sha256;
  }
  if (options.cidVersion === void 0) {
    options.cidVersion = 1;
  }
  if (options.codec === src_exports && options.hasher !== sha256) {
    options.cidVersion = 1;
  }
  const multihash = yield options.hasher.digest(buffer2);
  const cid = CID.create(options.cidVersion, options.codec.code, multihash);
  if (!options.onlyHash) {
    yield blockstore.put(cid, buffer2, { signal: options.signal });
  }
  return cid;
});
var persist_default = persist;

// ../../node_modules/.pnpm/ipfs-unixfs-importer@9.0.10/node_modules/ipfs-unixfs-importer/esm/src/dag-builder/dir.js
var dirBuilder = (item, blockstore, options) => __async(void 0, null, function* () {
  const unixfs = new UnixFS({
    type: "directory",
    mtime: item.mtime,
    mode: item.mode
  });
  const buffer2 = encode8(prepare({ Data: unixfs.marshal() }));
  const cid = yield persist_default(buffer2, blockstore, options);
  const path = item.path;
  return {
    cid,
    path,
    unixfs,
    size: buffer2.length
  };
});
var dir_default = dirBuilder;

// ../../node_modules/.pnpm/ipfs-unixfs-importer@9.0.10/node_modules/ipfs-unixfs-importer/esm/src/dag-builder/file/index.js
var import_err_code2 = __toESM(require_err_code(), 1);
var import_it_parallel_batch = __toESM(require_it_parallel_batch(), 1);

// ../../node_modules/.pnpm/ipfs-unixfs-importer@9.0.10/node_modules/ipfs-unixfs-importer/esm/src/dag-builder/file/flat.js
var import_it_all = __toESM(require_it_all(), 1);
function flat(source, reduce2) {
  return __async(this, null, function* () {
    return reduce2(yield (0, import_it_all.default)(source));
  });
}
var flat_default = flat;

// ../../node_modules/.pnpm/ipfs-unixfs-importer@9.0.10/node_modules/ipfs-unixfs-importer/esm/src/dag-builder/file/balanced.js
var import_it_batch = __toESM(require_it_batch(), 1);
function balanced(source, reduce2, options) {
  return reduceToParents(source, reduce2, options);
}
function reduceToParents(source, reduce2, options) {
  return __async(this, null, function* () {
    const roots = [];
    try {
      for (var iter = __forAwait((0, import_it_batch.default)(source, options.maxChildrenPerNode)), more, temp, error; more = !(temp = yield iter.next()).done; more = false) {
        const chunked = temp.value;
        roots.push(yield reduce2(chunked));
      }
    } catch (temp) {
      error = [temp];
    } finally {
      try {
        more && (temp = iter.return) && (yield temp.call(iter));
      } finally {
        if (error)
          throw error[0];
      }
    }
    if (roots.length > 1) {
      return reduceToParents(roots, reduce2, options);
    }
    return roots[0];
  });
}
var balanced_default = balanced;

// ../../node_modules/.pnpm/ipfs-unixfs-importer@9.0.10/node_modules/ipfs-unixfs-importer/esm/src/dag-builder/file/trickle.js
var import_it_batch2 = __toESM(require_it_batch(), 1);
function trickleStream(source, reduce2, options) {
  return __async(this, null, function* () {
    const root = new Root(options.layerRepeat);
    let iteration = 0;
    let maxDepth = 1;
    let subTree = root;
    try {
      for (var iter = __forAwait((0, import_it_batch2.default)(source, options.maxChildrenPerNode)), more, temp, error; more = !(temp = yield iter.next()).done; more = false) {
        const layer = temp.value;
        if (subTree.isFull()) {
          if (subTree !== root) {
            root.addChild(yield subTree.reduce(reduce2));
          }
          if (iteration && iteration % options.layerRepeat === 0) {
            maxDepth++;
          }
          subTree = new SubTree(maxDepth, options.layerRepeat, iteration);
          iteration++;
        }
        subTree.append(layer);
      }
    } catch (temp) {
      error = [temp];
    } finally {
      try {
        more && (temp = iter.return) && (yield temp.call(iter));
      } finally {
        if (error)
          throw error[0];
      }
    }
    if (subTree && subTree !== root) {
      root.addChild(yield subTree.reduce(reduce2));
    }
    return root.reduce(reduce2);
  });
}
var trickle_default = trickleStream;
var SubTree = class {
  constructor(maxDepth, layerRepeat, iteration = 0) {
    this.maxDepth = maxDepth;
    this.layerRepeat = layerRepeat;
    this.currentDepth = 1;
    this.iteration = iteration;
    this.root = this.node = this.parent = {
      children: [],
      depth: this.currentDepth,
      maxDepth,
      maxChildren: (this.maxDepth - this.currentDepth) * this.layerRepeat
    };
  }
  isFull() {
    if (!this.root.data) {
      return false;
    }
    if (this.currentDepth < this.maxDepth && this.node.maxChildren) {
      this._addNextNodeToParent(this.node);
      return false;
    }
    const distantRelative = this._findParent(this.node, this.currentDepth);
    if (distantRelative) {
      this._addNextNodeToParent(distantRelative);
      return false;
    }
    return true;
  }
  _addNextNodeToParent(parent) {
    this.parent = parent;
    const nextNode = {
      children: [],
      depth: parent.depth + 1,
      parent,
      maxDepth: this.maxDepth,
      maxChildren: Math.floor(parent.children.length / this.layerRepeat) * this.layerRepeat
    };
    parent.children.push(nextNode);
    this.currentDepth = nextNode.depth;
    this.node = nextNode;
  }
  append(layer) {
    this.node.data = layer;
  }
  reduce(reduce2) {
    return this._reduce(this.root, reduce2);
  }
  _reduce(node, reduce2) {
    return __async(this, null, function* () {
      let children = [];
      if (node.children.length) {
        children = yield Promise.all(node.children.filter((child) => child.data).map((child) => this._reduce(child, reduce2)));
      }
      return reduce2((node.data || []).concat(children));
    });
  }
  _findParent(node, depth) {
    const parent = node.parent;
    if (!parent || parent.depth === 0) {
      return;
    }
    if (parent.children.length === parent.maxChildren || !parent.maxChildren) {
      return this._findParent(parent, depth);
    }
    return parent;
  }
};
var Root = class extends SubTree {
  constructor(layerRepeat) {
    super(0, layerRepeat);
    this.root.depth = 0;
    this.currentDepth = 1;
  }
  addChild(child) {
    this.root.children.push(child);
  }
  reduce(reduce2) {
    return reduce2((this.root.data || []).concat(this.root.children));
  }
};

// ../../node_modules/.pnpm/ipfs-unixfs-importer@9.0.10/node_modules/ipfs-unixfs-importer/esm/src/dag-builder/file/buffer-importer.js
function bufferImporter(file, block, options) {
  return __asyncGenerator(this, null, function* () {
    try {
      for (var iter = __forAwait(file.content), more, temp, error; more = !(temp = yield new __await(iter.next())).done; more = false) {
        let buffer2 = temp.value;
        yield () => __async(this, null, function* () {
          options.progress(buffer2.length, file.path);
          let unixfs;
          const opts = {
            codec: src_exports,
            cidVersion: options.cidVersion,
            hasher: options.hasher,
            onlyHash: options.onlyHash
          };
          if (options.rawLeaves) {
            opts.codec = raw_exports;
            opts.cidVersion = 1;
          } else {
            unixfs = new UnixFS({
              type: options.leafType,
              data: buffer2
            });
            buffer2 = encode8({
              Data: unixfs.marshal(),
              Links: []
            });
          }
          return {
            cid: yield persist_default(buffer2, block, opts),
            unixfs,
            size: buffer2.length
          };
        });
      }
    } catch (temp) {
      error = [temp];
    } finally {
      try {
        more && (temp = iter.return) && (yield new __await(temp.call(iter)));
      } finally {
        if (error)
          throw error[0];
      }
    }
  });
}
var buffer_importer_default = bufferImporter;

// ../../node_modules/.pnpm/ipfs-unixfs-importer@9.0.10/node_modules/ipfs-unixfs-importer/esm/src/dag-builder/file/index.js
var dagBuilders = {
  flat: flat_default,
  balanced: balanced_default,
  trickle: trickle_default
};
function buildFileBatch(file, blockstore, options) {
  return __asyncGenerator(this, null, function* () {
    let count = -1;
    let previous;
    let bufferImporter2;
    if (typeof options.bufferImporter === "function") {
      bufferImporter2 = options.bufferImporter;
    } else {
      bufferImporter2 = buffer_importer_default;
    }
    try {
      for (var iter = __forAwait((0, import_it_parallel_batch.default)(bufferImporter2(file, blockstore, options), options.blockWriteConcurrency)), more, temp, error; more = !(temp = yield new __await(iter.next())).done; more = false) {
        const entry = temp.value;
        count++;
        if (count === 0) {
          previous = entry;
          continue;
        } else if (count === 1 && previous) {
          yield previous;
          previous = null;
        }
        yield entry;
      }
    } catch (temp) {
      error = [temp];
    } finally {
      try {
        more && (temp = iter.return) && (yield new __await(temp.call(iter)));
      } finally {
        if (error)
          throw error[0];
      }
    }
    if (previous) {
      previous.single = true;
      yield previous;
    }
  });
}
var reduce = (file, blockstore, options) => {
  function reducer(leaves) {
    return __async(this, null, function* () {
      if (leaves.length === 1 && leaves[0].single && options.reduceSingleLeafToSelf) {
        const leaf = leaves[0];
        if (file.mtime !== void 0 || file.mode !== void 0) {
          let buffer3 = yield blockstore.get(leaf.cid);
          leaf.unixfs = new UnixFS({
            type: "file",
            mtime: file.mtime,
            mode: file.mode,
            data: buffer3
          });
          buffer3 = encode8(prepare({ Data: leaf.unixfs.marshal() }));
          leaf.cid = yield persist_default(buffer3, blockstore, __spreadProps(__spreadValues({}, options), {
            codec: src_exports,
            hasher: options.hasher,
            cidVersion: options.cidVersion
          }));
          leaf.size = buffer3.length;
        }
        return {
          cid: leaf.cid,
          path: file.path,
          unixfs: leaf.unixfs,
          size: leaf.size
        };
      }
      const f = new UnixFS({
        type: "file",
        mtime: file.mtime,
        mode: file.mode
      });
      const links2 = leaves.filter((leaf) => {
        if (leaf.cid.code === code && leaf.size) {
          return true;
        }
        if (leaf.unixfs && !leaf.unixfs.data && leaf.unixfs.fileSize()) {
          return true;
        }
        return Boolean(leaf.unixfs && leaf.unixfs.data && leaf.unixfs.data.length);
      }).map((leaf) => {
        if (leaf.cid.code === code) {
          f.addBlockSize(leaf.size);
          return {
            Name: "",
            Tsize: leaf.size,
            Hash: leaf.cid
          };
        }
        if (!leaf.unixfs || !leaf.unixfs.data) {
          f.addBlockSize(leaf.unixfs && leaf.unixfs.fileSize() || 0);
        } else {
          f.addBlockSize(leaf.unixfs.data.length);
        }
        return {
          Name: "",
          Tsize: leaf.size,
          Hash: leaf.cid
        };
      });
      const node = {
        Data: f.marshal(),
        Links: links2
      };
      const buffer2 = encode8(prepare(node));
      const cid = yield persist_default(buffer2, blockstore, options);
      return {
        cid,
        path: file.path,
        unixfs: f,
        size: buffer2.length + node.Links.reduce((acc, curr) => acc + curr.Tsize, 0)
      };
    });
  }
  return reducer;
};
function fileBuilder(file, block, options) {
  const dagBuilder2 = dagBuilders[options.strategy];
  if (!dagBuilder2) {
    throw (0, import_err_code2.default)(new Error(`Unknown importer build strategy name: ${options.strategy}`), "ERR_BAD_STRATEGY");
  }
  return dagBuilder2(buildFileBatch(file, block, options), reduce(file, block, options), options);
}
var file_default = fileBuilder;

// ../../node_modules/.pnpm/ipfs-unixfs-importer@9.0.10/node_modules/ipfs-unixfs-importer/esm/src/dag-builder/index.js
var import_err_code5 = __toESM(require_err_code(), 1);

// ../../node_modules/.pnpm/ipfs-unixfs-importer@9.0.10/node_modules/ipfs-unixfs-importer/esm/src/chunker/rabin.js
var import_BufferList = __toESM(require_BufferList(), 1);
var import_rabin_wasm = __toESM(require_src(), 1);
var import_err_code3 = __toESM(require_err_code(), 1);
function rabinChunker(source, options) {
  return __asyncGenerator(this, null, function* () {
    let min, max, avg;
    if (options.minChunkSize && options.maxChunkSize && options.avgChunkSize) {
      avg = options.avgChunkSize;
      min = options.minChunkSize;
      max = options.maxChunkSize;
    } else if (!options.avgChunkSize) {
      throw (0, import_err_code3.default)(new Error("please specify an average chunk size"), "ERR_INVALID_AVG_CHUNK_SIZE");
    } else {
      avg = options.avgChunkSize;
      min = avg / 3;
      max = avg + avg / 2;
    }
    if (min < 16) {
      throw (0, import_err_code3.default)(new Error("rabin min must be greater than 16"), "ERR_INVALID_MIN_CHUNK_SIZE");
    }
    if (max < min) {
      max = min;
    }
    if (avg < min) {
      avg = min;
    }
    const sizepow = Math.floor(Math.log2(avg));
    try {
      for (var iter = __forAwait(rabin(source, {
        min,
        max,
        bits: sizepow,
        window: options.window,
        polynomial: options.polynomial
      })), more, temp, error; more = !(temp = yield new __await(iter.next())).done; more = false) {
        const chunk = temp.value;
        yield chunk;
      }
    } catch (temp) {
      error = [temp];
    } finally {
      try {
        more && (temp = iter.return) && (yield new __await(temp.call(iter)));
      } finally {
        if (error)
          throw error[0];
      }
    }
  });
}
var rabin_default = rabinChunker;
function rabin(source, options) {
  return __asyncGenerator(this, null, function* () {
    const r = yield new __await((0, import_rabin_wasm.create)(options.bits, options.min, options.max, options.window));
    const buffers = new import_BufferList.default();
    try {
      for (var iter = __forAwait(source), more, temp, error; more = !(temp = yield new __await(iter.next())).done; more = false) {
        const chunk = temp.value;
        buffers.append(chunk);
        const sizes = r.fingerprint(chunk);
        for (let i = 0; i < sizes.length; i++) {
          const size = sizes[i];
          const buf2 = buffers.slice(0, size);
          buffers.consume(size);
          yield buf2;
        }
      }
    } catch (temp) {
      error = [temp];
    } finally {
      try {
        more && (temp = iter.return) && (yield new __await(temp.call(iter)));
      } finally {
        if (error)
          throw error[0];
      }
    }
    if (buffers.length) {
      yield buffers.slice(0);
    }
  });
}

// ../../node_modules/.pnpm/ipfs-unixfs-importer@9.0.10/node_modules/ipfs-unixfs-importer/esm/src/chunker/fixed-size.js
var import_BufferList2 = __toESM(require_BufferList(), 1);
function fixedSizeChunker(source, options) {
  return __asyncGenerator(this, null, function* () {
    let bl = new import_BufferList2.default();
    let currentLength = 0;
    let emitted = false;
    const maxChunkSize = options.maxChunkSize;
    try {
      for (var iter = __forAwait(source), more, temp, error; more = !(temp = yield new __await(iter.next())).done; more = false) {
        const buffer2 = temp.value;
        bl.append(buffer2);
        currentLength += buffer2.length;
        while (currentLength >= maxChunkSize) {
          yield bl.slice(0, maxChunkSize);
          emitted = true;
          if (maxChunkSize === bl.length) {
            bl = new import_BufferList2.default();
            currentLength = 0;
          } else {
            const newBl = new import_BufferList2.default();
            newBl.append(bl.shallowSlice(maxChunkSize));
            bl = newBl;
            currentLength -= maxChunkSize;
          }
        }
      }
    } catch (temp) {
      error = [temp];
    } finally {
      try {
        more && (temp = iter.return) && (yield new __await(temp.call(iter)));
      } finally {
        if (error)
          throw error[0];
      }
    }
    if (!emitted || currentLength) {
      yield bl.slice(0, currentLength);
    }
  });
}
var fixed_size_default = fixedSizeChunker;

// ../../node_modules/.pnpm/ipfs-unixfs-importer@9.0.10/node_modules/ipfs-unixfs-importer/esm/src/dag-builder/validate-chunks.js
var import_err_code4 = __toESM(require_err_code(), 1);

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/identity.js
var identity_exports = {};
__export(identity_exports, {
  identity: () => identity
});
var identity = from({
  prefix: "\0",
  name: "identity",
  encode: (buf2) => toString(buf2),
  decode: (str) => fromString(str)
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base2.js
var base2_exports = {};
__export(base2_exports, {
  base2: () => base2
});
var base2 = rfc4648({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base8.js
var base8_exports = {};
__export(base8_exports, {
  base8: () => base8
});
var base8 = rfc4648({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base10.js
var base10_exports = {};
__export(base10_exports, {
  base10: () => base10
});
var base10 = baseX({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base16.js
var base16_exports = {};
__export(base16_exports, {
  base16: () => base16,
  base16upper: () => base16upper
});
var base16 = rfc4648({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
});
var base16upper = rfc4648({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base36.js
var base36_exports = {};
__export(base36_exports, {
  base36: () => base36,
  base36upper: () => base36upper
});
var base36 = baseX({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
var base36upper = baseX({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base64.js
var base64_exports = {};
__export(base64_exports, {
  base64: () => base64,
  base64pad: () => base64pad,
  base64url: () => base64url,
  base64urlpad: () => base64urlpad
});
var base64 = rfc4648({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad = rfc4648({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url = rfc4648({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad = rfc4648({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base256emoji.js
var base256emoji_exports = {};
__export(base256emoji_exports, {
  base256emoji: () => base256emoji
});
var alphabet = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
var alphabetBytesToChars = alphabet.reduce((p, c, i) => {
  p[i] = c;
  return p;
}, []);
var alphabetCharsToBytes = alphabet.reduce((p, c, i) => {
  p[c.codePointAt(0)] = i;
  return p;
}, []);
function encode9(data) {
  return data.reduce((p, c) => {
    p += alphabetBytesToChars[c];
    return p;
  }, "");
}
function decode10(str) {
  const byts = [];
  for (const char of str) {
    const byt = alphabetCharsToBytes[char.codePointAt(0)];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
var base256emoji = from({
  prefix: "\u{1F680}",
  name: "base256emoji",
  encode: encode9,
  decode: decode10
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/hashes/identity.js
var identity_exports2 = {};
__export(identity_exports2, {
  identity: () => identity2
});
var code4 = 0;
var name4 = "identity";
var encode10 = coerce;
var digest = (input) => create(code4, encode10(input));
var identity2 = {
  code: code4,
  name: name4,
  encode: encode10,
  digest
};

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/codecs/json.js
var textEncoder4 = new TextEncoder();
var textDecoder3 = new TextDecoder();

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/basics.js
var bases = __spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({}, identity_exports), base2_exports), base8_exports), base10_exports), base16_exports), base32_exports), base36_exports), base58_exports), base64_exports), base256emoji_exports);
var hashes = __spreadValues(__spreadValues({}, sha2_exports), identity_exports2);

// ../../node_modules/.pnpm/uint8arrays@3.1.1/node_modules/uint8arrays/esm/src/util/as-uint8array.js
function asUint8Array(buf2) {
  if (globalThis.Buffer != null) {
    return new Uint8Array(buf2.buffer, buf2.byteOffset, buf2.byteLength);
  }
  return buf2;
}

// ../../node_modules/.pnpm/uint8arrays@3.1.1/node_modules/uint8arrays/esm/src/alloc.js
function allocUnsafe(size = 0) {
  if (globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null) {
    return asUint8Array(globalThis.Buffer.allocUnsafe(size));
  }
  return new Uint8Array(size);
}

// ../../node_modules/.pnpm/uint8arrays@3.1.1/node_modules/uint8arrays/esm/src/util/bases.js
function createCodec(name5, prefix, encode12, decode12) {
  return {
    name: name5,
    prefix,
    encoder: {
      name: name5,
      prefix,
      encode: encode12
    },
    decoder: { decode: decode12 }
  };
}
var string = createCodec("utf8", "u", (buf2) => {
  const decoder2 = new TextDecoder("utf8");
  return "u" + decoder2.decode(buf2);
}, (str) => {
  const encoder2 = new TextEncoder();
  return encoder2.encode(str.substring(1));
});
var ascii = createCodec("ascii", "a", (buf2) => {
  let string2 = "a";
  for (let i = 0; i < buf2.length; i++) {
    string2 += String.fromCharCode(buf2[i]);
  }
  return string2;
}, (str) => {
  str = str.substring(1);
  const buf2 = allocUnsafe(str.length);
  for (let i = 0; i < str.length; i++) {
    buf2[i] = str.charCodeAt(i);
  }
  return buf2;
});
var BASES = __spreadValues({
  utf8: string,
  "utf-8": string,
  hex: bases.base16,
  latin1: ascii,
  ascii,
  binary: ascii
}, bases);
var bases_default = BASES;

// ../../node_modules/.pnpm/uint8arrays@3.1.1/node_modules/uint8arrays/esm/src/from-string.js
function fromString3(string2, encoding = "utf8") {
  const base3 = bases_default[encoding];
  if (!base3) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return asUint8Array(globalThis.Buffer.from(string2, "utf-8"));
  }
  return base3.decoder.decode(`${base3.prefix}${string2}`);
}

// ../../node_modules/.pnpm/ipfs-unixfs-importer@9.0.10/node_modules/ipfs-unixfs-importer/esm/src/dag-builder/validate-chunks.js
function validateChunks(source) {
  return __asyncGenerator(this, null, function* () {
    try {
      for (var iter = __forAwait(source), more, temp, error; more = !(temp = yield new __await(iter.next())).done; more = false) {
        const content = temp.value;
        if (content.length === void 0) {
          throw (0, import_err_code4.default)(new Error("Content was invalid"), "ERR_INVALID_CONTENT");
        }
        if (typeof content === "string" || content instanceof String) {
          yield fromString3(content.toString());
        } else if (Array.isArray(content)) {
          yield Uint8Array.from(content);
        } else if (content instanceof Uint8Array) {
          yield content;
        } else {
          throw (0, import_err_code4.default)(new Error("Content was invalid"), "ERR_INVALID_CONTENT");
        }
      }
    } catch (temp) {
      error = [temp];
    } finally {
      try {
        more && (temp = iter.return) && (yield new __await(temp.call(iter)));
      } finally {
        if (error)
          throw error[0];
      }
    }
  });
}
var validate_chunks_default = validateChunks;

// ../../node_modules/.pnpm/ipfs-unixfs-importer@9.0.10/node_modules/ipfs-unixfs-importer/esm/src/dag-builder/index.js
function isIterable(thing) {
  return Symbol.iterator in thing;
}
function isAsyncIterable(thing) {
  return Symbol.asyncIterator in thing;
}
function contentAsAsyncIterable(content) {
  try {
    if (content instanceof Uint8Array) {
      return function() {
        return __asyncGenerator(this, null, function* () {
          yield content;
        });
      }();
    } else if (isIterable(content)) {
      return function() {
        return __asyncGenerator(this, null, function* () {
          yield* __yieldStar(content);
        });
      }();
    } else if (isAsyncIterable(content)) {
      return content;
    }
  } catch (e) {
    throw (0, import_err_code5.default)(new Error("Content was invalid"), "ERR_INVALID_CONTENT");
  }
  throw (0, import_err_code5.default)(new Error("Content was invalid"), "ERR_INVALID_CONTENT");
}
function dagBuilder(source, blockstore, options) {
  return __asyncGenerator(this, null, function* () {
    try {
      for (var iter = __forAwait(source), more, temp, error; more = !(temp = yield new __await(iter.next())).done; more = false) {
        const entry = temp.value;
        if (entry.path) {
          if (entry.path.substring(0, 2) === "./") {
            options.wrapWithDirectory = true;
          }
          entry.path = entry.path.split("/").filter((path) => path && path !== ".").join("/");
        }
        if (entry.content) {
          let chunker;
          if (typeof options.chunker === "function") {
            chunker = options.chunker;
          } else if (options.chunker === "rabin") {
            chunker = rabin_default;
          } else {
            chunker = fixed_size_default;
          }
          let chunkValidator;
          if (typeof options.chunkValidator === "function") {
            chunkValidator = options.chunkValidator;
          } else {
            chunkValidator = validate_chunks_default;
          }
          const file = {
            path: entry.path,
            mtime: entry.mtime,
            mode: entry.mode,
            content: chunker(chunkValidator(contentAsAsyncIterable(entry.content), options), options)
          };
          yield () => file_default(file, blockstore, options);
        } else if (entry.path) {
          const dir = {
            path: entry.path,
            mtime: entry.mtime,
            mode: entry.mode
          };
          yield () => dir_default(dir, blockstore, options);
        } else {
          throw new Error("Import candidate must have content or path or both");
        }
      }
    } catch (temp) {
      error = [temp];
    } finally {
      try {
        more && (temp = iter.return) && (yield new __await(temp.call(iter)));
      } finally {
        if (error)
          throw error[0];
      }
    }
  });
}
var dag_builder_default = dagBuilder;

// ../../node_modules/.pnpm/ipfs-unixfs-importer@9.0.10/node_modules/ipfs-unixfs-importer/esm/src/dir.js
var Dir = class {
  constructor(props, options) {
    this.options = options || {};
    this.root = props.root;
    this.dir = props.dir;
    this.path = props.path;
    this.dirty = props.dirty;
    this.flat = props.flat;
    this.parent = props.parent;
    this.parentKey = props.parentKey;
    this.unixfs = props.unixfs;
    this.mode = props.mode;
    this.mtime = props.mtime;
    this.cid = void 0;
    this.size = void 0;
  }
  put(name5, value) {
    return __async(this, null, function* () {
    });
  }
  get(name5) {
    return Promise.resolve(this);
  }
  eachChildSeries() {
    return __asyncGenerator(this, null, function* () {
    });
  }
  flush(blockstore) {
    return __asyncGenerator(this, null, function* () {
    });
  }
};
var dir_default2 = Dir;

// ../../node_modules/.pnpm/ipfs-unixfs-importer@9.0.10/node_modules/ipfs-unixfs-importer/esm/src/dir-flat.js
var DirFlat = class extends dir_default2 {
  constructor(props, options) {
    super(props, options);
    this._children = {};
  }
  put(name5, value) {
    return __async(this, null, function* () {
      this.cid = void 0;
      this.size = void 0;
      this._children[name5] = value;
    });
  }
  get(name5) {
    return Promise.resolve(this._children[name5]);
  }
  childCount() {
    return Object.keys(this._children).length;
  }
  directChildrenCount() {
    return this.childCount();
  }
  onlyChild() {
    return this._children[Object.keys(this._children)[0]];
  }
  eachChildSeries() {
    return __asyncGenerator(this, null, function* () {
      const keys = Object.keys(this._children);
      for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        yield {
          key,
          child: this._children[key]
        };
      }
    });
  }
  flush(block) {
    return __asyncGenerator(this, null, function* () {
      const children = Object.keys(this._children);
      const links2 = [];
      for (let i = 0; i < children.length; i++) {
        let child = this._children[children[i]];
        if (child instanceof dir_default2) {
          try {
            for (var iter = __forAwait(child.flush(block)), more, temp, error; more = !(temp = yield new __await(iter.next())).done; more = false) {
              const entry = temp.value;
              child = entry;
              yield child;
            }
          } catch (temp) {
            error = [temp];
          } finally {
            try {
              more && (temp = iter.return) && (yield new __await(temp.call(iter)));
            } finally {
              if (error)
                throw error[0];
            }
          }
        }
        if (child.size != null && child.cid) {
          links2.push({
            Name: children[i],
            Tsize: child.size,
            Hash: child.cid
          });
        }
      }
      const unixfs = new UnixFS({
        type: "directory",
        mtime: this.mtime,
        mode: this.mode
      });
      const node = {
        Data: unixfs.marshal(),
        Links: links2
      };
      const buffer2 = encode8(prepare(node));
      const cid = yield new __await(persist_default(buffer2, block, this.options));
      const size = buffer2.length + node.Links.reduce((acc, curr) => acc + (curr.Tsize == null ? 0 : curr.Tsize), 0);
      this.cid = cid;
      this.size = size;
      yield {
        cid,
        unixfs,
        path: this.path,
        size
      };
    });
  }
};
var dir_flat_default = DirFlat;

// ../../node_modules/.pnpm/ipfs-unixfs-importer@9.0.10/node_modules/ipfs-unixfs-importer/esm/src/dir-sharded.js
var import_hamt_sharding = __toESM(require_src3(), 1);
var DirSharded = class extends dir_default2 {
  constructor(props, options) {
    super(props, options);
    this._bucket = (0, import_hamt_sharding.createHAMT)({
      hashFn: options.hamtHashFn,
      bits: options.hamtBucketBits
    });
  }
  put(name5, value) {
    return __async(this, null, function* () {
      yield this._bucket.put(name5, value);
    });
  }
  get(name5) {
    return this._bucket.get(name5);
  }
  childCount() {
    return this._bucket.leafCount();
  }
  directChildrenCount() {
    return this._bucket.childrenCount();
  }
  onlyChild() {
    return this._bucket.onlyChild();
  }
  eachChildSeries() {
    return __asyncGenerator(this, null, function* () {
      try {
        for (var iter = __forAwait(this._bucket.eachLeafSeries()), more, temp, error; more = !(temp = yield new __await(iter.next())).done; more = false) {
          const { key, value } = temp.value;
          yield {
            key,
            child: value
          };
        }
      } catch (temp) {
        error = [temp];
      } finally {
        try {
          more && (temp = iter.return) && (yield new __await(temp.call(iter)));
        } finally {
          if (error)
            throw error[0];
        }
      }
    });
  }
  flush(blockstore) {
    return __asyncGenerator(this, null, function* () {
      try {
        for (var iter = __forAwait(flush(this._bucket, blockstore, this, this.options)), more, temp, error; more = !(temp = yield new __await(iter.next())).done; more = false) {
          const entry = temp.value;
          yield __spreadProps(__spreadValues({}, entry), {
            path: this.path
          });
        }
      } catch (temp) {
        error = [temp];
      } finally {
        try {
          more && (temp = iter.return) && (yield new __await(temp.call(iter)));
        } finally {
          if (error)
            throw error[0];
        }
      }
    });
  }
};
var dir_sharded_default = DirSharded;
function flush(bucket, blockstore, shardRoot, options) {
  return __asyncGenerator(this, null, function* () {
    const children = bucket._children;
    const links2 = [];
    let childrenSize = 0;
    for (let i = 0; i < children.length; i++) {
      const child = children.get(i);
      if (!child) {
        continue;
      }
      const labelPrefix = i.toString(16).toUpperCase().padStart(2, "0");
      if (child instanceof import_hamt_sharding.Bucket) {
        let shard;
        try {
          for (var iter = __forAwait(yield new __await(flush(child, blockstore, null, options))), more, temp, error; more = !(temp = yield new __await(iter.next())).done; more = false) {
            const subShard = temp.value;
            shard = subShard;
          }
        } catch (temp) {
          error = [temp];
        } finally {
          try {
            more && (temp = iter.return) && (yield new __await(temp.call(iter)));
          } finally {
            if (error)
              throw error[0];
          }
        }
        if (!shard) {
          throw new Error("Could not flush sharded directory, no subshard found");
        }
        links2.push({
          Name: labelPrefix,
          Tsize: shard.size,
          Hash: shard.cid
        });
        childrenSize += shard.size;
      } else if (typeof child.value.flush === "function") {
        const dir2 = child.value;
        let flushedDir;
        try {
          for (var iter2 = __forAwait(dir2.flush(blockstore)), more2, temp2, error2; more2 = !(temp2 = yield new __await(iter2.next())).done; more2 = false) {
            const entry = temp2.value;
            flushedDir = entry;
            yield flushedDir;
          }
        } catch (temp2) {
          error2 = [temp2];
        } finally {
          try {
            more2 && (temp2 = iter2.return) && (yield new __await(temp2.call(iter2)));
          } finally {
            if (error2)
              throw error2[0];
          }
        }
        const label = labelPrefix + child.key;
        links2.push({
          Name: label,
          Tsize: flushedDir.size,
          Hash: flushedDir.cid
        });
        childrenSize += flushedDir.size;
      } else {
        const value = child.value;
        if (!value.cid) {
          continue;
        }
        const label = labelPrefix + child.key;
        const size2 = value.size;
        links2.push({
          Name: label,
          Tsize: size2,
          Hash: value.cid
        });
        childrenSize += size2;
      }
    }
    const data = Uint8Array.from(children.bitField().reverse());
    const dir = new UnixFS({
      type: "hamt-sharded-directory",
      data,
      fanout: bucket.tableSize(),
      hashType: options.hamtHashCode,
      mtime: shardRoot && shardRoot.mtime,
      mode: shardRoot && shardRoot.mode
    });
    const node = {
      Data: dir.marshal(),
      Links: links2
    };
    const buffer2 = encode8(prepare(node));
    const cid = yield new __await(persist_default(buffer2, blockstore, options));
    const size = buffer2.length + childrenSize;
    yield {
      cid,
      unixfs: dir,
      size
    };
  });
}

// ../../node_modules/.pnpm/ipfs-unixfs-importer@9.0.10/node_modules/ipfs-unixfs-importer/esm/src/flat-to-shard.js
function flatToShard(child, dir, threshold, options) {
  return __async(this, null, function* () {
    let newDir = dir;
    if (dir instanceof dir_flat_default && dir.directChildrenCount() >= threshold) {
      newDir = yield convertToShard(dir, options);
    }
    const parent = newDir.parent;
    if (parent) {
      if (newDir !== dir) {
        if (child) {
          child.parent = newDir;
        }
        if (!newDir.parentKey) {
          throw new Error("No parent key found");
        }
        yield parent.put(newDir.parentKey, newDir);
      }
      return flatToShard(newDir, parent, threshold, options);
    }
    return newDir;
  });
}
function convertToShard(oldDir, options) {
  return __async(this, null, function* () {
    const newDir = new dir_sharded_default({
      root: oldDir.root,
      dir: true,
      parent: oldDir.parent,
      parentKey: oldDir.parentKey,
      path: oldDir.path,
      dirty: oldDir.dirty,
      flat: false,
      mtime: oldDir.mtime,
      mode: oldDir.mode
    }, options);
    try {
      for (var iter = __forAwait(oldDir.eachChildSeries()), more, temp, error; more = !(temp = yield iter.next()).done; more = false) {
        const { key, child } = temp.value;
        yield newDir.put(key, child);
      }
    } catch (temp) {
      error = [temp];
    } finally {
      try {
        more && (temp = iter.return) && (yield temp.call(iter));
      } finally {
        if (error)
          throw error[0];
      }
    }
    return newDir;
  });
}
var flat_to_shard_default = flatToShard;

// ../../node_modules/.pnpm/ipfs-unixfs-importer@9.0.10/node_modules/ipfs-unixfs-importer/esm/src/utils/to-path-components.js
var toPathComponents = (path = "") => {
  return (path.trim().match(/([^\\/]|\\\/)+/g) || []).filter(Boolean);
};
var to_path_components_default = toPathComponents;

// ../../node_modules/.pnpm/ipfs-unixfs-importer@9.0.10/node_modules/ipfs-unixfs-importer/esm/src/tree-builder.js
function addToTree(elem, tree2, options) {
  return __async(this, null, function* () {
    const pathElems = to_path_components_default(elem.path || "");
    const lastIndex = pathElems.length - 1;
    let parent = tree2;
    let currentPath = "";
    for (let i = 0; i < pathElems.length; i++) {
      const pathElem = pathElems[i];
      currentPath += `${currentPath ? "/" : ""}${pathElem}`;
      const last2 = i === lastIndex;
      parent.dirty = true;
      parent.cid = void 0;
      parent.size = void 0;
      if (last2) {
        yield parent.put(pathElem, elem);
        tree2 = yield flat_to_shard_default(null, parent, options.shardSplitThreshold, options);
      } else {
        let dir = yield parent.get(pathElem);
        if (!dir || !(dir instanceof dir_default2)) {
          dir = new dir_flat_default({
            root: false,
            dir: true,
            parent,
            parentKey: pathElem,
            path: currentPath,
            dirty: true,
            flat: true,
            mtime: dir && dir.unixfs && dir.unixfs.mtime,
            mode: dir && dir.unixfs && dir.unixfs.mode
          }, options);
        }
        yield parent.put(pathElem, dir);
        parent = dir;
      }
    }
    return tree2;
  });
}
function flushAndYield(tree2, blockstore) {
  return __asyncGenerator(this, null, function* () {
    if (!(tree2 instanceof dir_default2)) {
      if (tree2 && tree2.unixfs && tree2.unixfs.isDirectory()) {
        yield tree2;
      }
      return;
    }
    yield* __yieldStar(tree2.flush(blockstore));
  });
}
function treeBuilder(source, block, options) {
  return __asyncGenerator(this, null, function* () {
    let tree2 = new dir_flat_default({
      root: true,
      dir: true,
      path: "",
      dirty: true,
      flat: true
    }, options);
    try {
      for (var iter = __forAwait(source), more, temp, error; more = !(temp = yield new __await(iter.next())).done; more = false) {
        const entry = temp.value;
        if (!entry) {
          continue;
        }
        tree2 = yield new __await(addToTree(entry, tree2, options));
        if (!entry.unixfs || !entry.unixfs.isDirectory()) {
          yield entry;
        }
      }
    } catch (temp) {
      error = [temp];
    } finally {
      try {
        more && (temp = iter.return) && (yield new __await(temp.call(iter)));
      } finally {
        if (error)
          throw error[0];
      }
    }
    if (options.wrapWithDirectory) {
      yield* __yieldStar(flushAndYield(tree2, block));
    } else {
      try {
        for (var iter2 = __forAwait(tree2.eachChildSeries()), more2, temp2, error2; more2 = !(temp2 = yield new __await(iter2.next())).done; more2 = false) {
          const unwrapped = temp2.value;
          if (!unwrapped) {
            continue;
          }
          yield* __yieldStar(flushAndYield(unwrapped.child, block));
        }
      } catch (temp2) {
        error2 = [temp2];
      } finally {
        try {
          more2 && (temp2 = iter2.return) && (yield new __await(temp2.call(iter2)));
        } finally {
          if (error2)
            throw error2[0];
        }
      }
    }
  });
}
var tree_builder_default = treeBuilder;

// ../../node_modules/.pnpm/ipfs-unixfs-importer@9.0.10/node_modules/ipfs-unixfs-importer/esm/src/index.js
function importer(_0, _1) {
  return __asyncGenerator(this, arguments, function* (source, blockstore, options = {}) {
    const opts = options_default(options);
    let dagBuilder2;
    if (typeof options.dagBuilder === "function") {
      dagBuilder2 = options.dagBuilder;
    } else {
      dagBuilder2 = dag_builder_default;
    }
    let treeBuilder2;
    if (typeof options.treeBuilder === "function") {
      treeBuilder2 = options.treeBuilder;
    } else {
      treeBuilder2 = tree_builder_default;
    }
    let candidates;
    if (Symbol.asyncIterator in source || Symbol.iterator in source) {
      candidates = source;
    } else {
      candidates = [source];
    }
    try {
      for (var iter = __forAwait(treeBuilder2((0, import_it_parallel_batch2.default)(dagBuilder2(candidates, blockstore, opts), opts.fileImportConcurrency), blockstore, opts)), more, temp, error; more = !(temp = yield new __await(iter.next())).done; more = false) {
        const entry = temp.value;
        yield {
          cid: entry.cid,
          path: entry.path,
          unixfs: entry.unixfs,
          size: entry.size
        };
      }
    } catch (temp) {
      error = [temp];
    } finally {
      try {
        more && (temp = iter.return) && (yield new __await(temp.call(iter)));
      } finally {
        if (error)
          throw error[0];
      }
    }
  });
}

// ../../node_modules/.pnpm/ipfs-core-utils@0.12.2_node-fetch@3.3.2/node_modules/ipfs-core-utils/esm/src/files/normalise-content.js
var import_err_code6 = __toESM(require_err_code(), 1);
var import_browser_readablestream_to_it = __toESM(require_browser_readablestream_to_it(), 1);
var import_blob_to_it = __toESM(require_blob_to_it(), 1);
var import_it_peekable = __toESM(require_it_peekable(), 1);
var import_it_all2 = __toESM(require_it_all(), 1);
var import_it_map = __toESM(require_it_map(), 1);

// ../../node_modules/.pnpm/ipfs-core-utils@0.12.2_node-fetch@3.3.2/node_modules/ipfs-core-utils/esm/src/files/utils.js
function isBytes(obj) {
  return ArrayBuffer.isView(obj) || obj instanceof ArrayBuffer;
}
function isBlob(obj) {
  return obj.constructor && (obj.constructor.name === "Blob" || obj.constructor.name === "File") && typeof obj.stream === "function";
}
function isFileObject(obj) {
  return typeof obj === "object" && (obj.path || obj.content);
}
var isReadableStream = (value) => value && typeof value.getReader === "function";

// ../../node_modules/.pnpm/ipfs-core-utils@0.12.2_node-fetch@3.3.2/node_modules/ipfs-core-utils/esm/src/files/normalise-content.js
function toAsyncIterable(thing) {
  return __asyncGenerator(this, null, function* () {
    yield thing;
  });
}
function normaliseContent(input) {
  return __async(this, null, function* () {
    if (isBytes(input)) {
      return toAsyncIterable(toBytes(input));
    }
    if (typeof input === "string" || input instanceof String) {
      return toAsyncIterable(toBytes(input.toString()));
    }
    if (isBlob(input)) {
      return (0, import_blob_to_it.default)(input);
    }
    if (isReadableStream(input)) {
      input = (0, import_browser_readablestream_to_it.default)(input);
    }
    if (Symbol.iterator in input || Symbol.asyncIterator in input) {
      const peekable = (0, import_it_peekable.default)(input);
      const { value, done } = yield peekable.peek();
      if (done) {
        return toAsyncIterable(new Uint8Array(0));
      }
      peekable.push(value);
      if (Number.isInteger(value)) {
        return toAsyncIterable(Uint8Array.from(yield (0, import_it_all2.default)(peekable)));
      }
      if (isBytes(value) || typeof value === "string" || value instanceof String) {
        return (0, import_it_map.default)(peekable, toBytes);
      }
    }
    throw (0, import_err_code6.default)(new Error(`Unexpected input: ${input}`), "ERR_UNEXPECTED_INPUT");
  });
}
function toBytes(chunk) {
  if (chunk instanceof Uint8Array) {
    return chunk;
  }
  if (ArrayBuffer.isView(chunk)) {
    return new Uint8Array(chunk.buffer, chunk.byteOffset, chunk.byteLength);
  }
  if (chunk instanceof ArrayBuffer) {
    return new Uint8Array(chunk);
  }
  if (Array.isArray(chunk)) {
    return Uint8Array.from(chunk);
  }
  return fromString3(chunk.toString());
}

// ../../node_modules/.pnpm/ipfs-core-utils@0.12.2_node-fetch@3.3.2/node_modules/ipfs-core-utils/esm/src/files/normalise-candidate-single.js
var import_err_code7 = __toESM(require_err_code(), 1);
var import_browser_readablestream_to_it2 = __toESM(require_browser_readablestream_to_it(), 1);
var import_it_peekable2 = __toESM(require_it_peekable(), 1);
function normaliseCandidateSingle(input, normaliseContent2) {
  return __asyncGenerator(this, null, function* () {
    if (input === null || input === void 0) {
      throw (0, import_err_code7.default)(new Error(`Unexpected input: ${input}`), "ERR_UNEXPECTED_INPUT");
    }
    if (typeof input === "string" || input instanceof String) {
      yield toFileObject(input.toString(), normaliseContent2);
      return;
    }
    if (isBytes(input) || isBlob(input)) {
      yield toFileObject(input, normaliseContent2);
      return;
    }
    if (isReadableStream(input)) {
      input = (0, import_browser_readablestream_to_it2.default)(input);
    }
    if (Symbol.iterator in input || Symbol.asyncIterator in input) {
      const peekable = (0, import_it_peekable2.default)(input);
      const { value, done } = yield new __await(peekable.peek());
      if (done) {
        yield { content: [] };
        return;
      }
      peekable.push(value);
      if (Number.isInteger(value) || isBytes(value) || typeof value === "string" || value instanceof String) {
        yield toFileObject(peekable, normaliseContent2);
        return;
      }
      throw (0, import_err_code7.default)(new Error("Unexpected input: multiple items passed - if you are using ipfs.add, please use ipfs.addAll instead"), "ERR_UNEXPECTED_INPUT");
    }
    if (isFileObject(input)) {
      yield toFileObject(input, normaliseContent2);
      return;
    }
    throw (0, import_err_code7.default)(new Error('Unexpected input: cannot convert "' + typeof input + '" into ImportCandidate'), "ERR_UNEXPECTED_INPUT");
  });
}
function toFileObject(input, normaliseContent2) {
  return __async(this, null, function* () {
    const { path, mode, mtime, content } = input;
    const file = {
      path: path || "",
      mode: parseMode(mode),
      mtime: parseMtime(mtime)
    };
    if (content) {
      file.content = yield normaliseContent2(content);
    } else if (!path) {
      file.content = yield normaliseContent2(input);
    }
    return file;
  });
}

// ../../node_modules/.pnpm/ipfs-core-utils@0.12.2_node-fetch@3.3.2/node_modules/ipfs-core-utils/esm/src/files/normalise-input-single.js
function normaliseInput(input) {
  return normaliseCandidateSingle(input, normaliseContent);
}

// ../../node_modules/.pnpm/ipfs-core-utils@0.12.2_node-fetch@3.3.2/node_modules/ipfs-core-utils/esm/src/files/normalise-candidate-multiple.js
var import_err_code8 = __toESM(require_err_code(), 1);
var import_browser_readablestream_to_it3 = __toESM(require_browser_readablestream_to_it(), 1);
var import_it_peekable3 = __toESM(require_it_peekable(), 1);
var import_it_map2 = __toESM(require_it_map(), 1);
function normaliseCandidateMultiple(input, normaliseContent2) {
  return __asyncGenerator(this, null, function* () {
    if (typeof input === "string" || input instanceof String || isBytes(input) || isBlob(input) || input._readableState) {
      throw (0, import_err_code8.default)(new Error("Unexpected input: single item passed - if you are using ipfs.addAll, please use ipfs.add instead"), "ERR_UNEXPECTED_INPUT");
    }
    if (isReadableStream(input)) {
      input = (0, import_browser_readablestream_to_it3.default)(input);
    }
    if (Symbol.iterator in input || Symbol.asyncIterator in input) {
      const peekable = (0, import_it_peekable3.default)(input);
      const { value, done } = yield new __await(peekable.peek());
      if (done) {
        yield* __yieldStar([]);
        return;
      }
      peekable.push(value);
      if (Number.isInteger(value)) {
        throw (0, import_err_code8.default)(new Error("Unexpected input: single item passed - if you are using ipfs.addAll, please use ipfs.add instead"), "ERR_UNEXPECTED_INPUT");
      }
      if (value._readableState) {
        yield* __yieldStar((0, import_it_map2.default)(peekable, (value2) => toFileObject2({ content: value2 }, normaliseContent2)));
        return;
      }
      if (isBytes(value)) {
        yield toFileObject2({ content: peekable }, normaliseContent2);
        return;
      }
      if (isFileObject(value) || value[Symbol.iterator] || value[Symbol.asyncIterator] || isReadableStream(value) || isBlob(value)) {
        yield* __yieldStar((0, import_it_map2.default)(peekable, (value2) => toFileObject2(value2, normaliseContent2)));
        return;
      }
    }
    if (isFileObject(input)) {
      throw (0, import_err_code8.default)(new Error("Unexpected input: single item passed - if you are using ipfs.addAll, please use ipfs.add instead"), "ERR_UNEXPECTED_INPUT");
    }
    throw (0, import_err_code8.default)(new Error("Unexpected input: " + typeof input), "ERR_UNEXPECTED_INPUT");
  });
}
function toFileObject2(input, normaliseContent2) {
  return __async(this, null, function* () {
    const { path, mode, mtime, content } = input;
    const file = {
      path: path || "",
      mode: parseMode(mode),
      mtime: parseMtime(mtime)
    };
    if (content) {
      file.content = yield normaliseContent2(content);
    } else if (!path) {
      file.content = yield normaliseContent2(input);
    }
    return file;
  });
}

// ../../node_modules/.pnpm/ipfs-core-utils@0.12.2_node-fetch@3.3.2/node_modules/ipfs-core-utils/esm/src/files/normalise-input-multiple.js
function normaliseInput2(input) {
  return normaliseCandidateMultiple(input, normaliseContent);
}

// ../../node_modules/.pnpm/ipfs-car@0.6.2_node-fetch@3.3.2/node_modules/ipfs-car/dist/esm/pack/utils/normalise-input.js
function isBytes2(obj) {
  return ArrayBuffer.isView(obj) || obj instanceof ArrayBuffer;
}
function isBlob2(obj) {
  return Boolean(obj.constructor) && (obj.constructor.name === "Blob" || obj.constructor.name === "File") && typeof obj.stream === "function";
}
function isSingle(input) {
  return typeof input === "string" || input instanceof String || isBytes2(input) || isBlob2(input) || "_readableState" in input;
}
function getNormaliser(input) {
  if (isSingle(input)) {
    return normaliseInput(input);
  } else {
    return normaliseInput2(input);
  }
}

// ../../node_modules/.pnpm/blockstore-core@1.0.5/node_modules/blockstore-core/esm/src/errors.js
var errors_exports = {};
__export(errors_exports, {
  abortedError: () => abortedError,
  notFoundError: () => notFoundError
});
var import_err_code9 = __toESM(require_err_code(), 1);
function notFoundError(err) {
  err = err || new Error("Not Found");
  return (0, import_err_code9.default)(err, "ERR_NOT_FOUND");
}
function abortedError(err) {
  err = err || new Error("Aborted");
  return (0, import_err_code9.default)(err, "ERR_ABORTED");
}

// ../../node_modules/.pnpm/blockstore-core@1.0.5/node_modules/blockstore-core/esm/src/base.js
var import_it_drain = __toESM(require_it_drain(), 1);
var import_it_filter = __toESM(require_it_filter(), 1);
var import_it_take = __toESM(require_it_take(), 1);
var import_it_all3 = __toESM(require_it_all(), 1);
var sortAll = (iterable, sorter) => {
  return function() {
    return __asyncGenerator(this, null, function* () {
      const values = yield new __await((0, import_it_all3.default)(iterable));
      yield* __yieldStar(values.sort(sorter));
    });
  }();
};
var BaseBlockstore = class {
  open() {
    return Promise.reject(new Error(".open is not implemented"));
  }
  close() {
    return Promise.reject(new Error(".close is not implemented"));
  }
  put(key, val, options) {
    return Promise.reject(new Error(".put is not implemented"));
  }
  get(key, options) {
    return Promise.reject(new Error(".get is not implemented"));
  }
  has(key, options) {
    return Promise.reject(new Error(".has is not implemented"));
  }
  delete(key, options) {
    return Promise.reject(new Error(".delete is not implemented"));
  }
  putMany(_0) {
    return __asyncGenerator(this, arguments, function* (source, options = {}) {
      try {
        for (var iter = __forAwait(source), more, temp, error; more = !(temp = yield new __await(iter.next())).done; more = false) {
          const { key, value } = temp.value;
          yield new __await(this.put(key, value, options));
          yield {
            key,
            value
          };
        }
      } catch (temp) {
        error = [temp];
      } finally {
        try {
          more && (temp = iter.return) && (yield new __await(temp.call(iter)));
        } finally {
          if (error)
            throw error[0];
        }
      }
    });
  }
  getMany(_0) {
    return __asyncGenerator(this, arguments, function* (source, options = {}) {
      try {
        for (var iter = __forAwait(source), more, temp, error; more = !(temp = yield new __await(iter.next())).done; more = false) {
          const key = temp.value;
          yield this.get(key, options);
        }
      } catch (temp) {
        error = [temp];
      } finally {
        try {
          more && (temp = iter.return) && (yield new __await(temp.call(iter)));
        } finally {
          if (error)
            throw error[0];
        }
      }
    });
  }
  deleteMany(_0) {
    return __asyncGenerator(this, arguments, function* (source, options = {}) {
      try {
        for (var iter = __forAwait(source), more, temp, error; more = !(temp = yield new __await(iter.next())).done; more = false) {
          const key = temp.value;
          yield new __await(this.delete(key, options));
          yield key;
        }
      } catch (temp) {
        error = [temp];
      } finally {
        try {
          more && (temp = iter.return) && (yield new __await(temp.call(iter)));
        } finally {
          if (error)
            throw error[0];
        }
      }
    });
  }
  batch() {
    let puts = [];
    let dels = [];
    return {
      put(key, value) {
        puts.push({
          key,
          value
        });
      },
      delete(key) {
        dels.push(key);
      },
      commit: (options) => __async(this, null, function* () {
        yield (0, import_it_drain.default)(this.putMany(puts, options));
        puts = [];
        yield (0, import_it_drain.default)(this.deleteMany(dels, options));
        dels = [];
      })
    };
  }
  _all(q, options) {
    return __asyncGenerator(this, null, function* () {
      throw new Error("._all is not implemented");
    });
  }
  _allKeys(q, options) {
    return __asyncGenerator(this, null, function* () {
      throw new Error("._allKeys is not implemented");
    });
  }
  query(q, options) {
    let it = this._all(q, options);
    if (q.prefix != null) {
      it = (0, import_it_filter.default)(it, (e) => e.key.toString().startsWith(q.prefix || ""));
    }
    if (Array.isArray(q.filters)) {
      it = q.filters.reduce((it2, f) => (0, import_it_filter.default)(it2, f), it);
    }
    if (Array.isArray(q.orders)) {
      it = q.orders.reduce((it2, f) => sortAll(it2, f), it);
    }
    if (q.offset != null) {
      let i = 0;
      it = (0, import_it_filter.default)(it, () => i++ >= (q.offset || 0));
    }
    if (q.limit != null) {
      it = (0, import_it_take.default)(it, q.limit);
    }
    return it;
  }
  queryKeys(q, options) {
    let it = this._allKeys(q, options);
    if (q.prefix != null) {
      it = (0, import_it_filter.default)(it, (cid) => cid.toString().startsWith(q.prefix || ""));
    }
    if (Array.isArray(q.filters)) {
      it = q.filters.reduce((it2, f) => (0, import_it_filter.default)(it2, f), it);
    }
    if (Array.isArray(q.orders)) {
      it = q.orders.reduce((it2, f) => sortAll(it2, f), it);
    }
    if (q.offset != null) {
      let i = 0;
      it = (0, import_it_filter.default)(it, () => i++ >= q.offset);
    }
    if (q.limit != null) {
      it = (0, import_it_take.default)(it, q.limit);
    }
    return it;
  }
};

// ../../node_modules/.pnpm/blockstore-core@1.0.5/node_modules/blockstore-core/esm/src/index.js
var Errors = __spreadValues({}, errors_exports);

// ../../node_modules/.pnpm/ipfs-car@0.6.2_node-fetch@3.3.2/node_modules/ipfs-car/dist/esm/blockstore/memory.js
var MemoryBlockStore = class extends BaseBlockstore {
  constructor() {
    super();
    this.store = /* @__PURE__ */ new Map();
  }
  blocks() {
    return __asyncGenerator(this, null, function* () {
      for (const [cidStr, bytes] of this.store.entries()) {
        yield { cid: CID.parse(cidStr), bytes };
      }
    });
  }
  put(cid, bytes) {
    this.store.set(cid.toString(), bytes);
    return Promise.resolve();
  }
  get(cid) {
    const bytes = this.store.get(cid.toString());
    if (!bytes) {
      throw new Error(`block with cid ${cid.toString()} no found`);
    }
    return Promise.resolve(bytes);
  }
  has(cid) {
    return Promise.resolve(this.store.has(cid.toString()));
  }
  close() {
    this.store.clear();
    return Promise.resolve();
  }
};

// ../../node_modules/.pnpm/ipfs-car@0.6.2_node-fetch@3.3.2/node_modules/ipfs-car/dist/esm/pack/constants.js
var unixfsImporterOptionsDefault = {
  cidVersion: 1,
  chunker: "fixed",
  maxChunkSize: 262144,
  hasher: sha256,
  rawLeaves: true,
  wrapWithDirectory: true,
  maxChildrenPerNode: 174
};

// ../../node_modules/.pnpm/ipfs-car@0.6.2_node-fetch@3.3.2/node_modules/ipfs-car/dist/esm/pack/index.js
function pack(_0) {
  return __async(this, arguments, function* ({ input, blockstore: userBlockstore, hasher, maxChunkSize, maxChildrenPerNode, wrapWithDirectory, rawLeaves }) {
    if (!input || Array.isArray(input) && !input.length) {
      throw new Error("missing input file(s)");
    }
    const blockstore = userBlockstore ? userBlockstore : new MemoryBlockStore();
    const rootEntry = yield (0, import_it_last.default)((0, import_it_pipe.default)(getNormaliser(input), (source) => importer(source, blockstore, __spreadProps(__spreadValues({}, unixfsImporterOptionsDefault), {
      hasher: hasher || unixfsImporterOptionsDefault.hasher,
      maxChunkSize: maxChunkSize || unixfsImporterOptionsDefault.maxChunkSize,
      maxChildrenPerNode: maxChildrenPerNode || unixfsImporterOptionsDefault.maxChildrenPerNode,
      wrapWithDirectory: wrapWithDirectory === false ? false : unixfsImporterOptionsDefault.wrapWithDirectory,
      rawLeaves: rawLeaves == null ? unixfsImporterOptionsDefault.rawLeaves : rawLeaves
    }))));
    if (!rootEntry || !rootEntry.cid) {
      throw new Error("given input could not be parsed correctly");
    }
    const root = rootEntry.cid;
    const { writer, out: carOut } = yield CarWriter2.create([root]);
    const carOutIter = carOut[Symbol.asyncIterator]();
    let writingPromise;
    const writeAll = () => __async(this, null, function* () {
      try {
        for (var iter = __forAwait(blockstore.blocks()), more, temp, error; more = !(temp = yield iter.next()).done; more = false) {
          const block = temp.value;
          yield writer.put(block);
        }
      } catch (temp) {
        error = [temp];
      } finally {
        try {
          more && (temp = iter.return) && (yield temp.call(iter));
        } finally {
          if (error)
            throw error[0];
        }
      }
      yield writer.close();
      if (!userBlockstore) {
        yield blockstore.close();
      }
    });
    const out = {
      [Symbol.asyncIterator]() {
        if (writingPromise != null) {
          throw new Error("Multiple iterator not supported");
        }
        writingPromise = writeAll();
        return {
          next() {
            return __async(this, null, function* () {
              const result = yield carOutIter.next();
              if (result.done) {
                yield writingPromise;
              }
              return result;
            });
          }
        };
      }
    };
    return { root, out };
  });
}

// ../../node_modules/.pnpm/nft.storage@7.1.1_node-fetch@3.3.2/node_modules/nft.storage/src/lib.js
var import_throttled_queue = __toESM(require_throttledQueue(), 1);

// ../../node_modules/.pnpm/@web-std+fetch@4.2.1/node_modules/@web-std/fetch/src/fetch.js
import http2 from "http";
import https from "https";
import zlib from "zlib";
import fs3 from "fs";

// ../../node_modules/.pnpm/mrmime@1.0.1/node_modules/mrmime/index.mjs
var mimes = {
  "ez": "application/andrew-inset",
  "aw": "application/applixware",
  "atom": "application/atom+xml",
  "atomcat": "application/atomcat+xml",
  "atomdeleted": "application/atomdeleted+xml",
  "atomsvc": "application/atomsvc+xml",
  "dwd": "application/atsc-dwd+xml",
  "held": "application/atsc-held+xml",
  "rsat": "application/atsc-rsat+xml",
  "bdoc": "application/bdoc",
  "xcs": "application/calendar+xml",
  "ccxml": "application/ccxml+xml",
  "cdfx": "application/cdfx+xml",
  "cdmia": "application/cdmi-capability",
  "cdmic": "application/cdmi-container",
  "cdmid": "application/cdmi-domain",
  "cdmio": "application/cdmi-object",
  "cdmiq": "application/cdmi-queue",
  "cu": "application/cu-seeme",
  "mpd": "application/dash+xml",
  "davmount": "application/davmount+xml",
  "dbk": "application/docbook+xml",
  "dssc": "application/dssc+der",
  "xdssc": "application/dssc+xml",
  "es": "application/ecmascript",
  "ecma": "application/ecmascript",
  "emma": "application/emma+xml",
  "emotionml": "application/emotionml+xml",
  "epub": "application/epub+zip",
  "exi": "application/exi",
  "fdt": "application/fdt+xml",
  "pfr": "application/font-tdpfr",
  "geojson": "application/geo+json",
  "gml": "application/gml+xml",
  "gpx": "application/gpx+xml",
  "gxf": "application/gxf",
  "gz": "application/gzip",
  "hjson": "application/hjson",
  "stk": "application/hyperstudio",
  "ink": "application/inkml+xml",
  "inkml": "application/inkml+xml",
  "ipfix": "application/ipfix",
  "its": "application/its+xml",
  "jar": "application/java-archive",
  "war": "application/java-archive",
  "ear": "application/java-archive",
  "ser": "application/java-serialized-object",
  "class": "application/java-vm",
  "js": "application/javascript",
  "mjs": "application/javascript",
  "json": "application/json",
  "map": "application/json",
  "json5": "application/json5",
  "jsonml": "application/jsonml+json",
  "jsonld": "application/ld+json",
  "lgr": "application/lgr+xml",
  "lostxml": "application/lost+xml",
  "hqx": "application/mac-binhex40",
  "cpt": "application/mac-compactpro",
  "mads": "application/mads+xml",
  "webmanifest": "application/manifest+json",
  "mrc": "application/marc",
  "mrcx": "application/marcxml+xml",
  "ma": "application/mathematica",
  "nb": "application/mathematica",
  "mb": "application/mathematica",
  "mathml": "application/mathml+xml",
  "mbox": "application/mbox",
  "mscml": "application/mediaservercontrol+xml",
  "metalink": "application/metalink+xml",
  "meta4": "application/metalink4+xml",
  "mets": "application/mets+xml",
  "maei": "application/mmt-aei+xml",
  "musd": "application/mmt-usd+xml",
  "mods": "application/mods+xml",
  "m21": "application/mp21",
  "mp21": "application/mp21",
  "mp4s": "application/mp4",
  "m4p": "application/mp4",
  "doc": "application/msword",
  "dot": "application/msword",
  "mxf": "application/mxf",
  "nq": "application/n-quads",
  "nt": "application/n-triples",
  "cjs": "application/node",
  "bin": "application/octet-stream",
  "dms": "application/octet-stream",
  "lrf": "application/octet-stream",
  "mar": "application/octet-stream",
  "so": "application/octet-stream",
  "dist": "application/octet-stream",
  "distz": "application/octet-stream",
  "pkg": "application/octet-stream",
  "bpk": "application/octet-stream",
  "dump": "application/octet-stream",
  "elc": "application/octet-stream",
  "deploy": "application/octet-stream",
  "exe": "application/octet-stream",
  "dll": "application/octet-stream",
  "deb": "application/octet-stream",
  "dmg": "application/octet-stream",
  "iso": "application/octet-stream",
  "img": "application/octet-stream",
  "msi": "application/octet-stream",
  "msp": "application/octet-stream",
  "msm": "application/octet-stream",
  "buffer": "application/octet-stream",
  "oda": "application/oda",
  "opf": "application/oebps-package+xml",
  "ogx": "application/ogg",
  "omdoc": "application/omdoc+xml",
  "onetoc": "application/onenote",
  "onetoc2": "application/onenote",
  "onetmp": "application/onenote",
  "onepkg": "application/onenote",
  "oxps": "application/oxps",
  "relo": "application/p2p-overlay+xml",
  "xer": "application/patch-ops-error+xml",
  "pdf": "application/pdf",
  "pgp": "application/pgp-encrypted",
  "asc": "application/pgp-signature",
  "sig": "application/pgp-signature",
  "prf": "application/pics-rules",
  "p10": "application/pkcs10",
  "p7m": "application/pkcs7-mime",
  "p7c": "application/pkcs7-mime",
  "p7s": "application/pkcs7-signature",
  "p8": "application/pkcs8",
  "ac": "application/pkix-attr-cert",
  "cer": "application/pkix-cert",
  "crl": "application/pkix-crl",
  "pkipath": "application/pkix-pkipath",
  "pki": "application/pkixcmp",
  "pls": "application/pls+xml",
  "ai": "application/postscript",
  "eps": "application/postscript",
  "ps": "application/postscript",
  "provx": "application/provenance+xml",
  "cww": "application/prs.cww",
  "pskcxml": "application/pskc+xml",
  "raml": "application/raml+yaml",
  "rdf": "application/rdf+xml",
  "owl": "application/rdf+xml",
  "rif": "application/reginfo+xml",
  "rnc": "application/relax-ng-compact-syntax",
  "rl": "application/resource-lists+xml",
  "rld": "application/resource-lists-diff+xml",
  "rs": "application/rls-services+xml",
  "rapd": "application/route-apd+xml",
  "sls": "application/route-s-tsid+xml",
  "rusd": "application/route-usd+xml",
  "gbr": "application/rpki-ghostbusters",
  "mft": "application/rpki-manifest",
  "roa": "application/rpki-roa",
  "rsd": "application/rsd+xml",
  "rss": "application/rss+xml",
  "rtf": "application/rtf",
  "sbml": "application/sbml+xml",
  "scq": "application/scvp-cv-request",
  "scs": "application/scvp-cv-response",
  "spq": "application/scvp-vp-request",
  "spp": "application/scvp-vp-response",
  "sdp": "application/sdp",
  "senmlx": "application/senml+xml",
  "sensmlx": "application/sensml+xml",
  "setpay": "application/set-payment-initiation",
  "setreg": "application/set-registration-initiation",
  "shf": "application/shf+xml",
  "siv": "application/sieve",
  "sieve": "application/sieve",
  "smi": "application/smil+xml",
  "smil": "application/smil+xml",
  "rq": "application/sparql-query",
  "srx": "application/sparql-results+xml",
  "gram": "application/srgs",
  "grxml": "application/srgs+xml",
  "sru": "application/sru+xml",
  "ssdl": "application/ssdl+xml",
  "ssml": "application/ssml+xml",
  "swidtag": "application/swid+xml",
  "tei": "application/tei+xml",
  "teicorpus": "application/tei+xml",
  "tfi": "application/thraud+xml",
  "tsd": "application/timestamped-data",
  "toml": "application/toml",
  "trig": "application/trig",
  "ttml": "application/ttml+xml",
  "ubj": "application/ubjson",
  "rsheet": "application/urc-ressheet+xml",
  "td": "application/urc-targetdesc+xml",
  "vxml": "application/voicexml+xml",
  "wasm": "application/wasm",
  "wgt": "application/widget",
  "hlp": "application/winhlp",
  "wsdl": "application/wsdl+xml",
  "wspolicy": "application/wspolicy+xml",
  "xaml": "application/xaml+xml",
  "xav": "application/xcap-att+xml",
  "xca": "application/xcap-caps+xml",
  "xdf": "application/xcap-diff+xml",
  "xel": "application/xcap-el+xml",
  "xns": "application/xcap-ns+xml",
  "xenc": "application/xenc+xml",
  "xhtml": "application/xhtml+xml",
  "xht": "application/xhtml+xml",
  "xlf": "application/xliff+xml",
  "xml": "application/xml",
  "xsl": "application/xml",
  "xsd": "application/xml",
  "rng": "application/xml",
  "dtd": "application/xml-dtd",
  "xop": "application/xop+xml",
  "xpl": "application/xproc+xml",
  "xslt": "application/xml",
  "xspf": "application/xspf+xml",
  "mxml": "application/xv+xml",
  "xhvml": "application/xv+xml",
  "xvml": "application/xv+xml",
  "xvm": "application/xv+xml",
  "yang": "application/yang",
  "yin": "application/yin+xml",
  "zip": "application/zip",
  "3gpp": "video/3gpp",
  "adp": "audio/adpcm",
  "amr": "audio/amr",
  "au": "audio/basic",
  "snd": "audio/basic",
  "mid": "audio/midi",
  "midi": "audio/midi",
  "kar": "audio/midi",
  "rmi": "audio/midi",
  "mxmf": "audio/mobile-xmf",
  "mp3": "audio/mpeg",
  "m4a": "audio/mp4",
  "mp4a": "audio/mp4",
  "mpga": "audio/mpeg",
  "mp2": "audio/mpeg",
  "mp2a": "audio/mpeg",
  "m2a": "audio/mpeg",
  "m3a": "audio/mpeg",
  "oga": "audio/ogg",
  "ogg": "audio/ogg",
  "spx": "audio/ogg",
  "opus": "audio/ogg",
  "s3m": "audio/s3m",
  "sil": "audio/silk",
  "wav": "audio/wav",
  "weba": "audio/webm",
  "xm": "audio/xm",
  "ttc": "font/collection",
  "otf": "font/otf",
  "ttf": "font/ttf",
  "woff": "font/woff",
  "woff2": "font/woff2",
  "exr": "image/aces",
  "apng": "image/apng",
  "avif": "image/avif",
  "bmp": "image/bmp",
  "cgm": "image/cgm",
  "drle": "image/dicom-rle",
  "emf": "image/emf",
  "fits": "image/fits",
  "g3": "image/g3fax",
  "gif": "image/gif",
  "heic": "image/heic",
  "heics": "image/heic-sequence",
  "heif": "image/heif",
  "heifs": "image/heif-sequence",
  "hej2": "image/hej2k",
  "hsj2": "image/hsj2",
  "ief": "image/ief",
  "jls": "image/jls",
  "jp2": "image/jp2",
  "jpg2": "image/jp2",
  "jpeg": "image/jpeg",
  "jpg": "image/jpeg",
  "jpe": "image/jpeg",
  "jph": "image/jph",
  "jhc": "image/jphc",
  "jpm": "image/jpm",
  "jpx": "image/jpx",
  "jpf": "image/jpx",
  "jxr": "image/jxr",
  "jxra": "image/jxra",
  "jxrs": "image/jxrs",
  "jxs": "image/jxs",
  "jxsc": "image/jxsc",
  "jxsi": "image/jxsi",
  "jxss": "image/jxss",
  "ktx": "image/ktx",
  "ktx2": "image/ktx2",
  "png": "image/png",
  "btif": "image/prs.btif",
  "pti": "image/prs.pti",
  "sgi": "image/sgi",
  "svg": "image/svg+xml",
  "svgz": "image/svg+xml",
  "t38": "image/t38",
  "tif": "image/tiff",
  "tiff": "image/tiff",
  "tfx": "image/tiff-fx",
  "webp": "image/webp",
  "wmf": "image/wmf",
  "disposition-notification": "message/disposition-notification",
  "u8msg": "message/global",
  "u8dsn": "message/global-delivery-status",
  "u8mdn": "message/global-disposition-notification",
  "u8hdr": "message/global-headers",
  "eml": "message/rfc822",
  "mime": "message/rfc822",
  "3mf": "model/3mf",
  "gltf": "model/gltf+json",
  "glb": "model/gltf-binary",
  "igs": "model/iges",
  "iges": "model/iges",
  "msh": "model/mesh",
  "mesh": "model/mesh",
  "silo": "model/mesh",
  "mtl": "model/mtl",
  "obj": "model/obj",
  "stpz": "model/step+zip",
  "stpxz": "model/step-xml+zip",
  "stl": "model/stl",
  "wrl": "model/vrml",
  "vrml": "model/vrml",
  "x3db": "model/x3d+fastinfoset",
  "x3dbz": "model/x3d+binary",
  "x3dv": "model/x3d-vrml",
  "x3dvz": "model/x3d+vrml",
  "x3d": "model/x3d+xml",
  "x3dz": "model/x3d+xml",
  "appcache": "text/cache-manifest",
  "manifest": "text/cache-manifest",
  "ics": "text/calendar",
  "ifb": "text/calendar",
  "coffee": "text/coffeescript",
  "litcoffee": "text/coffeescript",
  "css": "text/css",
  "csv": "text/csv",
  "html": "text/html",
  "htm": "text/html",
  "shtml": "text/html",
  "jade": "text/jade",
  "jsx": "text/jsx",
  "less": "text/less",
  "markdown": "text/markdown",
  "md": "text/markdown",
  "mml": "text/mathml",
  "mdx": "text/mdx",
  "n3": "text/n3",
  "txt": "text/plain",
  "text": "text/plain",
  "conf": "text/plain",
  "def": "text/plain",
  "list": "text/plain",
  "log": "text/plain",
  "in": "text/plain",
  "ini": "text/plain",
  "dsc": "text/prs.lines.tag",
  "rtx": "text/richtext",
  "sgml": "text/sgml",
  "sgm": "text/sgml",
  "shex": "text/shex",
  "slim": "text/slim",
  "slm": "text/slim",
  "spdx": "text/spdx",
  "stylus": "text/stylus",
  "styl": "text/stylus",
  "tsv": "text/tab-separated-values",
  "t": "text/troff",
  "tr": "text/troff",
  "roff": "text/troff",
  "man": "text/troff",
  "me": "text/troff",
  "ms": "text/troff",
  "ttl": "text/turtle",
  "uri": "text/uri-list",
  "uris": "text/uri-list",
  "urls": "text/uri-list",
  "vcard": "text/vcard",
  "vtt": "text/vtt",
  "yaml": "text/yaml",
  "yml": "text/yaml",
  "3gp": "video/3gpp",
  "3g2": "video/3gpp2",
  "h261": "video/h261",
  "h263": "video/h263",
  "h264": "video/h264",
  "m4s": "video/iso.segment",
  "jpgv": "video/jpeg",
  "jpgm": "image/jpm",
  "mj2": "video/mj2",
  "mjp2": "video/mj2",
  "ts": "video/mp2t",
  "mp4": "video/mp4",
  "mp4v": "video/mp4",
  "mpg4": "video/mp4",
  "mpeg": "video/mpeg",
  "mpg": "video/mpeg",
  "mpe": "video/mpeg",
  "m1v": "video/mpeg",
  "m2v": "video/mpeg",
  "ogv": "video/ogg",
  "qt": "video/quicktime",
  "mov": "video/quicktime",
  "webm": "video/webm"
};
function lookup(extn) {
  let tmp = ("" + extn).trim().toLowerCase();
  let idx = tmp.lastIndexOf(".");
  return mimes[!~idx ? tmp : tmp.substring(++idx)];
}

// ../../node_modules/.pnpm/@web-std+fetch@4.2.1/node_modules/@web-std/fetch/src/fetch.js
var import_data_uri_to_buffer = __toESM(require_src4(), 1);
import { Buffer as Buffer2 } from "buffer";

// ../../node_modules/.pnpm/@web-std+fetch@4.2.1/node_modules/@web-std/fetch/src/body.js
import Stream2 from "stream";
import { types as types2 } from "util";

// ../../node_modules/.pnpm/web-encoding@1.1.5/node_modules/web-encoding/src/lib.mjs
var Encoder2 = TextEncoder;
var Decoder2 = TextDecoder;

// ../../node_modules/.pnpm/@web-std+stream@1.0.0/node_modules/@web-std/stream/src/lib.node.js
var import_stream = __toESM(require_stream(), 1);
var {
  ReadableStream: ReadableStream2,
  ReadableStreamDefaultReader: ReadableStreamDefaultReader2,
  ReadableStreamBYOBReader: ReadableStreamBYOBReader2,
  ReadableStreamBYOBRequest: ReadableStreamBYOBRequest2,
  ReadableByteStreamController: ReadableByteStreamController2,
  ReadableStreamDefaultController: ReadableStreamDefaultController2,
  TransformStream: TransformStream2,
  TransformStreamDefaultController: TransformStreamDefaultController2,
  WritableStream: WritableStream2,
  WritableStreamDefaultWriter: WritableStreamDefaultWriter2,
  WritableStreamDefaultController: WritableStreamDefaultController2,
  ByteLengthQueuingStrategy: ByteLengthQueuingStrategy2,
  CountQueuingStrategy: CountQueuingStrategy2,
  TextEncoderStream,
  TextDecoderStream
} = import_stream.default;

// ../../node_modules/.pnpm/@web-std+blob@3.0.5/node_modules/@web-std/blob/src/blob.js
var WebBlob = class Blob {
  /**
   * @param {BlobPart[]} [init]
   * @param {BlobPropertyBag} [options]
   */
  constructor(init = [], options = {}) {
    const parts = [];
    let size = 0;
    for (const part of init) {
      if (typeof part === "string") {
        const bytes = new Encoder2().encode(part);
        parts.push(bytes);
        size += bytes.byteLength;
      } else if (part instanceof WebBlob) {
        size += part.size;
        parts.push(...part._parts);
      } else if (part instanceof ArrayBuffer) {
        parts.push(new Uint8Array(part));
        size += part.byteLength;
      } else if (part instanceof Uint8Array) {
        parts.push(part);
        size += part.byteLength;
      } else if (ArrayBuffer.isView(part)) {
        const { buffer: buffer2, byteOffset, byteLength } = part;
        parts.push(new Uint8Array(buffer2, byteOffset, byteLength));
        size += byteLength;
      } else {
        const bytes = new Encoder2().encode(String(part));
        parts.push(bytes);
        size += bytes.byteLength;
      }
    }
    this._size = size;
    this._type = readType(options.type);
    this._parts = parts;
    Object.defineProperties(this, {
      _size: { enumerable: false },
      _type: { enumerable: false },
      _parts: { enumerable: false }
    });
  }
  /**
   * A string indicating the MIME type of the data contained in the Blob.
   * If the type is unknown, this string is empty.
   * @type {string}
   */
  get type() {
    return this._type;
  }
  /**
   * The size, in bytes, of the data contained in the Blob object.
   * @type {number}
   */
  get size() {
    return this._size;
  }
  /**
   * Returns a new Blob object containing the data in the specified range of
   * bytes of the blob on which it's called.
   * @param {number} [start=0] - An index into the Blob indicating the first
   * byte to include in the new Blob. If you specify a negative value, it's
   * treated as an offset from the end of the Blob toward the beginning. For
   * example, `-10` would be the 10th from last byte in the Blob. The default
   * value is `0`. If you specify a value for start that is larger than the
   * size of the source Blob, the returned Blob has size 0 and contains no
   * data.
   * @param {number} [end] - An index into the `Blob` indicating the first byte
   *  that will *not* be included in the new `Blob` (i.e. the byte exactly at
   * this index is not included). If you specify a negative value, it's treated
   * as an offset from the end of the Blob toward the beginning. For example,
   * `-10` would be the 10th from last byte in the `Blob`. The default value is
   * size.
   * @param {string} [type] - The content type to assign to the new Blob;
   * this will be the value of its type property. The default value is an empty
   * string.
   * @returns {Blob}
   */
  slice(start = 0, end = this.size, type = "") {
    const { size, _parts } = this;
    let offset = start < 0 ? Math.max(size + start, 0) : Math.min(start, size);
    let limit = end < 0 ? Math.max(size + end, 0) : Math.min(end, size);
    const span = Math.max(limit - offset, 0);
    const blob = new Blob([], { type });
    if (span === 0) {
      return blob;
    }
    let blobSize = 0;
    const blobParts = [];
    for (const part of _parts) {
      const { byteLength } = part;
      if (offset > 0 && byteLength <= offset) {
        offset -= byteLength;
        limit -= byteLength;
      } else {
        const chunk = part.subarray(offset, Math.min(byteLength, limit));
        blobParts.push(chunk);
        blobSize += chunk.byteLength;
        offset = 0;
        if (blobSize >= span) {
          break;
        }
      }
    }
    blob._parts = blobParts;
    blob._size = blobSize;
    return blob;
  }
  /**
   * Returns a promise that resolves with an ArrayBuffer containing the entire
   * contents of the Blob as binary data.
   * @returns {Promise<ArrayBuffer>}
   */
  // eslint-disable-next-line require-await
  arrayBuffer() {
    return __async(this, null, function* () {
      const buffer2 = new ArrayBuffer(this.size);
      const bytes = new Uint8Array(buffer2);
      let offset = 0;
      for (const part of this._parts) {
        bytes.set(part, offset);
        offset += part.byteLength;
      }
      return buffer2;
    });
  }
  /**
   * Returns a promise that resolves with a USVString containing the entire
   * contents of the Blob interpreted as UTF-8 text.
   * @returns {Promise<string>}
   */
  // eslint-disable-next-line require-await
  text() {
    return __async(this, null, function* () {
      const decoder2 = new Decoder2();
      let text = "";
      for (const part of this._parts) {
        text += decoder2.decode(part);
      }
      return text;
    });
  }
  /**
   * @returns {BlobStream}
   */
  stream() {
    return new BlobStream(this._parts);
  }
  /**
   * @returns {string}
   */
  toString() {
    return "[object Blob]";
  }
  get [Symbol.toStringTag]() {
    return "Blob";
  }
};
var Blob2 = WebBlob;
var BlobStream = class extends ReadableStream2 {
  /**
   * @param {Uint8Array[]} chunks
   */
  constructor(chunks) {
    super(new BlobStreamController(chunks.values()), { type: "bytes" });
    this._chunks = chunks;
  }
  /**
   * @param {Object} [_options]
   * @property {boolean} [_options.preventCancel]
   * @returns {AsyncIterator<Uint8Array>}
   */
  [Symbol.asyncIterator](_options) {
    return __asyncGenerator(this, null, function* () {
      const reader = this.getReader();
      yield* __yieldStar(this._chunks);
      reader.releaseLock();
    });
  }
};
var BlobStreamController = class {
  /**
   * @param {Iterator<Uint8Array>} chunks
   */
  constructor(chunks) {
    this.chunks = chunks;
  }
  /**
   * @param {ReadableStreamDefaultController} controller
   */
  start(controller) {
    this.work(controller);
    this.isWorking = false;
    this.isCancelled = false;
  }
  /**
   *
   * @param {ReadableStreamDefaultController} controller
   */
  work(controller) {
    return __async(this, null, function* () {
      const { chunks } = this;
      this.isWorking = true;
      while (!this.isCancelled && (controller.desiredSize || 0) > 0) {
        let next = null;
        try {
          next = chunks.next();
        } catch (error) {
          controller.error(error);
          break;
        }
        if (next) {
          if (!next.done && !this.isCancelled) {
            controller.enqueue(next.value);
          } else {
            controller.close();
          }
        }
      }
      this.isWorking = false;
    });
  }
  /**
   * @param {ReadableStreamDefaultController} controller
   */
  pull(controller) {
    if (!this.isWorking) {
      this.work(controller);
    }
  }
  cancel() {
    this.isCancelled = true;
  }
};
var readType = (input = "") => {
  const type = String(input).toLowerCase();
  return /[^\u0020-\u007E]/.test(type) ? "" : type;
};

// ../../node_modules/.pnpm/@web-std+blob@3.0.5/node_modules/@web-std/blob/src/lib.node.js
var Blob3 = globalThis.Blob || // Disable node native blob until impractical perf issue is fixed
// @see https://github.com/nodejs/node/issues/42108
// NodeBlob ||
Blob2;

// ../../node_modules/.pnpm/@web-std+file@3.0.3/node_modules/@web-std/file/src/file.js
var File = class extends Blob3 {
  /**
   *
   * @param {BlobPart[]} init
   * @param {string} name - A USVString representing the file name or the path
   * to the file.
   * @param {FilePropertyBag} [options]
   */
  constructor(init, name5 = panic(new TypeError("File constructor requires name argument")), options = {}) {
    super(init, options);
    this._name = name5;
    this._lastModified = options.lastModified || Date.now();
  }
  /**
   * The name of the file referenced by the File object.
   * @type {string}
   */
  get name() {
    return this._name;
  }
  /**
   * The path the URL of the File is relative to.
   * @type {string}
   */
  get webkitRelativePath() {
    return "";
  }
  /**
   * Returns the last modified time of the file, in millisecond since the UNIX
   * epoch (January 1st, 1970 at Midnight).
   * @returns {number}
   */
  get lastModified() {
    return this._lastModified;
  }
  get [Symbol.toStringTag]() {
    return "File";
  }
};
var panic = (error) => {
  throw error;
};

// ../../node_modules/.pnpm/@web-std+file@3.0.3/node_modules/@web-std/file/src/lib.node.js
var File2 = typeof globalThis.File === "function" ? globalThis.File : File;

// ../../node_modules/.pnpm/@web-std+form-data@3.1.0/node_modules/@web-std/form-data/src/form-data.js
var FormData = class {
  /**
   * @param {HTMLFormElement} [form]
   */
  constructor(form) {
    this._entries = [];
    Object.defineProperty(this, "_entries", { enumerable: false });
    if (isHTMLFormElement(form)) {
      for (const element of form.elements) {
        if (isSelectElement(element)) {
          for (const option of element.options) {
            if (option.selected) {
              this.append(element.name, option.value);
            }
          }
        } else if (isInputElement(element) && (element.checked || !["radio", "checkbox"].includes(element.type)) && element.name) {
          this.append(element.name, element.value);
        }
      }
    }
  }
  get [Symbol.toStringTag]() {
    return "FormData";
  }
  /**
   * Appends a new value onto an existing key inside a FormData object, or adds
   * the key if it does not already exist.
   *
   * The difference between `set` and `append` is that if the specified key
   * already exists, `set` will overwrite all existing values with the new one,
   * whereas `append` will append the new value onto the end of the existing
   * set of values.
   *
   * @param {string} name
   * @param {string|Blob|File} value - The name of the field whose data is
   * contained in value.
   * @param {string} [filename] - The filename reported to the server, when a
   * value is a `Blob` or a `File`. The default filename for a `Blob` objects is
   * `"blob"`. The default filename for a `File` is the it's name.
   */
  append(name5, value = panic2(
    new TypeError("FormData.append: requires at least 2 arguments")
  ), filename) {
    this._entries.push([name5, toEntryValue(value, filename)]);
  }
  /**
   * Deletes a key and all its values from a FormData object.
   *
   * @param {string} name
   */
  delete(name5 = panic2(new TypeError("FormData.delete: requires string argument"))) {
    const entries = this._entries;
    let index = 0;
    while (index < entries.length) {
      const [entryName] = (
        /** @type {[string, FormDataEntryValue]}*/
        entries[index]
      );
      if (entryName === name5) {
        entries.splice(index, 1);
      } else {
        index++;
      }
    }
  }
  /**
   * Returns the first value associated with a given key from within a
   * FormData object.
   *
   * @param {string} name
   * @returns {FormDataEntryValue|null}
   */
  get(name5 = panic2(new TypeError("FormData.get: requires string argument"))) {
    for (const [entryName, value] of this._entries) {
      if (entryName === name5) {
        return value;
      }
    }
    return null;
  }
  /**
   * Returns an array of all the values associated with a given key from within
   * a FormData.
   *
   * @param {string} name
   * @returns {FormDataEntryValue[]}
   */
  getAll(name5 = panic2(new TypeError("FormData.getAll: requires string argument"))) {
    const values = [];
    for (const [entryName, value] of this._entries) {
      if (entryName === name5) {
        values.push(value);
      }
    }
    return values;
  }
  /**
   * Returns a boolean stating whether a FormData object contains a certain key.
   *
   * @param {string} name
   */
  has(name5 = panic2(new TypeError("FormData.has: requires string argument"))) {
    for (const [entryName] of this._entries) {
      if (entryName === name5) {
        return true;
      }
    }
    return false;
  }
  /**
   * Sets a new value for an existing key inside a FormData object, or adds the
   * key/value if it does not already exist.
   *
   * @param {string} name
   * @param {string|Blob|File} value
   * @param {string} [filename]
   */
  set(name5, value = panic2(new TypeError("FormData.set: requires at least 2 arguments")), filename) {
    let index = 0;
    const { _entries: entries } = this;
    const entryValue = toEntryValue(value, filename);
    let wasSet = false;
    while (index < entries.length) {
      const entry = (
        /** @type {[string, FormDataEntryValue]}*/
        entries[index]
      );
      if (entry[0] === name5) {
        if (wasSet) {
          entries.splice(index, 1);
        } else {
          wasSet = true;
          entry[1] = entryValue;
          index++;
        }
      } else {
        index++;
      }
    }
    if (!wasSet) {
      entries.push([name5, entryValue]);
    }
  }
  /**
   * Method returns an iterator allowing to go through all key/value pairs
   * contained in this object.
   */
  entries() {
    return this._entries.values();
  }
  /**
   * Returns an iterator allowing to go through all keys of the key/value pairs
   * contained in this object.
   *
   * @returns {IterableIterator<string>}
   */
  *keys() {
    for (const [name5] of this._entries) {
      yield name5;
    }
  }
  /**
   * Returns an iterator allowing to go through all values contained in this
   * object.
   *
   * @returns {IterableIterator<FormDataEntryValue>}
   */
  *values() {
    for (const [_, value] of this._entries) {
      yield value;
    }
  }
  [Symbol.iterator]() {
    return this._entries.values();
  }
  /**
   * @param {(value: FormDataEntryValue, key: string, parent: globalThis.FormData) => void} fn
   * @param {any} [thisArg]
   * @returns {void}
   */
  forEach(fn, thisArg) {
    for (const [key, value] of this._entries) {
      fn.call(thisArg, value, key, this);
    }
  }
};
var isHTMLFormElement = (value) => Object.prototype.toString.call(value) === "[object HTMLFormElement]";
var toEntryValue = (value, filename) => {
  if (isFile(value)) {
    return filename != null ? new BlobFile([value], filename, value) : value;
  } else if (isBlob3(value)) {
    return new BlobFile([value], filename != null ? filename : "blob");
  } else {
    if (filename != null && filename != "") {
      throw new TypeError(
        "filename is only supported when value is Blob or File"
      );
    }
    return `${value}`;
  }
};
var isFile = (value) => Object.prototype.toString.call(value) === "[object File]" && typeof value.name === "string";
var isBlob3 = (value) => Object.prototype.toString.call(value) === "[object Blob]";
var BlobFile = class File3 {
  /**
   * @param {[Blob]} parts
   * @param {string} name
   * @param {FilePropertyBag} [options]
   */
  constructor([blob], name5, { lastModified = Date.now() } = {}) {
    this.blob = blob;
    this.name = name5;
    this.lastModified = lastModified;
  }
  get webkitRelativePath() {
    return "";
  }
  get size() {
    return this.blob.size;
  }
  get type() {
    return this.blob.type;
  }
  /**
   *
   * @param {number} [start]
   * @param {number} [end]
   * @param {string} [contentType]
   */
  slice(start, end, contentType) {
    return this.blob.slice(start, end, contentType);
  }
  stream() {
    return this.blob.stream();
  }
  text() {
    return this.blob.text();
  }
  arrayBuffer() {
    return this.blob.arrayBuffer();
  }
  get [Symbol.toStringTag]() {
    return "File";
  }
};
var panic2 = (error) => {
  throw error;
};
function isSelectElement(element) {
  return element.tagName === "SELECT";
}
function isInputElement(element) {
  return element.tagName === "INPUT" || element.tagName === "TEXTAREA";
}

// ../../node_modules/.pnpm/@web-std+form-data@3.1.0/node_modules/@web-std/form-data/src/lib.node.js
var FormData2 = typeof globalThis.FormData === "function" ? globalThis.FormData : FormData;

// ../../node_modules/.pnpm/@web-std+fetch@4.2.1/node_modules/@web-std/fetch/src/errors/base.js
var FetchBaseError = class extends Error {
  /**
   * @param {string} message 
   * @param {string} type 
   */
  constructor(message, type) {
    super(message);
    Error.captureStackTrace(this, this.constructor);
    this.type = type;
  }
  get name() {
    return this.constructor.name;
  }
  get [Symbol.toStringTag]() {
    return this.constructor.name;
  }
};

// ../../node_modules/.pnpm/@web-std+fetch@4.2.1/node_modules/@web-std/fetch/src/errors/fetch-error.js
var FetchError = class extends FetchBaseError {
  /**
   * @param  {string} message -      Error message for human
   * @param  {string} type -        Error type for machine
   * @param  {SystemError} [systemError] - For Node.js system error
   */
  constructor(message, type, systemError) {
    super(message, type);
    if (systemError) {
      this.code = this.errno = systemError.code;
      this.erroredSysCall = systemError.syscall;
    }
  }
};

// ../../node_modules/.pnpm/@web-std+fetch@4.2.1/node_modules/@web-std/fetch/src/utils/form-data.js
import { randomBytes } from "crypto";

// ../../node_modules/.pnpm/@web3-storage+multipart-parser@1.0.0/node_modules/@web3-storage/multipart-parser/esm/src/utils.js
function stringToArray(s) {
  const utf8 = unescape(encodeURIComponent(s));
  return Uint8Array.from(utf8, (_, i) => utf8.charCodeAt(i));
}
function arrayToString(a) {
  const utf8 = String.fromCharCode.apply(null, a);
  return decodeURIComponent(escape(utf8));
}
function mergeArrays(...arrays) {
  const out = new Uint8Array(arrays.reduce((total, arr) => total + arr.length, 0));
  let offset = 0;
  for (const arr of arrays) {
    out.set(arr, offset);
    offset += arr.length;
  }
  return out;
}
function arraysEqual(a, b) {
  if (a.length !== b.length) {
    return false;
  }
  for (let i = 0; i < a.length; i++) {
    if (a[i] !== b[i]) {
      return false;
    }
  }
  return true;
}

// ../../node_modules/.pnpm/@web3-storage+multipart-parser@1.0.0/node_modules/@web3-storage/multipart-parser/esm/src/search.js
function coerce2(a) {
  if (a instanceof Uint8Array) {
    return (index) => a[index];
  }
  return a;
}
function jsmemcmp(buf1, pos1, buf2, pos2, len) {
  const fn1 = coerce2(buf1);
  const fn2 = coerce2(buf2);
  for (let i = 0; i < len; ++i) {
    if (fn1(pos1 + i) !== fn2(pos2 + i)) {
      return false;
    }
  }
  return true;
}
function createOccurenceTable(s) {
  const table = new Array(256).fill(s.length);
  if (s.length > 1) {
    for (let i = 0; i < s.length - 1; i++) {
      table[s[i]] = s.length - 1 - i;
    }
  }
  return table;
}
var MATCH = Symbol("Match");
var StreamSearch = class {
  constructor(needle) {
    this._lookbehind = new Uint8Array();
    if (typeof needle === "string") {
      this._needle = needle = stringToArray(needle);
    } else {
      this._needle = needle;
    }
    this._lastChar = needle[needle.length - 1];
    this._occ = createOccurenceTable(needle);
  }
  feed(chunk) {
    let pos = 0;
    let tokens;
    const allTokens = [];
    while (pos !== chunk.length) {
      ;
      [pos, ...tokens] = this._feed(chunk, pos);
      allTokens.push(...tokens);
    }
    return allTokens;
  }
  end() {
    const tail = this._lookbehind;
    this._lookbehind = new Uint8Array();
    return tail;
  }
  _feed(data, bufPos) {
    const tokens = [];
    let pos = -this._lookbehind.length;
    if (pos < 0) {
      while (pos < 0 && pos <= data.length - this._needle.length) {
        const ch = this._charAt(data, pos + this._needle.length - 1);
        if (ch === this._lastChar && this._memcmp(data, pos, this._needle.length - 1)) {
          if (pos > -this._lookbehind.length) {
            tokens.push(this._lookbehind.slice(0, this._lookbehind.length + pos));
          }
          tokens.push(MATCH);
          this._lookbehind = new Uint8Array();
          return [
            pos + this._needle.length,
            ...tokens
          ];
        } else {
          pos += this._occ[ch];
        }
      }
      if (pos < 0) {
        while (pos < 0 && !this._memcmp(data, pos, data.length - pos)) {
          pos++;
        }
      }
      if (pos >= 0) {
        tokens.push(this._lookbehind);
        this._lookbehind = new Uint8Array();
      } else {
        const bytesToCutOff = this._lookbehind.length + pos;
        if (bytesToCutOff > 0) {
          tokens.push(this._lookbehind.slice(0, bytesToCutOff));
          this._lookbehind = this._lookbehind.slice(bytesToCutOff);
        }
        this._lookbehind = Uint8Array.from(new Array(this._lookbehind.length + data.length), (_, i) => this._charAt(data, i - this._lookbehind.length));
        return [
          data.length,
          ...tokens
        ];
      }
    }
    pos += bufPos;
    while (pos <= data.length - this._needle.length) {
      const ch = data[pos + this._needle.length - 1];
      if (ch === this._lastChar && data[pos] === this._needle[0] && jsmemcmp(this._needle, 0, data, pos, this._needle.length - 1)) {
        if (pos > bufPos) {
          tokens.push(data.slice(bufPos, pos));
        }
        tokens.push(MATCH);
        return [
          pos + this._needle.length,
          ...tokens
        ];
      } else {
        pos += this._occ[ch];
      }
    }
    if (pos < data.length) {
      while (pos < data.length && (data[pos] !== this._needle[0] || !jsmemcmp(data, pos, this._needle, 0, data.length - pos))) {
        ++pos;
      }
      if (pos < data.length) {
        this._lookbehind = data.slice(pos);
      }
    }
    if (pos > 0) {
      tokens.push(data.slice(bufPos, pos < data.length ? pos : data.length));
    }
    return [
      data.length,
      ...tokens
    ];
  }
  _charAt(data, pos) {
    if (pos < 0) {
      return this._lookbehind[this._lookbehind.length + pos];
    }
    return data[pos];
  }
  _memcmp(data, pos, len) {
    return jsmemcmp(this._charAt.bind(this, data), pos, this._needle, 0, len);
  }
};
var ReadableStreamSearch = class {
  constructor(needle, _readableStream) {
    this._readableStream = _readableStream;
    this._search = new StreamSearch(needle);
  }
  [Symbol.asyncIterator]() {
    return __asyncGenerator(this, null, function* () {
      const reader = this._readableStream.getReader();
      try {
        while (true) {
          const result = yield new __await(reader.read());
          if (result.done) {
            break;
          }
          yield* __yieldStar(this._search.feed(result.value));
        }
        const tail = this._search.end();
        if (tail.length) {
          yield tail;
        }
      } finally {
        reader.releaseLock();
      }
    });
  }
};
var EOQ = Symbol("End of Queue");
var QueueableStreamSearch = class {
  constructor(needle) {
    this._chunksQueue = [];
    this._closed = false;
    this._search = new StreamSearch(needle);
  }
  push(...chunks) {
    if (this._closed) {
      throw new Error("cannot call push after close");
    }
    this._chunksQueue.push(...chunks);
    if (this._notify) {
      this._notify();
    }
  }
  close() {
    if (this._closed) {
      throw new Error("close was already called");
    }
    this._closed = true;
    this._chunksQueue.push(EOQ);
    if (this._notify) {
      this._notify();
    }
  }
  [Symbol.asyncIterator]() {
    return __asyncGenerator(this, null, function* () {
      while (true) {
        let chunk;
        while (!(chunk = this._chunksQueue.shift())) {
          yield new __await(new Promise((resolve) => this._notify = resolve));
          this._notify = void 0;
        }
        if (chunk === EOQ) {
          break;
        }
        yield* __yieldStar(this._search.feed(chunk));
      }
      const tail = this._search.end();
      if (tail.length) {
        yield tail;
      }
    });
  }
};

// ../../node_modules/.pnpm/@web3-storage+multipart-parser@1.0.0/node_modules/@web3-storage/multipart-parser/esm/src/index.js
var mergeArrays2 = Function.prototype.apply.bind(mergeArrays, void 0);
var dash = stringToArray("--");
var CRLF = stringToArray("\r\n");
function parseContentDisposition(header) {
  const parts = header.split(";").map((part) => part.trim());
  if (parts.shift() !== "form-data") {
    throw new Error('malformed content-disposition header: missing "form-data" in `' + JSON.stringify(parts) + "`");
  }
  const out = {};
  for (const part of parts) {
    const kv = part.split("=", 2);
    if (kv.length !== 2) {
      throw new Error("malformed content-disposition header: key-value pair not found - " + part + " in `" + header + "`");
    }
    const [name5, value] = kv;
    if (value[0] === '"' && value[value.length - 1] === '"') {
      out[name5] = value.slice(1, -1).replace(/\\"/g, '"');
    } else if (value[0] !== '"' && value[value.length - 1] !== '"') {
      out[name5] = value;
    } else if (value[0] === '"' && value[value.length - 1] !== '"' || value[0] !== '"' && value[value.length - 1] === '"') {
      throw new Error("malformed content-disposition header: mismatched quotations in `" + header + "`");
    }
  }
  if (!out.name) {
    throw new Error("malformed content-disposition header: missing field name in `" + header + "`");
  }
  return out;
}
function parsePartHeaders(lines) {
  const entries = [];
  let disposition = false;
  let line;
  while (typeof (line = lines.shift()) !== "undefined") {
    const colon = line.indexOf(":");
    if (colon === -1) {
      throw new Error("malformed multipart-form header: missing colon");
    }
    const header = line.slice(0, colon).trim().toLowerCase();
    const value = line.slice(colon + 1).trim();
    switch (header) {
      case "content-disposition":
        disposition = true;
        entries.push(...Object.entries(parseContentDisposition(value)));
        break;
      case "content-type":
        entries.push([
          "contentType",
          value
        ]);
    }
  }
  if (!disposition) {
    throw new Error("malformed multipart-form header: missing content-disposition");
  }
  return Object.fromEntries(entries);
}
function readHeaderLines(it, needle) {
  return __async(this, null, function* () {
    let firstChunk = true;
    let lastTokenWasMatch = false;
    const headerLines = [[]];
    const crlfSearch = new StreamSearch(CRLF);
    for (; ; ) {
      const result = yield it.next();
      if (result.done) {
        throw new Error("malformed multipart-form data: unexpected end of stream");
      }
      if (firstChunk && result.value !== MATCH && arraysEqual(result.value.slice(0, 2), dash)) {
        return [
          void 0,
          new Uint8Array()
        ];
      }
      let chunk;
      if (result.value !== MATCH) {
        chunk = result.value;
      } else if (!lastTokenWasMatch) {
        chunk = needle;
      } else {
        throw new Error("malformed multipart-form data: unexpected boundary");
      }
      if (!chunk.length) {
        continue;
      }
      if (firstChunk) {
        firstChunk = false;
      }
      const tokens = crlfSearch.feed(chunk);
      for (const [i, token] of tokens.entries()) {
        const isMatch = token === MATCH;
        if (!isMatch && !token.length) {
          continue;
        }
        if (lastTokenWasMatch && isMatch) {
          tokens.push(crlfSearch.end());
          return [
            headerLines.filter((chunks) => chunks.length).map(mergeArrays2).map(arrayToString),
            mergeArrays(...tokens.slice(i + 1).map((token2) => token2 === MATCH ? CRLF : token2))
          ];
        }
        if (lastTokenWasMatch = isMatch) {
          headerLines.push([]);
        } else {
          headerLines[headerLines.length - 1].push(token);
        }
      }
    }
  });
}
function streamMultipart(body, boundary) {
  return __asyncGenerator(this, null, function* () {
    const needle = mergeArrays(dash, stringToArray(boundary));
    const it = new ReadableStreamSearch(needle, body)[Symbol.asyncIterator]();
    for (; ; ) {
      const result = yield new __await(it.next());
      if (result.done) {
        return;
      }
      if (result.value === MATCH) {
        break;
      }
    }
    const crlfSearch = new StreamSearch(CRLF);
    for (; ; ) {
      let feedChunk2 = function(chunk) {
        const chunks = [];
        for (const token of crlfSearch.feed(chunk)) {
          if (trailingCRLF) {
            chunks.push(CRLF);
          }
          if (!(trailingCRLF = token === MATCH)) {
            chunks.push(token);
          }
        }
        return mergeArrays(...chunks);
      };
      var feedChunk = feedChunk2;
      let _a2;
      const [headerLines, tail] = yield new __await(readHeaderLines(it, needle));
      if (!headerLines) {
        return;
      }
      function nextToken() {
        return __async(this, null, function* () {
          const result = yield it.next();
          if (result.done) {
            throw new Error("malformed multipart-form data: unexpected end of stream");
          }
          return result;
        });
      }
      let trailingCRLF = false;
      let done = false;
      function nextChunk() {
        return __async(this, null, function* () {
          const result = yield nextToken();
          let chunk;
          if (result.value !== MATCH) {
            chunk = result.value;
          } else if (!trailingCRLF) {
            chunk = CRLF;
          } else {
            done = true;
            return { value: crlfSearch.end() };
          }
          return { value: feedChunk2(chunk) };
        });
      }
      const bufferedChunks = [{ value: feedChunk2(tail) }];
      yield __spreadProps(__spreadValues({}, parsePartHeaders(headerLines)), {
        data: {
          [Symbol.asyncIterator]() {
            return this;
          },
          next() {
            return __async(this, null, function* () {
              for (; ; ) {
                const result = bufferedChunks.shift();
                if (!result) {
                  break;
                }
                if (result.value.length > 0) {
                  return result;
                }
              }
              for (; ; ) {
                if (done) {
                  return {
                    done,
                    value: void 0
                  };
                }
                const result = yield nextChunk();
                if (result.value.length > 0) {
                  return result;
                }
              }
            });
          }
        }
      });
      while (!done) {
        bufferedChunks.push(yield new __await(nextChunk()));
      }
    }
  });
}
function iterateMultipart(body, boundary) {
  return __asyncGenerator(this, null, function* () {
    try {
      for (var iter2 = __forAwait(streamMultipart(body, boundary)), more2, temp2, error2; more2 = !(temp2 = yield new __await(iter2.next())).done; more2 = false) {
        const part = temp2.value;
        const chunks = [];
        try {
          for (var iter = __forAwait(part.data), more, temp, error; more = !(temp = yield new __await(iter.next())).done; more = false) {
            const chunk = temp.value;
            chunks.push(chunk);
          }
        } catch (temp) {
          error = [temp];
        } finally {
          try {
            more && (temp = iter.return) && (yield new __await(temp.call(iter)));
          } finally {
            if (error)
              throw error[0];
          }
        }
        yield __spreadProps(__spreadValues({}, part), {
          data: mergeArrays(...chunks)
        });
      }
    } catch (temp2) {
      error2 = [temp2];
    } finally {
      try {
        more2 && (temp2 = iter2.return) && (yield new __await(temp2.call(iter2)));
      } finally {
        if (error2)
          throw error2[0];
      }
    }
  });
}

// ../../node_modules/.pnpm/@web-std+fetch@4.2.1/node_modules/@web-std/fetch/src/utils/is.js
import Stream from "stream";
var NAME = Symbol.toStringTag;
var isURLSearchParameters = (object) => {
  return typeof object === "object" && typeof object.append === "function" && typeof object.delete === "function" && typeof object.get === "function" && typeof object.getAll === "function" && typeof object.has === "function" && typeof object.set === "function" && typeof object.sort === "function" && object[NAME] === "URLSearchParams";
};
var isBlob4 = (object) => {
  return typeof object === "object" && typeof object.arrayBuffer === "function" && typeof object.type === "string" && typeof object.stream === "function" && typeof object.constructor === "function" && /^(Blob|File)$/.test(object[NAME]);
};
function isFormData(object) {
  return typeof object === "object" && typeof object.append === "function" && typeof object.set === "function" && typeof object.get === "function" && typeof object.getAll === "function" && typeof object.delete === "function" && typeof object.keys === "function" && typeof object.values === "function" && typeof object.entries === "function" && typeof object.constructor === "function" && object[NAME] === "FormData";
}
var isMultipartFormDataStream = (value) => {
  return value instanceof Stream === true && typeof value.getBoundary === "function" && typeof value.hasKnownLength === "function" && typeof value.getLengthSync === "function";
};
var isAbortSignal2 = (object) => {
  return typeof object === "object" && (object[NAME] === "AbortSignal" || object[NAME] === "EventTarget");
};
var isReadableStream2 = (value) => {
  return typeof value === "object" && typeof value.getReader === "function" && typeof value.cancel === "function" && typeof value.tee === "function";
};
var isIterable2 = (value) => value && Symbol.iterator in value;

// ../../node_modules/.pnpm/@web-std+fetch@4.2.1/node_modules/@web-std/fetch/src/utils/form-data.js
var carriage = "\r\n";
var dashes = "-".repeat(2);
var carriageLength = Buffer.byteLength(carriage);
var getFooter = (boundary) => `${dashes}${boundary}${dashes}${carriage.repeat(2)}`;
function getHeader(boundary, name5, field) {
  let header = "";
  header += `${dashes}${boundary}${carriage}`;
  header += `Content-Disposition: form-data; name="${name5}"`;
  if (isBlob4(field)) {
    const { name: name6 = "blob", type } = (
      /** @type {Blob & {name?:string}} */
      field
    );
    header += `; filename="${name6}"${carriage}`;
    header += `Content-Type: ${type || "application/octet-stream"}`;
  }
  return `${header}${carriage.repeat(2)}`;
}
var getBoundary = () => randomBytes(8).toString("hex");
function formDataIterator(form, boundary) {
  return __asyncGenerator(this, null, function* () {
    const encoder2 = new TextEncoder();
    for (const [name5, value] of form) {
      yield encoder2.encode(getHeader(boundary, name5, value));
      if (isBlob4(value)) {
        yield* __yieldStar(value.stream());
      } else {
        yield encoder2.encode(value);
      }
      yield encoder2.encode(carriage);
    }
    yield encoder2.encode(getFooter(boundary));
  });
}
function getFormDataLength(form, boundary) {
  let length2 = 0;
  for (const [name5, value] of form) {
    length2 += Buffer.byteLength(getHeader(boundary, name5, value));
    if (isBlob4(value)) {
      length2 += value.size;
    } else {
      length2 += Buffer.byteLength(String(value));
    }
    length2 += carriageLength;
  }
  length2 += Buffer.byteLength(getFooter(boundary));
  return length2;
}
var toFormData = (source) => __async(void 0, null, function* () {
  let { body, headers } = source;
  const contentType = (headers == null ? void 0 : headers.get("Content-Type")) || "";
  if (contentType.startsWith("application/x-www-form-urlencoded") && body != null) {
    const form = new FormData2();
    let bodyText = yield source.text();
    new URLSearchParams(bodyText).forEach((v, k) => form.append(k, v));
    return form;
  }
  const [type, boundary] = contentType.split(/\s*;\s*boundary=/);
  if (type === "multipart/form-data" && boundary != null && body != null) {
    const form = new FormData2();
    const parts = iterateMultipart(body, boundary);
    try {
      for (var iter = __forAwait(parts), more, temp, error; more = !(temp = yield iter.next()).done; more = false) {
        const { name: name5, data, filename, contentType: contentType2 } = temp.value;
        if (typeof filename === "string") {
          form.append(name5, new File2([data], filename, { type: contentType2 }));
        } else if (typeof filename !== "undefined") {
          form.append(name5, new File2([], "", { type: contentType2 }));
        } else {
          form.append(name5, new TextDecoder().decode(data), filename);
        }
      }
    } catch (temp) {
      error = [temp];
    } finally {
      try {
        more && (temp = iter.return) && (yield temp.call(iter));
      } finally {
        if (error)
          throw error[0];
      }
    }
    return form;
  } else {
    throw new TypeError("Could not parse content as FormData.");
  }
});

// ../../node_modules/.pnpm/@web-std+fetch@4.2.1/node_modules/@web-std/fetch/src/utils/utf8.js
import { TextEncoder as TextEncoder2, TextDecoder as TextDecoder2 } from "util";
var encoder = new TextEncoder2();
var decoder = new TextDecoder2();
var encode11 = (text) => encoder.encode(text);
var decode11 = (bytes) => decoder.decode(bytes);

// ../../node_modules/.pnpm/@web-std+fetch@4.2.1/node_modules/@web-std/fetch/src/body.js
var { readableHighWaterMark } = new Stream2.Readable();
var INTERNALS = Symbol("Body internals");
var Body = class {
  /**
   * @param {BodyInit|Stream|null} body
   * @param {{size?:number}} options
   */
  constructor(body, {
    size = 0
  } = {}) {
    const state = {
      /** @type {null|ReadableStream<Uint8Array>} */
      body: null,
      /** @type {string|null} */
      type: null,
      /** @type {number|null} */
      size: null,
      /** @type {null|string} */
      boundary: null,
      disturbed: false,
      /** @type {null|Error} */
      error: null
    };
    this[INTERNALS] = state;
    if (body === null) {
      state.body = null;
      state.size = 0;
    } else if (isURLSearchParameters(body)) {
      const bytes = encode11(body.toString());
      state.body = fromBytes2(bytes);
      state.size = bytes.byteLength;
      state.type = "application/x-www-form-urlencoded;charset=UTF-8";
    } else if (isBlob4(body)) {
      state.size = body.size;
      state.type = body.type || null;
      state.body = body.stream();
    } else if (body instanceof Uint8Array) {
      state.body = fromBytes2(body);
      state.size = body.byteLength;
    } else if (types2.isAnyArrayBuffer(body)) {
      const bytes = new Uint8Array(body);
      state.body = fromBytes2(bytes);
      state.size = bytes.byteLength;
    } else if (ArrayBuffer.isView(body)) {
      const bytes = new Uint8Array(body.buffer, body.byteOffset, body.byteLength);
      state.body = fromBytes2(bytes);
      state.size = bytes.byteLength;
    } else if (isReadableStream2(body)) {
      state.body = body;
    } else if (isFormData(body)) {
      const boundary = `NodeFetchFormDataBoundary${getBoundary()}`;
      state.type = `multipart/form-data; boundary=${boundary}`;
      state.size = getFormDataLength(body, boundary);
      state.body = fromAsyncIterable(formDataIterator(body, boundary));
    } else if (isMultipartFormDataStream(body)) {
      state.type = `multipart/form-data; boundary=${body.getBoundary()}`;
      state.size = body.hasKnownLength() ? body.getLengthSync() : null;
      state.body = fromStream(body);
    } else if (body instanceof Stream2) {
      state.body = fromStream(body);
    } else {
      const bytes = encode11(String(body));
      state.type = "text/plain;charset=UTF-8";
      state.size = bytes.byteLength;
      state.body = fromBytes2(bytes);
    }
    this.size = size;
  }
  /** @type {Headers} */
  /* c8 ignore next 3 */
  get headers() {
    throw new TypeError(`'get headers' called on an object that does not implements interface.`);
  }
  get body() {
    return this[INTERNALS].body;
  }
  get bodyUsed() {
    return this[INTERNALS].disturbed;
  }
  /**
   * Decode response as ArrayBuffer
   *
   * @return {Promise<ArrayBuffer>}
   */
  arrayBuffer() {
    return __async(this, null, function* () {
      const { buffer: buffer2, byteOffset, byteLength } = yield consumeBody(this);
      return buffer2.slice(byteOffset, byteOffset + byteLength);
    });
  }
  /**
   * Return raw response as Blob
   *
   * @return Promise
   */
  blob() {
    return __async(this, null, function* () {
      const ct = this.headers && this.headers.get("content-type") || this[INTERNALS].body && this[INTERNALS].type || "";
      const buf2 = yield consumeBody(this);
      return new Blob3([buf2], {
        type: ct
      });
    });
  }
  /**
   * Decode response as json
   *
   * @return  Promise
   */
  json() {
    return __async(this, null, function* () {
      return JSON.parse(yield this.text());
    });
  }
  /**
   * Decode response as text
   *
   * @return  Promise
   */
  text() {
    return __async(this, null, function* () {
      const buffer2 = yield consumeBody(this);
      return decode11(buffer2);
    });
  }
  /**
   * @returns {Promise<FormData>}
   */
  formData() {
    return __async(this, null, function* () {
      return toFormData(this);
    });
  }
};
Object.defineProperties(Body.prototype, {
  body: { enumerable: true },
  bodyUsed: { enumerable: true },
  arrayBuffer: { enumerable: true },
  blob: { enumerable: true },
  json: { enumerable: true },
  text: { enumerable: true },
  formData: { enumerable: true }
});
function consumeBody(data) {
  return __async(this, null, function* () {
    const state = data[INTERNALS];
    if (state.disturbed) {
      throw new TypeError(`body used already for: ${data.url}`);
    }
    state.disturbed = true;
    if (state.error) {
      throw state.error;
    }
    const { body } = state;
    if (body === null) {
      return new Uint8Array(0);
    }
    const [buffer2, chunks, limit] = data.size > 0 ? [new Uint8Array(data.size), [], data.size] : [null, [], Infinity];
    let offset = 0;
    const source = streamIterator(body);
    try {
      try {
        for (var iter = __forAwait(source), more, temp, error; more = !(temp = yield iter.next()).done; more = false) {
          const chunk = temp.value;
          const bytes = chunk instanceof Uint8Array ? chunk : Buffer.from(chunk);
          if (offset + bytes.byteLength > limit) {
            const error2 = new FetchError(`content size at ${data.url} over limit: ${limit}`, "max-size");
            source.throw(error2);
            throw error2;
          } else if (buffer2) {
            buffer2.set(bytes, offset);
          } else {
            chunks.push(bytes);
          }
          offset += bytes.byteLength;
        }
      } catch (temp) {
        error = [temp];
      } finally {
        try {
          more && (temp = iter.return) && (yield temp.call(iter));
        } finally {
          if (error)
            throw error[0];
        }
      }
      if (buffer2) {
        if (offset < buffer2.byteLength) {
          throw new FetchError(`Premature close of server response while trying to fetch ${data.url}`, "premature-close");
        } else {
          return buffer2;
        }
      } else {
        return writeBytes(new Uint8Array(offset), chunks);
      }
    } catch (error2) {
      if (error2 instanceof FetchBaseError) {
        throw error2;
      } else if (error2 && error2.name === "AbortError") {
        throw error2;
      } else {
        const e = (
          /** @type {import('./errors/fetch-error').SystemError} */
          error2
        );
        throw new FetchError(`Invalid response body while trying to fetch ${data.url}: ${e.message}`, "system", e);
      }
    }
  });
}
var clone = (instance) => {
  const { body } = instance;
  if (instance.bodyUsed) {
    throw new Error("cannot clone body after it is used");
  }
  if (!body) {
    return null;
  }
  const [left, right] = body.tee();
  instance[INTERNALS].body = left;
  return right;
};
var extractContentType = (source) => source[INTERNALS].type;
var getTotalBytes = (source) => source[INTERNALS].size;
var writeToStream = (dest, { body }) => {
  if (body === null) {
    dest.end();
  } else {
    Stream2.Readable.from(streamIterator(body)).pipe(dest);
  }
};
var StreamIterableIterator = class {
  /**
   * @param {ReadableStream<T>} stream
   */
  constructor(stream) {
    this.stream = stream;
    this.reader = null;
  }
  /**
   * @returns {AsyncGenerator<T, void, void>}
   */
  [Symbol.asyncIterator]() {
    return this;
  }
  getReader() {
    if (this.reader) {
      return this.reader;
    }
    const reader = this.stream.getReader();
    this.reader = reader;
    return reader;
  }
  /**
   * @returns {Promise<IteratorResult<T, void>>}
   */
  next() {
    return (
      /** @type {Promise<IteratorResult<T, void>>} */
      this.getReader().read()
    );
  }
  /**
   * @returns {Promise<IteratorResult<T, void>>}
   */
  return() {
    return __async(this, null, function* () {
      if (this.reader) {
        yield this.reader.cancel();
      }
      return { done: true, value: void 0 };
    });
  }
  /**
   * 
   * @param {any} error 
   * @returns {Promise<IteratorResult<T, void>>}
   */
  throw(error) {
    return __async(this, null, function* () {
      yield this.getReader().cancel(error);
      return { done: true, value: void 0 };
    });
  }
};
var streamIterator = (stream) => new StreamIterableIterator(stream);
var writeBytes = (buffer2, chunks) => {
  let offset = 0;
  for (const chunk of chunks) {
    buffer2.set(chunk, offset);
    offset += chunk.byteLength;
  }
  return buffer2;
};
var fromBytes2 = (bytes) => new ReadableStream2({
  start(controller) {
    controller.enqueue(bytes);
    controller.close();
  }
});
var fromAsyncIterable = (content) => (
  // @ts-ignore
  new ReadableStream2(new AsyncIterablePump(content))
);
var AsyncIterablePump = class {
  /**
   * @param {AsyncIterable<Uint8Array>} source
   */
  constructor(source) {
    this.source = source[Symbol.asyncIterator]();
  }
  /**
   * @param {ReadableStreamController<Uint8Array>} controller
   */
  pull(controller) {
    return __async(this, null, function* () {
      try {
        while (controller.desiredSize || 0 > 0) {
          const next = yield this.source.next();
          if (next.done) {
            controller.close();
            break;
          } else {
            controller.enqueue(next.value);
          }
        }
      } catch (error) {
        controller.error(error);
      }
    });
  }
  /**
   * @param {any} [reason]
   */
  cancel(reason) {
    if (reason) {
      if (typeof this.source.throw === "function") {
        this.source.throw(reason);
      } else if (typeof this.source.return === "function") {
        this.source.return();
      }
    } else if (typeof this.source.return === "function") {
      this.source.return();
    }
  }
};
var fromStream = (source) => {
  const pump2 = new StreamPump(source);
  const stream = new ReadableStream2(pump2, pump2);
  return stream;
};
var StreamPump = class {
  /**
   * @param {Stream & {
   * 	readableHighWaterMark?: number
   * 	readable?:boolean,
   * 	resume?: () => void,
   * 	pause?: () => void
   * 	destroy?: (error?:Error) => void
   * }} stream
   */
  constructor(stream) {
    this.highWaterMark = stream.readableHighWaterMark || readableHighWaterMark;
    this.accumalatedSize = 0;
    this.stream = stream;
    this.enqueue = this.enqueue.bind(this);
    this.error = this.error.bind(this);
    this.close = this.close.bind(this);
  }
  /**
   * @param {Uint8Array} [chunk]
   */
  size(chunk) {
    return (chunk == null ? void 0 : chunk.byteLength) || 0;
  }
  /**
   * @param {ReadableStreamController<Uint8Array>} controller
   */
  start(controller) {
    this.controller = controller;
    this.stream.on("data", this.enqueue);
    this.stream.once("error", this.error);
    this.stream.once("end", this.close);
    this.stream.once("close", this.close);
  }
  pull() {
    this.resume();
  }
  /**
   * @param {any} [reason]
   */
  cancel(reason) {
    if (this.stream.destroy) {
      this.stream.destroy(reason);
    }
    this.stream.off("data", this.enqueue);
    this.stream.off("error", this.error);
    this.stream.off("end", this.close);
    this.stream.off("close", this.close);
  }
  /**
   * @param {Uint8Array|string} chunk
   */
  enqueue(chunk) {
    if (this.controller) {
      try {
        const bytes = chunk instanceof Uint8Array ? chunk : Buffer.from(chunk);
        const available = (this.controller.desiredSize || 0) - bytes.byteLength;
        this.controller.enqueue(bytes);
        if (available <= 0) {
          this.pause();
        }
      } catch (e) {
        this.controller.error(new Error("Could not create Buffer, chunk must be of type string or an instance of Buffer, ArrayBuffer, or Array or an Array-like Object"));
        this.cancel();
      }
    }
  }
  pause() {
    if (this.stream.pause) {
      this.stream.pause();
    }
  }
  resume() {
    if (this.stream.readable && this.stream.resume) {
      this.stream.resume();
    }
  }
  close() {
    if (this.controller) {
      this.controller.close();
      delete this.controller;
    }
  }
  /**
   * @param {Error} error 
   */
  error(error) {
    if (this.controller) {
      this.controller.error(error);
      delete this.controller;
    }
  }
};

// ../../node_modules/.pnpm/@web-std+fetch@4.2.1/node_modules/@web-std/fetch/src/headers.js
import { types as types3 } from "util";
import http from "http";
var validators = (
  /** @type {{validateHeaderName?:(name:string) => any, validateHeaderValue?:(name:string, value:string) => any}} */
  http
);
var validateHeaderName = typeof validators.validateHeaderName === "function" ? validators.validateHeaderName : (
  /**
   * @param {string} name 
   */
  (name5) => {
    if (!/^[\^`\-\w!#$%&'*+.|~]+$/.test(name5)) {
      const err = new TypeError(`Header name must be a valid HTTP token [${name5}]`);
      Object.defineProperty(err, "code", { value: "ERR_INVALID_HTTP_TOKEN" });
      throw err;
    }
  }
);
var validateHeaderValue = typeof validators.validateHeaderValue === "function" ? validators.validateHeaderValue : (
  /**
   * @param {string} name 
   * @param {string} value 
   */
  (name5, value) => {
    if (/[^\t\u0020-\u007E\u0080-\u00FF]/.test(value)) {
      const err = new TypeError(`Invalid character in header content ["${name5}"]`);
      Object.defineProperty(err, "code", { value: "ERR_INVALID_CHAR" });
      throw err;
    }
  }
);
var Headers = class _Headers extends URLSearchParams {
  /**
   * Headers class
   *
   * @constructor
   * @param {HeadersInit} [init] - Response headers
   */
  constructor(init) {
    let result = [];
    if (init instanceof _Headers) {
      const raw = init.raw();
      for (const [name5, values] of Object.entries(raw)) {
        result.push(...values.map((value) => [name5, value]));
      }
    } else if (init == null) {
    } else if (isIterable2(init)) {
      result = [...init].map((pair) => {
        if (typeof pair !== "object" || types3.isBoxedPrimitive(pair)) {
          throw new TypeError("Each header pair must be an iterable object");
        }
        return [...pair];
      }).map((pair) => {
        if (pair.length !== 2) {
          throw new TypeError("Each header pair must be a name/value tuple");
        }
        return [...pair];
      });
    } else if (typeof init === "object" && init !== null) {
      result.push(...Object.entries(init));
    } else {
      throw new TypeError("Failed to construct 'Headers': The provided value is not of type '(sequence<sequence<ByteString>> or record<ByteString, ByteString>)");
    }
    result = result.length > 0 ? result.map(([name5, value]) => {
      validateHeaderName(name5);
      validateHeaderValue(name5, String(value));
      return [String(name5).toLowerCase(), String(value)];
    }) : [];
    super(result);
    return new Proxy(this, {
      get(target, p, receiver) {
        switch (p) {
          case "append":
          case "set":
            return (name5, value) => {
              validateHeaderName(name5);
              validateHeaderValue(name5, String(value));
              return URLSearchParams.prototype[p].call(
                receiver,
                String(name5).toLowerCase(),
                String(value)
              );
            };
          case "delete":
          case "has":
          case "getAll":
            return (name5) => {
              validateHeaderName(name5);
              return URLSearchParams.prototype[p].call(
                receiver,
                String(name5).toLowerCase()
              );
            };
          case "keys":
            return () => {
              target.sort();
              return new Set(URLSearchParams.prototype.keys.call(target)).keys();
            };
          default:
            return Reflect.get(target, p, receiver);
        }
      }
      /* c8 ignore next */
    });
  }
  get [Symbol.toStringTag]() {
    return this.constructor.name;
  }
  toString() {
    return Object.prototype.toString.call(this);
  }
  /**
   * 
   * @param {string} name 
   */
  get(name5) {
    const values = this.getAll(name5);
    if (values.length === 0) {
      return null;
    }
    let value = values.join(", ");
    if (/^content-encoding$/i.test(name5)) {
      value = value.toLowerCase();
    }
    return value;
  }
  /**
   * @param {(value: string, key: string, parent: this) => void} callback 
   * @param {any} thisArg 
   * @returns {void}
   */
  forEach(callback, thisArg = void 0) {
    for (const name5 of this.keys()) {
      if (name5.toLowerCase() === "set-cookie") {
        let cookies = this.getAll(name5);
        while (cookies.length > 0) {
          Reflect.apply(callback, thisArg, [cookies.shift(), name5, this]);
        }
      } else {
        Reflect.apply(callback, thisArg, [this.get(name5), name5, this]);
      }
    }
  }
  /**
   * @returns {IterableIterator<string>}
   */
  *values() {
    for (const name5 of this.keys()) {
      if (name5.toLowerCase() === "set-cookie") {
        let cookies = this.getAll(name5);
        while (cookies.length > 0) {
          yield (
            /** @type {string} */
            cookies.shift()
          );
        }
      } else {
        yield (
          /** @type {string} */
          this.get(name5)
        );
      }
    }
  }
  /**
   * @returns {IterableIterator<[string, string]>}
   */
  *entries() {
    for (const name5 of this.keys()) {
      if (name5.toLowerCase() === "set-cookie") {
        let cookies = this.getAll(name5);
        while (cookies.length > 0) {
          yield [
            name5,
            /** @type {string} */
            cookies.shift()
          ];
        }
      } else {
        yield [
          name5,
          /** @type {string} */
          this.get(name5)
        ];
      }
    }
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  /**
   * Node-fetch non-spec method
   * returning all headers and their values as array
   * @returns {Record<string, string[]>}
   */
  raw() {
    return [...this.keys()].reduce(
      (result, key) => {
        result[key] = this.getAll(key);
        return result;
      },
      /** @type {Record<string, string[]>} */
      {}
    );
  }
  /**
   * For better console.log(headers) and also to convert Headers into Node.js Request compatible format
   */
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return [...this.keys()].reduce(
      (result, key) => {
        const values = this.getAll(key);
        if (key === "host") {
          result[key] = values[0];
        } else {
          result[key] = values.length > 1 ? values : values[0];
        }
        return result;
      },
      /** @type {Record<string, string|string[]>} */
      {}
    );
  }
};
Object.defineProperties(
  Headers.prototype,
  ["get", "entries", "forEach", "values"].reduce(
    (result, property) => {
      result[property] = { enumerable: true };
      return result;
    },
    /** @type {Record<string, {enumerable:true}>} */
    {}
  )
);
function fromRawHeaders(headers = []) {
  return new Headers(
    headers.reduce(
      (result, value, index, array) => {
        if (index % 2 === 0) {
          result.push(array.slice(index, index + 2));
        }
        return result;
      },
      /** @type {string[][]} */
      []
    ).filter(([name5, value]) => {
      try {
        validateHeaderName(name5);
        validateHeaderValue(name5, String(value));
        return true;
      } catch (e) {
        return false;
      }
    })
  );
}

// ../../node_modules/.pnpm/@web-std+fetch@4.2.1/node_modules/@web-std/fetch/src/utils/is-redirect.js
var redirectStatus = /* @__PURE__ */ new Set([301, 302, 303, 307, 308]);
var isRedirect = (code5) => {
  return redirectStatus.has(code5);
};

// ../../node_modules/.pnpm/@web-std+fetch@4.2.1/node_modules/@web-std/fetch/src/response.js
var INTERNALS2 = Symbol("Response internals");
var Response2 = class _Response extends Body {
  /**
   * @param {BodyInit|import('stream').Stream|null} [body] - Readable stream
   * @param {ResponseInit & Ext} [options] - Response options
   */
  constructor(body = null, options = {}) {
    super(body, options);
    const status = options.status || 200;
    const headers = new Headers(options.headers);
    if (body !== null && !headers.has("Content-Type")) {
      const contentType = extractContentType(this);
      if (contentType) {
        headers.append("Content-Type", contentType);
      }
    }
    this[INTERNALS2] = {
      url: options.url,
      status,
      statusText: options.statusText || "",
      headers,
      counter: options.counter || 0,
      highWaterMark: options.highWaterMark
    };
  }
  /**
   * @type {ResponseType}
   */
  get type() {
    return "default";
  }
  get url() {
    return this[INTERNALS2].url || "";
  }
  get status() {
    return this[INTERNALS2].status;
  }
  /**
   * Convenience property representing if the request ended normally
   */
  get ok() {
    return this[INTERNALS2].status >= 200 && this[INTERNALS2].status < 300;
  }
  get redirected() {
    return this[INTERNALS2].counter > 0;
  }
  get statusText() {
    return this[INTERNALS2].statusText;
  }
  /**
   * @type {Headers}
   */
  get headers() {
    return this[INTERNALS2].headers;
  }
  get highWaterMark() {
    return this[INTERNALS2].highWaterMark;
  }
  /**
   * Clone this response
   *
   * @returns {Response}
   */
  clone() {
    return new _Response(clone(this), {
      url: this.url,
      status: this.status,
      statusText: this.statusText,
      headers: this.headers,
      size: this.size
    });
  }
  /**
   * @param {string} url    The URL that the new response is to originate from.
   * @param {number} status An optional status code for the response (e.g., 302.)
   * @returns {Response}    A Response object.
   */
  static redirect(url, status = 302) {
    if (!isRedirect(status)) {
      throw new RangeError('Failed to execute "redirect" on "response": Invalid status code');
    }
    return new _Response(null, {
      headers: {
        location: new URL(url).toString()
      },
      status
    });
  }
  get [Symbol.toStringTag]() {
    return "Response";
  }
};
Object.defineProperties(Response2.prototype, {
  url: { enumerable: true },
  status: { enumerable: true },
  ok: { enumerable: true },
  redirected: { enumerable: true },
  statusText: { enumerable: true },
  headers: { enumerable: true },
  clone: { enumerable: true }
});

// ../../node_modules/.pnpm/@web-std+fetch@4.2.1/node_modules/@web-std/fetch/src/request.js
var import_abort_controller = __toESM(require_abort_controller(), 1);
import { format as formatUrl } from "url";

// ../../node_modules/.pnpm/@web-std+fetch@4.2.1/node_modules/@web-std/fetch/src/utils/get-search.js
var getSearch = (parsedURL) => {
  if (parsedURL.search) {
    return parsedURL.search;
  }
  const lastOffset = parsedURL.href.length - 1;
  const hash = parsedURL.hash || (parsedURL.href[lastOffset] === "#" ? "#" : "");
  return parsedURL.href[lastOffset - hash.length] === "?" ? "?" : "";
};

// ../../node_modules/.pnpm/@web-std+fetch@4.2.1/node_modules/@web-std/fetch/src/request.js
var INTERNALS3 = Symbol("Request internals");
var forbiddenMethods = /* @__PURE__ */ new Set(["CONNECT", "TRACE", "TRACK"]);
var normalizedMethods = /* @__PURE__ */ new Set(["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"]);
var isRequest = (object) => {
  return typeof object === "object" && typeof object[INTERNALS3] === "object";
};
var Request = class _Request extends Body {
  /**
   * @param {string|Request|URL} info  Url or Request instance
   * @param {RequestInit & RequestExtraOptions} init   Custom options
   */
  constructor(info, init = {}) {
    let parsedURL;
    let settings;
    if (isRequest(info)) {
      parsedURL = new URL(info.url);
      settings = info;
    } else {
      parsedURL = new URL(info);
      settings = {};
    }
    let method = init.method || settings.method || "GET";
    if (forbiddenMethods.has(method.toUpperCase())) {
      throw new TypeError(`Failed to construct 'Request': '${method}' HTTP method is unsupported.`);
    } else if (normalizedMethods.has(method.toUpperCase())) {
      method = method.toUpperCase();
    }
    const inputBody = init.body != null ? init.body : isRequest(info) && info.body !== null ? clone(info) : null;
    if (inputBody != null && (method === "GET" || method === "HEAD")) {
      throw new TypeError("Request with GET/HEAD method cannot have body");
    }
    super(inputBody, {
      size: init.size || settings.size || 0
    });
    const input = settings;
    const headers = (
      /** @type {globalThis.Headers} */
      new Headers(init.headers || input.headers || {})
    );
    if (inputBody !== null && !headers.has("Content-Type")) {
      const contentType = extractContentType(this);
      if (contentType) {
        headers.append("Content-Type", contentType);
      }
    }
    let signal = "signal" in init ? init.signal : isRequest(input) ? input.signal : null;
    if (signal != null && !isAbortSignal2(signal)) {
      throw new TypeError("Expected signal to be an instanceof AbortSignal or EventTarget");
    }
    if (!signal) {
      let AbortControllerConstructor = typeof AbortController != "undefined" ? AbortController : import_abort_controller.AbortController;
      let newSignal = new AbortControllerConstructor().signal;
      signal = newSignal;
    }
    this[INTERNALS3] = {
      method,
      redirect: init.redirect || input.redirect || "follow",
      headers,
      credentials: init.credentials || "same-origin",
      parsedURL,
      signal: signal || null
    };
    this.keepalive;
    this.follow = init.follow === void 0 ? input.follow === void 0 ? 20 : input.follow : init.follow;
    this.compress = init.compress === void 0 ? input.compress === void 0 ? true : input.compress : init.compress;
    this.counter = init.counter || input.counter || 0;
    this.agent = init.agent || input.agent;
    this.highWaterMark = init.highWaterMark || input.highWaterMark || 16384;
    this.insecureHTTPParser = init.insecureHTTPParser || input.insecureHTTPParser || false;
  }
  /**
   * @type {RequestCache}
   */
  get cache() {
    return "default";
  }
  /**
   * @type {RequestCredentials}
   */
  get credentials() {
    return this[INTERNALS3].credentials;
  }
  /**
   * @type {RequestDestination}
   */
  get destination() {
    return "";
  }
  get integrity() {
    return "";
  }
  /** @type {RequestMode} */
  get mode() {
    return "cors";
  }
  /** @type {string} */
  get referrer() {
    return "";
  }
  /** @type {ReferrerPolicy} */
  get referrerPolicy() {
    return "";
  }
  get method() {
    return this[INTERNALS3].method;
  }
  /**
   * @type {string}
   */
  get url() {
    return formatUrl(this[INTERNALS3].parsedURL);
  }
  /**
   * @type {globalThis.Headers}
   */
  get headers() {
    return this[INTERNALS3].headers;
  }
  get redirect() {
    return this[INTERNALS3].redirect;
  }
  /**
   * @returns {AbortSignal}
   */
  get signal() {
    return this[INTERNALS3].signal;
  }
  /**
   * Clone this request
   *
   * @return  {globalThis.Request}
   */
  clone() {
    return new _Request(this);
  }
  get [Symbol.toStringTag]() {
    return "Request";
  }
};
Object.defineProperties(Request.prototype, {
  method: { enumerable: true },
  url: { enumerable: true },
  headers: { enumerable: true },
  redirect: { enumerable: true },
  clone: { enumerable: true },
  signal: { enumerable: true }
});
var getNodeRequestOptions = (request) => {
  const { parsedURL } = request[INTERNALS3];
  const headers = new Headers(request[INTERNALS3].headers);
  if (!headers.has("Accept")) {
    headers.set("Accept", "*/*");
  }
  let contentLengthValue = null;
  if (request.body === null && /^(post|put)$/i.test(request.method)) {
    contentLengthValue = "0";
  }
  if (request.body !== null) {
    const totalBytes = getTotalBytes(request);
    if (typeof totalBytes === "number" && !Number.isNaN(totalBytes)) {
      contentLengthValue = String(totalBytes);
    }
  }
  if (contentLengthValue) {
    headers.set("Content-Length", contentLengthValue);
  }
  if (!headers.has("User-Agent")) {
    headers.set("User-Agent", "node-fetch");
  }
  if (request.compress && !headers.has("Accept-Encoding")) {
    headers.set("Accept-Encoding", "gzip,deflate,br");
  }
  let { agent } = request;
  if (typeof agent === "function") {
    agent = agent(parsedURL);
  }
  if (!headers.has("Connection") && !agent) {
    headers.set("Connection", "close");
  }
  const search = getSearch(parsedURL);
  const requestOptions = {
    path: parsedURL.pathname + search,
    pathname: parsedURL.pathname,
    hostname: parsedURL.hostname,
    protocol: parsedURL.protocol,
    port: parsedURL.port,
    hash: parsedURL.hash,
    search: parsedURL.search,
    // @ts-ignore - it does not has a query
    query: parsedURL.query,
    href: parsedURL.href,
    method: request.method,
    // @ts-ignore - not sure what this supposed to do
    headers: headers[Symbol.for("nodejs.util.inspect.custom")](),
    insecureHTTPParser: request.insecureHTTPParser,
    agent
  };
  return requestOptions;
};

// ../../node_modules/.pnpm/@web-std+fetch@4.2.1/node_modules/@web-std/fetch/src/errors/abort-error.js
var AbortError = class extends FetchBaseError {
  /**
   * @param {string} message 
   * @param {string} [type]
   */
  constructor(message, type = "aborted") {
    super(message, type);
  }
};

// ../../node_modules/.pnpm/@web-std+fetch@4.2.1/node_modules/@web-std/fetch/src/fetch.js
import { pipeline as pump, PassThrough } from "stream";
import * as Stream3 from "stream";
var supportedSchemas = /* @__PURE__ */ new Set(["data:", "http:", "https:", "file:"]);
function fetch(_0) {
  return __async(this, arguments, function* (url, options_ = {}) {
    return new Promise((resolve, reject) => {
      const request = new Request(url, options_);
      const options = getNodeRequestOptions(request);
      if (!supportedSchemas.has(options.protocol)) {
        throw new TypeError(`node-fetch cannot load ${url}. URL scheme "${options.protocol.replace(/:$/, "")}" is not supported.`);
      }
      if (options.protocol === "data:") {
        const data = (0, import_data_uri_to_buffer.default)(request.url.toString());
        const response2 = new Response2(data, { headers: { "Content-Type": data.typeFull } });
        resolve(response2);
        return;
      }
      if (options.protocol === "file:") {
        const stream = fs3.createReadStream(new URL(request.url));
        const type = lookup(request.url) || "application/octet-stream";
        const response2 = new Response2(stream, { headers: { "Content-Type": type } });
        resolve(response2);
        return;
      }
      const send = (options.protocol === "https:" ? https : http2).request;
      const { signal } = request;
      let response = null;
      let response_ = null;
      const abort = () => {
        const error = new AbortError("The operation was aborted.");
        reject(error);
        if (request.body) {
          request.body.cancel(error);
        }
        if (!response_) {
          return;
        }
        response_.emit("error", error);
      };
      if (signal && signal.aborted) {
        abort();
        return;
      }
      const abortAndFinalize = () => {
        abort();
        finalize();
      };
      const request_ = send(options);
      if (signal) {
        signal.addEventListener("abort", abortAndFinalize);
      }
      const finalize = () => {
        request_.abort();
        if (signal) {
          signal.removeEventListener("abort", abortAndFinalize);
        }
      };
      request_.on("error", (err) => {
        reject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, "system", err));
        finalize();
      });
      fixResponseChunkedTransferBadEnding(request_, (err) => {
        if (signal && signal.aborted) {
          return;
        }
        response_ == null ? void 0 : response_.emit("error", err);
      });
      if (parseInt(process.version.substring(1)) < 14) {
        request_.on("socket", (s) => {
          s.prependListener("close", (hadError) => {
            const hasDataListener = s.listenerCount("data") > 0;
            if (response && hasDataListener && !hadError && !(signal && signal.aborted)) {
              const err = Object.assign(new Error("Premature close"), {
                code: "ERR_STREAM_PREMATURE_CLOSE"
              });
              response_ == null ? void 0 : response_.emit("error", err);
            }
          });
        });
      }
      request_.on("response", (incoming) => {
        response_ = incoming;
        request_.setTimeout(0);
        const headers = fromRawHeaders(response_.rawHeaders);
        if (isRedirect(Number(response_.statusCode))) {
          const location = headers.get("Location");
          const locationURL = location === null ? null : new URL(location, request.url);
          switch (request.redirect) {
            case "error":
              reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, "no-redirect"));
              finalize();
              return;
            case "manual":
              if (locationURL !== null) {
                headers.set("Location", locationURL.toString());
              }
              break;
            case "follow": {
              if (locationURL === null) {
                break;
              }
              if (request.counter >= request.follow) {
                reject(new FetchError(`maximum redirect reached at: ${request.url}`, "max-redirect"));
                finalize();
                return;
              }
              const requestOptions = {
                headers: new Headers(request.headers),
                follow: request.follow,
                counter: request.counter + 1,
                agent: request.agent,
                compress: request.compress,
                method: request.method,
                // Note: We can not use `request.body` because send would have
                // consumed it already.
                body: options_.body,
                signal,
                size: request.size
              };
              const isStreamBody = requestOptions.body instanceof ReadableStream2 || requestOptions.body instanceof Stream3.Readable;
              if (response_.statusCode !== 303 && isStreamBody) {
                reject(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect"));
                finalize();
                return;
              }
              if (response_.statusCode === 303 || (response_.statusCode === 301 || response_.statusCode === 302) && request.method === "POST") {
                requestOptions.method = "GET";
                requestOptions.body = void 0;
                requestOptions.headers.delete("content-length");
              }
              fetch(new Request(locationURL.href, requestOptions)).then(resolve, reject);
              finalize();
              return;
            }
            default:
              return reject(new TypeError(`Redirect option '${request.redirect}' is not a valid value of RequestRedirect`));
          }
        }
        if (signal) {
          response_.once("end", () => {
            signal.removeEventListener("abort", abortAndFinalize);
          });
        }
        let body = pump(response_, new PassThrough(), reject);
        if (process.version < "v12.10") {
          response_.on("aborted", abortAndFinalize);
        }
        const responseOptions = {
          url: request.url,
          status: response_.statusCode,
          statusText: response_.statusMessage,
          headers,
          size: request.size,
          counter: request.counter,
          highWaterMark: request.highWaterMark
        };
        const codings = headers.get("Content-Encoding");
        if (!request.compress || request.method === "HEAD" || codings === null || response_.statusCode === 204 || response_.statusCode === 304) {
          response = new Response2(body, responseOptions);
          resolve(response);
          return;
        }
        const zlibOptions = {
          flush: zlib.Z_SYNC_FLUSH,
          finishFlush: zlib.Z_SYNC_FLUSH
        };
        if (codings === "gzip" || codings === "x-gzip") {
          body = pump(body, zlib.createGunzip(zlibOptions), reject);
          response = new Response2(fromAsyncIterable(body), responseOptions);
          resolve(response);
          return;
        }
        if (codings === "deflate" || codings === "x-deflate") {
          const raw = pump(response_, new PassThrough(), reject);
          raw.once("data", (chunk) => {
            if ((chunk[0] & 15) === 8) {
              body = pump(body, zlib.createInflate(), reject);
            } else {
              body = pump(body, zlib.createInflateRaw(), reject);
            }
            response = new Response2(fromAsyncIterable(body), responseOptions);
            resolve(response);
          });
          return;
        }
        if (codings === "br") {
          body = pump(body, zlib.createBrotliDecompress(), reject);
          response = new Response2(fromAsyncIterable(body), responseOptions);
          resolve(response);
          return;
        }
        response = new Response2(fromAsyncIterable(body), responseOptions);
        resolve(response);
      });
      writeToStream(request_, request);
    });
  });
}
function fixResponseChunkedTransferBadEnding(request, errorCallback) {
  const LAST_CHUNK = Buffer2.from("0\r\n\r\n");
  let isChunkedTransfer = false;
  let properLastChunkReceived = false;
  let previousChunk;
  request.on("response", (response) => {
    const { headers } = response;
    isChunkedTransfer = headers["transfer-encoding"] === "chunked" && !headers["content-length"];
  });
  request.on("socket", (socket) => {
    const onSocketClose = () => {
      if (isChunkedTransfer && !properLastChunkReceived) {
        const error = Object.assign(new Error("Premature close"), {
          code: "ERR_STREAM_PREMATURE_CLOSE"
        });
        errorCallback(error);
      }
    };
    const onData = (buf2) => {
      properLastChunkReceived = Buffer2.compare(buf2.slice(-5), LAST_CHUNK) === 0;
      if (!properLastChunkReceived && previousChunk) {
        properLastChunkReceived = Buffer2.compare(previousChunk.slice(-3), LAST_CHUNK.slice(0, 3)) === 0 && Buffer2.compare(buf2.slice(-2), LAST_CHUNK.slice(3)) === 0;
      }
      previousChunk = buf2;
    };
    socket.prependListener("close", onSocketClose);
    socket.on("data", onData);
    const removeSocketListeners = () => {
      socket.removeListener("close", onSocketClose);
      socket.removeListener("data", onData);
    };
    request.on("close", removeSocketListeners);
    request.on("abort", removeSocketListeners);
  });
}

// ../../node_modules/.pnpm/@web-std+fetch@4.2.1/node_modules/@web-std/fetch/src/lib.node.js
var fetch2 = (
  /** @type {typeof globalThis.fetch} */
  typeof globalThis.fetch === "function" ? globalThis.fetch.bind(globalThis) : fetch
);
var Headers2 = globalThis.Headers || Headers;
var Request2 = globalThis.Request || Request;
var Response3 = globalThis.Response || Response2;
var lib_node_default = fetch2;

// ../../node_modules/.pnpm/ipfs-car@0.6.2_node-fetch@3.3.2/node_modules/ipfs-car/dist/esm/blockstore/fs.js
import fs4 from "fs";
import os from "os";
var FsBlockStore = class extends BaseBlockstore {
  constructor() {
    super();
    this.path = `${os.tmpdir()}/${parseInt(String(Math.random() * 1e9), 10).toString() + Date.now()}`;
    this._opened = false;
  }
  _open() {
    return __async(this, null, function* () {
      if (this._opening) {
        yield this._opening;
      } else {
        this._opening = fs4.promises.mkdir(this.path);
        yield this._opening;
        this._opened = true;
      }
    });
  }
  put(cid, bytes) {
    return __async(this, null, function* () {
      if (!this._opened) {
        yield this._open();
      }
      const cidStr = cid.toString();
      const location = `${this.path}/${cidStr}`;
      yield fs4.promises.writeFile(location, bytes);
    });
  }
  get(cid) {
    return __async(this, null, function* () {
      if (!this._opened) {
        yield this._open();
      }
      const cidStr = cid.toString();
      const location = `${this.path}/${cidStr}`;
      const bytes = yield fs4.promises.readFile(location);
      return bytes;
    });
  }
  has(cid) {
    return __async(this, null, function* () {
      if (!this._opened) {
        yield this._open();
      }
      const cidStr = cid.toString();
      const location = `${this.path}/${cidStr}`;
      try {
        yield fs4.promises.access(location);
        return true;
      } catch (err) {
        return false;
      }
    });
  }
  blocks() {
    return __asyncGenerator(this, null, function* () {
      if (!this._opened) {
        yield new __await(this._open());
      }
      const cids = yield new __await(fs4.promises.readdir(this.path));
      for (const cidStr of cids) {
        const location = `${this.path}/${cidStr}`;
        const bytes = yield new __await(fs4.promises.readFile(location));
        yield { cid: CID.parse(cidStr), bytes };
      }
    });
  }
  close() {
    return __async(this, null, function* () {
      if (this._opened) {
        yield fs4.promises.rm(this.path, { recursive: true });
      }
      this._opened = false;
    });
  }
};

// ../../node_modules/.pnpm/nft.storage@7.1.1_node-fetch@3.3.2/node_modules/nft.storage/src/gateway.js
var GATEWAY = new URL("https://nftstorage.link/");
var toGatewayURL = (url, options = {}) => {
  const gateway = options.gateway || GATEWAY;
  url = new URL(String(url));
  return url.protocol === "ipfs:" ? new URL(`/ipfs/${url.href.slice("ipfs://".length)}`, gateway) : url;
};

// ../../node_modules/.pnpm/nft.storage@7.1.1_node-fetch@3.3.2/node_modules/nft.storage/src/bs-car-reader.js
var BlockstoreCarReader = class {
  /**
   * @param {number} version
   * @param {CID[]} roots
   * @param {import('ipfs-car/blockstore').Blockstore} blockstore
   */
  constructor(version2, roots, blockstore) {
    this._version = version2;
    this._roots = roots;
    this._blockstore = blockstore;
  }
  get version() {
    return this._version;
  }
  get blockstore() {
    return this._blockstore;
  }
  getRoots() {
    return __async(this, null, function* () {
      return this._roots;
    });
  }
  /**
   * @param {CID} cid
   */
  has(cid) {
    return this._blockstore.has(cid);
  }
  /**
   * @param {CID} cid
   */
  get(cid) {
    return __async(this, null, function* () {
      const bytes = yield this._blockstore.get(cid);
      return { cid, bytes };
    });
  }
  blocks() {
    return this._blockstore.blocks();
  }
  cids() {
    return __asyncGenerator(this, null, function* () {
      try {
        for (var iter = __forAwait(this.blocks()), more, temp, error; more = !(temp = yield new __await(iter.next())).done; more = false) {
          const b = temp.value;
          yield b.cid;
        }
      } catch (temp) {
        error = [temp];
      } finally {
        try {
          more && (temp = iter.return) && (yield new __await(temp.call(iter)));
        } finally {
          if (error)
            throw error[0];
        }
      }
    });
  }
};

// ../../node_modules/.pnpm/nft.storage@7.1.1_node-fetch@3.3.2/node_modules/nft.storage/src/token.js
var Token2 = class _Token {
  /**
   * @param {import('./lib/interface.js').CIDString} ipnft
   * @param {import('./lib/interface.js').EncodedURL} url
   * @param {import('./lib/interface.js').Encoded<T, [[Blob, URL]]>} data
   */
  constructor(ipnft, url, data) {
    this.ipnft = ipnft;
    this.url = url;
    this.data = data;
    Object.defineProperties(this, {
      ipnft: { enumerable: true, writable: false },
      url: { enumerable: true, writable: false },
      data: { enumerable: false, writable: false }
    });
  }
  /**
   * @returns {import('./lib/interface.js').Encoded<T, [[Blob, URL]]>}
   */
  embed() {
    return _Token.embed(this);
  }
  /**
   * @template {TokenInput} T
   * @param {{data: import('./lib/interface.js').Encoded<T, [[Blob, URL]]>}} token
   * @returns {import('./lib/interface.js').Encoded<T, [[Blob, URL]]>}
   */
  static embed({ data }) {
    return embed(data, { gateway: GATEWAY });
  }
  /**
   * Takes token input, encodes it as a DAG, wraps it in a CAR and creates a new
   * Token instance from it. Where values are discovered `Blob` (or `File`)
   * objects in the given input, they are replaced with IPFS URLs (an `ipfs://`
   * prefixed CID with an optional path).
   *
   * @example
   * ```js
   * const cat = new File(['...'], 'cat.png')
   * const kitty = new File(['...'], 'kitty.png')
   * const { token, car } = await Token.encode({
   *   name: 'hello'
   *   image: cat
   *   properties: {
   *     extra: {
   *       image: kitty
   *     }
   *   }
   * })
   * ```
   *
   * @template {TokenInput} T
   * @param {T} input
   * @returns {Promise<{ cid: CID, token: TokenType<T>, car: import('./lib/interface.js').CarReader }>}
   */
  static encode(input) {
    return __async(this, null, function* () {
      var _a2, _b;
      const blockstore = new FsBlockStore();
      const [blobs, meta] = mapTokenInputBlobs(input);
      const data = JSON.parse(JSON.stringify(meta));
      const dag = JSON.parse(JSON.stringify(meta));
      for (const [dotPath, blob] of blobs.entries()) {
        const name5 = blob.name || "blob";
        let content;
        if (parseInt((_b = (_a2 = globalThis.process) == null ? void 0 : _a2.versions) == null ? void 0 : _b.node) > 18) {
          content = new Uint8Array(yield blob.arrayBuffer());
        } else {
          content = blob.stream();
        }
        const { root: cid } = yield pack({
          input: [{ path: name5, content }],
          blockstore,
          wrapWithDirectory: true
        });
        const href = new URL(`ipfs://${cid}/${name5}`);
        const path = dotPath.split(".");
        setIn(data, path, href);
        setIn(dag, path, cid);
      }
      const { root: metadataJsonCid } = yield pack({
        input: [{ path: "metadata.json", content: JSON.stringify(data) }],
        blockstore,
        wrapWithDirectory: false
      });
      const block = yield encode5({
        value: __spreadProps(__spreadValues({}, dag), {
          "metadata.json": metadataJsonCid,
          type: "nft"
        }),
        codec: esm_exports,
        hasher: sha256
      });
      yield blockstore.put(block.cid, block.bytes);
      return {
        cid: block.cid,
        token: new _Token(
          block.cid.toString(),
          `ipfs://${block.cid}/metadata.json`,
          data
        ),
        car: new BlockstoreCarReader(1, [block.cid], blockstore)
      };
    });
  }
};
var embed = (input, options) => mapWith(input, isURL, embedURL, options);
var isURL = (value) => value instanceof URL;
var embedURL = (context, url) => [context, toGatewayURL(url, context)];
var isObject2 = (value) => typeof value === "object" && value != null;
var encodeBlob = (data, blob, path) => {
  data.set(path.join("."), blob);
  return [data, void 0];
};
var isBlob5 = (value) => value instanceof Blob3;
var mapTokenInputBlobs = (input) => {
  return mapValueWith(input, isBlob5, encodeBlob, /* @__PURE__ */ new Map(), []);
};
var mapWith = (input, p, f, state) => {
  const [, output] = mapValueWith(input, p, f, state, []);
  return output;
};
var mapValueWith = (input, p, f, state, path) => p(input, state, path) ? f(state, input, path) : Array.isArray(input) ? mapArrayWith(input, p, f, state, path) : isObject2(input) ? mapObjectWith(input, p, f, state, path) : [
  state,
  /** @type {any} */
  input
];
var mapObjectWith = (input, p, f, init, path) => {
  let state = init;
  const output = (
    /** @type {import('./lib/interface.js').Encoded<T, [[I, O]]>} */
    {}
  );
  for (const [key, value] of Object.entries(input)) {
    const [next, out] = mapValueWith(value, p, f, state, [...path, key]);
    output[key] = out;
    state = next;
  }
  return [state, output];
};
var mapArrayWith = (input, p, f, init, path) => {
  const output = (
    /** @type {unknown[]} */
    []
  );
  let state = init;
  for (const [index, element] of input.entries()) {
    const [next, out] = mapValueWith(element, p, f, state, [...path, index]);
    output[index] = out;
    state = next;
  }
  return [
    state,
    /** @type {import('./lib/interface.js').Encoded<T, [[I, O]]>} */
    output
  ];
};
var setIn = (object, path, value) => {
  const n = path.length - 1;
  let target = object;
  for (let [index, key] of path.entries()) {
    if (index === n) {
      target[key] = value;
    } else {
      target = target[key];
    }
  }
};

// ../../node_modules/.pnpm/nft.storage@7.1.1_node-fetch@3.3.2/node_modules/nft.storage/src/lib.js
var import_it_pipe2 = __toESM(require_it_pipe(), 1);
var MAX_STORE_RETRIES = 5;
var MAX_CONCURRENT_UPLOADS = 3;
var MAX_CHUNK_SIZE = 1024 * 1024 * 50;
var RATE_LIMIT_REQUESTS = 30;
var RATE_LIMIT_PERIOD = 10 * 1e3;
function createRateLimiter() {
  const throttle = (0, import_throttled_queue.default)(RATE_LIMIT_REQUESTS, RATE_LIMIT_PERIOD);
  return () => throttle(() => {
  });
}
var globalRateLimiter = createRateLimiter();
var NFTStorage = class _NFTStorage {
  /**
   * Constructs a client bound to the given `options.token` and
   * `options.endpoint`.
   *
   * @example
   * ```js
   * import { NFTStorage, File, Blob } from "nft.storage"
   * const client = new NFTStorage({ token: API_TOKEN })
   *
   * const cid = await client.storeBlob(new Blob(['hello world']))
   * ```
   * Optionally you could pass an alternative API endpoint (e.g. for testing)
   * @example
   * ```js
   * import { NFTStorage } from "nft.storage"
   * const client = new NFTStorage({
   *   token: API_TOKEN
   *   endpoint: new URL('http://localhost:8080/')
   * })
   * ```
   *
   * @param {{token: string, endpoint?: URL, rateLimiter?: RateLimiter, did?: string}} options
   */
  constructor({
    token,
    did,
    endpoint = new URL("https://api.nft.storage"),
    rateLimiter
  }) {
    this.token = token;
    this.endpoint = endpoint;
    this.rateLimiter = rateLimiter || createRateLimiter();
    this.did = did;
  }
  /**
   * @hidden
   * @param {object} options
   * @param {string} options.token
   * @param {string} [options.did]
   */
  static auth({ token, did }) {
    if (!token)
      throw new Error("missing token");
    return __spreadValues({
      Authorization: `Bearer ${token}`,
      "X-Client": "nft.storage/js"
    }, did ? { "x-agent-did": did } : {});
  }
  /**
   * Stores a single file and returns its CID.
   *
   * @param {Service} service
   * @param {Blob} blob
   * @param {RequestOptions} [options]
   * @returns {Promise<CIDString>}
   */
  static storeBlob(service, blob, options) {
    return __async(this, null, function* () {
      const blockstore = new FsBlockStore();
      let cidString;
      try {
        const { cid, car } = yield _NFTStorage.encodeBlob(blob, { blockstore });
        yield _NFTStorage.storeCar(service, car, options);
        cidString = cid.toString();
      } finally {
        yield blockstore.close();
      }
      return cidString;
    });
  }
  /**
   * Stores a CAR file and returns its root CID.
   *
   * @param {Service} service
   * @param {Blob|CarReader} car
   * @param {import('./lib/interface.js').CarStorerOptions} [options]
   * @returns {Promise<CIDString>}
   */
  static storeCar(_0, _1) {
    return __async(this, arguments, function* (_a2, car, { onStoredChunk, maxRetries, maxChunkSize, decoders, signal } = {}) {
      var _b = _a2, { endpoint, rateLimiter = globalRateLimiter } = _b, token = __objRest(_b, ["endpoint", "rateLimiter"]);
      const url = new URL("upload/", endpoint);
      const headers = __spreadProps(__spreadValues({}, _NFTStorage.auth(token)), {
        "Content-Type": "application/car"
      });
      const targetSize = maxChunkSize || MAX_CHUNK_SIZE;
      const splitter = car instanceof Blob3 ? yield TreewalkCarSplitter.fromBlob(car, targetSize, { decoders }) : new TreewalkCarSplitter(car, targetSize, { decoders });
      const upload = transform(
        MAX_CONCURRENT_UPLOADS,
        function(car2) {
          return __async(this, null, function* () {
            var _a3, _b2;
            const carParts = [];
            try {
              for (var iter2 = __forAwait(car2), more2, temp2, error2; more2 = !(temp2 = yield iter2.next()).done; more2 = false) {
                const part = temp2.value;
                carParts.push(part);
              }
            } catch (temp2) {
              error2 = [temp2];
            } finally {
              try {
                more2 && (temp2 = iter2.return) && (yield temp2.call(iter2));
              } finally {
                if (error2)
                  throw error2[0];
              }
            }
            const carFile = new Blob3(carParts, { type: "application/car" });
            let body = carFile;
            if (parseInt((_b2 = (_a3 = globalThis.process) == null ? void 0 : _a3.versions) == null ? void 0 : _b2.node) > 18) {
              body = yield body.arrayBuffer();
            }
            const cid = yield (0, import_p_retry.default)(
              () => __async(this, null, function* () {
                yield rateLimiter();
                let response;
                try {
                  response = yield lib_node_default(url.toString(), {
                    method: "POST",
                    headers,
                    body,
                    signal
                  });
                } catch (err) {
                  throw signal && signal.aborted ? new import_p_retry.AbortError(err) : err;
                }
                if (response.status === 429) {
                  throw new Error("rate limited");
                }
                const result = yield response.json();
                if (!result.ok) {
                  if (response.status === 401) {
                    throw new import_p_retry.AbortError(result.error.message);
                  }
                  throw new Error(result.error.message);
                }
                return result.value.cid;
              }),
              {
                retries: maxRetries == null ? MAX_STORE_RETRIES : maxRetries
              }
            );
            onStoredChunk && onStoredChunk(carFile.size);
            return cid;
          });
        }
      );
      let root;
      try {
        for (var iter = __forAwait(upload(splitter.cars())), more, temp, error; more = !(temp = yield iter.next()).done; more = false) {
          const cid = temp.value;
          root = cid;
        }
      } catch (temp) {
        error = [temp];
      } finally {
        try {
          more && (temp = iter.return) && (yield temp.call(iter));
        } finally {
          if (error)
            throw error[0];
        }
      }
      return (
        /** @type {CIDString} */
        root
      );
    });
  }
  /**
   * Stores a directory of files and returns a CID. Provided files **MUST**
   * be within the same directory, otherwise error is raised e.g. `foo/bar.png`,
   * `foo/bla/baz.json` is ok but `foo/bar.png`, `bla/baz.json` is not.
   *
   * @param {Service} service
   * @param {FilesSource} filesSource
   * @param {RequestOptions} [options]
   * @returns {Promise<CIDString>}
   */
  static storeDirectory(service, filesSource, options) {
    return __async(this, null, function* () {
      const blockstore = new FsBlockStore();
      let cidString;
      try {
        const { cid, car } = yield _NFTStorage.encodeDirectory(filesSource, {
          blockstore
        });
        yield _NFTStorage.storeCar(service, car, options);
        cidString = cid.toString();
      } finally {
        yield blockstore.close();
      }
      return cidString;
    });
  }
  /**
   * Stores the given token and all resources it references (in the form of a
   * File or a Blob) along with a metadata JSON as specificed in ERC-1155. The
   * `token.image` must be either a `File` or a `Blob` instance, which will be
   * stored and the corresponding content address URL will be saved in the
   * metadata JSON file under `image` field.
   *
   * If `token.properties` contains properties with `File` or `Blob` values,
   * those also get stored and their URLs will be saved in the metadata JSON
   * file in their place.
   *
   * Note: URLs for `File` objects will retain file names e.g. in case of
   * `new File([bytes], 'cat.png', { type: 'image/png' })` will be transformed
   * into a URL that looks like `ipfs://bafy...hash/image/cat.png`. For `Blob`
   * objects, the URL will not have a file name name or mime type, instead it
   * will be transformed into a URL that looks like
   * `ipfs://bafy...hash/image/blob`.
   *
   * @template {import('./lib/interface.js').TokenInput} T
   * @param {Service} service
   * @param {T} metadata
   * @param {RequestOptions} [options]
   * @returns {Promise<TokenType<T>>}
   */
  static store(service, metadata, options) {
    return __async(this, null, function* () {
      const { token, car } = yield _NFTStorage.encodeNFT(metadata);
      yield _NFTStorage.storeCar(service, car, options);
      return token;
    });
  }
  /**
   * Returns current status of the stored NFT by its CID. Note the NFT must
   * have previously been stored by this account.
   *
   * @param {Service} service
   * @param {string} cid
   * @param {RequestOptions} [options]
   * @returns {Promise<import('./lib/interface.js').StatusResult>}
   */
  static status(_c, cid, options) {
    return __async(this, null, function* () {
      var _d = _c, { endpoint, rateLimiter = globalRateLimiter } = _d, token = __objRest(_d, ["endpoint", "rateLimiter"]);
      const url = new URL(`${cid}/`, endpoint);
      yield rateLimiter();
      const response = yield lib_node_default(url.toString(), {
        method: "GET",
        headers: _NFTStorage.auth(token),
        signal: options && options.signal
      });
      if (response.status === 429) {
        throw new Error("rate limited");
      }
      const result = yield response.json();
      if (result.ok) {
        return {
          cid: result.value.cid,
          deals: decodeDeals(result.value.deals),
          size: result.value.size,
          pin: decodePin(result.value.pin),
          created: new Date(result.value.created)
        };
      } else {
        throw new Error(result.error.message);
      }
    });
  }
  /**
   * Check if a CID of an NFT is being stored by NFT.Storage.
   *
   * @param {import('./lib/interface.js').PublicService} service
   * @param {string} cid
   * @param {RequestOptions} [options]
   * @returns {Promise<import('./lib/interface.js').CheckResult>}
   */
  static check(_0, _1, _2) {
    return __async(this, arguments, function* ({ endpoint, rateLimiter = globalRateLimiter }, cid, options) {
      const url = new URL(`check/${cid}/`, endpoint);
      yield rateLimiter();
      const response = yield lib_node_default(url.toString(), {
        signal: options && options.signal
      });
      if (response.status === 429) {
        throw new Error("rate limited");
      }
      const result = yield response.json();
      if (result.ok) {
        return {
          cid: result.value.cid,
          deals: decodeDeals(result.value.deals),
          pin: result.value.pin
        };
      } else {
        throw new Error(result.error.message);
      }
    });
  }
  /**
   * Removes stored content by its CID from this account. Please note that
   * even if content is removed from the service other nodes that have
   * replicated it might still continue providing it.
   *
   * @param {Service} service
   * @param {string} cid
   * @param {RequestOptions} [options]
   * @returns {Promise<void>}
   */
  static delete(_e, cid, options) {
    return __async(this, null, function* () {
      var _f = _e, { endpoint, rateLimiter = globalRateLimiter } = _f, token = __objRest(_f, ["endpoint", "rateLimiter"]);
      const url = new URL(`${cid}/`, endpoint);
      yield rateLimiter();
      const response = yield lib_node_default(url.toString(), {
        method: "DELETE",
        headers: _NFTStorage.auth(token),
        signal: options && options.signal
      });
      if (response.status === 429) {
        throw new Error("rate limited");
      }
      const result = yield response.json();
      if (!result.ok) {
        throw new Error(result.error.message);
      }
    });
  }
  /**
   * Encodes the given token and all resources it references (in the form of a
   * File or a Blob) along with a metadata JSON as specificed in ERC-1155 to a
   * CAR file. The `token.image` must be either a `File` or a `Blob` instance,
   * which will be stored and the corresponding content address URL will be
   * saved in the metadata JSON file under `image` field.
   *
   * If `token.properties` contains properties with `File` or `Blob` values,
   * those also get stored and their URLs will be saved in the metadata JSON
   * file in their place.
   *
   * Note: URLs for `File` objects will retain file names e.g. in case of
   * `new File([bytes], 'cat.png', { type: 'image/png' })` will be transformed
   * into a URL that looks like `ipfs://bafy...hash/image/cat.png`. For `Blob`
   * objects, the URL will not have a file name name or mime type, instead it
   * will be transformed into a URL that looks like
   * `ipfs://bafy...hash/image/blob`.
   *
   * @example
   * ```js
   * const { token, car } = await NFTStorage.encodeNFT({
   *   name: 'nft.storage store test',
   *   description: 'Test ERC-1155 compatible metadata.',
   *   image: new File(['<DATA>'], 'pinpie.jpg', { type: 'image/jpg' }),
   *   properties: {
   *     custom: 'Custom data can appear here, files are auto uploaded.',
   *     file: new File(['<DATA>'], 'README.md', { type: 'text/plain' }),
   *   }
   * })
   *
   * console.log('IPFS URL for the metadata:', token.url)
   * console.log('metadata.json contents:\n', token.data)
   * console.log('metadata.json with IPFS gateway URLs:\n', token.embed())
   *
   * // Now store the CAR file on NFT.Storage
   * await client.storeCar(car)
   * ```
   *
   * @template {import('./lib/interface.js').TokenInput} T
   * @param {T} input
   * @returns {Promise<{ cid: CID, token: TokenType<T>, car: CarReader }>}
   */
  static encodeNFT(input) {
    return __async(this, null, function* () {
      validateERC1155(input);
      return Token2.encode(input);
    });
  }
  /**
   * Encodes a single file to a CAR file and also returns its root CID.
   *
   * @example
   * ```js
   * const content = new Blob(['hello world'])
   * const { cid, car } = await NFTStorage.encodeBlob(content)
   *
   * // Root CID of the file
   * console.log(cid.toString())
   *
   * // Now store the CAR file on NFT.Storage
   * await client.storeCar(car)
   * ```
   *
   * @param {Blob} blob
   * @param {object} [options]
   * @param {BlockstoreI} [options.blockstore]
   * @returns {Promise<{ cid: CID, car: CarReader }>}
   */
  static encodeBlob(_0) {
    return __async(this, arguments, function* (blob, { blockstore } = {}) {
      if (blob.size === 0) {
        throw new Error("Content size is 0, make sure to provide some content");
      }
      return packCar([toImportCandidate("blob", blob)], {
        blockstore,
        wrapWithDirectory: false
      });
    });
  }
  /**
   * Encodes a directory of files to a CAR file and also returns the root CID.
   * Provided files **MUST** be within the same directory, otherwise error is
   * raised e.g. `foo/bar.png`, `foo/bla/baz.json` is ok but `foo/bar.png`,
   * `bla/baz.json` is not.
   *
   * @example
   * ```js
   * const { cid, car } = await NFTStorage.encodeDirectory([
   *   new File(['hello world'], 'hello.txt'),
   *   new File([JSON.stringify({'from': 'incognito'}, null, 2)], 'metadata.json')
   * ])
   *
   * // Root CID of the directory
   * console.log(cid.toString())
   *
   * // Now store the CAR file on NFT.Storage
   * await client.storeCar(car)
   * ```
   *
   * @param {FilesSource} files
   * @param {object} [options]
   * @param {BlockstoreI} [options.blockstore]
   * @returns {Promise<{ cid: CID, car: CarReader }>}
   */
  static encodeDirectory(_0) {
    return __async(this, arguments, function* (files, { blockstore } = {}) {
      let size = 0;
      const input = (0, import_it_pipe2.default)(files, function(files2) {
        return __asyncGenerator(this, null, function* () {
          try {
            for (var iter = __forAwait(files2), more, temp, error; more = !(temp = yield new __await(iter.next())).done; more = false) {
              const file = temp.value;
              yield toImportCandidate(file.name, file);
              size += file.size;
            }
          } catch (temp) {
            error = [temp];
          } finally {
            try {
              more && (temp = iter.return) && (yield new __await(temp.call(iter)));
            } finally {
              if (error)
                throw error[0];
            }
          }
        });
      });
      const packed = yield packCar(input, {
        blockstore,
        wrapWithDirectory: true
      });
      if (size === 0) {
        throw new Error(
          "Total size of files should exceed 0, make sure to provide some content"
        );
      }
      return packed;
    });
  }
  // Just a sugar so you don't have to pass around endpoint and token around.
  /**
   * Stores a single file and returns the corresponding Content Identifier (CID).
   * Takes a [Blob](https://developer.mozilla.org/en-US/docs/Web/API/Blob/Blob)
   * or a [File](https://developer.mozilla.org/en-US/docs/Web/API/File). Note
   * that no file name or file metadata is retained.
   *
   * @example
   * ```js
   * const content = new Blob(['hello world'])
   * const cid = await client.storeBlob(content)
   * cid //> 'zdj7Wn9FQAURCP6MbwcWuzi7u65kAsXCdjNTkhbJcoaXBusq9'
   * ```
   *
   * @param {Blob} blob
   * @param {RequestOptions} [options]
   */
  storeBlob(blob, options) {
    return _NFTStorage.storeBlob(this, blob, options);
  }
  /**
   * Stores files encoded as a single [Content Addressed Archive
   * (CAR)](https://github.com/ipld/specs/blob/master/block-layer/content-addressable-archives.md).
   *
   * Takes a [Blob](https://developer.mozilla.org/en-US/docs/Web/API/Blob/Blob)
   * or a [File](https://developer.mozilla.org/en-US/docs/Web/API/File).
   *
   * Returns the corresponding Content Identifier (CID).
   *
   * See the [`ipfs-car` docs](https://www.npmjs.com/package/ipfs-car) for more
   * details on packing a CAR file.
   *
   * @example
   * ```js
   * import { pack } from 'ipfs-car/pack'
   * import { CarReader } from '@ipld/car'
   * const { out, root } = await pack({
   *  input: fs.createReadStream('pinpie.pdf')
   * })
   * const expectedCid = root.toString()
   * const carReader = await CarReader.fromIterable(out)
   * const cid = await storage.storeCar(carReader)
   * console.assert(cid === expectedCid)
   * ```
   *
   * @example
   * ```
   * import { packToBlob } from 'ipfs-car/pack/blob'
   * const data = 'Hello world'
   * const { root, car } = await packToBlob({ input: [new TextEncoder().encode(data)] })
   * const expectedCid = root.toString()
   * const cid = await client.storeCar(car)
   * console.assert(cid === expectedCid)
   * ```
   * @param {Blob|CarReader} car
   * @param {import('./lib/interface.js').CarStorerOptions} [options]
   */
  storeCar(car, options) {
    return _NFTStorage.storeCar(this, car, options);
  }
  /**
   * Stores a directory of files and returns a CID for the directory.
   *
   * @example
   * ```js
   * const cid = await client.storeDirectory([
   *   new File(['hello world'], 'hello.txt'),
   *   new File([JSON.stringify({'from': 'incognito'}, null, 2)], 'metadata.json')
   * ])
   * cid //>
   * ```
   *
   * Argument can be a [FileList](https://developer.mozilla.org/en-US/docs/Web/API/FileList)
   * instance as well, in which case directory structure will be retained.
   *
   * @param {FilesSource} files
   * @param {RequestOptions} [options]
   */
  storeDirectory(files, options) {
    return _NFTStorage.storeDirectory(this, files, options);
  }
  /**
   * Returns current status of the stored NFT by its CID. Note the NFT must
   * have previously been stored by this account.
   *
   * @example
   * ```js
   * const status = await client.status('zdj7Wn9FQAURCP6MbwcWuzi7u65kAsXCdjNTkhbJcoaXBusq9')
   * ```
   *
   * @param {string} cid
   * @param {RequestOptions} [options]
   */
  status(cid, options) {
    return _NFTStorage.status(this, cid, options);
  }
  /**
   * Removes stored content by its CID from the service.
   *
   * > Please note that even if content is removed from the service other nodes
   * that have replicated it might still continue providing it.
   *
   * @example
   * ```js
   * await client.delete('zdj7Wn9FQAURCP6MbwcWuzi7u65kAsXCdjNTkhbJcoaXBusq9')
   * ```
   *
   * @param {string} cid
   * @param {RequestOptions} [options]
   */
  delete(cid, options) {
    return _NFTStorage.delete(this, cid, options);
  }
  /**
   * Check if a CID of an NFT is being stored by nft.storage. Throws if the NFT
   * was not found.
   *
   * @example
   * ```js
   * const status = await client.check('zdj7Wn9FQAURCP6MbwcWuzi7u65kAsXCdjNTkhbJcoaXBusq9')
   * ```
   *
   * @param {string} cid
   * @param {RequestOptions} [options]
   */
  check(cid, options) {
    return _NFTStorage.check(this, cid, options);
  }
  /**
   * Stores the given token and all resources it references (in the form of a
   * File or a Blob) along with a metadata JSON as specificed in
   * [ERC-1155](https://eips.ethereum.org/EIPS/eip-1155#metadata). The
   * `token.image` must be either a `File` or a `Blob` instance, which will be
   * stored and the corresponding content address URL will be saved in the
   * metadata JSON file under `image` field.
   *
   * If `token.properties` contains properties with `File` or `Blob` values,
   * those also get stored and their URLs will be saved in the metadata JSON
   * file in their place.
   *
   * Note: URLs for `File` objects will retain file names e.g. in case of
   * `new File([bytes], 'cat.png', { type: 'image/png' })` will be transformed
   * into a URL that looks like `ipfs://bafy...hash/image/cat.png`. For `Blob`
   * objects, the URL will not have a file name name or mime type, instead it
   * will be transformed into a URL that looks like
   * `ipfs://bafy...hash/image/blob`.
   *
   * @example
   * ```js
   * const metadata = await client.store({
   *   name: 'nft.storage store test',
   *   description: 'Test ERC-1155 compatible metadata.',
   *   image: new File(['<DATA>'], 'pinpie.jpg', { type: 'image/jpg' }),
   *   properties: {
   *     custom: 'Custom data can appear here, files are auto uploaded.',
   *     file: new File(['<DATA>'], 'README.md', { type: 'text/plain' }),
   *   }
   * })
   *
   * console.log('IPFS URL for the metadata:', metadata.url)
   * console.log('metadata.json contents:\n', metadata.data)
   * console.log('metadata.json with IPFS gateway URLs:\n', metadata.embed())
   * ```
   *
   * @template {import('./lib/interface.js').TokenInput} T
   * @param {T} token
   * @param {RequestOptions} [options]
   */
  store(token, options) {
    return _NFTStorage.store(this, token, options);
  }
};
var validateERC1155 = ({ name: name5, description, image, decimals }) => {
  if (typeof name5 !== "string") {
    throw new TypeError(
      "string property `name` identifying the asset is required"
    );
  }
  if (typeof description !== "string") {
    throw new TypeError(
      "string property `description` describing asset is required"
    );
  }
  if (!(image instanceof Blob3)) {
    throw new TypeError("property `image` must be a Blob or File object");
  } else if (!image.type.startsWith("image/")) {
    console.warn(`According to ERC721 Metadata JSON Schema 'image' must have 'image/*' mime type.

For better interoperability we would highly recommend storing content with different mime type under 'properties' namespace e.g. \`properties: { video: file }\` and using 'image' field for storing a preview image for it instead.

For more context please see ERC-721 specification https://eips.ethereum.org/EIPS/eip-721`);
  }
  if (typeof decimals !== "undefined" && typeof decimals !== "number") {
    throw new TypeError("property `decimals` must be an integer value");
  }
};
var packCar = (_0, ..._1) => __async(void 0, [_0, ..._1], function* (input, { blockstore, wrapWithDirectory } = {}) {
  blockstore = blockstore || new FsBlockStore();
  const { root: cid } = yield pack({ input, blockstore, wrapWithDirectory });
  const car = new BlockstoreCarReader(1, [cid], blockstore);
  return { cid, car };
});
var decodeDeals = (deals) => deals.map((deal) => {
  const { dealActivation, dealExpiration, lastChanged } = __spreadValues({
    dealExpiration: null,
    dealActivation: null
  }, deal);
  return __spreadValues(__spreadValues(__spreadProps(__spreadValues({}, deal), {
    lastChanged: new Date(lastChanged)
  }), dealActivation && { dealActivation: new Date(dealActivation) }), dealExpiration && { dealExpiration: new Date(dealExpiration) });
});
var decodePin = (pin) => __spreadProps(__spreadValues({}, pin), { created: new Date(pin.created) });
function toImportCandidate(path, blob) {
  let stream;
  return {
    path,
    get content() {
      stream = stream || blob.stream();
      return stream;
    }
  };
}

// ../internal/storage/dist/index.mjs
import {
  Constants as Constants2,
  isNode as isNode2,
  isBrowser as isBrowser2,
  debugLog as debugLog2,
  Try as Try22
} from "@solana-suite/shared";
import { toMetaplexFile as toMetaplexFile2 } from "@metaplex-foundation/js";
var __async3 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var Bundlr;
((Bundlr2) => {
  const BUNDLR_CONNECT_TIMEOUT = 6e4;
  Bundlr2.make = (feePayer) => {
    const object = MetaplexFoundation.make(Node.getConnection()).use(
      bundlrStorage({
        address: Constants.BUNDLR_NETWORK_URL,
        providerUrl: Constants.switchCluster({
          cluster: Constants.currentCluster
        }),
        timeout: BUNDLR_CONNECT_TIMEOUT
      })
    );
    if (isKeypair(feePayer)) {
      object.use(keypairIdentity(feePayer));
    } else if (isPhantom(feePayer)) {
      object.use(walletAdapterIdentity(feePayer));
    }
    return object;
  };
  Bundlr2.useStorage = (feePayer) => {
    return (0, Bundlr2.make)(feePayer).storage().driver();
  };
  const isKeypair = (payer) => {
    if (!payer) {
      return false;
    }
    return "secretKey" in payer;
  };
  const isPhantom = (payer) => {
    if (!payer) {
      return false;
    }
    return "connect" in payer;
  };
})(Bundlr || (Bundlr = {}));
var Arweave;
((Arweave2) => {
  Arweave2.getUploadPrice = (filePath, feePayer) => __async3(void 0, null, function* () {
    return Try3(() => __async3(void 0, null, function* () {
      let buffer2;
      if (isNode()) {
        const filepath = filePath;
        buffer2 = (yield import("fs")).readFileSync(filepath);
      } else if (isBrowser()) {
        const filepath = filePath;
        buffer2 = toMetaplexFile(filepath, "").buffer;
      } else {
        throw Error("Supported environment: only Node.js and Browser js");
      }
      const res = yield Bundlr.useStorage(feePayer.toKeypair()).getUploadPrice(
        buffer2.length
      );
      const basisPoints = res.basisPoints.toString();
      debugLog(
        "# buffer length, price",
        buffer2.length,
        parseInt(basisPoints).toSol()
      );
      return {
        price: parseInt(basisPoints).toSol(),
        currency: res.currency
      };
    }));
  });
  Arweave2.uploadContent = (filePath, feePayer, fileOptions) => __async3(void 0, null, function* () {
    return Try3(() => __async3(void 0, null, function* () {
      debugLog("# upload content: ", filePath);
      let file;
      if (isNode()) {
        const filepath = filePath;
        const buffer2 = (yield import("fs")).readFileSync(filepath);
        if (fileOptions) {
          file = toMetaplexFile(buffer2, filepath, fileOptions);
        } else {
          file = toMetaplexFile(buffer2, filepath);
        }
      } else if (isBrowser()) {
        const filepath = filePath;
        if (fileOptions) {
          file = toMetaplexFile(filepath, "", fileOptions);
        } else {
          file = toMetaplexFile(filepath, "");
        }
      } else {
        throw Error("Supported environment: only Node.js and Browser js");
      }
      return Bundlr.useStorage(feePayer.toKeypair()).upload(file);
    }));
  });
  Arweave2.uploadMetadata = (metadata, feePayer) => __async3(void 0, null, function* () {
    return Try3(() => __async3(void 0, null, function* () {
      debugLog("# upload meta data: ", metadata);
      const uploaded = yield Bundlr.make(feePayer.toKeypair()).nfts().uploadMetadata(metadata);
      return uploaded.uri;
    }));
  });
})(Arweave || (Arweave = {}));
var NftStorage;
((NftStorage2) => {
  let isDisplayWarning = false;
  const getNftStorageApiKey = () => {
    if (!Constants2.nftStorageApiKey) {
      if (!isDisplayWarning) {
        console.warn(
          `
        [Warning]
        --------------------------------------
        If will use @solana-suite/nft package
        your need to update nftStorage.apiKey define parameter in solana-suite.json.
        can get apiKey from https://nft.storage/
        --------------------------------------
        `
        );
        isDisplayWarning = true;
      }
      return Constants2.NFT_STORAGE_API_KEY;
    } else {
      return Constants2.nftStorageApiKey;
    }
  };
  const createGatewayUrl = (cid) => `${Constants2.NFT_STORAGE_GATEWAY_URL}/${cid}`;
  const connect = () => new NFTStorage({ token: getNftStorageApiKey() });
  NftStorage2.uploadContent = (filePath) => __async3(void 0, null, function* () {
    return Try22(() => __async3(void 0, null, function* () {
      debugLog2("# upload content: ", filePath);
      let file;
      if (isNode2()) {
        const filepath = filePath;
        file = (yield import("fs")).readFileSync(filepath);
      } else if (isBrowser2()) {
        const filepath = filePath;
        file = toMetaplexFile2(filepath, "").buffer;
      } else {
        throw Error("Supported environment: only Node.js and Browser js");
      }
      const blobImage = new Blob3([file]);
      const res = yield connect().storeBlob(blobImage);
      return createGatewayUrl(res);
    }));
  });
  NftStorage2.uploadMetadata = (metadata) => __async3(void 0, null, function* () {
    return Try22(() => __async3(void 0, null, function* () {
      debugLog2("# upload metadata: ", metadata);
      const blobJson = new Blob3([JSON.stringify(metadata)]);
      const res = yield connect().storeBlob(blobJson);
      return createGatewayUrl(res);
    }));
  });
})(NftStorage || (NftStorage = {}));
var Storage;
((Storage2) => {
  Storage2.toConvertOffchaindata = (input, sellerFeeBasisPoints) => {
    const data = {
      name: input.name,
      symbol: input.symbol,
      description: input.description,
      seller_fee_basis_points: sellerFeeBasisPoints,
      external_url: input.external_url,
      attributes: input.attributes,
      properties: input.properties,
      image: "",
      options: input.options
    };
    return data;
  };
  Storage2.uploadContent = (filePath, storageType, feePayer) => __async3(void 0, null, function* () {
    if (storageType === "arweave") {
      if (!feePayer) {
        throw Error("Arweave needs to have feepayer");
      }
      return yield Arweave.uploadContent(filePath, feePayer);
    } else if (storageType === "nftStorage") {
      return yield NftStorage.uploadContent(filePath);
    } else {
      throw Error("Not found storageType");
    }
  });
  Storage2.uploadMetaAndContent = (input, filePath, storageType, feePayer) => __async3(void 0, null, function* () {
    let storage;
    if (storageType === "arweave") {
      if (!feePayer) {
        throw Error("Arweave needs to have feepayer");
      }
      storage = yield (yield Arweave.uploadContent(filePath, feePayer)).unwrap(
        (ok) => __async3(void 0, null, function* () {
          input.image = ok;
          return yield Arweave.uploadMetadata(input, feePayer);
        }),
        (err) => {
          throw err;
        }
      );
    } else if (storageType === "nftStorage") {
      storage = yield (yield NftStorage.uploadContent(filePath)).unwrap(
        (ok) => __async3(void 0, null, function* () {
          input.image = ok;
          return yield NftStorage.uploadMetadata(input);
        }),
        (err) => {
          throw err;
        }
      );
    } else {
      throw Error("No match storageType");
    }
    if (!storage) {
      throw Error("Empty storage object");
    }
    return storage;
  });
})(Storage || (Storage = {}));

// src/metaplex/mint.ts
import {
  SystemProgram
} from "@solana/web3.js";
import BN from "bn.js";
import {
  createApproveInstruction,
  createAssociatedTokenAccountInstruction,
  createInitializeMintInstruction,
  createMintToCheckedInstruction,
  getAssociatedTokenAddressSync as getAssociatedTokenAddressSync2,
  getMinimumBalanceForRentExemptMint,
  MINT_SIZE,
  TOKEN_PROGRAM_ID
} from "@solana/spl-token";
import {
  debugLog as debugLog3,
  KeypairAccount as KeypairAccount2,
  MintInstruction,
  Try as Try4
} from "@solana-suite/shared";
import {
  createCreateMasterEditionV3Instruction,
  createCreateMetadataAccountV3Instruction
} from "@metaplex-foundation/mpl-token-metadata";
import { Node as Node2 } from "@solana-suite/shared";
var NFT_AMOUNT = 1;
var Metaplex4;
((Metaplex10) => {
  Metaplex10.createDeleagateInstruction = (mint2, owner, delegateAuthority) => {
    const tokenAccount = getAssociatedTokenAddressSync2(mint2, owner);
    return createApproveInstruction(
      tokenAccount,
      delegateAuthority,
      owner,
      NFT_AMOUNT
    );
  };
  Metaplex10.createMintInstructions = (mint2, owner, nftMetadata, feePayer, isMutable) => __async(void 0, null, function* () {
    const ata = getAssociatedTokenAddressSync2(mint2, owner);
    const tokenMetadataPubkey = Pda.getMetadata(mint2.toString());
    const masterEditionPubkey = Pda.getMasterEdition(mint2.toString());
    const connection = Node2.getConnection();
    const inst1 = SystemProgram.createAccount({
      fromPubkey: feePayer,
      newAccountPubkey: mint2,
      lamports: yield getMinimumBalanceForRentExemptMint(connection),
      space: MINT_SIZE,
      programId: TOKEN_PROGRAM_ID
    });
    const inst2 = createInitializeMintInstruction(mint2, 0, owner, owner);
    const inst3 = createAssociatedTokenAccountInstruction(
      feePayer,
      ata,
      owner,
      mint2
    );
    const inst4 = createMintToCheckedInstruction(mint2, ata, owner, 1, 0);
    const inst5 = createCreateMetadataAccountV3Instruction(
      {
        metadata: tokenMetadataPubkey,
        mint: mint2,
        mintAuthority: owner,
        payer: feePayer,
        updateAuthority: owner
      },
      {
        createMetadataAccountArgsV3: {
          data: nftMetadata,
          isMutable,
          collectionDetails: { __kind: "V1", size: new BN(1) }
        }
      }
    );
    const inst6 = createCreateMasterEditionV3Instruction(
      {
        edition: masterEditionPubkey,
        mint: mint2,
        updateAuthority: owner,
        mintAuthority: owner,
        payer: feePayer,
        metadata: tokenMetadataPubkey
      },
      {
        createMasterEditionArgs: {
          maxSupply: 0
        }
      }
    );
    return [inst1, inst2, inst3, inst4, inst5, inst6];
  });
  Metaplex10.mint = (owner, signer, input, feePayer, freezeAuthority) => __async(void 0, null, function* () {
    return Try4(() => __async(void 0, null, function* () {
      const valid = Validator.checkAll(input);
      if (valid.isErr) {
        throw valid.error;
      }
      const payer = feePayer ? feePayer : signer;
      let properties;
      if (input.properties && input.storageType) {
        properties = yield Convert7.Properties.intoInfraSide(
          input.properties,
          Storage.uploadContent,
          input.storageType,
          payer
        );
      } else if (input.properties && !input.storageType) {
        throw Error("Must set storageType if will use properties");
      }
      input = __spreadProps(__spreadValues({}, input), {
        properties
      });
      const sellerFeeBasisPoints = Royalty.convert(input.royalty);
      const nftStorageMetadata = Storage.toConvertOffchaindata(
        input,
        sellerFeeBasisPoints
      );
      const createdAt = Math.floor((/* @__PURE__ */ new Date()).getTime() / 1e3);
      nftStorageMetadata.created_at = createdAt;
      let uri;
      if (input.filePath && input.storageType) {
        const uploaded = yield Storage.uploadMetaAndContent(
          nftStorageMetadata,
          input.filePath,
          input.storageType,
          payer
        );
        debugLog3("# upload content url: ", uploaded);
        if (uploaded.isErr) {
          throw uploaded;
        }
        uri = uploaded.value;
      } else if (input.uri) {
        uri = input.uri;
      } else {
        throw Error(`Must set 'storageType + filePath' or 'uri'`);
      }
      let datav2 = Convert7.NftMetadata.intoInfraSide(
        input,
        uri,
        sellerFeeBasisPoints
      );
      let collection;
      if (input.collection && input.collection) {
        collection = Convert7.Collection.intoInfraSide(input.collection);
        datav2 = __spreadProps(__spreadValues({}, datav2), { collection });
      }
      const isMutable = input.isMutable === void 0 ? true : input.isMutable;
      debugLog3("# input: ", input);
      debugLog3("# sellerFeeBasisPoints: ", sellerFeeBasisPoints);
      debugLog3("# datav2: ", datav2);
      const mint2 = KeypairAccount2.create();
      const insts = yield (0, Metaplex10.createMintInstructions)(
        mint2.toPublicKey(),
        owner.toPublicKey(),
        datav2,
        payer.toKeypair().publicKey,
        isMutable
      );
      if (freezeAuthority) {
        insts.push(
          (0, Metaplex10.createDeleagateInstruction)(
            mint2.toPublicKey(),
            owner.toPublicKey(),
            freezeAuthority.toPublicKey()
          )
        );
      }
      return new MintInstruction(
        insts,
        [signer.toKeypair(), mint2.toKeypair()],
        payer.toKeypair(),
        mint2.pubkey
      );
    }));
  });
})(Metaplex4 || (Metaplex4 = {}));

// src/metaplex/fee-payer-partial-sign-mint.ts
var Metaplex5;
((Metaplex10) => {
  Metaplex10.feePayerPartialSignMint = (owner, signer, input, feePayer, freezeAuthority) => __async(void 0, null, function* () {
    return Try5(() => __async(void 0, null, function* () {
      const valid = Validator.checkAll(input);
      if (valid.isErr) {
        throw valid.error;
      }
      const sellerFeeBasisPoints = Royalty.convert(input.royalty);
      let uri = "";
      if (input.filePath && input.storageType === "nftStorage") {
        const properties = yield Convert7.Properties.intoInfraSide(
          input.properties,
          Storage.uploadContent,
          input.storageType
        );
        const nftStorageMetadata = Storage.toConvertOffchaindata(
          __spreadProps(__spreadValues({}, input), { properties }),
          sellerFeeBasisPoints
        );
        const uploaded = yield Storage.uploadMetaAndContent(
          nftStorageMetadata,
          input.filePath,
          input.storageType
        );
        if (uploaded.isErr) {
          throw uploaded;
        }
        uri = uploaded.value;
        debugLog4("# upload content url: ", uploaded);
      } else if (input.uri) {
        uri = input.uri;
      } else {
        throw Error(`Must set 'storageType=nftStorage + filePath' or 'uri'`);
      }
      let datav2 = Convert7.NftMetadata.intoInfraSide(
        input,
        uri,
        sellerFeeBasisPoints
      );
      let collection;
      if (input.collection && input.collection) {
        collection = Convert7.Collection.intoInfraSide(input.collection);
        datav2 = __spreadProps(__spreadValues({}, datav2), { collection });
      }
      const isMutable = input.isMutable === void 0 ? true : input.isMutable;
      debugLog4("# input: ", input);
      debugLog4("# sellerFeeBasisPoints: ", sellerFeeBasisPoints);
      debugLog4("# datav2: ", datav2);
      const mint = KeypairAccount3.create();
      const insts = yield Metaplex4.createMintInstructions(
        mint.toPublicKey(),
        owner.toPublicKey(),
        datav2,
        feePayer.toPublicKey(),
        isMutable
      );
      if (freezeAuthority) {
        insts.push(
          Metaplex4.createDeleagateInstruction(
            mint.toPublicKey(),
            owner.toPublicKey(),
            freezeAuthority.toPublicKey()
          )
        );
      }
      const blockhashObj = yield Node3.getConnection().getLatestBlockhash();
      const tx = new Transaction({
        lastValidBlockHeight: blockhashObj.lastValidBlockHeight,
        blockhash: blockhashObj.blockhash,
        feePayer: feePayer.toPublicKey()
      });
      insts.forEach((inst) => tx.add(inst));
      tx.recentBlockhash = blockhashObj.blockhash;
      [signer, mint].forEach((signer2) => tx.partialSign(signer2.toKeypair()));
      const serializedTx = tx.serialize({
        requireAllSignatures: false
      });
      const hex = serializedTx.toString("hex");
      return new PartialSignInstruction(hex, mint.pubkey);
    }));
  });
})(Metaplex5 || (Metaplex5 = {}));

// src/metaplex/fee-payer-partial-sign-transfer.ts
import { SplToken as SplToken3 } from "@solana-suite/core";
var Metaplex6;
((Metaplex10) => {
  const NFT_AMOUNT2 = 1;
  const NFT_DECIMALS = 0;
  Metaplex10.feePayerPartialSignTransferNft = (mint, owner, dest, signers, feePayer) => __async(void 0, null, function* () {
    return SplToken3.feePayerPartialSignTransfer(
      mint,
      owner,
      dest,
      signers,
      NFT_AMOUNT2,
      NFT_DECIMALS,
      feePayer
    );
  });
})(Metaplex6 || (Metaplex6 = {}));

// src/metaplex/thaw.ts
import {
  Instruction as Instruction2,
  KeypairAccount as KeypairAccount4,
  Try as Try6
} from "@solana-suite/shared";
import { getAssociatedTokenAddressSync as getAssociatedTokenAddressSync3 } from "@solana/spl-token";
import { createThawDelegatedAccountInstruction } from "@metaplex-foundation/mpl-token-metadata";
var Metaplex7;
((Metaplex10) => {
  Metaplex10.thaw = (mint, owner, freezeAuthority, feePayer) => {
    const payer = feePayer ? feePayer : freezeAuthority;
    return Try6(() => {
      const tokenAccount = getAssociatedTokenAddressSync3(
        mint.toPublicKey(),
        owner.toPublicKey()
      );
      const editionAddress = Pda.getMasterEdition(mint);
      const inst = createThawDelegatedAccountInstruction({
        delegate: new KeypairAccount4({ secret: freezeAuthority }).toPublicKey(),
        tokenAccount,
        edition: editionAddress,
        mint: mint.toPublicKey()
      });
      return new Instruction2(
        [inst],
        [freezeAuthority.toKeypair()],
        payer.toKeypair()
      );
    });
  };
})(Metaplex7 || (Metaplex7 = {}));

// src/metaplex/transfer.ts
import { SplToken as SplToken4 } from "@solana-suite/core";
var Metaplex8;
((Metaplex10) => {
  const NFT_AMOUNT2 = 1;
  const NFT_DECIMALS = 0;
  Metaplex10.transfer = (mint, owner, dest, signers, feePayer) => __async(void 0, null, function* () {
    return SplToken4.transfer(
      mint,
      owner,
      dest,
      signers,
      NFT_AMOUNT2,
      NFT_DECIMALS,
      feePayer
    );
  });
})(Metaplex8 || (Metaplex8 = {}));

// src/metaplex/index.ts
var Metaplex9 = Object.assign(
  {},
  Metaplex,
  Metaplex2,
  Metaplex3,
  Metaplex5,
  Metaplex6,
  Metaplex4,
  Metaplex7,
  Metaplex8
);
export {
  Metaplex9 as Metaplex
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3JldHJ5QDAuMTMuMS9ub2RlX21vZHVsZXMvcmV0cnkvbGliL3JldHJ5X29wZXJhdGlvbi5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vcmV0cnlAMC4xMy4xL25vZGVfbW9kdWxlcy9yZXRyeS9saWIvcmV0cnkuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3JldHJ5QDAuMTMuMS9ub2RlX21vZHVsZXMvcmV0cnkvaW5kZXguanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3AtcmV0cnlANC42LjIvbm9kZV9tb2R1bGVzL3AtcmV0cnkvaW5kZXguanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3ZhcmludEA2LjAuMC9ub2RlX21vZHVsZXMvdmFyaW50L2VuY29kZS5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vdmFyaW50QDYuMC4wL25vZGVfbW9kdWxlcy92YXJpbnQvZGVjb2RlLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS92YXJpbnRANi4wLjAvbm9kZV9tb2R1bGVzL3ZhcmludC9sZW5ndGguanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3ZhcmludEA2LjAuMC9ub2RlX21vZHVsZXMvdmFyaW50L2luZGV4LmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9pdC1sYXN0QDEuMC42L25vZGVfbW9kdWxlcy9pdC1sYXN0L2luZGV4LmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9pdC1waXBlQDEuMS4wL25vZGVfbW9kdWxlcy9pdC1waXBlL2luZGV4LmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9pdC1iYXRjaEAxLjAuOS9ub2RlX21vZHVsZXMvaXQtYmF0Y2gvaW5kZXguanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2l0LXBhcmFsbGVsLWJhdGNoQDEuMC4xMS9ub2RlX21vZHVsZXMvaXQtcGFyYWxsZWwtYmF0Y2gvaW5kZXguanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2lzLXBsYWluLW9iakAyLjEuMC9ub2RlX21vZHVsZXMvaXMtcGxhaW4tb2JqL2luZGV4LmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9tZXJnZS1vcHRpb25zQDMuMC40L25vZGVfbW9kdWxlcy9tZXJnZS1vcHRpb25zL2luZGV4LmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9tdXJtdXJoYXNoM2pzLXJldmlzaXRlZEAzLjAuMC9ub2RlX21vZHVsZXMvbXVybXVyaGFzaDNqcy1yZXZpc2l0ZWQvbGliL211cm11ckhhc2gzanMuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL211cm11cmhhc2gzanMtcmV2aXNpdGVkQDMuMC4wL25vZGVfbW9kdWxlcy9tdXJtdXJoYXNoM2pzLXJldmlzaXRlZC9pbmRleC5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZXJyLWNvZGVAMy4wLjEvbm9kZV9tb2R1bGVzL2Vyci1jb2RlL2luZGV4LmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AcHJvdG9idWZqcythc3Byb21pc2VAMS4xLjIvbm9kZV9tb2R1bGVzL0Bwcm90b2J1ZmpzL2FzcHJvbWlzZS9pbmRleC5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHByb3RvYnVmanMrYmFzZTY0QDEuMS4yL25vZGVfbW9kdWxlcy9AcHJvdG9idWZqcy9iYXNlNjQvaW5kZXguanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0Bwcm90b2J1ZmpzK2V2ZW50ZW1pdHRlckAxLjEuMC9ub2RlX21vZHVsZXMvQHByb3RvYnVmanMvZXZlbnRlbWl0dGVyL2luZGV4LmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AcHJvdG9idWZqcytmbG9hdEAxLjAuMi9ub2RlX21vZHVsZXMvQHByb3RvYnVmanMvZmxvYXQvaW5kZXguanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0Bwcm90b2J1ZmpzK2lucXVpcmVAMS4xLjAvbm9kZV9tb2R1bGVzL0Bwcm90b2J1ZmpzL2lucXVpcmUvaW5kZXguanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0Bwcm90b2J1ZmpzK3V0ZjhAMS4xLjAvbm9kZV9tb2R1bGVzL0Bwcm90b2J1ZmpzL3V0ZjgvaW5kZXguanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0Bwcm90b2J1ZmpzK3Bvb2xAMS4xLjAvbm9kZV9tb2R1bGVzL0Bwcm90b2J1ZmpzL3Bvb2wvaW5kZXguanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3Byb3RvYnVmanNANi4xMS40L25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy91dGlsL2xvbmdiaXRzLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9wcm90b2J1ZmpzQDYuMTEuNC9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvdXRpbC9taW5pbWFsLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9wcm90b2J1ZmpzQDYuMTEuNC9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvd3JpdGVyLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9wcm90b2J1ZmpzQDYuMTEuNC9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvd3JpdGVyX2J1ZmZlci5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vcHJvdG9idWZqc0A2LjExLjQvbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3JlYWRlci5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vcHJvdG9idWZqc0A2LjExLjQvbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3JlYWRlcl9idWZmZXIuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3Byb3RvYnVmanNANi4xMS40L25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9ycGMvc2VydmljZS5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vcHJvdG9idWZqc0A2LjExLjQvbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3JwYy5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vcHJvdG9idWZqc0A2LjExLjQvbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3Jvb3RzLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9wcm90b2J1ZmpzQDYuMTEuNC9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvaW5kZXgtbWluaW1hbC5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vcHJvdG9idWZqc0A2LjExLjQvbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvbWluaW1hbC5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vaXQtYWxsQDEuMC42L25vZGVfbW9kdWxlcy9pdC1hbGwvaW5kZXguanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2JsQDUuMS4wL25vZGVfbW9kdWxlcy9ibC9CdWZmZXJMaXN0LmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9yYWJpbi13YXNtQDAuMS41L25vZGVfbW9kdWxlcy9yYWJpbi13YXNtL3NyYy9yYWJpbi5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQGFzc2VtYmx5c2NyaXB0K2xvYWRlckAwLjkuNC9ub2RlX21vZHVsZXMvQGFzc2VtYmx5c2NyaXB0L2xvYWRlci9pbmRleC5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vcmFiaW4td2FzbUAwLjEuNS9ub2RlX21vZHVsZXMvcmFiaW4td2FzbS9kaXN0L3JhYmluLXdhc20ubm9kZS5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vcmFiaW4td2FzbUAwLjEuNS9ub2RlX21vZHVsZXMvcmFiaW4td2FzbS9zcmMvaW5kZXguanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3NwYXJzZS1hcnJheUAxLjMuMi9ub2RlX21vZHVsZXMvc3BhcnNlLWFycmF5L2luZGV4LmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9tdWx0aWZvcm1hdHNAOS45LjAvbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9janMvdmVuZG9yL2Jhc2UteC5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbXVsdGlmb3JtYXRzQDkuOS4wL25vZGVfbW9kdWxlcy9tdWx0aWZvcm1hdHMvY2pzL3NyYy9ieXRlcy5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbXVsdGlmb3JtYXRzQDkuOS4wL25vZGVfbW9kdWxlcy9tdWx0aWZvcm1hdHMvY2pzL3NyYy9iYXNlcy9iYXNlLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9tdWx0aWZvcm1hdHNAOS45LjAvbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9janMvc3JjL2Jhc2VzL2lkZW50aXR5LmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9tdWx0aWZvcm1hdHNAOS45LjAvbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9janMvc3JjL2Jhc2VzL2Jhc2UyLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9tdWx0aWZvcm1hdHNAOS45LjAvbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9janMvc3JjL2Jhc2VzL2Jhc2U4LmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9tdWx0aWZvcm1hdHNAOS45LjAvbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9janMvc3JjL2Jhc2VzL2Jhc2UxMC5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbXVsdGlmb3JtYXRzQDkuOS4wL25vZGVfbW9kdWxlcy9tdWx0aWZvcm1hdHMvY2pzL3NyYy9iYXNlcy9iYXNlMTYuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL211bHRpZm9ybWF0c0A5LjkuMC9ub2RlX21vZHVsZXMvbXVsdGlmb3JtYXRzL2Nqcy9zcmMvYmFzZXMvYmFzZTMyLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9tdWx0aWZvcm1hdHNAOS45LjAvbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9janMvc3JjL2Jhc2VzL2Jhc2UzNi5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbXVsdGlmb3JtYXRzQDkuOS4wL25vZGVfbW9kdWxlcy9tdWx0aWZvcm1hdHMvY2pzL3NyYy9iYXNlcy9iYXNlNTguanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL211bHRpZm9ybWF0c0A5LjkuMC9ub2RlX21vZHVsZXMvbXVsdGlmb3JtYXRzL2Nqcy9zcmMvYmFzZXMvYmFzZTY0LmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9tdWx0aWZvcm1hdHNAOS45LjAvbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9janMvc3JjL2Jhc2VzL2Jhc2UyNTZlbW9qaS5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbXVsdGlmb3JtYXRzQDkuOS4wL25vZGVfbW9kdWxlcy9tdWx0aWZvcm1hdHMvY2pzL3ZlbmRvci92YXJpbnQuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL211bHRpZm9ybWF0c0A5LjkuMC9ub2RlX21vZHVsZXMvbXVsdGlmb3JtYXRzL2Nqcy9zcmMvdmFyaW50LmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9tdWx0aWZvcm1hdHNAOS45LjAvbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9janMvc3JjL2hhc2hlcy9kaWdlc3QuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL211bHRpZm9ybWF0c0A5LjkuMC9ub2RlX21vZHVsZXMvbXVsdGlmb3JtYXRzL2Nqcy9zcmMvaGFzaGVzL2hhc2hlci5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbXVsdGlmb3JtYXRzQDkuOS4wL25vZGVfbW9kdWxlcy9tdWx0aWZvcm1hdHMvY2pzL3NyYy9oYXNoZXMvc2hhMi5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbXVsdGlmb3JtYXRzQDkuOS4wL25vZGVfbW9kdWxlcy9tdWx0aWZvcm1hdHMvY2pzL3NyYy9oYXNoZXMvaWRlbnRpdHkuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL211bHRpZm9ybWF0c0A5LjkuMC9ub2RlX21vZHVsZXMvbXVsdGlmb3JtYXRzL2Nqcy9zcmMvY29kZWNzL3Jhdy5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbXVsdGlmb3JtYXRzQDkuOS4wL25vZGVfbW9kdWxlcy9tdWx0aWZvcm1hdHMvY2pzL3NyYy9jb2RlY3MvanNvbi5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbXVsdGlmb3JtYXRzQDkuOS4wL25vZGVfbW9kdWxlcy9tdWx0aWZvcm1hdHMvY2pzL3NyYy9jaWQuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL211bHRpZm9ybWF0c0A5LjkuMC9ub2RlX21vZHVsZXMvbXVsdGlmb3JtYXRzL2Nqcy9zcmMvaW5kZXguanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL211bHRpZm9ybWF0c0A5LjkuMC9ub2RlX21vZHVsZXMvbXVsdGlmb3JtYXRzL2Nqcy9zcmMvYmFzaWNzLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS91aW50OGFycmF5c0AzLjEuMS9ub2RlX21vZHVsZXMvdWludDhhcnJheXMvY2pzL3NyYy91dGlsL2FzLXVpbnQ4YXJyYXkuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3VpbnQ4YXJyYXlzQDMuMS4xL25vZGVfbW9kdWxlcy91aW50OGFycmF5cy9janMvc3JjL2FsbG9jLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS91aW50OGFycmF5c0AzLjEuMS9ub2RlX21vZHVsZXMvdWludDhhcnJheXMvY2pzL3NyYy91dGlsL2Jhc2VzLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS91aW50OGFycmF5c0AzLjEuMS9ub2RlX21vZHVsZXMvdWludDhhcnJheXMvY2pzL3NyYy9mcm9tLXN0cmluZy5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vaGFtdC1zaGFyZGluZ0AyLjAuMS9ub2RlX21vZHVsZXMvaGFtdC1zaGFyZGluZy9zcmMvYnVja2V0LmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9oYW10LXNoYXJkaW5nQDIuMC4xL25vZGVfbW9kdWxlcy9oYW10LXNoYXJkaW5nL3NyYy9jb25zdW1hYmxlLWJ1ZmZlci5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vdWludDhhcnJheXNAMy4xLjEvbm9kZV9tb2R1bGVzL3VpbnQ4YXJyYXlzL2Nqcy9zcmMvY29uY2F0LmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9oYW10LXNoYXJkaW5nQDIuMC4xL25vZGVfbW9kdWxlcy9oYW10LXNoYXJkaW5nL3NyYy9jb25zdW1hYmxlLWhhc2guanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2hhbXQtc2hhcmRpbmdAMi4wLjEvbm9kZV9tb2R1bGVzL2hhbXQtc2hhcmRpbmcvc3JjL2luZGV4LmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9icm93c2VyLXJlYWRhYmxlc3RyZWFtLXRvLWl0QDEuMC4zL25vZGVfbW9kdWxlcy9icm93c2VyLXJlYWRhYmxlc3RyZWFtLXRvLWl0L2luZGV4LmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9ibG9iLXRvLWl0QDEuMC40L25vZGVfbW9kdWxlcy9ibG9iLXRvLWl0L2luZGV4LmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9pdC1wZWVrYWJsZUAxLjAuMy9ub2RlX21vZHVsZXMvaXQtcGVla2FibGUvaW5kZXguanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2l0LW1hcEAxLjAuNi9ub2RlX21vZHVsZXMvaXQtbWFwL2luZGV4LmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9pdC1kcmFpbkAxLjAuNS9ub2RlX21vZHVsZXMvaXQtZHJhaW4vaW5kZXguanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2l0LWZpbHRlckAxLjAuMy9ub2RlX21vZHVsZXMvaXQtZmlsdGVyL2luZGV4LmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9pdC10YWtlQDEuMC4yL25vZGVfbW9kdWxlcy9pdC10YWtlL2luZGV4LmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS90aHJvdHRsZWQtcXVldWVAMi4xLjQvbm9kZV9tb2R1bGVzL3Rocm90dGxlZC1xdWV1ZS9zcmMvdGhyb3R0bGVkUXVldWUudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2RhdGEtdXJpLXRvLWJ1ZmZlckAzLjAuMS9ub2RlX21vZHVsZXMvZGF0YS11cmktdG8tYnVmZmVyL3NyYy9pbmRleC50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vd2ViLXN0cmVhbXMtcG9seWZpbGxAMy4yLjEvbm9kZV9tb2R1bGVzL3dlYi1zdHJlYW1zLXBvbHlmaWxsL3NyYy9zdHViL3N5bWJvbC50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vd2ViLXN0cmVhbXMtcG9seWZpbGxAMy4yLjEvbm9kZV9tb2R1bGVzL3dlYi1zdHJlYW1zLXBvbHlmaWxsL3NyYy91dGlscy50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vd2ViLXN0cmVhbXMtcG9seWZpbGxAMy4yLjEvbm9kZV9tb2R1bGVzL3dlYi1zdHJlYW1zLXBvbHlmaWxsL3NyYy9saWIvaGVscGVycy9taXNjZWxsYW5lb3VzLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS93ZWItc3RyZWFtcy1wb2x5ZmlsbEAzLjIuMS9ub2RlX21vZHVsZXMvd2ViLXN0cmVhbXMtcG9seWZpbGwvc3JjL2xpYi9oZWxwZXJzL3dlYmlkbC50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vd2ViLXN0cmVhbXMtcG9seWZpbGxAMy4yLjEvbm9kZV9tb2R1bGVzL3dlYi1zdHJlYW1zLXBvbHlmaWxsL3NyYy9saWIvc2ltcGxlLXF1ZXVlLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS93ZWItc3RyZWFtcy1wb2x5ZmlsbEAzLjIuMS9ub2RlX21vZHVsZXMvd2ViLXN0cmVhbXMtcG9seWZpbGwvc3JjL2xpYi9yZWFkYWJsZS1zdHJlYW0vZ2VuZXJpYy1yZWFkZXIudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3dlYi1zdHJlYW1zLXBvbHlmaWxsQDMuMi4xL25vZGVfbW9kdWxlcy93ZWItc3RyZWFtcy1wb2x5ZmlsbC9zcmMvbGliL2Fic3RyYWN0LW9wcy9pbnRlcm5hbC1tZXRob2RzLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS93ZWItc3RyZWFtcy1wb2x5ZmlsbEAzLjIuMS9ub2RlX21vZHVsZXMvd2ViLXN0cmVhbXMtcG9seWZpbGwvc3JjL3N0dWIvbnVtYmVyLWlzZmluaXRlLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS93ZWItc3RyZWFtcy1wb2x5ZmlsbEAzLjIuMS9ub2RlX21vZHVsZXMvd2ViLXN0cmVhbXMtcG9seWZpbGwvc3JjL3N0dWIvbWF0aC10cnVuYy50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vd2ViLXN0cmVhbXMtcG9seWZpbGxAMy4yLjEvbm9kZV9tb2R1bGVzL3dlYi1zdHJlYW1zLXBvbHlmaWxsL3NyYy9saWIvdmFsaWRhdG9ycy9iYXNpYy50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vd2ViLXN0cmVhbXMtcG9seWZpbGxAMy4yLjEvbm9kZV9tb2R1bGVzL3dlYi1zdHJlYW1zLXBvbHlmaWxsL3NyYy9saWIvdmFsaWRhdG9ycy9yZWFkYWJsZS1zdHJlYW0udHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3dlYi1zdHJlYW1zLXBvbHlmaWxsQDMuMi4xL25vZGVfbW9kdWxlcy93ZWItc3RyZWFtcy1wb2x5ZmlsbC9zcmMvbGliL3JlYWRhYmxlLXN0cmVhbS9kZWZhdWx0LXJlYWRlci50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vd2ViLXN0cmVhbXMtcG9seWZpbGxAMy4yLjEvbm9kZV9tb2R1bGVzL3dlYi1zdHJlYW1zLXBvbHlmaWxsL3NyYy90YXJnZXQvZXM1L3N0dWIvYXN5bmMtaXRlcmF0b3ItcHJvdG90eXBlLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS93ZWItc3RyZWFtcy1wb2x5ZmlsbEAzLjIuMS9ub2RlX21vZHVsZXMvd2ViLXN0cmVhbXMtcG9seWZpbGwvc3JjL2xpYi9yZWFkYWJsZS1zdHJlYW0vYXN5bmMtaXRlcmF0b3IudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3dlYi1zdHJlYW1zLXBvbHlmaWxsQDMuMi4xL25vZGVfbW9kdWxlcy93ZWItc3RyZWFtcy1wb2x5ZmlsbC9zcmMvc3R1Yi9udW1iZXItaXNuYW4udHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3dlYi1zdHJlYW1zLXBvbHlmaWxsQDMuMi4xL25vZGVfbW9kdWxlcy93ZWItc3RyZWFtcy1wb2x5ZmlsbC9zcmMvbGliL2Fic3RyYWN0LW9wcy9lY21hc2NyaXB0LnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS93ZWItc3RyZWFtcy1wb2x5ZmlsbEAzLjIuMS9ub2RlX21vZHVsZXMvd2ViLXN0cmVhbXMtcG9seWZpbGwvc3JjL2xpYi9hYnN0cmFjdC1vcHMvbWlzY2VsbGFuZW91cy50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vd2ViLXN0cmVhbXMtcG9seWZpbGxAMy4yLjEvbm9kZV9tb2R1bGVzL3dlYi1zdHJlYW1zLXBvbHlmaWxsL3NyYy9saWIvYWJzdHJhY3Qtb3BzL3F1ZXVlLXdpdGgtc2l6ZXMudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3dlYi1zdHJlYW1zLXBvbHlmaWxsQDMuMi4xL25vZGVfbW9kdWxlcy93ZWItc3RyZWFtcy1wb2x5ZmlsbC9zcmMvbGliL3JlYWRhYmxlLXN0cmVhbS9ieXRlLXN0cmVhbS1jb250cm9sbGVyLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS93ZWItc3RyZWFtcy1wb2x5ZmlsbEAzLjIuMS9ub2RlX21vZHVsZXMvd2ViLXN0cmVhbXMtcG9seWZpbGwvc3JjL2xpYi9yZWFkYWJsZS1zdHJlYW0vYnlvYi1yZWFkZXIudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3dlYi1zdHJlYW1zLXBvbHlmaWxsQDMuMi4xL25vZGVfbW9kdWxlcy93ZWItc3RyZWFtcy1wb2x5ZmlsbC9zcmMvbGliL2Fic3RyYWN0LW9wcy9xdWV1aW5nLXN0cmF0ZWd5LnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS93ZWItc3RyZWFtcy1wb2x5ZmlsbEAzLjIuMS9ub2RlX21vZHVsZXMvd2ViLXN0cmVhbXMtcG9seWZpbGwvc3JjL2xpYi92YWxpZGF0b3JzL3F1ZXVpbmctc3RyYXRlZ3kudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3dlYi1zdHJlYW1zLXBvbHlmaWxsQDMuMi4xL25vZGVfbW9kdWxlcy93ZWItc3RyZWFtcy1wb2x5ZmlsbC9zcmMvbGliL3ZhbGlkYXRvcnMvdW5kZXJseWluZy1zaW5rLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS93ZWItc3RyZWFtcy1wb2x5ZmlsbEAzLjIuMS9ub2RlX21vZHVsZXMvd2ViLXN0cmVhbXMtcG9seWZpbGwvc3JjL2xpYi92YWxpZGF0b3JzL3dyaXRhYmxlLXN0cmVhbS50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vd2ViLXN0cmVhbXMtcG9seWZpbGxAMy4yLjEvbm9kZV9tb2R1bGVzL3dlYi1zdHJlYW1zLXBvbHlmaWxsL3NyYy9saWIvYWJvcnQtc2lnbmFsLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS93ZWItc3RyZWFtcy1wb2x5ZmlsbEAzLjIuMS9ub2RlX21vZHVsZXMvd2ViLXN0cmVhbXMtcG9seWZpbGwvc3JjL2xpYi93cml0YWJsZS1zdHJlYW0udHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3dlYi1zdHJlYW1zLXBvbHlmaWxsQDMuMi4xL25vZGVfbW9kdWxlcy93ZWItc3RyZWFtcy1wb2x5ZmlsbC9zcmMvc3R1Yi9uYXRpdmUudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3dlYi1zdHJlYW1zLXBvbHlmaWxsQDMuMi4xL25vZGVfbW9kdWxlcy93ZWItc3RyZWFtcy1wb2x5ZmlsbC9zcmMvc3R1Yi9kb20tZXhjZXB0aW9uLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS93ZWItc3RyZWFtcy1wb2x5ZmlsbEAzLjIuMS9ub2RlX21vZHVsZXMvd2ViLXN0cmVhbXMtcG9seWZpbGwvc3JjL2xpYi9yZWFkYWJsZS1zdHJlYW0vcGlwZS50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vd2ViLXN0cmVhbXMtcG9seWZpbGxAMy4yLjEvbm9kZV9tb2R1bGVzL3dlYi1zdHJlYW1zLXBvbHlmaWxsL3NyYy9saWIvcmVhZGFibGUtc3RyZWFtL2RlZmF1bHQtY29udHJvbGxlci50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vd2ViLXN0cmVhbXMtcG9seWZpbGxAMy4yLjEvbm9kZV9tb2R1bGVzL3dlYi1zdHJlYW1zLXBvbHlmaWxsL3NyYy9saWIvcmVhZGFibGUtc3RyZWFtL3RlZS50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vd2ViLXN0cmVhbXMtcG9seWZpbGxAMy4yLjEvbm9kZV9tb2R1bGVzL3dlYi1zdHJlYW1zLXBvbHlmaWxsL3NyYy9saWIvdmFsaWRhdG9ycy91bmRlcmx5aW5nLXNvdXJjZS50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vd2ViLXN0cmVhbXMtcG9seWZpbGxAMy4yLjEvbm9kZV9tb2R1bGVzL3dlYi1zdHJlYW1zLXBvbHlmaWxsL3NyYy9saWIvdmFsaWRhdG9ycy9yZWFkZXItb3B0aW9ucy50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vd2ViLXN0cmVhbXMtcG9seWZpbGxAMy4yLjEvbm9kZV9tb2R1bGVzL3dlYi1zdHJlYW1zLXBvbHlmaWxsL3NyYy9saWIvdmFsaWRhdG9ycy9pdGVyYXRvci1vcHRpb25zLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS93ZWItc3RyZWFtcy1wb2x5ZmlsbEAzLjIuMS9ub2RlX21vZHVsZXMvd2ViLXN0cmVhbXMtcG9seWZpbGwvc3JjL2xpYi92YWxpZGF0b3JzL3BpcGUtb3B0aW9ucy50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vd2ViLXN0cmVhbXMtcG9seWZpbGxAMy4yLjEvbm9kZV9tb2R1bGVzL3dlYi1zdHJlYW1zLXBvbHlmaWxsL3NyYy9saWIvdmFsaWRhdG9ycy9yZWFkYWJsZS13cml0YWJsZS1wYWlyLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS93ZWItc3RyZWFtcy1wb2x5ZmlsbEAzLjIuMS9ub2RlX21vZHVsZXMvd2ViLXN0cmVhbXMtcG9seWZpbGwvc3JjL2xpYi9yZWFkYWJsZS1zdHJlYW0udHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3dlYi1zdHJlYW1zLXBvbHlmaWxsQDMuMi4xL25vZGVfbW9kdWxlcy93ZWItc3RyZWFtcy1wb2x5ZmlsbC9zcmMvbGliL3ZhbGlkYXRvcnMvcXVldWluZy1zdHJhdGVneS1pbml0LnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS93ZWItc3RyZWFtcy1wb2x5ZmlsbEAzLjIuMS9ub2RlX21vZHVsZXMvd2ViLXN0cmVhbXMtcG9seWZpbGwvc3JjL2xpYi9ieXRlLWxlbmd0aC1xdWV1aW5nLXN0cmF0ZWd5LnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS93ZWItc3RyZWFtcy1wb2x5ZmlsbEAzLjIuMS9ub2RlX21vZHVsZXMvd2ViLXN0cmVhbXMtcG9seWZpbGwvc3JjL2xpYi9jb3VudC1xdWV1aW5nLXN0cmF0ZWd5LnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS93ZWItc3RyZWFtcy1wb2x5ZmlsbEAzLjIuMS9ub2RlX21vZHVsZXMvd2ViLXN0cmVhbXMtcG9seWZpbGwvc3JjL2xpYi92YWxpZGF0b3JzL3RyYW5zZm9ybWVyLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS93ZWItc3RyZWFtcy1wb2x5ZmlsbEAzLjIuMS9ub2RlX21vZHVsZXMvd2ViLXN0cmVhbXMtcG9seWZpbGwvc3JjL2xpYi90cmFuc2Zvcm0tc3RyZWFtLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ad2ViLXN0ZCtzdHJlYW1AMS4wLjAvbm9kZV9tb2R1bGVzL0B3ZWItc3RkL3N0cmVhbS9zcmMvc3RyZWFtLmNqcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZXZlbnQtdGFyZ2V0LXNoaW1ANS4wLjEvbm9kZV9tb2R1bGVzL2V2ZW50LXRhcmdldC1zaGltL3NyYy9ldmVudC5tanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2V2ZW50LXRhcmdldC1zaGltQDUuMC4xL25vZGVfbW9kdWxlcy9ldmVudC10YXJnZXQtc2hpbS9zcmMvZXZlbnQtdGFyZ2V0Lm1qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vYWJvcnQtY29udHJvbGxlckAzLjAuMC9ub2RlX21vZHVsZXMvYWJvcnQtY29udHJvbGxlci9zcmMvYWJvcnQtc2lnbmFsLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9hYm9ydC1jb250cm9sbGVyQDMuMC4wL25vZGVfbW9kdWxlcy9hYm9ydC1jb250cm9sbGVyL3NyYy9hYm9ydC1jb250cm9sbGVyLnRzIiwgIi4uL3NyYy9tZXRhcGxleC9idXJuLnRzIiwgIi4uLy4uL2ludGVybmFsL3NoYXJlZC1tZXRhcGxleC9zcmMvY29udmVydC9jb2xsZWN0aW9uLnRzIiwgIi4uLy4uL2ludGVybmFsL3NoYXJlZC1tZXRhcGxleC9zcmMvY29udmVydC9jcmVhdG9ycy50cyIsICIuLi8uLi9pbnRlcm5hbC9zaGFyZWQtbWV0YXBsZXgvc3JjL2NvbnZlcnQvdXNlcy50cyIsICIuLi8uLi9pbnRlcm5hbC9zaGFyZWQtbWV0YXBsZXgvc3JjL2NvbnZlcnQvdG9rZW4tbWV0YWRhdGEudHMiLCAiLi4vLi4vaW50ZXJuYWwvc2hhcmVkLW1ldGFwbGV4L3NyYy9jb252ZXJ0L25mdC1tZXRhZGF0YS50cyIsICIuLi8uLi9pbnRlcm5hbC9zaGFyZWQtbWV0YXBsZXgvc3JjL2NvbnZlcnQvcHJvcGVydGllcy50cyIsICIuLi8uLi9pbnRlcm5hbC9zaGFyZWQtbWV0YXBsZXgvc3JjL2NvbnZlcnQvaW5kZXgudHMiLCAiLi4vLi4vaW50ZXJuYWwvc2hhcmVkLW1ldGFwbGV4L3NyYy90eXBlcy91c2VyLXNpZGUvaW5wdXQudHMiLCAiLi4vLi4vaW50ZXJuYWwvc2hhcmVkLW1ldGFwbGV4L3NyYy90eXBlcy9zaGFyZWQudHMiLCAiLi4vLi4vaW50ZXJuYWwvc2hhcmVkLW1ldGFwbGV4L3NyYy9wZGEudHMiLCAiLi4vLi4vaW50ZXJuYWwvc2hhcmVkLW1ldGFwbGV4L3NyYy92YWxpZGF0b3IudHMiLCAiLi4vLi4vaW50ZXJuYWwvc2hhcmVkLW1ldGFwbGV4L3NyYy9yb3lhbHR5LnRzIiwgIi4uL3NyYy9tZXRhcGxleC9maW5kLnRzIiwgIi4uL3NyYy9tZXRhcGxleC9mcmVlemUudHMiLCAiLi4vc3JjL21ldGFwbGV4L2ZlZS1wYXllci1wYXJ0aWFsLXNpZ24tbWludC50cyIsICIuLi8uLi9pbnRlcm5hbC9zdG9yYWdlL3NyYy9hcndlYXZlLnRzIiwgIi4uLy4uL2ludGVybmFsL3N0b3JhZ2Uvc3JjL2J1bmRsci50cyIsICIuLi8uLi9pbnRlcm5hbC9zdG9yYWdlL3NyYy9uZnQtc3RvcmFnZS50cyIsICIuLi8uLi9pbnRlcm5hbC9zdG9yYWdlL3NyYy9zdG9yYWdlLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9zdHJlYW1pbmctaXRlcmFibGVzQDYuMi4wL25vZGVfbW9kdWxlcy9zdHJlYW1pbmctaXRlcmFibGVzL2Rpc3QvaW5kZXgubWpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9uZnQuc3RvcmFnZUA3LjEuMV9ub2RlLWZldGNoQDMuMy4yL25vZGVfbW9kdWxlcy9uZnQuc3RvcmFnZS9zcmMvbGliLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AaXBsZCtjYXJAMy4yLjQvbm9kZV9tb2R1bGVzL0BpcGxkL2Nhci9lc20vbGliL3JlYWRlci5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQGlwbGQrY2FyQDMuMi40L25vZGVfbW9kdWxlcy9AaXBsZC9jYXIvZXNtL2xpYi9kZWNvZGVyLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9tdWx0aWZvcm1hdHNAOS45LjAvbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9lc20vdmVuZG9yL3ZhcmludC5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbXVsdGlmb3JtYXRzQDkuOS4wL25vZGVfbW9kdWxlcy9tdWx0aWZvcm1hdHMvZXNtL3NyYy92YXJpbnQuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL211bHRpZm9ybWF0c0A5LjkuMC9ub2RlX21vZHVsZXMvbXVsdGlmb3JtYXRzL2VzbS9zcmMvYnl0ZXMuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL211bHRpZm9ybWF0c0A5LjkuMC9ub2RlX21vZHVsZXMvbXVsdGlmb3JtYXRzL2VzbS9zcmMvaGFzaGVzL2RpZ2VzdC5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbXVsdGlmb3JtYXRzQDkuOS4wL25vZGVfbW9kdWxlcy9tdWx0aWZvcm1hdHMvZXNtL3NyYy9iYXNlcy9iYXNlNTguanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL211bHRpZm9ybWF0c0A5LjkuMC9ub2RlX21vZHVsZXMvbXVsdGlmb3JtYXRzL2VzbS92ZW5kb3IvYmFzZS14LmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9tdWx0aWZvcm1hdHNAOS45LjAvbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9lc20vc3JjL2Jhc2VzL2Jhc2UuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL211bHRpZm9ybWF0c0A5LjkuMC9ub2RlX21vZHVsZXMvbXVsdGlmb3JtYXRzL2VzbS9zcmMvYmFzZXMvYmFzZTMyLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9tdWx0aWZvcm1hdHNAOS45LjAvbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9lc20vc3JjL2NpZC5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vY2JvcmdAMS4xMC4yL25vZGVfbW9kdWxlcy9jYm9yZy9lc20vbGliL2lzLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9jYm9yZ0AxLjEwLjIvbm9kZV9tb2R1bGVzL2Nib3JnL2VzbS9saWIvdG9rZW4uanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2Nib3JnQDEuMTAuMi9ub2RlX21vZHVsZXMvY2JvcmcvZXNtL2xpYi9ieXRlLXV0aWxzLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9jYm9yZ0AxLjEwLjIvbm9kZV9tb2R1bGVzL2Nib3JnL2VzbS9saWIvYmwuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2Nib3JnQDEuMTAuMi9ub2RlX21vZHVsZXMvY2JvcmcvZXNtL2xpYi9jb21tb24uanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2Nib3JnQDEuMTAuMi9ub2RlX21vZHVsZXMvY2JvcmcvZXNtL2xpYi8wdWludC5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vY2JvcmdAMS4xMC4yL25vZGVfbW9kdWxlcy9jYm9yZy9lc20vbGliLzFuZWdpbnQuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2Nib3JnQDEuMTAuMi9ub2RlX21vZHVsZXMvY2JvcmcvZXNtL2xpYi8yYnl0ZXMuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2Nib3JnQDEuMTAuMi9ub2RlX21vZHVsZXMvY2JvcmcvZXNtL2xpYi8zc3RyaW5nLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9jYm9yZ0AxLjEwLjIvbm9kZV9tb2R1bGVzL2Nib3JnL2VzbS9saWIvNGFycmF5LmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9jYm9yZ0AxLjEwLjIvbm9kZV9tb2R1bGVzL2Nib3JnL2VzbS9saWIvNW1hcC5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vY2JvcmdAMS4xMC4yL25vZGVfbW9kdWxlcy9jYm9yZy9lc20vbGliLzZ0YWcuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2Nib3JnQDEuMTAuMi9ub2RlX21vZHVsZXMvY2JvcmcvZXNtL2xpYi83ZmxvYXQuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2Nib3JnQDEuMTAuMi9ub2RlX21vZHVsZXMvY2JvcmcvZXNtL2xpYi9qdW1wLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9jYm9yZ0AxLjEwLjIvbm9kZV9tb2R1bGVzL2Nib3JnL2VzbS9saWIvZW5jb2RlLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9jYm9yZ0AxLjEwLjIvbm9kZV9tb2R1bGVzL2Nib3JnL2VzbS9saWIvZGVjb2RlLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AaXBsZCtkYWctY2JvckA3LjAuMy9ub2RlX21vZHVsZXMvQGlwbGQvZGFnLWNib3IvZXNtL2luZGV4LmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AaXBsZCtjYXJAMy4yLjQvbm9kZV9tb2R1bGVzL0BpcGxkL2Nhci9lc20vbGliL3JlYWRlci1icm93c2VyLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AaXBsZCtjYXJAMy4yLjQvbm9kZV9tb2R1bGVzL0BpcGxkL2Nhci9lc20vbGliL2luZGV4ZXIuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BpcGxkK2NhckAzLjIuNC9ub2RlX21vZHVsZXMvQGlwbGQvY2FyL2VzbS9saWIvaXRlcmF0b3IuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BpcGxkK2NhckAzLjIuNC9ub2RlX21vZHVsZXMvQGlwbGQvY2FyL2VzbS9saWIvd3JpdGVyLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AaXBsZCtjYXJAMy4yLjQvbm9kZV9tb2R1bGVzL0BpcGxkL2Nhci9lc20vbGliL2VuY29kZXIuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BpcGxkK2NhckAzLjIuNC9ub2RlX21vZHVsZXMvQGlwbGQvY2FyL2VzbS9saWIvaXRlcmF0b3ItY2hhbm5lbC5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQGlwbGQrY2FyQDMuMi40L25vZGVfbW9kdWxlcy9AaXBsZC9jYXIvZXNtL2xpYi93cml0ZXItYnJvd3Nlci5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbXVsdGlmb3JtYXRzQDkuOS4wL25vZGVfbW9kdWxlcy9tdWx0aWZvcm1hdHMvZXNtL3NyYy9oYXNoZXMvaGFzaGVyLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9tdWx0aWZvcm1hdHNAOS45LjAvbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9lc20vc3JjL2Jsb2NrLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9tdWx0aWZvcm1hdHNAOS45LjAvbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9lc20vc3JjL2NvZGVjcy9yYXcuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BpcGxkK2RhZy1jYm9yQDYuMC4xNS9ub2RlX21vZHVsZXMvQGlwbGQvZGFnLWNib3IvZXNtL2luZGV4LmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AaXBsZCtkYWctcGJAMi4xLjE4L25vZGVfbW9kdWxlcy9AaXBsZC9kYWctcGIvZXNtL3NyYy9pbmRleC5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQGlwbGQrZGFnLXBiQDIuMS4xOC9ub2RlX21vZHVsZXMvQGlwbGQvZGFnLXBiL2VzbS9zcmMvcGItZGVjb2RlLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AaXBsZCtkYWctcGJAMi4xLjE4L25vZGVfbW9kdWxlcy9AaXBsZC9kYWctcGIvZXNtL3NyYy9wYi1lbmNvZGUuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BpcGxkK2RhZy1wYkAyLjEuMTgvbm9kZV9tb2R1bGVzL0BpcGxkL2RhZy1wYi9lc20vc3JjL3V0aWwuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2NhcmJpdGVzQDEuMC42L25vZGVfbW9kdWxlcy9jYXJiaXRlcy9lc20vbGliL3RyZWV3YWxrL3NwbGl0dGVyLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9pcGZzLWNhckAwLjYuMl9ub2RlLWZldGNoQDMuMy4yL25vZGVfbW9kdWxlcy9pcGZzLWNhci9kaXN0L2VzbS9wYWNrL2luZGV4LmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9pcGZzLXVuaXhmcy1pbXBvcnRlckA5LjAuMTAvbm9kZV9tb2R1bGVzL2lwZnMtdW5peGZzLWltcG9ydGVyL2VzbS9zcmMvaW5kZXguanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL21lcmdlLW9wdGlvbnNAMy4wLjQvbm9kZV9tb2R1bGVzL21lcmdlLW9wdGlvbnMvaW5kZXgubWpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9tdWx0aWZvcm1hdHNAOS45LjAvbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9lc20vc3JjL2hhc2hlcy9zaGEyLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AbXVsdGlmb3JtYXRzK211cm11cjNAMS4xLjMvbm9kZV9tb2R1bGVzL0BtdWx0aWZvcm1hdHMvbXVybXVyMy9lc20vaW5kZXguanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2lwZnMtdW5peGZzLWltcG9ydGVyQDkuMC4xMC9ub2RlX21vZHVsZXMvaXBmcy11bml4ZnMtaW1wb3J0ZXIvZXNtL3NyYy9vcHRpb25zLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9pcGZzLXVuaXhmc0A2LjAuOS9ub2RlX21vZHVsZXMvaXBmcy11bml4ZnMvZXNtL3NyYy9pbmRleC5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vaXBmcy11bml4ZnNANi4wLjkvbm9kZV9tb2R1bGVzL2lwZnMtdW5peGZzL2VzbS9zcmMvdW5peGZzLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9pcGZzLXVuaXhmcy1pbXBvcnRlckA5LjAuMTAvbm9kZV9tb2R1bGVzL2lwZnMtdW5peGZzLWltcG9ydGVyL2VzbS9zcmMvdXRpbHMvcGVyc2lzdC5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vaXBmcy11bml4ZnMtaW1wb3J0ZXJAOS4wLjEwL25vZGVfbW9kdWxlcy9pcGZzLXVuaXhmcy1pbXBvcnRlci9lc20vc3JjL2RhZy1idWlsZGVyL2Rpci5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vaXBmcy11bml4ZnMtaW1wb3J0ZXJAOS4wLjEwL25vZGVfbW9kdWxlcy9pcGZzLXVuaXhmcy1pbXBvcnRlci9lc20vc3JjL2RhZy1idWlsZGVyL2ZpbGUvaW5kZXguanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2lwZnMtdW5peGZzLWltcG9ydGVyQDkuMC4xMC9ub2RlX21vZHVsZXMvaXBmcy11bml4ZnMtaW1wb3J0ZXIvZXNtL3NyYy9kYWctYnVpbGRlci9maWxlL2ZsYXQuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2lwZnMtdW5peGZzLWltcG9ydGVyQDkuMC4xMC9ub2RlX21vZHVsZXMvaXBmcy11bml4ZnMtaW1wb3J0ZXIvZXNtL3NyYy9kYWctYnVpbGRlci9maWxlL2JhbGFuY2VkLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9pcGZzLXVuaXhmcy1pbXBvcnRlckA5LjAuMTAvbm9kZV9tb2R1bGVzL2lwZnMtdW5peGZzLWltcG9ydGVyL2VzbS9zcmMvZGFnLWJ1aWxkZXIvZmlsZS90cmlja2xlLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9pcGZzLXVuaXhmcy1pbXBvcnRlckA5LjAuMTAvbm9kZV9tb2R1bGVzL2lwZnMtdW5peGZzLWltcG9ydGVyL2VzbS9zcmMvZGFnLWJ1aWxkZXIvZmlsZS9idWZmZXItaW1wb3J0ZXIuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2lwZnMtdW5peGZzLWltcG9ydGVyQDkuMC4xMC9ub2RlX21vZHVsZXMvaXBmcy11bml4ZnMtaW1wb3J0ZXIvZXNtL3NyYy9kYWctYnVpbGRlci9pbmRleC5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vaXBmcy11bml4ZnMtaW1wb3J0ZXJAOS4wLjEwL25vZGVfbW9kdWxlcy9pcGZzLXVuaXhmcy1pbXBvcnRlci9lc20vc3JjL2NodW5rZXIvcmFiaW4uanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2lwZnMtdW5peGZzLWltcG9ydGVyQDkuMC4xMC9ub2RlX21vZHVsZXMvaXBmcy11bml4ZnMtaW1wb3J0ZXIvZXNtL3NyYy9jaHVua2VyL2ZpeGVkLXNpemUuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2lwZnMtdW5peGZzLWltcG9ydGVyQDkuMC4xMC9ub2RlX21vZHVsZXMvaXBmcy11bml4ZnMtaW1wb3J0ZXIvZXNtL3NyYy9kYWctYnVpbGRlci92YWxpZGF0ZS1jaHVua3MuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL211bHRpZm9ybWF0c0A5LjkuMC9ub2RlX21vZHVsZXMvbXVsdGlmb3JtYXRzL2VzbS9zcmMvYmFzZXMvaWRlbnRpdHkuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL211bHRpZm9ybWF0c0A5LjkuMC9ub2RlX21vZHVsZXMvbXVsdGlmb3JtYXRzL2VzbS9zcmMvYmFzZXMvYmFzZTIuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL211bHRpZm9ybWF0c0A5LjkuMC9ub2RlX21vZHVsZXMvbXVsdGlmb3JtYXRzL2VzbS9zcmMvYmFzZXMvYmFzZTguanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL211bHRpZm9ybWF0c0A5LjkuMC9ub2RlX21vZHVsZXMvbXVsdGlmb3JtYXRzL2VzbS9zcmMvYmFzZXMvYmFzZTEwLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9tdWx0aWZvcm1hdHNAOS45LjAvbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9lc20vc3JjL2Jhc2VzL2Jhc2UxNi5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbXVsdGlmb3JtYXRzQDkuOS4wL25vZGVfbW9kdWxlcy9tdWx0aWZvcm1hdHMvZXNtL3NyYy9iYXNlcy9iYXNlMzYuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL211bHRpZm9ybWF0c0A5LjkuMC9ub2RlX21vZHVsZXMvbXVsdGlmb3JtYXRzL2VzbS9zcmMvYmFzZXMvYmFzZTY0LmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9tdWx0aWZvcm1hdHNAOS45LjAvbm9kZV9tb2R1bGVzL211bHRpZm9ybWF0cy9lc20vc3JjL2Jhc2VzL2Jhc2UyNTZlbW9qaS5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbXVsdGlmb3JtYXRzQDkuOS4wL25vZGVfbW9kdWxlcy9tdWx0aWZvcm1hdHMvZXNtL3NyYy9oYXNoZXMvaWRlbnRpdHkuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL211bHRpZm9ybWF0c0A5LjkuMC9ub2RlX21vZHVsZXMvbXVsdGlmb3JtYXRzL2VzbS9zcmMvY29kZWNzL2pzb24uanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL211bHRpZm9ybWF0c0A5LjkuMC9ub2RlX21vZHVsZXMvbXVsdGlmb3JtYXRzL2VzbS9zcmMvYmFzaWNzLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS91aW50OGFycmF5c0AzLjEuMS9ub2RlX21vZHVsZXMvdWludDhhcnJheXMvZXNtL3NyYy91dGlsL2FzLXVpbnQ4YXJyYXkuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3VpbnQ4YXJyYXlzQDMuMS4xL25vZGVfbW9kdWxlcy91aW50OGFycmF5cy9lc20vc3JjL2FsbG9jLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS91aW50OGFycmF5c0AzLjEuMS9ub2RlX21vZHVsZXMvdWludDhhcnJheXMvZXNtL3NyYy91dGlsL2Jhc2VzLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS91aW50OGFycmF5c0AzLjEuMS9ub2RlX21vZHVsZXMvdWludDhhcnJheXMvZXNtL3NyYy9mcm9tLXN0cmluZy5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vaXBmcy11bml4ZnMtaW1wb3J0ZXJAOS4wLjEwL25vZGVfbW9kdWxlcy9pcGZzLXVuaXhmcy1pbXBvcnRlci9lc20vc3JjL2Rpci5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vaXBmcy11bml4ZnMtaW1wb3J0ZXJAOS4wLjEwL25vZGVfbW9kdWxlcy9pcGZzLXVuaXhmcy1pbXBvcnRlci9lc20vc3JjL2Rpci1mbGF0LmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9pcGZzLXVuaXhmcy1pbXBvcnRlckA5LjAuMTAvbm9kZV9tb2R1bGVzL2lwZnMtdW5peGZzLWltcG9ydGVyL2VzbS9zcmMvZGlyLXNoYXJkZWQuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2lwZnMtdW5peGZzLWltcG9ydGVyQDkuMC4xMC9ub2RlX21vZHVsZXMvaXBmcy11bml4ZnMtaW1wb3J0ZXIvZXNtL3NyYy9mbGF0LXRvLXNoYXJkLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9pcGZzLXVuaXhmcy1pbXBvcnRlckA5LjAuMTAvbm9kZV9tb2R1bGVzL2lwZnMtdW5peGZzLWltcG9ydGVyL2VzbS9zcmMvdXRpbHMvdG8tcGF0aC1jb21wb25lbnRzLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9pcGZzLXVuaXhmcy1pbXBvcnRlckA5LjAuMTAvbm9kZV9tb2R1bGVzL2lwZnMtdW5peGZzLWltcG9ydGVyL2VzbS9zcmMvdHJlZS1idWlsZGVyLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9pcGZzLWNvcmUtdXRpbHNAMC4xMi4yX25vZGUtZmV0Y2hAMy4zLjIvbm9kZV9tb2R1bGVzL2lwZnMtY29yZS11dGlscy9lc20vc3JjL2ZpbGVzL25vcm1hbGlzZS1jb250ZW50LmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9pcGZzLWNvcmUtdXRpbHNAMC4xMi4yX25vZGUtZmV0Y2hAMy4zLjIvbm9kZV9tb2R1bGVzL2lwZnMtY29yZS11dGlscy9lc20vc3JjL2ZpbGVzL3V0aWxzLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9pcGZzLWNvcmUtdXRpbHNAMC4xMi4yX25vZGUtZmV0Y2hAMy4zLjIvbm9kZV9tb2R1bGVzL2lwZnMtY29yZS11dGlscy9lc20vc3JjL2ZpbGVzL25vcm1hbGlzZS1jYW5kaWRhdGUtc2luZ2xlLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9pcGZzLWNvcmUtdXRpbHNAMC4xMi4yX25vZGUtZmV0Y2hAMy4zLjIvbm9kZV9tb2R1bGVzL2lwZnMtY29yZS11dGlscy9lc20vc3JjL2ZpbGVzL25vcm1hbGlzZS1pbnB1dC1zaW5nbGUuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2lwZnMtY29yZS11dGlsc0AwLjEyLjJfbm9kZS1mZXRjaEAzLjMuMi9ub2RlX21vZHVsZXMvaXBmcy1jb3JlLXV0aWxzL2VzbS9zcmMvZmlsZXMvbm9ybWFsaXNlLWNhbmRpZGF0ZS1tdWx0aXBsZS5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vaXBmcy1jb3JlLXV0aWxzQDAuMTIuMl9ub2RlLWZldGNoQDMuMy4yL25vZGVfbW9kdWxlcy9pcGZzLWNvcmUtdXRpbHMvZXNtL3NyYy9maWxlcy9ub3JtYWxpc2UtaW5wdXQtbXVsdGlwbGUuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2lwZnMtY2FyQDAuNi4yX25vZGUtZmV0Y2hAMy4zLjIvbm9kZV9tb2R1bGVzL2lwZnMtY2FyL2Rpc3QvZXNtL3BhY2svdXRpbHMvbm9ybWFsaXNlLWlucHV0LmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9ibG9ja3N0b3JlLWNvcmVAMS4wLjUvbm9kZV9tb2R1bGVzL2Jsb2Nrc3RvcmUtY29yZS9lc20vc3JjL2Vycm9ycy5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vYmxvY2tzdG9yZS1jb3JlQDEuMC41L25vZGVfbW9kdWxlcy9ibG9ja3N0b3JlLWNvcmUvZXNtL3NyYy9iYXNlLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9ibG9ja3N0b3JlLWNvcmVAMS4wLjUvbm9kZV9tb2R1bGVzL2Jsb2Nrc3RvcmUtY29yZS9lc20vc3JjL2luZGV4LmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9pcGZzLWNhckAwLjYuMl9ub2RlLWZldGNoQDMuMy4yL25vZGVfbW9kdWxlcy9pcGZzLWNhci9kaXN0L2VzbS9ibG9ja3N0b3JlL21lbW9yeS5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vaXBmcy1jYXJAMC42LjJfbm9kZS1mZXRjaEAzLjMuMi9ub2RlX21vZHVsZXMvaXBmcy1jYXIvZGlzdC9lc20vcGFjay9jb25zdGFudHMuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0B3ZWItc3RkK2ZldGNoQDQuMi4xL25vZGVfbW9kdWxlcy9Ad2ViLXN0ZC9mZXRjaC9zcmMvZmV0Y2guanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL21ybWltZUAxLjAuMS9ub2RlX21vZHVsZXMvbXJtaW1lL2luZGV4Lm1qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHdlYi1zdGQrZmV0Y2hANC4yLjEvbm9kZV9tb2R1bGVzL0B3ZWItc3RkL2ZldGNoL3NyYy9ib2R5LmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS93ZWItZW5jb2RpbmdAMS4xLjUvbm9kZV9tb2R1bGVzL3dlYi1lbmNvZGluZy9zcmMvbGliLm1qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHdlYi1zdGQrc3RyZWFtQDEuMC4wL25vZGVfbW9kdWxlcy9Ad2ViLXN0ZC9zdHJlYW0vc3JjL2xpYi5ub2RlLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ad2ViLXN0ZCtibG9iQDMuMC41L25vZGVfbW9kdWxlcy9Ad2ViLXN0ZC9ibG9iL3NyYy9ibG9iLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ad2ViLXN0ZCtibG9iQDMuMC41L25vZGVfbW9kdWxlcy9Ad2ViLXN0ZC9ibG9iL3NyYy9saWIubm9kZS5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHdlYi1zdGQrZmlsZUAzLjAuMy9ub2RlX21vZHVsZXMvQHdlYi1zdGQvZmlsZS9zcmMvZmlsZS5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHdlYi1zdGQrZmlsZUAzLjAuMy9ub2RlX21vZHVsZXMvQHdlYi1zdGQvZmlsZS9zcmMvbGliLm5vZGUuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0B3ZWItc3RkK2Zvcm0tZGF0YUAzLjEuMC9ub2RlX21vZHVsZXMvQHdlYi1zdGQvZm9ybS1kYXRhL3NyYy9mb3JtLWRhdGEuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0B3ZWItc3RkK2Zvcm0tZGF0YUAzLjEuMC9ub2RlX21vZHVsZXMvQHdlYi1zdGQvZm9ybS1kYXRhL3NyYy9saWIubm9kZS5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHdlYi1zdGQrZmV0Y2hANC4yLjEvbm9kZV9tb2R1bGVzL0B3ZWItc3RkL2ZldGNoL3NyYy9lcnJvcnMvYmFzZS5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHdlYi1zdGQrZmV0Y2hANC4yLjEvbm9kZV9tb2R1bGVzL0B3ZWItc3RkL2ZldGNoL3NyYy9lcnJvcnMvZmV0Y2gtZXJyb3IuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0B3ZWItc3RkK2ZldGNoQDQuMi4xL25vZGVfbW9kdWxlcy9Ad2ViLXN0ZC9mZXRjaC9zcmMvdXRpbHMvZm9ybS1kYXRhLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ad2ViMy1zdG9yYWdlK211bHRpcGFydC1wYXJzZXJAMS4wLjAvbm9kZV9tb2R1bGVzL0B3ZWIzLXN0b3JhZ2UvbXVsdGlwYXJ0LXBhcnNlci9lc20vc3JjL3V0aWxzLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ad2ViMy1zdG9yYWdlK211bHRpcGFydC1wYXJzZXJAMS4wLjAvbm9kZV9tb2R1bGVzL0B3ZWIzLXN0b3JhZ2UvbXVsdGlwYXJ0LXBhcnNlci9lc20vc3JjL3NlYXJjaC5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHdlYjMtc3RvcmFnZSttdWx0aXBhcnQtcGFyc2VyQDEuMC4wL25vZGVfbW9kdWxlcy9Ad2ViMy1zdG9yYWdlL211bHRpcGFydC1wYXJzZXIvZXNtL3NyYy9pbmRleC5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHdlYi1zdGQrZmV0Y2hANC4yLjEvbm9kZV9tb2R1bGVzL0B3ZWItc3RkL2ZldGNoL3NyYy91dGlscy9pcy5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHdlYi1zdGQrZmV0Y2hANC4yLjEvbm9kZV9tb2R1bGVzL0B3ZWItc3RkL2ZldGNoL3NyYy91dGlscy91dGY4LmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ad2ViLXN0ZCtmZXRjaEA0LjIuMS9ub2RlX21vZHVsZXMvQHdlYi1zdGQvZmV0Y2gvc3JjL2hlYWRlcnMuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0B3ZWItc3RkK2ZldGNoQDQuMi4xL25vZGVfbW9kdWxlcy9Ad2ViLXN0ZC9mZXRjaC9zcmMvdXRpbHMvaXMtcmVkaXJlY3QuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0B3ZWItc3RkK2ZldGNoQDQuMi4xL25vZGVfbW9kdWxlcy9Ad2ViLXN0ZC9mZXRjaC9zcmMvcmVzcG9uc2UuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0B3ZWItc3RkK2ZldGNoQDQuMi4xL25vZGVfbW9kdWxlcy9Ad2ViLXN0ZC9mZXRjaC9zcmMvcmVxdWVzdC5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHdlYi1zdGQrZmV0Y2hANC4yLjEvbm9kZV9tb2R1bGVzL0B3ZWItc3RkL2ZldGNoL3NyYy91dGlscy9nZXQtc2VhcmNoLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ad2ViLXN0ZCtmZXRjaEA0LjIuMS9ub2RlX21vZHVsZXMvQHdlYi1zdGQvZmV0Y2gvc3JjL2Vycm9ycy9hYm9ydC1lcnJvci5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHdlYi1zdGQrZmV0Y2hANC4yLjEvbm9kZV9tb2R1bGVzL0B3ZWItc3RkL2ZldGNoL3NyYy9saWIubm9kZS5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vaXBmcy1jYXJAMC42LjJfbm9kZS1mZXRjaEAzLjMuMi9ub2RlX21vZHVsZXMvaXBmcy1jYXIvZGlzdC9lc20vYmxvY2tzdG9yZS9mcy5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbmZ0LnN0b3JhZ2VANy4xLjFfbm9kZS1mZXRjaEAzLjMuMi9ub2RlX21vZHVsZXMvbmZ0LnN0b3JhZ2Uvc3JjL2dhdGV3YXkuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL25mdC5zdG9yYWdlQDcuMS4xX25vZGUtZmV0Y2hAMy4zLjIvbm9kZV9tb2R1bGVzL25mdC5zdG9yYWdlL3NyYy9icy1jYXItcmVhZGVyLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9uZnQuc3RvcmFnZUA3LjEuMV9ub2RlLWZldGNoQDMuMy4yL25vZGVfbW9kdWxlcy9uZnQuc3RvcmFnZS9zcmMvdG9rZW4uanMiLCAiLi4vc3JjL21ldGFwbGV4L21pbnQudHMiLCAiLi4vc3JjL21ldGFwbGV4L2ZlZS1wYXllci1wYXJ0aWFsLXNpZ24tdHJhbnNmZXIudHMiLCAiLi4vc3JjL21ldGFwbGV4L3RoYXcudHMiLCAiLi4vc3JjL21ldGFwbGV4L3RyYW5zZmVyLnRzIiwgIi4uL3NyYy9tZXRhcGxleC9pbmRleC50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiZnVuY3Rpb24gUmV0cnlPcGVyYXRpb24odGltZW91dHMsIG9wdGlvbnMpIHtcbiAgLy8gQ29tcGF0aWJpbGl0eSBmb3IgdGhlIG9sZCAodGltZW91dHMsIHJldHJ5Rm9yZXZlcikgc2lnbmF0dXJlXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgb3B0aW9ucyA9IHsgZm9yZXZlcjogb3B0aW9ucyB9O1xuICB9XG5cbiAgdGhpcy5fb3JpZ2luYWxUaW1lb3V0cyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodGltZW91dHMpKTtcbiAgdGhpcy5fdGltZW91dHMgPSB0aW1lb3V0cztcbiAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHRoaXMuX21heFJldHJ5VGltZSA9IG9wdGlvbnMgJiYgb3B0aW9ucy5tYXhSZXRyeVRpbWUgfHwgSW5maW5pdHk7XG4gIHRoaXMuX2ZuID0gbnVsbDtcbiAgdGhpcy5fZXJyb3JzID0gW107XG4gIHRoaXMuX2F0dGVtcHRzID0gMTtcbiAgdGhpcy5fb3BlcmF0aW9uVGltZW91dCA9IG51bGw7XG4gIHRoaXMuX29wZXJhdGlvblRpbWVvdXRDYiA9IG51bGw7XG4gIHRoaXMuX3RpbWVvdXQgPSBudWxsO1xuICB0aGlzLl9vcGVyYXRpb25TdGFydCA9IG51bGw7XG4gIHRoaXMuX3RpbWVyID0gbnVsbDtcblxuICBpZiAodGhpcy5fb3B0aW9ucy5mb3JldmVyKSB7XG4gICAgdGhpcy5fY2FjaGVkVGltZW91dHMgPSB0aGlzLl90aW1lb3V0cy5zbGljZSgwKTtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBSZXRyeU9wZXJhdGlvbjtcblxuUmV0cnlPcGVyYXRpb24ucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2F0dGVtcHRzID0gMTtcbiAgdGhpcy5fdGltZW91dHMgPSB0aGlzLl9vcmlnaW5hbFRpbWVvdXRzLnNsaWNlKDApO1xufVxuXG5SZXRyeU9wZXJhdGlvbi5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5fdGltZW91dCkge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lb3V0KTtcbiAgfVxuICBpZiAodGhpcy5fdGltZXIpIHtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZXIpO1xuICB9XG5cbiAgdGhpcy5fdGltZW91dHMgICAgICAgPSBbXTtcbiAgdGhpcy5fY2FjaGVkVGltZW91dHMgPSBudWxsO1xufTtcblxuUmV0cnlPcGVyYXRpb24ucHJvdG90eXBlLnJldHJ5ID0gZnVuY3Rpb24oZXJyKSB7XG4gIGlmICh0aGlzLl90aW1lb3V0KSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXQpO1xuICB9XG5cbiAgaWYgKCFlcnIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGN1cnJlbnRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gIGlmIChlcnIgJiYgY3VycmVudFRpbWUgLSB0aGlzLl9vcGVyYXRpb25TdGFydCA+PSB0aGlzLl9tYXhSZXRyeVRpbWUpIHtcbiAgICB0aGlzLl9lcnJvcnMucHVzaChlcnIpO1xuICAgIHRoaXMuX2Vycm9ycy51bnNoaWZ0KG5ldyBFcnJvcignUmV0cnlPcGVyYXRpb24gdGltZW91dCBvY2N1cnJlZCcpKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB0aGlzLl9lcnJvcnMucHVzaChlcnIpO1xuXG4gIHZhciB0aW1lb3V0ID0gdGhpcy5fdGltZW91dHMuc2hpZnQoKTtcbiAgaWYgKHRpbWVvdXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0aGlzLl9jYWNoZWRUaW1lb3V0cykge1xuICAgICAgLy8gcmV0cnkgZm9yZXZlciwgb25seSBrZWVwIGxhc3QgZXJyb3JcbiAgICAgIHRoaXMuX2Vycm9ycy5zcGxpY2UoMCwgdGhpcy5fZXJyb3JzLmxlbmd0aCAtIDEpO1xuICAgICAgdGltZW91dCA9IHRoaXMuX2NhY2hlZFRpbWVvdXRzLnNsaWNlKC0xKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5fdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgIHNlbGYuX2F0dGVtcHRzKys7XG5cbiAgICBpZiAoc2VsZi5fb3BlcmF0aW9uVGltZW91dENiKSB7XG4gICAgICBzZWxmLl90aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgc2VsZi5fb3BlcmF0aW9uVGltZW91dENiKHNlbGYuX2F0dGVtcHRzKTtcbiAgICAgIH0sIHNlbGYuX29wZXJhdGlvblRpbWVvdXQpO1xuXG4gICAgICBpZiAoc2VsZi5fb3B0aW9ucy51bnJlZikge1xuICAgICAgICAgIHNlbGYuX3RpbWVvdXQudW5yZWYoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxmLl9mbihzZWxmLl9hdHRlbXB0cyk7XG4gIH0sIHRpbWVvdXQpO1xuXG4gIGlmICh0aGlzLl9vcHRpb25zLnVucmVmKSB7XG4gICAgICB0aGlzLl90aW1lci51bnJlZigpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5SZXRyeU9wZXJhdGlvbi5wcm90b3R5cGUuYXR0ZW1wdCA9IGZ1bmN0aW9uKGZuLCB0aW1lb3V0T3BzKSB7XG4gIHRoaXMuX2ZuID0gZm47XG5cbiAgaWYgKHRpbWVvdXRPcHMpIHtcbiAgICBpZiAodGltZW91dE9wcy50aW1lb3V0KSB7XG4gICAgICB0aGlzLl9vcGVyYXRpb25UaW1lb3V0ID0gdGltZW91dE9wcy50aW1lb3V0O1xuICAgIH1cbiAgICBpZiAodGltZW91dE9wcy5jYikge1xuICAgICAgdGhpcy5fb3BlcmF0aW9uVGltZW91dENiID0gdGltZW91dE9wcy5jYjtcbiAgICB9XG4gIH1cblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGlmICh0aGlzLl9vcGVyYXRpb25UaW1lb3V0Q2IpIHtcbiAgICB0aGlzLl90aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYuX29wZXJhdGlvblRpbWVvdXRDYigpO1xuICAgIH0sIHNlbGYuX29wZXJhdGlvblRpbWVvdXQpO1xuICB9XG5cbiAgdGhpcy5fb3BlcmF0aW9uU3RhcnQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblxuICB0aGlzLl9mbih0aGlzLl9hdHRlbXB0cyk7XG59O1xuXG5SZXRyeU9wZXJhdGlvbi5wcm90b3R5cGUudHJ5ID0gZnVuY3Rpb24oZm4pIHtcbiAgY29uc29sZS5sb2coJ1VzaW5nIFJldHJ5T3BlcmF0aW9uLnRyeSgpIGlzIGRlcHJlY2F0ZWQnKTtcbiAgdGhpcy5hdHRlbXB0KGZuKTtcbn07XG5cblJldHJ5T3BlcmF0aW9uLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uKGZuKSB7XG4gIGNvbnNvbGUubG9nKCdVc2luZyBSZXRyeU9wZXJhdGlvbi5zdGFydCgpIGlzIGRlcHJlY2F0ZWQnKTtcbiAgdGhpcy5hdHRlbXB0KGZuKTtcbn07XG5cblJldHJ5T3BlcmF0aW9uLnByb3RvdHlwZS5zdGFydCA9IFJldHJ5T3BlcmF0aW9uLnByb3RvdHlwZS50cnk7XG5cblJldHJ5T3BlcmF0aW9uLnByb3RvdHlwZS5lcnJvcnMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2Vycm9ycztcbn07XG5cblJldHJ5T3BlcmF0aW9uLnByb3RvdHlwZS5hdHRlbXB0cyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fYXR0ZW1wdHM7XG59O1xuXG5SZXRyeU9wZXJhdGlvbi5wcm90b3R5cGUubWFpbkVycm9yID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLl9lcnJvcnMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgY291bnRzID0ge307XG4gIHZhciBtYWluRXJyb3IgPSBudWxsO1xuICB2YXIgbWFpbkVycm9yQ291bnQgPSAwO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fZXJyb3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVycm9yID0gdGhpcy5fZXJyb3JzW2ldO1xuICAgIHZhciBtZXNzYWdlID0gZXJyb3IubWVzc2FnZTtcbiAgICB2YXIgY291bnQgPSAoY291bnRzW21lc3NhZ2VdIHx8IDApICsgMTtcblxuICAgIGNvdW50c1ttZXNzYWdlXSA9IGNvdW50O1xuXG4gICAgaWYgKGNvdW50ID49IG1haW5FcnJvckNvdW50KSB7XG4gICAgICBtYWluRXJyb3IgPSBlcnJvcjtcbiAgICAgIG1haW5FcnJvckNvdW50ID0gY291bnQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1haW5FcnJvcjtcbn07XG4iLCAidmFyIFJldHJ5T3BlcmF0aW9uID0gcmVxdWlyZSgnLi9yZXRyeV9vcGVyYXRpb24nKTtcblxuZXhwb3J0cy5vcGVyYXRpb24gPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIHZhciB0aW1lb3V0cyA9IGV4cG9ydHMudGltZW91dHMob3B0aW9ucyk7XG4gIHJldHVybiBuZXcgUmV0cnlPcGVyYXRpb24odGltZW91dHMsIHtcbiAgICAgIGZvcmV2ZXI6IG9wdGlvbnMgJiYgKG9wdGlvbnMuZm9yZXZlciB8fCBvcHRpb25zLnJldHJpZXMgPT09IEluZmluaXR5KSxcbiAgICAgIHVucmVmOiBvcHRpb25zICYmIG9wdGlvbnMudW5yZWYsXG4gICAgICBtYXhSZXRyeVRpbWU6IG9wdGlvbnMgJiYgb3B0aW9ucy5tYXhSZXRyeVRpbWVcbiAgfSk7XG59O1xuXG5leHBvcnRzLnRpbWVvdXRzID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgcmV0dXJuIFtdLmNvbmNhdChvcHRpb25zKTtcbiAgfVxuXG4gIHZhciBvcHRzID0ge1xuICAgIHJldHJpZXM6IDEwLFxuICAgIGZhY3RvcjogMixcbiAgICBtaW5UaW1lb3V0OiAxICogMTAwMCxcbiAgICBtYXhUaW1lb3V0OiBJbmZpbml0eSxcbiAgICByYW5kb21pemU6IGZhbHNlXG4gIH07XG4gIGZvciAodmFyIGtleSBpbiBvcHRpb25zKSB7XG4gICAgb3B0c1trZXldID0gb3B0aW9uc1trZXldO1xuICB9XG5cbiAgaWYgKG9wdHMubWluVGltZW91dCA+IG9wdHMubWF4VGltZW91dCkge1xuICAgIHRocm93IG5ldyBFcnJvcignbWluVGltZW91dCBpcyBncmVhdGVyIHRoYW4gbWF4VGltZW91dCcpO1xuICB9XG5cbiAgdmFyIHRpbWVvdXRzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgb3B0cy5yZXRyaWVzOyBpKyspIHtcbiAgICB0aW1lb3V0cy5wdXNoKHRoaXMuY3JlYXRlVGltZW91dChpLCBvcHRzKSk7XG4gIH1cblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmZvcmV2ZXIgJiYgIXRpbWVvdXRzLmxlbmd0aCkge1xuICAgIHRpbWVvdXRzLnB1c2godGhpcy5jcmVhdGVUaW1lb3V0KGksIG9wdHMpKTtcbiAgfVxuXG4gIC8vIHNvcnQgdGhlIGFycmF5IG51bWVyaWNhbGx5IGFzY2VuZGluZ1xuICB0aW1lb3V0cy5zb3J0KGZ1bmN0aW9uKGEsYikge1xuICAgIHJldHVybiBhIC0gYjtcbiAgfSk7XG5cbiAgcmV0dXJuIHRpbWVvdXRzO1xufTtcblxuZXhwb3J0cy5jcmVhdGVUaW1lb3V0ID0gZnVuY3Rpb24oYXR0ZW1wdCwgb3B0cykge1xuICB2YXIgcmFuZG9tID0gKG9wdHMucmFuZG9taXplKVxuICAgID8gKE1hdGgucmFuZG9tKCkgKyAxKVxuICAgIDogMTtcblxuICB2YXIgdGltZW91dCA9IE1hdGgucm91bmQocmFuZG9tICogTWF0aC5tYXgob3B0cy5taW5UaW1lb3V0LCAxKSAqIE1hdGgucG93KG9wdHMuZmFjdG9yLCBhdHRlbXB0KSk7XG4gIHRpbWVvdXQgPSBNYXRoLm1pbih0aW1lb3V0LCBvcHRzLm1heFRpbWVvdXQpO1xuXG4gIHJldHVybiB0aW1lb3V0O1xufTtcblxuZXhwb3J0cy53cmFwID0gZnVuY3Rpb24ob2JqLCBvcHRpb25zLCBtZXRob2RzKSB7XG4gIGlmIChvcHRpb25zIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICBtZXRob2RzID0gb3B0aW9ucztcbiAgICBvcHRpb25zID0gbnVsbDtcbiAgfVxuXG4gIGlmICghbWV0aG9kcykge1xuICAgIG1ldGhvZHMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAodHlwZW9mIG9ialtrZXldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG1ldGhvZHMucHVzaChrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbWV0aG9kcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBtZXRob2QgICA9IG1ldGhvZHNbaV07XG4gICAgdmFyIG9yaWdpbmFsID0gb2JqW21ldGhvZF07XG5cbiAgICBvYmpbbWV0aG9kXSA9IGZ1bmN0aW9uIHJldHJ5V3JhcHBlcihvcmlnaW5hbCkge1xuICAgICAgdmFyIG9wICAgICAgID0gZXhwb3J0cy5vcGVyYXRpb24ob3B0aW9ucyk7XG4gICAgICB2YXIgYXJncyAgICAgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgdmFyIGNhbGxiYWNrID0gYXJncy5wb3AoKTtcblxuICAgICAgYXJncy5wdXNoKGZ1bmN0aW9uKGVycikge1xuICAgICAgICBpZiAob3AucmV0cnkoZXJyKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgYXJndW1lbnRzWzBdID0gb3AubWFpbkVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2FsbGJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuXG4gICAgICBvcC5hdHRlbXB0KGZ1bmN0aW9uKCkge1xuICAgICAgICBvcmlnaW5hbC5hcHBseShvYmosIGFyZ3MpO1xuICAgICAgfSk7XG4gICAgfS5iaW5kKG9iaiwgb3JpZ2luYWwpO1xuICAgIG9ialttZXRob2RdLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9XG59O1xuIiwgIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvcmV0cnknKTsiLCAiJ3VzZSBzdHJpY3QnO1xuY29uc3QgcmV0cnkgPSByZXF1aXJlKCdyZXRyeScpO1xuXG5jb25zdCBuZXR3b3JrRXJyb3JNc2dzID0gW1xuXHQnRmFpbGVkIHRvIGZldGNoJywgLy8gQ2hyb21lXG5cdCdOZXR3b3JrRXJyb3Igd2hlbiBhdHRlbXB0aW5nIHRvIGZldGNoIHJlc291cmNlLicsIC8vIEZpcmVmb3hcblx0J1RoZSBJbnRlcm5ldCBjb25uZWN0aW9uIGFwcGVhcnMgdG8gYmUgb2ZmbGluZS4nLCAvLyBTYWZhcmlcblx0J05ldHdvcmsgcmVxdWVzdCBmYWlsZWQnIC8vIGBjcm9zcy1mZXRjaGBcbl07XG5cbmNsYXNzIEFib3J0RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG5cdGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcblx0XHRzdXBlcigpO1xuXG5cdFx0aWYgKG1lc3NhZ2UgaW5zdGFuY2VvZiBFcnJvcikge1xuXHRcdFx0dGhpcy5vcmlnaW5hbEVycm9yID0gbWVzc2FnZTtcblx0XHRcdCh7bWVzc2FnZX0gPSBtZXNzYWdlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5vcmlnaW5hbEVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuXHRcdFx0dGhpcy5vcmlnaW5hbEVycm9yLnN0YWNrID0gdGhpcy5zdGFjaztcblx0XHR9XG5cblx0XHR0aGlzLm5hbWUgPSAnQWJvcnRFcnJvcic7XG5cdFx0dGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcblx0fVxufVxuXG5jb25zdCBkZWNvcmF0ZUVycm9yV2l0aENvdW50cyA9IChlcnJvciwgYXR0ZW1wdE51bWJlciwgb3B0aW9ucykgPT4ge1xuXHQvLyBNaW51cyAxIGZyb20gYXR0ZW1wdE51bWJlciBiZWNhdXNlIHRoZSBmaXJzdCBhdHRlbXB0IGRvZXMgbm90IGNvdW50IGFzIGEgcmV0cnlcblx0Y29uc3QgcmV0cmllc0xlZnQgPSBvcHRpb25zLnJldHJpZXMgLSAoYXR0ZW1wdE51bWJlciAtIDEpO1xuXG5cdGVycm9yLmF0dGVtcHROdW1iZXIgPSBhdHRlbXB0TnVtYmVyO1xuXHRlcnJvci5yZXRyaWVzTGVmdCA9IHJldHJpZXNMZWZ0O1xuXHRyZXR1cm4gZXJyb3I7XG59O1xuXG5jb25zdCBpc05ldHdvcmtFcnJvciA9IGVycm9yTWVzc2FnZSA9PiBuZXR3b3JrRXJyb3JNc2dzLmluY2x1ZGVzKGVycm9yTWVzc2FnZSk7XG5cbmNvbnN0IHBSZXRyeSA9IChpbnB1dCwgb3B0aW9ucykgPT4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXHRvcHRpb25zID0ge1xuXHRcdG9uRmFpbGVkQXR0ZW1wdDogKCkgPT4ge30sXG5cdFx0cmV0cmllczogMTAsXG5cdFx0Li4ub3B0aW9uc1xuXHR9O1xuXG5cdGNvbnN0IG9wZXJhdGlvbiA9IHJldHJ5Lm9wZXJhdGlvbihvcHRpb25zKTtcblxuXHRvcGVyYXRpb24uYXR0ZW1wdChhc3luYyBhdHRlbXB0TnVtYmVyID0+IHtcblx0XHR0cnkge1xuXHRcdFx0cmVzb2x2ZShhd2FpdCBpbnB1dChhdHRlbXB0TnVtYmVyKSk7XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGlmICghKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpKSB7XG5cdFx0XHRcdHJlamVjdChuZXcgVHlwZUVycm9yKGBOb24tZXJyb3Igd2FzIHRocm93bjogXCIke2Vycm9yfVwiLiBZb3Ugc2hvdWxkIG9ubHkgdGhyb3cgZXJyb3JzLmApKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoZXJyb3IgaW5zdGFuY2VvZiBBYm9ydEVycm9yKSB7XG5cdFx0XHRcdG9wZXJhdGlvbi5zdG9wKCk7XG5cdFx0XHRcdHJlamVjdChlcnJvci5vcmlnaW5hbEVycm9yKTtcblx0XHRcdH0gZWxzZSBpZiAoZXJyb3IgaW5zdGFuY2VvZiBUeXBlRXJyb3IgJiYgIWlzTmV0d29ya0Vycm9yKGVycm9yLm1lc3NhZ2UpKSB7XG5cdFx0XHRcdG9wZXJhdGlvbi5zdG9wKCk7XG5cdFx0XHRcdHJlamVjdChlcnJvcik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkZWNvcmF0ZUVycm9yV2l0aENvdW50cyhlcnJvciwgYXR0ZW1wdE51bWJlciwgb3B0aW9ucyk7XG5cblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRhd2FpdCBvcHRpb25zLm9uRmFpbGVkQXR0ZW1wdChlcnJvcik7XG5cdFx0XHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRcdFx0cmVqZWN0KGVycm9yKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIW9wZXJhdGlvbi5yZXRyeShlcnJvcikpIHtcblx0XHRcdFx0XHRyZWplY3Qob3BlcmF0aW9uLm1haW5FcnJvcigpKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBwUmV0cnk7XG4vLyBUT0RPOiByZW1vdmUgdGhpcyBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uXG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gcFJldHJ5O1xuXG5tb2R1bGUuZXhwb3J0cy5BYm9ydEVycm9yID0gQWJvcnRFcnJvcjtcbiIsICJtb2R1bGUuZXhwb3J0cyA9IGVuY29kZVxuXG52YXIgTVNCID0gMHg4MFxuICAsIFJFU1QgPSAweDdGXG4gICwgTVNCQUxMID0gflJFU1RcbiAgLCBJTlQgPSBNYXRoLnBvdygyLCAzMSlcblxuZnVuY3Rpb24gZW5jb2RlKG51bSwgb3V0LCBvZmZzZXQpIHtcbiAgaWYgKE51bWJlci5NQVhfU0FGRV9JTlRFR0VSICYmIG51bSA+IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSB7XG4gICAgZW5jb2RlLmJ5dGVzID0gMFxuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdDb3VsZCBub3QgZW5jb2RlIHZhcmludCcpXG4gIH1cbiAgb3V0ID0gb3V0IHx8IFtdXG4gIG9mZnNldCA9IG9mZnNldCB8fCAwXG4gIHZhciBvbGRPZmZzZXQgPSBvZmZzZXRcblxuICB3aGlsZShudW0gPj0gSU5UKSB7XG4gICAgb3V0W29mZnNldCsrXSA9IChudW0gJiAweEZGKSB8IE1TQlxuICAgIG51bSAvPSAxMjhcbiAgfVxuICB3aGlsZShudW0gJiBNU0JBTEwpIHtcbiAgICBvdXRbb2Zmc2V0KytdID0gKG51bSAmIDB4RkYpIHwgTVNCXG4gICAgbnVtID4+Pj0gN1xuICB9XG4gIG91dFtvZmZzZXRdID0gbnVtIHwgMFxuICBcbiAgZW5jb2RlLmJ5dGVzID0gb2Zmc2V0IC0gb2xkT2Zmc2V0ICsgMVxuICBcbiAgcmV0dXJuIG91dFxufVxuIiwgIm1vZHVsZS5leHBvcnRzID0gcmVhZFxuXG52YXIgTVNCID0gMHg4MFxuICAsIFJFU1QgPSAweDdGXG5cbmZ1bmN0aW9uIHJlYWQoYnVmLCBvZmZzZXQpIHtcbiAgdmFyIHJlcyAgICA9IDBcbiAgICAsIG9mZnNldCA9IG9mZnNldCB8fCAwXG4gICAgLCBzaGlmdCAgPSAwXG4gICAgLCBjb3VudGVyID0gb2Zmc2V0XG4gICAgLCBiXG4gICAgLCBsID0gYnVmLmxlbmd0aFxuXG4gIGRvIHtcbiAgICBpZiAoY291bnRlciA+PSBsIHx8IHNoaWZ0ID4gNDkpIHtcbiAgICAgIHJlYWQuYnl0ZXMgPSAwXG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQ291bGQgbm90IGRlY29kZSB2YXJpbnQnKVxuICAgIH1cbiAgICBiID0gYnVmW2NvdW50ZXIrK11cbiAgICByZXMgKz0gc2hpZnQgPCAyOFxuICAgICAgPyAoYiAmIFJFU1QpIDw8IHNoaWZ0XG4gICAgICA6IChiICYgUkVTVCkgKiBNYXRoLnBvdygyLCBzaGlmdClcbiAgICBzaGlmdCArPSA3XG4gIH0gd2hpbGUgKGIgPj0gTVNCKVxuXG4gIHJlYWQuYnl0ZXMgPSBjb3VudGVyIC0gb2Zmc2V0XG5cbiAgcmV0dXJuIHJlc1xufVxuIiwgIlxudmFyIE4xID0gTWF0aC5wb3coMiwgIDcpXG52YXIgTjIgPSBNYXRoLnBvdygyLCAxNClcbnZhciBOMyA9IE1hdGgucG93KDIsIDIxKVxudmFyIE40ID0gTWF0aC5wb3coMiwgMjgpXG52YXIgTjUgPSBNYXRoLnBvdygyLCAzNSlcbnZhciBONiA9IE1hdGgucG93KDIsIDQyKVxudmFyIE43ID0gTWF0aC5wb3coMiwgNDkpXG52YXIgTjggPSBNYXRoLnBvdygyLCA1NilcbnZhciBOOSA9IE1hdGgucG93KDIsIDYzKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICByZXR1cm4gKFxuICAgIHZhbHVlIDwgTjEgPyAxXG4gIDogdmFsdWUgPCBOMiA/IDJcbiAgOiB2YWx1ZSA8IE4zID8gM1xuICA6IHZhbHVlIDwgTjQgPyA0XG4gIDogdmFsdWUgPCBONSA/IDVcbiAgOiB2YWx1ZSA8IE42ID8gNlxuICA6IHZhbHVlIDwgTjcgPyA3XG4gIDogdmFsdWUgPCBOOCA/IDhcbiAgOiB2YWx1ZSA8IE45ID8gOVxuICA6ICAgICAgICAgICAgICAxMFxuICApXG59XG4iLCAibW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgZW5jb2RlOiByZXF1aXJlKCcuL2VuY29kZS5qcycpXG4gICwgZGVjb2RlOiByZXF1aXJlKCcuL2RlY29kZS5qcycpXG4gICwgZW5jb2RpbmdMZW5ndGg6IHJlcXVpcmUoJy4vbGVuZ3RoLmpzJylcbn1cbiIsICIndXNlIHN0cmljdCdcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBsYXN0IGl0ZW0gb2YgYW4gKGFzeW5jKSBpdGVyYWJsZSwgdW5sZXNzIGVtcHR5LCBpbiB3aGljaCBjYXNlXG4gKiByZXR1cm4gYHVuZGVmaW5lZGAuXG4gKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7QXN5bmNJdGVyYWJsZTxUPnxJdGVyYWJsZTxUPn0gc291cmNlXG4gKi9cbmNvbnN0IGxhc3QgPSBhc3luYyAoc291cmNlKSA9PiB7XG4gIGxldCByZXNcblxuICBmb3IgYXdhaXQgKGNvbnN0IGVudHJ5IG9mIHNvdXJjZSkge1xuICAgIHJlcyA9IGVudHJ5XG4gIH1cblxuICByZXR1cm4gcmVzXG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGFzdFxuIiwgImNvbnN0IHJhd1BpcGUgPSAoLi4uZm5zKSA9PiB7XG4gIGxldCByZXNcbiAgd2hpbGUgKGZucy5sZW5ndGgpIHtcbiAgICByZXMgPSBmbnMuc2hpZnQoKShyZXMpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5jb25zdCBpc0l0ZXJhYmxlID0gb2JqID0+IG9iaiAmJiAoXG4gIHR5cGVvZiBvYmpbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID09PSAnZnVuY3Rpb24nIHx8XG4gIHR5cGVvZiBvYmpbU3ltYm9sLml0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJyB8fFxuICB0eXBlb2Ygb2JqLm5leHQgPT09ICdmdW5jdGlvbicgLy8gUHJvYmFibHksIHJpZ2h0P1xuKVxuXG5jb25zdCBpc0R1cGxleCA9IG9iaiA9PiBvYmogJiYgdHlwZW9mIG9iai5zaW5rID09PSAnZnVuY3Rpb24nICYmIGlzSXRlcmFibGUob2JqLnNvdXJjZSlcblxuY29uc3QgZHVwbGV4UGlwZWxpbmVGbiA9IGR1cGxleCA9PiBzb3VyY2UgPT4ge1xuICBkdXBsZXguc2luayhzb3VyY2UpIC8vIFRPRE86IGVycm9yIG9uIHNpbmsgc2lkZSBpcyB1bmhhbmRsZWQgcmVqZWN0aW9uIC0gdGhpcyBpcyB0aGUgc2FtZSBhcyBwdWxsIHN0cmVhbXNcbiAgcmV0dXJuIGR1cGxleC5zb3VyY2Vcbn1cblxuY29uc3QgcGlwZSA9ICguLi5mbnMpID0+IHtcbiAgLy8gRHVwbGV4IGF0IHN0YXJ0OiB3cmFwIGluIGZ1bmN0aW9uIGFuZCByZXR1cm4gZHVwbGV4IHNvdXJjZVxuICBpZiAoaXNEdXBsZXgoZm5zWzBdKSkge1xuICAgIGNvbnN0IGR1cGxleCA9IGZuc1swXVxuICAgIGZuc1swXSA9ICgpID0+IGR1cGxleC5zb3VyY2VcbiAgLy8gSXRlcmFibGUgYXQgc3RhcnQ6IHdyYXAgaW4gZnVuY3Rpb25cbiAgfSBlbHNlIGlmIChpc0l0ZXJhYmxlKGZuc1swXSkpIHtcbiAgICBjb25zdCBzb3VyY2UgPSBmbnNbMF1cbiAgICBmbnNbMF0gPSAoKSA9PiBzb3VyY2VcbiAgfVxuXG4gIGlmIChmbnMubGVuZ3RoID4gMSkge1xuICAgIC8vIER1cGxleCBhdCBlbmQ6IHVzZSBkdXBsZXggc2lua1xuICAgIGlmIChpc0R1cGxleChmbnNbZm5zLmxlbmd0aCAtIDFdKSkge1xuICAgICAgZm5zW2Zucy5sZW5ndGggLSAxXSA9IGZuc1tmbnMubGVuZ3RoIC0gMV0uc2lua1xuICAgIH1cbiAgfVxuXG4gIGlmIChmbnMubGVuZ3RoID4gMikge1xuICAgIC8vIER1cGxleCBpbiB0aGUgbWlkZGxlLCBjb25zdW1lIHNvdXJjZSB3aXRoIGR1cGxleCBzaW5rIGFuZCByZXR1cm4gZHVwbGV4IHNvdXJjZVxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgZm5zLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgaWYgKGlzRHVwbGV4KGZuc1tpXSkpIHtcbiAgICAgICAgZm5zW2ldID0gZHVwbGV4UGlwZWxpbmVGbihmbnNbaV0pXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJhd1BpcGUoLi4uZm5zKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBpcGVcbm1vZHVsZS5leHBvcnRzLnBpcGUgPSBwaXBlXG5tb2R1bGUuZXhwb3J0cy5yYXdQaXBlID0gcmF3UGlwZVxubW9kdWxlLmV4cG9ydHMuaXNJdGVyYWJsZSA9IGlzSXRlcmFibGVcbm1vZHVsZS5leHBvcnRzLmlzRHVwbGV4ID0gaXNEdXBsZXhcbiIsICIndXNlIHN0cmljdCdcblxuLyoqXG4gKiBUYWtlcyBhbiAoYXN5bmMpIGl0ZXJhYmxlIHRoYXQgZW1pdHMgdGhpbmdzIGFuZCByZXR1cm5zIGFuIGFzeW5jIGl0ZXJhYmxlIHRoYXRcbiAqIGVtaXRzIHRob3NlIHRoaW5ncyBpbiBmaXhlZC1zaXplZCBiYXRjaGVzLlxuICpcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge0FzeW5jSXRlcmFibGU8VD58SXRlcmFibGU8VD59IHNvdXJjZVxuICogQHBhcmFtIHtudW1iZXJ9IFtzaXplPTFdXG4gKiBAcmV0dXJucyB7QXN5bmNJdGVyYWJsZTxUW10+fVxuICovXG5hc3luYyBmdW5jdGlvbiAqIGJhdGNoIChzb3VyY2UsIHNpemUgPSAxKSB7XG4gIC8qKiBAdHlwZSB7VFtdfSAqL1xuICBsZXQgdGhpbmdzID0gW11cblxuICBpZiAoc2l6ZSA8IDEpIHtcbiAgICBzaXplID0gMVxuICB9XG5cbiAgZm9yIGF3YWl0IChjb25zdCB0aGluZyBvZiBzb3VyY2UpIHtcbiAgICB0aGluZ3MucHVzaCh0aGluZylcblxuICAgIHdoaWxlICh0aGluZ3MubGVuZ3RoID49IHNpemUpIHtcbiAgICAgIHlpZWxkIHRoaW5ncy5zbGljZSgwLCBzaXplKVxuXG4gICAgICB0aGluZ3MgPSB0aGluZ3Muc2xpY2Uoc2l6ZSlcbiAgICB9XG4gIH1cblxuICB3aGlsZSAodGhpbmdzLmxlbmd0aCkge1xuICAgIHlpZWxkIHRoaW5ncy5zbGljZSgwLCBzaXplKVxuXG4gICAgdGhpbmdzID0gdGhpbmdzLnNsaWNlKHNpemUpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXRjaFxuIiwgIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBiYXRjaCA9IHJlcXVpcmUoJ2l0LWJhdGNoJylcblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHR5cGVkZWYge3tvazp0cnVlLCB2YWx1ZTpUfX0gU3VjY2Vzc1xuICovXG5cbi8qKlxuICogQHR5cGVkZWYge3tvazpmYWxzZSwgZXJyOkVycm9yfX0gRmFpbHVyZVxuICovXG5cbi8qKlxuICogVGFrZXMgYW4gKGFzeW5jKSBpdGVyYXRvciB0aGF0IGVtaXRzIHByb21pc2UtcmV0dXJuaW5nIGZ1bmN0aW9ucyxcbiAqIGludm9rZXMgdGhlbSBpbiBwYXJhbGxlbCBhbmQgZW1pdHMgdGhlIHJlc3VsdHMgYXMgdGhleSBiZWNvbWUgYXZhaWxhYmxlIGJ1dFxuICogaW4gdGhlIHNhbWUgb3JkZXIgYXMgdGhlIGlucHV0XG4gKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7QXN5bmNJdGVyYWJsZTwoKSA9PiBQcm9taXNlPFQ+PnxJdGVyYWJsZTwoKSA9PiBQcm9taXNlPFQ+Pn0gc291cmNlXG4gKiBAcGFyYW0ge251bWJlcn0gW3NpemU9MV1cbiAqIEByZXR1cm5zIHtBc3luY0l0ZXJhYmxlPFQ+fVxuICovXG5hc3luYyBmdW5jdGlvbiAqIHBhcmFsbGVsQmF0Y2ggKHNvdXJjZSwgc2l6ZSA9IDEpIHtcbiAgZm9yIGF3YWl0IChjb25zdCB0YXNrcyBvZiBiYXRjaChzb3VyY2UsIHNpemUpKSB7XG4gICAgLyoqIEB0eXBlIHtQcm9taXNlPFN1Y2Nlc3M8VD58RmFpbHVyZT5bXX0gKi9cbiAgICBjb25zdCB0aGluZ3MgPSB0YXNrcy5tYXAoXG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7KCkgPT4gUHJvbWlzZTxUPn0gcFxuICAgICAgICovXG4gICAgICBwID0+IHtcbiAgICAgICAgcmV0dXJuIHAoKS50aGVuKHZhbHVlID0+ICh7IG9rOiB0cnVlLCB2YWx1ZSB9KSwgZXJyID0+ICh7IG9rOiBmYWxzZSwgZXJyIH0pKVxuICAgICAgfSlcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGluZ3NbaV1cblxuICAgICAgaWYgKHJlc3VsdC5vaykge1xuICAgICAgICB5aWVsZCByZXN1bHQudmFsdWVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IHJlc3VsdC5lcnJcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwYXJhbGxlbEJhdGNoXG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHZhbHVlID0+IHtcblx0aWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgIT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0Y29uc3QgcHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKTtcblx0cmV0dXJuIHByb3RvdHlwZSA9PT0gbnVsbCB8fCBwcm90b3R5cGUgPT09IE9iamVjdC5wcm90b3R5cGU7XG59O1xuIiwgIid1c2Ugc3RyaWN0JztcbmNvbnN0IGlzT3B0aW9uT2JqZWN0ID0gcmVxdWlyZSgnaXMtcGxhaW4tb2JqJyk7XG5cbmNvbnN0IHtoYXNPd25Qcm9wZXJ0eX0gPSBPYmplY3QucHJvdG90eXBlO1xuY29uc3Qge3Byb3BlcnR5SXNFbnVtZXJhYmxlfSA9IE9iamVjdDtcbmNvbnN0IGRlZmluZVByb3BlcnR5ID0gKG9iamVjdCwgbmFtZSwgdmFsdWUpID0+IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIG5hbWUsIHtcblx0dmFsdWUsXG5cdHdyaXRhYmxlOiB0cnVlLFxuXHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRjb25maWd1cmFibGU6IHRydWVcbn0pO1xuXG5jb25zdCBnbG9iYWxUaGlzID0gdGhpcztcbmNvbnN0IGRlZmF1bHRNZXJnZU9wdGlvbnMgPSB7XG5cdGNvbmNhdEFycmF5czogZmFsc2UsXG5cdGlnbm9yZVVuZGVmaW5lZDogZmFsc2Vcbn07XG5cbmNvbnN0IGdldEVudW1lcmFibGVPd25Qcm9wZXJ0eUtleXMgPSB2YWx1ZSA9PiB7XG5cdGNvbnN0IGtleXMgPSBbXTtcblxuXHRmb3IgKGNvbnN0IGtleSBpbiB2YWx1ZSkge1xuXHRcdGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSB7XG5cdFx0XHRrZXlzLnB1c2goa2V5KTtcblx0XHR9XG5cdH1cblxuXHQvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAgKi9cblx0aWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcblx0XHRjb25zdCBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh2YWx1ZSk7XG5cblx0XHRmb3IgKGNvbnN0IHN5bWJvbCBvZiBzeW1ib2xzKSB7XG5cdFx0XHRpZiAocHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgc3ltYm9sKSkge1xuXHRcdFx0XHRrZXlzLnB1c2goc3ltYm9sKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4ga2V5cztcbn07XG5cbmZ1bmN0aW9uIGNsb25lKHZhbHVlKSB7XG5cdGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuXHRcdHJldHVybiBjbG9uZUFycmF5KHZhbHVlKTtcblx0fVxuXG5cdGlmIChpc09wdGlvbk9iamVjdCh2YWx1ZSkpIHtcblx0XHRyZXR1cm4gY2xvbmVPcHRpb25PYmplY3QodmFsdWUpO1xuXHR9XG5cblx0cmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBjbG9uZUFycmF5KGFycmF5KSB7XG5cdGNvbnN0IHJlc3VsdCA9IGFycmF5LnNsaWNlKDAsIDApO1xuXG5cdGdldEVudW1lcmFibGVPd25Qcm9wZXJ0eUtleXMoYXJyYXkpLmZvckVhY2goa2V5ID0+IHtcblx0XHRkZWZpbmVQcm9wZXJ0eShyZXN1bHQsIGtleSwgY2xvbmUoYXJyYXlba2V5XSkpO1xuXHR9KTtcblxuXHRyZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBjbG9uZU9wdGlvbk9iamVjdChvYmplY3QpIHtcblx0Y29uc3QgcmVzdWx0ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCkgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKG51bGwpIDoge307XG5cblx0Z2V0RW51bWVyYWJsZU93blByb3BlcnR5S2V5cyhvYmplY3QpLmZvckVhY2goa2V5ID0+IHtcblx0XHRkZWZpbmVQcm9wZXJ0eShyZXN1bHQsIGtleSwgY2xvbmUob2JqZWN0W2tleV0pKTtcblx0fSk7XG5cblx0cmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBAcGFyYW0geyp9IG1lcmdlZCBhbHJlYWR5IGNsb25lZFxuICogQHBhcmFtIHsqfSBzb3VyY2Ugc29tZXRoaW5nIHRvIG1lcmdlXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBrZXlzIGtleXMgdG8gbWVyZ2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgQ29uZmlnIE9iamVjdFxuICogQHJldHVybnMgeyp9IGNsb25lZCBPYmplY3RcbiAqL1xuY29uc3QgbWVyZ2VLZXlzID0gKG1lcmdlZCwgc291cmNlLCBrZXlzLCBjb25maWcpID0+IHtcblx0a2V5cy5mb3JFYWNoKGtleSA9PiB7XG5cdFx0aWYgKHR5cGVvZiBzb3VyY2Vba2V5XSA9PT0gJ3VuZGVmaW5lZCcgJiYgY29uZmlnLmlnbm9yZVVuZGVmaW5lZCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIERvIG5vdCByZWN1cnNlIGludG8gcHJvdG90eXBlIGNoYWluIG9mIG1lcmdlZFxuXHRcdGlmIChrZXkgaW4gbWVyZ2VkICYmIG1lcmdlZFtrZXldICE9PSBPYmplY3QuZ2V0UHJvdG90eXBlT2YobWVyZ2VkKSkge1xuXHRcdFx0ZGVmaW5lUHJvcGVydHkobWVyZ2VkLCBrZXksIG1lcmdlKG1lcmdlZFtrZXldLCBzb3VyY2Vba2V5XSwgY29uZmlnKSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRlZmluZVByb3BlcnR5KG1lcmdlZCwga2V5LCBjbG9uZShzb3VyY2Vba2V5XSkpO1xuXHRcdH1cblx0fSk7XG5cblx0cmV0dXJuIG1lcmdlZDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHsqfSBtZXJnZWQgYWxyZWFkeSBjbG9uZWRcbiAqIEBwYXJhbSB7Kn0gc291cmNlIHNvbWV0aGluZyB0byBtZXJnZVxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBDb25maWcgT2JqZWN0XG4gKiBAcmV0dXJucyB7Kn0gY2xvbmVkIE9iamVjdFxuICpcbiAqIHNlZSBbQXJyYXkucHJvdG90eXBlLmNvbmNhdCAoIC4uLmFyZ3VtZW50cyApXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtYXJyYXkucHJvdG90eXBlLmNvbmNhdClcbiAqL1xuY29uc3QgY29uY2F0QXJyYXlzID0gKG1lcmdlZCwgc291cmNlLCBjb25maWcpID0+IHtcblx0bGV0IHJlc3VsdCA9IG1lcmdlZC5zbGljZSgwLCAwKTtcblx0bGV0IHJlc3VsdEluZGV4ID0gMDtcblxuXHRbbWVyZ2VkLCBzb3VyY2VdLmZvckVhY2goYXJyYXkgPT4ge1xuXHRcdGNvbnN0IGluZGljZXMgPSBbXTtcblxuXHRcdC8vIGByZXN1bHQuY29uY2F0KGFycmF5KWAgd2l0aCBjbG9uaW5nXG5cdFx0Zm9yIChsZXQgayA9IDA7IGsgPCBhcnJheS5sZW5ndGg7IGsrKykge1xuXHRcdFx0aWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKGFycmF5LCBrKSkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0aW5kaWNlcy5wdXNoKFN0cmluZyhrKSk7XG5cblx0XHRcdGlmIChhcnJheSA9PT0gbWVyZ2VkKSB7XG5cdFx0XHRcdC8vIEFscmVhZHkgY2xvbmVkXG5cdFx0XHRcdGRlZmluZVByb3BlcnR5KHJlc3VsdCwgcmVzdWx0SW5kZXgrKywgYXJyYXlba10pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVmaW5lUHJvcGVydHkocmVzdWx0LCByZXN1bHRJbmRleCsrLCBjbG9uZShhcnJheVtrXSkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIE1lcmdlIG5vbi1pbmRleCBrZXlzXG5cdFx0cmVzdWx0ID0gbWVyZ2VLZXlzKHJlc3VsdCwgYXJyYXksIGdldEVudW1lcmFibGVPd25Qcm9wZXJ0eUtleXMoYXJyYXkpLmZpbHRlcihrZXkgPT4gIWluZGljZXMuaW5jbHVkZXMoa2V5KSksIGNvbmZpZyk7XG5cdH0pO1xuXG5cdHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7Kn0gbWVyZ2VkIGFscmVhZHkgY2xvbmVkXG4gKiBAcGFyYW0geyp9IHNvdXJjZSBzb21ldGhpbmcgdG8gbWVyZ2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgQ29uZmlnIE9iamVjdFxuICogQHJldHVybnMgeyp9IGNsb25lZCBPYmplY3RcbiAqL1xuZnVuY3Rpb24gbWVyZ2UobWVyZ2VkLCBzb3VyY2UsIGNvbmZpZykge1xuXHRpZiAoY29uZmlnLmNvbmNhdEFycmF5cyAmJiBBcnJheS5pc0FycmF5KG1lcmdlZCkgJiYgQXJyYXkuaXNBcnJheShzb3VyY2UpKSB7XG5cdFx0cmV0dXJuIGNvbmNhdEFycmF5cyhtZXJnZWQsIHNvdXJjZSwgY29uZmlnKTtcblx0fVxuXG5cdGlmICghaXNPcHRpb25PYmplY3Qoc291cmNlKSB8fCAhaXNPcHRpb25PYmplY3QobWVyZ2VkKSkge1xuXHRcdHJldHVybiBjbG9uZShzb3VyY2UpO1xuXHR9XG5cblx0cmV0dXJuIG1lcmdlS2V5cyhtZXJnZWQsIHNvdXJjZSwgZ2V0RW51bWVyYWJsZU93blByb3BlcnR5S2V5cyhzb3VyY2UpLCBjb25maWcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICguLi5vcHRpb25zKSB7XG5cdGNvbnN0IGNvbmZpZyA9IG1lcmdlKGNsb25lKGRlZmF1bHRNZXJnZU9wdGlvbnMpLCAodGhpcyAhPT0gZ2xvYmFsVGhpcyAmJiB0aGlzKSB8fCB7fSwgZGVmYXVsdE1lcmdlT3B0aW9ucyk7XG5cdGxldCBtZXJnZWQgPSB7Xzoge319O1xuXG5cdGZvciAoY29uc3Qgb3B0aW9uIG9mIG9wdGlvbnMpIHtcblx0XHRpZiAob3B0aW9uID09PSB1bmRlZmluZWQpIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGlmICghaXNPcHRpb25PYmplY3Qob3B0aW9uKSkge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignYCcgKyBvcHRpb24gKyAnYCBpcyBub3QgYW4gT3B0aW9uIE9iamVjdCcpO1xuXHRcdH1cblxuXHRcdG1lcmdlZCA9IG1lcmdlKG1lcmdlZCwge186IG9wdGlvbn0sIGNvbmZpZyk7XG5cdH1cblxuXHRyZXR1cm4gbWVyZ2VkLl87XG59O1xuIiwgIi8qIGpzaGludCAtVzA4NjogdHJ1ZSAqL1xuLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4vLyB8IG11cm11ckhhc2gzanMuanMgdjMuMC4xIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9waWQvbXVybXVySGFzaDNqc1xuLy8gfCBBIGphdmFzY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgTXVybXVySGFzaDMncyB4ODYgaGFzaGluZyBhbGdvcml0aG1zLiB8XG4vLyB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcbi8vIHwgQ29weXJpZ2h0IChjKSAyMDEyLTIwMTUgS2FyYW4gTHlvbnMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4vLyB8IGh0dHBzOi8vZ2l0aHViLmNvbS9rYXJhbmx5b25zL211cm11ckhhc2gzLmpzL2Jsb2IvYzE3NzhmNzU3OTJhYmVmN2JkZDc0YmM4NWQyZDRlMWEzZDI1Y2ZlOS9tdXJtdXJIYXNoMy5qcyB8XG4vLyB8IEZyZWVseSBkaXN0cmlidXRhYmxlIHVuZGVyIHRoZSBNSVQgbGljZW5zZS4gICAgICAgICAgICAgICAgICAgICAgICAgIHxcbi8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuXG47KGZ1bmN0aW9uIChyb290LCB1bmRlZmluZWQpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICAvLyBDcmVhdGUgYSBsb2NhbCBvYmplY3QgdGhhdCdsbCBiZSBleHBvcnRlZCBvciByZWZlcmVuY2VkIGdsb2JhbGx5LlxuICAgIHZhciBsaWJyYXJ5ID0ge1xuICAgICAgICAndmVyc2lvbic6ICczLjAuMCcsXG4gICAgICAgICd4ODYnOiB7fSxcbiAgICAgICAgJ3g2NCc6IHt9LFxuICAgICAgICAnaW5wdXRWYWxpZGF0aW9uJzogdHJ1ZVxuICAgIH07XG5cbiAgICAvLyBQUklWQVRFIEZVTkNUSU9OU1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBmdW5jdGlvbiBfdmFsaWRCeXRlcyhieXRlcykge1xuICAgICAgICAvLyBjaGVjayB0aGUgaW5wdXQgaXMgYW4gYXJyYXkgb3IgYSB0eXBlZCBhcnJheVxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYnl0ZXMpICYmICFBcnJheUJ1ZmZlci5pc1ZpZXcoYnl0ZXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjaGVjayBhbGwgYnl0ZXMgYXJlIGFjdHVhbGx5IGJ5dGVzXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihieXRlc1tpXSkgfHwgYnl0ZXNbaV0gPCAwIHx8IGJ5dGVzW2ldID4gMjU1KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF94ODZNdWx0aXBseShtLCBuKSB7XG4gICAgICAgIC8vXG4gICAgICAgIC8vIEdpdmVuIHR3byAzMmJpdCBpbnRzLCByZXR1cm5zIHRoZSB0d28gbXVsdGlwbGllZCB0b2dldGhlciBhcyBhXG4gICAgICAgIC8vIDMyYml0IGludC5cbiAgICAgICAgLy9cblxuICAgICAgICByZXR1cm4gKChtICYgMHhmZmZmKSAqIG4pICsgKCgoKG0gPj4+IDE2KSAqIG4pICYgMHhmZmZmKSA8PCAxNik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX3g4NlJvdGwobSwgbikge1xuICAgICAgICAvL1xuICAgICAgICAvLyBHaXZlbiBhIDMyYml0IGludCBhbmQgYW4gaW50IHJlcHJlc2VudGluZyBhIG51bWJlciBvZiBiaXQgcG9zaXRpb25zLFxuICAgICAgICAvLyByZXR1cm5zIHRoZSAzMmJpdCBpbnQgcm90YXRlZCBsZWZ0IGJ5IHRoYXQgbnVtYmVyIG9mIHBvc2l0aW9ucy5cbiAgICAgICAgLy9cblxuICAgICAgICByZXR1cm4gKG0gPDwgbikgfCAobSA+Pj4gKDMyIC0gbikpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF94ODZGbWl4KGgpIHtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gR2l2ZW4gYSBibG9jaywgcmV0dXJucyBtdXJtdXJIYXNoMydzIGZpbmFsIHg4NiBtaXggb2YgdGhhdCBibG9jay5cbiAgICAgICAgLy9cblxuICAgICAgICBoIF49IGggPj4+IDE2O1xuICAgICAgICBoID0gX3g4Nk11bHRpcGx5KGgsIDB4ODVlYmNhNmIpO1xuICAgICAgICBoIF49IGggPj4+IDEzO1xuICAgICAgICBoID0gX3g4Nk11bHRpcGx5KGgsIDB4YzJiMmFlMzUpO1xuICAgICAgICBoIF49IGggPj4+IDE2O1xuXG4gICAgICAgIHJldHVybiBoO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF94NjRBZGQobSwgbikge1xuICAgICAgICAvL1xuICAgICAgICAvLyBHaXZlbiB0d28gNjRiaXQgaW50cyAoYXMgYW4gYXJyYXkgb2YgdHdvIDMyYml0IGludHMpIHJldHVybnMgdGhlIHR3b1xuICAgICAgICAvLyBhZGRlZCB0b2dldGhlciBhcyBhIDY0Yml0IGludCAoYXMgYW4gYXJyYXkgb2YgdHdvIDMyYml0IGludHMpLlxuICAgICAgICAvL1xuXG4gICAgICAgIG0gPSBbbVswXSA+Pj4gMTYsIG1bMF0gJiAweGZmZmYsIG1bMV0gPj4+IDE2LCBtWzFdICYgMHhmZmZmXTtcbiAgICAgICAgbiA9IFtuWzBdID4+PiAxNiwgblswXSAmIDB4ZmZmZiwgblsxXSA+Pj4gMTYsIG5bMV0gJiAweGZmZmZdO1xuICAgICAgICB2YXIgbyA9IFswLCAwLCAwLCAwXTtcblxuICAgICAgICBvWzNdICs9IG1bM10gKyBuWzNdO1xuICAgICAgICBvWzJdICs9IG9bM10gPj4+IDE2O1xuICAgICAgICBvWzNdICY9IDB4ZmZmZjtcblxuICAgICAgICBvWzJdICs9IG1bMl0gKyBuWzJdO1xuICAgICAgICBvWzFdICs9IG9bMl0gPj4+IDE2O1xuICAgICAgICBvWzJdICY9IDB4ZmZmZjtcblxuICAgICAgICBvWzFdICs9IG1bMV0gKyBuWzFdO1xuICAgICAgICBvWzBdICs9IG9bMV0gPj4+IDE2O1xuICAgICAgICBvWzFdICY9IDB4ZmZmZjtcblxuICAgICAgICBvWzBdICs9IG1bMF0gKyBuWzBdO1xuICAgICAgICBvWzBdICY9IDB4ZmZmZjtcblxuICAgICAgICByZXR1cm4gWyhvWzBdIDw8IDE2KSB8IG9bMV0sIChvWzJdIDw8IDE2KSB8IG9bM11dO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF94NjRNdWx0aXBseShtLCBuKSB7XG4gICAgICAgIC8vXG4gICAgICAgIC8vIEdpdmVuIHR3byA2NGJpdCBpbnRzIChhcyBhbiBhcnJheSBvZiB0d28gMzJiaXQgaW50cykgcmV0dXJucyB0aGUgdHdvXG4gICAgICAgIC8vIG11bHRpcGxpZWQgdG9nZXRoZXIgYXMgYSA2NGJpdCBpbnQgKGFzIGFuIGFycmF5IG9mIHR3byAzMmJpdCBpbnRzKS5cbiAgICAgICAgLy9cblxuICAgICAgICBtID0gW21bMF0gPj4+IDE2LCBtWzBdICYgMHhmZmZmLCBtWzFdID4+PiAxNiwgbVsxXSAmIDB4ZmZmZl07XG4gICAgICAgIG4gPSBbblswXSA+Pj4gMTYsIG5bMF0gJiAweGZmZmYsIG5bMV0gPj4+IDE2LCBuWzFdICYgMHhmZmZmXTtcbiAgICAgICAgdmFyIG8gPSBbMCwgMCwgMCwgMF07XG5cbiAgICAgICAgb1szXSArPSBtWzNdICogblszXTtcbiAgICAgICAgb1syXSArPSBvWzNdID4+PiAxNjtcbiAgICAgICAgb1szXSAmPSAweGZmZmY7XG5cbiAgICAgICAgb1syXSArPSBtWzJdICogblszXTtcbiAgICAgICAgb1sxXSArPSBvWzJdID4+PiAxNjtcbiAgICAgICAgb1syXSAmPSAweGZmZmY7XG5cbiAgICAgICAgb1syXSArPSBtWzNdICogblsyXTtcbiAgICAgICAgb1sxXSArPSBvWzJdID4+PiAxNjtcbiAgICAgICAgb1syXSAmPSAweGZmZmY7XG5cbiAgICAgICAgb1sxXSArPSBtWzFdICogblszXTtcbiAgICAgICAgb1swXSArPSBvWzFdID4+PiAxNjtcbiAgICAgICAgb1sxXSAmPSAweGZmZmY7XG5cbiAgICAgICAgb1sxXSArPSBtWzJdICogblsyXTtcbiAgICAgICAgb1swXSArPSBvWzFdID4+PiAxNjtcbiAgICAgICAgb1sxXSAmPSAweGZmZmY7XG5cbiAgICAgICAgb1sxXSArPSBtWzNdICogblsxXTtcbiAgICAgICAgb1swXSArPSBvWzFdID4+PiAxNjtcbiAgICAgICAgb1sxXSAmPSAweGZmZmY7XG5cbiAgICAgICAgb1swXSArPSAobVswXSAqIG5bM10pICsgKG1bMV0gKiBuWzJdKSArIChtWzJdICogblsxXSkgKyAobVszXSAqIG5bMF0pO1xuICAgICAgICBvWzBdICY9IDB4ZmZmZjtcblxuICAgICAgICByZXR1cm4gWyhvWzBdIDw8IDE2KSB8IG9bMV0sIChvWzJdIDw8IDE2KSB8IG9bM11dO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF94NjRSb3RsKG0sIG4pIHtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gR2l2ZW4gYSA2NGJpdCBpbnQgKGFzIGFuIGFycmF5IG9mIHR3byAzMmJpdCBpbnRzKSBhbmQgYW4gaW50XG4gICAgICAgIC8vIHJlcHJlc2VudGluZyBhIG51bWJlciBvZiBiaXQgcG9zaXRpb25zLCByZXR1cm5zIHRoZSA2NGJpdCBpbnQgKGFzIGFuXG4gICAgICAgIC8vIGFycmF5IG9mIHR3byAzMmJpdCBpbnRzKSByb3RhdGVkIGxlZnQgYnkgdGhhdCBudW1iZXIgb2YgcG9zaXRpb25zLlxuICAgICAgICAvL1xuXG4gICAgICAgIG4gJT0gNjQ7XG5cbiAgICAgICAgaWYgKG4gPT09IDMyKSB7XG4gICAgICAgICAgICByZXR1cm4gW21bMV0sIG1bMF1dO1xuICAgICAgICB9IGVsc2UgaWYgKG4gPCAzMikge1xuICAgICAgICAgICAgcmV0dXJuIFsobVswXSA8PCBuKSB8IChtWzFdID4+PiAoMzIgLSBuKSksIChtWzFdIDw8IG4pIHwgKG1bMF0gPj4+ICgzMiAtIG4pKV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuIC09IDMyO1xuICAgICAgICAgICAgcmV0dXJuIFsobVsxXSA8PCBuKSB8IChtWzBdID4+PiAoMzIgLSBuKSksIChtWzBdIDw8IG4pIHwgKG1bMV0gPj4+ICgzMiAtIG4pKV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfeDY0TGVmdFNoaWZ0KG0sIG4pIHtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gR2l2ZW4gYSA2NGJpdCBpbnQgKGFzIGFuIGFycmF5IG9mIHR3byAzMmJpdCBpbnRzKSBhbmQgYW4gaW50XG4gICAgICAgIC8vIHJlcHJlc2VudGluZyBhIG51bWJlciBvZiBiaXQgcG9zaXRpb25zLCByZXR1cm5zIHRoZSA2NGJpdCBpbnQgKGFzIGFuXG4gICAgICAgIC8vIGFycmF5IG9mIHR3byAzMmJpdCBpbnRzKSBzaGlmdGVkIGxlZnQgYnkgdGhhdCBudW1iZXIgb2YgcG9zaXRpb25zLlxuICAgICAgICAvL1xuXG4gICAgICAgIG4gJT0gNjQ7XG5cbiAgICAgICAgaWYgKG4gPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBtO1xuICAgICAgICB9IGVsc2UgaWYgKG4gPCAzMikge1xuICAgICAgICAgICAgcmV0dXJuIFsobVswXSA8PCBuKSB8IChtWzFdID4+PiAoMzIgLSBuKSksIG1bMV0gPDwgbl07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gW21bMV0gPDwgKG4gLSAzMiksIDBdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX3g2NFhvcihtLCBuKSB7XG4gICAgICAgIC8vXG4gICAgICAgIC8vIEdpdmVuIHR3byA2NGJpdCBpbnRzIChhcyBhbiBhcnJheSBvZiB0d28gMzJiaXQgaW50cykgcmV0dXJucyB0aGUgdHdvXG4gICAgICAgIC8vIHhvcmVkIHRvZ2V0aGVyIGFzIGEgNjRiaXQgaW50IChhcyBhbiBhcnJheSBvZiB0d28gMzJiaXQgaW50cykuXG4gICAgICAgIC8vXG5cbiAgICAgICAgcmV0dXJuIFttWzBdIF4gblswXSwgbVsxXSBeIG5bMV1dO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF94NjRGbWl4KGgpIHtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gR2l2ZW4gYSBibG9jaywgcmV0dXJucyBtdXJtdXJIYXNoMydzIGZpbmFsIHg2NCBtaXggb2YgdGhhdCBibG9jay5cbiAgICAgICAgLy8gKGBbMCwgaFswXSA+Pj4gMV1gIGlzIGEgMzMgYml0IHVuc2lnbmVkIHJpZ2h0IHNoaWZ0LiBUaGlzIGlzIHRoZVxuICAgICAgICAvLyBvbmx5IHBsYWNlIHdoZXJlIHdlIG5lZWQgdG8gcmlnaHQgc2hpZnQgNjRiaXQgaW50cy4pXG4gICAgICAgIC8vXG5cbiAgICAgICAgaCA9IF94NjRYb3IoaCwgWzAsIGhbMF0gPj4+IDFdKTtcbiAgICAgICAgaCA9IF94NjRNdWx0aXBseShoLCBbMHhmZjUxYWZkNywgMHhlZDU1OGNjZF0pO1xuICAgICAgICBoID0gX3g2NFhvcihoLCBbMCwgaFswXSA+Pj4gMV0pO1xuICAgICAgICBoID0gX3g2NE11bHRpcGx5KGgsIFsweGM0Y2ViOWZlLCAweDFhODVlYzUzXSk7XG4gICAgICAgIGggPSBfeDY0WG9yKGgsIFswLCBoWzBdID4+PiAxXSk7XG5cbiAgICAgICAgcmV0dXJuIGg7XG4gICAgfVxuXG4gICAgLy8gUFVCTElDIEZVTkNUSU9OU1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGxpYnJhcnkueDg2Lmhhc2gzMiA9IGZ1bmN0aW9uIChieXRlcywgc2VlZCkge1xuICAgICAgICAvL1xuICAgICAgICAvLyBHaXZlbiBhIHN0cmluZyBhbmQgYW4gb3B0aW9uYWwgc2VlZCBhcyBhbiBpbnQsIHJldHVybnMgYSAzMiBiaXQgaGFzaFxuICAgICAgICAvLyB1c2luZyB0aGUgeDg2IGZsYXZvciBvZiBNdXJtdXJIYXNoMywgYXMgYW4gdW5zaWduZWQgaW50LlxuICAgICAgICAvL1xuICAgICAgICBpZiAobGlicmFyeS5pbnB1dFZhbGlkYXRpb24gJiYgIV92YWxpZEJ5dGVzKGJ5dGVzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBzZWVkID0gc2VlZCB8fCAwO1xuXG4gICAgICAgIHZhciByZW1haW5kZXIgPSBieXRlcy5sZW5ndGggJSA0O1xuICAgICAgICB2YXIgYmxvY2tzID0gYnl0ZXMubGVuZ3RoIC0gcmVtYWluZGVyO1xuXG4gICAgICAgIHZhciBoMSA9IHNlZWQ7XG5cbiAgICAgICAgdmFyIGsxID0gMDtcblxuICAgICAgICB2YXIgYzEgPSAweGNjOWUyZDUxO1xuICAgICAgICB2YXIgYzIgPSAweDFiODczNTkzO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmxvY2tzOyBpID0gaSArIDQpIHtcbiAgICAgICAgICAgIGsxID0gKGJ5dGVzW2ldKSB8IChieXRlc1tpICsgMV0gPDwgOCkgfCAoYnl0ZXNbaSArIDJdIDw8IDE2KSB8IChieXRlc1tpICsgM10gPDwgMjQpO1xuXG4gICAgICAgICAgICBrMSA9IF94ODZNdWx0aXBseShrMSwgYzEpO1xuICAgICAgICAgICAgazEgPSBfeDg2Um90bChrMSwgMTUpO1xuICAgICAgICAgICAgazEgPSBfeDg2TXVsdGlwbHkoazEsIGMyKTtcblxuICAgICAgICAgICAgaDEgXj0gazE7XG4gICAgICAgICAgICBoMSA9IF94ODZSb3RsKGgxLCAxMyk7XG4gICAgICAgICAgICBoMSA9IF94ODZNdWx0aXBseShoMSwgNSkgKyAweGU2NTQ2YjY0O1xuICAgICAgICB9XG5cbiAgICAgICAgazEgPSAwO1xuXG4gICAgICAgIHN3aXRjaCAocmVtYWluZGVyKSB7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgazEgXj0gYnl0ZXNbaSArIDJdIDw8IDE2O1xuXG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgazEgXj0gYnl0ZXNbaSArIDFdIDw8IDg7XG5cbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBrMSBePSBieXRlc1tpXTtcbiAgICAgICAgICAgICAgICBrMSA9IF94ODZNdWx0aXBseShrMSwgYzEpO1xuICAgICAgICAgICAgICAgIGsxID0gX3g4NlJvdGwoazEsIDE1KTtcbiAgICAgICAgICAgICAgICBrMSA9IF94ODZNdWx0aXBseShrMSwgYzIpO1xuICAgICAgICAgICAgICAgIGgxIF49IGsxO1xuICAgICAgICB9XG5cbiAgICAgICAgaDEgXj0gYnl0ZXMubGVuZ3RoO1xuICAgICAgICBoMSA9IF94ODZGbWl4KGgxKTtcblxuICAgICAgICByZXR1cm4gaDEgPj4+IDA7XG4gICAgfTtcblxuICAgIGxpYnJhcnkueDg2Lmhhc2gxMjggPSBmdW5jdGlvbiAoYnl0ZXMsIHNlZWQpIHtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gR2l2ZW4gYSBzdHJpbmcgYW5kIGFuIG9wdGlvbmFsIHNlZWQgYXMgYW4gaW50LCByZXR1cm5zIGEgMTI4IGJpdFxuICAgICAgICAvLyBoYXNoIHVzaW5nIHRoZSB4ODYgZmxhdm9yIG9mIE11cm11ckhhc2gzLCBhcyBhbiB1bnNpZ25lZCBoZXguXG4gICAgICAgIC8vXG4gICAgICAgIGlmIChsaWJyYXJ5LmlucHV0VmFsaWRhdGlvbiAmJiAhX3ZhbGlkQnl0ZXMoYnl0ZXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgc2VlZCA9IHNlZWQgfHwgMDtcbiAgICAgICAgdmFyIHJlbWFpbmRlciA9IGJ5dGVzLmxlbmd0aCAlIDE2O1xuICAgICAgICB2YXIgYmxvY2tzID0gYnl0ZXMubGVuZ3RoIC0gcmVtYWluZGVyO1xuXG4gICAgICAgIHZhciBoMSA9IHNlZWQ7XG4gICAgICAgIHZhciBoMiA9IHNlZWQ7XG4gICAgICAgIHZhciBoMyA9IHNlZWQ7XG4gICAgICAgIHZhciBoNCA9IHNlZWQ7XG5cbiAgICAgICAgdmFyIGsxID0gMDtcbiAgICAgICAgdmFyIGsyID0gMDtcbiAgICAgICAgdmFyIGszID0gMDtcbiAgICAgICAgdmFyIGs0ID0gMDtcblxuICAgICAgICB2YXIgYzEgPSAweDIzOWI5NjFiO1xuICAgICAgICB2YXIgYzIgPSAweGFiMGU5Nzg5O1xuICAgICAgICB2YXIgYzMgPSAweDM4YjM0YWU1O1xuICAgICAgICB2YXIgYzQgPSAweGExZTM4YjkzO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmxvY2tzOyBpID0gaSArIDE2KSB7XG4gICAgICAgICAgICBrMSA9IChieXRlc1tpXSkgfCAoYnl0ZXNbaSArIDFdIDw8IDgpIHwgKGJ5dGVzW2kgKyAyXSA8PCAxNikgfCAoYnl0ZXNbaSArIDNdIDw8IDI0KTtcbiAgICAgICAgICAgIGsyID0gKGJ5dGVzW2kgKyA0XSkgfCAoYnl0ZXNbaSArIDVdIDw8IDgpIHwgKGJ5dGVzW2kgKyA2XSA8PCAxNikgfCAoYnl0ZXNbaSArIDddIDw8IDI0KTtcbiAgICAgICAgICAgIGszID0gKGJ5dGVzW2kgKyA4XSkgfCAoYnl0ZXNbaSArIDldIDw8IDgpIHwgKGJ5dGVzW2kgKyAxMF0gPDwgMTYpIHwgKGJ5dGVzW2kgKyAxMV0gPDwgMjQpO1xuICAgICAgICAgICAgazQgPSAoYnl0ZXNbaSArIDEyXSkgfCAoYnl0ZXNbaSArIDEzXSA8PCA4KSB8IChieXRlc1tpICsgMTRdIDw8IDE2KSB8IChieXRlc1tpICsgMTVdIDw8IDI0KTtcblxuICAgICAgICAgICAgazEgPSBfeDg2TXVsdGlwbHkoazEsIGMxKTtcbiAgICAgICAgICAgIGsxID0gX3g4NlJvdGwoazEsIDE1KTtcbiAgICAgICAgICAgIGsxID0gX3g4Nk11bHRpcGx5KGsxLCBjMik7XG4gICAgICAgICAgICBoMSBePSBrMTtcblxuICAgICAgICAgICAgaDEgPSBfeDg2Um90bChoMSwgMTkpO1xuICAgICAgICAgICAgaDEgKz0gaDI7XG4gICAgICAgICAgICBoMSA9IF94ODZNdWx0aXBseShoMSwgNSkgKyAweDU2MWNjZDFiO1xuXG4gICAgICAgICAgICBrMiA9IF94ODZNdWx0aXBseShrMiwgYzIpO1xuICAgICAgICAgICAgazIgPSBfeDg2Um90bChrMiwgMTYpO1xuICAgICAgICAgICAgazIgPSBfeDg2TXVsdGlwbHkoazIsIGMzKTtcbiAgICAgICAgICAgIGgyIF49IGsyO1xuXG4gICAgICAgICAgICBoMiA9IF94ODZSb3RsKGgyLCAxNyk7XG4gICAgICAgICAgICBoMiArPSBoMztcbiAgICAgICAgICAgIGgyID0gX3g4Nk11bHRpcGx5KGgyLCA1KSArIDB4MGJjYWE3NDc7XG5cbiAgICAgICAgICAgIGszID0gX3g4Nk11bHRpcGx5KGszLCBjMyk7XG4gICAgICAgICAgICBrMyA9IF94ODZSb3RsKGszLCAxNyk7XG4gICAgICAgICAgICBrMyA9IF94ODZNdWx0aXBseShrMywgYzQpO1xuICAgICAgICAgICAgaDMgXj0gazM7XG5cbiAgICAgICAgICAgIGgzID0gX3g4NlJvdGwoaDMsIDE1KTtcbiAgICAgICAgICAgIGgzICs9IGg0O1xuICAgICAgICAgICAgaDMgPSBfeDg2TXVsdGlwbHkoaDMsIDUpICsgMHg5NmNkMWMzNTtcblxuICAgICAgICAgICAgazQgPSBfeDg2TXVsdGlwbHkoazQsIGM0KTtcbiAgICAgICAgICAgIGs0ID0gX3g4NlJvdGwoazQsIDE4KTtcbiAgICAgICAgICAgIGs0ID0gX3g4Nk11bHRpcGx5KGs0LCBjMSk7XG4gICAgICAgICAgICBoNCBePSBrNDtcblxuICAgICAgICAgICAgaDQgPSBfeDg2Um90bChoNCwgMTMpO1xuICAgICAgICAgICAgaDQgKz0gaDE7XG4gICAgICAgICAgICBoNCA9IF94ODZNdWx0aXBseShoNCwgNSkgKyAweDMyYWMzYjE3O1xuICAgICAgICB9XG5cbiAgICAgICAgazEgPSAwO1xuICAgICAgICBrMiA9IDA7XG4gICAgICAgIGszID0gMDtcbiAgICAgICAgazQgPSAwO1xuXG4gICAgICAgIHN3aXRjaCAocmVtYWluZGVyKSB7XG4gICAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgICAgIGs0IF49IGJ5dGVzW2kgKyAxNF0gPDwgMTY7XG5cbiAgICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICAgICAgazQgXj0gYnl0ZXNbaSArIDEzXSA8PCA4O1xuXG4gICAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgICAgIGs0IF49IGJ5dGVzW2kgKyAxMl07XG4gICAgICAgICAgICAgICAgazQgPSBfeDg2TXVsdGlwbHkoazQsIGM0KTtcbiAgICAgICAgICAgICAgICBrNCA9IF94ODZSb3RsKGs0LCAxOCk7XG4gICAgICAgICAgICAgICAgazQgPSBfeDg2TXVsdGlwbHkoazQsIGMxKTtcbiAgICAgICAgICAgICAgICBoNCBePSBrNDtcblxuICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgICAgICBrMyBePSBieXRlc1tpICsgMTFdIDw8IDI0O1xuXG4gICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICAgIGszIF49IGJ5dGVzW2kgKyAxMF0gPDwgMTY7XG5cbiAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgICAgazMgXj0gYnl0ZXNbaSArIDldIDw8IDg7XG5cbiAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICBrMyBePSBieXRlc1tpICsgOF07XG4gICAgICAgICAgICAgICAgazMgPSBfeDg2TXVsdGlwbHkoazMsIGMzKTtcbiAgICAgICAgICAgICAgICBrMyA9IF94ODZSb3RsKGszLCAxNyk7XG4gICAgICAgICAgICAgICAgazMgPSBfeDg2TXVsdGlwbHkoazMsIGM0KTtcbiAgICAgICAgICAgICAgICBoMyBePSBrMztcblxuICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgIGsyIF49IGJ5dGVzW2kgKyA3XSA8PCAyNDtcblxuICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgIGsyIF49IGJ5dGVzW2kgKyA2XSA8PCAxNjtcblxuICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgIGsyIF49IGJ5dGVzW2kgKyA1XSA8PCA4O1xuXG4gICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgazIgXj0gYnl0ZXNbaSArIDRdO1xuICAgICAgICAgICAgICAgIGsyID0gX3g4Nk11bHRpcGx5KGsyLCBjMik7XG4gICAgICAgICAgICAgICAgazIgPSBfeDg2Um90bChrMiwgMTYpO1xuICAgICAgICAgICAgICAgIGsyID0gX3g4Nk11bHRpcGx5KGsyLCBjMyk7XG4gICAgICAgICAgICAgICAgaDIgXj0gazI7XG5cbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICBrMSBePSBieXRlc1tpICsgM10gPDwgMjQ7XG5cbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICBrMSBePSBieXRlc1tpICsgMl0gPDwgMTY7XG5cbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBrMSBePSBieXRlc1tpICsgMV0gPDwgODtcblxuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGsxIF49IGJ5dGVzW2ldO1xuICAgICAgICAgICAgICAgIGsxID0gX3g4Nk11bHRpcGx5KGsxLCBjMSk7XG4gICAgICAgICAgICAgICAgazEgPSBfeDg2Um90bChrMSwgMTUpO1xuICAgICAgICAgICAgICAgIGsxID0gX3g4Nk11bHRpcGx5KGsxLCBjMik7XG4gICAgICAgICAgICAgICAgaDEgXj0gazE7XG4gICAgICAgIH1cblxuICAgICAgICBoMSBePSBieXRlcy5sZW5ndGg7XG4gICAgICAgIGgyIF49IGJ5dGVzLmxlbmd0aDtcbiAgICAgICAgaDMgXj0gYnl0ZXMubGVuZ3RoO1xuICAgICAgICBoNCBePSBieXRlcy5sZW5ndGg7XG5cbiAgICAgICAgaDEgKz0gaDI7XG4gICAgICAgIGgxICs9IGgzO1xuICAgICAgICBoMSArPSBoNDtcbiAgICAgICAgaDIgKz0gaDE7XG4gICAgICAgIGgzICs9IGgxO1xuICAgICAgICBoNCArPSBoMTtcblxuICAgICAgICBoMSA9IF94ODZGbWl4KGgxKTtcbiAgICAgICAgaDIgPSBfeDg2Rm1peChoMik7XG4gICAgICAgIGgzID0gX3g4NkZtaXgoaDMpO1xuICAgICAgICBoNCA9IF94ODZGbWl4KGg0KTtcblxuICAgICAgICBoMSArPSBoMjtcbiAgICAgICAgaDEgKz0gaDM7XG4gICAgICAgIGgxICs9IGg0O1xuICAgICAgICBoMiArPSBoMTtcbiAgICAgICAgaDMgKz0gaDE7XG4gICAgICAgIGg0ICs9IGgxO1xuXG4gICAgICAgIHJldHVybiAoXCIwMDAwMDAwMFwiICsgKGgxID4+PiAwKS50b1N0cmluZygxNikpLnNsaWNlKC04KSArIChcIjAwMDAwMDAwXCIgKyAoaDIgPj4+IDApLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTgpICsgKFwiMDAwMDAwMDBcIiArIChoMyA+Pj4gMCkudG9TdHJpbmcoMTYpKS5zbGljZSgtOCkgKyAoXCIwMDAwMDAwMFwiICsgKGg0ID4+PiAwKS50b1N0cmluZygxNikpLnNsaWNlKC04KTtcbiAgICB9O1xuXG4gICAgbGlicmFyeS54NjQuaGFzaDEyOCA9IGZ1bmN0aW9uIChieXRlcywgc2VlZCkge1xuICAgICAgICAvL1xuICAgICAgICAvLyBHaXZlbiBhIHN0cmluZyBhbmQgYW4gb3B0aW9uYWwgc2VlZCBhcyBhbiBpbnQsIHJldHVybnMgYSAxMjggYml0XG4gICAgICAgIC8vIGhhc2ggdXNpbmcgdGhlIHg2NCBmbGF2b3Igb2YgTXVybXVySGFzaDMsIGFzIGFuIHVuc2lnbmVkIGhleC5cbiAgICAgICAgLy9cbiAgICAgICAgaWYgKGxpYnJhcnkuaW5wdXRWYWxpZGF0aW9uICYmICFfdmFsaWRCeXRlcyhieXRlcykpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgc2VlZCA9IHNlZWQgfHwgMDtcblxuICAgICAgICB2YXIgcmVtYWluZGVyID0gYnl0ZXMubGVuZ3RoICUgMTY7XG4gICAgICAgIHZhciBibG9ja3MgPSBieXRlcy5sZW5ndGggLSByZW1haW5kZXI7XG5cbiAgICAgICAgdmFyIGgxID0gWzAsIHNlZWRdO1xuICAgICAgICB2YXIgaDIgPSBbMCwgc2VlZF07XG5cbiAgICAgICAgdmFyIGsxID0gWzAsIDBdO1xuICAgICAgICB2YXIgazIgPSBbMCwgMF07XG5cbiAgICAgICAgdmFyIGMxID0gWzB4ODdjMzdiOTEsIDB4MTE0MjUzZDVdO1xuICAgICAgICB2YXIgYzIgPSBbMHg0Y2Y1YWQ0MywgMHgyNzQ1OTM3Zl07XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBibG9ja3M7IGkgPSBpICsgMTYpIHtcbiAgICAgICAgICAgIGsxID0gWyhieXRlc1tpICsgNF0pIHwgKGJ5dGVzW2kgKyA1XSA8PCA4KSB8IChieXRlc1tpICsgNl0gPDwgMTYpIHwgKGJ5dGVzW2kgKyA3XSA8PCAyNCksIChieXRlc1tpXSkgfFxuICAgICAgICAgICAgICAgIChieXRlc1tpICsgMV0gPDwgOCkgfCAoYnl0ZXNbaSArIDJdIDw8IDE2KSB8IChieXRlc1tpICsgM10gPDwgMjQpXTtcbiAgICAgICAgICAgIGsyID0gWyhieXRlc1tpICsgMTJdKSB8IChieXRlc1tpICsgMTNdIDw8IDgpIHwgKGJ5dGVzW2kgKyAxNF0gPDwgMTYpIHwgKGJ5dGVzW2kgKyAxNV0gPDwgMjQpLCAoYnl0ZXNbaSArIDhdKSB8XG4gICAgICAgICAgICAgICAgKGJ5dGVzW2kgKyA5XSA8PCA4KSB8IChieXRlc1tpICsgMTBdIDw8IDE2KSB8IChieXRlc1tpICsgMTFdIDw8IDI0KV07XG5cbiAgICAgICAgICAgIGsxID0gX3g2NE11bHRpcGx5KGsxLCBjMSk7XG4gICAgICAgICAgICBrMSA9IF94NjRSb3RsKGsxLCAzMSk7XG4gICAgICAgICAgICBrMSA9IF94NjRNdWx0aXBseShrMSwgYzIpO1xuICAgICAgICAgICAgaDEgPSBfeDY0WG9yKGgxLCBrMSk7XG5cbiAgICAgICAgICAgIGgxID0gX3g2NFJvdGwoaDEsIDI3KTtcbiAgICAgICAgICAgIGgxID0gX3g2NEFkZChoMSwgaDIpO1xuICAgICAgICAgICAgaDEgPSBfeDY0QWRkKF94NjRNdWx0aXBseShoMSwgWzAsIDVdKSwgWzAsIDB4NTJkY2U3MjldKTtcblxuICAgICAgICAgICAgazIgPSBfeDY0TXVsdGlwbHkoazIsIGMyKTtcbiAgICAgICAgICAgIGsyID0gX3g2NFJvdGwoazIsIDMzKTtcbiAgICAgICAgICAgIGsyID0gX3g2NE11bHRpcGx5KGsyLCBjMSk7XG4gICAgICAgICAgICBoMiA9IF94NjRYb3IoaDIsIGsyKTtcblxuICAgICAgICAgICAgaDIgPSBfeDY0Um90bChoMiwgMzEpO1xuICAgICAgICAgICAgaDIgPSBfeDY0QWRkKGgyLCBoMSk7XG4gICAgICAgICAgICBoMiA9IF94NjRBZGQoX3g2NE11bHRpcGx5KGgyLCBbMCwgNV0pLCBbMCwgMHgzODQ5NWFiNV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgazEgPSBbMCwgMF07XG4gICAgICAgIGsyID0gWzAsIDBdO1xuXG4gICAgICAgIHN3aXRjaCAocmVtYWluZGVyKSB7XG4gICAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgICAgIGsyID0gX3g2NFhvcihrMiwgX3g2NExlZnRTaGlmdChbMCwgYnl0ZXNbaSArIDE0XV0sIDQ4KSk7XG5cbiAgICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICAgICAgazIgPSBfeDY0WG9yKGsyLCBfeDY0TGVmdFNoaWZ0KFswLCBieXRlc1tpICsgMTNdXSwgNDApKTtcblxuICAgICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgICAgICBrMiA9IF94NjRYb3IoazIsIF94NjRMZWZ0U2hpZnQoWzAsIGJ5dGVzW2kgKyAxMl1dLCAzMikpO1xuXG4gICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICAgIGsyID0gX3g2NFhvcihrMiwgX3g2NExlZnRTaGlmdChbMCwgYnl0ZXNbaSArIDExXV0sIDI0KSk7XG5cbiAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgICAgazIgPSBfeDY0WG9yKGsyLCBfeDY0TGVmdFNoaWZ0KFswLCBieXRlc1tpICsgMTBdXSwgMTYpKTtcblxuICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgICBrMiA9IF94NjRYb3IoazIsIF94NjRMZWZ0U2hpZnQoWzAsIGJ5dGVzW2kgKyA5XV0sIDgpKTtcblxuICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgIGsyID0gX3g2NFhvcihrMiwgWzAsIGJ5dGVzW2kgKyA4XV0pO1xuICAgICAgICAgICAgICAgIGsyID0gX3g2NE11bHRpcGx5KGsyLCBjMik7XG4gICAgICAgICAgICAgICAgazIgPSBfeDY0Um90bChrMiwgMzMpO1xuICAgICAgICAgICAgICAgIGsyID0gX3g2NE11bHRpcGx5KGsyLCBjMSk7XG4gICAgICAgICAgICAgICAgaDIgPSBfeDY0WG9yKGgyLCBrMik7XG5cbiAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICBrMSA9IF94NjRYb3IoazEsIF94NjRMZWZ0U2hpZnQoWzAsIGJ5dGVzW2kgKyA3XV0sIDU2KSk7XG5cbiAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICBrMSA9IF94NjRYb3IoazEsIF94NjRMZWZ0U2hpZnQoWzAsIGJ5dGVzW2kgKyA2XV0sIDQ4KSk7XG5cbiAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICBrMSA9IF94NjRYb3IoazEsIF94NjRMZWZ0U2hpZnQoWzAsIGJ5dGVzW2kgKyA1XV0sIDQwKSk7XG5cbiAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICBrMSA9IF94NjRYb3IoazEsIF94NjRMZWZ0U2hpZnQoWzAsIGJ5dGVzW2kgKyA0XV0sIDMyKSk7XG5cbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICBrMSA9IF94NjRYb3IoazEsIF94NjRMZWZ0U2hpZnQoWzAsIGJ5dGVzW2kgKyAzXV0sIDI0KSk7XG5cbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICBrMSA9IF94NjRYb3IoazEsIF94NjRMZWZ0U2hpZnQoWzAsIGJ5dGVzW2kgKyAyXV0sIDE2KSk7XG5cbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBrMSA9IF94NjRYb3IoazEsIF94NjRMZWZ0U2hpZnQoWzAsIGJ5dGVzW2kgKyAxXV0sIDgpKTtcblxuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGsxID0gX3g2NFhvcihrMSwgWzAsIGJ5dGVzW2ldXSk7XG4gICAgICAgICAgICAgICAgazEgPSBfeDY0TXVsdGlwbHkoazEsIGMxKTtcbiAgICAgICAgICAgICAgICBrMSA9IF94NjRSb3RsKGsxLCAzMSk7XG4gICAgICAgICAgICAgICAgazEgPSBfeDY0TXVsdGlwbHkoazEsIGMyKTtcbiAgICAgICAgICAgICAgICBoMSA9IF94NjRYb3IoaDEsIGsxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGgxID0gX3g2NFhvcihoMSwgWzAsIGJ5dGVzLmxlbmd0aF0pO1xuICAgICAgICBoMiA9IF94NjRYb3IoaDIsIFswLCBieXRlcy5sZW5ndGhdKTtcblxuICAgICAgICBoMSA9IF94NjRBZGQoaDEsIGgyKTtcbiAgICAgICAgaDIgPSBfeDY0QWRkKGgyLCBoMSk7XG5cbiAgICAgICAgaDEgPSBfeDY0Rm1peChoMSk7XG4gICAgICAgIGgyID0gX3g2NEZtaXgoaDIpO1xuXG4gICAgICAgIGgxID0gX3g2NEFkZChoMSwgaDIpO1xuICAgICAgICBoMiA9IF94NjRBZGQoaDIsIGgxKTtcblxuICAgICAgICByZXR1cm4gKFwiMDAwMDAwMDBcIiArIChoMVswXSA+Pj4gMCkudG9TdHJpbmcoMTYpKS5zbGljZSgtOCkgKyAoXCIwMDAwMDAwMFwiICsgKGgxWzFdID4+PiAwKS50b1N0cmluZygxNikpLnNsaWNlKC04KSArIChcIjAwMDAwMDAwXCIgKyAoaDJbMF0gPj4+IDApLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTgpICsgKFwiMDAwMDAwMDBcIiArIChoMlsxXSA+Pj4gMCkudG9TdHJpbmcoMTYpKS5zbGljZSgtOCk7XG4gICAgfTtcblxuICAgIC8vIElOSVRJQUxJWkFUSU9OXG4gICAgLy8gLS0tLS0tLS0tLS0tLS1cblxuICAgIC8vIEV4cG9ydCBtdXJtdXJIYXNoMyBmb3IgQ29tbW9uSlMsIGVpdGhlciBhcyBhbiBBTUQgbW9kdWxlIG9yIGp1c3QgYXMgcGFydFxuICAgIC8vIG9mIHRoZSBnbG9iYWwgb2JqZWN0LlxuICAgIGlmICh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcblxuICAgICAgICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgICAgICAgIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGxpYnJhcnk7XG4gICAgICAgIH1cblxuICAgICAgICBleHBvcnRzLm11cm11ckhhc2gzID0gbGlicmFyeTtcblxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG5cbiAgICAgICAgZGVmaW5lKFtdLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbGlicmFyeTtcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcblxuICAgICAgICAvLyBVc2UgbXVybXVySGFzaDMubm9Db25mbGljdCB0byByZXN0b3JlIGBtdXJtdXJIYXNoM2AgYmFjayB0byBpdHNcbiAgICAgICAgLy8gb3JpZ2luYWwgdmFsdWUuIFJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIGxpYnJhcnkgb2JqZWN0LCB0byBhbGxvd1xuICAgICAgICAvLyBpdCB0byBiZSB1c2VkIHVuZGVyIGEgZGlmZmVyZW50IG5hbWUuXG4gICAgICAgIGxpYnJhcnkuX211cm11ckhhc2gzID0gcm9vdC5tdXJtdXJIYXNoMztcblxuICAgICAgICBsaWJyYXJ5Lm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByb290Lm11cm11ckhhc2gzID0gbGlicmFyeS5fbXVybXVySGFzaDM7XG4gICAgICAgICAgICBsaWJyYXJ5Ll9tdXJtdXJIYXNoMyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGxpYnJhcnkubm9Db25mbGljdCA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgcmV0dXJuIGxpYnJhcnk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcm9vdC5tdXJtdXJIYXNoMyA9IGxpYnJhcnk7XG4gICAgfVxufSkodGhpcyk7XG4iLCAibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9tdXJtdXJIYXNoM2pzJyk7XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHt7IFtrZXk6IHN0cmluZ106IGFueSB9fSBFeHRlbnNpb25zXG4gKiBAdHlwZWRlZiB7RXJyb3J9IEVyclxuICogQHByb3BlcnR5IHtzdHJpbmd9IG1lc3NhZ2VcbiAqL1xuXG4vKipcbiAqXG4gKiBAcGFyYW0ge0Vycm9yfSBvYmpcbiAqIEBwYXJhbSB7RXh0ZW5zaW9uc30gcHJvcHNcbiAqIEByZXR1cm5zIHtFcnJvciAmIEV4dGVuc2lvbnN9XG4gKi9cbmZ1bmN0aW9uIGFzc2lnbihvYmosIHByb3BzKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gcHJvcHMpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICAgICAgICB2YWx1ZTogcHJvcHNba2V5XSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBvYmo7XG59XG5cbi8qKlxuICpcbiAqIEBwYXJhbSB7YW55fSBlcnIgLSBBbiBFcnJvclxuICogQHBhcmFtIHtzdHJpbmd8RXh0ZW5zaW9uc30gY29kZSAtIEEgc3RyaW5nIGNvZGUgb3IgcHJvcHMgdG8gc2V0IG9uIHRoZSBlcnJvclxuICogQHBhcmFtIHtFeHRlbnNpb25zfSBbcHJvcHNdIC0gUHJvcHMgdG8gc2V0IG9uIHRoZSBlcnJvclxuICogQHJldHVybnMge0Vycm9yICYgRXh0ZW5zaW9uc31cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRXJyb3IoZXJyLCBjb2RlLCBwcm9wcykge1xuICAgIGlmICghZXJyIHx8IHR5cGVvZiBlcnIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1BsZWFzZSBwYXNzIGFuIEVycm9yIHRvIGVyci1jb2RlJyk7XG4gICAgfVxuXG4gICAgaWYgKCFwcm9wcykge1xuICAgICAgICBwcm9wcyA9IHt9O1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY29kZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgcHJvcHMgPSBjb2RlO1xuICAgICAgICBjb2RlID0gJyc7XG4gICAgfVxuXG4gICAgaWYgKGNvZGUpIHtcbiAgICAgICAgcHJvcHMuY29kZSA9IGNvZGU7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGFzc2lnbihlcnIsIHByb3BzKTtcbiAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgIHByb3BzLm1lc3NhZ2UgPSBlcnIubWVzc2FnZTtcbiAgICAgICAgcHJvcHMuc3RhY2sgPSBlcnIuc3RhY2s7XG5cbiAgICAgICAgY29uc3QgRXJyQ2xhc3MgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgICAgICBFcnJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZihlcnIpKTtcblxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGNvbnN0IG91dHB1dCA9IGFzc2lnbihuZXcgRXJyQ2xhc3MoKSwgcHJvcHMpO1xuXG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUVycm9yO1xuIiwgIlwidXNlIHN0cmljdFwiO1xyXG5tb2R1bGUuZXhwb3J0cyA9IGFzUHJvbWlzZTtcclxuXHJcbi8qKlxyXG4gKiBDYWxsYmFjayBhcyB1c2VkIGJ5IHtAbGluayB1dGlsLmFzUHJvbWlzZX0uXHJcbiAqIEB0eXBlZGVmIGFzUHJvbWlzZUNhbGxiYWNrXHJcbiAqIEB0eXBlIHtmdW5jdGlvbn1cclxuICogQHBhcmFtIHtFcnJvcnxudWxsfSBlcnJvciBFcnJvciwgaWYgYW55XHJcbiAqIEBwYXJhbSB7Li4uKn0gcGFyYW1zIEFkZGl0aW9uYWwgYXJndW1lbnRzXHJcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYSBwcm9taXNlIGZyb20gYSBub2RlLXN0eWxlIGNhbGxiYWNrIGZ1bmN0aW9uLlxyXG4gKiBAbWVtYmVyb2YgdXRpbFxyXG4gKiBAcGFyYW0ge2FzUHJvbWlzZUNhbGxiYWNrfSBmbiBGdW5jdGlvbiB0byBjYWxsXHJcbiAqIEBwYXJhbSB7Kn0gY3R4IEZ1bmN0aW9uIGNvbnRleHRcclxuICogQHBhcmFtIHsuLi4qfSBwYXJhbXMgRnVuY3Rpb24gYXJndW1lbnRzXHJcbiAqIEByZXR1cm5zIHtQcm9taXNlPCo+fSBQcm9taXNpZmllZCBmdW5jdGlvblxyXG4gKi9cclxuZnVuY3Rpb24gYXNQcm9taXNlKGZuLCBjdHgvKiwgdmFyYXJncyAqLykge1xyXG4gICAgdmFyIHBhcmFtcyAgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpLFxyXG4gICAgICAgIG9mZnNldCAgPSAwLFxyXG4gICAgICAgIGluZGV4ICAgPSAyLFxyXG4gICAgICAgIHBlbmRpbmcgPSB0cnVlO1xyXG4gICAgd2hpbGUgKGluZGV4IDwgYXJndW1lbnRzLmxlbmd0aClcclxuICAgICAgICBwYXJhbXNbb2Zmc2V0KytdID0gYXJndW1lbnRzW2luZGV4KytdO1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIGV4ZWN1dG9yKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIHBhcmFtc1tvZmZzZXRdID0gZnVuY3Rpb24gY2FsbGJhY2soZXJyLyosIHZhcmFyZ3MgKi8pIHtcclxuICAgICAgICAgICAgaWYgKHBlbmRpbmcpIHtcclxuICAgICAgICAgICAgICAgIHBlbmRpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGlmIChlcnIpXHJcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyYW1zID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAob2Zmc2V0IDwgcGFyYW1zLmxlbmd0aClcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zW29mZnNldCsrXSA9IGFyZ3VtZW50c1tvZmZzZXRdO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUuYXBwbHkobnVsbCwgcGFyYW1zKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgZm4uYXBwbHkoY3R4IHx8IG51bGwsIHBhcmFtcyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgIGlmIChwZW5kaW5nKSB7XHJcbiAgICAgICAgICAgICAgICBwZW5kaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcbiIsICJcInVzZSBzdHJpY3RcIjtcclxuXHJcbi8qKlxyXG4gKiBBIG1pbmltYWwgYmFzZTY0IGltcGxlbWVudGF0aW9uIGZvciBudW1iZXIgYXJyYXlzLlxyXG4gKiBAbWVtYmVyb2YgdXRpbFxyXG4gKiBAbmFtZXNwYWNlXHJcbiAqL1xyXG52YXIgYmFzZTY0ID0gZXhwb3J0cztcclxuXHJcbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBieXRlIGxlbmd0aCBvZiBhIGJhc2U2NCBlbmNvZGVkIHN0cmluZy5cclxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBCYXNlNjQgZW5jb2RlZCBzdHJpbmdcclxuICogQHJldHVybnMge251bWJlcn0gQnl0ZSBsZW5ndGhcclxuICovXHJcbmJhc2U2NC5sZW5ndGggPSBmdW5jdGlvbiBsZW5ndGgoc3RyaW5nKSB7XHJcbiAgICB2YXIgcCA9IHN0cmluZy5sZW5ndGg7XHJcbiAgICBpZiAoIXApXHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB2YXIgbiA9IDA7XHJcbiAgICB3aGlsZSAoLS1wICUgNCA+IDEgJiYgc3RyaW5nLmNoYXJBdChwKSA9PT0gXCI9XCIpXHJcbiAgICAgICAgKytuO1xyXG4gICAgcmV0dXJuIE1hdGguY2VpbChzdHJpbmcubGVuZ3RoICogMykgLyA0IC0gbjtcclxufTtcclxuXHJcbi8vIEJhc2U2NCBlbmNvZGluZyB0YWJsZVxyXG52YXIgYjY0ID0gbmV3IEFycmF5KDY0KTtcclxuXHJcbi8vIEJhc2U2NCBkZWNvZGluZyB0YWJsZVxyXG52YXIgczY0ID0gbmV3IEFycmF5KDEyMyk7XHJcblxyXG4vLyA2NS4uOTAsIDk3Li4xMjIsIDQ4Li41NywgNDMsIDQ3XHJcbmZvciAodmFyIGkgPSAwOyBpIDwgNjQ7KVxyXG4gICAgczY0W2I2NFtpXSA9IGkgPCAyNiA/IGkgKyA2NSA6IGkgPCA1MiA/IGkgKyA3MSA6IGkgPCA2MiA/IGkgLSA0IDogaSAtIDU5IHwgNDNdID0gaSsrO1xyXG5cclxuLyoqXHJcbiAqIEVuY29kZXMgYSBidWZmZXIgdG8gYSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcuXHJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmZmVyIFNvdXJjZSBidWZmZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFNvdXJjZSBzdGFydFxyXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIFNvdXJjZSBlbmRcclxuICogQHJldHVybnMge3N0cmluZ30gQmFzZTY0IGVuY29kZWQgc3RyaW5nXHJcbiAqL1xyXG5iYXNlNjQuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKGJ1ZmZlciwgc3RhcnQsIGVuZCkge1xyXG4gICAgdmFyIHBhcnRzID0gbnVsbCxcclxuICAgICAgICBjaHVuayA9IFtdO1xyXG4gICAgdmFyIGkgPSAwLCAvLyBvdXRwdXQgaW5kZXhcclxuICAgICAgICBqID0gMCwgLy8gZ290byBpbmRleFxyXG4gICAgICAgIHQ7ICAgICAvLyB0ZW1wb3JhcnlcclxuICAgIHdoaWxlIChzdGFydCA8IGVuZCkge1xyXG4gICAgICAgIHZhciBiID0gYnVmZmVyW3N0YXJ0KytdO1xyXG4gICAgICAgIHN3aXRjaCAoaikge1xyXG4gICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICBjaHVua1tpKytdID0gYjY0W2IgPj4gMl07XHJcbiAgICAgICAgICAgICAgICB0ID0gKGIgJiAzKSA8PCA0O1xyXG4gICAgICAgICAgICAgICAgaiA9IDE7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgY2h1bmtbaSsrXSA9IGI2NFt0IHwgYiA+PiA0XTtcclxuICAgICAgICAgICAgICAgIHQgPSAoYiAmIDE1KSA8PCAyO1xyXG4gICAgICAgICAgICAgICAgaiA9IDI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgY2h1bmtbaSsrXSA9IGI2NFt0IHwgYiA+PiA2XTtcclxuICAgICAgICAgICAgICAgIGNodW5rW2krK10gPSBiNjRbYiAmIDYzXTtcclxuICAgICAgICAgICAgICAgIGogPSAwO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpID4gODE5MSkge1xyXG4gICAgICAgICAgICAocGFydHMgfHwgKHBhcnRzID0gW10pKS5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjaHVuaykpO1xyXG4gICAgICAgICAgICBpID0gMDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoaikge1xyXG4gICAgICAgIGNodW5rW2krK10gPSBiNjRbdF07XHJcbiAgICAgICAgY2h1bmtbaSsrXSA9IDYxO1xyXG4gICAgICAgIGlmIChqID09PSAxKVxyXG4gICAgICAgICAgICBjaHVua1tpKytdID0gNjE7XHJcbiAgICB9XHJcbiAgICBpZiAocGFydHMpIHtcclxuICAgICAgICBpZiAoaSlcclxuICAgICAgICAgICAgcGFydHMucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY2h1bmsuc2xpY2UoMCwgaSkpKTtcclxuICAgICAgICByZXR1cm4gcGFydHMuam9pbihcIlwiKTtcclxuICAgIH1cclxuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY2h1bmsuc2xpY2UoMCwgaSkpO1xyXG59O1xyXG5cclxudmFyIGludmFsaWRFbmNvZGluZyA9IFwiaW52YWxpZCBlbmNvZGluZ1wiO1xyXG5cclxuLyoqXHJcbiAqIERlY29kZXMgYSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcgdG8gYSBidWZmZXIuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgU291cmNlIHN0cmluZ1xyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZmZlciBEZXN0aW5hdGlvbiBidWZmZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBEZXN0aW5hdGlvbiBvZmZzZXRcclxuICogQHJldHVybnMge251bWJlcn0gTnVtYmVyIG9mIGJ5dGVzIHdyaXR0ZW5cclxuICogQHRocm93cyB7RXJyb3J9IElmIGVuY29kaW5nIGlzIGludmFsaWRcclxuICovXHJcbmJhc2U2NC5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUoc3RyaW5nLCBidWZmZXIsIG9mZnNldCkge1xyXG4gICAgdmFyIHN0YXJ0ID0gb2Zmc2V0O1xyXG4gICAgdmFyIGogPSAwLCAvLyBnb3RvIGluZGV4XHJcbiAgICAgICAgdDsgICAgIC8vIHRlbXBvcmFyeVxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOykge1xyXG4gICAgICAgIHZhciBjID0gc3RyaW5nLmNoYXJDb2RlQXQoaSsrKTtcclxuICAgICAgICBpZiAoYyA9PT0gNjEgJiYgaiA+IDEpXHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGlmICgoYyA9IHM2NFtjXSkgPT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoaW52YWxpZEVuY29kaW5nKTtcclxuICAgICAgICBzd2l0Y2ggKGopIHtcclxuICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgdCA9IGM7XHJcbiAgICAgICAgICAgICAgICBqID0gMTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gdCA8PCAyIHwgKGMgJiA0OCkgPj4gNDtcclxuICAgICAgICAgICAgICAgIHQgPSBjO1xyXG4gICAgICAgICAgICAgICAgaiA9IDI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9ICh0ICYgMTUpIDw8IDQgfCAoYyAmIDYwKSA+PiAyO1xyXG4gICAgICAgICAgICAgICAgdCA9IGM7XHJcbiAgICAgICAgICAgICAgICBqID0gMztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gKHQgJiAzKSA8PCA2IHwgYztcclxuICAgICAgICAgICAgICAgIGogPSAwO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGogPT09IDEpXHJcbiAgICAgICAgdGhyb3cgRXJyb3IoaW52YWxpZEVuY29kaW5nKTtcclxuICAgIHJldHVybiBvZmZzZXQgLSBzdGFydDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGUgc3BlY2lmaWVkIHN0cmluZyBhcHBlYXJzIHRvIGJlIGJhc2U2NCBlbmNvZGVkLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFN0cmluZyB0byB0ZXN0XHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgcHJvYmFibHkgYmFzZTY0IGVuY29kZWQsIG90aGVyd2lzZSBmYWxzZVxyXG4gKi9cclxuYmFzZTY0LnRlc3QgPSBmdW5jdGlvbiB0ZXN0KHN0cmluZykge1xyXG4gICAgcmV0dXJuIC9eKD86W0EtWmEtejAtOSsvXXs0fSkqKD86W0EtWmEtejAtOSsvXXsyfT09fFtBLVphLXowLTkrL117M309KT8kLy50ZXN0KHN0cmluZyk7XHJcbn07XHJcbiIsICJcInVzZSBzdHJpY3RcIjtcclxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XHJcblxyXG4vKipcclxuICogQ29uc3RydWN0cyBhIG5ldyBldmVudCBlbWl0dGVyIGluc3RhbmNlLlxyXG4gKiBAY2xhc3NkZXNjIEEgbWluaW1hbCBldmVudCBlbWl0dGVyLlxyXG4gKiBAbWVtYmVyb2YgdXRpbFxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlZ2lzdGVyZWQgbGlzdGVuZXJzLlxyXG4gICAgICogQHR5cGUge09iamVjdC48c3RyaW5nLCo+fVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdGhpcy5fbGlzdGVuZXJzID0ge307XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZWdpc3RlcnMgYW4gZXZlbnQgbGlzdGVuZXIuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBldnQgRXZlbnQgbmFtZVxyXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBmbiBMaXN0ZW5lclxyXG4gKiBAcGFyYW0geyp9IFtjdHhdIExpc3RlbmVyIGNvbnRleHRcclxuICogQHJldHVybnMge3V0aWwuRXZlbnRFbWl0dGVyfSBgdGhpc2BcclxuICovXHJcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBmdW5jdGlvbiBvbihldnQsIGZuLCBjdHgpIHtcclxuICAgICh0aGlzLl9saXN0ZW5lcnNbZXZ0XSB8fCAodGhpcy5fbGlzdGVuZXJzW2V2dF0gPSBbXSkpLnB1c2goe1xyXG4gICAgICAgIGZuICA6IGZuLFxyXG4gICAgICAgIGN0eCA6IGN0eCB8fCB0aGlzXHJcbiAgICB9KTtcclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlbW92ZXMgYW4gZXZlbnQgbGlzdGVuZXIgb3IgYW55IG1hdGNoaW5nIGxpc3RlbmVycyBpZiBhcmd1bWVudHMgYXJlIG9taXR0ZWQuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBbZXZ0XSBFdmVudCBuYW1lLiBSZW1vdmVzIGFsbCBsaXN0ZW5lcnMgaWYgb21pdHRlZC5cclxuICogQHBhcmFtIHtmdW5jdGlvbn0gW2ZuXSBMaXN0ZW5lciB0byByZW1vdmUuIFJlbW92ZXMgYWxsIGxpc3RlbmVycyBvZiBgZXZ0YCBpZiBvbWl0dGVkLlxyXG4gKiBAcmV0dXJucyB7dXRpbC5FdmVudEVtaXR0ZXJ9IGB0aGlzYFxyXG4gKi9cclxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbiBvZmYoZXZ0LCBmbikge1xyXG4gICAgaWYgKGV2dCA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgIHRoaXMuX2xpc3RlbmVycyA9IHt9O1xyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgaWYgKGZuID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgIHRoaXMuX2xpc3RlbmVyc1tldnRdID0gW107XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnNbZXZ0XTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOylcclxuICAgICAgICAgICAgICAgIGlmIChsaXN0ZW5lcnNbaV0uZm4gPT09IGZuKVxyXG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgKytpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEVtaXRzIGFuIGV2ZW50IGJ5IGNhbGxpbmcgaXRzIGxpc3RlbmVycyB3aXRoIHRoZSBzcGVjaWZpZWQgYXJndW1lbnRzLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZ0IEV2ZW50IG5hbWVcclxuICogQHBhcmFtIHsuLi4qfSBhcmdzIEFyZ3VtZW50c1xyXG4gKiBAcmV0dXJucyB7dXRpbC5FdmVudEVtaXR0ZXJ9IGB0aGlzYFxyXG4gKi9cclxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdChldnQpIHtcclxuICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnNbZXZ0XTtcclxuICAgIGlmIChsaXN0ZW5lcnMpIHtcclxuICAgICAgICB2YXIgYXJncyA9IFtdLFxyXG4gICAgICAgICAgICBpID0gMTtcclxuICAgICAgICBmb3IgKDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7KVxyXG4gICAgICAgICAgICBhcmdzLnB1c2goYXJndW1lbnRzW2krK10pO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOylcclxuICAgICAgICAgICAgbGlzdGVuZXJzW2ldLmZuLmFwcGx5KGxpc3RlbmVyc1tpKytdLmN0eCwgYXJncyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuIiwgIlwidXNlIHN0cmljdFwiO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KGZhY3RvcnkpO1xyXG5cclxuLyoqXHJcbiAqIFJlYWRzIC8gd3JpdGVzIGZsb2F0cyAvIGRvdWJsZXMgZnJvbSAvIHRvIGJ1ZmZlcnMuXHJcbiAqIEBuYW1lIHV0aWwuZmxvYXRcclxuICogQG5hbWVzcGFjZVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBXcml0ZXMgYSAzMiBiaXQgZmxvYXQgdG8gYSBidWZmZXIgdXNpbmcgbGl0dGxlIGVuZGlhbiBieXRlIG9yZGVyLlxyXG4gKiBAbmFtZSB1dGlsLmZsb2F0LndyaXRlRmxvYXRMRVxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtudW1iZXJ9IHZhbCBWYWx1ZSB0byB3cml0ZVxyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZiBUYXJnZXQgYnVmZmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBwb3MgVGFyZ2V0IGJ1ZmZlciBvZmZzZXRcclxuICogQHJldHVybnMge3VuZGVmaW5lZH1cclxuICovXHJcblxyXG4vKipcclxuICogV3JpdGVzIGEgMzIgYml0IGZsb2F0IHRvIGEgYnVmZmVyIHVzaW5nIGJpZyBlbmRpYW4gYnl0ZSBvcmRlci5cclxuICogQG5hbWUgdXRpbC5mbG9hdC53cml0ZUZsb2F0QkVcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgVmFsdWUgdG8gd3JpdGVcclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWYgVGFyZ2V0IGJ1ZmZlclxyXG4gKiBAcGFyYW0ge251bWJlcn0gcG9zIFRhcmdldCBidWZmZXIgb2Zmc2V0XHJcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFJlYWRzIGEgMzIgYml0IGZsb2F0IGZyb20gYSBidWZmZXIgdXNpbmcgbGl0dGxlIGVuZGlhbiBieXRlIG9yZGVyLlxyXG4gKiBAbmFtZSB1dGlsLmZsb2F0LnJlYWRGbG9hdExFXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZiBTb3VyY2UgYnVmZmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBwb3MgU291cmNlIGJ1ZmZlciBvZmZzZXRcclxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBSZWFkcyBhIDMyIGJpdCBmbG9hdCBmcm9tIGEgYnVmZmVyIHVzaW5nIGJpZyBlbmRpYW4gYnl0ZSBvcmRlci5cclxuICogQG5hbWUgdXRpbC5mbG9hdC5yZWFkRmxvYXRCRVxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWYgU291cmNlIGJ1ZmZlclxyXG4gKiBAcGFyYW0ge251bWJlcn0gcG9zIFNvdXJjZSBidWZmZXIgb2Zmc2V0XHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcclxuICovXHJcblxyXG4vKipcclxuICogV3JpdGVzIGEgNjQgYml0IGRvdWJsZSB0byBhIGJ1ZmZlciB1c2luZyBsaXR0bGUgZW5kaWFuIGJ5dGUgb3JkZXIuXHJcbiAqIEBuYW1lIHV0aWwuZmxvYXQud3JpdGVEb3VibGVMRVxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtudW1iZXJ9IHZhbCBWYWx1ZSB0byB3cml0ZVxyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZiBUYXJnZXQgYnVmZmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBwb3MgVGFyZ2V0IGJ1ZmZlciBvZmZzZXRcclxuICogQHJldHVybnMge3VuZGVmaW5lZH1cclxuICovXHJcblxyXG4vKipcclxuICogV3JpdGVzIGEgNjQgYml0IGRvdWJsZSB0byBhIGJ1ZmZlciB1c2luZyBiaWcgZW5kaWFuIGJ5dGUgb3JkZXIuXHJcbiAqIEBuYW1lIHV0aWwuZmxvYXQud3JpdGVEb3VibGVCRVxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtudW1iZXJ9IHZhbCBWYWx1ZSB0byB3cml0ZVxyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZiBUYXJnZXQgYnVmZmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBwb3MgVGFyZ2V0IGJ1ZmZlciBvZmZzZXRcclxuICogQHJldHVybnMge3VuZGVmaW5lZH1cclxuICovXHJcblxyXG4vKipcclxuICogUmVhZHMgYSA2NCBiaXQgZG91YmxlIGZyb20gYSBidWZmZXIgdXNpbmcgbGl0dGxlIGVuZGlhbiBieXRlIG9yZGVyLlxyXG4gKiBAbmFtZSB1dGlsLmZsb2F0LnJlYWREb3VibGVMRVxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWYgU291cmNlIGJ1ZmZlclxyXG4gKiBAcGFyYW0ge251bWJlcn0gcG9zIFNvdXJjZSBidWZmZXIgb2Zmc2V0XHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcclxuICovXHJcblxyXG4vKipcclxuICogUmVhZHMgYSA2NCBiaXQgZG91YmxlIGZyb20gYSBidWZmZXIgdXNpbmcgYmlnIGVuZGlhbiBieXRlIG9yZGVyLlxyXG4gKiBAbmFtZSB1dGlsLmZsb2F0LnJlYWREb3VibGVCRVxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWYgU291cmNlIGJ1ZmZlclxyXG4gKiBAcGFyYW0ge251bWJlcn0gcG9zIFNvdXJjZSBidWZmZXIgb2Zmc2V0XHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcclxuICovXHJcblxyXG4vLyBGYWN0b3J5IGZ1bmN0aW9uIGZvciB0aGUgcHVycG9zZSBvZiBub2RlLWJhc2VkIHRlc3RpbmcgaW4gbW9kaWZpZWQgZ2xvYmFsIGVudmlyb25tZW50c1xyXG5mdW5jdGlvbiBmYWN0b3J5KGV4cG9ydHMpIHtcclxuXHJcbiAgICAvLyBmbG9hdDogdHlwZWQgYXJyYXlcclxuICAgIGlmICh0eXBlb2YgRmxvYXQzMkFycmF5ICE9PSBcInVuZGVmaW5lZFwiKSAoZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICAgIHZhciBmMzIgPSBuZXcgRmxvYXQzMkFycmF5KFsgLTAgXSksXHJcbiAgICAgICAgICAgIGY4YiA9IG5ldyBVaW50OEFycmF5KGYzMi5idWZmZXIpLFxyXG4gICAgICAgICAgICBsZSAgPSBmOGJbM10gPT09IDEyODtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gd3JpdGVGbG9hdF9mMzJfY3B5KHZhbCwgYnVmLCBwb3MpIHtcclxuICAgICAgICAgICAgZjMyWzBdID0gdmFsO1xyXG4gICAgICAgICAgICBidWZbcG9zICAgIF0gPSBmOGJbMF07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyAxXSA9IGY4YlsxXTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDJdID0gZjhiWzJdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgM10gPSBmOGJbM107XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiB3cml0ZUZsb2F0X2YzMl9yZXYodmFsLCBidWYsIHBvcykge1xyXG4gICAgICAgICAgICBmMzJbMF0gPSB2YWw7XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgICAgXSA9IGY4YlszXTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDFdID0gZjhiWzJdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgMl0gPSBmOGJbMV07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyAzXSA9IGY4YlswXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgZXhwb3J0cy53cml0ZUZsb2F0TEUgPSBsZSA/IHdyaXRlRmxvYXRfZjMyX2NweSA6IHdyaXRlRmxvYXRfZjMyX3JldjtcclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIGV4cG9ydHMud3JpdGVGbG9hdEJFID0gbGUgPyB3cml0ZUZsb2F0X2YzMl9yZXYgOiB3cml0ZUZsb2F0X2YzMl9jcHk7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHJlYWRGbG9hdF9mMzJfY3B5KGJ1ZiwgcG9zKSB7XHJcbiAgICAgICAgICAgIGY4YlswXSA9IGJ1Zltwb3MgICAgXTtcclxuICAgICAgICAgICAgZjhiWzFdID0gYnVmW3BvcyArIDFdO1xyXG4gICAgICAgICAgICBmOGJbMl0gPSBidWZbcG9zICsgMl07XHJcbiAgICAgICAgICAgIGY4YlszXSA9IGJ1Zltwb3MgKyAzXTtcclxuICAgICAgICAgICAgcmV0dXJuIGYzMlswXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHJlYWRGbG9hdF9mMzJfcmV2KGJ1ZiwgcG9zKSB7XHJcbiAgICAgICAgICAgIGY4YlszXSA9IGJ1Zltwb3MgICAgXTtcclxuICAgICAgICAgICAgZjhiWzJdID0gYnVmW3BvcyArIDFdO1xyXG4gICAgICAgICAgICBmOGJbMV0gPSBidWZbcG9zICsgMl07XHJcbiAgICAgICAgICAgIGY4YlswXSA9IGJ1Zltwb3MgKyAzXTtcclxuICAgICAgICAgICAgcmV0dXJuIGYzMlswXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgZXhwb3J0cy5yZWFkRmxvYXRMRSA9IGxlID8gcmVhZEZsb2F0X2YzMl9jcHkgOiByZWFkRmxvYXRfZjMyX3JldjtcclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIGV4cG9ydHMucmVhZEZsb2F0QkUgPSBsZSA/IHJlYWRGbG9hdF9mMzJfcmV2IDogcmVhZEZsb2F0X2YzMl9jcHk7XHJcblxyXG4gICAgLy8gZmxvYXQ6IGllZWU3NTRcclxuICAgIH0pKCk7IGVsc2UgKGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgICBmdW5jdGlvbiB3cml0ZUZsb2F0X2llZWU3NTQod3JpdGVVaW50LCB2YWwsIGJ1ZiwgcG9zKSB7XHJcbiAgICAgICAgICAgIHZhciBzaWduID0gdmFsIDwgMCA/IDEgOiAwO1xyXG4gICAgICAgICAgICBpZiAoc2lnbilcclxuICAgICAgICAgICAgICAgIHZhbCA9IC12YWw7XHJcbiAgICAgICAgICAgIGlmICh2YWwgPT09IDApXHJcbiAgICAgICAgICAgICAgICB3cml0ZVVpbnQoMSAvIHZhbCA+IDAgPyAvKiBwb3NpdGl2ZSAqLyAwIDogLyogbmVnYXRpdmUgMCAqLyAyMTQ3NDgzNjQ4LCBidWYsIHBvcyk7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzTmFOKHZhbCkpXHJcbiAgICAgICAgICAgICAgICB3cml0ZVVpbnQoMjE0MzI4OTM0NCwgYnVmLCBwb3MpO1xyXG4gICAgICAgICAgICBlbHNlIGlmICh2YWwgPiAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KSAvLyArLUluZmluaXR5XHJcbiAgICAgICAgICAgICAgICB3cml0ZVVpbnQoKHNpZ24gPDwgMzEgfCAyMTM5MDk1MDQwKSA+Pj4gMCwgYnVmLCBwb3MpO1xyXG4gICAgICAgICAgICBlbHNlIGlmICh2YWwgPCAxLjE3NTQ5NDM1MDgyMjI4NzVlLTM4KSAvLyBkZW5vcm1hbFxyXG4gICAgICAgICAgICAgICAgd3JpdGVVaW50KChzaWduIDw8IDMxIHwgTWF0aC5yb3VuZCh2YWwgLyAxLjQwMTI5ODQ2NDMyNDgxN2UtNDUpKSA+Pj4gMCwgYnVmLCBwb3MpO1xyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciBleHBvbmVudCA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsKSAvIE1hdGguTE4yKSxcclxuICAgICAgICAgICAgICAgICAgICBtYW50aXNzYSA9IE1hdGgucm91bmQodmFsICogTWF0aC5wb3coMiwgLWV4cG9uZW50KSAqIDgzODg2MDgpICYgODM4ODYwNztcclxuICAgICAgICAgICAgICAgIHdyaXRlVWludCgoc2lnbiA8PCAzMSB8IGV4cG9uZW50ICsgMTI3IDw8IDIzIHwgbWFudGlzc2EpID4+PiAwLCBidWYsIHBvcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGV4cG9ydHMud3JpdGVGbG9hdExFID0gd3JpdGVGbG9hdF9pZWVlNzU0LmJpbmQobnVsbCwgd3JpdGVVaW50TEUpO1xyXG4gICAgICAgIGV4cG9ydHMud3JpdGVGbG9hdEJFID0gd3JpdGVGbG9hdF9pZWVlNzU0LmJpbmQobnVsbCwgd3JpdGVVaW50QkUpO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiByZWFkRmxvYXRfaWVlZTc1NChyZWFkVWludCwgYnVmLCBwb3MpIHtcclxuICAgICAgICAgICAgdmFyIHVpbnQgPSByZWFkVWludChidWYsIHBvcyksXHJcbiAgICAgICAgICAgICAgICBzaWduID0gKHVpbnQgPj4gMzEpICogMiArIDEsXHJcbiAgICAgICAgICAgICAgICBleHBvbmVudCA9IHVpbnQgPj4+IDIzICYgMjU1LFxyXG4gICAgICAgICAgICAgICAgbWFudGlzc2EgPSB1aW50ICYgODM4ODYwNztcclxuICAgICAgICAgICAgcmV0dXJuIGV4cG9uZW50ID09PSAyNTVcclxuICAgICAgICAgICAgICAgID8gbWFudGlzc2FcclxuICAgICAgICAgICAgICAgID8gTmFOXHJcbiAgICAgICAgICAgICAgICA6IHNpZ24gKiBJbmZpbml0eVxyXG4gICAgICAgICAgICAgICAgOiBleHBvbmVudCA9PT0gMCAvLyBkZW5vcm1hbFxyXG4gICAgICAgICAgICAgICAgPyBzaWduICogMS40MDEyOTg0NjQzMjQ4MTdlLTQ1ICogbWFudGlzc2FcclxuICAgICAgICAgICAgICAgIDogc2lnbiAqIE1hdGgucG93KDIsIGV4cG9uZW50IC0gMTUwKSAqIChtYW50aXNzYSArIDgzODg2MDgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZXhwb3J0cy5yZWFkRmxvYXRMRSA9IHJlYWRGbG9hdF9pZWVlNzU0LmJpbmQobnVsbCwgcmVhZFVpbnRMRSk7XHJcbiAgICAgICAgZXhwb3J0cy5yZWFkRmxvYXRCRSA9IHJlYWRGbG9hdF9pZWVlNzU0LmJpbmQobnVsbCwgcmVhZFVpbnRCRSk7XHJcblxyXG4gICAgfSkoKTtcclxuXHJcbiAgICAvLyBkb3VibGU6IHR5cGVkIGFycmF5XHJcbiAgICBpZiAodHlwZW9mIEZsb2F0NjRBcnJheSAhPT0gXCJ1bmRlZmluZWRcIikgKGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgICB2YXIgZjY0ID0gbmV3IEZsb2F0NjRBcnJheShbLTBdKSxcclxuICAgICAgICAgICAgZjhiID0gbmV3IFVpbnQ4QXJyYXkoZjY0LmJ1ZmZlciksXHJcbiAgICAgICAgICAgIGxlICA9IGY4Yls3XSA9PT0gMTI4O1xyXG5cclxuICAgICAgICBmdW5jdGlvbiB3cml0ZURvdWJsZV9mNjRfY3B5KHZhbCwgYnVmLCBwb3MpIHtcclxuICAgICAgICAgICAgZjY0WzBdID0gdmFsO1xyXG4gICAgICAgICAgICBidWZbcG9zICAgIF0gPSBmOGJbMF07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyAxXSA9IGY4YlsxXTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDJdID0gZjhiWzJdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgM10gPSBmOGJbM107XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyA0XSA9IGY4Yls0XTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDVdID0gZjhiWzVdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgNl0gPSBmOGJbNl07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyA3XSA9IGY4Yls3XTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHdyaXRlRG91YmxlX2Y2NF9yZXYodmFsLCBidWYsIHBvcykge1xyXG4gICAgICAgICAgICBmNjRbMF0gPSB2YWw7XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgICAgXSA9IGY4Yls3XTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDFdID0gZjhiWzZdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgMl0gPSBmOGJbNV07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyAzXSA9IGY4Yls0XTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDRdID0gZjhiWzNdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgNV0gPSBmOGJbMl07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyA2XSA9IGY4YlsxXTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDddID0gZjhiWzBdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICBleHBvcnRzLndyaXRlRG91YmxlTEUgPSBsZSA/IHdyaXRlRG91YmxlX2Y2NF9jcHkgOiB3cml0ZURvdWJsZV9mNjRfcmV2O1xyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgZXhwb3J0cy53cml0ZURvdWJsZUJFID0gbGUgPyB3cml0ZURvdWJsZV9mNjRfcmV2IDogd3JpdGVEb3VibGVfZjY0X2NweTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gcmVhZERvdWJsZV9mNjRfY3B5KGJ1ZiwgcG9zKSB7XHJcbiAgICAgICAgICAgIGY4YlswXSA9IGJ1Zltwb3MgICAgXTtcclxuICAgICAgICAgICAgZjhiWzFdID0gYnVmW3BvcyArIDFdO1xyXG4gICAgICAgICAgICBmOGJbMl0gPSBidWZbcG9zICsgMl07XHJcbiAgICAgICAgICAgIGY4YlszXSA9IGJ1Zltwb3MgKyAzXTtcclxuICAgICAgICAgICAgZjhiWzRdID0gYnVmW3BvcyArIDRdO1xyXG4gICAgICAgICAgICBmOGJbNV0gPSBidWZbcG9zICsgNV07XHJcbiAgICAgICAgICAgIGY4Yls2XSA9IGJ1Zltwb3MgKyA2XTtcclxuICAgICAgICAgICAgZjhiWzddID0gYnVmW3BvcyArIDddO1xyXG4gICAgICAgICAgICByZXR1cm4gZjY0WzBdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gcmVhZERvdWJsZV9mNjRfcmV2KGJ1ZiwgcG9zKSB7XHJcbiAgICAgICAgICAgIGY4Yls3XSA9IGJ1Zltwb3MgICAgXTtcclxuICAgICAgICAgICAgZjhiWzZdID0gYnVmW3BvcyArIDFdO1xyXG4gICAgICAgICAgICBmOGJbNV0gPSBidWZbcG9zICsgMl07XHJcbiAgICAgICAgICAgIGY4Yls0XSA9IGJ1Zltwb3MgKyAzXTtcclxuICAgICAgICAgICAgZjhiWzNdID0gYnVmW3BvcyArIDRdO1xyXG4gICAgICAgICAgICBmOGJbMl0gPSBidWZbcG9zICsgNV07XHJcbiAgICAgICAgICAgIGY4YlsxXSA9IGJ1Zltwb3MgKyA2XTtcclxuICAgICAgICAgICAgZjhiWzBdID0gYnVmW3BvcyArIDddO1xyXG4gICAgICAgICAgICByZXR1cm4gZjY0WzBdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICBleHBvcnRzLnJlYWREb3VibGVMRSA9IGxlID8gcmVhZERvdWJsZV9mNjRfY3B5IDogcmVhZERvdWJsZV9mNjRfcmV2O1xyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgZXhwb3J0cy5yZWFkRG91YmxlQkUgPSBsZSA/IHJlYWREb3VibGVfZjY0X3JldiA6IHJlYWREb3VibGVfZjY0X2NweTtcclxuXHJcbiAgICAvLyBkb3VibGU6IGllZWU3NTRcclxuICAgIH0pKCk7IGVsc2UgKGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgICBmdW5jdGlvbiB3cml0ZURvdWJsZV9pZWVlNzU0KHdyaXRlVWludCwgb2ZmMCwgb2ZmMSwgdmFsLCBidWYsIHBvcykge1xyXG4gICAgICAgICAgICB2YXIgc2lnbiA9IHZhbCA8IDAgPyAxIDogMDtcclxuICAgICAgICAgICAgaWYgKHNpZ24pXHJcbiAgICAgICAgICAgICAgICB2YWwgPSAtdmFsO1xyXG4gICAgICAgICAgICBpZiAodmFsID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB3cml0ZVVpbnQoMCwgYnVmLCBwb3MgKyBvZmYwKTtcclxuICAgICAgICAgICAgICAgIHdyaXRlVWludCgxIC8gdmFsID4gMCA/IC8qIHBvc2l0aXZlICovIDAgOiAvKiBuZWdhdGl2ZSAwICovIDIxNDc0ODM2NDgsIGJ1ZiwgcG9zICsgb2ZmMSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNOYU4odmFsKSkge1xyXG4gICAgICAgICAgICAgICAgd3JpdGVVaW50KDAsIGJ1ZiwgcG9zICsgb2ZmMCk7XHJcbiAgICAgICAgICAgICAgICB3cml0ZVVpbnQoMjE0Njk1OTM2MCwgYnVmLCBwb3MgKyBvZmYxKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICh2YWwgPiAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOCkgeyAvLyArLUluZmluaXR5XHJcbiAgICAgICAgICAgICAgICB3cml0ZVVpbnQoMCwgYnVmLCBwb3MgKyBvZmYwKTtcclxuICAgICAgICAgICAgICAgIHdyaXRlVWludCgoc2lnbiA8PCAzMSB8IDIxNDY0MzUwNzIpID4+PiAwLCBidWYsIHBvcyArIG9mZjEpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIG1hbnRpc3NhO1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbCA8IDIuMjI1MDczODU4NTA3MjAxNGUtMzA4KSB7IC8vIGRlbm9ybWFsXHJcbiAgICAgICAgICAgICAgICAgICAgbWFudGlzc2EgPSB2YWwgLyA1ZS0zMjQ7XHJcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVVaW50KG1hbnRpc3NhID4+PiAwLCBidWYsIHBvcyArIG9mZjApO1xyXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlVWludCgoc2lnbiA8PCAzMSB8IG1hbnRpc3NhIC8gNDI5NDk2NzI5NikgPj4+IDAsIGJ1ZiwgcG9zICsgb2ZmMSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBleHBvbmVudCA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsKSAvIE1hdGguTE4yKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXhwb25lbnQgPT09IDEwMjQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cG9uZW50ID0gMTAyMztcclxuICAgICAgICAgICAgICAgICAgICBtYW50aXNzYSA9IHZhbCAqIE1hdGgucG93KDIsIC1leHBvbmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVVaW50KG1hbnRpc3NhICogNDUwMzU5OTYyNzM3MDQ5NiA+Pj4gMCwgYnVmLCBwb3MgKyBvZmYwKTtcclxuICAgICAgICAgICAgICAgICAgICB3cml0ZVVpbnQoKHNpZ24gPDwgMzEgfCBleHBvbmVudCArIDEwMjMgPDwgMjAgfCBtYW50aXNzYSAqIDEwNDg1NzYgJiAxMDQ4NTc1KSA+Pj4gMCwgYnVmLCBwb3MgKyBvZmYxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZXhwb3J0cy53cml0ZURvdWJsZUxFID0gd3JpdGVEb3VibGVfaWVlZTc1NC5iaW5kKG51bGwsIHdyaXRlVWludExFLCAwLCA0KTtcclxuICAgICAgICBleHBvcnRzLndyaXRlRG91YmxlQkUgPSB3cml0ZURvdWJsZV9pZWVlNzU0LmJpbmQobnVsbCwgd3JpdGVVaW50QkUsIDQsIDApO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiByZWFkRG91YmxlX2llZWU3NTQocmVhZFVpbnQsIG9mZjAsIG9mZjEsIGJ1ZiwgcG9zKSB7XHJcbiAgICAgICAgICAgIHZhciBsbyA9IHJlYWRVaW50KGJ1ZiwgcG9zICsgb2ZmMCksXHJcbiAgICAgICAgICAgICAgICBoaSA9IHJlYWRVaW50KGJ1ZiwgcG9zICsgb2ZmMSk7XHJcbiAgICAgICAgICAgIHZhciBzaWduID0gKGhpID4+IDMxKSAqIDIgKyAxLFxyXG4gICAgICAgICAgICAgICAgZXhwb25lbnQgPSBoaSA+Pj4gMjAgJiAyMDQ3LFxyXG4gICAgICAgICAgICAgICAgbWFudGlzc2EgPSA0Mjk0OTY3Mjk2ICogKGhpICYgMTA0ODU3NSkgKyBsbztcclxuICAgICAgICAgICAgcmV0dXJuIGV4cG9uZW50ID09PSAyMDQ3XHJcbiAgICAgICAgICAgICAgICA/IG1hbnRpc3NhXHJcbiAgICAgICAgICAgICAgICA/IE5hTlxyXG4gICAgICAgICAgICAgICAgOiBzaWduICogSW5maW5pdHlcclxuICAgICAgICAgICAgICAgIDogZXhwb25lbnQgPT09IDAgLy8gZGVub3JtYWxcclxuICAgICAgICAgICAgICAgID8gc2lnbiAqIDVlLTMyNCAqIG1hbnRpc3NhXHJcbiAgICAgICAgICAgICAgICA6IHNpZ24gKiBNYXRoLnBvdygyLCBleHBvbmVudCAtIDEwNzUpICogKG1hbnRpc3NhICsgNDUwMzU5OTYyNzM3MDQ5Nik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBleHBvcnRzLnJlYWREb3VibGVMRSA9IHJlYWREb3VibGVfaWVlZTc1NC5iaW5kKG51bGwsIHJlYWRVaW50TEUsIDAsIDQpO1xyXG4gICAgICAgIGV4cG9ydHMucmVhZERvdWJsZUJFID0gcmVhZERvdWJsZV9pZWVlNzU0LmJpbmQobnVsbCwgcmVhZFVpbnRCRSwgNCwgMCk7XHJcblxyXG4gICAgfSkoKTtcclxuXHJcbiAgICByZXR1cm4gZXhwb3J0cztcclxufVxyXG5cclxuLy8gdWludCBoZWxwZXJzXHJcblxyXG5mdW5jdGlvbiB3cml0ZVVpbnRMRSh2YWwsIGJ1ZiwgcG9zKSB7XHJcbiAgICBidWZbcG9zICAgIF0gPSAgdmFsICAgICAgICAmIDI1NTtcclxuICAgIGJ1Zltwb3MgKyAxXSA9ICB2YWwgPj4+IDggICYgMjU1O1xyXG4gICAgYnVmW3BvcyArIDJdID0gIHZhbCA+Pj4gMTYgJiAyNTU7XHJcbiAgICBidWZbcG9zICsgM10gPSAgdmFsID4+PiAyNDtcclxufVxyXG5cclxuZnVuY3Rpb24gd3JpdGVVaW50QkUodmFsLCBidWYsIHBvcykge1xyXG4gICAgYnVmW3BvcyAgICBdID0gIHZhbCA+Pj4gMjQ7XHJcbiAgICBidWZbcG9zICsgMV0gPSAgdmFsID4+PiAxNiAmIDI1NTtcclxuICAgIGJ1Zltwb3MgKyAyXSA9ICB2YWwgPj4+IDggICYgMjU1O1xyXG4gICAgYnVmW3BvcyArIDNdID0gIHZhbCAgICAgICAgJiAyNTU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlYWRVaW50TEUoYnVmLCBwb3MpIHtcclxuICAgIHJldHVybiAoYnVmW3BvcyAgICBdXHJcbiAgICAgICAgICB8IGJ1Zltwb3MgKyAxXSA8PCA4XHJcbiAgICAgICAgICB8IGJ1Zltwb3MgKyAyXSA8PCAxNlxyXG4gICAgICAgICAgfCBidWZbcG9zICsgM10gPDwgMjQpID4+PiAwO1xyXG59XHJcblxyXG5mdW5jdGlvbiByZWFkVWludEJFKGJ1ZiwgcG9zKSB7XHJcbiAgICByZXR1cm4gKGJ1Zltwb3MgICAgXSA8PCAyNFxyXG4gICAgICAgICAgfCBidWZbcG9zICsgMV0gPDwgMTZcclxuICAgICAgICAgIHwgYnVmW3BvcyArIDJdIDw8IDhcclxuICAgICAgICAgIHwgYnVmW3BvcyArIDNdKSA+Pj4gMDtcclxufVxyXG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XHJcbm1vZHVsZS5leHBvcnRzID0gaW5xdWlyZTtcclxuXHJcbi8qKlxyXG4gKiBSZXF1aXJlcyBhIG1vZHVsZSBvbmx5IGlmIGF2YWlsYWJsZS5cclxuICogQG1lbWJlcm9mIHV0aWxcclxuICogQHBhcmFtIHtzdHJpbmd9IG1vZHVsZU5hbWUgTW9kdWxlIHRvIHJlcXVpcmVcclxuICogQHJldHVybnMgez9PYmplY3R9IFJlcXVpcmVkIG1vZHVsZSBpZiBhdmFpbGFibGUgYW5kIG5vdCBlbXB0eSwgb3RoZXJ3aXNlIGBudWxsYFxyXG4gKi9cclxuZnVuY3Rpb24gaW5xdWlyZShtb2R1bGVOYW1lKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHZhciBtb2QgPSBldmFsKFwicXVpcmVcIi5yZXBsYWNlKC9eLyxcInJlXCIpKShtb2R1bGVOYW1lKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1ldmFsXHJcbiAgICAgICAgaWYgKG1vZCAmJiAobW9kLmxlbmd0aCB8fCBPYmplY3Qua2V5cyhtb2QpLmxlbmd0aCkpXHJcbiAgICAgICAgICAgIHJldHVybiBtb2Q7XHJcbiAgICB9IGNhdGNoIChlKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWVtcHR5XHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxyXG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4vKipcclxuICogQSBtaW5pbWFsIFVURjggaW1wbGVtZW50YXRpb24gZm9yIG51bWJlciBhcnJheXMuXHJcbiAqIEBtZW1iZXJvZiB1dGlsXHJcbiAqIEBuYW1lc3BhY2VcclxuICovXHJcbnZhciB1dGY4ID0gZXhwb3J0cztcclxuXHJcbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBVVEY4IGJ5dGUgbGVuZ3RoIG9mIGEgc3RyaW5nLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFN0cmluZ1xyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBCeXRlIGxlbmd0aFxyXG4gKi9cclxudXRmOC5sZW5ndGggPSBmdW5jdGlvbiB1dGY4X2xlbmd0aChzdHJpbmcpIHtcclxuICAgIHZhciBsZW4gPSAwLFxyXG4gICAgICAgIGMgPSAwO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICBjID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7XHJcbiAgICAgICAgaWYgKGMgPCAxMjgpXHJcbiAgICAgICAgICAgIGxlbiArPSAxO1xyXG4gICAgICAgIGVsc2UgaWYgKGMgPCAyMDQ4KVxyXG4gICAgICAgICAgICBsZW4gKz0gMjtcclxuICAgICAgICBlbHNlIGlmICgoYyAmIDB4RkMwMCkgPT09IDB4RDgwMCAmJiAoc3RyaW5nLmNoYXJDb2RlQXQoaSArIDEpICYgMHhGQzAwKSA9PT0gMHhEQzAwKSB7XHJcbiAgICAgICAgICAgICsraTtcclxuICAgICAgICAgICAgbGVuICs9IDQ7XHJcbiAgICAgICAgfSBlbHNlXHJcbiAgICAgICAgICAgIGxlbiArPSAzO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxlbjtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZWFkcyBVVEY4IGJ5dGVzIGFzIGEgc3RyaW5nLlxyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZmZlciBTb3VyY2UgYnVmZmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBTb3VyY2Ugc3RhcnRcclxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBTb3VyY2UgZW5kXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFN0cmluZyByZWFkXHJcbiAqL1xyXG51dGY4LnJlYWQgPSBmdW5jdGlvbiB1dGY4X3JlYWQoYnVmZmVyLCBzdGFydCwgZW5kKSB7XHJcbiAgICB2YXIgbGVuID0gZW5kIC0gc3RhcnQ7XHJcbiAgICBpZiAobGVuIDwgMSlcclxuICAgICAgICByZXR1cm4gXCJcIjtcclxuICAgIHZhciBwYXJ0cyA9IG51bGwsXHJcbiAgICAgICAgY2h1bmsgPSBbXSxcclxuICAgICAgICBpID0gMCwgLy8gY2hhciBvZmZzZXRcclxuICAgICAgICB0OyAgICAgLy8gdGVtcG9yYXJ5XHJcbiAgICB3aGlsZSAoc3RhcnQgPCBlbmQpIHtcclxuICAgICAgICB0ID0gYnVmZmVyW3N0YXJ0KytdO1xyXG4gICAgICAgIGlmICh0IDwgMTI4KVxyXG4gICAgICAgICAgICBjaHVua1tpKytdID0gdDtcclxuICAgICAgICBlbHNlIGlmICh0ID4gMTkxICYmIHQgPCAyMjQpXHJcbiAgICAgICAgICAgIGNodW5rW2krK10gPSAodCAmIDMxKSA8PCA2IHwgYnVmZmVyW3N0YXJ0KytdICYgNjM7XHJcbiAgICAgICAgZWxzZSBpZiAodCA+IDIzOSAmJiB0IDwgMzY1KSB7XHJcbiAgICAgICAgICAgIHQgPSAoKHQgJiA3KSA8PCAxOCB8IChidWZmZXJbc3RhcnQrK10gJiA2MykgPDwgMTIgfCAoYnVmZmVyW3N0YXJ0KytdICYgNjMpIDw8IDYgfCBidWZmZXJbc3RhcnQrK10gJiA2MykgLSAweDEwMDAwO1xyXG4gICAgICAgICAgICBjaHVua1tpKytdID0gMHhEODAwICsgKHQgPj4gMTApO1xyXG4gICAgICAgICAgICBjaHVua1tpKytdID0gMHhEQzAwICsgKHQgJiAxMDIzKTtcclxuICAgICAgICB9IGVsc2VcclxuICAgICAgICAgICAgY2h1bmtbaSsrXSA9ICh0ICYgMTUpIDw8IDEyIHwgKGJ1ZmZlcltzdGFydCsrXSAmIDYzKSA8PCA2IHwgYnVmZmVyW3N0YXJ0KytdICYgNjM7XHJcbiAgICAgICAgaWYgKGkgPiA4MTkxKSB7XHJcbiAgICAgICAgICAgIChwYXJ0cyB8fCAocGFydHMgPSBbXSkpLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNodW5rKSk7XHJcbiAgICAgICAgICAgIGkgPSAwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChwYXJ0cykge1xyXG4gICAgICAgIGlmIChpKVxyXG4gICAgICAgICAgICBwYXJ0cy5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjaHVuay5zbGljZSgwLCBpKSkpO1xyXG4gICAgICAgIHJldHVybiBwYXJ0cy5qb2luKFwiXCIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjaHVuay5zbGljZSgwLCBpKSk7XHJcbn07XHJcblxyXG4vKipcclxuICogV3JpdGVzIGEgc3RyaW5nIGFzIFVURjggYnl0ZXMuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgU291cmNlIHN0cmluZ1xyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZmZlciBEZXN0aW5hdGlvbiBidWZmZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBEZXN0aW5hdGlvbiBvZmZzZXRcclxuICogQHJldHVybnMge251bWJlcn0gQnl0ZXMgd3JpdHRlblxyXG4gKi9cclxudXRmOC53cml0ZSA9IGZ1bmN0aW9uIHV0Zjhfd3JpdGUoc3RyaW5nLCBidWZmZXIsIG9mZnNldCkge1xyXG4gICAgdmFyIHN0YXJ0ID0gb2Zmc2V0LFxyXG4gICAgICAgIGMxLCAvLyBjaGFyYWN0ZXIgMVxyXG4gICAgICAgIGMyOyAvLyBjaGFyYWN0ZXIgMlxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICBjMSA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xyXG4gICAgICAgIGlmIChjMSA8IDEyOCkge1xyXG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gYzE7XHJcbiAgICAgICAgfSBlbHNlIGlmIChjMSA8IDIwNDgpIHtcclxuICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IGMxID4+IDYgICAgICAgfCAxOTI7XHJcbiAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSBjMSAgICAgICAmIDYzIHwgMTI4O1xyXG4gICAgICAgIH0gZWxzZSBpZiAoKGMxICYgMHhGQzAwKSA9PT0gMHhEODAwICYmICgoYzIgPSBzdHJpbmcuY2hhckNvZGVBdChpICsgMSkpICYgMHhGQzAwKSA9PT0gMHhEQzAwKSB7XHJcbiAgICAgICAgICAgIGMxID0gMHgxMDAwMCArICgoYzEgJiAweDAzRkYpIDw8IDEwKSArIChjMiAmIDB4MDNGRik7XHJcbiAgICAgICAgICAgICsraTtcclxuICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IGMxID4+IDE4ICAgICAgfCAyNDA7XHJcbiAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSBjMSA+PiAxMiAmIDYzIHwgMTI4O1xyXG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gYzEgPj4gNiAgJiA2MyB8IDEyODtcclxuICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IGMxICAgICAgICYgNjMgfCAxMjg7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IGMxID4+IDEyICAgICAgfCAyMjQ7XHJcbiAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSBjMSA+PiA2ICAmIDYzIHwgMTI4O1xyXG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gYzEgICAgICAgJiA2MyB8IDEyODtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb2Zmc2V0IC0gc3RhcnQ7XHJcbn07XHJcbiIsICJcInVzZSBzdHJpY3RcIjtcclxubW9kdWxlLmV4cG9ydHMgPSBwb29sO1xyXG5cclxuLyoqXHJcbiAqIEFuIGFsbG9jYXRvciBhcyB1c2VkIGJ5IHtAbGluayB1dGlsLnBvb2x9LlxyXG4gKiBAdHlwZWRlZiBQb29sQWxsb2NhdG9yXHJcbiAqIEB0eXBlIHtmdW5jdGlvbn1cclxuICogQHBhcmFtIHtudW1iZXJ9IHNpemUgQnVmZmVyIHNpemVcclxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9IEJ1ZmZlclxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBBIHNsaWNlciBhcyB1c2VkIGJ5IHtAbGluayB1dGlsLnBvb2x9LlxyXG4gKiBAdHlwZWRlZiBQb29sU2xpY2VyXHJcbiAqIEB0eXBlIHtmdW5jdGlvbn1cclxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFN0YXJ0IG9mZnNldFxyXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIEVuZCBvZmZzZXRcclxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9IEJ1ZmZlciBzbGljZVxyXG4gKiBAdGhpcyB7VWludDhBcnJheX1cclxuICovXHJcblxyXG4vKipcclxuICogQSBnZW5lcmFsIHB1cnBvc2UgYnVmZmVyIHBvb2wuXHJcbiAqIEBtZW1iZXJvZiB1dGlsXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge1Bvb2xBbGxvY2F0b3J9IGFsbG9jIEFsbG9jYXRvclxyXG4gKiBAcGFyYW0ge1Bvb2xTbGljZXJ9IHNsaWNlIFNsaWNlclxyXG4gKiBAcGFyYW0ge251bWJlcn0gW3NpemU9ODE5Ml0gU2xhYiBzaXplXHJcbiAqIEByZXR1cm5zIHtQb29sQWxsb2NhdG9yfSBQb29sZWQgYWxsb2NhdG9yXHJcbiAqL1xyXG5mdW5jdGlvbiBwb29sKGFsbG9jLCBzbGljZSwgc2l6ZSkge1xyXG4gICAgdmFyIFNJWkUgICA9IHNpemUgfHwgODE5MjtcclxuICAgIHZhciBNQVggICAgPSBTSVpFID4+PiAxO1xyXG4gICAgdmFyIHNsYWIgICA9IG51bGw7XHJcbiAgICB2YXIgb2Zmc2V0ID0gU0laRTtcclxuICAgIHJldHVybiBmdW5jdGlvbiBwb29sX2FsbG9jKHNpemUpIHtcclxuICAgICAgICBpZiAoc2l6ZSA8IDEgfHwgc2l6ZSA+IE1BWClcclxuICAgICAgICAgICAgcmV0dXJuIGFsbG9jKHNpemUpO1xyXG4gICAgICAgIGlmIChvZmZzZXQgKyBzaXplID4gU0laRSkge1xyXG4gICAgICAgICAgICBzbGFiID0gYWxsb2MoU0laRSk7XHJcbiAgICAgICAgICAgIG9mZnNldCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBidWYgPSBzbGljZS5jYWxsKHNsYWIsIG9mZnNldCwgb2Zmc2V0ICs9IHNpemUpO1xyXG4gICAgICAgIGlmIChvZmZzZXQgJiA3KSAvLyBhbGlnbiB0byAzMiBiaXRcclxuICAgICAgICAgICAgb2Zmc2V0ID0gKG9mZnNldCB8IDcpICsgMTtcclxuICAgICAgICByZXR1cm4gYnVmO1xyXG4gICAgfTtcclxufVxyXG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IExvbmdCaXRzO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsL21pbmltYWxcIik7XG5cbi8qKlxuICogQ29uc3RydWN0cyBuZXcgbG9uZyBiaXRzLlxuICogQGNsYXNzZGVzYyBIZWxwZXIgY2xhc3MgZm9yIHdvcmtpbmcgd2l0aCB0aGUgbG93IGFuZCBoaWdoIGJpdHMgb2YgYSA2NCBiaXQgdmFsdWUuXG4gKiBAbWVtYmVyb2YgdXRpbFxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge251bWJlcn0gbG8gTG93IDMyIGJpdHMsIHVuc2lnbmVkXG4gKiBAcGFyYW0ge251bWJlcn0gaGkgSGlnaCAzMiBiaXRzLCB1bnNpZ25lZFxuICovXG5mdW5jdGlvbiBMb25nQml0cyhsbywgaGkpIHtcblxuICAgIC8vIG5vdGUgdGhhdCB0aGUgY2FzdHMgYmVsb3cgYXJlIHRoZW9yZXRpY2FsbHkgdW5uZWNlc3NhcnkgYXMgb2YgdG9kYXksIGJ1dCBvbGRlciBzdGF0aWNhbGx5XG4gICAgLy8gZ2VuZXJhdGVkIGNvbnZlcnRlciBjb2RlIG1pZ2h0IHN0aWxsIGNhbGwgdGhlIGN0b3Igd2l0aCBzaWduZWQgMzJiaXRzLiBrZXB0IGZvciBjb21wYXQuXG5cbiAgICAvKipcbiAgICAgKiBMb3cgYml0cy5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubG8gPSBsbyA+Pj4gMDtcblxuICAgIC8qKlxuICAgICAqIEhpZ2ggYml0cy5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuaGkgPSBoaSA+Pj4gMDtcbn1cblxuLyoqXG4gKiBaZXJvIGJpdHMuXG4gKiBAbWVtYmVyb2YgdXRpbC5Mb25nQml0c1xuICogQHR5cGUge3V0aWwuTG9uZ0JpdHN9XG4gKi9cbnZhciB6ZXJvID0gTG9uZ0JpdHMuemVybyA9IG5ldyBMb25nQml0cygwLCAwKTtcblxuemVyby50b051bWJlciA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbnplcm8uenpFbmNvZGUgPSB6ZXJvLnp6RGVjb2RlID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9O1xuemVyby5sZW5ndGggPSBmdW5jdGlvbigpIHsgcmV0dXJuIDE7IH07XG5cbi8qKlxuICogWmVybyBoYXNoLlxuICogQG1lbWJlcm9mIHV0aWwuTG9uZ0JpdHNcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbnZhciB6ZXJvSGFzaCA9IExvbmdCaXRzLnplcm9IYXNoID0gXCJcXDBcXDBcXDBcXDBcXDBcXDBcXDBcXDBcIjtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIG5ldyBsb25nIGJpdHMgZnJvbSB0aGUgc3BlY2lmaWVkIG51bWJlci5cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZVxuICogQHJldHVybnMge3V0aWwuTG9uZ0JpdHN9IEluc3RhbmNlXG4gKi9cbkxvbmdCaXRzLmZyb21OdW1iZXIgPSBmdW5jdGlvbiBmcm9tTnVtYmVyKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSAwKVxuICAgICAgICByZXR1cm4gemVybztcbiAgICB2YXIgc2lnbiA9IHZhbHVlIDwgMDtcbiAgICBpZiAoc2lnbilcbiAgICAgICAgdmFsdWUgPSAtdmFsdWU7XG4gICAgdmFyIGxvID0gdmFsdWUgPj4+IDAsXG4gICAgICAgIGhpID0gKHZhbHVlIC0gbG8pIC8gNDI5NDk2NzI5NiA+Pj4gMDtcbiAgICBpZiAoc2lnbikge1xuICAgICAgICBoaSA9IH5oaSA+Pj4gMDtcbiAgICAgICAgbG8gPSB+bG8gPj4+IDA7XG4gICAgICAgIGlmICgrK2xvID4gNDI5NDk2NzI5NSkge1xuICAgICAgICAgICAgbG8gPSAwO1xuICAgICAgICAgICAgaWYgKCsraGkgPiA0Mjk0OTY3Mjk1KVxuICAgICAgICAgICAgICAgIGhpID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IExvbmdCaXRzKGxvLCBoaSk7XG59O1xuXG4vKipcbiAqIENvbnN0cnVjdHMgbmV3IGxvbmcgYml0cyBmcm9tIGEgbnVtYmVyLCBsb25nIG9yIHN0cmluZy5cbiAqIEBwYXJhbSB7TG9uZ3xudW1iZXJ8c3RyaW5nfSB2YWx1ZSBWYWx1ZVxuICogQHJldHVybnMge3V0aWwuTG9uZ0JpdHN9IEluc3RhbmNlXG4gKi9cbkxvbmdCaXRzLmZyb20gPSBmdW5jdGlvbiBmcm9tKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgcmV0dXJuIExvbmdCaXRzLmZyb21OdW1iZXIodmFsdWUpO1xuICAgIGlmICh1dGlsLmlzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICBpZiAodXRpbC5Mb25nKVxuICAgICAgICAgICAgdmFsdWUgPSB1dGlsLkxvbmcuZnJvbVN0cmluZyh2YWx1ZSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBMb25nQml0cy5mcm9tTnVtYmVyKHBhcnNlSW50KHZhbHVlLCAxMCkpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWUubG93IHx8IHZhbHVlLmhpZ2ggPyBuZXcgTG9uZ0JpdHModmFsdWUubG93ID4+PiAwLCB2YWx1ZS5oaWdoID4+PiAwKSA6IHplcm87XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoaXMgbG9uZyBiaXRzIHRvIGEgcG9zc2libHkgdW5zYWZlIEphdmFTY3JpcHQgbnVtYmVyLlxuICogQHBhcmFtIHtib29sZWFufSBbdW5zaWduZWQ9ZmFsc2VdIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90XG4gKiBAcmV0dXJucyB7bnVtYmVyfSBQb3NzaWJseSB1bnNhZmUgbnVtYmVyXG4gKi9cbkxvbmdCaXRzLnByb3RvdHlwZS50b051bWJlciA9IGZ1bmN0aW9uIHRvTnVtYmVyKHVuc2lnbmVkKSB7XG4gICAgaWYgKCF1bnNpZ25lZCAmJiB0aGlzLmhpID4+PiAzMSkge1xuICAgICAgICB2YXIgbG8gPSB+dGhpcy5sbyArIDEgPj4+IDAsXG4gICAgICAgICAgICBoaSA9IH50aGlzLmhpICAgICA+Pj4gMDtcbiAgICAgICAgaWYgKCFsbylcbiAgICAgICAgICAgIGhpID0gaGkgKyAxID4+PiAwO1xuICAgICAgICByZXR1cm4gLShsbyArIGhpICogNDI5NDk2NzI5Nik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmxvICsgdGhpcy5oaSAqIDQyOTQ5NjcyOTY7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoaXMgbG9uZyBiaXRzIHRvIGEgbG9uZy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Vuc2lnbmVkPWZhbHNlXSBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdFxuICogQHJldHVybnMge0xvbmd9IExvbmdcbiAqL1xuTG9uZ0JpdHMucHJvdG90eXBlLnRvTG9uZyA9IGZ1bmN0aW9uIHRvTG9uZyh1bnNpZ25lZCkge1xuICAgIHJldHVybiB1dGlsLkxvbmdcbiAgICAgICAgPyBuZXcgdXRpbC5Mb25nKHRoaXMubG8gfCAwLCB0aGlzLmhpIHwgMCwgQm9vbGVhbih1bnNpZ25lZCkpXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIDogeyBsb3c6IHRoaXMubG8gfCAwLCBoaWdoOiB0aGlzLmhpIHwgMCwgdW5zaWduZWQ6IEJvb2xlYW4odW5zaWduZWQpIH07XG59O1xuXG52YXIgY2hhckNvZGVBdCA9IFN0cmluZy5wcm90b3R5cGUuY2hhckNvZGVBdDtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIG5ldyBsb25nIGJpdHMgZnJvbSB0aGUgc3BlY2lmaWVkIDggY2hhcmFjdGVycyBsb25nIGhhc2guXG4gKiBAcGFyYW0ge3N0cmluZ30gaGFzaCBIYXNoXG4gKiBAcmV0dXJucyB7dXRpbC5Mb25nQml0c30gQml0c1xuICovXG5Mb25nQml0cy5mcm9tSGFzaCA9IGZ1bmN0aW9uIGZyb21IYXNoKGhhc2gpIHtcbiAgICBpZiAoaGFzaCA9PT0gemVyb0hhc2gpXG4gICAgICAgIHJldHVybiB6ZXJvO1xuICAgIHJldHVybiBuZXcgTG9uZ0JpdHMoXG4gICAgICAgICggY2hhckNvZGVBdC5jYWxsKGhhc2gsIDApXG4gICAgICAgIHwgY2hhckNvZGVBdC5jYWxsKGhhc2gsIDEpIDw8IDhcbiAgICAgICAgfCBjaGFyQ29kZUF0LmNhbGwoaGFzaCwgMikgPDwgMTZcbiAgICAgICAgfCBjaGFyQ29kZUF0LmNhbGwoaGFzaCwgMykgPDwgMjQpID4+PiAwXG4gICAgLFxuICAgICAgICAoIGNoYXJDb2RlQXQuY2FsbChoYXNoLCA0KVxuICAgICAgICB8IGNoYXJDb2RlQXQuY2FsbChoYXNoLCA1KSA8PCA4XG4gICAgICAgIHwgY2hhckNvZGVBdC5jYWxsKGhhc2gsIDYpIDw8IDE2XG4gICAgICAgIHwgY2hhckNvZGVBdC5jYWxsKGhhc2gsIDcpIDw8IDI0KSA+Pj4gMFxuICAgICk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoaXMgbG9uZyBiaXRzIHRvIGEgOCBjaGFyYWN0ZXJzIGxvbmcgaGFzaC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IEhhc2hcbiAqL1xuTG9uZ0JpdHMucHJvdG90eXBlLnRvSGFzaCA9IGZ1bmN0aW9uIHRvSGFzaCgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShcbiAgICAgICAgdGhpcy5sbyAgICAgICAgJiAyNTUsXG4gICAgICAgIHRoaXMubG8gPj4+IDggICYgMjU1LFxuICAgICAgICB0aGlzLmxvID4+PiAxNiAmIDI1NSxcbiAgICAgICAgdGhpcy5sbyA+Pj4gMjQgICAgICAsXG4gICAgICAgIHRoaXMuaGkgICAgICAgICYgMjU1LFxuICAgICAgICB0aGlzLmhpID4+PiA4ICAmIDI1NSxcbiAgICAgICAgdGhpcy5oaSA+Pj4gMTYgJiAyNTUsXG4gICAgICAgIHRoaXMuaGkgPj4+IDI0XG4gICAgKTtcbn07XG5cbi8qKlxuICogWmlnLXphZyBlbmNvZGVzIHRoaXMgbG9uZyBiaXRzLlxuICogQHJldHVybnMge3V0aWwuTG9uZ0JpdHN9IGB0aGlzYFxuICovXG5Mb25nQml0cy5wcm90b3R5cGUuenpFbmNvZGUgPSBmdW5jdGlvbiB6ekVuY29kZSgpIHtcbiAgICB2YXIgbWFzayA9ICAgdGhpcy5oaSA+PiAzMTtcbiAgICB0aGlzLmhpICA9ICgodGhpcy5oaSA8PCAxIHwgdGhpcy5sbyA+Pj4gMzEpIF4gbWFzaykgPj4+IDA7XG4gICAgdGhpcy5sbyAgPSAoIHRoaXMubG8gPDwgMSAgICAgICAgICAgICAgICAgICBeIG1hc2spID4+PiAwO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBaaWctemFnIGRlY29kZXMgdGhpcyBsb25nIGJpdHMuXG4gKiBAcmV0dXJucyB7dXRpbC5Mb25nQml0c30gYHRoaXNgXG4gKi9cbkxvbmdCaXRzLnByb3RvdHlwZS56ekRlY29kZSA9IGZ1bmN0aW9uIHp6RGVjb2RlKCkge1xuICAgIHZhciBtYXNrID0gLSh0aGlzLmxvICYgMSk7XG4gICAgdGhpcy5sbyAgPSAoKHRoaXMubG8gPj4+IDEgfCB0aGlzLmhpIDw8IDMxKSBeIG1hc2spID4+PiAwO1xuICAgIHRoaXMuaGkgID0gKCB0aGlzLmhpID4+PiAxICAgICAgICAgICAgICAgICAgXiBtYXNrKSA+Pj4gMDtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgbGVuZ3RoIG9mIHRoaXMgbG9uZ2JpdHMgd2hlbiBlbmNvZGVkIGFzIGEgdmFyaW50LlxuICogQHJldHVybnMge251bWJlcn0gTGVuZ3RoXG4gKi9cbkxvbmdCaXRzLnByb3RvdHlwZS5sZW5ndGggPSBmdW5jdGlvbiBsZW5ndGgoKSB7XG4gICAgdmFyIHBhcnQwID0gIHRoaXMubG8sXG4gICAgICAgIHBhcnQxID0gKHRoaXMubG8gPj4+IDI4IHwgdGhpcy5oaSA8PCA0KSA+Pj4gMCxcbiAgICAgICAgcGFydDIgPSAgdGhpcy5oaSA+Pj4gMjQ7XG4gICAgcmV0dXJuIHBhcnQyID09PSAwXG4gICAgICAgICA/IHBhcnQxID09PSAwXG4gICAgICAgICAgID8gcGFydDAgPCAxNjM4NFxuICAgICAgICAgICAgID8gcGFydDAgPCAxMjggPyAxIDogMlxuICAgICAgICAgICAgIDogcGFydDAgPCAyMDk3MTUyID8gMyA6IDRcbiAgICAgICAgICAgOiBwYXJ0MSA8IDE2Mzg0XG4gICAgICAgICAgICAgPyBwYXJ0MSA8IDEyOCA/IDUgOiA2XG4gICAgICAgICAgICAgOiBwYXJ0MSA8IDIwOTcxNTIgPyA3IDogOFxuICAgICAgICAgOiBwYXJ0MiA8IDEyOCA/IDkgOiAxMDtcbn07XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgdXRpbCA9IGV4cG9ydHM7XG5cbi8vIHVzZWQgdG8gcmV0dXJuIGEgUHJvbWlzZSB3aGVyZSBjYWxsYmFjayBpcyBvbWl0dGVkXG51dGlsLmFzUHJvbWlzZSA9IHJlcXVpcmUoXCJAcHJvdG9idWZqcy9hc3Byb21pc2VcIik7XG5cbi8vIGNvbnZlcnRzIHRvIC8gZnJvbSBiYXNlNjQgZW5jb2RlZCBzdHJpbmdzXG51dGlsLmJhc2U2NCA9IHJlcXVpcmUoXCJAcHJvdG9idWZqcy9iYXNlNjRcIik7XG5cbi8vIGJhc2UgY2xhc3Mgb2YgcnBjLlNlcnZpY2VcbnV0aWwuRXZlbnRFbWl0dGVyID0gcmVxdWlyZShcIkBwcm90b2J1ZmpzL2V2ZW50ZW1pdHRlclwiKTtcblxuLy8gZmxvYXQgaGFuZGxpbmcgYWNjcm9zcyBicm93c2Vyc1xudXRpbC5mbG9hdCA9IHJlcXVpcmUoXCJAcHJvdG9idWZqcy9mbG9hdFwiKTtcblxuLy8gcmVxdWlyZXMgbW9kdWxlcyBvcHRpb25hbGx5IGFuZCBoaWRlcyB0aGUgY2FsbCBmcm9tIGJ1bmRsZXJzXG51dGlsLmlucXVpcmUgPSByZXF1aXJlKFwiQHByb3RvYnVmanMvaW5xdWlyZVwiKTtcblxuLy8gY29udmVydHMgdG8gLyBmcm9tIHV0ZjggZW5jb2RlZCBzdHJpbmdzXG51dGlsLnV0ZjggPSByZXF1aXJlKFwiQHByb3RvYnVmanMvdXRmOFwiKTtcblxuLy8gcHJvdmlkZXMgYSBub2RlLWxpa2UgYnVmZmVyIHBvb2wgaW4gdGhlIGJyb3dzZXJcbnV0aWwucG9vbCA9IHJlcXVpcmUoXCJAcHJvdG9idWZqcy9wb29sXCIpO1xuXG4vLyB1dGlsaXR5IHRvIHdvcmsgd2l0aCB0aGUgbG93IGFuZCBoaWdoIGJpdHMgb2YgYSA2NCBiaXQgdmFsdWVcbnV0aWwuTG9uZ0JpdHMgPSByZXF1aXJlKFwiLi9sb25nYml0c1wiKTtcblxuLyoqXG4gKiBXaGV0aGVyIHJ1bm5pbmcgd2l0aGluIG5vZGUgb3Igbm90LlxuICogQG1lbWJlcm9mIHV0aWxcbiAqIEB0eXBlIHtib29sZWFufVxuICovXG51dGlsLmlzTm9kZSA9IEJvb2xlYW4odHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIlxuICAgICAgICAgICAgICAgICAgICYmIGdsb2JhbFxuICAgICAgICAgICAgICAgICAgICYmIGdsb2JhbC5wcm9jZXNzXG4gICAgICAgICAgICAgICAgICAgJiYgZ2xvYmFsLnByb2Nlc3MudmVyc2lvbnNcbiAgICAgICAgICAgICAgICAgICAmJiBnbG9iYWwucHJvY2Vzcy52ZXJzaW9ucy5ub2RlKTtcblxuLyoqXG4gKiBHbG9iYWwgb2JqZWN0IHJlZmVyZW5jZS5cbiAqIEBtZW1iZXJvZiB1dGlsXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG51dGlsLmdsb2JhbCA9IHV0aWwuaXNOb2RlICYmIGdsb2JhbFxuICAgICAgICAgICB8fCB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvd1xuICAgICAgICAgICB8fCB0eXBlb2Ygc2VsZiAgICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGZcbiAgICAgICAgICAgfHwgdGhpczsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1pbnZhbGlkLXRoaXNcblxuLyoqXG4gKiBBbiBpbW11YWJsZSBlbXB0eSBhcnJheS5cbiAqIEBtZW1iZXJvZiB1dGlsXG4gKiBAdHlwZSB7QXJyYXkuPCo+fVxuICogQGNvbnN0XG4gKi9cbnV0aWwuZW1wdHlBcnJheSA9IE9iamVjdC5mcmVlemUgPyBPYmplY3QuZnJlZXplKFtdKSA6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIFtdOyAvLyB1c2VkIG9uIHByb3RvdHlwZXNcblxuLyoqXG4gKiBBbiBpbW11dGFibGUgZW1wdHkgb2JqZWN0LlxuICogQHR5cGUge09iamVjdH1cbiAqIEBjb25zdFxuICovXG51dGlsLmVtcHR5T2JqZWN0ID0gT2JqZWN0LmZyZWV6ZSA/IE9iamVjdC5mcmVlemUoe30pIDogLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8ge307IC8vIHVzZWQgb24gcHJvdG90eXBlc1xuXG4vKipcbiAqIFRlc3RzIGlmIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgYW4gaW50ZWdlci5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSB2YWx1ZSBpcyBhbiBpbnRlZ2VyXG4gKi9cbnV0aWwuaXNJbnRlZ2VyID0gTnVtYmVyLmlzSW50ZWdlciB8fCAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyBmdW5jdGlvbiBpc0ludGVnZXIodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiICYmIGlzRmluaXRlKHZhbHVlKSAmJiBNYXRoLmZsb29yKHZhbHVlKSA9PT0gdmFsdWU7XG59O1xuXG4vKipcbiAqIFRlc3RzIGlmIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgYSBzdHJpbmcuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIHZhbHVlIGlzIGEgc3RyaW5nXG4gKi9cbnV0aWwuaXNTdHJpbmcgPSBmdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgfHwgdmFsdWUgaW5zdGFuY2VvZiBTdHJpbmc7XG59O1xuXG4vKipcbiAqIFRlc3RzIGlmIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgYSBub24tbnVsbCBvYmplY3QuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIHZhbHVlIGlzIGEgbm9uLW51bGwgb2JqZWN0XG4gKi9cbnV0aWwuaXNPYmplY3QgPSBmdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCI7XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIHByb3BlcnR5IG9uIGEgbWVzc2FnZSBpcyBjb25zaWRlcmVkIHRvIGJlIHByZXNlbnQuXG4gKiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayB1dGlsLmlzU2V0fS5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBQbGFpbiBvYmplY3Qgb3IgbWVzc2FnZSBpbnN0YW5jZVxuICogQHBhcmFtIHtzdHJpbmd9IHByb3AgUHJvcGVydHkgbmFtZVxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiBjb25zaWRlcmVkIHRvIGJlIHByZXNlbnQsIG90aGVyd2lzZSBgZmFsc2VgXG4gKi9cbnV0aWwuaXNzZXQgPVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIHByb3BlcnR5IG9uIGEgbWVzc2FnZSBpcyBjb25zaWRlcmVkIHRvIGJlIHByZXNlbnQuXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFBsYWluIG9iamVjdCBvciBtZXNzYWdlIGluc3RhbmNlXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcCBQcm9wZXJ0eSBuYW1lXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIGNvbnNpZGVyZWQgdG8gYmUgcHJlc2VudCwgb3RoZXJ3aXNlIGBmYWxzZWBcbiAqL1xudXRpbC5pc1NldCA9IGZ1bmN0aW9uIGlzU2V0KG9iaiwgcHJvcCkge1xuICAgIHZhciB2YWx1ZSA9IG9ialtwcm9wXTtcbiAgICBpZiAodmFsdWUgIT0gbnVsbCAmJiBvYmouaGFzT3duUHJvcGVydHkocHJvcCkpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxLCBuby1wcm90b3R5cGUtYnVpbHRpbnNcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZS5sZW5ndGggOiBPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoKSA+IDA7XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBBbnkgY29tcGF0aWJsZSBCdWZmZXIgaW5zdGFuY2UuXG4gKiBUaGlzIGlzIGEgbWluaW1hbCBzdGFuZC1hbG9uZSBkZWZpbml0aW9uIG9mIGEgQnVmZmVyIGluc3RhbmNlLiBUaGUgYWN0dWFsIHR5cGUgaXMgdGhhdCBleHBvcnRlZCBieSBub2RlJ3MgdHlwaW5ncy5cbiAqIEBpbnRlcmZhY2UgQnVmZmVyXG4gKiBAZXh0ZW5kcyBVaW50OEFycmF5XG4gKi9cblxuLyoqXG4gKiBOb2RlJ3MgQnVmZmVyIGNsYXNzIGlmIGF2YWlsYWJsZS5cbiAqIEB0eXBlIHtDb25zdHJ1Y3RvcjxCdWZmZXI+fVxuICovXG51dGlsLkJ1ZmZlciA9IChmdW5jdGlvbigpIHtcbiAgICB0cnkge1xuICAgICAgICB2YXIgQnVmZmVyID0gdXRpbC5pbnF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcjtcbiAgICAgICAgLy8gcmVmdXNlIHRvIHVzZSBub24tbm9kZSBidWZmZXJzIGlmIG5vdCBleHBsaWNpdGx5IGFzc2lnbmVkIChwZXJmIHJlYXNvbnMpOlxuICAgICAgICByZXR1cm4gQnVmZmVyLnByb3RvdHlwZS51dGY4V3JpdGUgPyBCdWZmZXIgOiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyBudWxsO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufSkoKTtcblxuLy8gSW50ZXJuYWwgYWxpYXMgb2Ygb3IgcG9seWZ1bGwgZm9yIEJ1ZmZlci5mcm9tLlxudXRpbC5fQnVmZmVyX2Zyb20gPSBudWxsO1xuXG4vLyBJbnRlcm5hbCBhbGlhcyBvZiBvciBwb2x5ZmlsbCBmb3IgQnVmZmVyLmFsbG9jVW5zYWZlLlxudXRpbC5fQnVmZmVyX2FsbG9jVW5zYWZlID0gbnVsbDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGJ1ZmZlciBvZiB3aGF0ZXZlciB0eXBlIHN1cHBvcnRlZCBieSB0aGUgZW52aXJvbm1lbnQuXG4gKiBAcGFyYW0ge251bWJlcnxudW1iZXJbXX0gW3NpemVPckFycmF5PTBdIEJ1ZmZlciBzaXplIG9yIG51bWJlciBhcnJheVxuICogQHJldHVybnMge1VpbnQ4QXJyYXl8QnVmZmVyfSBCdWZmZXJcbiAqL1xudXRpbC5uZXdCdWZmZXIgPSBmdW5jdGlvbiBuZXdCdWZmZXIoc2l6ZU9yQXJyYXkpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHJldHVybiB0eXBlb2Ygc2l6ZU9yQXJyYXkgPT09IFwibnVtYmVyXCJcbiAgICAgICAgPyB1dGlsLkJ1ZmZlclxuICAgICAgICAgICAgPyB1dGlsLl9CdWZmZXJfYWxsb2NVbnNhZmUoc2l6ZU9yQXJyYXkpXG4gICAgICAgICAgICA6IG5ldyB1dGlsLkFycmF5KHNpemVPckFycmF5KVxuICAgICAgICA6IHV0aWwuQnVmZmVyXG4gICAgICAgICAgICA/IHV0aWwuX0J1ZmZlcl9mcm9tKHNpemVPckFycmF5KVxuICAgICAgICAgICAgOiB0eXBlb2YgVWludDhBcnJheSA9PT0gXCJ1bmRlZmluZWRcIlxuICAgICAgICAgICAgICAgID8gc2l6ZU9yQXJyYXlcbiAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KHNpemVPckFycmF5KTtcbn07XG5cbi8qKlxuICogQXJyYXkgaW1wbGVtZW50YXRpb24gdXNlZCBpbiB0aGUgYnJvd3Nlci4gYFVpbnQ4QXJyYXlgIGlmIHN1cHBvcnRlZCwgb3RoZXJ3aXNlIGBBcnJheWAuXG4gKiBAdHlwZSB7Q29uc3RydWN0b3I8VWludDhBcnJheT59XG4gKi9cbnV0aWwuQXJyYXkgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gXCJ1bmRlZmluZWRcIiA/IFVpbnQ4QXJyYXkgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gOiBBcnJheTtcblxuLyoqXG4gKiBBbnkgY29tcGF0aWJsZSBMb25nIGluc3RhbmNlLlxuICogVGhpcyBpcyBhIG1pbmltYWwgc3RhbmQtYWxvbmUgZGVmaW5pdGlvbiBvZiBhIExvbmcgaW5zdGFuY2UuIFRoZSBhY3R1YWwgdHlwZSBpcyB0aGF0IGV4cG9ydGVkIGJ5IGxvbmcuanMuXG4gKiBAaW50ZXJmYWNlIExvbmdcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBsb3cgTG93IGJpdHNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBoaWdoIEhpZ2ggYml0c1xuICogQHByb3BlcnR5IHtib29sZWFufSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdFxuICovXG5cbi8qKlxuICogTG9uZy5qcydzIExvbmcgY2xhc3MgaWYgYXZhaWxhYmxlLlxuICogQHR5cGUge0NvbnN0cnVjdG9yPExvbmc+fVxuICovXG51dGlsLkxvbmcgPSAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyB1dGlsLmdsb2JhbC5kY29kZUlPICYmIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIHV0aWwuZ2xvYmFsLmRjb2RlSU8uTG9uZ1xuICAgICAgICAgfHwgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gdXRpbC5nbG9iYWwuTG9uZ1xuICAgICAgICAgfHwgdXRpbC5pbnF1aXJlKFwibG9uZ1wiKTtcblxuLyoqXG4gKiBSZWd1bGFyIGV4cHJlc3Npb24gdXNlZCB0byB2ZXJpZnkgMiBiaXQgKGBib29sYCkgbWFwIGtleXMuXG4gKiBAdHlwZSB7UmVnRXhwfVxuICogQGNvbnN0XG4gKi9cbnV0aWwua2V5MlJlID0gL150cnVlfGZhbHNlfDB8MSQvO1xuXG4vKipcbiAqIFJlZ3VsYXIgZXhwcmVzc2lvbiB1c2VkIHRvIHZlcmlmeSAzMiBiaXQgKGBpbnQzMmAgZXRjLikgbWFwIGtleXMuXG4gKiBAdHlwZSB7UmVnRXhwfVxuICogQGNvbnN0XG4gKi9cbnV0aWwua2V5MzJSZSA9IC9eLT8oPzowfFsxLTldWzAtOV0qKSQvO1xuXG4vKipcbiAqIFJlZ3VsYXIgZXhwcmVzc2lvbiB1c2VkIHRvIHZlcmlmeSA2NCBiaXQgKGBpbnQ2NGAgZXRjLikgbWFwIGtleXMuXG4gKiBAdHlwZSB7UmVnRXhwfVxuICogQGNvbnN0XG4gKi9cbnV0aWwua2V5NjRSZSA9IC9eKD86W1xcXFx4MDAtXFxcXHhmZl17OH18LT8oPzowfFsxLTldWzAtOV0qKSkkLztcblxuLyoqXG4gKiBDb252ZXJ0cyBhIG51bWJlciBvciBsb25nIHRvIGFuIDggY2hhcmFjdGVycyBsb25nIGhhc2ggc3RyaW5nLlxuICogQHBhcmFtIHtMb25nfG51bWJlcn0gdmFsdWUgVmFsdWUgdG8gY29udmVydFxuICogQHJldHVybnMge3N0cmluZ30gSGFzaFxuICovXG51dGlsLmxvbmdUb0hhc2ggPSBmdW5jdGlvbiBsb25nVG9IYXNoKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlXG4gICAgICAgID8gdXRpbC5Mb25nQml0cy5mcm9tKHZhbHVlKS50b0hhc2goKVxuICAgICAgICA6IHV0aWwuTG9uZ0JpdHMuemVyb0hhc2g7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIDggY2hhcmFjdGVycyBsb25nIGhhc2ggc3RyaW5nIHRvIGEgbG9uZyBvciBudW1iZXIuXG4gKiBAcGFyYW0ge3N0cmluZ30gaGFzaCBIYXNoXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFt1bnNpZ25lZD1mYWxzZV0gV2hldGhlciB1bnNpZ25lZCBvciBub3RcbiAqIEByZXR1cm5zIHtMb25nfG51bWJlcn0gT3JpZ2luYWwgdmFsdWVcbiAqL1xudXRpbC5sb25nRnJvbUhhc2ggPSBmdW5jdGlvbiBsb25nRnJvbUhhc2goaGFzaCwgdW5zaWduZWQpIHtcbiAgICB2YXIgYml0cyA9IHV0aWwuTG9uZ0JpdHMuZnJvbUhhc2goaGFzaCk7XG4gICAgaWYgKHV0aWwuTG9uZylcbiAgICAgICAgcmV0dXJuIHV0aWwuTG9uZy5mcm9tQml0cyhiaXRzLmxvLCBiaXRzLmhpLCB1bnNpZ25lZCk7XG4gICAgcmV0dXJuIGJpdHMudG9OdW1iZXIoQm9vbGVhbih1bnNpZ25lZCkpO1xufTtcblxuLyoqXG4gKiBNZXJnZXMgdGhlIHByb3BlcnRpZXMgb2YgdGhlIHNvdXJjZSBvYmplY3QgaW50byB0aGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQG1lbWJlcm9mIHV0aWxcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IGRzdCBEZXN0aW5hdGlvbiBvYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IHNyYyBTb3VyY2Ugb2JqZWN0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpZk5vdFNldD1mYWxzZV0gTWVyZ2VzIG9ubHkgaWYgdGhlIGtleSBpcyBub3QgYWxyZWFkeSBzZXRcbiAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gRGVzdGluYXRpb24gb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIG1lcmdlKGRzdCwgc3JjLCBpZk5vdFNldCkgeyAvLyB1c2VkIGJ5IGNvbnZlcnRlcnNcbiAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMoc3JjKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICBpZiAoZHN0W2tleXNbaV1dID09PSB1bmRlZmluZWQgfHwgIWlmTm90U2V0KVxuICAgICAgICAgICAgZHN0W2tleXNbaV1dID0gc3JjW2tleXNbaV1dO1xuICAgIHJldHVybiBkc3Q7XG59XG5cbnV0aWwubWVyZ2UgPSBtZXJnZTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIGEgc3RyaW5nIHRvIGxvd2VyIGNhc2UuXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIFN0cmluZyB0byBjb252ZXJ0XG4gKiBAcmV0dXJucyB7c3RyaW5nfSBDb252ZXJ0ZWQgc3RyaW5nXG4gKi9cbnV0aWwubGNGaXJzdCA9IGZ1bmN0aW9uIGxjRmlyc3Qoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKSArIHN0ci5zdWJzdHJpbmcoMSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjdXN0b20gZXJyb3IgY29uc3RydWN0b3IuXG4gKiBAbWVtYmVyb2YgdXRpbFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgRXJyb3IgbmFtZVxuICogQHJldHVybnMge0NvbnN0cnVjdG9yPEVycm9yPn0gQ3VzdG9tIGVycm9yIGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIG5ld0Vycm9yKG5hbWUpIHtcblxuICAgIGZ1bmN0aW9uIEN1c3RvbUVycm9yKG1lc3NhZ2UsIHByb3BlcnRpZXMpIHtcblxuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQ3VzdG9tRXJyb3IpKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDdXN0b21FcnJvcihtZXNzYWdlLCBwcm9wZXJ0aWVzKTtcblxuICAgICAgICAvLyBFcnJvci5jYWxsKHRoaXMsIG1lc3NhZ2UpO1xuICAgICAgICAvLyBeIGp1c3QgcmV0dXJucyBhIG5ldyBlcnJvciBpbnN0YW5jZSBiZWNhdXNlIHRoZSBjdG9yIGNhbiBiZSBjYWxsZWQgYXMgYSBmdW5jdGlvblxuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1lc3NhZ2VcIiwgeyBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbWVzc2FnZTsgfSB9KTtcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIC8vIG5vZGVcbiAgICAgICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIEN1c3RvbUVycm9yKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic3RhY2tcIiwgeyB2YWx1ZTogbmV3IEVycm9yKCkuc3RhY2sgfHwgXCJcIiB9KTtcblxuICAgICAgICBpZiAocHJvcGVydGllcylcbiAgICAgICAgICAgIG1lcmdlKHRoaXMsIHByb3BlcnRpZXMpO1xuICAgIH1cblxuICAgIChDdXN0b21FcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gQ3VzdG9tRXJyb3I7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ3VzdG9tRXJyb3IucHJvdG90eXBlLCBcIm5hbWVcIiwgeyBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbmFtZTsgfSB9KTtcblxuICAgIEN1c3RvbUVycm9yLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uYW1lICsgXCI6IFwiICsgdGhpcy5tZXNzYWdlO1xuICAgIH07XG5cbiAgICByZXR1cm4gQ3VzdG9tRXJyb3I7XG59XG5cbnV0aWwubmV3RXJyb3IgPSBuZXdFcnJvcjtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IHByb3RvY29sIGVycm9yLlxuICogQGNsYXNzZGVzYyBFcnJvciBzdWJjbGFzcyBpbmRpY2F0aW5nIGEgcHJvdG9jb2wgc3BlY2lmYyBlcnJvci5cbiAqIEBtZW1iZXJvZiB1dGlsXG4gKiBAZXh0ZW5kcyBFcnJvclxuICogQHRlbXBsYXRlIFQgZXh0ZW5kcyBNZXNzYWdlPFQ+XG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIEVycm9yIG1lc3NhZ2VcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IFtwcm9wZXJ0aWVzXSBBZGRpdGlvbmFsIHByb3BlcnRpZXNcbiAqIEBleGFtcGxlXG4gKiB0cnkge1xuICogICAgIE15TWVzc2FnZS5kZWNvZGUoc29tZUJ1ZmZlcik7IC8vIHRocm93cyBpZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAqIH0gY2F0Y2ggKGUpIHtcbiAqICAgICBpZiAoZSBpbnN0YW5jZW9mIFByb3RvY29sRXJyb3IgJiYgZS5pbnN0YW5jZSlcbiAqICAgICAgICAgY29uc29sZS5sb2coXCJkZWNvZGVkIHNvIGZhcjogXCIgKyBKU09OLnN0cmluZ2lmeShlLmluc3RhbmNlKSk7XG4gKiB9XG4gKi9cbnV0aWwuUHJvdG9jb2xFcnJvciA9IG5ld0Vycm9yKFwiUHJvdG9jb2xFcnJvclwiKTtcblxuLyoqXG4gKiBTbyBmYXIgZGVjb2RlZCBtZXNzYWdlIGluc3RhbmNlLlxuICogQG5hbWUgdXRpbC5Qcm90b2NvbEVycm9yI2luc3RhbmNlXG4gKiBAdHlwZSB7TWVzc2FnZTxUPn1cbiAqL1xuXG4vKipcbiAqIEEgT25lT2YgZ2V0dGVyIGFzIHJldHVybmVkIGJ5IHtAbGluayB1dGlsLm9uZU9mR2V0dGVyfS5cbiAqIEB0eXBlZGVmIE9uZU9mR2V0dGVyXG4gKiBAdHlwZSB7ZnVuY3Rpb259XG4gKiBAcmV0dXJucyB7c3RyaW5nfHVuZGVmaW5lZH0gU2V0IGZpZWxkIG5hbWUsIGlmIGFueVxuICovXG5cbi8qKlxuICogQnVpbGRzIGEgZ2V0dGVyIGZvciBhIG9uZW9mJ3MgcHJlc2VudCBmaWVsZCBuYW1lLlxuICogQHBhcmFtIHtzdHJpbmdbXX0gZmllbGROYW1lcyBGaWVsZCBuYW1lc1xuICogQHJldHVybnMge09uZU9mR2V0dGVyfSBVbmJvdW5kIGdldHRlclxuICovXG51dGlsLm9uZU9mR2V0dGVyID0gZnVuY3Rpb24gZ2V0T25lT2YoZmllbGROYW1lcykge1xuICAgIHZhciBmaWVsZE1hcCA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmllbGROYW1lcy5sZW5ndGg7ICsraSlcbiAgICAgICAgZmllbGRNYXBbZmllbGROYW1lc1tpXV0gPSAxO1xuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge3N0cmluZ3x1bmRlZmluZWR9IFNldCBmaWVsZCBuYW1lLCBpZiBhbnlcbiAgICAgKiBAdGhpcyBPYmplY3RcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG4gICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyh0aGlzKSwgaSA9IGtleXMubGVuZ3RoIC0gMTsgaSA+IC0xOyAtLWkpXG4gICAgICAgICAgICBpZiAoZmllbGRNYXBba2V5c1tpXV0gPT09IDEgJiYgdGhpc1trZXlzW2ldXSAhPT0gdW5kZWZpbmVkICYmIHRoaXNba2V5c1tpXV0gIT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGtleXNbaV07XG4gICAgfTtcbn07XG5cbi8qKlxuICogQSBPbmVPZiBzZXR0ZXIgYXMgcmV0dXJuZWQgYnkge0BsaW5rIHV0aWwub25lT2ZTZXR0ZXJ9LlxuICogQHR5cGVkZWYgT25lT2ZTZXR0ZXJcbiAqIEB0eXBlIHtmdW5jdGlvbn1cbiAqIEBwYXJhbSB7c3RyaW5nfHVuZGVmaW5lZH0gdmFsdWUgRmllbGQgbmFtZVxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuXG4vKipcbiAqIEJ1aWxkcyBhIHNldHRlciBmb3IgYSBvbmVvZidzIHByZXNlbnQgZmllbGQgbmFtZS5cbiAqIEBwYXJhbSB7c3RyaW5nW119IGZpZWxkTmFtZXMgRmllbGQgbmFtZXNcbiAqIEByZXR1cm5zIHtPbmVPZlNldHRlcn0gVW5ib3VuZCBzZXR0ZXJcbiAqL1xudXRpbC5vbmVPZlNldHRlciA9IGZ1bmN0aW9uIHNldE9uZU9mKGZpZWxkTmFtZXMpIHtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIEZpZWxkIG5hbWVcbiAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgICAqIEB0aGlzIE9iamVjdFxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICByZXR1cm4gZnVuY3Rpb24obmFtZSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpZWxkTmFtZXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICBpZiAoZmllbGROYW1lc1tpXSAhPT0gbmFtZSlcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpc1tmaWVsZE5hbWVzW2ldXTtcbiAgICB9O1xufTtcblxuLyoqXG4gKiBEZWZhdWx0IGNvbnZlcnNpb24gb3B0aW9ucyB1c2VkIGZvciB7QGxpbmsgTWVzc2FnZSN0b0pTT059IGltcGxlbWVudGF0aW9ucy5cbiAqXG4gKiBUaGVzZSBvcHRpb25zIGFyZSBjbG9zZSB0byBwcm90bzMncyBKU09OIG1hcHBpbmcgd2l0aCB0aGUgZXhjZXB0aW9uIHRoYXQgaW50ZXJuYWwgdHlwZXMgbGlrZSBBbnkgYXJlIGhhbmRsZWQganVzdCBsaWtlIG1lc3NhZ2VzLiBNb3JlIHByZWNpc2VseTpcbiAqXG4gKiAtIExvbmdzIGJlY29tZSBzdHJpbmdzXG4gKiAtIEVudW1zIGJlY29tZSBzdHJpbmcga2V5c1xuICogLSBCeXRlcyBiZWNvbWUgYmFzZTY0IGVuY29kZWQgc3RyaW5nc1xuICogLSAoU3ViLSlNZXNzYWdlcyBiZWNvbWUgcGxhaW4gb2JqZWN0c1xuICogLSBNYXBzIGJlY29tZSBwbGFpbiBvYmplY3RzIHdpdGggYWxsIHN0cmluZyBrZXlzXG4gKiAtIFJlcGVhdGVkIGZpZWxkcyBiZWNvbWUgYXJyYXlzXG4gKiAtIE5hTiBhbmQgSW5maW5pdHkgZm9yIGZsb2F0IGFuZCBkb3VibGUgZmllbGRzIGJlY29tZSBzdHJpbmdzXG4gKlxuICogQHR5cGUge0lDb252ZXJzaW9uT3B0aW9uc31cbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vcHJvdG9jb2wtYnVmZmVycy9kb2NzL3Byb3RvMz9obD1lbiNqc29uXG4gKi9cbnV0aWwudG9KU09OT3B0aW9ucyA9IHtcbiAgICBsb25nczogU3RyaW5nLFxuICAgIGVudW1zOiBTdHJpbmcsXG4gICAgYnl0ZXM6IFN0cmluZyxcbiAgICBqc29uOiB0cnVlXG59O1xuXG4vLyBTZXRzIHVwIGJ1ZmZlciB1dGlsaXR5IGFjY29yZGluZyB0byB0aGUgZW52aXJvbm1lbnQgKGNhbGxlZCBpbiBpbmRleC1taW5pbWFsKVxudXRpbC5fY29uZmlndXJlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIEJ1ZmZlciA9IHV0aWwuQnVmZmVyO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghQnVmZmVyKSB7XG4gICAgICAgIHV0aWwuX0J1ZmZlcl9mcm9tID0gdXRpbC5fQnVmZmVyX2FsbG9jVW5zYWZlID0gbnVsbDtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBiZWNhdXNlIG5vZGUgNC54IGJ1ZmZlcnMgYXJlIGluY29tcGF0aWJsZSAmIGltbXV0YWJsZVxuICAgIC8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Rjb2RlSU8vcHJvdG9idWYuanMvcHVsbC82NjVcbiAgICB1dGlsLl9CdWZmZXJfZnJvbSA9IEJ1ZmZlci5mcm9tICE9PSBVaW50OEFycmF5LmZyb20gJiYgQnVmZmVyLmZyb20gfHxcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgZnVuY3Rpb24gQnVmZmVyX2Zyb20odmFsdWUsIGVuY29kaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlcih2YWx1ZSwgZW5jb2RpbmcpO1xuICAgICAgICB9O1xuICAgIHV0aWwuX0J1ZmZlcl9hbGxvY1Vuc2FmZSA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSB8fFxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBmdW5jdGlvbiBCdWZmZXJfYWxsb2NVbnNhZmUoc2l6ZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXIoc2l6ZSk7XG4gICAgICAgIH07XG59O1xuIiwgIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBXcml0ZXI7XG5cbnZhciB1dGlsICAgICAgPSByZXF1aXJlKFwiLi91dGlsL21pbmltYWxcIik7XG5cbnZhciBCdWZmZXJXcml0ZXI7IC8vIGN5Y2xpY1xuXG52YXIgTG9uZ0JpdHMgID0gdXRpbC5Mb25nQml0cyxcbiAgICBiYXNlNjQgICAgPSB1dGlsLmJhc2U2NCxcbiAgICB1dGY4ICAgICAgPSB1dGlsLnV0Zjg7XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyB3cml0ZXIgb3BlcmF0aW9uIGluc3RhbmNlLlxuICogQGNsYXNzZGVzYyBTY2hlZHVsZWQgd3JpdGVyIG9wZXJhdGlvbi5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtmdW5jdGlvbigqLCBVaW50OEFycmF5LCBudW1iZXIpfSBmbiBGdW5jdGlvbiB0byBjYWxsXG4gKiBAcGFyYW0ge251bWJlcn0gbGVuIFZhbHVlIGJ5dGUgbGVuZ3RoXG4gKiBAcGFyYW0geyp9IHZhbCBWYWx1ZSB0byB3cml0ZVxuICogQGlnbm9yZVxuICovXG5mdW5jdGlvbiBPcChmbiwgbGVuLCB2YWwpIHtcblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHRvIGNhbGwuXG4gICAgICogQHR5cGUge2Z1bmN0aW9uKFVpbnQ4QXJyYXksIG51bWJlciwgKil9XG4gICAgICovXG4gICAgdGhpcy5mbiA9IGZuO1xuXG4gICAgLyoqXG4gICAgICogVmFsdWUgYnl0ZSBsZW5ndGguXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmxlbiA9IGxlbjtcblxuICAgIC8qKlxuICAgICAqIE5leHQgb3BlcmF0aW9uLlxuICAgICAqIEB0eXBlIHtXcml0ZXIuT3B8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMubmV4dCA9IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIFZhbHVlIHRvIHdyaXRlLlxuICAgICAqIEB0eXBlIHsqfVxuICAgICAqL1xuICAgIHRoaXMudmFsID0gdmFsOyAvLyB0eXBlIHZhcmllc1xufVxuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gbm9vcCgpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZW1wdHktZnVuY3Rpb25cblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IHdyaXRlciBzdGF0ZSBpbnN0YW5jZS5cbiAqIEBjbGFzc2Rlc2MgQ29waWVkIHdyaXRlciBzdGF0ZS5cbiAqIEBtZW1iZXJvZiBXcml0ZXJcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtXcml0ZXJ9IHdyaXRlciBXcml0ZXIgdG8gY29weSBzdGF0ZSBmcm9tXG4gKiBAaWdub3JlXG4gKi9cbmZ1bmN0aW9uIFN0YXRlKHdyaXRlcikge1xuXG4gICAgLyoqXG4gICAgICogQ3VycmVudCBoZWFkLlxuICAgICAqIEB0eXBlIHtXcml0ZXIuT3B9XG4gICAgICovXG4gICAgdGhpcy5oZWFkID0gd3JpdGVyLmhlYWQ7XG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IHRhaWwuXG4gICAgICogQHR5cGUge1dyaXRlci5PcH1cbiAgICAgKi9cbiAgICB0aGlzLnRhaWwgPSB3cml0ZXIudGFpbDtcblxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgYnVmZmVyIGxlbmd0aC5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubGVuID0gd3JpdGVyLmxlbjtcblxuICAgIC8qKlxuICAgICAqIE5leHQgc3RhdGUuXG4gICAgICogQHR5cGUge1N0YXRlfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5uZXh0ID0gd3JpdGVyLnN0YXRlcztcbn1cblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IHdyaXRlciBpbnN0YW5jZS5cbiAqIEBjbGFzc2Rlc2MgV2lyZSBmb3JtYXQgd3JpdGVyIHVzaW5nIGBVaW50OEFycmF5YCBpZiBhdmFpbGFibGUsIG90aGVyd2lzZSBgQXJyYXlgLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFdyaXRlcigpIHtcblxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgbGVuZ3RoLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5sZW4gPSAwO1xuXG4gICAgLyoqXG4gICAgICogT3BlcmF0aW9ucyBoZWFkLlxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgdGhpcy5oZWFkID0gbmV3IE9wKG5vb3AsIDAsIDApO1xuXG4gICAgLyoqXG4gICAgICogT3BlcmF0aW9ucyB0YWlsXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLnRhaWwgPSB0aGlzLmhlYWQ7XG5cbiAgICAvKipcbiAgICAgKiBMaW5rZWQgZm9ya2VkIHN0YXRlcy5cbiAgICAgKiBAdHlwZSB7T2JqZWN0fG51bGx9XG4gICAgICovXG4gICAgdGhpcy5zdGF0ZXMgPSBudWxsO1xuXG4gICAgLy8gV2hlbiBhIHZhbHVlIGlzIHdyaXR0ZW4sIHRoZSB3cml0ZXIgY2FsY3VsYXRlcyBpdHMgYnl0ZSBsZW5ndGggYW5kIHB1dHMgaXQgaW50byBhIGxpbmtlZFxuICAgIC8vIGxpc3Qgb2Ygb3BlcmF0aW9ucyB0byBwZXJmb3JtIHdoZW4gZmluaXNoKCkgaXMgY2FsbGVkLiBUaGlzIGJvdGggYWxsb3dzIHVzIHRvIGFsbG9jYXRlXG4gICAgLy8gYnVmZmVycyBvZiB0aGUgZXhhY3QgcmVxdWlyZWQgc2l6ZSBhbmQgcmVkdWNlcyB0aGUgYW1vdW50IG9mIHdvcmsgd2UgaGF2ZSB0byBkbyBjb21wYXJlZFxuICAgIC8vIHRvIGZpcnN0IGNhbGN1bGF0aW5nIG92ZXIgb2JqZWN0cyBhbmQgdGhlbiBlbmNvZGluZyBvdmVyIG9iamVjdHMuIEluIG91ciBjYXNlLCB0aGUgZW5jb2RpbmdcbiAgICAvLyBwYXJ0IGlzIGp1c3QgYSBsaW5rZWQgbGlzdCB3YWxrIGNhbGxpbmcgb3BlcmF0aW9ucyB3aXRoIGFscmVhZHkgcHJlcGFyZWQgdmFsdWVzLlxufVxuXG52YXIgY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKCkge1xuICAgIHJldHVybiB1dGlsLkJ1ZmZlclxuICAgICAgICA/IGZ1bmN0aW9uIGNyZWF0ZV9idWZmZXJfc2V0dXAoKSB7XG4gICAgICAgICAgICByZXR1cm4gKFdyaXRlci5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGVfYnVmZmVyKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQnVmZmVyV3JpdGVyKCk7XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICB9XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIDogZnVuY3Rpb24gY3JlYXRlX2FycmF5KCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBXcml0ZXIoKTtcbiAgICAgICAgfTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB3cml0ZXIuXG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtCdWZmZXJXcml0ZXJ8V3JpdGVyfSBBIHtAbGluayBCdWZmZXJXcml0ZXJ9IHdoZW4gQnVmZmVycyBhcmUgc3VwcG9ydGVkLCBvdGhlcndpc2UgYSB7QGxpbmsgV3JpdGVyfVxuICovXG5Xcml0ZXIuY3JlYXRlID0gY3JlYXRlKCk7XG5cbi8qKlxuICogQWxsb2NhdGVzIGEgYnVmZmVyIG9mIHRoZSBzcGVjaWZpZWQgc2l6ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzaXplIEJ1ZmZlciBzaXplXG4gKiBAcmV0dXJucyB7VWludDhBcnJheX0gQnVmZmVyXG4gKi9cbldyaXRlci5hbGxvYyA9IGZ1bmN0aW9uIGFsbG9jKHNpemUpIHtcbiAgICByZXR1cm4gbmV3IHV0aWwuQXJyYXkoc2l6ZSk7XG59O1xuXG4vLyBVc2UgVWludDhBcnJheSBidWZmZXIgcG9vbCBpbiB0aGUgYnJvd3NlciwganVzdCBsaWtlIG5vZGUgZG9lcyB3aXRoIGJ1ZmZlcnNcbi8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG5pZiAodXRpbC5BcnJheSAhPT0gQXJyYXkpXG4gICAgV3JpdGVyLmFsbG9jID0gdXRpbC5wb29sKFdyaXRlci5hbGxvYywgdXRpbC5BcnJheS5wcm90b3R5cGUuc3ViYXJyYXkpO1xuXG4vKipcbiAqIFB1c2hlcyBhIG5ldyBvcGVyYXRpb24gdG8gdGhlIHF1ZXVlLlxuICogQHBhcmFtIHtmdW5jdGlvbihVaW50OEFycmF5LCBudW1iZXIsICopfSBmbiBGdW5jdGlvbiB0byBjYWxsXG4gKiBAcGFyYW0ge251bWJlcn0gbGVuIFZhbHVlIGJ5dGUgbGVuZ3RoXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqIEBwcml2YXRlXG4gKi9cbldyaXRlci5wcm90b3R5cGUuX3B1c2ggPSBmdW5jdGlvbiBwdXNoKGZuLCBsZW4sIHZhbCkge1xuICAgIHRoaXMudGFpbCA9IHRoaXMudGFpbC5uZXh0ID0gbmV3IE9wKGZuLCBsZW4sIHZhbCk7XG4gICAgdGhpcy5sZW4gKz0gbGVuO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gd3JpdGVCeXRlKHZhbCwgYnVmLCBwb3MpIHtcbiAgICBidWZbcG9zXSA9IHZhbCAmIDI1NTtcbn1cblxuZnVuY3Rpb24gd3JpdGVWYXJpbnQzMih2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgd2hpbGUgKHZhbCA+IDEyNykge1xuICAgICAgICBidWZbcG9zKytdID0gdmFsICYgMTI3IHwgMTI4O1xuICAgICAgICB2YWwgPj4+PSA3O1xuICAgIH1cbiAgICBidWZbcG9zXSA9IHZhbDtcbn1cblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IHZhcmludCB3cml0ZXIgb3BlcmF0aW9uIGluc3RhbmNlLlxuICogQGNsYXNzZGVzYyBTY2hlZHVsZWQgdmFyaW50IHdyaXRlciBvcGVyYXRpb24uXG4gKiBAZXh0ZW5kcyBPcFxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge251bWJlcn0gbGVuIFZhbHVlIGJ5dGUgbGVuZ3RoXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsIFZhbHVlIHRvIHdyaXRlXG4gKiBAaWdub3JlXG4gKi9cbmZ1bmN0aW9uIFZhcmludE9wKGxlbiwgdmFsKSB7XG4gICAgdGhpcy5sZW4gPSBsZW47XG4gICAgdGhpcy5uZXh0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMudmFsID0gdmFsO1xufVxuXG5WYXJpbnRPcC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE9wLnByb3RvdHlwZSk7XG5WYXJpbnRPcC5wcm90b3R5cGUuZm4gPSB3cml0ZVZhcmludDMyO1xuXG4vKipcbiAqIFdyaXRlcyBhbiB1bnNpZ25lZCAzMiBiaXQgdmFsdWUgYXMgYSB2YXJpbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLnVpbnQzMiA9IGZ1bmN0aW9uIHdyaXRlX3VpbnQzMih2YWx1ZSkge1xuICAgIC8vIGhlcmUsIHRoZSBjYWxsIHRvIHRoaXMucHVzaCBoYXMgYmVlbiBpbmxpbmVkIGFuZCBhIHZhcmludCBzcGVjaWZpYyBPcCBzdWJjbGFzcyBpcyB1c2VkLlxuICAgIC8vIHVpbnQzMiBpcyBieSBmYXIgdGhlIG1vc3QgZnJlcXVlbnRseSB1c2VkIG9wZXJhdGlvbiBhbmQgYmVuZWZpdHMgc2lnbmlmaWNhbnRseSBmcm9tIHRoaXMuXG4gICAgdGhpcy5sZW4gKz0gKHRoaXMudGFpbCA9IHRoaXMudGFpbC5uZXh0ID0gbmV3IFZhcmludE9wKFxuICAgICAgICAodmFsdWUgPSB2YWx1ZSA+Pj4gMClcbiAgICAgICAgICAgICAgICA8IDEyOCAgICAgICA/IDFcbiAgICAgICAgOiB2YWx1ZSA8IDE2Mzg0ICAgICA/IDJcbiAgICAgICAgOiB2YWx1ZSA8IDIwOTcxNTIgICA/IDNcbiAgICAgICAgOiB2YWx1ZSA8IDI2ODQzNTQ1NiA/IDRcbiAgICAgICAgOiAgICAgICAgICAgICAgICAgICAgIDUsXG4gICAgdmFsdWUpKS5sZW47XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFdyaXRlcyBhIHNpZ25lZCAzMiBiaXQgdmFsdWUgYXMgYSB2YXJpbnQuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUuaW50MzIgPSBmdW5jdGlvbiB3cml0ZV9pbnQzMih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA8IDBcbiAgICAgICAgPyB0aGlzLl9wdXNoKHdyaXRlVmFyaW50NjQsIDEwLCBMb25nQml0cy5mcm9tTnVtYmVyKHZhbHVlKSkgLy8gMTAgYnl0ZXMgcGVyIHNwZWNcbiAgICAgICAgOiB0aGlzLnVpbnQzMih2YWx1ZSk7XG59O1xuXG4vKipcbiAqIFdyaXRlcyBhIDMyIGJpdCB2YWx1ZSBhcyBhIHZhcmludCwgemlnLXphZyBlbmNvZGVkLlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5zaW50MzIgPSBmdW5jdGlvbiB3cml0ZV9zaW50MzIodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy51aW50MzIoKHZhbHVlIDw8IDEgXiB2YWx1ZSA+PiAzMSkgPj4+IDApO1xufTtcblxuZnVuY3Rpb24gd3JpdGVWYXJpbnQ2NCh2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgd2hpbGUgKHZhbC5oaSkge1xuICAgICAgICBidWZbcG9zKytdID0gdmFsLmxvICYgMTI3IHwgMTI4O1xuICAgICAgICB2YWwubG8gPSAodmFsLmxvID4+PiA3IHwgdmFsLmhpIDw8IDI1KSA+Pj4gMDtcbiAgICAgICAgdmFsLmhpID4+Pj0gNztcbiAgICB9XG4gICAgd2hpbGUgKHZhbC5sbyA+IDEyNykge1xuICAgICAgICBidWZbcG9zKytdID0gdmFsLmxvICYgMTI3IHwgMTI4O1xuICAgICAgICB2YWwubG8gPSB2YWwubG8gPj4+IDc7XG4gICAgfVxuICAgIGJ1Zltwb3MrK10gPSB2YWwubG87XG59XG5cbi8qKlxuICogV3JpdGVzIGFuIHVuc2lnbmVkIDY0IGJpdCB2YWx1ZSBhcyBhIHZhcmludC5cbiAqIEBwYXJhbSB7TG9uZ3xudW1iZXJ8c3RyaW5nfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGB2YWx1ZWAgaXMgYSBzdHJpbmcgYW5kIG5vIGxvbmcgbGlicmFyeSBpcyBwcmVzZW50LlxuICovXG5Xcml0ZXIucHJvdG90eXBlLnVpbnQ2NCA9IGZ1bmN0aW9uIHdyaXRlX3VpbnQ2NCh2YWx1ZSkge1xuICAgIHZhciBiaXRzID0gTG9uZ0JpdHMuZnJvbSh2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXMuX3B1c2god3JpdGVWYXJpbnQ2NCwgYml0cy5sZW5ndGgoKSwgYml0cyk7XG59O1xuXG4vKipcbiAqIFdyaXRlcyBhIHNpZ25lZCA2NCBiaXQgdmFsdWUgYXMgYSB2YXJpbnQuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7TG9uZ3xudW1iZXJ8c3RyaW5nfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGB2YWx1ZWAgaXMgYSBzdHJpbmcgYW5kIG5vIGxvbmcgbGlicmFyeSBpcyBwcmVzZW50LlxuICovXG5Xcml0ZXIucHJvdG90eXBlLmludDY0ID0gV3JpdGVyLnByb3RvdHlwZS51aW50NjQ7XG5cbi8qKlxuICogV3JpdGVzIGEgc2lnbmVkIDY0IGJpdCB2YWx1ZSBhcyBhIHZhcmludCwgemlnLXphZyBlbmNvZGVkLlxuICogQHBhcmFtIHtMb25nfG51bWJlcnxzdHJpbmd9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYHZhbHVlYCBpcyBhIHN0cmluZyBhbmQgbm8gbG9uZyBsaWJyYXJ5IGlzIHByZXNlbnQuXG4gKi9cbldyaXRlci5wcm90b3R5cGUuc2ludDY0ID0gZnVuY3Rpb24gd3JpdGVfc2ludDY0KHZhbHVlKSB7XG4gICAgdmFyIGJpdHMgPSBMb25nQml0cy5mcm9tKHZhbHVlKS56ekVuY29kZSgpO1xuICAgIHJldHVybiB0aGlzLl9wdXNoKHdyaXRlVmFyaW50NjQsIGJpdHMubGVuZ3RoKCksIGJpdHMpO1xufTtcblxuLyoqXG4gKiBXcml0ZXMgYSBib29saXNoIHZhbHVlIGFzIGEgdmFyaW50LlxuICogQHBhcmFtIHtib29sZWFufSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUuYm9vbCA9IGZ1bmN0aW9uIHdyaXRlX2Jvb2wodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5fcHVzaCh3cml0ZUJ5dGUsIDEsIHZhbHVlID8gMSA6IDApO1xufTtcblxuZnVuY3Rpb24gd3JpdGVGaXhlZDMyKHZhbCwgYnVmLCBwb3MpIHtcbiAgICBidWZbcG9zICAgIF0gPSAgdmFsICAgICAgICAgJiAyNTU7XG4gICAgYnVmW3BvcyArIDFdID0gIHZhbCA+Pj4gOCAgICYgMjU1O1xuICAgIGJ1Zltwb3MgKyAyXSA9ICB2YWwgPj4+IDE2ICAmIDI1NTtcbiAgICBidWZbcG9zICsgM10gPSAgdmFsID4+PiAyNDtcbn1cblxuLyoqXG4gKiBXcml0ZXMgYW4gdW5zaWduZWQgMzIgYml0IHZhbHVlIGFzIGZpeGVkIDMyIGJpdHMuXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLmZpeGVkMzIgPSBmdW5jdGlvbiB3cml0ZV9maXhlZDMyKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuX3B1c2god3JpdGVGaXhlZDMyLCA0LCB2YWx1ZSA+Pj4gMCk7XG59O1xuXG4vKipcbiAqIFdyaXRlcyBhIHNpZ25lZCAzMiBiaXQgdmFsdWUgYXMgZml4ZWQgMzIgYml0cy5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5zZml4ZWQzMiA9IFdyaXRlci5wcm90b3R5cGUuZml4ZWQzMjtcblxuLyoqXG4gKiBXcml0ZXMgYW4gdW5zaWduZWQgNjQgYml0IHZhbHVlIGFzIGZpeGVkIDY0IGJpdHMuXG4gKiBAcGFyYW0ge0xvbmd8bnVtYmVyfHN0cmluZ30gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBgdmFsdWVgIGlzIGEgc3RyaW5nIGFuZCBubyBsb25nIGxpYnJhcnkgaXMgcHJlc2VudC5cbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5maXhlZDY0ID0gZnVuY3Rpb24gd3JpdGVfZml4ZWQ2NCh2YWx1ZSkge1xuICAgIHZhciBiaXRzID0gTG9uZ0JpdHMuZnJvbSh2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXMuX3B1c2god3JpdGVGaXhlZDMyLCA0LCBiaXRzLmxvKS5fcHVzaCh3cml0ZUZpeGVkMzIsIDQsIGJpdHMuaGkpO1xufTtcblxuLyoqXG4gKiBXcml0ZXMgYSBzaWduZWQgNjQgYml0IHZhbHVlIGFzIGZpeGVkIDY0IGJpdHMuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7TG9uZ3xudW1iZXJ8c3RyaW5nfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGB2YWx1ZWAgaXMgYSBzdHJpbmcgYW5kIG5vIGxvbmcgbGlicmFyeSBpcyBwcmVzZW50LlxuICovXG5Xcml0ZXIucHJvdG90eXBlLnNmaXhlZDY0ID0gV3JpdGVyLnByb3RvdHlwZS5maXhlZDY0O1xuXG4vKipcbiAqIFdyaXRlcyBhIGZsb2F0ICgzMiBiaXQpLlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLmZsb2F0ID0gZnVuY3Rpb24gd3JpdGVfZmxvYXQodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5fcHVzaCh1dGlsLmZsb2F0LndyaXRlRmxvYXRMRSwgNCwgdmFsdWUpO1xufTtcblxuLyoqXG4gKiBXcml0ZXMgYSBkb3VibGUgKDY0IGJpdCBmbG9hdCkuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUuZG91YmxlID0gZnVuY3Rpb24gd3JpdGVfZG91YmxlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuX3B1c2godXRpbC5mbG9hdC53cml0ZURvdWJsZUxFLCA4LCB2YWx1ZSk7XG59O1xuXG52YXIgd3JpdGVCeXRlcyA9IHV0aWwuQXJyYXkucHJvdG90eXBlLnNldFxuICAgID8gZnVuY3Rpb24gd3JpdGVCeXRlc19zZXQodmFsLCBidWYsIHBvcykge1xuICAgICAgICBidWYuc2V0KHZhbCwgcG9zKTsgLy8gYWxzbyB3b3JrcyBmb3IgcGxhaW4gYXJyYXkgdmFsdWVzXG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgOiBmdW5jdGlvbiB3cml0ZUJ5dGVzX2Zvcih2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgYnVmW3BvcyArIGldID0gdmFsW2ldO1xuICAgIH07XG5cbi8qKlxuICogV3JpdGVzIGEgc2VxdWVuY2Ugb2YgYnl0ZXMuXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl8c3RyaW5nfSB2YWx1ZSBCdWZmZXIgb3IgYmFzZTY0IGVuY29kZWQgc3RyaW5nIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5ieXRlcyA9IGZ1bmN0aW9uIHdyaXRlX2J5dGVzKHZhbHVlKSB7XG4gICAgdmFyIGxlbiA9IHZhbHVlLmxlbmd0aCA+Pj4gMDtcbiAgICBpZiAoIWxlbilcbiAgICAgICAgcmV0dXJuIHRoaXMuX3B1c2god3JpdGVCeXRlLCAxLCAwKTtcbiAgICBpZiAodXRpbC5pc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgdmFyIGJ1ZiA9IFdyaXRlci5hbGxvYyhsZW4gPSBiYXNlNjQubGVuZ3RoKHZhbHVlKSk7XG4gICAgICAgIGJhc2U2NC5kZWNvZGUodmFsdWUsIGJ1ZiwgMCk7XG4gICAgICAgIHZhbHVlID0gYnVmO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy51aW50MzIobGVuKS5fcHVzaCh3cml0ZUJ5dGVzLCBsZW4sIHZhbHVlKTtcbn07XG5cbi8qKlxuICogV3JpdGVzIGEgc3RyaW5nLlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5zdHJpbmcgPSBmdW5jdGlvbiB3cml0ZV9zdHJpbmcodmFsdWUpIHtcbiAgICB2YXIgbGVuID0gdXRmOC5sZW5ndGgodmFsdWUpO1xuICAgIHJldHVybiBsZW5cbiAgICAgICAgPyB0aGlzLnVpbnQzMihsZW4pLl9wdXNoKHV0Zjgud3JpdGUsIGxlbiwgdmFsdWUpXG4gICAgICAgIDogdGhpcy5fcHVzaCh3cml0ZUJ5dGUsIDEsIDApO1xufTtcblxuLyoqXG4gKiBGb3JrcyB0aGlzIHdyaXRlcidzIHN0YXRlIGJ5IHB1c2hpbmcgaXQgdG8gYSBzdGFjay5cbiAqIENhbGxpbmcge0BsaW5rIFdyaXRlciNyZXNldHxyZXNldH0gb3Ige0BsaW5rIFdyaXRlciNsZGVsaW18bGRlbGltfSByZXNldHMgdGhlIHdyaXRlciB0byB0aGUgcHJldmlvdXMgc3RhdGUuXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5mb3JrID0gZnVuY3Rpb24gZm9yaygpIHtcbiAgICB0aGlzLnN0YXRlcyA9IG5ldyBTdGF0ZSh0aGlzKTtcbiAgICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBuZXcgT3Aobm9vcCwgMCwgMCk7XG4gICAgdGhpcy5sZW4gPSAwO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZXNldHMgdGhpcyBpbnN0YW5jZSB0byB0aGUgbGFzdCBzdGF0ZS5cbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgaWYgKHRoaXMuc3RhdGVzKSB7XG4gICAgICAgIHRoaXMuaGVhZCAgID0gdGhpcy5zdGF0ZXMuaGVhZDtcbiAgICAgICAgdGhpcy50YWlsICAgPSB0aGlzLnN0YXRlcy50YWlsO1xuICAgICAgICB0aGlzLmxlbiAgICA9IHRoaXMuc3RhdGVzLmxlbjtcbiAgICAgICAgdGhpcy5zdGF0ZXMgPSB0aGlzLnN0YXRlcy5uZXh0O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG5ldyBPcChub29wLCAwLCAwKTtcbiAgICAgICAgdGhpcy5sZW4gID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlc2V0cyB0byB0aGUgbGFzdCBzdGF0ZSBhbmQgYXBwZW5kcyB0aGUgZm9yayBzdGF0ZSdzIGN1cnJlbnQgd3JpdGUgbGVuZ3RoIGFzIGEgdmFyaW50IGZvbGxvd2VkIGJ5IGl0cyBvcGVyYXRpb25zLlxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUubGRlbGltID0gZnVuY3Rpb24gbGRlbGltKCkge1xuICAgIHZhciBoZWFkID0gdGhpcy5oZWFkLFxuICAgICAgICB0YWlsID0gdGhpcy50YWlsLFxuICAgICAgICBsZW4gID0gdGhpcy5sZW47XG4gICAgdGhpcy5yZXNldCgpLnVpbnQzMihsZW4pO1xuICAgIGlmIChsZW4pIHtcbiAgICAgICAgdGhpcy50YWlsLm5leHQgPSBoZWFkLm5leHQ7IC8vIHNraXAgbm9vcFxuICAgICAgICB0aGlzLnRhaWwgPSB0YWlsO1xuICAgICAgICB0aGlzLmxlbiArPSBsZW47XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBGaW5pc2hlcyB0aGUgd3JpdGUgb3BlcmF0aW9uLlxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9IEZpbmlzaGVkIGJ1ZmZlclxuICovXG5Xcml0ZXIucHJvdG90eXBlLmZpbmlzaCA9IGZ1bmN0aW9uIGZpbmlzaCgpIHtcbiAgICB2YXIgaGVhZCA9IHRoaXMuaGVhZC5uZXh0LCAvLyBza2lwIG5vb3BcbiAgICAgICAgYnVmICA9IHRoaXMuY29uc3RydWN0b3IuYWxsb2ModGhpcy5sZW4pLFxuICAgICAgICBwb3MgID0gMDtcbiAgICB3aGlsZSAoaGVhZCkge1xuICAgICAgICBoZWFkLmZuKGhlYWQudmFsLCBidWYsIHBvcyk7XG4gICAgICAgIHBvcyArPSBoZWFkLmxlbjtcbiAgICAgICAgaGVhZCA9IGhlYWQubmV4dDtcbiAgICB9XG4gICAgLy8gdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtcbiAgICByZXR1cm4gYnVmO1xufTtcblxuV3JpdGVyLl9jb25maWd1cmUgPSBmdW5jdGlvbihCdWZmZXJXcml0ZXJfKSB7XG4gICAgQnVmZmVyV3JpdGVyID0gQnVmZmVyV3JpdGVyXztcbiAgICBXcml0ZXIuY3JlYXRlID0gY3JlYXRlKCk7XG4gICAgQnVmZmVyV3JpdGVyLl9jb25maWd1cmUoKTtcbn07XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IEJ1ZmZlcldyaXRlcjtcblxuLy8gZXh0ZW5kcyBXcml0ZXJcbnZhciBXcml0ZXIgPSByZXF1aXJlKFwiLi93cml0ZXJcIik7XG4oQnVmZmVyV3JpdGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoV3JpdGVyLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gQnVmZmVyV3JpdGVyO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWwvbWluaW1hbFwiKTtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IGJ1ZmZlciB3cml0ZXIgaW5zdGFuY2UuXG4gKiBAY2xhc3NkZXNjIFdpcmUgZm9ybWF0IHdyaXRlciB1c2luZyBub2RlIGJ1ZmZlcnMuXG4gKiBAZXh0ZW5kcyBXcml0ZXJcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBCdWZmZXJXcml0ZXIoKSB7XG4gICAgV3JpdGVyLmNhbGwodGhpcyk7XG59XG5cbkJ1ZmZlcldyaXRlci5fY29uZmlndXJlID0gZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEFsbG9jYXRlcyBhIGJ1ZmZlciBvZiB0aGUgc3BlY2lmaWVkIHNpemUuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNpemUgQnVmZmVyIHNpemVcbiAgICAgKiBAcmV0dXJucyB7QnVmZmVyfSBCdWZmZXJcbiAgICAgKi9cbiAgICBCdWZmZXJXcml0ZXIuYWxsb2MgPSB1dGlsLl9CdWZmZXJfYWxsb2NVbnNhZmU7XG5cbiAgICBCdWZmZXJXcml0ZXIud3JpdGVCeXRlc0J1ZmZlciA9IHV0aWwuQnVmZmVyICYmIHV0aWwuQnVmZmVyLnByb3RvdHlwZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgJiYgdXRpbC5CdWZmZXIucHJvdG90eXBlLnNldC5uYW1lID09PSBcInNldFwiXG4gICAgICAgID8gZnVuY3Rpb24gd3JpdGVCeXRlc0J1ZmZlcl9zZXQodmFsLCBidWYsIHBvcykge1xuICAgICAgICAgIGJ1Zi5zZXQodmFsLCBwb3MpOyAvLyBmYXN0ZXIgdGhhbiBjb3B5IChyZXF1aXJlcyBub2RlID49IDQgd2hlcmUgQnVmZmVycyBleHRlbmQgVWludDhBcnJheSBhbmQgc2V0IGlzIHByb3Blcmx5IGluaGVyaXRlZClcbiAgICAgICAgICAvLyBhbHNvIHdvcmtzIGZvciBwbGFpbiBhcnJheSB2YWx1ZXNcbiAgICAgICAgfVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICA6IGZ1bmN0aW9uIHdyaXRlQnl0ZXNCdWZmZXJfY29weSh2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgICAgICAgaWYgKHZhbC5jb3B5KSAvLyBCdWZmZXIgdmFsdWVzXG4gICAgICAgICAgICB2YWwuY29weShidWYsIHBvcywgMCwgdmFsLmxlbmd0aCk7XG4gICAgICAgICAgZWxzZSBmb3IgKHZhciBpID0gMDsgaSA8IHZhbC5sZW5ndGg7KSAvLyBwbGFpbiBhcnJheSB2YWx1ZXNcbiAgICAgICAgICAgIGJ1Zltwb3MrK10gPSB2YWxbaSsrXTtcbiAgICAgICAgfTtcbn07XG5cblxuLyoqXG4gKiBAb3ZlcnJpZGVcbiAqL1xuQnVmZmVyV3JpdGVyLnByb3RvdHlwZS5ieXRlcyA9IGZ1bmN0aW9uIHdyaXRlX2J5dGVzX2J1ZmZlcih2YWx1ZSkge1xuICAgIGlmICh1dGlsLmlzU3RyaW5nKHZhbHVlKSlcbiAgICAgICAgdmFsdWUgPSB1dGlsLl9CdWZmZXJfZnJvbSh2YWx1ZSwgXCJiYXNlNjRcIik7XG4gICAgdmFyIGxlbiA9IHZhbHVlLmxlbmd0aCA+Pj4gMDtcbiAgICB0aGlzLnVpbnQzMihsZW4pO1xuICAgIGlmIChsZW4pXG4gICAgICAgIHRoaXMuX3B1c2goQnVmZmVyV3JpdGVyLndyaXRlQnl0ZXNCdWZmZXIsIGxlbiwgdmFsdWUpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gd3JpdGVTdHJpbmdCdWZmZXIodmFsLCBidWYsIHBvcykge1xuICAgIGlmICh2YWwubGVuZ3RoIDwgNDApIC8vIHBsYWluIGpzIGlzIGZhc3RlciBmb3Igc2hvcnQgc3RyaW5ncyAocHJvYmFibHkgZHVlIHRvIHJlZHVuZGFudCBhc3NlcnRpb25zKVxuICAgICAgICB1dGlsLnV0Zjgud3JpdGUodmFsLCBidWYsIHBvcyk7XG4gICAgZWxzZSBpZiAoYnVmLnV0ZjhXcml0ZSlcbiAgICAgICAgYnVmLnV0ZjhXcml0ZSh2YWwsIHBvcyk7XG4gICAgZWxzZVxuICAgICAgICBidWYud3JpdGUodmFsLCBwb3MpO1xufVxuXG4vKipcbiAqIEBvdmVycmlkZVxuICovXG5CdWZmZXJXcml0ZXIucHJvdG90eXBlLnN0cmluZyA9IGZ1bmN0aW9uIHdyaXRlX3N0cmluZ19idWZmZXIodmFsdWUpIHtcbiAgICB2YXIgbGVuID0gdXRpbC5CdWZmZXIuYnl0ZUxlbmd0aCh2YWx1ZSk7XG4gICAgdGhpcy51aW50MzIobGVuKTtcbiAgICBpZiAobGVuKVxuICAgICAgICB0aGlzLl9wdXNoKHdyaXRlU3RyaW5nQnVmZmVyLCBsZW4sIHZhbHVlKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cblxuLyoqXG4gKiBGaW5pc2hlcyB0aGUgd3JpdGUgb3BlcmF0aW9uLlxuICogQG5hbWUgQnVmZmVyV3JpdGVyI2ZpbmlzaFxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7QnVmZmVyfSBGaW5pc2hlZCBidWZmZXJcbiAqL1xuXG5CdWZmZXJXcml0ZXIuX2NvbmZpZ3VyZSgpO1xuIiwgIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBSZWFkZXI7XG5cbnZhciB1dGlsICAgICAgPSByZXF1aXJlKFwiLi91dGlsL21pbmltYWxcIik7XG5cbnZhciBCdWZmZXJSZWFkZXI7IC8vIGN5Y2xpY1xuXG52YXIgTG9uZ0JpdHMgID0gdXRpbC5Mb25nQml0cyxcbiAgICB1dGY4ICAgICAgPSB1dGlsLnV0Zjg7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBpbmRleE91dE9mUmFuZ2UocmVhZGVyLCB3cml0ZUxlbmd0aCkge1xuICAgIHJldHVybiBSYW5nZUVycm9yKFwiaW5kZXggb3V0IG9mIHJhbmdlOiBcIiArIHJlYWRlci5wb3MgKyBcIiArIFwiICsgKHdyaXRlTGVuZ3RoIHx8IDEpICsgXCIgPiBcIiArIHJlYWRlci5sZW4pO1xufVxuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgcmVhZGVyIGluc3RhbmNlIHVzaW5nIHRoZSBzcGVjaWZpZWQgYnVmZmVyLlxuICogQGNsYXNzZGVzYyBXaXJlIGZvcm1hdCByZWFkZXIgdXNpbmcgYFVpbnQ4QXJyYXlgIGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIGBBcnJheWAuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmZmVyIEJ1ZmZlciB0byByZWFkIGZyb21cbiAqL1xuZnVuY3Rpb24gUmVhZGVyKGJ1ZmZlcikge1xuXG4gICAgLyoqXG4gICAgICogUmVhZCBidWZmZXIuXG4gICAgICogQHR5cGUge1VpbnQ4QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5idWYgPSBidWZmZXI7XG5cbiAgICAvKipcbiAgICAgKiBSZWFkIGJ1ZmZlciBwb3NpdGlvbi5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucG9zID0gMDtcblxuICAgIC8qKlxuICAgICAqIFJlYWQgYnVmZmVyIGxlbmd0aC5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubGVuID0gYnVmZmVyLmxlbmd0aDtcbn1cblxudmFyIGNyZWF0ZV9hcnJheSA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSBcInVuZGVmaW5lZFwiXG4gICAgPyBmdW5jdGlvbiBjcmVhdGVfdHlwZWRfYXJyYXkoYnVmZmVyKSB7XG4gICAgICAgIGlmIChidWZmZXIgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8IEFycmF5LmlzQXJyYXkoYnVmZmVyKSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVhZGVyKGJ1ZmZlcik7XG4gICAgICAgIHRocm93IEVycm9yKFwiaWxsZWdhbCBidWZmZXJcIik7XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgOiBmdW5jdGlvbiBjcmVhdGVfYXJyYXkoYnVmZmVyKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGJ1ZmZlcikpXG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlYWRlcihidWZmZXIpO1xuICAgICAgICB0aHJvdyBFcnJvcihcImlsbGVnYWwgYnVmZmVyXCIpO1xuICAgIH07XG5cbnZhciBjcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gICAgcmV0dXJuIHV0aWwuQnVmZmVyXG4gICAgICAgID8gZnVuY3Rpb24gY3JlYXRlX2J1ZmZlcl9zZXR1cChidWZmZXIpIHtcbiAgICAgICAgICAgIHJldHVybiAoUmVhZGVyLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZV9idWZmZXIoYnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHV0aWwuQnVmZmVyLmlzQnVmZmVyKGJ1ZmZlcilcbiAgICAgICAgICAgICAgICAgICAgPyBuZXcgQnVmZmVyUmVhZGVyKGJ1ZmZlcilcbiAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgICAgICAgICAgOiBjcmVhdGVfYXJyYXkoYnVmZmVyKTtcbiAgICAgICAgICAgIH0pKGJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgOiBjcmVhdGVfYXJyYXk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgcmVhZGVyIHVzaW5nIHRoZSBzcGVjaWZpZWQgYnVmZmVyLlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl8QnVmZmVyfSBidWZmZXIgQnVmZmVyIHRvIHJlYWQgZnJvbVxuICogQHJldHVybnMge1JlYWRlcnxCdWZmZXJSZWFkZXJ9IEEge0BsaW5rIEJ1ZmZlclJlYWRlcn0gaWYgYGJ1ZmZlcmAgaXMgYSBCdWZmZXIsIG90aGVyd2lzZSBhIHtAbGluayBSZWFkZXJ9XG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgYGJ1ZmZlcmAgaXMgbm90IGEgdmFsaWQgYnVmZmVyXG4gKi9cblJlYWRlci5jcmVhdGUgPSBjcmVhdGUoKTtcblxuUmVhZGVyLnByb3RvdHlwZS5fc2xpY2UgPSB1dGlsLkFycmF5LnByb3RvdHlwZS5zdWJhcnJheSB8fCAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyB1dGlsLkFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuLyoqXG4gKiBSZWFkcyBhIHZhcmludCBhcyBhbiB1bnNpZ25lZCAzMiBiaXQgdmFsdWUuXG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcbiAqL1xuUmVhZGVyLnByb3RvdHlwZS51aW50MzIgPSAoZnVuY3Rpb24gcmVhZF91aW50MzJfc2V0dXAoKSB7XG4gICAgdmFyIHZhbHVlID0gNDI5NDk2NzI5NTsgLy8gb3B0aW1pemVyIHR5cGUtaGludCwgdGVuZHMgdG8gZGVvcHQgb3RoZXJ3aXNlICg/ISlcbiAgICByZXR1cm4gZnVuY3Rpb24gcmVhZF91aW50MzIoKSB7XG4gICAgICAgIHZhbHVlID0gKCAgICAgICAgIHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNyAgICAgICApID4+PiAwOyBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpIHJldHVybiB2YWx1ZTtcbiAgICAgICAgdmFsdWUgPSAodmFsdWUgfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA8PCAgNykgPj4+IDA7IGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOCkgcmV0dXJuIHZhbHVlO1xuICAgICAgICB2YWx1ZSA9ICh2YWx1ZSB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpIDw8IDE0KSA+Pj4gMDsgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KSByZXR1cm4gdmFsdWU7XG4gICAgICAgIHZhbHVlID0gKHZhbHVlIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPDwgMjEpID4+PiAwOyBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpIHJldHVybiB2YWx1ZTtcbiAgICAgICAgdmFsdWUgPSAodmFsdWUgfCAodGhpcy5idWZbdGhpcy5wb3NdICYgIDE1KSA8PCAyOCkgPj4+IDA7IGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOCkgcmV0dXJuIHZhbHVlO1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoKHRoaXMucG9zICs9IDUpID4gdGhpcy5sZW4pIHtcbiAgICAgICAgICAgIHRoaXMucG9zID0gdGhpcy5sZW47XG4gICAgICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcywgMTApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xufSkoKTtcblxuLyoqXG4gKiBSZWFkcyBhIHZhcmludCBhcyBhIHNpZ25lZCAzMiBiaXQgdmFsdWUuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXG4gKi9cblJlYWRlci5wcm90b3R5cGUuaW50MzIgPSBmdW5jdGlvbiByZWFkX2ludDMyKCkge1xuICAgIHJldHVybiB0aGlzLnVpbnQzMigpIHwgMDtcbn07XG5cbi8qKlxuICogUmVhZHMgYSB6aWctemFnIGVuY29kZWQgdmFyaW50IGFzIGEgc2lnbmVkIDMyIGJpdCB2YWx1ZS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcbiAqL1xuUmVhZGVyLnByb3RvdHlwZS5zaW50MzIgPSBmdW5jdGlvbiByZWFkX3NpbnQzMigpIHtcbiAgICB2YXIgdmFsdWUgPSB0aGlzLnVpbnQzMigpO1xuICAgIHJldHVybiB2YWx1ZSA+Pj4gMSBeIC0odmFsdWUgJiAxKSB8IDA7XG59O1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1pbnZhbGlkLXRoaXMgKi9cblxuZnVuY3Rpb24gcmVhZExvbmdWYXJpbnQoKSB7XG4gICAgLy8gdGVuZHMgdG8gZGVvcHQgd2l0aCBsb2NhbCB2YXJzIGZvciBvY3RldCBldGMuXG4gICAgdmFyIGJpdHMgPSBuZXcgTG9uZ0JpdHMoMCwgMCk7XG4gICAgdmFyIGkgPSAwO1xuICAgIGlmICh0aGlzLmxlbiAtIHRoaXMucG9zID4gNCkgeyAvLyBmYXN0IHJvdXRlIChsbylcbiAgICAgICAgZm9yICg7IGkgPCA0OyArK2kpIHtcbiAgICAgICAgICAgIC8vIDFzdC4uNHRoXG4gICAgICAgICAgICBiaXRzLmxvID0gKGJpdHMubG8gfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA8PCBpICogNykgPj4+IDA7XG4gICAgICAgICAgICBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJpdHM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gNXRoXG4gICAgICAgIGJpdHMubG8gPSAoYml0cy5sbyB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpIDw8IDI4KSA+Pj4gMDtcbiAgICAgICAgYml0cy5oaSA9IChiaXRzLmhpIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPj4gIDQpID4+PiAwO1xuICAgICAgICBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpXG4gICAgICAgICAgICByZXR1cm4gYml0cztcbiAgICAgICAgaSA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICg7IGkgPCAzOyArK2kpIHtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zID49IHRoaXMubGVuKVxuICAgICAgICAgICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzKTtcbiAgICAgICAgICAgIC8vIDFzdC4uM3RoXG4gICAgICAgICAgICBiaXRzLmxvID0gKGJpdHMubG8gfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA8PCBpICogNykgPj4+IDA7XG4gICAgICAgICAgICBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJpdHM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gNHRoXG4gICAgICAgIGJpdHMubG8gPSAoYml0cy5sbyB8ICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSAmIDEyNykgPDwgaSAqIDcpID4+PiAwO1xuICAgICAgICByZXR1cm4gYml0cztcbiAgICB9XG4gICAgaWYgKHRoaXMubGVuIC0gdGhpcy5wb3MgPiA0KSB7IC8vIGZhc3Qgcm91dGUgKGhpKVxuICAgICAgICBmb3IgKDsgaSA8IDU7ICsraSkge1xuICAgICAgICAgICAgLy8gNnRoLi4xMHRoXG4gICAgICAgICAgICBiaXRzLmhpID0gKGJpdHMuaGkgfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA8PCBpICogNyArIDMpID4+PiAwO1xuICAgICAgICAgICAgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KVxuICAgICAgICAgICAgICAgIHJldHVybiBiaXRzO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICg7IGkgPCA1OyArK2kpIHtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zID49IHRoaXMubGVuKVxuICAgICAgICAgICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzKTtcbiAgICAgICAgICAgIC8vIDZ0aC4uMTB0aFxuICAgICAgICAgICAgYml0cy5oaSA9IChiaXRzLmhpIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPDwgaSAqIDcgKyAzKSA+Pj4gMDtcbiAgICAgICAgICAgIGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOClcbiAgICAgICAgICAgICAgICByZXR1cm4gYml0cztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHRocm93IEVycm9yKFwiaW52YWxpZCB2YXJpbnQgZW5jb2RpbmdcIik7XG59XG5cbi8qIGVzbGludC1lbmFibGUgbm8taW52YWxpZC10aGlzICovXG5cbi8qKlxuICogUmVhZHMgYSB2YXJpbnQgYXMgYSBzaWduZWQgNjQgYml0IHZhbHVlLlxuICogQG5hbWUgUmVhZGVyI2ludDY0XG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtMb25nfSBWYWx1ZSByZWFkXG4gKi9cblxuLyoqXG4gKiBSZWFkcyBhIHZhcmludCBhcyBhbiB1bnNpZ25lZCA2NCBiaXQgdmFsdWUuXG4gKiBAbmFtZSBSZWFkZXIjdWludDY0XG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtMb25nfSBWYWx1ZSByZWFkXG4gKi9cblxuLyoqXG4gKiBSZWFkcyBhIHppZy16YWcgZW5jb2RlZCB2YXJpbnQgYXMgYSBzaWduZWQgNjQgYml0IHZhbHVlLlxuICogQG5hbWUgUmVhZGVyI3NpbnQ2NFxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7TG9uZ30gVmFsdWUgcmVhZFxuICovXG5cbi8qKlxuICogUmVhZHMgYSB2YXJpbnQgYXMgYSBib29sZWFuLlxuICogQHJldHVybnMge2Jvb2xlYW59IFZhbHVlIHJlYWRcbiAqL1xuUmVhZGVyLnByb3RvdHlwZS5ib29sID0gZnVuY3Rpb24gcmVhZF9ib29sKCkge1xuICAgIHJldHVybiB0aGlzLnVpbnQzMigpICE9PSAwO1xufTtcblxuZnVuY3Rpb24gcmVhZEZpeGVkMzJfZW5kKGJ1ZiwgZW5kKSB7IC8vIG5vdGUgdGhhdCB0aGlzIHVzZXMgYGVuZGAsIG5vdCBgcG9zYFxuICAgIHJldHVybiAoYnVmW2VuZCAtIDRdXG4gICAgICAgICAgfCBidWZbZW5kIC0gM10gPDwgOFxuICAgICAgICAgIHwgYnVmW2VuZCAtIDJdIDw8IDE2XG4gICAgICAgICAgfCBidWZbZW5kIC0gMV0gPDwgMjQpID4+PiAwO1xufVxuXG4vKipcbiAqIFJlYWRzIGZpeGVkIDMyIGJpdHMgYXMgYW4gdW5zaWduZWQgMzIgYml0IGludGVnZXIuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXG4gKi9cblJlYWRlci5wcm90b3R5cGUuZml4ZWQzMiA9IGZ1bmN0aW9uIHJlYWRfZml4ZWQzMigpIHtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh0aGlzLnBvcyArIDQgPiB0aGlzLmxlbilcbiAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMsIDQpO1xuXG4gICAgcmV0dXJuIHJlYWRGaXhlZDMyX2VuZCh0aGlzLmJ1ZiwgdGhpcy5wb3MgKz0gNCk7XG59O1xuXG4vKipcbiAqIFJlYWRzIGZpeGVkIDMyIGJpdHMgYXMgYSBzaWduZWQgMzIgYml0IGludGVnZXIuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXG4gKi9cblJlYWRlci5wcm90b3R5cGUuc2ZpeGVkMzIgPSBmdW5jdGlvbiByZWFkX3NmaXhlZDMyKCkge1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHRoaXMucG9zICsgNCA+IHRoaXMubGVuKVxuICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcywgNCk7XG5cbiAgICByZXR1cm4gcmVhZEZpeGVkMzJfZW5kKHRoaXMuYnVmLCB0aGlzLnBvcyArPSA0KSB8IDA7XG59O1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1pbnZhbGlkLXRoaXMgKi9cblxuZnVuY3Rpb24gcmVhZEZpeGVkNjQoLyogdGhpczogUmVhZGVyICovKSB7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAodGhpcy5wb3MgKyA4ID4gdGhpcy5sZW4pXG4gICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLCA4KTtcblxuICAgIHJldHVybiBuZXcgTG9uZ0JpdHMocmVhZEZpeGVkMzJfZW5kKHRoaXMuYnVmLCB0aGlzLnBvcyArPSA0KSwgcmVhZEZpeGVkMzJfZW5kKHRoaXMuYnVmLCB0aGlzLnBvcyArPSA0KSk7XG59XG5cbi8qIGVzbGludC1lbmFibGUgbm8taW52YWxpZC10aGlzICovXG5cbi8qKlxuICogUmVhZHMgZml4ZWQgNjQgYml0cy5cbiAqIEBuYW1lIFJlYWRlciNmaXhlZDY0XG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtMb25nfSBWYWx1ZSByZWFkXG4gKi9cblxuLyoqXG4gKiBSZWFkcyB6aWctemFnIGVuY29kZWQgZml4ZWQgNjQgYml0cy5cbiAqIEBuYW1lIFJlYWRlciNzZml4ZWQ2NFxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7TG9uZ30gVmFsdWUgcmVhZFxuICovXG5cbi8qKlxuICogUmVhZHMgYSBmbG9hdCAoMzIgYml0KSBhcyBhIG51bWJlci5cbiAqIEBmdW5jdGlvblxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxuICovXG5SZWFkZXIucHJvdG90eXBlLmZsb2F0ID0gZnVuY3Rpb24gcmVhZF9mbG9hdCgpIHtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh0aGlzLnBvcyArIDQgPiB0aGlzLmxlbilcbiAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMsIDQpO1xuXG4gICAgdmFyIHZhbHVlID0gdXRpbC5mbG9hdC5yZWFkRmxvYXRMRSh0aGlzLmJ1ZiwgdGhpcy5wb3MpO1xuICAgIHRoaXMucG9zICs9IDQ7XG4gICAgcmV0dXJuIHZhbHVlO1xufTtcblxuLyoqXG4gKiBSZWFkcyBhIGRvdWJsZSAoNjQgYml0IGZsb2F0KSBhcyBhIG51bWJlci5cbiAqIEBmdW5jdGlvblxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxuICovXG5SZWFkZXIucHJvdG90eXBlLmRvdWJsZSA9IGZ1bmN0aW9uIHJlYWRfZG91YmxlKCkge1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHRoaXMucG9zICsgOCA+IHRoaXMubGVuKVxuICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcywgNCk7XG5cbiAgICB2YXIgdmFsdWUgPSB1dGlsLmZsb2F0LnJlYWREb3VibGVMRSh0aGlzLmJ1ZiwgdGhpcy5wb3MpO1xuICAgIHRoaXMucG9zICs9IDg7XG4gICAgcmV0dXJuIHZhbHVlO1xufTtcblxuLyoqXG4gKiBSZWFkcyBhIHNlcXVlbmNlIG9mIGJ5dGVzIHByZWNlZWRlZCBieSBpdHMgbGVuZ3RoIGFzIGEgdmFyaW50LlxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9IFZhbHVlIHJlYWRcbiAqL1xuUmVhZGVyLnByb3RvdHlwZS5ieXRlcyA9IGZ1bmN0aW9uIHJlYWRfYnl0ZXMoKSB7XG4gICAgdmFyIGxlbmd0aCA9IHRoaXMudWludDMyKCksXG4gICAgICAgIHN0YXJ0ICA9IHRoaXMucG9zLFxuICAgICAgICBlbmQgICAgPSB0aGlzLnBvcyArIGxlbmd0aDtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChlbmQgPiB0aGlzLmxlbilcbiAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMsIGxlbmd0aCk7XG5cbiAgICB0aGlzLnBvcyArPSBsZW5ndGg7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5idWYpKSAvLyBwbGFpbiBhcnJheVxuICAgICAgICByZXR1cm4gdGhpcy5idWYuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gICAgcmV0dXJuIHN0YXJ0ID09PSBlbmQgLy8gZml4IGZvciBJRSAxMC9XaW44IGFuZCBvdGhlcnMnIHN1YmFycmF5IHJldHVybmluZyBhcnJheSBvZiBzaXplIDFcbiAgICAgICAgPyBuZXcgdGhpcy5idWYuY29uc3RydWN0b3IoMClcbiAgICAgICAgOiB0aGlzLl9zbGljZS5jYWxsKHRoaXMuYnVmLCBzdGFydCwgZW5kKTtcbn07XG5cbi8qKlxuICogUmVhZHMgYSBzdHJpbmcgcHJlY2VlZGVkIGJ5IGl0cyBieXRlIGxlbmd0aCBhcyBhIHZhcmludC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFZhbHVlIHJlYWRcbiAqL1xuUmVhZGVyLnByb3RvdHlwZS5zdHJpbmcgPSBmdW5jdGlvbiByZWFkX3N0cmluZygpIHtcbiAgICB2YXIgYnl0ZXMgPSB0aGlzLmJ5dGVzKCk7XG4gICAgcmV0dXJuIHV0ZjgucmVhZChieXRlcywgMCwgYnl0ZXMubGVuZ3RoKTtcbn07XG5cbi8qKlxuICogU2tpcHMgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgYnl0ZXMgaWYgc3BlY2lmaWVkLCBvdGhlcndpc2Ugc2tpcHMgYSB2YXJpbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF0gTGVuZ3RoIGlmIGtub3duLCBvdGhlcndpc2UgYSB2YXJpbnQgaXMgYXNzdW1lZFxuICogQHJldHVybnMge1JlYWRlcn0gYHRoaXNgXG4gKi9cblJlYWRlci5wcm90b3R5cGUuc2tpcCA9IGZ1bmN0aW9uIHNraXAobGVuZ3RoKSB7XG4gICAgaWYgKHR5cGVvZiBsZW5ndGggPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICh0aGlzLnBvcyArIGxlbmd0aCA+IHRoaXMubGVuKVxuICAgICAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMsIGxlbmd0aCk7XG4gICAgICAgIHRoaXMucG9zICs9IGxlbmd0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgIGlmICh0aGlzLnBvcyA+PSB0aGlzLmxlbilcbiAgICAgICAgICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcyk7XG4gICAgICAgIH0gd2hpbGUgKHRoaXMuYnVmW3RoaXMucG9zKytdICYgMTI4KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNraXBzIHRoZSBuZXh0IGVsZW1lbnQgb2YgdGhlIHNwZWNpZmllZCB3aXJlIHR5cGUuXG4gKiBAcGFyYW0ge251bWJlcn0gd2lyZVR5cGUgV2lyZSB0eXBlIHJlY2VpdmVkXG4gKiBAcmV0dXJucyB7UmVhZGVyfSBgdGhpc2BcbiAqL1xuUmVhZGVyLnByb3RvdHlwZS5za2lwVHlwZSA9IGZ1bmN0aW9uKHdpcmVUeXBlKSB7XG4gICAgc3dpdGNoICh3aXJlVHlwZSkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICB0aGlzLnNraXAoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICB0aGlzLnNraXAoOCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgdGhpcy5za2lwKHRoaXMudWludDMyKCkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHdoaWxlICgod2lyZVR5cGUgPSB0aGlzLnVpbnQzMigpICYgNykgIT09IDQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNraXBUeXBlKHdpcmVUeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICB0aGlzLnNraXAoNCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJpbnZhbGlkIHdpcmUgdHlwZSBcIiArIHdpcmVUeXBlICsgXCIgYXQgb2Zmc2V0IFwiICsgdGhpcy5wb3MpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cblJlYWRlci5fY29uZmlndXJlID0gZnVuY3Rpb24oQnVmZmVyUmVhZGVyXykge1xuICAgIEJ1ZmZlclJlYWRlciA9IEJ1ZmZlclJlYWRlcl87XG4gICAgUmVhZGVyLmNyZWF0ZSA9IGNyZWF0ZSgpO1xuICAgIEJ1ZmZlclJlYWRlci5fY29uZmlndXJlKCk7XG5cbiAgICB2YXIgZm4gPSB1dGlsLkxvbmcgPyBcInRvTG9uZ1wiIDogLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gXCJ0b051bWJlclwiO1xuICAgIHV0aWwubWVyZ2UoUmVhZGVyLnByb3RvdHlwZSwge1xuXG4gICAgICAgIGludDY0OiBmdW5jdGlvbiByZWFkX2ludDY0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlYWRMb25nVmFyaW50LmNhbGwodGhpcylbZm5dKGZhbHNlKTtcbiAgICAgICAgfSxcblxuICAgICAgICB1aW50NjQ6IGZ1bmN0aW9uIHJlYWRfdWludDY0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlYWRMb25nVmFyaW50LmNhbGwodGhpcylbZm5dKHRydWUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNpbnQ2NDogZnVuY3Rpb24gcmVhZF9zaW50NjQoKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVhZExvbmdWYXJpbnQuY2FsbCh0aGlzKS56ekRlY29kZSgpW2ZuXShmYWxzZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZml4ZWQ2NDogZnVuY3Rpb24gcmVhZF9maXhlZDY0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlYWRGaXhlZDY0LmNhbGwodGhpcylbZm5dKHRydWUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNmaXhlZDY0OiBmdW5jdGlvbiByZWFkX3NmaXhlZDY0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlYWRGaXhlZDY0LmNhbGwodGhpcylbZm5dKGZhbHNlKTtcbiAgICAgICAgfVxuXG4gICAgfSk7XG59O1xuIiwgIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBCdWZmZXJSZWFkZXI7XG5cbi8vIGV4dGVuZHMgUmVhZGVyXG52YXIgUmVhZGVyID0gcmVxdWlyZShcIi4vcmVhZGVyXCIpO1xuKEJ1ZmZlclJlYWRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFJlYWRlci5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IEJ1ZmZlclJlYWRlcjtcblxudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsL21pbmltYWxcIik7XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyBidWZmZXIgcmVhZGVyIGluc3RhbmNlLlxuICogQGNsYXNzZGVzYyBXaXJlIGZvcm1hdCByZWFkZXIgdXNpbmcgbm9kZSBidWZmZXJzLlxuICogQGV4dGVuZHMgUmVhZGVyXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWZmZXIgQnVmZmVyIHRvIHJlYWQgZnJvbVxuICovXG5mdW5jdGlvbiBCdWZmZXJSZWFkZXIoYnVmZmVyKSB7XG4gICAgUmVhZGVyLmNhbGwodGhpcywgYnVmZmVyKTtcblxuICAgIC8qKlxuICAgICAqIFJlYWQgYnVmZmVyLlxuICAgICAqIEBuYW1lIEJ1ZmZlclJlYWRlciNidWZcbiAgICAgKiBAdHlwZSB7QnVmZmVyfVxuICAgICAqL1xufVxuXG5CdWZmZXJSZWFkZXIuX2NvbmZpZ3VyZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmICh1dGlsLkJ1ZmZlcilcbiAgICAgICAgQnVmZmVyUmVhZGVyLnByb3RvdHlwZS5fc2xpY2UgPSB1dGlsLkJ1ZmZlci5wcm90b3R5cGUuc2xpY2U7XG59O1xuXG5cbi8qKlxuICogQG92ZXJyaWRlXG4gKi9cbkJ1ZmZlclJlYWRlci5wcm90b3R5cGUuc3RyaW5nID0gZnVuY3Rpb24gcmVhZF9zdHJpbmdfYnVmZmVyKCkge1xuICAgIHZhciBsZW4gPSB0aGlzLnVpbnQzMigpOyAvLyBtb2RpZmllcyBwb3NcbiAgICByZXR1cm4gdGhpcy5idWYudXRmOFNsaWNlXG4gICAgICAgID8gdGhpcy5idWYudXRmOFNsaWNlKHRoaXMucG9zLCB0aGlzLnBvcyA9IE1hdGgubWluKHRoaXMucG9zICsgbGVuLCB0aGlzLmxlbikpXG4gICAgICAgIDogdGhpcy5idWYudG9TdHJpbmcoXCJ1dGYtOFwiLCB0aGlzLnBvcywgdGhpcy5wb3MgPSBNYXRoLm1pbih0aGlzLnBvcyArIGxlbiwgdGhpcy5sZW4pKTtcbn07XG5cbi8qKlxuICogUmVhZHMgYSBzZXF1ZW5jZSBvZiBieXRlcyBwcmVjZWVkZWQgYnkgaXRzIGxlbmd0aCBhcyBhIHZhcmludC5cbiAqIEBuYW1lIEJ1ZmZlclJlYWRlciNieXRlc1xuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7QnVmZmVyfSBWYWx1ZSByZWFkXG4gKi9cblxuQnVmZmVyUmVhZGVyLl9jb25maWd1cmUoKTtcbiIsICJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gU2VydmljZTtcblxudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbC9taW5pbWFsXCIpO1xuXG4vLyBFeHRlbmRzIEV2ZW50RW1pdHRlclxuKFNlcnZpY2UucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh1dGlsLkV2ZW50RW1pdHRlci5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IFNlcnZpY2U7XG5cbi8qKlxuICogQSBzZXJ2aWNlIG1ldGhvZCBjYWxsYmFjayBhcyB1c2VkIGJ5IHtAbGluayBycGMuU2VydmljZU1ldGhvZHxTZXJ2aWNlTWV0aG9kfS5cbiAqXG4gKiBEaWZmZXJzIGZyb20ge0BsaW5rIFJQQ0ltcGxDYWxsYmFja30gaW4gdGhhdCBpdCBpcyBhbiBhY3R1YWwgY2FsbGJhY2sgb2YgYSBzZXJ2aWNlIG1ldGhvZCB3aGljaCBtYXkgbm90IHJldHVybiBgcmVzcG9uc2UgPSBudWxsYC5cbiAqIEB0eXBlZGVmIHJwYy5TZXJ2aWNlTWV0aG9kQ2FsbGJhY2tcbiAqIEB0ZW1wbGF0ZSBUUmVzIGV4dGVuZHMgTWVzc2FnZTxUUmVzPlxuICogQHR5cGUge2Z1bmN0aW9ufVxuICogQHBhcmFtIHtFcnJvcnxudWxsfSBlcnJvciBFcnJvciwgaWYgYW55XG4gKiBAcGFyYW0ge1RSZXN9IFtyZXNwb25zZV0gUmVzcG9uc2UgbWVzc2FnZVxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuXG4vKipcbiAqIEEgc2VydmljZSBtZXRob2QgcGFydCBvZiBhIHtAbGluayBycGMuU2VydmljZX0gYXMgY3JlYXRlZCBieSB7QGxpbmsgU2VydmljZS5jcmVhdGV9LlxuICogQHR5cGVkZWYgcnBjLlNlcnZpY2VNZXRob2RcbiAqIEB0ZW1wbGF0ZSBUUmVxIGV4dGVuZHMgTWVzc2FnZTxUUmVxPlxuICogQHRlbXBsYXRlIFRSZXMgZXh0ZW5kcyBNZXNzYWdlPFRSZXM+XG4gKiBAdHlwZSB7ZnVuY3Rpb259XG4gKiBAcGFyYW0ge1RSZXF8UHJvcGVydGllczxUUmVxPn0gcmVxdWVzdCBSZXF1ZXN0IG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0XG4gKiBAcGFyYW0ge3JwYy5TZXJ2aWNlTWV0aG9kQ2FsbGJhY2s8VFJlcz59IFtjYWxsYmFja10gTm9kZS1zdHlsZSBjYWxsYmFjayBjYWxsZWQgd2l0aCB0aGUgZXJyb3IsIGlmIGFueSwgYW5kIHRoZSByZXNwb25zZSBtZXNzYWdlXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxNZXNzYWdlPFRSZXM+Pn0gUHJvbWlzZSBpZiBgY2FsbGJhY2tgIGhhcyBiZWVuIG9taXR0ZWQsIG90aGVyd2lzZSBgdW5kZWZpbmVkYFxuICovXG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyBSUEMgc2VydmljZSBpbnN0YW5jZS5cbiAqIEBjbGFzc2Rlc2MgQW4gUlBDIHNlcnZpY2UgYXMgcmV0dXJuZWQgYnkge0BsaW5rIFNlcnZpY2UjY3JlYXRlfS5cbiAqIEBleHBvcnRzIHJwYy5TZXJ2aWNlXG4gKiBAZXh0ZW5kcyB1dGlsLkV2ZW50RW1pdHRlclxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1JQQ0ltcGx9IHJwY0ltcGwgUlBDIGltcGxlbWVudGF0aW9uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXF1ZXN0RGVsaW1pdGVkPWZhbHNlXSBXaGV0aGVyIHJlcXVlc3RzIGFyZSBsZW5ndGgtZGVsaW1pdGVkXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXNwb25zZURlbGltaXRlZD1mYWxzZV0gV2hldGhlciByZXNwb25zZXMgYXJlIGxlbmd0aC1kZWxpbWl0ZWRcbiAqL1xuZnVuY3Rpb24gU2VydmljZShycGNJbXBsLCByZXF1ZXN0RGVsaW1pdGVkLCByZXNwb25zZURlbGltaXRlZCkge1xuXG4gICAgaWYgKHR5cGVvZiBycGNJbXBsICE9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIHRocm93IFR5cGVFcnJvcihcInJwY0ltcGwgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xuXG4gICAgdXRpbC5FdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIFJQQyBpbXBsZW1lbnRhdGlvbi4gQmVjb21lcyBgbnVsbGAgb25jZSB0aGUgc2VydmljZSBpcyBlbmRlZC5cbiAgICAgKiBAdHlwZSB7UlBDSW1wbHxudWxsfVxuICAgICAqL1xuICAgIHRoaXMucnBjSW1wbCA9IHJwY0ltcGw7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHJlcXVlc3RzIGFyZSBsZW5ndGgtZGVsaW1pdGVkLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMucmVxdWVzdERlbGltaXRlZCA9IEJvb2xlYW4ocmVxdWVzdERlbGltaXRlZCk7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHJlc3BvbnNlcyBhcmUgbGVuZ3RoLWRlbGltaXRlZC5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnJlc3BvbnNlRGVsaW1pdGVkID0gQm9vbGVhbihyZXNwb25zZURlbGltaXRlZCk7XG59XG5cbi8qKlxuICogQ2FsbHMgYSBzZXJ2aWNlIG1ldGhvZCB0aHJvdWdoIHtAbGluayBycGMuU2VydmljZSNycGNJbXBsfHJwY0ltcGx9LlxuICogQHBhcmFtIHtNZXRob2R8cnBjLlNlcnZpY2VNZXRob2Q8VFJlcSxUUmVzPn0gbWV0aG9kIFJlZmxlY3RlZCBvciBzdGF0aWMgbWV0aG9kXG4gKiBAcGFyYW0ge0NvbnN0cnVjdG9yPFRSZXE+fSByZXF1ZXN0Q3RvciBSZXF1ZXN0IGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0NvbnN0cnVjdG9yPFRSZXM+fSByZXNwb25zZUN0b3IgUmVzcG9uc2UgY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7VFJlcXxQcm9wZXJ0aWVzPFRSZXE+fSByZXF1ZXN0IFJlcXVlc3QgbWVzc2FnZSBvciBwbGFpbiBvYmplY3RcbiAqIEBwYXJhbSB7cnBjLlNlcnZpY2VNZXRob2RDYWxsYmFjazxUUmVzPn0gY2FsbGJhY2sgU2VydmljZSBjYWxsYmFja1xuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqIEB0ZW1wbGF0ZSBUUmVxIGV4dGVuZHMgTWVzc2FnZTxUUmVxPlxuICogQHRlbXBsYXRlIFRSZXMgZXh0ZW5kcyBNZXNzYWdlPFRSZXM+XG4gKi9cblNlcnZpY2UucHJvdG90eXBlLnJwY0NhbGwgPSBmdW5jdGlvbiBycGNDYWxsKG1ldGhvZCwgcmVxdWVzdEN0b3IsIHJlc3BvbnNlQ3RvciwgcmVxdWVzdCwgY2FsbGJhY2spIHtcblxuICAgIGlmICghcmVxdWVzdClcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwicmVxdWVzdCBtdXN0IGJlIHNwZWNpZmllZFwiKTtcblxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBpZiAoIWNhbGxiYWNrKVxuICAgICAgICByZXR1cm4gdXRpbC5hc1Byb21pc2UocnBjQ2FsbCwgc2VsZiwgbWV0aG9kLCByZXF1ZXN0Q3RvciwgcmVzcG9uc2VDdG9yLCByZXF1ZXN0KTtcblxuICAgIGlmICghc2VsZi5ycGNJbXBsKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IGNhbGxiYWNrKEVycm9yKFwiYWxyZWFkeSBlbmRlZFwiKSk7IH0sIDApO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBzZWxmLnJwY0ltcGwoXG4gICAgICAgICAgICBtZXRob2QsXG4gICAgICAgICAgICByZXF1ZXN0Q3RvcltzZWxmLnJlcXVlc3REZWxpbWl0ZWQgPyBcImVuY29kZURlbGltaXRlZFwiIDogXCJlbmNvZGVcIl0ocmVxdWVzdCkuZmluaXNoKCksXG4gICAgICAgICAgICBmdW5jdGlvbiBycGNDYWxsYmFjayhlcnIsIHJlc3BvbnNlKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZW1pdChcImVycm9yXCIsIGVyciwgbWV0aG9kKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZW5kKC8qIGVuZGVkQnlSUEMgKi8gdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCEocmVzcG9uc2UgaW5zdGFuY2VvZiByZXNwb25zZUN0b3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IHJlc3BvbnNlQ3RvcltzZWxmLnJlc3BvbnNlRGVsaW1pdGVkID8gXCJkZWNvZGVEZWxpbWl0ZWRcIiA6IFwiZGVjb2RlXCJdKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmVtaXQoXCJlcnJvclwiLCBlcnIsIG1ldGhvZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHNlbGYuZW1pdChcImRhdGFcIiwgcmVzcG9uc2UsIG1ldGhvZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgc2VsZi5lbWl0KFwiZXJyb3JcIiwgZXJyLCBtZXRob2QpO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBjYWxsYmFjayhlcnIpOyB9LCAwKTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG59O1xuXG4vKipcbiAqIEVuZHMgdGhpcyBzZXJ2aWNlIGFuZCBlbWl0cyB0aGUgYGVuZGAgZXZlbnQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtlbmRlZEJ5UlBDPWZhbHNlXSBXaGV0aGVyIHRoZSBzZXJ2aWNlIGhhcyBiZWVuIGVuZGVkIGJ5IHRoZSBSUEMgaW1wbGVtZW50YXRpb24uXG4gKiBAcmV0dXJucyB7cnBjLlNlcnZpY2V9IGB0aGlzYFxuICovXG5TZXJ2aWNlLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiBlbmQoZW5kZWRCeVJQQykge1xuICAgIGlmICh0aGlzLnJwY0ltcGwpIHtcbiAgICAgICAgaWYgKCFlbmRlZEJ5UlBDKSAvLyBzaWduYWwgZW5kIHRvIHJwY0ltcGxcbiAgICAgICAgICAgIHRoaXMucnBjSW1wbChudWxsLCBudWxsLCBudWxsKTtcbiAgICAgICAgdGhpcy5ycGNJbXBsID0gbnVsbDtcbiAgICAgICAgdGhpcy5lbWl0KFwiZW5kXCIpLm9mZigpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogU3RyZWFtaW5nIFJQQyBoZWxwZXJzLlxuICogQG5hbWVzcGFjZVxuICovXG52YXIgcnBjID0gZXhwb3J0cztcblxuLyoqXG4gKiBSUEMgaW1wbGVtZW50YXRpb24gcGFzc2VkIHRvIHtAbGluayBTZXJ2aWNlI2NyZWF0ZX0gcGVyZm9ybWluZyBhIHNlcnZpY2UgcmVxdWVzdCBvbiBuZXR3b3JrIGxldmVsLCBpLmUuIGJ5IHV0aWxpemluZyBodHRwIHJlcXVlc3RzIG9yIHdlYnNvY2tldHMuXG4gKiBAdHlwZWRlZiBSUENJbXBsXG4gKiBAdHlwZSB7ZnVuY3Rpb259XG4gKiBAcGFyYW0ge01ldGhvZHxycGMuU2VydmljZU1ldGhvZDxNZXNzYWdlPHt9PixNZXNzYWdlPHt9Pj59IG1ldGhvZCBSZWZsZWN0ZWQgb3Igc3RhdGljIG1ldGhvZCBiZWluZyBjYWxsZWRcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gcmVxdWVzdERhdGEgUmVxdWVzdCBkYXRhXG4gKiBAcGFyYW0ge1JQQ0ltcGxDYWxsYmFja30gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKiBAZXhhbXBsZVxuICogZnVuY3Rpb24gcnBjSW1wbChtZXRob2QsIHJlcXVlc3REYXRhLCBjYWxsYmFjaykge1xuICogICAgIGlmIChwcm90b2J1Zi51dGlsLmxjRmlyc3QobWV0aG9kLm5hbWUpICE9PSBcIm15TWV0aG9kXCIpIC8vIGNvbXBhdGlibGUgd2l0aCBzdGF0aWMgY29kZVxuICogICAgICAgICB0aHJvdyBFcnJvcihcIm5vIHN1Y2ggbWV0aG9kXCIpO1xuICogICAgIGFzeW5jaHJvbm91c2x5T2J0YWluQVJlc3BvbnNlKHJlcXVlc3REYXRhLCBmdW5jdGlvbihlcnIsIHJlc3BvbnNlRGF0YSkge1xuICogICAgICAgICBjYWxsYmFjayhlcnIsIHJlc3BvbnNlRGF0YSk7XG4gKiAgICAgfSk7XG4gKiB9XG4gKi9cblxuLyoqXG4gKiBOb2RlLXN0eWxlIGNhbGxiYWNrIGFzIHVzZWQgYnkge0BsaW5rIFJQQ0ltcGx9LlxuICogQHR5cGVkZWYgUlBDSW1wbENhbGxiYWNrXG4gKiBAdHlwZSB7ZnVuY3Rpb259XG4gKiBAcGFyYW0ge0Vycm9yfG51bGx9IGVycm9yIEVycm9yLCBpZiBhbnksIG90aGVyd2lzZSBgbnVsbGBcbiAqIEBwYXJhbSB7VWludDhBcnJheXxudWxsfSBbcmVzcG9uc2VdIFJlc3BvbnNlIGRhdGEgb3IgYG51bGxgIHRvIHNpZ25hbCBlbmQgb2Ygc3RyZWFtLCBpZiB0aGVyZSBoYXNuJ3QgYmVlbiBhbiBlcnJvclxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuXG5ycGMuU2VydmljZSA9IHJlcXVpcmUoXCIuL3JwYy9zZXJ2aWNlXCIpO1xuIiwgIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLyoqXG4gKiBOYW1lZCByb290cy5cbiAqIFRoaXMgaXMgd2hlcmUgcGJqcyBzdG9yZXMgZ2VuZXJhdGVkIHN0cnVjdHVyZXMgKHRoZSBvcHRpb24gYC1yLCAtLXJvb3RgIHNwZWNpZmllcyBhIG5hbWUpLlxuICogQ2FuIGFsc28gYmUgdXNlZCBtYW51YWxseSB0byBtYWtlIHJvb3RzIGF2YWlsYWJsZSBhY2Nyb3NzIG1vZHVsZXMuXG4gKiBAbmFtZSByb290c1xuICogQHR5cGUge09iamVjdC48c3RyaW5nLFJvb3Q+fVxuICogQGV4YW1wbGVcbiAqIC8vIHBianMgLXIgbXlyb290IC1vIGNvbXBpbGVkLmpzIC4uLlxuICpcbiAqIC8vIGluIGFub3RoZXIgbW9kdWxlOlxuICogcmVxdWlyZShcIi4vY29tcGlsZWQuanNcIik7XG4gKlxuICogLy8gaW4gYW55IHN1YnNlcXVlbnQgbW9kdWxlOlxuICogdmFyIHJvb3QgPSBwcm90b2J1Zi5yb290c1tcIm15cm9vdFwiXTtcbiAqL1xuIiwgIlwidXNlIHN0cmljdFwiO1xudmFyIHByb3RvYnVmID0gZXhwb3J0cztcblxuLyoqXG4gKiBCdWlsZCB0eXBlLCBvbmUgb2YgYFwiZnVsbFwiYCwgYFwibGlnaHRcImAgb3IgYFwibWluaW1hbFwiYC5cbiAqIEBuYW1lIGJ1aWxkXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQGNvbnN0XG4gKi9cbnByb3RvYnVmLmJ1aWxkID0gXCJtaW5pbWFsXCI7XG5cbi8vIFNlcmlhbGl6YXRpb25cbnByb3RvYnVmLldyaXRlciAgICAgICA9IHJlcXVpcmUoXCIuL3dyaXRlclwiKTtcbnByb3RvYnVmLkJ1ZmZlcldyaXRlciA9IHJlcXVpcmUoXCIuL3dyaXRlcl9idWZmZXJcIik7XG5wcm90b2J1Zi5SZWFkZXIgICAgICAgPSByZXF1aXJlKFwiLi9yZWFkZXJcIik7XG5wcm90b2J1Zi5CdWZmZXJSZWFkZXIgPSByZXF1aXJlKFwiLi9yZWFkZXJfYnVmZmVyXCIpO1xuXG4vLyBVdGlsaXR5XG5wcm90b2J1Zi51dGlsICAgICAgICAgPSByZXF1aXJlKFwiLi91dGlsL21pbmltYWxcIik7XG5wcm90b2J1Zi5ycGMgICAgICAgICAgPSByZXF1aXJlKFwiLi9ycGNcIik7XG5wcm90b2J1Zi5yb290cyAgICAgICAgPSByZXF1aXJlKFwiLi9yb290c1wiKTtcbnByb3RvYnVmLmNvbmZpZ3VyZSAgICA9IGNvbmZpZ3VyZTtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbi8qKlxuICogUmVjb25maWd1cmVzIHRoZSBsaWJyYXJ5IGFjY29yZGluZyB0byB0aGUgZW52aXJvbm1lbnQuXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5mdW5jdGlvbiBjb25maWd1cmUoKSB7XG4gICAgcHJvdG9idWYudXRpbC5fY29uZmlndXJlKCk7XG4gICAgcHJvdG9idWYuV3JpdGVyLl9jb25maWd1cmUocHJvdG9idWYuQnVmZmVyV3JpdGVyKTtcbiAgICBwcm90b2J1Zi5SZWFkZXIuX2NvbmZpZ3VyZShwcm90b2J1Zi5CdWZmZXJSZWFkZXIpO1xufVxuXG4vLyBTZXQgdXAgYnVmZmVyIHV0aWxpdHkgYWNjb3JkaW5nIHRvIHRoZSBlbnZpcm9ubWVudFxuY29uZmlndXJlKCk7XG4iLCAiLy8gbWluaW1hbCBsaWJyYXJ5IGVudHJ5IHBvaW50LlxuXG5cInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vc3JjL2luZGV4LW1pbmltYWxcIik7XG4iLCAiJ3VzZSBzdHJpY3QnXG5cbi8qKlxuICogQ29sbGVjdHMgYWxsIHZhbHVlcyBmcm9tIGFuIChhc3luYykgaXRlcmFibGUgaW50byBhbiBhcnJheSBhbmQgcmV0dXJucyBpdC5cbiAqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtBc3luY0l0ZXJhYmxlPFQ+fEl0ZXJhYmxlPFQ+fSBzb3VyY2VcbiAqL1xuY29uc3QgYWxsID0gYXN5bmMgKHNvdXJjZSkgPT4ge1xuICBjb25zdCBhcnIgPSBbXVxuXG4gIGZvciBhd2FpdCAoY29uc3QgZW50cnkgb2Ygc291cmNlKSB7XG4gICAgYXJyLnB1c2goZW50cnkpXG4gIH1cblxuICByZXR1cm4gYXJyXG59XG5cbm1vZHVsZS5leHBvcnRzID0gYWxsXG4iLCAiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgQnVmZmVyIH0gPSByZXF1aXJlKCdidWZmZXInKVxuY29uc3Qgc3ltYm9sID0gU3ltYm9sLmZvcignQnVmZmVyTGlzdCcpXG5cbmZ1bmN0aW9uIEJ1ZmZlckxpc3QgKGJ1Zikge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQnVmZmVyTGlzdCkpIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlckxpc3QoYnVmKVxuICB9XG5cbiAgQnVmZmVyTGlzdC5faW5pdC5jYWxsKHRoaXMsIGJ1Zilcbn1cblxuQnVmZmVyTGlzdC5faW5pdCA9IGZ1bmN0aW9uIF9pbml0IChidWYpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIHN5bWJvbCwgeyB2YWx1ZTogdHJ1ZSB9KVxuXG4gIHRoaXMuX2J1ZnMgPSBbXVxuICB0aGlzLmxlbmd0aCA9IDBcblxuICBpZiAoYnVmKSB7XG4gICAgdGhpcy5hcHBlbmQoYnVmKVxuICB9XG59XG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLl9uZXcgPSBmdW5jdGlvbiBfbmV3IChidWYpIHtcbiAgcmV0dXJuIG5ldyBCdWZmZXJMaXN0KGJ1Zilcbn1cblxuQnVmZmVyTGlzdC5wcm90b3R5cGUuX29mZnNldCA9IGZ1bmN0aW9uIF9vZmZzZXQgKG9mZnNldCkge1xuICBpZiAob2Zmc2V0ID09PSAwKSB7XG4gICAgcmV0dXJuIFswLCAwXVxuICB9XG5cbiAgbGV0IHRvdCA9IDBcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2J1ZnMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBfdCA9IHRvdCArIHRoaXMuX2J1ZnNbaV0ubGVuZ3RoXG4gICAgaWYgKG9mZnNldCA8IF90IHx8IGkgPT09IHRoaXMuX2J1ZnMubGVuZ3RoIC0gMSkge1xuICAgICAgcmV0dXJuIFtpLCBvZmZzZXQgLSB0b3RdXG4gICAgfVxuICAgIHRvdCA9IF90XG4gIH1cbn1cblxuQnVmZmVyTGlzdC5wcm90b3R5cGUuX3JldmVyc2VPZmZzZXQgPSBmdW5jdGlvbiAoYmxPZmZzZXQpIHtcbiAgY29uc3QgYnVmZmVySWQgPSBibE9mZnNldFswXVxuICBsZXQgb2Zmc2V0ID0gYmxPZmZzZXRbMV1cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1ZmZlcklkOyBpKyspIHtcbiAgICBvZmZzZXQgKz0gdGhpcy5fYnVmc1tpXS5sZW5ndGhcbiAgfVxuXG4gIHJldHVybiBvZmZzZXRcbn1cblxuQnVmZmVyTGlzdC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0IChpbmRleCkge1xuICBpZiAoaW5kZXggPiB0aGlzLmxlbmd0aCB8fCBpbmRleCA8IDApIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cblxuICBjb25zdCBvZmZzZXQgPSB0aGlzLl9vZmZzZXQoaW5kZXgpXG5cbiAgcmV0dXJuIHRoaXMuX2J1ZnNbb2Zmc2V0WzBdXVtvZmZzZXRbMV1dXG59XG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ251bWJlcicgJiYgc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmICh0eXBlb2YgZW5kID09PSAnbnVtYmVyJyAmJiBlbmQgPCAwKSB7XG4gICAgZW5kICs9IHRoaXMubGVuZ3RoXG4gIH1cblxuICByZXR1cm4gdGhpcy5jb3B5KG51bGwsIDAsIHN0YXJ0LCBlbmQpXG59XG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5IChkc3QsIGRzdFN0YXJ0LCBzcmNTdGFydCwgc3JjRW5kKSB7XG4gIGlmICh0eXBlb2Ygc3JjU3RhcnQgIT09ICdudW1iZXInIHx8IHNyY1N0YXJ0IDwgMCkge1xuICAgIHNyY1N0YXJ0ID0gMFxuICB9XG5cbiAgaWYgKHR5cGVvZiBzcmNFbmQgIT09ICdudW1iZXInIHx8IHNyY0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgc3JjRW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChzcmNTdGFydCA+PSB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiBkc3QgfHwgQnVmZmVyLmFsbG9jKDApXG4gIH1cblxuICBpZiAoc3JjRW5kIDw9IDApIHtcbiAgICByZXR1cm4gZHN0IHx8IEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgY29uc3QgY29weSA9ICEhZHN0XG4gIGNvbnN0IG9mZiA9IHRoaXMuX29mZnNldChzcmNTdGFydClcbiAgY29uc3QgbGVuID0gc3JjRW5kIC0gc3JjU3RhcnRcbiAgbGV0IGJ5dGVzID0gbGVuXG4gIGxldCBidWZvZmYgPSAoY29weSAmJiBkc3RTdGFydCkgfHwgMFxuICBsZXQgc3RhcnQgPSBvZmZbMV1cblxuICAvLyBjb3B5L3NsaWNlIGV2ZXJ5dGhpbmdcbiAgaWYgKHNyY1N0YXJ0ID09PSAwICYmIHNyY0VuZCA9PT0gdGhpcy5sZW5ndGgpIHtcbiAgICBpZiAoIWNvcHkpIHtcbiAgICAgIC8vIHNsaWNlLCBidXQgZnVsbCBjb25jYXQgaWYgbXVsdGlwbGUgYnVmZmVyc1xuICAgICAgcmV0dXJuIHRoaXMuX2J1ZnMubGVuZ3RoID09PSAxXG4gICAgICAgID8gdGhpcy5fYnVmc1swXVxuICAgICAgICA6IEJ1ZmZlci5jb25jYXQodGhpcy5fYnVmcywgdGhpcy5sZW5ndGgpXG4gICAgfVxuXG4gICAgLy8gY29weSwgbmVlZCB0byBjb3B5IGluZGl2aWR1YWwgYnVmZmVyc1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fYnVmcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5fYnVmc1tpXS5jb3B5KGRzdCwgYnVmb2ZmKVxuICAgICAgYnVmb2ZmICs9IHRoaXMuX2J1ZnNbaV0ubGVuZ3RoXG4gICAgfVxuXG4gICAgcmV0dXJuIGRzdFxuICB9XG5cbiAgLy8gZWFzeSwgY2hlYXAgY2FzZSB3aGVyZSBpdCdzIGEgc3Vic2V0IG9mIG9uZSBvZiB0aGUgYnVmZmVyc1xuICBpZiAoYnl0ZXMgPD0gdGhpcy5fYnVmc1tvZmZbMF1dLmxlbmd0aCAtIHN0YXJ0KSB7XG4gICAgcmV0dXJuIGNvcHlcbiAgICAgID8gdGhpcy5fYnVmc1tvZmZbMF1dLmNvcHkoZHN0LCBkc3RTdGFydCwgc3RhcnQsIHN0YXJ0ICsgYnl0ZXMpXG4gICAgICA6IHRoaXMuX2J1ZnNbb2ZmWzBdXS5zbGljZShzdGFydCwgc3RhcnQgKyBieXRlcylcbiAgfVxuXG4gIGlmICghY29weSkge1xuICAgIC8vIGEgc2xpY2UsIHdlIG5lZWQgc29tZXRoaW5nIHRvIGNvcHkgaW4gdG9cbiAgICBkc3QgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuKVxuICB9XG5cbiAgZm9yIChsZXQgaSA9IG9mZlswXTsgaSA8IHRoaXMuX2J1ZnMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBsID0gdGhpcy5fYnVmc1tpXS5sZW5ndGggLSBzdGFydFxuXG4gICAgaWYgKGJ5dGVzID4gbCkge1xuICAgICAgdGhpcy5fYnVmc1tpXS5jb3B5KGRzdCwgYnVmb2ZmLCBzdGFydClcbiAgICAgIGJ1Zm9mZiArPSBsXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2J1ZnNbaV0uY29weShkc3QsIGJ1Zm9mZiwgc3RhcnQsIHN0YXJ0ICsgYnl0ZXMpXG4gICAgICBidWZvZmYgKz0gbFxuICAgICAgYnJlYWtcbiAgICB9XG5cbiAgICBieXRlcyAtPSBsXG5cbiAgICBpZiAoc3RhcnQpIHtcbiAgICAgIHN0YXJ0ID0gMFxuICAgIH1cbiAgfVxuXG4gIC8vIHNhZmVndWFyZCBzbyB0aGF0IHdlIGRvbid0IHJldHVybiB1bmluaXRpYWxpemVkIG1lbW9yeVxuICBpZiAoZHN0Lmxlbmd0aCA+IGJ1Zm9mZikgcmV0dXJuIGRzdC5zbGljZSgwLCBidWZvZmYpXG5cbiAgcmV0dXJuIGRzdFxufVxuXG5CdWZmZXJMaXN0LnByb3RvdHlwZS5zaGFsbG93U2xpY2UgPSBmdW5jdGlvbiBzaGFsbG93U2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgc3RhcnQgPSBzdGFydCB8fCAwXG4gIGVuZCA9IHR5cGVvZiBlbmQgIT09ICdudW1iZXInID8gdGhpcy5sZW5ndGggOiBlbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoc3RhcnQgPT09IGVuZCkge1xuICAgIHJldHVybiB0aGlzLl9uZXcoKVxuICB9XG5cbiAgY29uc3Qgc3RhcnRPZmZzZXQgPSB0aGlzLl9vZmZzZXQoc3RhcnQpXG4gIGNvbnN0IGVuZE9mZnNldCA9IHRoaXMuX29mZnNldChlbmQpXG4gIGNvbnN0IGJ1ZmZlcnMgPSB0aGlzLl9idWZzLnNsaWNlKHN0YXJ0T2Zmc2V0WzBdLCBlbmRPZmZzZXRbMF0gKyAxKVxuXG4gIGlmIChlbmRPZmZzZXRbMV0gPT09IDApIHtcbiAgICBidWZmZXJzLnBvcCgpXG4gIH0gZWxzZSB7XG4gICAgYnVmZmVyc1tidWZmZXJzLmxlbmd0aCAtIDFdID0gYnVmZmVyc1tidWZmZXJzLmxlbmd0aCAtIDFdLnNsaWNlKDAsIGVuZE9mZnNldFsxXSlcbiAgfVxuXG4gIGlmIChzdGFydE9mZnNldFsxXSAhPT0gMCkge1xuICAgIGJ1ZmZlcnNbMF0gPSBidWZmZXJzWzBdLnNsaWNlKHN0YXJ0T2Zmc2V0WzFdKVxuICB9XG5cbiAgcmV0dXJuIHRoaXMuX25ldyhidWZmZXJzKVxufVxuXG5CdWZmZXJMaXN0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICByZXR1cm4gdGhpcy5zbGljZShzdGFydCwgZW5kKS50b1N0cmluZyhlbmNvZGluZylcbn1cblxuQnVmZmVyTGlzdC5wcm90b3R5cGUuY29uc3VtZSA9IGZ1bmN0aW9uIGNvbnN1bWUgKGJ5dGVzKSB7XG4gIC8vIGZpcnN0LCBub3JtYWxpemUgdGhlIGFyZ3VtZW50LCBpbiBhY2NvcmRhbmNlIHdpdGggaG93IEJ1ZmZlciBkb2VzIGl0XG4gIGJ5dGVzID0gTWF0aC50cnVuYyhieXRlcylcbiAgLy8gZG8gbm90aGluZyBpZiBub3QgYSBwb3NpdGl2ZSBudW1iZXJcbiAgaWYgKE51bWJlci5pc05hTihieXRlcykgfHwgYnl0ZXMgPD0gMCkgcmV0dXJuIHRoaXNcblxuICB3aGlsZSAodGhpcy5fYnVmcy5sZW5ndGgpIHtcbiAgICBpZiAoYnl0ZXMgPj0gdGhpcy5fYnVmc1swXS5sZW5ndGgpIHtcbiAgICAgIGJ5dGVzIC09IHRoaXMuX2J1ZnNbMF0ubGVuZ3RoXG4gICAgICB0aGlzLmxlbmd0aCAtPSB0aGlzLl9idWZzWzBdLmxlbmd0aFxuICAgICAgdGhpcy5fYnVmcy5zaGlmdCgpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2J1ZnNbMF0gPSB0aGlzLl9idWZzWzBdLnNsaWNlKGJ5dGVzKVxuICAgICAgdGhpcy5sZW5ndGggLT0gYnl0ZXNcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyTGlzdC5wcm90b3R5cGUuZHVwbGljYXRlID0gZnVuY3Rpb24gZHVwbGljYXRlICgpIHtcbiAgY29uc3QgY29weSA9IHRoaXMuX25ldygpXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9idWZzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29weS5hcHBlbmQodGhpcy5fYnVmc1tpXSlcbiAgfVxuXG4gIHJldHVybiBjb3B5XG59XG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uIGFwcGVuZCAoYnVmKSB7XG4gIGlmIChidWYgPT0gbnVsbCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBpZiAoYnVmLmJ1ZmZlcikge1xuICAgIC8vIGFwcGVuZCBhIHZpZXcgb2YgdGhlIHVuZGVybHlpbmcgQXJyYXlCdWZmZXJcbiAgICB0aGlzLl9hcHBlbmRCdWZmZXIoQnVmZmVyLmZyb20oYnVmLmJ1ZmZlciwgYnVmLmJ5dGVPZmZzZXQsIGJ1Zi5ieXRlTGVuZ3RoKSlcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGJ1ZikpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1Zi5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5hcHBlbmQoYnVmW2ldKVxuICAgIH1cbiAgfSBlbHNlIGlmICh0aGlzLl9pc0J1ZmZlckxpc3QoYnVmKSkge1xuICAgIC8vIHVud3JhcCBhcmd1bWVudCBpbnRvIGluZGl2aWR1YWwgQnVmZmVyTGlzdHNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1Zi5fYnVmcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5hcHBlbmQoYnVmLl9idWZzW2ldKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBjb2VyY2UgbnVtYmVyIGFyZ3VtZW50cyB0byBzdHJpbmdzLCBzaW5jZSBCdWZmZXIobnVtYmVyKSBkb2VzXG4gICAgLy8gdW5pbml0aWFsaXplZCBtZW1vcnkgYWxsb2NhdGlvblxuICAgIGlmICh0eXBlb2YgYnVmID09PSAnbnVtYmVyJykge1xuICAgICAgYnVmID0gYnVmLnRvU3RyaW5nKClcbiAgICB9XG5cbiAgICB0aGlzLl9hcHBlbmRCdWZmZXIoQnVmZmVyLmZyb20oYnVmKSlcbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLl9hcHBlbmRCdWZmZXIgPSBmdW5jdGlvbiBhcHBlbmRCdWZmZXIgKGJ1Zikge1xuICB0aGlzLl9idWZzLnB1c2goYnVmKVxuICB0aGlzLmxlbmd0aCArPSBidWYubGVuZ3RoXG59XG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiAoc2VhcmNoLCBvZmZzZXQsIGVuY29kaW5nKSB7XG4gIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBvZmZzZXQgPSB1bmRlZmluZWRcbiAgfVxuXG4gIGlmICh0eXBlb2Ygc2VhcmNoID09PSAnZnVuY3Rpb24nIHx8IEFycmF5LmlzQXJyYXkoc2VhcmNoKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQnVmZmVyTGlzdCwgb3IgVWludDhBcnJheS4nKVxuICB9IGVsc2UgaWYgKHR5cGVvZiBzZWFyY2ggPT09ICdudW1iZXInKSB7XG4gICAgc2VhcmNoID0gQnVmZmVyLmZyb20oW3NlYXJjaF0pXG4gIH0gZWxzZSBpZiAodHlwZW9mIHNlYXJjaCA9PT0gJ3N0cmluZycpIHtcbiAgICBzZWFyY2ggPSBCdWZmZXIuZnJvbShzZWFyY2gsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKHRoaXMuX2lzQnVmZmVyTGlzdChzZWFyY2gpKSB7XG4gICAgc2VhcmNoID0gc2VhcmNoLnNsaWNlKClcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHNlYXJjaC5idWZmZXIpKSB7XG4gICAgc2VhcmNoID0gQnVmZmVyLmZyb20oc2VhcmNoLmJ1ZmZlciwgc2VhcmNoLmJ5dGVPZmZzZXQsIHNlYXJjaC5ieXRlTGVuZ3RoKVxuICB9IGVsc2UgaWYgKCFCdWZmZXIuaXNCdWZmZXIoc2VhcmNoKSkge1xuICAgIHNlYXJjaCA9IEJ1ZmZlci5mcm9tKHNlYXJjaClcbiAgfVxuXG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQgfHwgMClcblxuICBpZiAoaXNOYU4ob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IDBcbiAgfVxuXG4gIGlmIChvZmZzZXQgPCAwKSB7XG4gICAgb2Zmc2V0ID0gdGhpcy5sZW5ndGggKyBvZmZzZXRcbiAgfVxuXG4gIGlmIChvZmZzZXQgPCAwKSB7XG4gICAgb2Zmc2V0ID0gMFxuICB9XG5cbiAgaWYgKHNlYXJjaC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gb2Zmc2V0ID4gdGhpcy5sZW5ndGggPyB0aGlzLmxlbmd0aCA6IG9mZnNldFxuICB9XG5cbiAgY29uc3QgYmxPZmZzZXQgPSB0aGlzLl9vZmZzZXQob2Zmc2V0KVxuICBsZXQgYmxJbmRleCA9IGJsT2Zmc2V0WzBdIC8vIGluZGV4IG9mIHdoaWNoIGludGVybmFsIGJ1ZmZlciB3ZSdyZSB3b3JraW5nIG9uXG4gIGxldCBidWZmT2Zmc2V0ID0gYmxPZmZzZXRbMV0gLy8gb2Zmc2V0IG9mIHRoZSBpbnRlcm5hbCBidWZmZXIgd2UncmUgd29ya2luZyBvblxuXG4gIC8vIHNjYW4gb3ZlciBlYWNoIGJ1ZmZlclxuICBmb3IgKDsgYmxJbmRleCA8IHRoaXMuX2J1ZnMubGVuZ3RoOyBibEluZGV4KyspIHtcbiAgICBjb25zdCBidWZmID0gdGhpcy5fYnVmc1tibEluZGV4XVxuXG4gICAgd2hpbGUgKGJ1ZmZPZmZzZXQgPCBidWZmLmxlbmd0aCkge1xuICAgICAgY29uc3QgYXZhaWxhYmxlV2luZG93ID0gYnVmZi5sZW5ndGggLSBidWZmT2Zmc2V0XG5cbiAgICAgIGlmIChhdmFpbGFibGVXaW5kb3cgPj0gc2VhcmNoLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBuYXRpdmVTZWFyY2hSZXN1bHQgPSBidWZmLmluZGV4T2Yoc2VhcmNoLCBidWZmT2Zmc2V0KVxuXG4gICAgICAgIGlmIChuYXRpdmVTZWFyY2hSZXN1bHQgIT09IC0xKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3JldmVyc2VPZmZzZXQoW2JsSW5kZXgsIG5hdGl2ZVNlYXJjaFJlc3VsdF0pXG4gICAgICAgIH1cblxuICAgICAgICBidWZmT2Zmc2V0ID0gYnVmZi5sZW5ndGggLSBzZWFyY2gubGVuZ3RoICsgMSAvLyBlbmQgb2YgbmF0aXZlIHNlYXJjaCB3aW5kb3dcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHJldk9mZnNldCA9IHRoaXMuX3JldmVyc2VPZmZzZXQoW2JsSW5kZXgsIGJ1ZmZPZmZzZXRdKVxuXG4gICAgICAgIGlmICh0aGlzLl9tYXRjaChyZXZPZmZzZXQsIHNlYXJjaCkpIHtcbiAgICAgICAgICByZXR1cm4gcmV2T2Zmc2V0XG4gICAgICAgIH1cblxuICAgICAgICBidWZmT2Zmc2V0KytcbiAgICAgIH1cbiAgICB9XG5cbiAgICBidWZmT2Zmc2V0ID0gMFxuICB9XG5cbiAgcmV0dXJuIC0xXG59XG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLl9tYXRjaCA9IGZ1bmN0aW9uIChvZmZzZXQsIHNlYXJjaCkge1xuICBpZiAodGhpcy5sZW5ndGggLSBvZmZzZXQgPCBzZWFyY2gubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBmb3IgKGxldCBzZWFyY2hPZmZzZXQgPSAwOyBzZWFyY2hPZmZzZXQgPCBzZWFyY2gubGVuZ3RoOyBzZWFyY2hPZmZzZXQrKykge1xuICAgIGlmICh0aGlzLmdldChvZmZzZXQgKyBzZWFyY2hPZmZzZXQpICE9PSBzZWFyY2hbc2VhcmNoT2Zmc2V0XSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlXG59XG5cbjsoZnVuY3Rpb24gKCkge1xuICBjb25zdCBtZXRob2RzID0ge1xuICAgIHJlYWREb3VibGVCRTogOCxcbiAgICByZWFkRG91YmxlTEU6IDgsXG4gICAgcmVhZEZsb2F0QkU6IDQsXG4gICAgcmVhZEZsb2F0TEU6IDQsXG4gICAgcmVhZEludDMyQkU6IDQsXG4gICAgcmVhZEludDMyTEU6IDQsXG4gICAgcmVhZFVJbnQzMkJFOiA0LFxuICAgIHJlYWRVSW50MzJMRTogNCxcbiAgICByZWFkSW50MTZCRTogMixcbiAgICByZWFkSW50MTZMRTogMixcbiAgICByZWFkVUludDE2QkU6IDIsXG4gICAgcmVhZFVJbnQxNkxFOiAyLFxuICAgIHJlYWRJbnQ4OiAxLFxuICAgIHJlYWRVSW50ODogMSxcbiAgICByZWFkSW50QkU6IG51bGwsXG4gICAgcmVhZEludExFOiBudWxsLFxuICAgIHJlYWRVSW50QkU6IG51bGwsXG4gICAgcmVhZFVJbnRMRTogbnVsbFxuICB9XG5cbiAgZm9yIChjb25zdCBtIGluIG1ldGhvZHMpIHtcbiAgICAoZnVuY3Rpb24gKG0pIHtcbiAgICAgIGlmIChtZXRob2RzW21dID09PSBudWxsKSB7XG4gICAgICAgIEJ1ZmZlckxpc3QucHJvdG90eXBlW21dID0gZnVuY3Rpb24gKG9mZnNldCwgYnl0ZUxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgYnl0ZUxlbmd0aClbbV0oMCwgYnl0ZUxlbmd0aClcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgQnVmZmVyTGlzdC5wcm90b3R5cGVbbV0gPSBmdW5jdGlvbiAob2Zmc2V0ID0gMCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgbWV0aG9kc1ttXSlbbV0oMClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0obSkpXG4gIH1cbn0oKSlcblxuLy8gVXNlZCBpbnRlcm5hbGx5IGJ5IHRoZSBjbGFzcyBhbmQgYWxzbyBhcyBhbiBpbmRpY2F0b3Igb2YgdGhpcyBvYmplY3QgYmVpbmdcbi8vIGEgYEJ1ZmZlckxpc3RgLiBJdCdzIG5vdCBwb3NzaWJsZSB0byB1c2UgYGluc3RhbmNlb2YgQnVmZmVyTGlzdGAgaW4gYSBicm93c2VyXG4vLyBlbnZpcm9ubWVudCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG11bHRpcGxlIGRpZmZlcmVudCBjb3BpZXMgb2YgdGhlXG4vLyBCdWZmZXJMaXN0IGNsYXNzIGFuZCBzb21lIGBCdWZmZXJMaXN0YHMgbWlnaHQgYmUgYEJ1ZmZlckxpc3Rgcy5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLl9pc0J1ZmZlckxpc3QgPSBmdW5jdGlvbiBfaXNCdWZmZXJMaXN0IChiKSB7XG4gIHJldHVybiBiIGluc3RhbmNlb2YgQnVmZmVyTGlzdCB8fCBCdWZmZXJMaXN0LmlzQnVmZmVyTGlzdChiKVxufVxuXG5CdWZmZXJMaXN0LmlzQnVmZmVyTGlzdCA9IGZ1bmN0aW9uIGlzQnVmZmVyTGlzdCAoYikge1xuICByZXR1cm4gYiAhPSBudWxsICYmIGJbc3ltYm9sXVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEJ1ZmZlckxpc3RcbiIsICIvKipcbiAqIFJhYmluIGZpbmdlcnByaW50aW5nXG4gKlxuICogQGNsYXNzIFJhYmluXG4gKi9cbmNsYXNzIFJhYmluIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIFJhYmluLlxuICAgICAqIEBwYXJhbSB7IGltcG9ydChcIi4vLi4vZGlzdC9yYWJpbi13YXNtXCIpIH0gYXNNb2R1bGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2JpdHM9MTJdXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFttaW49OCAqIDEwMjRdXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFttYXg9MzIgKiAxMDI0XVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwb2x5bm9taWFsXG4gICAgICogQG1lbWJlcm9mIFJhYmluXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoYXNNb2R1bGUsIGJpdHMgPSAxMiwgbWluID0gOCAqIDEwMjQsIG1heCA9IDMyICogMTAyNCwgd2luZG93U2l6ZSA9IDY0LCBwb2x5bm9taWFsKSB7XG4gICAgICAgIHRoaXMuYml0cyA9IGJpdHNcbiAgICAgICAgdGhpcy5taW4gPSBtaW5cbiAgICAgICAgdGhpcy5tYXggPSBtYXhcbiAgICAgICAgdGhpcy5hc01vZHVsZSA9IGFzTW9kdWxlXG4gICAgICAgIHRoaXMucmFiaW4gPSBuZXcgYXNNb2R1bGUuUmFiaW4oYml0cywgbWluLCBtYXgsIHdpbmRvd1NpemUsIHBvbHlub21pYWwpXG4gICAgICAgIHRoaXMucG9seW5vbWlhbCA9IHBvbHlub21pYWxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaW5nZXJwcmludHMgdGhlIGJ1ZmZlclxuICAgICAqXG4gICAgICogQHBhcmFtIHtVaW50OEFycmF5fSBidWZcbiAgICAgKiBAcmV0dXJucyB7QXJyYXk8bnVtYmVyPn1cbiAgICAgKiBAbWVtYmVyb2YgUmFiaW5cbiAgICAgKi9cbiAgICBmaW5nZXJwcmludChidWYpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgX19yZXRhaW4sXG4gICAgICAgICAgICBfX3JlbGVhc2UsXG4gICAgICAgICAgICBfX2FsbG9jQXJyYXksXG4gICAgICAgICAgICBfX2dldEludDMyQXJyYXksXG4gICAgICAgICAgICBJbnQzMkFycmF5X0lELFxuICAgICAgICAgICAgVWludDhBcnJheV9JRFxuICAgICAgICB9ID0gdGhpcy5hc01vZHVsZVxuXG4gICAgICAgIGNvbnN0IGxlbmd0aHMgPSBuZXcgSW50MzJBcnJheShNYXRoLmNlaWwoYnVmLmxlbmd0aC90aGlzLm1pbikpXG4gICAgICAgIGNvbnN0IGxlbmd0aHNQdHIgPSBfX3JldGFpbihfX2FsbG9jQXJyYXkoSW50MzJBcnJheV9JRCwgbGVuZ3RocykpXG4gICAgICAgIGNvbnN0IHBvaW50ZXIgPSBfX3JldGFpbihfX2FsbG9jQXJyYXkoVWludDhBcnJheV9JRCwgYnVmKSlcblxuICAgICAgICBjb25zdCBvdXQgPSB0aGlzLnJhYmluLmZpbmdlcnByaW50KHBvaW50ZXIsIGxlbmd0aHNQdHIpXG4gICAgICAgIGNvbnN0IHByb2Nlc3NlZCA9IF9fZ2V0SW50MzJBcnJheShvdXQpXG5cbiAgICAgICAgX19yZWxlYXNlKHBvaW50ZXIpXG4gICAgICAgIF9fcmVsZWFzZShsZW5ndGhzUHRyKVxuXG4gICAgICAgIGNvbnN0IGVuZCA9IHByb2Nlc3NlZC5pbmRleE9mKDApO1xuICAgICAgICByZXR1cm4gZW5kID49IDAgPyBwcm9jZXNzZWQuc3ViYXJyYXkoMCwgZW5kKSA6IHByb2Nlc3NlZDtcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmFiaW4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIFJ1bnRpbWUgaGVhZGVyIG9mZnNldHNcbmNvbnN0IElEX09GRlNFVCA9IC04O1xuY29uc3QgU0laRV9PRkZTRVQgPSAtNDtcblxuLy8gUnVudGltZSBpZHNcbmNvbnN0IEFSUkFZQlVGRkVSX0lEID0gMDtcbmNvbnN0IFNUUklOR19JRCA9IDE7XG5jb25zdCBBUlJBWUJVRkZFUlZJRVdfSUQgPSAyO1xuXG4vLyBSdW50aW1lIHR5cGUgaW5mb3JtYXRpb25cbmNvbnN0IEFSUkFZQlVGRkVSVklFVyA9IDEgPDwgMDtcbmNvbnN0IEFSUkFZID0gMSA8PCAxO1xuY29uc3QgU0VUID0gMSA8PCAyO1xuY29uc3QgTUFQID0gMSA8PCAzO1xuY29uc3QgVkFMX0FMSUdOX09GRlNFVCA9IDU7XG5jb25zdCBWQUxfQUxJR04gPSAxIDw8IFZBTF9BTElHTl9PRkZTRVQ7XG5jb25zdCBWQUxfU0lHTkVEID0gMSA8PCAxMDtcbmNvbnN0IFZBTF9GTE9BVCA9IDEgPDwgMTE7XG5jb25zdCBWQUxfTlVMTEFCTEUgPSAxIDw8IDEyO1xuY29uc3QgVkFMX01BTkFHRUQgPSAxIDw8IDEzO1xuY29uc3QgS0VZX0FMSUdOX09GRlNFVCA9IDE0O1xuY29uc3QgS0VZX0FMSUdOID0gMSA8PCBLRVlfQUxJR05fT0ZGU0VUO1xuY29uc3QgS0VZX1NJR05FRCA9IDEgPDwgMTk7XG5jb25zdCBLRVlfRkxPQVQgPSAxIDw8IDIwO1xuY29uc3QgS0VZX05VTExBQkxFID0gMSA8PCAyMTtcbmNvbnN0IEtFWV9NQU5BR0VEID0gMSA8PCAyMjtcblxuLy8gQXJyYXkoQnVmZmVyVmlldykgbGF5b3V0XG5jb25zdCBBUlJBWUJVRkZFUlZJRVdfQlVGRkVSX09GRlNFVCA9IDA7XG5jb25zdCBBUlJBWUJVRkZFUlZJRVdfREFUQVNUQVJUX09GRlNFVCA9IDQ7XG5jb25zdCBBUlJBWUJVRkZFUlZJRVdfREFUQUxFTkdUSF9PRkZTRVQgPSA4O1xuY29uc3QgQVJSQVlCVUZGRVJWSUVXX1NJWkUgPSAxMjtcbmNvbnN0IEFSUkFZX0xFTkdUSF9PRkZTRVQgPSAxMjtcbmNvbnN0IEFSUkFZX1NJWkUgPSAxNjtcblxuY29uc3QgQklHSU5UID0gdHlwZW9mIEJpZ1VpbnQ2NEFycmF5ICE9PSBcInVuZGVmaW5lZFwiO1xuY29uc3QgVEhJUyA9IFN5bWJvbCgpO1xuY29uc3QgQ0hVTktTSVpFID0gMTAyNDtcblxuLyoqIEdldHMgYSBzdHJpbmcgZnJvbSBhbiBVMzIgYW5kIGFuIFUxNiB2aWV3IG9uIGEgbWVtb3J5LiAqL1xuZnVuY3Rpb24gZ2V0U3RyaW5nSW1wbChidWZmZXIsIHB0cikge1xuICBjb25zdCBVMzIgPSBuZXcgVWludDMyQXJyYXkoYnVmZmVyKTtcbiAgY29uc3QgVTE2ID0gbmV3IFVpbnQxNkFycmF5KGJ1ZmZlcik7XG4gIHZhciBsZW5ndGggPSBVMzJbKHB0ciArIFNJWkVfT0ZGU0VUKSA+Pj4gMl0gPj4+IDE7XG4gIHZhciBvZmZzZXQgPSBwdHIgPj4+IDE7XG4gIGlmIChsZW5ndGggPD0gQ0hVTktTSVpFKSByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIFUxNi5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIGxlbmd0aCkpO1xuICBjb25zdCBwYXJ0cyA9IFtdO1xuICBkbyB7XG4gICAgY29uc3QgbGFzdCA9IFUxNltvZmZzZXQgKyBDSFVOS1NJWkUgLSAxXTtcbiAgICBjb25zdCBzaXplID0gbGFzdCA+PSAweEQ4MDAgJiYgbGFzdCA8IDB4REMwMCA/IENIVU5LU0laRSAtIDEgOiBDSFVOS1NJWkU7XG4gICAgcGFydHMucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgVTE2LnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICs9IHNpemUpKSk7XG4gICAgbGVuZ3RoIC09IHNpemU7XG4gIH0gd2hpbGUgKGxlbmd0aCA+IENIVU5LU0laRSk7XG4gIHJldHVybiBwYXJ0cy5qb2luKFwiXCIpICsgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIFUxNi5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIGxlbmd0aCkpO1xufVxuXG4vKiogUHJlcGFyZXMgdGhlIGJhc2UgbW9kdWxlIHByaW9yIHRvIGluc3RhbnRpYXRpb24uICovXG5mdW5jdGlvbiBwcmVJbnN0YW50aWF0ZShpbXBvcnRzKSB7XG4gIGNvbnN0IGJhc2VNb2R1bGUgPSB7fTtcblxuICBmdW5jdGlvbiBnZXRTdHJpbmcobWVtb3J5LCBwdHIpIHtcbiAgICBpZiAoIW1lbW9yeSkgcmV0dXJuIFwiPHlldCB1bmtub3duPlwiO1xuICAgIHJldHVybiBnZXRTdHJpbmdJbXBsKG1lbW9yeS5idWZmZXIsIHB0cik7XG4gIH1cblxuICAvLyBhZGQgY29tbW9uIGltcG9ydHMgdXNlZCBieSBzdGRsaWIgZm9yIGNvbnZlbmllbmNlXG4gIGNvbnN0IGVudiA9IChpbXBvcnRzLmVudiA9IGltcG9ydHMuZW52IHx8IHt9KTtcbiAgZW52LmFib3J0ID0gZW52LmFib3J0IHx8IGZ1bmN0aW9uIGFib3J0KG1lc2csIGZpbGUsIGxpbmUsIGNvbG0pIHtcbiAgICBjb25zdCBtZW1vcnkgPSBiYXNlTW9kdWxlLm1lbW9yeSB8fCBlbnYubWVtb3J5OyAvLyBwcmVmZXIgZXhwb3J0ZWQsIG90aGVyd2lzZSB0cnkgaW1wb3J0ZWRcbiAgICB0aHJvdyBFcnJvcihcImFib3J0OiBcIiArIGdldFN0cmluZyhtZW1vcnksIG1lc2cpICsgXCIgYXQgXCIgKyBnZXRTdHJpbmcobWVtb3J5LCBmaWxlKSArIFwiOlwiICsgbGluZSArIFwiOlwiICsgY29sbSk7XG4gIH1cbiAgZW52LnRyYWNlID0gZW52LnRyYWNlIHx8IGZ1bmN0aW9uIHRyYWNlKG1lc2csIG4pIHtcbiAgICBjb25zdCBtZW1vcnkgPSBiYXNlTW9kdWxlLm1lbW9yeSB8fCBlbnYubWVtb3J5O1xuICAgIGNvbnNvbGUubG9nKFwidHJhY2U6IFwiICsgZ2V0U3RyaW5nKG1lbW9yeSwgbWVzZykgKyAobiA/IFwiIFwiIDogXCJcIikgKyBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIsIDIgKyBuKS5qb2luKFwiLCBcIikpO1xuICB9XG4gIGltcG9ydHMuTWF0aCA9IGltcG9ydHMuTWF0aCB8fCBNYXRoO1xuICBpbXBvcnRzLkRhdGUgPSBpbXBvcnRzLkRhdGUgfHwgRGF0ZTtcblxuICByZXR1cm4gYmFzZU1vZHVsZTtcbn1cblxuLyoqIFByZXBhcmVzIHRoZSBmaW5hbCBtb2R1bGUgb25jZSBpbnN0YW50aWF0aW9uIGlzIGNvbXBsZXRlLiAqL1xuZnVuY3Rpb24gcG9zdEluc3RhbnRpYXRlKGJhc2VNb2R1bGUsIGluc3RhbmNlKSB7XG4gIGNvbnN0IHJhd0V4cG9ydHMgPSBpbnN0YW5jZS5leHBvcnRzO1xuICBjb25zdCBtZW1vcnkgPSByYXdFeHBvcnRzLm1lbW9yeTtcbiAgY29uc3QgdGFibGUgPSByYXdFeHBvcnRzLnRhYmxlO1xuICBjb25zdCBhbGxvYyA9IHJhd0V4cG9ydHNbXCJfX2FsbG9jXCJdO1xuICBjb25zdCByZXRhaW4gPSByYXdFeHBvcnRzW1wiX19yZXRhaW5cIl07XG4gIGNvbnN0IHJ0dGlCYXNlID0gcmF3RXhwb3J0c1tcIl9fcnR0aV9iYXNlXCJdIHx8IH4wOyAvLyBvb2IgaWYgbm90IHByZXNlbnRcblxuICAvKiogR2V0cyB0aGUgcnVudGltZSB0eXBlIGluZm8gZm9yIHRoZSBnaXZlbiBpZC4gKi9cbiAgZnVuY3Rpb24gZ2V0SW5mbyhpZCkge1xuICAgIGNvbnN0IFUzMiA9IG5ldyBVaW50MzJBcnJheShtZW1vcnkuYnVmZmVyKTtcbiAgICBjb25zdCBjb3VudCA9IFUzMltydHRpQmFzZSA+Pj4gMl07XG4gICAgaWYgKChpZCA+Pj49IDApID49IGNvdW50KSB0aHJvdyBFcnJvcihcImludmFsaWQgaWQ6IFwiICsgaWQpO1xuICAgIHJldHVybiBVMzJbKHJ0dGlCYXNlICsgNCA+Pj4gMikgKyBpZCAqIDJdO1xuICB9XG5cbiAgLyoqIEdldHMgdGhlIHJ1bnRpbWUgYmFzZSBpZCBmb3IgdGhlIGdpdmVuIGlkLiAqL1xuICBmdW5jdGlvbiBnZXRCYXNlKGlkKSB7XG4gICAgY29uc3QgVTMyID0gbmV3IFVpbnQzMkFycmF5KG1lbW9yeS5idWZmZXIpO1xuICAgIGNvbnN0IGNvdW50ID0gVTMyW3J0dGlCYXNlID4+PiAyXTtcbiAgICBpZiAoKGlkID4+Pj0gMCkgPj0gY291bnQpIHRocm93IEVycm9yKFwiaW52YWxpZCBpZDogXCIgKyBpZCk7XG4gICAgcmV0dXJuIFUzMlsocnR0aUJhc2UgKyA0ID4+PiAyKSArIGlkICogMiArIDFdO1xuICB9XG5cbiAgLyoqIEdldHMgdGhlIHJ1bnRpbWUgYWxpZ25tZW50IG9mIGEgY29sbGVjdGlvbidzIHZhbHVlcy4gKi9cbiAgZnVuY3Rpb24gZ2V0VmFsdWVBbGlnbihpbmZvKSB7XG4gICAgcmV0dXJuIDMxIC0gTWF0aC5jbHozMigoaW5mbyA+Pj4gVkFMX0FMSUdOX09GRlNFVCkgJiAzMSk7IC8vIC0xIGlmIG5vbmVcbiAgfVxuXG4gIC8qKiBHZXRzIHRoZSBydW50aW1lIGFsaWdubWVudCBvZiBhIGNvbGxlY3Rpb24ncyBrZXlzLiAqL1xuICBmdW5jdGlvbiBnZXRLZXlBbGlnbihpbmZvKSB7XG4gICAgcmV0dXJuIDMxIC0gTWF0aC5jbHozMigoaW5mbyA+Pj4gS0VZX0FMSUdOX09GRlNFVCkgJiAzMSk7IC8vIC0xIGlmIG5vbmVcbiAgfVxuXG4gIC8qKiBBbGxvY2F0ZXMgYSBuZXcgc3RyaW5nIGluIHRoZSBtb2R1bGUncyBtZW1vcnkgYW5kIHJldHVybnMgaXRzIHJldGFpbmVkIHBvaW50ZXIuICovXG4gIGZ1bmN0aW9uIF9fYWxsb2NTdHJpbmcoc3RyKSB7XG4gICAgY29uc3QgbGVuZ3RoID0gc3RyLmxlbmd0aDtcbiAgICBjb25zdCBwdHIgPSBhbGxvYyhsZW5ndGggPDwgMSwgU1RSSU5HX0lEKTtcbiAgICBjb25zdCBVMTYgPSBuZXcgVWludDE2QXJyYXkobWVtb3J5LmJ1ZmZlcik7XG4gICAgZm9yICh2YXIgaSA9IDAsIHAgPSBwdHIgPj4+IDE7IGkgPCBsZW5ndGg7ICsraSkgVTE2W3AgKyBpXSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgIHJldHVybiBwdHI7XG4gIH1cblxuICBiYXNlTW9kdWxlLl9fYWxsb2NTdHJpbmcgPSBfX2FsbG9jU3RyaW5nO1xuXG4gIC8qKiBSZWFkcyBhIHN0cmluZyBmcm9tIHRoZSBtb2R1bGUncyBtZW1vcnkgYnkgaXRzIHBvaW50ZXIuICovXG4gIGZ1bmN0aW9uIF9fZ2V0U3RyaW5nKHB0cikge1xuICAgIGNvbnN0IGJ1ZmZlciA9IG1lbW9yeS5idWZmZXI7XG4gICAgY29uc3QgaWQgPSBuZXcgVWludDMyQXJyYXkoYnVmZmVyKVtwdHIgKyBJRF9PRkZTRVQgPj4+IDJdO1xuICAgIGlmIChpZCAhPT0gU1RSSU5HX0lEKSB0aHJvdyBFcnJvcihcIm5vdCBhIHN0cmluZzogXCIgKyBwdHIpO1xuICAgIHJldHVybiBnZXRTdHJpbmdJbXBsKGJ1ZmZlciwgcHRyKTtcbiAgfVxuXG4gIGJhc2VNb2R1bGUuX19nZXRTdHJpbmcgPSBfX2dldFN0cmluZztcblxuICAvKiogR2V0cyB0aGUgdmlldyBtYXRjaGluZyB0aGUgc3BlY2lmaWVkIGFsaWdubWVudCwgc2lnbmVkbmVzcyBhbmQgZmxvYXRuZXNzLiAqL1xuICBmdW5jdGlvbiBnZXRWaWV3KGFsaWduTG9nMiwgc2lnbmVkLCBmbG9hdCkge1xuICAgIGNvbnN0IGJ1ZmZlciA9IG1lbW9yeS5idWZmZXI7XG4gICAgaWYgKGZsb2F0KSB7XG4gICAgICBzd2l0Y2ggKGFsaWduTG9nMikge1xuICAgICAgICBjYXNlIDI6IHJldHVybiBuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlcik7XG4gICAgICAgIGNhc2UgMzogcmV0dXJuIG5ldyBGbG9hdDY0QXJyYXkoYnVmZmVyKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3dpdGNoIChhbGlnbkxvZzIpIHtcbiAgICAgICAgY2FzZSAwOiByZXR1cm4gbmV3IChzaWduZWQgPyBJbnQ4QXJyYXkgOiBVaW50OEFycmF5KShidWZmZXIpO1xuICAgICAgICBjYXNlIDE6IHJldHVybiBuZXcgKHNpZ25lZCA/IEludDE2QXJyYXkgOiBVaW50MTZBcnJheSkoYnVmZmVyKTtcbiAgICAgICAgY2FzZSAyOiByZXR1cm4gbmV3IChzaWduZWQgPyBJbnQzMkFycmF5IDogVWludDMyQXJyYXkpKGJ1ZmZlcik7XG4gICAgICAgIGNhc2UgMzogcmV0dXJuIG5ldyAoc2lnbmVkID8gQmlnSW50NjRBcnJheSA6IEJpZ1VpbnQ2NEFycmF5KShidWZmZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBFcnJvcihcInVuc3VwcG9ydGVkIGFsaWduOiBcIiArIGFsaWduTG9nMik7XG4gIH1cblxuICAvKiogQWxsb2NhdGVzIGEgbmV3IGFycmF5IGluIHRoZSBtb2R1bGUncyBtZW1vcnkgYW5kIHJldHVybnMgaXRzIHJldGFpbmVkIHBvaW50ZXIuICovXG4gIGZ1bmN0aW9uIF9fYWxsb2NBcnJheShpZCwgdmFsdWVzKSB7XG4gICAgY29uc3QgaW5mbyA9IGdldEluZm8oaWQpO1xuICAgIGlmICghKGluZm8gJiAoQVJSQVlCVUZGRVJWSUVXIHwgQVJSQVkpKSkgdGhyb3cgRXJyb3IoXCJub3QgYW4gYXJyYXk6IFwiICsgaWQgKyBcIiBAIFwiICsgaW5mbyk7XG4gICAgY29uc3QgYWxpZ24gPSBnZXRWYWx1ZUFsaWduKGluZm8pO1xuICAgIGNvbnN0IGxlbmd0aCA9IHZhbHVlcy5sZW5ndGg7XG4gICAgY29uc3QgYnVmID0gYWxsb2MobGVuZ3RoIDw8IGFsaWduLCBBUlJBWUJVRkZFUl9JRCk7XG4gICAgY29uc3QgYXJyID0gYWxsb2MoaW5mbyAmIEFSUkFZID8gQVJSQVlfU0laRSA6IEFSUkFZQlVGRkVSVklFV19TSVpFLCBpZCk7XG4gICAgY29uc3QgVTMyID0gbmV3IFVpbnQzMkFycmF5KG1lbW9yeS5idWZmZXIpO1xuICAgIFUzMlthcnIgKyBBUlJBWUJVRkZFUlZJRVdfQlVGRkVSX09GRlNFVCA+Pj4gMl0gPSByZXRhaW4oYnVmKTtcbiAgICBVMzJbYXJyICsgQVJSQVlCVUZGRVJWSUVXX0RBVEFTVEFSVF9PRkZTRVQgPj4+IDJdID0gYnVmO1xuICAgIFUzMlthcnIgKyBBUlJBWUJVRkZFUlZJRVdfREFUQUxFTkdUSF9PRkZTRVQgPj4+IDJdID0gbGVuZ3RoIDw8IGFsaWduO1xuICAgIGlmIChpbmZvICYgQVJSQVkpIFUzMlthcnIgKyBBUlJBWV9MRU5HVEhfT0ZGU0VUID4+PiAyXSA9IGxlbmd0aDtcbiAgICBjb25zdCB2aWV3ID0gZ2V0VmlldyhhbGlnbiwgaW5mbyAmIFZBTF9TSUdORUQsIGluZm8gJiBWQUxfRkxPQVQpO1xuICAgIGlmIChpbmZvICYgVkFMX01BTkFHRUQpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHZpZXdbKGJ1ZiA+Pj4gYWxpZ24pICsgaV0gPSByZXRhaW4odmFsdWVzW2ldKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmlldy5zZXQodmFsdWVzLCBidWYgPj4+IGFsaWduKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycjtcbiAgfVxuXG4gIGJhc2VNb2R1bGUuX19hbGxvY0FycmF5ID0gX19hbGxvY0FycmF5O1xuXG4gIC8qKiBHZXRzIGEgbGl2ZSB2aWV3IG9uIGFuIGFycmF5J3MgdmFsdWVzIGluIHRoZSBtb2R1bGUncyBtZW1vcnkuIEluZmVycyB0aGUgYXJyYXkgdHlwZSBmcm9tIFJUVEkuICovXG4gIGZ1bmN0aW9uIF9fZ2V0QXJyYXlWaWV3KGFycikge1xuICAgIGNvbnN0IFUzMiA9IG5ldyBVaW50MzJBcnJheShtZW1vcnkuYnVmZmVyKTtcbiAgICBjb25zdCBpZCA9IFUzMlthcnIgKyBJRF9PRkZTRVQgPj4+IDJdO1xuICAgIGNvbnN0IGluZm8gPSBnZXRJbmZvKGlkKTtcbiAgICBpZiAoIShpbmZvICYgQVJSQVlCVUZGRVJWSUVXKSkgdGhyb3cgRXJyb3IoXCJub3QgYW4gYXJyYXk6IFwiICsgaWQpO1xuICAgIGNvbnN0IGFsaWduID0gZ2V0VmFsdWVBbGlnbihpbmZvKTtcbiAgICB2YXIgYnVmID0gVTMyW2FyciArIEFSUkFZQlVGRkVSVklFV19EQVRBU1RBUlRfT0ZGU0VUID4+PiAyXTtcbiAgICBjb25zdCBsZW5ndGggPSBpbmZvICYgQVJSQVlcbiAgICAgID8gVTMyW2FyciArIEFSUkFZX0xFTkdUSF9PRkZTRVQgPj4+IDJdXG4gICAgICA6IFUzMltidWYgKyBTSVpFX09GRlNFVCA+Pj4gMl0gPj4+IGFsaWduO1xuICAgIHJldHVybiBnZXRWaWV3KGFsaWduLCBpbmZvICYgVkFMX1NJR05FRCwgaW5mbyAmIFZBTF9GTE9BVClcbiAgICAgICAgICAuc3ViYXJyYXkoYnVmID4+Pj0gYWxpZ24sIGJ1ZiArIGxlbmd0aCk7XG4gIH1cblxuICBiYXNlTW9kdWxlLl9fZ2V0QXJyYXlWaWV3ID0gX19nZXRBcnJheVZpZXc7XG5cbiAgLyoqIENvcGllcyBhbiBhcnJheSdzIHZhbHVlcyBmcm9tIHRoZSBtb2R1bGUncyBtZW1vcnkuIEluZmVycyB0aGUgYXJyYXkgdHlwZSBmcm9tIFJUVEkuICovXG4gIGZ1bmN0aW9uIF9fZ2V0QXJyYXkoYXJyKSB7XG4gICAgY29uc3QgaW5wdXQgPSBfX2dldEFycmF5VmlldyhhcnIpO1xuICAgIGNvbnN0IGxlbiA9IGlucHV0Lmxlbmd0aDtcbiAgICBjb25zdCBvdXQgPSBuZXcgQXJyYXkobGVuKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSBvdXRbaV0gPSBpbnB1dFtpXTtcbiAgICByZXR1cm4gb3V0O1xuICB9XG5cbiAgYmFzZU1vZHVsZS5fX2dldEFycmF5ID0gX19nZXRBcnJheTtcblxuICAvKiogQ29waWVzIGFuIEFycmF5QnVmZmVyJ3MgdmFsdWUgZnJvbSB0aGUgbW9kdWxlJ3MgbWVtb3J5LiAqL1xuICBmdW5jdGlvbiBfX2dldEFycmF5QnVmZmVyKHB0cikge1xuICAgIGNvbnN0IGJ1ZmZlciA9IG1lbW9yeS5idWZmZXI7XG4gICAgY29uc3QgbGVuZ3RoID0gbmV3IFVpbnQzMkFycmF5KGJ1ZmZlcilbcHRyICsgU0laRV9PRkZTRVQgPj4+IDJdO1xuICAgIHJldHVybiBidWZmZXIuc2xpY2UocHRyLCBwdHIgKyBsZW5ndGgpO1xuICB9XG5cbiAgYmFzZU1vZHVsZS5fX2dldEFycmF5QnVmZmVyID0gX19nZXRBcnJheUJ1ZmZlcjtcblxuICAvKiogQ29waWVzIGEgdHlwZWQgYXJyYXkncyB2YWx1ZXMgZnJvbSB0aGUgbW9kdWxlJ3MgbWVtb3J5LiAqL1xuICBmdW5jdGlvbiBnZXRUeXBlZEFycmF5KFR5cGUsIGFsaWduTG9nMiwgcHRyKSB7XG4gICAgcmV0dXJuIG5ldyBUeXBlKGdldFR5cGVkQXJyYXlWaWV3KFR5cGUsIGFsaWduTG9nMiwgcHRyKSk7XG4gIH1cblxuICAvKiogR2V0cyBhIGxpdmUgdmlldyBvbiBhIHR5cGVkIGFycmF5J3MgdmFsdWVzIGluIHRoZSBtb2R1bGUncyBtZW1vcnkuICovXG4gIGZ1bmN0aW9uIGdldFR5cGVkQXJyYXlWaWV3KFR5cGUsIGFsaWduTG9nMiwgcHRyKSB7XG4gICAgY29uc3QgYnVmZmVyID0gbWVtb3J5LmJ1ZmZlcjtcbiAgICBjb25zdCBVMzIgPSBuZXcgVWludDMyQXJyYXkoYnVmZmVyKTtcbiAgICBjb25zdCBidWZQdHIgPSBVMzJbcHRyICsgQVJSQVlCVUZGRVJWSUVXX0RBVEFTVEFSVF9PRkZTRVQgPj4+IDJdO1xuICAgIHJldHVybiBuZXcgVHlwZShidWZmZXIsIGJ1ZlB0ciwgVTMyW2J1ZlB0ciArIFNJWkVfT0ZGU0VUID4+PiAyXSA+Pj4gYWxpZ25Mb2cyKTtcbiAgfVxuXG4gIGJhc2VNb2R1bGUuX19nZXRJbnQ4QXJyYXkgPSBnZXRUeXBlZEFycmF5LmJpbmQobnVsbCwgSW50OEFycmF5LCAwKTtcbiAgYmFzZU1vZHVsZS5fX2dldEludDhBcnJheVZpZXcgPSBnZXRUeXBlZEFycmF5Vmlldy5iaW5kKG51bGwsIEludDhBcnJheSwgMCk7XG4gIGJhc2VNb2R1bGUuX19nZXRVaW50OEFycmF5ID0gZ2V0VHlwZWRBcnJheS5iaW5kKG51bGwsIFVpbnQ4QXJyYXksIDApO1xuICBiYXNlTW9kdWxlLl9fZ2V0VWludDhBcnJheVZpZXcgPSBnZXRUeXBlZEFycmF5Vmlldy5iaW5kKG51bGwsIFVpbnQ4QXJyYXksIDApO1xuICBiYXNlTW9kdWxlLl9fZ2V0VWludDhDbGFtcGVkQXJyYXkgPSBnZXRUeXBlZEFycmF5LmJpbmQobnVsbCwgVWludDhDbGFtcGVkQXJyYXksIDApO1xuICBiYXNlTW9kdWxlLl9fZ2V0VWludDhDbGFtcGVkQXJyYXlWaWV3ID0gZ2V0VHlwZWRBcnJheVZpZXcuYmluZChudWxsLCBVaW50OENsYW1wZWRBcnJheSwgMCk7XG4gIGJhc2VNb2R1bGUuX19nZXRJbnQxNkFycmF5ID0gZ2V0VHlwZWRBcnJheS5iaW5kKG51bGwsIEludDE2QXJyYXksIDEpO1xuICBiYXNlTW9kdWxlLl9fZ2V0SW50MTZBcnJheVZpZXcgPSBnZXRUeXBlZEFycmF5Vmlldy5iaW5kKG51bGwsIEludDE2QXJyYXksIDEpO1xuICBiYXNlTW9kdWxlLl9fZ2V0VWludDE2QXJyYXkgPSBnZXRUeXBlZEFycmF5LmJpbmQobnVsbCwgVWludDE2QXJyYXksIDEpO1xuICBiYXNlTW9kdWxlLl9fZ2V0VWludDE2QXJyYXlWaWV3ID0gZ2V0VHlwZWRBcnJheVZpZXcuYmluZChudWxsLCBVaW50MTZBcnJheSwgMSk7XG4gIGJhc2VNb2R1bGUuX19nZXRJbnQzMkFycmF5ID0gZ2V0VHlwZWRBcnJheS5iaW5kKG51bGwsIEludDMyQXJyYXksIDIpO1xuICBiYXNlTW9kdWxlLl9fZ2V0SW50MzJBcnJheVZpZXcgPSBnZXRUeXBlZEFycmF5Vmlldy5iaW5kKG51bGwsIEludDMyQXJyYXksIDIpO1xuICBiYXNlTW9kdWxlLl9fZ2V0VWludDMyQXJyYXkgPSBnZXRUeXBlZEFycmF5LmJpbmQobnVsbCwgVWludDMyQXJyYXksIDIpO1xuICBiYXNlTW9kdWxlLl9fZ2V0VWludDMyQXJyYXlWaWV3ID0gZ2V0VHlwZWRBcnJheVZpZXcuYmluZChudWxsLCBVaW50MzJBcnJheSwgMik7XG4gIGlmIChCSUdJTlQpIHtcbiAgICBiYXNlTW9kdWxlLl9fZ2V0SW50NjRBcnJheSA9IGdldFR5cGVkQXJyYXkuYmluZChudWxsLCBCaWdJbnQ2NEFycmF5LCAzKTtcbiAgICBiYXNlTW9kdWxlLl9fZ2V0SW50NjRBcnJheVZpZXcgPSBnZXRUeXBlZEFycmF5Vmlldy5iaW5kKG51bGwsIEJpZ0ludDY0QXJyYXksIDMpO1xuICAgIGJhc2VNb2R1bGUuX19nZXRVaW50NjRBcnJheSA9IGdldFR5cGVkQXJyYXkuYmluZChudWxsLCBCaWdVaW50NjRBcnJheSwgMyk7XG4gICAgYmFzZU1vZHVsZS5fX2dldFVpbnQ2NEFycmF5VmlldyA9IGdldFR5cGVkQXJyYXlWaWV3LmJpbmQobnVsbCwgQmlnVWludDY0QXJyYXksIDMpO1xuICB9XG4gIGJhc2VNb2R1bGUuX19nZXRGbG9hdDMyQXJyYXkgPSBnZXRUeXBlZEFycmF5LmJpbmQobnVsbCwgRmxvYXQzMkFycmF5LCAyKTtcbiAgYmFzZU1vZHVsZS5fX2dldEZsb2F0MzJBcnJheVZpZXcgPSBnZXRUeXBlZEFycmF5Vmlldy5iaW5kKG51bGwsIEZsb2F0MzJBcnJheSwgMik7XG4gIGJhc2VNb2R1bGUuX19nZXRGbG9hdDY0QXJyYXkgPSBnZXRUeXBlZEFycmF5LmJpbmQobnVsbCwgRmxvYXQ2NEFycmF5LCAzKTtcbiAgYmFzZU1vZHVsZS5fX2dldEZsb2F0NjRBcnJheVZpZXcgPSBnZXRUeXBlZEFycmF5Vmlldy5iaW5kKG51bGwsIEZsb2F0NjRBcnJheSwgMyk7XG5cbiAgLyoqIFRlc3RzIHdoZXRoZXIgYW4gb2JqZWN0IGlzIGFuIGluc3RhbmNlIG9mIHRoZSBjbGFzcyByZXByZXNlbnRlZCBieSB0aGUgc3BlY2lmaWVkIGJhc2UgaWQuICovXG4gIGZ1bmN0aW9uIF9faW5zdGFuY2VvZihwdHIsIGJhc2VJZCkge1xuICAgIGNvbnN0IFUzMiA9IG5ldyBVaW50MzJBcnJheShtZW1vcnkuYnVmZmVyKTtcbiAgICB2YXIgaWQgPSBVMzJbKHB0ciArIElEX09GRlNFVCkgPj4+IDJdO1xuICAgIGlmIChpZCA8PSBVMzJbcnR0aUJhc2UgPj4+IDJdKSB7XG4gICAgICBkbyBpZiAoaWQgPT0gYmFzZUlkKSByZXR1cm4gdHJ1ZTtcbiAgICAgIHdoaWxlIChpZCA9IGdldEJhc2UoaWQpKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgYmFzZU1vZHVsZS5fX2luc3RhbmNlb2YgPSBfX2luc3RhbmNlb2Y7XG5cbiAgLy8gUHVsbCBiYXNpYyBleHBvcnRzIHRvIGJhc2VNb2R1bGUgc28gY29kZSBpbiBwcmVJbnN0YW50aWF0ZSBjYW4gdXNlIHRoZW1cbiAgYmFzZU1vZHVsZS5tZW1vcnkgPSBiYXNlTW9kdWxlLm1lbW9yeSB8fCBtZW1vcnk7XG4gIGJhc2VNb2R1bGUudGFibGUgID0gYmFzZU1vZHVsZS50YWJsZSAgfHwgdGFibGU7XG5cbiAgLy8gRGVtYW5nbGUgZXhwb3J0cyBhbmQgcHJvdmlkZSB0aGUgdXN1YWwgdXRpbGl0eSBvbiB0aGUgcHJvdG90eXBlXG4gIHJldHVybiBkZW1hbmdsZShyYXdFeHBvcnRzLCBiYXNlTW9kdWxlKTtcbn1cblxuZnVuY3Rpb24gaXNSZXNwb25zZShvKSB7XG4gIHJldHVybiB0eXBlb2YgUmVzcG9uc2UgIT09IFwidW5kZWZpbmVkXCIgJiYgbyBpbnN0YW5jZW9mIFJlc3BvbnNlO1xufVxuXG4vKiogQXN5bmNocm9ub3VzbHkgaW5zdGFudGlhdGVzIGFuIEFzc2VtYmx5U2NyaXB0IG1vZHVsZSBmcm9tIGFueXRoaW5nIHRoYXQgY2FuIGJlIGluc3RhbnRpYXRlZC4gKi9cbmFzeW5jIGZ1bmN0aW9uIGluc3RhbnRpYXRlKHNvdXJjZSwgaW1wb3J0cykge1xuICBpZiAoaXNSZXNwb25zZShzb3VyY2UgPSBhd2FpdCBzb3VyY2UpKSByZXR1cm4gaW5zdGFudGlhdGVTdHJlYW1pbmcoc291cmNlLCBpbXBvcnRzKTtcbiAgcmV0dXJuIHBvc3RJbnN0YW50aWF0ZShcbiAgICBwcmVJbnN0YW50aWF0ZShpbXBvcnRzIHx8IChpbXBvcnRzID0ge30pKSxcbiAgICBhd2FpdCBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZShcbiAgICAgIHNvdXJjZSBpbnN0YW5jZW9mIFdlYkFzc2VtYmx5Lk1vZHVsZVxuICAgICAgICA/IHNvdXJjZVxuICAgICAgICA6IGF3YWl0IFdlYkFzc2VtYmx5LmNvbXBpbGUoc291cmNlKSxcbiAgICAgIGltcG9ydHNcbiAgICApXG4gICk7XG59XG5cbmV4cG9ydHMuaW5zdGFudGlhdGUgPSBpbnN0YW50aWF0ZTtcblxuLyoqIFN5bmNocm9ub3VzbHkgaW5zdGFudGlhdGVzIGFuIEFzc2VtYmx5U2NyaXB0IG1vZHVsZSBmcm9tIGEgV2ViQXNzZW1ibHkuTW9kdWxlIG9yIGJpbmFyeSBidWZmZXIuICovXG5mdW5jdGlvbiBpbnN0YW50aWF0ZVN5bmMoc291cmNlLCBpbXBvcnRzKSB7XG4gIHJldHVybiBwb3N0SW5zdGFudGlhdGUoXG4gICAgcHJlSW5zdGFudGlhdGUoaW1wb3J0cyB8fCAoaW1wb3J0cyA9IHt9KSksXG4gICAgbmV3IFdlYkFzc2VtYmx5Lkluc3RhbmNlKFxuICAgICAgc291cmNlIGluc3RhbmNlb2YgV2ViQXNzZW1ibHkuTW9kdWxlXG4gICAgICAgID8gc291cmNlXG4gICAgICAgIDogbmV3IFdlYkFzc2VtYmx5Lk1vZHVsZShzb3VyY2UpLFxuICAgICAgaW1wb3J0c1xuICAgIClcbiAgKVxufVxuXG5leHBvcnRzLmluc3RhbnRpYXRlU3luYyA9IGluc3RhbnRpYXRlU3luYztcblxuLyoqIEFzeW5jaHJvbm91c2x5IGluc3RhbnRpYXRlcyBhbiBBc3NlbWJseVNjcmlwdCBtb2R1bGUgZnJvbSBhIHJlc3BvbnNlLCBpLmUuIGFzIG9idGFpbmVkIGJ5IGBmZXRjaGAuICovXG5hc3luYyBmdW5jdGlvbiBpbnN0YW50aWF0ZVN0cmVhbWluZyhzb3VyY2UsIGltcG9ydHMpIHtcbiAgaWYgKCFXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZykge1xuICAgIHJldHVybiBpbnN0YW50aWF0ZShcbiAgICAgIGlzUmVzcG9uc2Uoc291cmNlID0gYXdhaXQgc291cmNlKVxuICAgICAgICA/IHNvdXJjZS5hcnJheUJ1ZmZlcigpXG4gICAgICAgIDogc291cmNlLFxuICAgICAgaW1wb3J0c1xuICAgICk7XG4gIH1cbiAgcmV0dXJuIHBvc3RJbnN0YW50aWF0ZShcbiAgICBwcmVJbnN0YW50aWF0ZShpbXBvcnRzIHx8IChpbXBvcnRzID0ge30pKSxcbiAgICAoYXdhaXQgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmcoc291cmNlLCBpbXBvcnRzKSkuaW5zdGFuY2VcbiAgKTtcbn1cblxuZXhwb3J0cy5pbnN0YW50aWF0ZVN0cmVhbWluZyA9IGluc3RhbnRpYXRlU3RyZWFtaW5nO1xuXG4vKiogRGVtYW5nbGVzIGFuIEFzc2VtYmx5U2NyaXB0IG1vZHVsZSdzIGV4cG9ydHMgdG8gYSBmcmllbmRseSBvYmplY3Qgc3RydWN0dXJlLiAqL1xuZnVuY3Rpb24gZGVtYW5nbGUoZXhwb3J0cywgYmFzZU1vZHVsZSkge1xuICB2YXIgbW9kdWxlID0gYmFzZU1vZHVsZSA/IE9iamVjdC5jcmVhdGUoYmFzZU1vZHVsZSkgOiB7fTtcbiAgdmFyIHNldEFyZ3VtZW50c0xlbmd0aCA9IGV4cG9ydHNbXCJfX2FyZ3VtZW50c0xlbmd0aFwiXVxuICAgID8gZnVuY3Rpb24obGVuZ3RoKSB7IGV4cG9ydHNbXCJfX2FyZ3VtZW50c0xlbmd0aFwiXS52YWx1ZSA9IGxlbmd0aDsgfVxuICAgIDogZXhwb3J0c1tcIl9fc2V0QXJndW1lbnRzTGVuZ3RoXCJdIHx8IGV4cG9ydHNbXCJfX3NldGFyZ2NcIl0gfHwgZnVuY3Rpb24oKSB7fTtcbiAgZm9yIChsZXQgaW50ZXJuYWxOYW1lIGluIGV4cG9ydHMpIHtcbiAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBpbnRlcm5hbE5hbWUpKSBjb250aW51ZTtcbiAgICBjb25zdCBlbGVtID0gZXhwb3J0c1tpbnRlcm5hbE5hbWVdO1xuICAgIGxldCBwYXJ0cyA9IGludGVybmFsTmFtZS5zcGxpdChcIi5cIik7XG4gICAgbGV0IGN1cnIgPSBtb2R1bGU7XG4gICAgd2hpbGUgKHBhcnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgIGxldCBwYXJ0ID0gcGFydHMuc2hpZnQoKTtcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGN1cnIsIHBhcnQpKSBjdXJyW3BhcnRdID0ge307XG4gICAgICBjdXJyID0gY3VycltwYXJ0XTtcbiAgICB9XG4gICAgbGV0IG5hbWUgPSBwYXJ0c1swXTtcbiAgICBsZXQgaGFzaCA9IG5hbWUuaW5kZXhPZihcIiNcIik7XG4gICAgaWYgKGhhc2ggPj0gMCkge1xuICAgICAgbGV0IGNsYXNzTmFtZSA9IG5hbWUuc3Vic3RyaW5nKDAsIGhhc2gpO1xuICAgICAgbGV0IGNsYXNzRWxlbSA9IGN1cnJbY2xhc3NOYW1lXTtcbiAgICAgIGlmICh0eXBlb2YgY2xhc3NFbGVtID09PSBcInVuZGVmaW5lZFwiIHx8ICFjbGFzc0VsZW0ucHJvdG90eXBlKSB7XG4gICAgICAgIGxldCBjdG9yID0gZnVuY3Rpb24oLi4uYXJncykge1xuICAgICAgICAgIHJldHVybiBjdG9yLndyYXAoY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IoMCwgLi4uYXJncykpO1xuICAgICAgICB9O1xuICAgICAgICBjdG9yLnByb3RvdHlwZSA9IHtcbiAgICAgICAgICB2YWx1ZU9mOiBmdW5jdGlvbiB2YWx1ZU9mKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbVEhJU107XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjdG9yLndyYXAgPSBmdW5jdGlvbih0aGlzVmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gT2JqZWN0LmNyZWF0ZShjdG9yLnByb3RvdHlwZSwgeyBbVEhJU106IHsgdmFsdWU6IHRoaXNWYWx1ZSwgd3JpdGFibGU6IGZhbHNlIH0gfSk7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChjbGFzc0VsZW0pIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGNsYXNzRWxlbSkuZm9yRWFjaChuYW1lID0+XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0b3IsIG5hbWUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY2xhc3NFbGVtLCBuYW1lKSlcbiAgICAgICAgKTtcbiAgICAgICAgY3VycltjbGFzc05hbWVdID0gY3RvcjtcbiAgICAgIH1cbiAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cmluZyhoYXNoICsgMSk7XG4gICAgICBjdXJyID0gY3VycltjbGFzc05hbWVdLnByb3RvdHlwZTtcbiAgICAgIGlmICgvXihnZXR8c2V0KTovLnRlc3QobmFtZSkpIHtcbiAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY3VyciwgbmFtZSA9IG5hbWUuc3Vic3RyaW5nKDQpKSkge1xuICAgICAgICAgIGxldCBnZXR0ZXIgPSBleHBvcnRzW2ludGVybmFsTmFtZS5yZXBsYWNlKFwic2V0OlwiLCBcImdldDpcIildO1xuICAgICAgICAgIGxldCBzZXR0ZXIgPSBleHBvcnRzW2ludGVybmFsTmFtZS5yZXBsYWNlKFwiZ2V0OlwiLCBcInNldDpcIildO1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdXJyLCBuYW1lLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gZ2V0dGVyKHRoaXNbVEhJU10pOyB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkgeyBzZXR0ZXIodGhpc1tUSElTXSwgdmFsdWUpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAobmFtZSA9PT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgICAgIChjdXJyW25hbWVdID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgIHNldEFyZ3VtZW50c0xlbmd0aChhcmdzLmxlbmd0aCk7XG4gICAgICAgICAgICByZXR1cm4gZWxlbSguLi5hcmdzKTtcbiAgICAgICAgICB9KS5vcmlnaW5hbCA9IGVsZW07XG4gICAgICAgIH0gZWxzZSB7IC8vIGluc3RhbmNlIG1ldGhvZFxuICAgICAgICAgIChjdXJyW25hbWVdID0gZnVuY3Rpb24oLi4uYXJncykgeyAvLyAhXG4gICAgICAgICAgICBzZXRBcmd1bWVudHNMZW5ndGgoYXJncy5sZW5ndGgpO1xuICAgICAgICAgICAgcmV0dXJuIGVsZW0odGhpc1tUSElTXSwgLi4uYXJncyk7XG4gICAgICAgICAgfSkub3JpZ2luYWwgPSBlbGVtO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICgvXihnZXR8c2V0KTovLnRlc3QobmFtZSkpIHtcbiAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY3VyciwgbmFtZSA9IG5hbWUuc3Vic3RyaW5nKDQpKSkge1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdXJyLCBuYW1lLCB7XG4gICAgICAgICAgICBnZXQ6IGV4cG9ydHNbaW50ZXJuYWxOYW1lLnJlcGxhY2UoXCJzZXQ6XCIsIFwiZ2V0OlwiKV0sXG4gICAgICAgICAgICBzZXQ6IGV4cG9ydHNbaW50ZXJuYWxOYW1lLnJlcGxhY2UoXCJnZXQ6XCIsIFwic2V0OlwiKV0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGVsZW0gPT09IFwiZnVuY3Rpb25cIiAmJiBlbGVtICE9PSBzZXRBcmd1bWVudHNMZW5ndGgpIHtcbiAgICAgICAgKGN1cnJbbmFtZV0gPSAoLi4uYXJncykgPT4ge1xuICAgICAgICAgIHNldEFyZ3VtZW50c0xlbmd0aChhcmdzLmxlbmd0aCk7XG4gICAgICAgICAgcmV0dXJuIGVsZW0oLi4uYXJncyk7XG4gICAgICAgIH0pLm9yaWdpbmFsID0gZWxlbTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnJbbmFtZV0gPSBlbGVtO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbW9kdWxlO1xufVxuXG5leHBvcnRzLmRlbWFuZ2xlID0gZGVtYW5nbGU7XG4iLCAiXG5jb25zdCB7IGluc3RhbnRpYXRlU3luYyB9ID0gcmVxdWlyZShcIkBhc3NlbWJseXNjcmlwdC9sb2FkZXJcIik7XG5jb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJylcblxubG9hZFdlYkFzc2VtYmx5LnN1cHBvcnRlZCA9IHR5cGVvZiBXZWJBc3NlbWJseSAhPT0gJ3VuZGVmaW5lZCdcblxuYXN5bmMgZnVuY3Rpb24gbG9hZFdlYkFzc2VtYmx5IChpbXAgPSB7fSkge1xuICBpZiAoIWxvYWRXZWJBc3NlbWJseS5zdXBwb3J0ZWQpIHJldHVybiBudWxsXG4gIFxuICByZXR1cm4gaW5zdGFudGlhdGVTeW5jKGZzLnJlYWRGaWxlU3luYyhfX2Rpcm5hbWUgKyBcIi8uLi9kaXN0L3JhYmluLndhc21cIiksIGltcCk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGxvYWRXZWJBc3NlbWJseVxuIiwgImNvbnN0IFJhYmluID0gcmVxdWlyZSgnLi9yYWJpbicpXG5jb25zdCBnZXRSYWJpbiA9IHJlcXVpcmUoJy4uL2Rpc3QvcmFiaW4td2FzbS5ub2RlLmpzJylcblxuY29uc3QgY3JlYXRlID0gYXN5bmMgKGF2ZywgbWluLCBtYXgsIHdpbmRvd1NpemUsIHBvbHlub21pYWwpID0+IHtcbiAgICBjb25zdCBjb21waWxlZCA9IGF3YWl0IGdldFJhYmluKClcbiAgICByZXR1cm4gbmV3IFJhYmluKGNvbXBpbGVkLCBhdmcsIG1pbiwgbWF4LCB3aW5kb3dTaXplLCBwb2x5bm9taWFsKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBSYWJpbixcbiAgICBjcmVhdGVcbn1cbiIsICIndXNlIHN0cmljdCdcblxuLy8gSlMgdHJlYXRzIHN1YmplY3RzIG9mIGJpdHdpc2Ugb3BlcmF0b3JzIGFzIFNJR05FRCAzMiBiaXQgbnVtYmVycyxcbi8vIHdoaWNoIG1lYW5zIHRoZSBtYXhpbXVtIGFtb3VudCBvZiBiaXRzIHdlIGNhbiBzdG9yZSBpbnNpZGUgZWFjaCBieXRlXG4vLyBpcyA3Li5cbmNvbnN0IEJJVFNfUEVSX0JZVEUgPSA3XG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgU3BhcnNlQXJyYXkge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgdGhpcy5fYml0QXJyYXlzID0gW11cbiAgICB0aGlzLl9kYXRhID0gW11cbiAgICB0aGlzLl9sZW5ndGggPSAwXG4gICAgdGhpcy5fY2hhbmdlZExlbmd0aCA9IGZhbHNlXG4gICAgdGhpcy5fY2hhbmdlZERhdGEgPSBmYWxzZVxuICB9XG5cbiAgc2V0IChpbmRleCwgdmFsdWUpIHtcbiAgICBsZXQgcG9zID0gdGhpcy5faW50ZXJuYWxQb3NpdGlvbkZvcihpbmRleCwgZmFsc2UpXG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIHVuc2V0dGluZ1xuICAgICAgaWYgKHBvcyAhPT0gLTEpIHtcbiAgICAgICAgLy8gcmVtb3ZlIGl0ZW0gZnJvbSBiaXQgYXJyYXkgYW5kIGFycmF5IGl0c2VsZlxuICAgICAgICB0aGlzLl91bnNldEludGVybmFsUG9zKHBvcylcbiAgICAgICAgdGhpcy5fdW5zZXRCaXQoaW5kZXgpXG4gICAgICAgIHRoaXMuX2NoYW5nZWRMZW5ndGggPSB0cnVlXG4gICAgICAgIHRoaXMuX2NoYW5nZWREYXRhID0gdHJ1ZVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgbmVlZHNTb3J0ID0gZmFsc2VcbiAgICAgIGlmIChwb3MgPT09IC0xKSB7XG4gICAgICAgIHBvcyA9IHRoaXMuX2RhdGEubGVuZ3RoXG4gICAgICAgIHRoaXMuX3NldEJpdChpbmRleClcbiAgICAgICAgdGhpcy5fY2hhbmdlZERhdGEgPSB0cnVlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZWVkc1NvcnQgPSB0cnVlXG4gICAgICB9XG4gICAgICB0aGlzLl9zZXRJbnRlcm5hbFBvcyhwb3MsIGluZGV4LCB2YWx1ZSwgbmVlZHNTb3J0KVxuICAgICAgdGhpcy5fY2hhbmdlZExlbmd0aCA9IHRydWVcbiAgICB9XG4gIH1cblxuICB1bnNldCAoaW5kZXgpIHtcbiAgICB0aGlzLnNldChpbmRleCwgdW5kZWZpbmVkKVxuICB9XG5cbiAgZ2V0IChpbmRleCkge1xuICAgIHRoaXMuX3NvcnREYXRhKClcbiAgICBjb25zdCBwb3MgPSB0aGlzLl9pbnRlcm5hbFBvc2l0aW9uRm9yKGluZGV4LCB0cnVlKVxuICAgIGlmIChwb3MgPT09IC0xKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9kYXRhW3Bvc11bMV1cbiAgfVxuXG4gIHB1c2ggKHZhbHVlKSB7XG4gICAgdGhpcy5zZXQodGhpcy5sZW5ndGgsIHZhbHVlKVxuICAgIHJldHVybiB0aGlzLmxlbmd0aFxuICB9XG5cbiAgZ2V0IGxlbmd0aCAoKSB7XG4gICAgdGhpcy5fc29ydERhdGEoKVxuICAgIGlmICh0aGlzLl9jaGFuZ2VkTGVuZ3RoKSB7XG4gICAgICBjb25zdCBsYXN0ID0gdGhpcy5fZGF0YVt0aGlzLl9kYXRhLmxlbmd0aCAtIDFdXG4gICAgICB0aGlzLl9sZW5ndGggPSBsYXN0ID8gbGFzdFswXSArIDEgOiAwXG4gICAgICB0aGlzLl9jaGFuZ2VkTGVuZ3RoID0gZmFsc2VcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2xlbmd0aFxuICB9XG5cbiAgZm9yRWFjaCAoaXRlcmF0b3IpIHtcbiAgICBsZXQgaSA9IDBcbiAgICB3aGlsZShpIDwgdGhpcy5sZW5ndGgpIHtcbiAgICAgIGl0ZXJhdG9yKHRoaXMuZ2V0KGkpLCBpLCB0aGlzKVxuICAgICAgaSsrXG4gICAgfVxuICB9XG5cbiAgbWFwIChpdGVyYXRvcikge1xuICAgIGxldCBpID0gMFxuICAgIGxldCBtYXBwZWQgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpXG4gICAgd2hpbGUoaSA8IHRoaXMubGVuZ3RoKSB7XG4gICAgICBtYXBwZWRbaV0gPSBpdGVyYXRvcih0aGlzLmdldChpKSwgaSwgdGhpcylcbiAgICAgIGkrK1xuICAgIH1cbiAgICByZXR1cm4gbWFwcGVkXG4gIH1cblxuICByZWR1Y2UgKHJlZHVjZXIsIGluaXRpYWxWYWx1ZSkge1xuICAgIGxldCBpID0gMFxuICAgIGxldCBhY2MgPSBpbml0aWFsVmFsdWVcbiAgICB3aGlsZShpIDwgdGhpcy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5nZXQoaSlcbiAgICAgIGFjYyA9IHJlZHVjZXIoYWNjLCB2YWx1ZSwgaSlcbiAgICAgIGkrK1xuICAgIH1cbiAgICByZXR1cm4gYWNjXG4gIH1cblxuICBmaW5kIChmaW5kZXIpIHtcbiAgICBsZXQgaSA9IDAsIGZvdW5kLCBsYXN0XG4gICAgd2hpbGUgKChpIDwgdGhpcy5sZW5ndGgpICYmICFmb3VuZCkge1xuICAgICAgbGFzdCA9IHRoaXMuZ2V0KGkpXG4gICAgICBmb3VuZCA9IGZpbmRlcihsYXN0KVxuICAgICAgaSsrXG4gICAgfVxuICAgIHJldHVybiBmb3VuZCA/IGxhc3QgOiB1bmRlZmluZWRcbiAgfVxuXG4gIF9pbnRlcm5hbFBvc2l0aW9uRm9yIChpbmRleCwgbm9DcmVhdGUpIHtcbiAgICBjb25zdCBieXRlUG9zID0gdGhpcy5fYnl0ZVBvc0ZvcihpbmRleCwgbm9DcmVhdGUpXG4gICAgaWYgKGJ5dGVQb3MgPj0gdGhpcy5fYml0QXJyYXlzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIGNvbnN0IGJ5dGUgPSB0aGlzLl9iaXRBcnJheXNbYnl0ZVBvc11cbiAgICBjb25zdCBiaXRQb3MgPSBpbmRleCAtIGJ5dGVQb3MgKiBCSVRTX1BFUl9CWVRFXG4gICAgY29uc3QgZXhpc3RzID0gKGJ5dGUgJiAoMSA8PCBiaXRQb3MpKSA+IDBcbiAgICBpZiAoIWV4aXN0cykge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIGNvbnN0IHByZXZpb3VzUG9wQ291bnQgPSB0aGlzLl9iaXRBcnJheXMuc2xpY2UoMCwgYnl0ZVBvcykucmVkdWNlKHBvcENvdW50UmVkdWNlLCAwKVxuXG4gICAgY29uc3QgbWFzayA9IH4oMHhmZmZmZmZmZiA8PCAoYml0UG9zICsgMSkpXG4gICAgY29uc3QgYnl0ZVBvcENvdW50ID0gcG9wQ291bnQoYnl0ZSAmIG1hc2spXG4gICAgY29uc3QgYXJyYXlQb3MgPSBwcmV2aW91c1BvcENvdW50ICsgYnl0ZVBvcENvdW50IC0gMVxuICAgIHJldHVybiBhcnJheVBvc1xuICB9XG5cbiAgX2J5dGVQb3NGb3IgKGluZGV4LCBub0NyZWF0ZSkge1xuICAgIGNvbnN0IGJ5dGVQb3MgPSBNYXRoLmZsb29yKGluZGV4IC8gQklUU19QRVJfQllURSlcbiAgICBjb25zdCB0YXJnZXRMZW5ndGggPSBieXRlUG9zICsgMVxuICAgIHdoaWxlICghbm9DcmVhdGUgJiYgdGhpcy5fYml0QXJyYXlzLmxlbmd0aCA8IHRhcmdldExlbmd0aCkge1xuICAgICAgdGhpcy5fYml0QXJyYXlzLnB1c2goMClcbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVQb3NcbiAgfVxuXG4gIF9zZXRCaXQgKGluZGV4KSB7XG4gICAgY29uc3QgYnl0ZVBvcyA9IHRoaXMuX2J5dGVQb3NGb3IoaW5kZXgsIGZhbHNlKVxuICAgIHRoaXMuX2JpdEFycmF5c1tieXRlUG9zXSB8PSAoMSA8PCAoaW5kZXggLSAoYnl0ZVBvcyAqIEJJVFNfUEVSX0JZVEUpKSlcbiAgfVxuXG4gIF91bnNldEJpdChpbmRleCkge1xuICAgIGNvbnN0IGJ5dGVQb3MgPSB0aGlzLl9ieXRlUG9zRm9yKGluZGV4LCBmYWxzZSlcbiAgICB0aGlzLl9iaXRBcnJheXNbYnl0ZVBvc10gJj0gfigxIDw8IChpbmRleCAtIChieXRlUG9zICogQklUU19QRVJfQllURSkpKVxuICB9XG5cbiAgX3NldEludGVybmFsUG9zKHBvcywgaW5kZXgsIHZhbHVlLCBuZWVkc1NvcnQpIHtcbiAgICBjb25zdCBkYXRhID10aGlzLl9kYXRhXG4gICAgY29uc3QgZWxlbSA9IFtpbmRleCwgdmFsdWVdXG4gICAgaWYgKG5lZWRzU29ydCkge1xuICAgICAgdGhpcy5fc29ydERhdGEoKVxuICAgICAgZGF0YVtwb3NdID0gZWxlbVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBuZXcgZWxlbWVudC4ganVzdCBzaG92ZSBpdCBpbnRvIHRoZSBhcnJheVxuICAgICAgLy8gYnV0IGJlIG5pY2UgYWJvdXQgd2hlcmUgd2Ugc2hvdmUgaXRcbiAgICAgIC8vIGluIG9yZGVyIHRvIG1ha2Ugc29ydGluZyBpdCBsYXRlciBlYXNpZXJcbiAgICAgIGlmIChkYXRhLmxlbmd0aCkge1xuICAgICAgICBpZiAoZGF0YVtkYXRhLmxlbmd0aCAtIDFdWzBdID49IGluZGV4KSB7XG4gICAgICAgICAgZGF0YS5wdXNoKGVsZW0pXG4gICAgICAgIH0gZWxzZSBpZiAoZGF0YVswXVswXSA8PSBpbmRleCkge1xuICAgICAgICAgIGRhdGEudW5zaGlmdChlbGVtKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHJhbmRvbUluZGV4ID0gTWF0aC5yb3VuZChkYXRhLmxlbmd0aCAvIDIpXG4gICAgICAgICAgdGhpcy5fZGF0YSA9IGRhdGEuc2xpY2UoMCwgcmFuZG9tSW5kZXgpLmNvbmNhdChlbGVtKS5jb25jYXQoZGF0YS5zbGljZShyYW5kb21JbmRleCkpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2RhdGEucHVzaChlbGVtKVxuICAgICAgfVxuICAgICAgdGhpcy5fY2hhbmdlZERhdGEgPSB0cnVlXG4gICAgICB0aGlzLl9jaGFuZ2VkTGVuZ3RoID0gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIF91bnNldEludGVybmFsUG9zIChwb3MpIHtcbiAgICB0aGlzLl9kYXRhLnNwbGljZShwb3MsIDEpXG4gIH1cblxuICBfc29ydERhdGEgKCkge1xuICAgIGlmICh0aGlzLl9jaGFuZ2VkRGF0YSkge1xuICAgICAgdGhpcy5fZGF0YS5zb3J0KHNvcnRJbnRlcm5hbClcbiAgICB9XG5cbiAgICB0aGlzLl9jaGFuZ2VkRGF0YSA9IGZhbHNlXG4gIH1cblxuICBiaXRGaWVsZCAoKSB7XG4gICAgY29uc3QgYnl0ZXMgPSBbXVxuICAgIGxldCBwZW5kaW5nQml0c0ZvclJlc3VsdGluZ0J5dGUgPSA4XG4gICAgbGV0IHBlbmRpbmdCaXRzRm9yTmV3Qnl0ZSA9IDBcbiAgICBsZXQgcmVzdWx0aW5nQnl0ZSA9IDBcbiAgICBsZXQgbmV3Qnl0ZVxuICAgIGNvbnN0IHBlbmRpbmcgPSB0aGlzLl9iaXRBcnJheXMuc2xpY2UoKVxuICAgIHdoaWxlIChwZW5kaW5nLmxlbmd0aCB8fCBwZW5kaW5nQml0c0Zvck5ld0J5dGUpIHtcbiAgICAgIGlmIChwZW5kaW5nQml0c0Zvck5ld0J5dGUgPT09IDApIHtcbiAgICAgICAgbmV3Qnl0ZSA9IHBlbmRpbmcuc2hpZnQoKVxuICAgICAgICBwZW5kaW5nQml0c0Zvck5ld0J5dGUgPSA3XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVzaW5nQml0cyA9IE1hdGgubWluKHBlbmRpbmdCaXRzRm9yTmV3Qnl0ZSwgcGVuZGluZ0JpdHNGb3JSZXN1bHRpbmdCeXRlKVxuICAgICAgY29uc3QgbWFzayA9IH4oMGIxMTExMTExMSA8PCB1c2luZ0JpdHMpXG4gICAgICBjb25zdCBtYXNrZWQgPSBuZXdCeXRlICYgbWFza1xuICAgICAgcmVzdWx0aW5nQnl0ZSB8PSBtYXNrZWQgPDwgKDggLSBwZW5kaW5nQml0c0ZvclJlc3VsdGluZ0J5dGUpXG4gICAgICBuZXdCeXRlID0gbmV3Qnl0ZSA+Pj4gdXNpbmdCaXRzXG4gICAgICBwZW5kaW5nQml0c0Zvck5ld0J5dGUgLT0gdXNpbmdCaXRzXG4gICAgICBwZW5kaW5nQml0c0ZvclJlc3VsdGluZ0J5dGUgLT0gdXNpbmdCaXRzXG5cbiAgICAgIGlmICghcGVuZGluZ0JpdHNGb3JSZXN1bHRpbmdCeXRlIHx8ICghcGVuZGluZ0JpdHNGb3JOZXdCeXRlICYmICFwZW5kaW5nLmxlbmd0aCkpIHtcbiAgICAgICAgYnl0ZXMucHVzaChyZXN1bHRpbmdCeXRlKVxuICAgICAgICByZXN1bHRpbmdCeXRlID0gMFxuICAgICAgICBwZW5kaW5nQml0c0ZvclJlc3VsdGluZ0J5dGUgPSA4XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIHRyYWlsaW5nIHplcm9lc1xuICAgIGZvcih2YXIgaSA9IGJ5dGVzLmxlbmd0aCAtIDE7IGkgPiAwOyBpLS0pIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gYnl0ZXNbaV1cbiAgICAgIGlmICh2YWx1ZSA9PT0gMCkge1xuICAgICAgICBieXRlcy5wb3AoKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYnl0ZXNcbiAgfVxuXG4gIGNvbXBhY3RBcnJheSAoKSB7XG4gICAgdGhpcy5fc29ydERhdGEoKVxuICAgIHJldHVybiB0aGlzLl9kYXRhLm1hcCh2YWx1ZU9ubHkpXG4gIH1cbn1cblxuZnVuY3Rpb24gcG9wQ291bnRSZWR1Y2UgKGNvdW50LCBieXRlKSB7XG4gIHJldHVybiBjb3VudCArIHBvcENvdW50KGJ5dGUpXG59XG5cbmZ1bmN0aW9uIHBvcENvdW50KF92KSB7XG4gIGxldCB2ID0gX3ZcbiAgdiA9IHYgLSAoKHYgPj4gMSkgJiAweDU1NTU1NTU1KSAgICAgICAgICAgICAgICAgICAgLy8gcmV1c2UgaW5wdXQgYXMgdGVtcG9yYXJ5XG4gIHYgPSAodiAmIDB4MzMzMzMzMzMpICsgKCh2ID4+IDIpICYgMHgzMzMzMzMzMykgICAgIC8vIHRlbXBcbiAgcmV0dXJuICgodiArICh2ID4+IDQpICYgMHhGMEYwRjBGKSAqIDB4MTAxMDEwMSkgPj4gMjRcbn1cblxuZnVuY3Rpb24gc29ydEludGVybmFsIChhLCBiKSB7XG4gIHJldHVybiBhWzBdIC0gYlswXVxufVxuXG5mdW5jdGlvbiB2YWx1ZU9ubHkgKGVsZW0pIHtcbiAgcmV0dXJuIGVsZW1bMV1cbn0iLCAiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBiYXNlKEFMUEhBQkVULCBuYW1lKSB7XG4gIGlmIChBTFBIQUJFVC5sZW5ndGggPj0gMjU1KSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQWxwaGFiZXQgdG9vIGxvbmcnKTtcbiAgfVxuICB2YXIgQkFTRV9NQVAgPSBuZXcgVWludDhBcnJheSgyNTYpO1xuICBmb3IgKHZhciBqID0gMDsgaiA8IEJBU0VfTUFQLmxlbmd0aDsgaisrKSB7XG4gICAgQkFTRV9NQVBbal0gPSAyNTU7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBBTFBIQUJFVC5sZW5ndGg7IGkrKykge1xuICAgIHZhciB4ID0gQUxQSEFCRVQuY2hhckF0KGkpO1xuICAgIHZhciB4YyA9IHguY2hhckNvZGVBdCgwKTtcbiAgICBpZiAoQkFTRV9NQVBbeGNdICE9PSAyNTUpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoeCArICcgaXMgYW1iaWd1b3VzJyk7XG4gICAgfVxuICAgIEJBU0VfTUFQW3hjXSA9IGk7XG4gIH1cbiAgdmFyIEJBU0UgPSBBTFBIQUJFVC5sZW5ndGg7XG4gIHZhciBMRUFERVIgPSBBTFBIQUJFVC5jaGFyQXQoMCk7XG4gIHZhciBGQUNUT1IgPSBNYXRoLmxvZyhCQVNFKSAvIE1hdGgubG9nKDI1Nik7XG4gIHZhciBpRkFDVE9SID0gTWF0aC5sb2coMjU2KSAvIE1hdGgubG9nKEJBU0UpO1xuICBmdW5jdGlvbiBlbmNvZGUoc291cmNlKSB7XG4gICAgaWYgKHNvdXJjZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpO1xuICAgIGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhzb3VyY2UpKSB7XG4gICAgICBzb3VyY2UgPSBuZXcgVWludDhBcnJheShzb3VyY2UuYnVmZmVyLCBzb3VyY2UuYnl0ZU9mZnNldCwgc291cmNlLmJ5dGVMZW5ndGgpO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShzb3VyY2UpKSB7XG4gICAgICBzb3VyY2UgPSBVaW50OEFycmF5LmZyb20oc291cmNlKTtcbiAgICB9XG4gICAgaWYgKCEoc291cmNlIGluc3RhbmNlb2YgVWludDhBcnJheSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFVpbnQ4QXJyYXknKTtcbiAgICB9XG4gICAgaWYgKHNvdXJjZS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgdmFyIHplcm9lcyA9IDA7XG4gICAgdmFyIGxlbmd0aCA9IDA7XG4gICAgdmFyIHBiZWdpbiA9IDA7XG4gICAgdmFyIHBlbmQgPSBzb3VyY2UubGVuZ3RoO1xuICAgIHdoaWxlIChwYmVnaW4gIT09IHBlbmQgJiYgc291cmNlW3BiZWdpbl0gPT09IDApIHtcbiAgICAgIHBiZWdpbisrO1xuICAgICAgemVyb2VzKys7XG4gICAgfVxuICAgIHZhciBzaXplID0gKHBlbmQgLSBwYmVnaW4pICogaUZBQ1RPUiArIDEgPj4+IDA7XG4gICAgdmFyIGI1OCA9IG5ldyBVaW50OEFycmF5KHNpemUpO1xuICAgIHdoaWxlIChwYmVnaW4gIT09IHBlbmQpIHtcbiAgICAgIHZhciBjYXJyeSA9IHNvdXJjZVtwYmVnaW5dO1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgZm9yICh2YXIgaXQxID0gc2l6ZSAtIDE7IChjYXJyeSAhPT0gMCB8fCBpIDwgbGVuZ3RoKSAmJiBpdDEgIT09IC0xOyBpdDEtLSwgaSsrKSB7XG4gICAgICAgIGNhcnJ5ICs9IDI1NiAqIGI1OFtpdDFdID4+PiAwO1xuICAgICAgICBiNThbaXQxXSA9IGNhcnJ5ICUgQkFTRSA+Pj4gMDtcbiAgICAgICAgY2FycnkgPSBjYXJyeSAvIEJBU0UgPj4+IDA7XG4gICAgICB9XG4gICAgICBpZiAoY2FycnkgIT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb24temVybyBjYXJyeScpO1xuICAgICAgfVxuICAgICAgbGVuZ3RoID0gaTtcbiAgICAgIHBiZWdpbisrO1xuICAgIH1cbiAgICB2YXIgaXQyID0gc2l6ZSAtIGxlbmd0aDtcbiAgICB3aGlsZSAoaXQyICE9PSBzaXplICYmIGI1OFtpdDJdID09PSAwKSB7XG4gICAgICBpdDIrKztcbiAgICB9XG4gICAgdmFyIHN0ciA9IExFQURFUi5yZXBlYXQoemVyb2VzKTtcbiAgICBmb3IgKDsgaXQyIDwgc2l6ZTsgKytpdDIpIHtcbiAgICAgIHN0ciArPSBBTFBIQUJFVC5jaGFyQXQoYjU4W2l0Ml0pO1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xuICB9XG4gIGZ1bmN0aW9uIGRlY29kZVVuc2FmZShzb3VyY2UpIHtcbiAgICBpZiAodHlwZW9mIHNvdXJjZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFN0cmluZycpO1xuICAgIH1cbiAgICBpZiAoc291cmNlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KCk7XG4gICAgfVxuICAgIHZhciBwc3ogPSAwO1xuICAgIGlmIChzb3VyY2VbcHN6XSA9PT0gJyAnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB6ZXJvZXMgPSAwO1xuICAgIHZhciBsZW5ndGggPSAwO1xuICAgIHdoaWxlIChzb3VyY2VbcHN6XSA9PT0gTEVBREVSKSB7XG4gICAgICB6ZXJvZXMrKztcbiAgICAgIHBzeisrO1xuICAgIH1cbiAgICB2YXIgc2l6ZSA9IChzb3VyY2UubGVuZ3RoIC0gcHN6KSAqIEZBQ1RPUiArIDEgPj4+IDA7XG4gICAgdmFyIGIyNTYgPSBuZXcgVWludDhBcnJheShzaXplKTtcbiAgICB3aGlsZSAoc291cmNlW3Bzel0pIHtcbiAgICAgIHZhciBjYXJyeSA9IEJBU0VfTUFQW3NvdXJjZS5jaGFyQ29kZUF0KHBzeildO1xuICAgICAgaWYgKGNhcnJ5ID09PSAyNTUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGkgPSAwO1xuICAgICAgZm9yICh2YXIgaXQzID0gc2l6ZSAtIDE7IChjYXJyeSAhPT0gMCB8fCBpIDwgbGVuZ3RoKSAmJiBpdDMgIT09IC0xOyBpdDMtLSwgaSsrKSB7XG4gICAgICAgIGNhcnJ5ICs9IEJBU0UgKiBiMjU2W2l0M10gPj4+IDA7XG4gICAgICAgIGIyNTZbaXQzXSA9IGNhcnJ5ICUgMjU2ID4+PiAwO1xuICAgICAgICBjYXJyeSA9IGNhcnJ5IC8gMjU2ID4+PiAwO1xuICAgICAgfVxuICAgICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm9uLXplcm8gY2FycnknKTtcbiAgICAgIH1cbiAgICAgIGxlbmd0aCA9IGk7XG4gICAgICBwc3orKztcbiAgICB9XG4gICAgaWYgKHNvdXJjZVtwc3pdID09PSAnICcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGl0NCA9IHNpemUgLSBsZW5ndGg7XG4gICAgd2hpbGUgKGl0NCAhPT0gc2l6ZSAmJiBiMjU2W2l0NF0gPT09IDApIHtcbiAgICAgIGl0NCsrO1xuICAgIH1cbiAgICB2YXIgdmNoID0gbmV3IFVpbnQ4QXJyYXkoemVyb2VzICsgKHNpemUgLSBpdDQpKTtcbiAgICB2YXIgaiA9IHplcm9lcztcbiAgICB3aGlsZSAoaXQ0ICE9PSBzaXplKSB7XG4gICAgICB2Y2hbaisrXSA9IGIyNTZbaXQ0KytdO1xuICAgIH1cbiAgICByZXR1cm4gdmNoO1xuICB9XG4gIGZ1bmN0aW9uIGRlY29kZShzdHJpbmcpIHtcbiAgICB2YXIgYnVmZmVyID0gZGVjb2RlVW5zYWZlKHN0cmluZyk7XG4gICAgaWYgKGJ1ZmZlcikge1xuICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBOb24tJHsgbmFtZSB9IGNoYXJhY3RlcmApO1xuICB9XG4gIHJldHVybiB7XG4gICAgZW5jb2RlOiBlbmNvZGUsXG4gICAgZGVjb2RlVW5zYWZlOiBkZWNvZGVVbnNhZmUsXG4gICAgZGVjb2RlOiBkZWNvZGVcbiAgfTtcbn1cbnZhciBzcmMgPSBiYXNlO1xudmFyIF9icnJwX19tdWx0aWZvcm1hdHNfc2NvcGVfYmFzZVggPSBzcmM7XG5cbm1vZHVsZS5leHBvcnRzID0gX2JycnBfX211bHRpZm9ybWF0c19zY29wZV9iYXNlWDtcbiIsICIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbmNvbnN0IGVtcHR5ID0gbmV3IFVpbnQ4QXJyYXkoMCk7XG5jb25zdCB0b0hleCA9IGQgPT4gZC5yZWR1Y2UoKGhleCwgYnl0ZSkgPT4gaGV4ICsgYnl0ZS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSwgJycpO1xuY29uc3QgZnJvbUhleCA9IGhleCA9PiB7XG4gIGNvbnN0IGhleGVzID0gaGV4Lm1hdGNoKC8uLi9nKTtcbiAgcmV0dXJuIGhleGVzID8gbmV3IFVpbnQ4QXJyYXkoaGV4ZXMubWFwKGIgPT4gcGFyc2VJbnQoYiwgMTYpKSkgOiBlbXB0eTtcbn07XG5jb25zdCBlcXVhbHMgPSAoYWEsIGJiKSA9PiB7XG4gIGlmIChhYSA9PT0gYmIpXG4gICAgcmV0dXJuIHRydWU7XG4gIGlmIChhYS5ieXRlTGVuZ3RoICE9PSBiYi5ieXRlTGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAobGV0IGlpID0gMDsgaWkgPCBhYS5ieXRlTGVuZ3RoOyBpaSsrKSB7XG4gICAgaWYgKGFhW2lpXSAhPT0gYmJbaWldKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufTtcbmNvbnN0IGNvZXJjZSA9IG8gPT4ge1xuICBpZiAobyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgJiYgby5jb25zdHJ1Y3Rvci5uYW1lID09PSAnVWludDhBcnJheScpXG4gICAgcmV0dXJuIG87XG4gIGlmIChvIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpXG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG8pO1xuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KG8pKSB7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG8uYnVmZmVyLCBvLmJ5dGVPZmZzZXQsIG8uYnl0ZUxlbmd0aCk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHR5cGUsIG11c3QgYmUgYmluYXJ5IHR5cGUnKTtcbn07XG5jb25zdCBpc0JpbmFyeSA9IG8gPT4gbyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8IEFycmF5QnVmZmVyLmlzVmlldyhvKTtcbmNvbnN0IGZyb21TdHJpbmcgPSBzdHIgPT4gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHN0cik7XG5jb25zdCB0b1N0cmluZyA9IGIgPT4gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGIpO1xuXG5leHBvcnRzLmNvZXJjZSA9IGNvZXJjZTtcbmV4cG9ydHMuZW1wdHkgPSBlbXB0eTtcbmV4cG9ydHMuZXF1YWxzID0gZXF1YWxzO1xuZXhwb3J0cy5mcm9tSGV4ID0gZnJvbUhleDtcbmV4cG9ydHMuZnJvbVN0cmluZyA9IGZyb21TdHJpbmc7XG5leHBvcnRzLmlzQmluYXJ5ID0gaXNCaW5hcnk7XG5leHBvcnRzLnRvSGV4ID0gdG9IZXg7XG5leHBvcnRzLnRvU3RyaW5nID0gdG9TdHJpbmc7XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgYmFzZVgkMSA9IHJlcXVpcmUoJy4uLy4uL3ZlbmRvci9iYXNlLXguanMnKTtcbnZhciBieXRlcyA9IHJlcXVpcmUoJy4uL2J5dGVzLmpzJyk7XG5cbmNsYXNzIEVuY29kZXIge1xuICBjb25zdHJ1Y3RvcihuYW1lLCBwcmVmaXgsIGJhc2VFbmNvZGUpIHtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMucHJlZml4ID0gcHJlZml4O1xuICAgIHRoaXMuYmFzZUVuY29kZSA9IGJhc2VFbmNvZGU7XG4gIH1cbiAgZW5jb2RlKGJ5dGVzKSB7XG4gICAgaWYgKGJ5dGVzIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgcmV0dXJuIGAkeyB0aGlzLnByZWZpeCB9JHsgdGhpcy5iYXNlRW5jb2RlKGJ5dGVzKSB9YDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgRXJyb3IoJ1Vua25vd24gdHlwZSwgbXVzdCBiZSBiaW5hcnkgdHlwZScpO1xuICAgIH1cbiAgfVxufVxuY2xhc3MgRGVjb2RlciB7XG4gIGNvbnN0cnVjdG9yKG5hbWUsIHByZWZpeCwgYmFzZURlY29kZSkge1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5wcmVmaXggPSBwcmVmaXg7XG4gICAgaWYgKHByZWZpeC5jb2RlUG9pbnRBdCgwKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcHJlZml4IGNoYXJhY3RlcicpO1xuICAgIH1cbiAgICB0aGlzLnByZWZpeENvZGVQb2ludCA9IHByZWZpeC5jb2RlUG9pbnRBdCgwKTtcbiAgICB0aGlzLmJhc2VEZWNvZGUgPSBiYXNlRGVjb2RlO1xuICB9XG4gIGRlY29kZSh0ZXh0KSB7XG4gICAgaWYgKHR5cGVvZiB0ZXh0ID09PSAnc3RyaW5nJykge1xuICAgICAgaWYgKHRleHQuY29kZVBvaW50QXQoMCkgIT09IHRoaXMucHJlZml4Q29kZVBvaW50KSB7XG4gICAgICAgIHRocm93IEVycm9yKGBVbmFibGUgdG8gZGVjb2RlIG11bHRpYmFzZSBzdHJpbmcgJHsgSlNPTi5zdHJpbmdpZnkodGV4dCkgfSwgJHsgdGhpcy5uYW1lIH0gZGVjb2RlciBvbmx5IHN1cHBvcnRzIGlucHV0cyBwcmVmaXhlZCB3aXRoICR7IHRoaXMucHJlZml4IH1gKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmJhc2VEZWNvZGUodGV4dC5zbGljZSh0aGlzLnByZWZpeC5sZW5ndGgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgRXJyb3IoJ0NhbiBvbmx5IG11bHRpYmFzZSBkZWNvZGUgc3RyaW5ncycpO1xuICAgIH1cbiAgfVxuICBvcihkZWNvZGVyKSB7XG4gICAgcmV0dXJuIG9yKHRoaXMsIGRlY29kZXIpO1xuICB9XG59XG5jbGFzcyBDb21wb3NlZERlY29kZXIge1xuICBjb25zdHJ1Y3RvcihkZWNvZGVycykge1xuICAgIHRoaXMuZGVjb2RlcnMgPSBkZWNvZGVycztcbiAgfVxuICBvcihkZWNvZGVyKSB7XG4gICAgcmV0dXJuIG9yKHRoaXMsIGRlY29kZXIpO1xuICB9XG4gIGRlY29kZShpbnB1dCkge1xuICAgIGNvbnN0IHByZWZpeCA9IGlucHV0WzBdO1xuICAgIGNvbnN0IGRlY29kZXIgPSB0aGlzLmRlY29kZXJzW3ByZWZpeF07XG4gICAgaWYgKGRlY29kZXIpIHtcbiAgICAgIHJldHVybiBkZWNvZGVyLmRlY29kZShpbnB1dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IFJhbmdlRXJyb3IoYFVuYWJsZSB0byBkZWNvZGUgbXVsdGliYXNlIHN0cmluZyAkeyBKU09OLnN0cmluZ2lmeShpbnB1dCkgfSwgb25seSBpbnB1dHMgcHJlZml4ZWQgd2l0aCAkeyBPYmplY3Qua2V5cyh0aGlzLmRlY29kZXJzKSB9IGFyZSBzdXBwb3J0ZWRgKTtcbiAgICB9XG4gIH1cbn1cbmNvbnN0IG9yID0gKGxlZnQsIHJpZ2h0KSA9PiBuZXcgQ29tcG9zZWREZWNvZGVyKHtcbiAgLi4ubGVmdC5kZWNvZGVycyB8fCB7IFtsZWZ0LnByZWZpeF06IGxlZnQgfSxcbiAgLi4ucmlnaHQuZGVjb2RlcnMgfHwgeyBbcmlnaHQucHJlZml4XTogcmlnaHQgfVxufSk7XG5jbGFzcyBDb2RlYyB7XG4gIGNvbnN0cnVjdG9yKG5hbWUsIHByZWZpeCwgYmFzZUVuY29kZSwgYmFzZURlY29kZSkge1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5wcmVmaXggPSBwcmVmaXg7XG4gICAgdGhpcy5iYXNlRW5jb2RlID0gYmFzZUVuY29kZTtcbiAgICB0aGlzLmJhc2VEZWNvZGUgPSBiYXNlRGVjb2RlO1xuICAgIHRoaXMuZW5jb2RlciA9IG5ldyBFbmNvZGVyKG5hbWUsIHByZWZpeCwgYmFzZUVuY29kZSk7XG4gICAgdGhpcy5kZWNvZGVyID0gbmV3IERlY29kZXIobmFtZSwgcHJlZml4LCBiYXNlRGVjb2RlKTtcbiAgfVxuICBlbmNvZGUoaW5wdXQpIHtcbiAgICByZXR1cm4gdGhpcy5lbmNvZGVyLmVuY29kZShpbnB1dCk7XG4gIH1cbiAgZGVjb2RlKGlucHV0KSB7XG4gICAgcmV0dXJuIHRoaXMuZGVjb2Rlci5kZWNvZGUoaW5wdXQpO1xuICB9XG59XG5jb25zdCBmcm9tID0gKHtuYW1lLCBwcmVmaXgsIGVuY29kZSwgZGVjb2RlfSkgPT4gbmV3IENvZGVjKG5hbWUsIHByZWZpeCwgZW5jb2RlLCBkZWNvZGUpO1xuY29uc3QgYmFzZVggPSAoe3ByZWZpeCwgbmFtZSwgYWxwaGFiZXR9KSA9PiB7XG4gIGNvbnN0IHtlbmNvZGUsIGRlY29kZX0gPSBiYXNlWCQxKGFscGhhYmV0LCBuYW1lKTtcbiAgcmV0dXJuIGZyb20oe1xuICAgIHByZWZpeCxcbiAgICBuYW1lLFxuICAgIGVuY29kZSxcbiAgICBkZWNvZGU6IHRleHQgPT4gYnl0ZXMuY29lcmNlKGRlY29kZSh0ZXh0KSlcbiAgfSk7XG59O1xuY29uc3QgZGVjb2RlID0gKHN0cmluZywgYWxwaGFiZXQsIGJpdHNQZXJDaGFyLCBuYW1lKSA9PiB7XG4gIGNvbnN0IGNvZGVzID0ge307XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYWxwaGFiZXQubGVuZ3RoOyArK2kpIHtcbiAgICBjb2Rlc1thbHBoYWJldFtpXV0gPSBpO1xuICB9XG4gIGxldCBlbmQgPSBzdHJpbmcubGVuZ3RoO1xuICB3aGlsZSAoc3RyaW5nW2VuZCAtIDFdID09PSAnPScpIHtcbiAgICAtLWVuZDtcbiAgfVxuICBjb25zdCBvdXQgPSBuZXcgVWludDhBcnJheShlbmQgKiBiaXRzUGVyQ2hhciAvIDggfCAwKTtcbiAgbGV0IGJpdHMgPSAwO1xuICBsZXQgYnVmZmVyID0gMDtcbiAgbGV0IHdyaXR0ZW4gPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGVuZDsgKytpKSB7XG4gICAgY29uc3QgdmFsdWUgPSBjb2Rlc1tzdHJpbmdbaV1dO1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYE5vbi0keyBuYW1lIH0gY2hhcmFjdGVyYCk7XG4gICAgfVxuICAgIGJ1ZmZlciA9IGJ1ZmZlciA8PCBiaXRzUGVyQ2hhciB8IHZhbHVlO1xuICAgIGJpdHMgKz0gYml0c1BlckNoYXI7XG4gICAgaWYgKGJpdHMgPj0gOCkge1xuICAgICAgYml0cyAtPSA4O1xuICAgICAgb3V0W3dyaXR0ZW4rK10gPSAyNTUgJiBidWZmZXIgPj4gYml0cztcbiAgICB9XG4gIH1cbiAgaWYgKGJpdHMgPj0gYml0c1BlckNoYXIgfHwgMjU1ICYgYnVmZmVyIDw8IDggLSBiaXRzKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdVbmV4cGVjdGVkIGVuZCBvZiBkYXRhJyk7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn07XG5jb25zdCBlbmNvZGUgPSAoZGF0YSwgYWxwaGFiZXQsIGJpdHNQZXJDaGFyKSA9PiB7XG4gIGNvbnN0IHBhZCA9IGFscGhhYmV0W2FscGhhYmV0Lmxlbmd0aCAtIDFdID09PSAnPSc7XG4gIGNvbnN0IG1hc2sgPSAoMSA8PCBiaXRzUGVyQ2hhcikgLSAxO1xuICBsZXQgb3V0ID0gJyc7XG4gIGxldCBiaXRzID0gMDtcbiAgbGV0IGJ1ZmZlciA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7ICsraSkge1xuICAgIGJ1ZmZlciA9IGJ1ZmZlciA8PCA4IHwgZGF0YVtpXTtcbiAgICBiaXRzICs9IDg7XG4gICAgd2hpbGUgKGJpdHMgPiBiaXRzUGVyQ2hhcikge1xuICAgICAgYml0cyAtPSBiaXRzUGVyQ2hhcjtcbiAgICAgIG91dCArPSBhbHBoYWJldFttYXNrICYgYnVmZmVyID4+IGJpdHNdO1xuICAgIH1cbiAgfVxuICBpZiAoYml0cykge1xuICAgIG91dCArPSBhbHBoYWJldFttYXNrICYgYnVmZmVyIDw8IGJpdHNQZXJDaGFyIC0gYml0c107XG4gIH1cbiAgaWYgKHBhZCkge1xuICAgIHdoaWxlIChvdXQubGVuZ3RoICogYml0c1BlckNoYXIgJiA3KSB7XG4gICAgICBvdXQgKz0gJz0nO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb3V0O1xufTtcbmNvbnN0IHJmYzQ2NDggPSAoe25hbWUsIHByZWZpeCwgYml0c1BlckNoYXIsIGFscGhhYmV0fSkgPT4ge1xuICByZXR1cm4gZnJvbSh7XG4gICAgcHJlZml4LFxuICAgIG5hbWUsXG4gICAgZW5jb2RlKGlucHV0KSB7XG4gICAgICByZXR1cm4gZW5jb2RlKGlucHV0LCBhbHBoYWJldCwgYml0c1BlckNoYXIpO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0KSB7XG4gICAgICByZXR1cm4gZGVjb2RlKGlucHV0LCBhbHBoYWJldCwgYml0c1BlckNoYXIsIG5hbWUpO1xuICAgIH1cbiAgfSk7XG59O1xuXG5leHBvcnRzLkNvZGVjID0gQ29kZWM7XG5leHBvcnRzLmJhc2VYID0gYmFzZVg7XG5leHBvcnRzLmZyb20gPSBmcm9tO1xuZXhwb3J0cy5vciA9IG9yO1xuZXhwb3J0cy5yZmM0NjQ4ID0gcmZjNDY0ODtcbiIsICIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBiYXNlID0gcmVxdWlyZSgnLi9iYXNlLmpzJyk7XG52YXIgYnl0ZXMgPSByZXF1aXJlKCcuLi9ieXRlcy5qcycpO1xuXG5jb25zdCBpZGVudGl0eSA9IGJhc2UuZnJvbSh7XG4gIHByZWZpeDogJ1xcMCcsXG4gIG5hbWU6ICdpZGVudGl0eScsXG4gIGVuY29kZTogYnVmID0+IGJ5dGVzLnRvU3RyaW5nKGJ1ZiksXG4gIGRlY29kZTogc3RyID0+IGJ5dGVzLmZyb21TdHJpbmcoc3RyKVxufSk7XG5cbmV4cG9ydHMuaWRlbnRpdHkgPSBpZGVudGl0eTtcbiIsICIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBiYXNlID0gcmVxdWlyZSgnLi9iYXNlLmpzJyk7XG5cbmNvbnN0IGJhc2UyID0gYmFzZS5yZmM0NjQ4KHtcbiAgcHJlZml4OiAnMCcsXG4gIG5hbWU6ICdiYXNlMicsXG4gIGFscGhhYmV0OiAnMDEnLFxuICBiaXRzUGVyQ2hhcjogMVxufSk7XG5cbmV4cG9ydHMuYmFzZTIgPSBiYXNlMjtcbiIsICIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBiYXNlID0gcmVxdWlyZSgnLi9iYXNlLmpzJyk7XG5cbmNvbnN0IGJhc2U4ID0gYmFzZS5yZmM0NjQ4KHtcbiAgcHJlZml4OiAnNycsXG4gIG5hbWU6ICdiYXNlOCcsXG4gIGFscGhhYmV0OiAnMDEyMzQ1NjcnLFxuICBiaXRzUGVyQ2hhcjogM1xufSk7XG5cbmV4cG9ydHMuYmFzZTggPSBiYXNlODtcbiIsICIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBiYXNlID0gcmVxdWlyZSgnLi9iYXNlLmpzJyk7XG5cbmNvbnN0IGJhc2UxMCA9IGJhc2UuYmFzZVgoe1xuICBwcmVmaXg6ICc5JyxcbiAgbmFtZTogJ2Jhc2UxMCcsXG4gIGFscGhhYmV0OiAnMDEyMzQ1Njc4OSdcbn0pO1xuXG5leHBvcnRzLmJhc2UxMCA9IGJhc2UxMDtcbiIsICIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBiYXNlID0gcmVxdWlyZSgnLi9iYXNlLmpzJyk7XG5cbmNvbnN0IGJhc2UxNiA9IGJhc2UucmZjNDY0OCh7XG4gIHByZWZpeDogJ2YnLFxuICBuYW1lOiAnYmFzZTE2JyxcbiAgYWxwaGFiZXQ6ICcwMTIzNDU2Nzg5YWJjZGVmJyxcbiAgYml0c1BlckNoYXI6IDRcbn0pO1xuY29uc3QgYmFzZTE2dXBwZXIgPSBiYXNlLnJmYzQ2NDgoe1xuICBwcmVmaXg6ICdGJyxcbiAgbmFtZTogJ2Jhc2UxNnVwcGVyJyxcbiAgYWxwaGFiZXQ6ICcwMTIzNDU2Nzg5QUJDREVGJyxcbiAgYml0c1BlckNoYXI6IDRcbn0pO1xuXG5leHBvcnRzLmJhc2UxNiA9IGJhc2UxNjtcbmV4cG9ydHMuYmFzZTE2dXBwZXIgPSBiYXNlMTZ1cHBlcjtcbiIsICIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBiYXNlID0gcmVxdWlyZSgnLi9iYXNlLmpzJyk7XG5cbmNvbnN0IGJhc2UzMiA9IGJhc2UucmZjNDY0OCh7XG4gIHByZWZpeDogJ2InLFxuICBuYW1lOiAnYmFzZTMyJyxcbiAgYWxwaGFiZXQ6ICdhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejIzNDU2NycsXG4gIGJpdHNQZXJDaGFyOiA1XG59KTtcbmNvbnN0IGJhc2UzMnVwcGVyID0gYmFzZS5yZmM0NjQ4KHtcbiAgcHJlZml4OiAnQicsXG4gIG5hbWU6ICdiYXNlMzJ1cHBlcicsXG4gIGFscGhhYmV0OiAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVoyMzQ1NjcnLFxuICBiaXRzUGVyQ2hhcjogNVxufSk7XG5jb25zdCBiYXNlMzJwYWQgPSBiYXNlLnJmYzQ2NDgoe1xuICBwcmVmaXg6ICdjJyxcbiAgbmFtZTogJ2Jhc2UzMnBhZCcsXG4gIGFscGhhYmV0OiAnYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoyMzQ1Njc9JyxcbiAgYml0c1BlckNoYXI6IDVcbn0pO1xuY29uc3QgYmFzZTMycGFkdXBwZXIgPSBiYXNlLnJmYzQ2NDgoe1xuICBwcmVmaXg6ICdDJyxcbiAgbmFtZTogJ2Jhc2UzMnBhZHVwcGVyJyxcbiAgYWxwaGFiZXQ6ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWjIzNDU2Nz0nLFxuICBiaXRzUGVyQ2hhcjogNVxufSk7XG5jb25zdCBiYXNlMzJoZXggPSBiYXNlLnJmYzQ2NDgoe1xuICBwcmVmaXg6ICd2JyxcbiAgbmFtZTogJ2Jhc2UzMmhleCcsXG4gIGFscGhhYmV0OiAnMDEyMzQ1Njc4OWFiY2RlZmdoaWprbG1ub3BxcnN0dXYnLFxuICBiaXRzUGVyQ2hhcjogNVxufSk7XG5jb25zdCBiYXNlMzJoZXh1cHBlciA9IGJhc2UucmZjNDY0OCh7XG4gIHByZWZpeDogJ1YnLFxuICBuYW1lOiAnYmFzZTMyaGV4dXBwZXInLFxuICBhbHBoYWJldDogJzAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWJyxcbiAgYml0c1BlckNoYXI6IDVcbn0pO1xuY29uc3QgYmFzZTMyaGV4cGFkID0gYmFzZS5yZmM0NjQ4KHtcbiAgcHJlZml4OiAndCcsXG4gIG5hbWU6ICdiYXNlMzJoZXhwYWQnLFxuICBhbHBoYWJldDogJzAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2PScsXG4gIGJpdHNQZXJDaGFyOiA1XG59KTtcbmNvbnN0IGJhc2UzMmhleHBhZHVwcGVyID0gYmFzZS5yZmM0NjQ4KHtcbiAgcHJlZml4OiAnVCcsXG4gIG5hbWU6ICdiYXNlMzJoZXhwYWR1cHBlcicsXG4gIGFscGhhYmV0OiAnMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVY9JyxcbiAgYml0c1BlckNoYXI6IDVcbn0pO1xuY29uc3QgYmFzZTMyeiA9IGJhc2UucmZjNDY0OCh7XG4gIHByZWZpeDogJ2gnLFxuICBuYW1lOiAnYmFzZTMyeicsXG4gIGFscGhhYmV0OiAneWJuZHJmZzhlamttY3BxeG90MXV3aXN6YTM0NWg3NjknLFxuICBiaXRzUGVyQ2hhcjogNVxufSk7XG5cbmV4cG9ydHMuYmFzZTMyID0gYmFzZTMyO1xuZXhwb3J0cy5iYXNlMzJoZXggPSBiYXNlMzJoZXg7XG5leHBvcnRzLmJhc2UzMmhleHBhZCA9IGJhc2UzMmhleHBhZDtcbmV4cG9ydHMuYmFzZTMyaGV4cGFkdXBwZXIgPSBiYXNlMzJoZXhwYWR1cHBlcjtcbmV4cG9ydHMuYmFzZTMyaGV4dXBwZXIgPSBiYXNlMzJoZXh1cHBlcjtcbmV4cG9ydHMuYmFzZTMycGFkID0gYmFzZTMycGFkO1xuZXhwb3J0cy5iYXNlMzJwYWR1cHBlciA9IGJhc2UzMnBhZHVwcGVyO1xuZXhwb3J0cy5iYXNlMzJ1cHBlciA9IGJhc2UzMnVwcGVyO1xuZXhwb3J0cy5iYXNlMzJ6ID0gYmFzZTMyejtcbiIsICIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBiYXNlID0gcmVxdWlyZSgnLi9iYXNlLmpzJyk7XG5cbmNvbnN0IGJhc2UzNiA9IGJhc2UuYmFzZVgoe1xuICBwcmVmaXg6ICdrJyxcbiAgbmFtZTogJ2Jhc2UzNicsXG4gIGFscGhhYmV0OiAnMDEyMzQ1Njc4OWFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6J1xufSk7XG5jb25zdCBiYXNlMzZ1cHBlciA9IGJhc2UuYmFzZVgoe1xuICBwcmVmaXg6ICdLJyxcbiAgbmFtZTogJ2Jhc2UzNnVwcGVyJyxcbiAgYWxwaGFiZXQ6ICcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVonXG59KTtcblxuZXhwb3J0cy5iYXNlMzYgPSBiYXNlMzY7XG5leHBvcnRzLmJhc2UzNnVwcGVyID0gYmFzZTM2dXBwZXI7XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgYmFzZSA9IHJlcXVpcmUoJy4vYmFzZS5qcycpO1xuXG5jb25zdCBiYXNlNThidGMgPSBiYXNlLmJhc2VYKHtcbiAgbmFtZTogJ2Jhc2U1OGJ0YycsXG4gIHByZWZpeDogJ3onLFxuICBhbHBoYWJldDogJzEyMzQ1Njc4OUFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWmFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXonXG59KTtcbmNvbnN0IGJhc2U1OGZsaWNrciA9IGJhc2UuYmFzZVgoe1xuICBuYW1lOiAnYmFzZTU4ZmxpY2tyJyxcbiAgcHJlZml4OiAnWicsXG4gIGFscGhhYmV0OiAnMTIzNDU2Nzg5YWJjZGVmZ2hpamttbm9wcXJzdHV2d3h5ekFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWidcbn0pO1xuXG5leHBvcnRzLmJhc2U1OGJ0YyA9IGJhc2U1OGJ0YztcbmV4cG9ydHMuYmFzZTU4ZmxpY2tyID0gYmFzZTU4ZmxpY2tyO1xuIiwgIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGJhc2UgPSByZXF1aXJlKCcuL2Jhc2UuanMnKTtcblxuY29uc3QgYmFzZTY0ID0gYmFzZS5yZmM0NjQ4KHtcbiAgcHJlZml4OiAnbScsXG4gIG5hbWU6ICdiYXNlNjQnLFxuICBhbHBoYWJldDogJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nLFxuICBiaXRzUGVyQ2hhcjogNlxufSk7XG5jb25zdCBiYXNlNjRwYWQgPSBiYXNlLnJmYzQ2NDgoe1xuICBwcmVmaXg6ICdNJyxcbiAgbmFtZTogJ2Jhc2U2NHBhZCcsXG4gIGFscGhhYmV0OiAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz0nLFxuICBiaXRzUGVyQ2hhcjogNlxufSk7XG5jb25zdCBiYXNlNjR1cmwgPSBiYXNlLnJmYzQ2NDgoe1xuICBwcmVmaXg6ICd1JyxcbiAgbmFtZTogJ2Jhc2U2NHVybCcsXG4gIGFscGhhYmV0OiAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODktXycsXG4gIGJpdHNQZXJDaGFyOiA2XG59KTtcbmNvbnN0IGJhc2U2NHVybHBhZCA9IGJhc2UucmZjNDY0OCh7XG4gIHByZWZpeDogJ1UnLFxuICBuYW1lOiAnYmFzZTY0dXJscGFkJyxcbiAgYWxwaGFiZXQ6ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OS1fPScsXG4gIGJpdHNQZXJDaGFyOiA2XG59KTtcblxuZXhwb3J0cy5iYXNlNjQgPSBiYXNlNjQ7XG5leHBvcnRzLmJhc2U2NHBhZCA9IGJhc2U2NHBhZDtcbmV4cG9ydHMuYmFzZTY0dXJsID0gYmFzZTY0dXJsO1xuZXhwb3J0cy5iYXNlNjR1cmxwYWQgPSBiYXNlNjR1cmxwYWQ7XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgYmFzZSA9IHJlcXVpcmUoJy4vYmFzZS5qcycpO1xuXG5jb25zdCBhbHBoYWJldCA9IEFycmF5LmZyb20oJ1xcdUQ4M0RcXHVERTgwXFx1RDgzRVxcdURFOTBcXHUyNjA0XFx1RDgzRFxcdURFRjBcXHVEODNDXFx1REYwQ1xcdUQ4M0NcXHVERjExXFx1RDgzQ1xcdURGMTJcXHVEODNDXFx1REYxM1xcdUQ4M0NcXHVERjE0XFx1RDgzQ1xcdURGMTVcXHVEODNDXFx1REYxNlxcdUQ4M0NcXHVERjE3XFx1RDgzQ1xcdURGMThcXHVEODNDXFx1REYwRFxcdUQ4M0NcXHVERjBGXFx1RDgzQ1xcdURGMEVcXHVEODNEXFx1REMwOVxcdTI2MDBcXHVEODNEXFx1RENCQlxcdUQ4M0RcXHVEREE1XFx1RDgzRFxcdURDQkVcXHVEODNEXFx1RENCRlxcdUQ4M0RcXHVERTAyXFx1Mjc2NFxcdUQ4M0RcXHVERTBEXFx1RDgzRVxcdUREMjNcXHVEODNEXFx1REUwQVxcdUQ4M0RcXHVERTRGXFx1RDgzRFxcdURDOTVcXHVEODNEXFx1REUyRFxcdUQ4M0RcXHVERTE4XFx1RDgzRFxcdURDNERcXHVEODNEXFx1REUwNVxcdUQ4M0RcXHVEQzRGXFx1RDgzRFxcdURFMDFcXHVEODNEXFx1REQyNVxcdUQ4M0VcXHVERDcwXFx1RDgzRFxcdURDOTRcXHVEODNEXFx1REM5NlxcdUQ4M0RcXHVEQzk5XFx1RDgzRFxcdURFMjJcXHVEODNFXFx1REQxNFxcdUQ4M0RcXHVERTA2XFx1RDgzRFxcdURFNDRcXHVEODNEXFx1RENBQVxcdUQ4M0RcXHVERTA5XFx1MjYzQVxcdUQ4M0RcXHVEQzRDXFx1RDgzRVxcdUREMTdcXHVEODNEXFx1REM5Q1xcdUQ4M0RcXHVERTE0XFx1RDgzRFxcdURFMEVcXHVEODNEXFx1REUwN1xcdUQ4M0NcXHVERjM5XFx1RDgzRVxcdUREMjZcXHVEODNDXFx1REY4OVxcdUQ4M0RcXHVEQzlFXFx1MjcwQ1xcdTI3MjhcXHVEODNFXFx1REQzN1xcdUQ4M0RcXHVERTMxXFx1RDgzRFxcdURFMENcXHVEODNDXFx1REYzOFxcdUQ4M0RcXHVERTRDXFx1RDgzRFxcdURFMEJcXHVEODNEXFx1REM5N1xcdUQ4M0RcXHVEQzlBXFx1RDgzRFxcdURFMEZcXHVEODNEXFx1REM5QlxcdUQ4M0RcXHVERTQyXFx1RDgzRFxcdURDOTNcXHVEODNFXFx1REQyOVxcdUQ4M0RcXHVERTA0XFx1RDgzRFxcdURFMDBcXHVEODNEXFx1RERBNFxcdUQ4M0RcXHVERTAzXFx1RDgzRFxcdURDQUZcXHVEODNEXFx1REU0OFxcdUQ4M0RcXHVEQzQ3XFx1RDgzQ1xcdURGQjZcXHVEODNEXFx1REUxMlxcdUQ4M0VcXHVERDJEXFx1Mjc2M1xcdUQ4M0RcXHVERTFDXFx1RDgzRFxcdURDOEJcXHVEODNEXFx1REM0MFxcdUQ4M0RcXHVERTJBXFx1RDgzRFxcdURFMTFcXHVEODNEXFx1RENBNVxcdUQ4M0RcXHVERTRCXFx1RDgzRFxcdURFMUVcXHVEODNEXFx1REUyOVxcdUQ4M0RcXHVERTIxXFx1RDgzRVxcdUREMkFcXHVEODNEXFx1REM0QVxcdUQ4M0VcXHVERDczXFx1RDgzRFxcdURFMjVcXHVEODNFXFx1REQyNFxcdUQ4M0RcXHVEQzQ5XFx1RDgzRFxcdURDODNcXHVEODNEXFx1REUzM1xcdTI3MEJcXHVEODNEXFx1REUxQVxcdUQ4M0RcXHVERTFEXFx1RDgzRFxcdURFMzRcXHVEODNDXFx1REYxRlxcdUQ4M0RcXHVERTJDXFx1RDgzRFxcdURFNDNcXHVEODNDXFx1REY0MFxcdUQ4M0NcXHVERjM3XFx1RDgzRFxcdURFM0JcXHVEODNEXFx1REUxM1xcdTJCNTBcXHUyNzA1XFx1RDgzRVxcdUREN0FcXHVEODNDXFx1REYwOFxcdUQ4M0RcXHVERTA4XFx1RDgzRVxcdUREMThcXHVEODNEXFx1RENBNlxcdTI3MTRcXHVEODNEXFx1REUyM1xcdUQ4M0NcXHVERkMzXFx1RDgzRFxcdURDOTBcXHUyNjM5XFx1RDgzQ1xcdURGOEFcXHVEODNEXFx1REM5OFxcdUQ4M0RcXHVERTIwXFx1MjYxRFxcdUQ4M0RcXHVERTE1XFx1RDgzQ1xcdURGM0FcXHVEODNDXFx1REY4MlxcdUQ4M0NcXHVERjNCXFx1RDgzRFxcdURFMTBcXHVEODNEXFx1REQ5NVxcdUQ4M0RcXHVEQzlEXFx1RDgzRFxcdURFNEFcXHVEODNEXFx1REUzOVxcdUQ4M0RcXHVEREUzXFx1RDgzRFxcdURDQUJcXHVEODNEXFx1REM4MFxcdUQ4M0RcXHVEQzUxXFx1RDgzQ1xcdURGQjVcXHVEODNFXFx1REQxRVxcdUQ4M0RcXHVERTFCXFx1RDgzRFxcdUREMzRcXHVEODNEXFx1REUyNFxcdUQ4M0NcXHVERjNDXFx1RDgzRFxcdURFMkJcXHUyNkJEXFx1RDgzRVxcdUREMTlcXHUyNjE1XFx1RDgzQ1xcdURGQzZcXHVEODNFXFx1REQyQlxcdUQ4M0RcXHVEQzQ4XFx1RDgzRFxcdURFMkVcXHVEODNEXFx1REU0NlxcdUQ4M0NcXHVERjdCXFx1RDgzQ1xcdURGNDNcXHVEODNEXFx1REMzNlxcdUQ4M0RcXHVEQzgxXFx1RDgzRFxcdURFMzJcXHVEODNDXFx1REYzRlxcdUQ4M0VcXHVEREUxXFx1RDgzQ1xcdURGODFcXHUyNkExXFx1RDgzQ1xcdURGMUVcXHVEODNDXFx1REY4OFxcdTI3NENcXHUyNzBBXFx1RDgzRFxcdURDNEJcXHVEODNEXFx1REUzMFxcdUQ4M0VcXHVERDI4XFx1RDgzRFxcdURFMzZcXHVEODNFXFx1REQxRFxcdUQ4M0RcXHVERUI2XFx1RDgzRFxcdURDQjBcXHVEODNDXFx1REY1M1xcdUQ4M0RcXHVEQ0EyXFx1RDgzRVxcdUREMUZcXHVEODNEXFx1REU0MVxcdUQ4M0RcXHVERUE4XFx1RDgzRFxcdURDQThcXHVEODNFXFx1REQyQ1xcdTI3MDhcXHVEODNDXFx1REY4MFxcdUQ4M0NcXHVERjdBXFx1RDgzRVxcdUREMTNcXHVEODNEXFx1REUxOVxcdUQ4M0RcXHVEQzlGXFx1RDgzQ1xcdURGMzFcXHVEODNEXFx1REUxNlxcdUQ4M0RcXHVEQzc2XFx1RDgzRVxcdURENzRcXHUyNUI2XFx1MjdBMVxcdTI3NTNcXHVEODNEXFx1REM4RVxcdUQ4M0RcXHVEQ0I4XFx1MkIwN1xcdUQ4M0RcXHVERTI4XFx1RDgzQ1xcdURGMUFcXHVEODNFXFx1REQ4QlxcdUQ4M0RcXHVERTM3XFx1RDgzRFxcdUREN0FcXHUyNkEwXFx1RDgzRFxcdURFNDVcXHVEODNEXFx1REUxRlxcdUQ4M0RcXHVERTM1XFx1RDgzRFxcdURDNEVcXHVEODNFXFx1REQzMlxcdUQ4M0VcXHVERDIwXFx1RDgzRVxcdUREMjdcXHVEODNEXFx1RENDQ1xcdUQ4M0RcXHVERDM1XFx1RDgzRFxcdURDODVcXHVEODNFXFx1REREMFxcdUQ4M0RcXHVEQzNFXFx1RDgzQ1xcdURGNTJcXHVEODNEXFx1REUxN1xcdUQ4M0VcXHVERDExXFx1RDgzQ1xcdURGMEFcXHVEODNFXFx1REQyRlxcdUQ4M0RcXHVEQzM3XFx1MjYwRVxcdUQ4M0RcXHVEQ0E3XFx1RDgzRFxcdURFMkZcXHVEODNEXFx1REM4NlxcdUQ4M0RcXHVEQzQ2XFx1RDgzQ1xcdURGQTRcXHVEODNEXFx1REU0N1xcdUQ4M0NcXHVERjUxXFx1Mjc0NFxcdUQ4M0NcXHVERjM0XFx1RDgzRFxcdURDQTNcXHVEODNEXFx1REMzOFxcdUQ4M0RcXHVEQzhDXFx1RDgzRFxcdURDQ0RcXHVEODNFXFx1REQ0MFxcdUQ4M0VcXHVERDIyXFx1RDgzRFxcdURDNDVcXHVEODNEXFx1RENBMVxcdUQ4M0RcXHVEQ0E5XFx1RDgzRFxcdURDNTBcXHVEODNEXFx1RENGOFxcdUQ4M0RcXHVEQzdCXFx1RDgzRVxcdUREMTBcXHVEODNFXFx1REQyRVxcdUQ4M0NcXHVERkJDXFx1RDgzRVxcdURENzVcXHVEODNEXFx1REVBOVxcdUQ4M0NcXHVERjRFXFx1RDgzQ1xcdURGNEFcXHVEODNEXFx1REM3Q1xcdUQ4M0RcXHVEQzhEXFx1RDgzRFxcdURDRTNcXHVEODNFXFx1REQ0MicpO1xuY29uc3QgYWxwaGFiZXRCeXRlc1RvQ2hhcnMgPSBhbHBoYWJldC5yZWR1Y2UoKHAsIGMsIGkpID0+IHtcbiAgcFtpXSA9IGM7XG4gIHJldHVybiBwO1xufSwgW10pO1xuY29uc3QgYWxwaGFiZXRDaGFyc1RvQnl0ZXMgPSBhbHBoYWJldC5yZWR1Y2UoKHAsIGMsIGkpID0+IHtcbiAgcFtjLmNvZGVQb2ludEF0KDApXSA9IGk7XG4gIHJldHVybiBwO1xufSwgW10pO1xuZnVuY3Rpb24gZW5jb2RlKGRhdGEpIHtcbiAgcmV0dXJuIGRhdGEucmVkdWNlKChwLCBjKSA9PiB7XG4gICAgcCArPSBhbHBoYWJldEJ5dGVzVG9DaGFyc1tjXTtcbiAgICByZXR1cm4gcDtcbiAgfSwgJycpO1xufVxuZnVuY3Rpb24gZGVjb2RlKHN0cikge1xuICBjb25zdCBieXRzID0gW107XG4gIGZvciAoY29uc3QgY2hhciBvZiBzdHIpIHtcbiAgICBjb25zdCBieXQgPSBhbHBoYWJldENoYXJzVG9CeXRlc1tjaGFyLmNvZGVQb2ludEF0KDApXTtcbiAgICBpZiAoYnl0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTm9uLWJhc2UyNTZlbW9qaSBjaGFyYWN0ZXI6ICR7IGNoYXIgfWApO1xuICAgIH1cbiAgICBieXRzLnB1c2goYnl0KTtcbiAgfVxuICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnl0cyk7XG59XG5jb25zdCBiYXNlMjU2ZW1vamkgPSBiYXNlLmZyb20oe1xuICBwcmVmaXg6ICdcXHVEODNEXFx1REU4MCcsXG4gIG5hbWU6ICdiYXNlMjU2ZW1vamknLFxuICBlbmNvZGUsXG4gIGRlY29kZVxufSk7XG5cbmV4cG9ydHMuYmFzZTI1NmVtb2ppID0gYmFzZTI1NmVtb2ppO1xuIiwgIid1c2Ugc3RyaWN0JztcblxudmFyIGVuY29kZV8xID0gZW5jb2RlO1xudmFyIE1TQiA9IDEyOCwgUkVTVCA9IDEyNywgTVNCQUxMID0gflJFU1QsIElOVCA9IE1hdGgucG93KDIsIDMxKTtcbmZ1bmN0aW9uIGVuY29kZShudW0sIG91dCwgb2Zmc2V0KSB7XG4gIG91dCA9IG91dCB8fCBbXTtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG4gIHZhciBvbGRPZmZzZXQgPSBvZmZzZXQ7XG4gIHdoaWxlIChudW0gPj0gSU5UKSB7XG4gICAgb3V0W29mZnNldCsrXSA9IG51bSAmIDI1NSB8IE1TQjtcbiAgICBudW0gLz0gMTI4O1xuICB9XG4gIHdoaWxlIChudW0gJiBNU0JBTEwpIHtcbiAgICBvdXRbb2Zmc2V0KytdID0gbnVtICYgMjU1IHwgTVNCO1xuICAgIG51bSA+Pj49IDc7XG4gIH1cbiAgb3V0W29mZnNldF0gPSBudW0gfCAwO1xuICBlbmNvZGUuYnl0ZXMgPSBvZmZzZXQgLSBvbGRPZmZzZXQgKyAxO1xuICByZXR1cm4gb3V0O1xufVxudmFyIGRlY29kZSA9IHJlYWQ7XG52YXIgTVNCJDEgPSAxMjgsIFJFU1QkMSA9IDEyNztcbmZ1bmN0aW9uIHJlYWQoYnVmLCBvZmZzZXQpIHtcbiAgdmFyIHJlcyA9IDAsIG9mZnNldCA9IG9mZnNldCB8fCAwLCBzaGlmdCA9IDAsIGNvdW50ZXIgPSBvZmZzZXQsIGIsIGwgPSBidWYubGVuZ3RoO1xuICBkbyB7XG4gICAgaWYgKGNvdW50ZXIgPj0gbCkge1xuICAgICAgcmVhZC5ieXRlcyA9IDA7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQ291bGQgbm90IGRlY29kZSB2YXJpbnQnKTtcbiAgICB9XG4gICAgYiA9IGJ1Zltjb3VudGVyKytdO1xuICAgIHJlcyArPSBzaGlmdCA8IDI4ID8gKGIgJiBSRVNUJDEpIDw8IHNoaWZ0IDogKGIgJiBSRVNUJDEpICogTWF0aC5wb3coMiwgc2hpZnQpO1xuICAgIHNoaWZ0ICs9IDc7XG4gIH0gd2hpbGUgKGIgPj0gTVNCJDEpO1xuICByZWFkLmJ5dGVzID0gY291bnRlciAtIG9mZnNldDtcbiAgcmV0dXJuIHJlcztcbn1cbnZhciBOMSA9IE1hdGgucG93KDIsIDcpO1xudmFyIE4yID0gTWF0aC5wb3coMiwgMTQpO1xudmFyIE4zID0gTWF0aC5wb3coMiwgMjEpO1xudmFyIE40ID0gTWF0aC5wb3coMiwgMjgpO1xudmFyIE41ID0gTWF0aC5wb3coMiwgMzUpO1xudmFyIE42ID0gTWF0aC5wb3coMiwgNDIpO1xudmFyIE43ID0gTWF0aC5wb3coMiwgNDkpO1xudmFyIE44ID0gTWF0aC5wb3coMiwgNTYpO1xudmFyIE45ID0gTWF0aC5wb3coMiwgNjMpO1xudmFyIGxlbmd0aCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPCBOMSA/IDEgOiB2YWx1ZSA8IE4yID8gMiA6IHZhbHVlIDwgTjMgPyAzIDogdmFsdWUgPCBONCA/IDQgOiB2YWx1ZSA8IE41ID8gNSA6IHZhbHVlIDwgTjYgPyA2IDogdmFsdWUgPCBONyA/IDcgOiB2YWx1ZSA8IE44ID8gOCA6IHZhbHVlIDwgTjkgPyA5IDogMTA7XG59O1xudmFyIHZhcmludCA9IHtcbiAgZW5jb2RlOiBlbmNvZGVfMSxcbiAgZGVjb2RlOiBkZWNvZGUsXG4gIGVuY29kaW5nTGVuZ3RoOiBsZW5ndGhcbn07XG52YXIgX2JycnBfdmFyaW50ID0gdmFyaW50O1xudmFyIHZhcmludCQxID0gX2JycnBfdmFyaW50O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHZhcmludCQxO1xuIiwgIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIHZhcmludCQxID0gcmVxdWlyZSgnLi4vdmVuZG9yL3ZhcmludC5qcycpO1xuXG5jb25zdCBkZWNvZGUgPSAoZGF0YSwgb2Zmc2V0ID0gMCkgPT4ge1xuICBjb25zdCBjb2RlID0gdmFyaW50JDEuZGVjb2RlKGRhdGEsIG9mZnNldCk7XG4gIHJldHVybiBbXG4gICAgY29kZSxcbiAgICB2YXJpbnQkMS5kZWNvZGUuYnl0ZXNcbiAgXTtcbn07XG5jb25zdCBlbmNvZGVUbyA9IChpbnQsIHRhcmdldCwgb2Zmc2V0ID0gMCkgPT4ge1xuICB2YXJpbnQkMS5lbmNvZGUoaW50LCB0YXJnZXQsIG9mZnNldCk7XG4gIHJldHVybiB0YXJnZXQ7XG59O1xuY29uc3QgZW5jb2RpbmdMZW5ndGggPSBpbnQgPT4ge1xuICByZXR1cm4gdmFyaW50JDEuZW5jb2RpbmdMZW5ndGgoaW50KTtcbn07XG5cbmV4cG9ydHMuZGVjb2RlID0gZGVjb2RlO1xuZXhwb3J0cy5lbmNvZGVUbyA9IGVuY29kZVRvO1xuZXhwb3J0cy5lbmNvZGluZ0xlbmd0aCA9IGVuY29kaW5nTGVuZ3RoO1xuIiwgIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGJ5dGVzID0gcmVxdWlyZSgnLi4vYnl0ZXMuanMnKTtcbnZhciB2YXJpbnQgPSByZXF1aXJlKCcuLi92YXJpbnQuanMnKTtcblxuY29uc3QgY3JlYXRlID0gKGNvZGUsIGRpZ2VzdCkgPT4ge1xuICBjb25zdCBzaXplID0gZGlnZXN0LmJ5dGVMZW5ndGg7XG4gIGNvbnN0IHNpemVPZmZzZXQgPSB2YXJpbnQuZW5jb2RpbmdMZW5ndGgoY29kZSk7XG4gIGNvbnN0IGRpZ2VzdE9mZnNldCA9IHNpemVPZmZzZXQgKyB2YXJpbnQuZW5jb2RpbmdMZW5ndGgoc2l6ZSk7XG4gIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoZGlnZXN0T2Zmc2V0ICsgc2l6ZSk7XG4gIHZhcmludC5lbmNvZGVUbyhjb2RlLCBieXRlcywgMCk7XG4gIHZhcmludC5lbmNvZGVUbyhzaXplLCBieXRlcywgc2l6ZU9mZnNldCk7XG4gIGJ5dGVzLnNldChkaWdlc3QsIGRpZ2VzdE9mZnNldCk7XG4gIHJldHVybiBuZXcgRGlnZXN0KGNvZGUsIHNpemUsIGRpZ2VzdCwgYnl0ZXMpO1xufTtcbmNvbnN0IGRlY29kZSA9IG11bHRpaGFzaCA9PiB7XG4gIGNvbnN0IGJ5dGVzJDEgPSBieXRlcy5jb2VyY2UobXVsdGloYXNoKTtcbiAgY29uc3QgW2NvZGUsIHNpemVPZmZzZXRdID0gdmFyaW50LmRlY29kZShieXRlcyQxKTtcbiAgY29uc3QgW3NpemUsIGRpZ2VzdE9mZnNldF0gPSB2YXJpbnQuZGVjb2RlKGJ5dGVzJDEuc3ViYXJyYXkoc2l6ZU9mZnNldCkpO1xuICBjb25zdCBkaWdlc3QgPSBieXRlcyQxLnN1YmFycmF5KHNpemVPZmZzZXQgKyBkaWdlc3RPZmZzZXQpO1xuICBpZiAoZGlnZXN0LmJ5dGVMZW5ndGggIT09IHNpemUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0luY29ycmVjdCBsZW5ndGgnKTtcbiAgfVxuICByZXR1cm4gbmV3IERpZ2VzdChjb2RlLCBzaXplLCBkaWdlc3QsIGJ5dGVzJDEpO1xufTtcbmNvbnN0IGVxdWFscyA9IChhLCBiKSA9PiB7XG4gIGlmIChhID09PSBiKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGEuY29kZSA9PT0gYi5jb2RlICYmIGEuc2l6ZSA9PT0gYi5zaXplICYmIGJ5dGVzLmVxdWFscyhhLmJ5dGVzLCBiLmJ5dGVzKTtcbiAgfVxufTtcbmNsYXNzIERpZ2VzdCB7XG4gIGNvbnN0cnVjdG9yKGNvZGUsIHNpemUsIGRpZ2VzdCwgYnl0ZXMpIHtcbiAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gICAgdGhpcy5kaWdlc3QgPSBkaWdlc3Q7XG4gICAgdGhpcy5ieXRlcyA9IGJ5dGVzO1xuICB9XG59XG5cbmV4cG9ydHMuRGlnZXN0ID0gRGlnZXN0O1xuZXhwb3J0cy5jcmVhdGUgPSBjcmVhdGU7XG5leHBvcnRzLmRlY29kZSA9IGRlY29kZTtcbmV4cG9ydHMuZXF1YWxzID0gZXF1YWxzO1xuIiwgIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGRpZ2VzdCA9IHJlcXVpcmUoJy4vZGlnZXN0LmpzJyk7XG5cbmNvbnN0IGZyb20gPSAoe25hbWUsIGNvZGUsIGVuY29kZX0pID0+IG5ldyBIYXNoZXIobmFtZSwgY29kZSwgZW5jb2RlKTtcbmNsYXNzIEhhc2hlciB7XG4gIGNvbnN0cnVjdG9yKG5hbWUsIGNvZGUsIGVuY29kZSkge1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICB0aGlzLmVuY29kZSA9IGVuY29kZTtcbiAgfVxuICBkaWdlc3QoaW5wdXQpIHtcbiAgICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmVuY29kZShpbnB1dCk7XG4gICAgICByZXR1cm4gcmVzdWx0IGluc3RhbmNlb2YgVWludDhBcnJheSA/IGRpZ2VzdC5jcmVhdGUodGhpcy5jb2RlLCByZXN1bHQpIDogcmVzdWx0LnRoZW4oZGlnZXN0JDEgPT4gZGlnZXN0LmNyZWF0ZSh0aGlzLmNvZGUsIGRpZ2VzdCQxKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IEVycm9yKCdVbmtub3duIHR5cGUsIG11c3QgYmUgYmluYXJ5IHR5cGUnKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0cy5IYXNoZXIgPSBIYXNoZXI7XG5leHBvcnRzLmZyb20gPSBmcm9tO1xuIiwgIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xudmFyIGhhc2hlciA9IHJlcXVpcmUoJy4vaGFzaGVyLmpzJyk7XG52YXIgYnl0ZXMgPSByZXF1aXJlKCcuLi9ieXRlcy5qcycpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcERlZmF1bHRMZWdhY3kgKGUpIHsgcmV0dXJuIGUgJiYgdHlwZW9mIGUgPT09ICdvYmplY3QnICYmICdkZWZhdWx0JyBpbiBlID8gZSA6IHsgJ2RlZmF1bHQnOiBlIH07IH1cblxudmFyIGNyeXB0b19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9faW50ZXJvcERlZmF1bHRMZWdhY3koY3J5cHRvKTtcblxuY29uc3Qgc2hhMjU2ID0gaGFzaGVyLmZyb20oe1xuICBuYW1lOiAnc2hhMi0yNTYnLFxuICBjb2RlOiAxOCxcbiAgZW5jb2RlOiBpbnB1dCA9PiBieXRlcy5jb2VyY2UoY3J5cHRvX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5jcmVhdGVIYXNoKCdzaGEyNTYnKS51cGRhdGUoaW5wdXQpLmRpZ2VzdCgpKVxufSk7XG5jb25zdCBzaGE1MTIgPSBoYXNoZXIuZnJvbSh7XG4gIG5hbWU6ICdzaGEyLTUxMicsXG4gIGNvZGU6IDE5LFxuICBlbmNvZGU6IGlucHV0ID0+IGJ5dGVzLmNvZXJjZShjcnlwdG9fX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUhhc2goJ3NoYTUxMicpLnVwZGF0ZShpbnB1dCkuZGlnZXN0KCkpXG59KTtcblxuZXhwb3J0cy5zaGEyNTYgPSBzaGEyNTY7XG5leHBvcnRzLnNoYTUxMiA9IHNoYTUxMjtcbiIsICIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBieXRlcyA9IHJlcXVpcmUoJy4uL2J5dGVzLmpzJyk7XG52YXIgZGlnZXN0JDEgPSByZXF1aXJlKCcuL2RpZ2VzdC5qcycpO1xuXG5jb25zdCBjb2RlID0gMDtcbmNvbnN0IG5hbWUgPSAnaWRlbnRpdHknO1xuY29uc3QgZW5jb2RlID0gYnl0ZXMuY29lcmNlO1xuY29uc3QgZGlnZXN0ID0gaW5wdXQgPT4gZGlnZXN0JDEuY3JlYXRlKGNvZGUsIGVuY29kZShpbnB1dCkpO1xuY29uc3QgaWRlbnRpdHkgPSB7XG4gIGNvZGUsXG4gIG5hbWUsXG4gIGVuY29kZSxcbiAgZGlnZXN0XG59O1xuXG5leHBvcnRzLmlkZW50aXR5ID0gaWRlbnRpdHk7XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgYnl0ZXMgPSByZXF1aXJlKCcuLi9ieXRlcy5qcycpO1xuXG5jb25zdCBuYW1lID0gJ3Jhdyc7XG5jb25zdCBjb2RlID0gODU7XG5jb25zdCBlbmNvZGUgPSBub2RlID0+IGJ5dGVzLmNvZXJjZShub2RlKTtcbmNvbnN0IGRlY29kZSA9IGRhdGEgPT4gYnl0ZXMuY29lcmNlKGRhdGEpO1xuXG5leHBvcnRzLmNvZGUgPSBjb2RlO1xuZXhwb3J0cy5kZWNvZGUgPSBkZWNvZGU7XG5leHBvcnRzLmVuY29kZSA9IGVuY29kZTtcbmV4cG9ydHMubmFtZSA9IG5hbWU7XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5jb25zdCB0ZXh0RW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuY29uc3QgdGV4dERlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbmNvbnN0IG5hbWUgPSAnanNvbic7XG5jb25zdCBjb2RlID0gNTEyO1xuY29uc3QgZW5jb2RlID0gbm9kZSA9PiB0ZXh0RW5jb2Rlci5lbmNvZGUoSlNPTi5zdHJpbmdpZnkobm9kZSkpO1xuY29uc3QgZGVjb2RlID0gZGF0YSA9PiBKU09OLnBhcnNlKHRleHREZWNvZGVyLmRlY29kZShkYXRhKSk7XG5cbmV4cG9ydHMuY29kZSA9IGNvZGU7XG5leHBvcnRzLmRlY29kZSA9IGRlY29kZTtcbmV4cG9ydHMuZW5jb2RlID0gZW5jb2RlO1xuZXhwb3J0cy5uYW1lID0gbmFtZTtcbiIsICIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciB2YXJpbnQgPSByZXF1aXJlKCcuL3ZhcmludC5qcycpO1xudmFyIGRpZ2VzdCA9IHJlcXVpcmUoJy4vaGFzaGVzL2RpZ2VzdC5qcycpO1xudmFyIGJhc2U1OCA9IHJlcXVpcmUoJy4vYmFzZXMvYmFzZTU4LmpzJyk7XG52YXIgYmFzZTMyID0gcmVxdWlyZSgnLi9iYXNlcy9iYXNlMzIuanMnKTtcbnZhciBieXRlcyA9IHJlcXVpcmUoJy4vYnl0ZXMuanMnKTtcblxuY2xhc3MgQ0lEIHtcbiAgY29uc3RydWN0b3IodmVyc2lvbiwgY29kZSwgbXVsdGloYXNoLCBieXRlcykge1xuICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgdGhpcy52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICB0aGlzLm11bHRpaGFzaCA9IG11bHRpaGFzaDtcbiAgICB0aGlzLmJ5dGVzID0gYnl0ZXM7XG4gICAgdGhpcy5ieXRlT2Zmc2V0ID0gYnl0ZXMuYnl0ZU9mZnNldDtcbiAgICB0aGlzLmJ5dGVMZW5ndGggPSBieXRlcy5ieXRlTGVuZ3RoO1xuICAgIHRoaXMuYXNDSUQgPSB0aGlzO1xuICAgIHRoaXMuX2Jhc2VDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICBieXRlT2Zmc2V0OiBoaWRkZW4sXG4gICAgICBieXRlTGVuZ3RoOiBoaWRkZW4sXG4gICAgICBjb2RlOiByZWFkb25seSxcbiAgICAgIHZlcnNpb246IHJlYWRvbmx5LFxuICAgICAgbXVsdGloYXNoOiByZWFkb25seSxcbiAgICAgIGJ5dGVzOiByZWFkb25seSxcbiAgICAgIF9iYXNlQ2FjaGU6IGhpZGRlbixcbiAgICAgIGFzQ0lEOiBoaWRkZW5cbiAgICB9KTtcbiAgfVxuICB0b1YwKCkge1xuICAgIHN3aXRjaCAodGhpcy52ZXJzaW9uKSB7XG4gICAgY2FzZSAwOiB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgY29uc3Qge2NvZGUsIG11bHRpaGFzaH0gPSB0aGlzO1xuICAgICAgICBpZiAoY29kZSAhPT0gREFHX1BCX0NPREUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IGEgbm9uIGRhZy1wYiBDSUQgdG8gQ0lEdjAnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobXVsdGloYXNoLmNvZGUgIT09IFNIQV8yNTZfQ09ERSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNvbnZlcnQgbm9uIHNoYTItMjU2IG11bHRpaGFzaCBDSUQgdG8gQ0lEdjAnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQ0lELmNyZWF0ZVYwKG11bHRpaGFzaCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHRvVjEoKSB7XG4gICAgc3dpdGNoICh0aGlzLnZlcnNpb24pIHtcbiAgICBjYXNlIDA6IHtcbiAgICAgICAgY29uc3Qge2NvZGUsIGRpZ2VzdDogZGlnZXN0JDF9ID0gdGhpcy5tdWx0aWhhc2g7XG4gICAgICAgIGNvbnN0IG11bHRpaGFzaCA9IGRpZ2VzdC5jcmVhdGUoY29kZSwgZGlnZXN0JDEpO1xuICAgICAgICByZXR1cm4gQ0lELmNyZWF0ZVYxKHRoaXMuY29kZSwgbXVsdGloYXNoKTtcbiAgICAgIH1cbiAgICBjYXNlIDE6IHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgICB0aHJvdyBFcnJvcihgQ2FuIG5vdCBjb252ZXJ0IENJRCB2ZXJzaW9uICR7IHRoaXMudmVyc2lvbiB9IHRvIHZlcnNpb24gMC4gVGhpcyBpcyBhIGJ1ZyBwbGVhc2UgcmVwb3J0YCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGVxdWFscyhvdGhlcikge1xuICAgIHJldHVybiBvdGhlciAmJiB0aGlzLmNvZGUgPT09IG90aGVyLmNvZGUgJiYgdGhpcy52ZXJzaW9uID09PSBvdGhlci52ZXJzaW9uICYmIGRpZ2VzdC5lcXVhbHModGhpcy5tdWx0aWhhc2gsIG90aGVyLm11bHRpaGFzaCk7XG4gIH1cbiAgdG9TdHJpbmcoYmFzZSkge1xuICAgIGNvbnN0IHtieXRlcywgdmVyc2lvbiwgX2Jhc2VDYWNoZX0gPSB0aGlzO1xuICAgIHN3aXRjaCAodmVyc2lvbikge1xuICAgIGNhc2UgMDpcbiAgICAgIHJldHVybiB0b1N0cmluZ1YwKGJ5dGVzLCBfYmFzZUNhY2hlLCBiYXNlIHx8IGJhc2U1OC5iYXNlNThidGMuZW5jb2Rlcik7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB0b1N0cmluZ1YxKGJ5dGVzLCBfYmFzZUNhY2hlLCBiYXNlIHx8IGJhc2UzMi5iYXNlMzIuZW5jb2Rlcik7XG4gICAgfVxuICB9XG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29kZTogdGhpcy5jb2RlLFxuICAgICAgdmVyc2lvbjogdGhpcy52ZXJzaW9uLFxuICAgICAgaGFzaDogdGhpcy5tdWx0aWhhc2guYnl0ZXNcbiAgICB9O1xuICB9XG4gIGdldCBbU3ltYm9sLnRvU3RyaW5nVGFnXSgpIHtcbiAgICByZXR1cm4gJ0NJRCc7XG4gIH1cbiAgW1N5bWJvbC5mb3IoJ25vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tJyldKCkge1xuICAgIHJldHVybiAnQ0lEKCcgKyB0aGlzLnRvU3RyaW5nKCkgKyAnKSc7XG4gIH1cbiAgc3RhdGljIGlzQ0lEKHZhbHVlKSB7XG4gICAgZGVwcmVjYXRlKC9eMFxcLjAvLCBJU19DSURfREVQUkVDQVRJT04pO1xuICAgIHJldHVybiAhISh2YWx1ZSAmJiAodmFsdWVbY2lkU3ltYm9sXSB8fCB2YWx1ZS5hc0NJRCA9PT0gdmFsdWUpKTtcbiAgfVxuICBnZXQgdG9CYXNlRW5jb2RlZFN0cmluZygpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlcHJlY2F0ZWQsIHVzZSAudG9TdHJpbmcoKScpO1xuICB9XG4gIGdldCBjb2RlYygpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiY29kZWNcIiBwcm9wZXJ0eSBpcyBkZXByZWNhdGVkLCB1c2UgaW50ZWdlciBcImNvZGVcIiBwcm9wZXJ0eSBpbnN0ZWFkJyk7XG4gIH1cbiAgZ2V0IGJ1ZmZlcigpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlcHJlY2F0ZWQgLmJ1ZmZlciBwcm9wZXJ0eSwgdXNlIC5ieXRlcyB0byBnZXQgVWludDhBcnJheSBpbnN0ZWFkJyk7XG4gIH1cbiAgZ2V0IG11bHRpYmFzZU5hbWUoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdcIm11bHRpYmFzZU5hbWVcIiBwcm9wZXJ0eSBpcyBkZXByZWNhdGVkJyk7XG4gIH1cbiAgZ2V0IHByZWZpeCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1wicHJlZml4XCIgcHJvcGVydHkgaXMgZGVwcmVjYXRlZCcpO1xuICB9XG4gIHN0YXRpYyBhc0NJRCh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIENJRCkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgIT0gbnVsbCAmJiB2YWx1ZS5hc0NJRCA9PT0gdmFsdWUpIHtcbiAgICAgIGNvbnN0IHt2ZXJzaW9uLCBjb2RlLCBtdWx0aWhhc2gsIGJ5dGVzfSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIG5ldyBDSUQodmVyc2lvbiwgY29kZSwgbXVsdGloYXNoLCBieXRlcyB8fCBlbmNvZGVDSUQodmVyc2lvbiwgY29kZSwgbXVsdGloYXNoLmJ5dGVzKSk7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSAhPSBudWxsICYmIHZhbHVlW2NpZFN5bWJvbF0gPT09IHRydWUpIHtcbiAgICAgIGNvbnN0IHt2ZXJzaW9uLCBtdWx0aWhhc2gsIGNvZGV9ID0gdmFsdWU7XG4gICAgICBjb25zdCBkaWdlc3QkMSA9IGRpZ2VzdC5kZWNvZGUobXVsdGloYXNoKTtcbiAgICAgIHJldHVybiBDSUQuY3JlYXRlKHZlcnNpb24sIGNvZGUsIGRpZ2VzdCQxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBjcmVhdGUodmVyc2lvbiwgY29kZSwgZGlnZXN0KSB7XG4gICAgaWYgKHR5cGVvZiBjb2RlICE9PSAnbnVtYmVyJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdHJpbmcgY29kZWNzIGFyZSBubyBsb25nZXIgc3VwcG9ydGVkJyk7XG4gICAgfVxuICAgIHN3aXRjaCAodmVyc2lvbikge1xuICAgIGNhc2UgMDoge1xuICAgICAgICBpZiAoY29kZSAhPT0gREFHX1BCX0NPREUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFZlcnNpb24gMCBDSUQgbXVzdCB1c2UgZGFnLXBiIChjb2RlOiAkeyBEQUdfUEJfQ09ERSB9KSBibG9jayBlbmNvZGluZ2ApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBuZXcgQ0lEKHZlcnNpb24sIGNvZGUsIGRpZ2VzdCwgZGlnZXN0LmJ5dGVzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIGNhc2UgMToge1xuICAgICAgICBjb25zdCBieXRlcyA9IGVuY29kZUNJRCh2ZXJzaW9uLCBjb2RlLCBkaWdlc3QuYnl0ZXMpO1xuICAgICAgICByZXR1cm4gbmV3IENJRCh2ZXJzaW9uLCBjb2RlLCBkaWdlc3QsIGJ5dGVzKTtcbiAgICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB2ZXJzaW9uJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHN0YXRpYyBjcmVhdGVWMChkaWdlc3QpIHtcbiAgICByZXR1cm4gQ0lELmNyZWF0ZSgwLCBEQUdfUEJfQ09ERSwgZGlnZXN0KTtcbiAgfVxuICBzdGF0aWMgY3JlYXRlVjEoY29kZSwgZGlnZXN0KSB7XG4gICAgcmV0dXJuIENJRC5jcmVhdGUoMSwgY29kZSwgZGlnZXN0KTtcbiAgfVxuICBzdGF0aWMgZGVjb2RlKGJ5dGVzKSB7XG4gICAgY29uc3QgW2NpZCwgcmVtYWluZGVyXSA9IENJRC5kZWNvZGVGaXJzdChieXRlcyk7XG4gICAgaWYgKHJlbWFpbmRlci5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5jb3JyZWN0IGxlbmd0aCcpO1xuICAgIH1cbiAgICByZXR1cm4gY2lkO1xuICB9XG4gIHN0YXRpYyBkZWNvZGVGaXJzdChieXRlcyQxKSB7XG4gICAgY29uc3Qgc3BlY3MgPSBDSUQuaW5zcGVjdEJ5dGVzKGJ5dGVzJDEpO1xuICAgIGNvbnN0IHByZWZpeFNpemUgPSBzcGVjcy5zaXplIC0gc3BlY3MubXVsdGloYXNoU2l6ZTtcbiAgICBjb25zdCBtdWx0aWhhc2hCeXRlcyA9IGJ5dGVzLmNvZXJjZShieXRlcyQxLnN1YmFycmF5KHByZWZpeFNpemUsIHByZWZpeFNpemUgKyBzcGVjcy5tdWx0aWhhc2hTaXplKSk7XG4gICAgaWYgKG11bHRpaGFzaEJ5dGVzLmJ5dGVMZW5ndGggIT09IHNwZWNzLm11bHRpaGFzaFNpemUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5jb3JyZWN0IGxlbmd0aCcpO1xuICAgIH1cbiAgICBjb25zdCBkaWdlc3RCeXRlcyA9IG11bHRpaGFzaEJ5dGVzLnN1YmFycmF5KHNwZWNzLm11bHRpaGFzaFNpemUgLSBzcGVjcy5kaWdlc3RTaXplKTtcbiAgICBjb25zdCBkaWdlc3QkMSA9IG5ldyBkaWdlc3QuRGlnZXN0KHNwZWNzLm11bHRpaGFzaENvZGUsIHNwZWNzLmRpZ2VzdFNpemUsIGRpZ2VzdEJ5dGVzLCBtdWx0aWhhc2hCeXRlcyk7XG4gICAgY29uc3QgY2lkID0gc3BlY3MudmVyc2lvbiA9PT0gMCA/IENJRC5jcmVhdGVWMChkaWdlc3QkMSkgOiBDSUQuY3JlYXRlVjEoc3BlY3MuY29kZWMsIGRpZ2VzdCQxKTtcbiAgICByZXR1cm4gW1xuICAgICAgY2lkLFxuICAgICAgYnl0ZXMkMS5zdWJhcnJheShzcGVjcy5zaXplKVxuICAgIF07XG4gIH1cbiAgc3RhdGljIGluc3BlY3RCeXRlcyhpbml0aWFsQnl0ZXMpIHtcbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICBjb25zdCBuZXh0ID0gKCkgPT4ge1xuICAgICAgY29uc3QgW2ksIGxlbmd0aF0gPSB2YXJpbnQuZGVjb2RlKGluaXRpYWxCeXRlcy5zdWJhcnJheShvZmZzZXQpKTtcbiAgICAgIG9mZnNldCArPSBsZW5ndGg7XG4gICAgICByZXR1cm4gaTtcbiAgICB9O1xuICAgIGxldCB2ZXJzaW9uID0gbmV4dCgpO1xuICAgIGxldCBjb2RlYyA9IERBR19QQl9DT0RFO1xuICAgIGlmICh2ZXJzaW9uID09PSAxOCkge1xuICAgICAgdmVyc2lvbiA9IDA7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH0gZWxzZSBpZiAodmVyc2lvbiA9PT0gMSkge1xuICAgICAgY29kZWMgPSBuZXh0KCk7XG4gICAgfVxuICAgIGlmICh2ZXJzaW9uICE9PSAwICYmIHZlcnNpb24gIT09IDEpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBJbnZhbGlkIENJRCB2ZXJzaW9uICR7IHZlcnNpb24gfWApO1xuICAgIH1cbiAgICBjb25zdCBwcmVmaXhTaXplID0gb2Zmc2V0O1xuICAgIGNvbnN0IG11bHRpaGFzaENvZGUgPSBuZXh0KCk7XG4gICAgY29uc3QgZGlnZXN0U2l6ZSA9IG5leHQoKTtcbiAgICBjb25zdCBzaXplID0gb2Zmc2V0ICsgZGlnZXN0U2l6ZTtcbiAgICBjb25zdCBtdWx0aWhhc2hTaXplID0gc2l6ZSAtIHByZWZpeFNpemU7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZlcnNpb24sXG4gICAgICBjb2RlYyxcbiAgICAgIG11bHRpaGFzaENvZGUsXG4gICAgICBkaWdlc3RTaXplLFxuICAgICAgbXVsdGloYXNoU2l6ZSxcbiAgICAgIHNpemVcbiAgICB9O1xuICB9XG4gIHN0YXRpYyBwYXJzZShzb3VyY2UsIGJhc2UpIHtcbiAgICBjb25zdCBbcHJlZml4LCBieXRlc10gPSBwYXJzZUNJRHRvQnl0ZXMoc291cmNlLCBiYXNlKTtcbiAgICBjb25zdCBjaWQgPSBDSUQuZGVjb2RlKGJ5dGVzKTtcbiAgICBjaWQuX2Jhc2VDYWNoZS5zZXQocHJlZml4LCBzb3VyY2UpO1xuICAgIHJldHVybiBjaWQ7XG4gIH1cbn1cbmNvbnN0IHBhcnNlQ0lEdG9CeXRlcyA9IChzb3VyY2UsIGJhc2UpID0+IHtcbiAgc3dpdGNoIChzb3VyY2VbMF0pIHtcbiAgY2FzZSAnUSc6IHtcbiAgICAgIGNvbnN0IGRlY29kZXIgPSBiYXNlIHx8IGJhc2U1OC5iYXNlNThidGM7XG4gICAgICByZXR1cm4gW1xuICAgICAgICBiYXNlNTguYmFzZTU4YnRjLnByZWZpeCxcbiAgICAgICAgZGVjb2Rlci5kZWNvZGUoYCR7IGJhc2U1OC5iYXNlNThidGMucHJlZml4IH0keyBzb3VyY2UgfWApXG4gICAgICBdO1xuICAgIH1cbiAgY2FzZSBiYXNlNTguYmFzZTU4YnRjLnByZWZpeDoge1xuICAgICAgY29uc3QgZGVjb2RlciA9IGJhc2UgfHwgYmFzZTU4LmJhc2U1OGJ0YztcbiAgICAgIHJldHVybiBbXG4gICAgICAgIGJhc2U1OC5iYXNlNThidGMucHJlZml4LFxuICAgICAgICBkZWNvZGVyLmRlY29kZShzb3VyY2UpXG4gICAgICBdO1xuICAgIH1cbiAgY2FzZSBiYXNlMzIuYmFzZTMyLnByZWZpeDoge1xuICAgICAgY29uc3QgZGVjb2RlciA9IGJhc2UgfHwgYmFzZTMyLmJhc2UzMjtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIGJhc2UzMi5iYXNlMzIucHJlZml4LFxuICAgICAgICBkZWNvZGVyLmRlY29kZShzb3VyY2UpXG4gICAgICBdO1xuICAgIH1cbiAgZGVmYXVsdDoge1xuICAgICAgaWYgKGJhc2UgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBFcnJvcignVG8gcGFyc2Ugbm9uIGJhc2UzMiBvciBiYXNlNThidGMgZW5jb2RlZCBDSUQgbXVsdGliYXNlIGRlY29kZXIgbXVzdCBiZSBwcm92aWRlZCcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtcbiAgICAgICAgc291cmNlWzBdLFxuICAgICAgICBiYXNlLmRlY29kZShzb3VyY2UpXG4gICAgICBdO1xuICAgIH1cbiAgfVxufTtcbmNvbnN0IHRvU3RyaW5nVjAgPSAoYnl0ZXMsIGNhY2hlLCBiYXNlKSA9PiB7XG4gIGNvbnN0IHtwcmVmaXh9ID0gYmFzZTtcbiAgaWYgKHByZWZpeCAhPT0gYmFzZTU4LmJhc2U1OGJ0Yy5wcmVmaXgpIHtcbiAgICB0aHJvdyBFcnJvcihgQ2Fubm90IHN0cmluZyBlbmNvZGUgVjAgaW4gJHsgYmFzZS5uYW1lIH0gZW5jb2RpbmdgKTtcbiAgfVxuICBjb25zdCBjaWQgPSBjYWNoZS5nZXQocHJlZml4KTtcbiAgaWYgKGNpZCA9PSBudWxsKSB7XG4gICAgY29uc3QgY2lkID0gYmFzZS5lbmNvZGUoYnl0ZXMpLnNsaWNlKDEpO1xuICAgIGNhY2hlLnNldChwcmVmaXgsIGNpZCk7XG4gICAgcmV0dXJuIGNpZDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY2lkO1xuICB9XG59O1xuY29uc3QgdG9TdHJpbmdWMSA9IChieXRlcywgY2FjaGUsIGJhc2UpID0+IHtcbiAgY29uc3Qge3ByZWZpeH0gPSBiYXNlO1xuICBjb25zdCBjaWQgPSBjYWNoZS5nZXQocHJlZml4KTtcbiAgaWYgKGNpZCA9PSBudWxsKSB7XG4gICAgY29uc3QgY2lkID0gYmFzZS5lbmNvZGUoYnl0ZXMpO1xuICAgIGNhY2hlLnNldChwcmVmaXgsIGNpZCk7XG4gICAgcmV0dXJuIGNpZDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY2lkO1xuICB9XG59O1xuY29uc3QgREFHX1BCX0NPREUgPSAxMTI7XG5jb25zdCBTSEFfMjU2X0NPREUgPSAxODtcbmNvbnN0IGVuY29kZUNJRCA9ICh2ZXJzaW9uLCBjb2RlLCBtdWx0aWhhc2gpID0+IHtcbiAgY29uc3QgY29kZU9mZnNldCA9IHZhcmludC5lbmNvZGluZ0xlbmd0aCh2ZXJzaW9uKTtcbiAgY29uc3QgaGFzaE9mZnNldCA9IGNvZGVPZmZzZXQgKyB2YXJpbnQuZW5jb2RpbmdMZW5ndGgoY29kZSk7XG4gIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoaGFzaE9mZnNldCArIG11bHRpaGFzaC5ieXRlTGVuZ3RoKTtcbiAgdmFyaW50LmVuY29kZVRvKHZlcnNpb24sIGJ5dGVzLCAwKTtcbiAgdmFyaW50LmVuY29kZVRvKGNvZGUsIGJ5dGVzLCBjb2RlT2Zmc2V0KTtcbiAgYnl0ZXMuc2V0KG11bHRpaGFzaCwgaGFzaE9mZnNldCk7XG4gIHJldHVybiBieXRlcztcbn07XG5jb25zdCBjaWRTeW1ib2wgPSBTeW1ib2wuZm9yKCdAaXBsZC9qcy1jaWQvQ0lEJyk7XG5jb25zdCByZWFkb25seSA9IHtcbiAgd3JpdGFibGU6IGZhbHNlLFxuICBjb25maWd1cmFibGU6IGZhbHNlLFxuICBlbnVtZXJhYmxlOiB0cnVlXG59O1xuY29uc3QgaGlkZGVuID0ge1xuICB3cml0YWJsZTogZmFsc2UsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBjb25maWd1cmFibGU6IGZhbHNlXG59O1xuY29uc3QgdmVyc2lvbiA9ICcwLjAuMC1kZXYnO1xuY29uc3QgZGVwcmVjYXRlID0gKHJhbmdlLCBtZXNzYWdlKSA9PiB7XG4gIGlmIChyYW5nZS50ZXN0KHZlcnNpb24pKSB7XG4gICAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgfVxufTtcbmNvbnN0IElTX0NJRF9ERVBSRUNBVElPTiA9IGBDSUQuaXNDSUQodikgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2UuXG5Gb2xsb3dpbmcgY29kZSBwYXR0ZXJuOlxuXG5pZiAoQ0lELmlzQ0lEKHZhbHVlKSkge1xuICBkb1NvbWV0aGluZ1dpdGhDSUQodmFsdWUpXG59XG5cbklzIHJlcGxhY2VkIHdpdGg6XG5cbmNvbnN0IGNpZCA9IENJRC5hc0NJRCh2YWx1ZSlcbmlmIChjaWQpIHtcbiAgLy8gTWFrZSBzdXJlIHRvIHVzZSBjaWQgaW5zdGVhZCBvZiB2YWx1ZVxuICBkb1NvbWV0aGluZ1dpdGhDSUQoY2lkKVxufVxuYDtcblxuZXhwb3J0cy5DSUQgPSBDSUQ7XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgY2lkID0gcmVxdWlyZSgnLi9jaWQuanMnKTtcbnZhciB2YXJpbnQgPSByZXF1aXJlKCcuL3ZhcmludC5qcycpO1xudmFyIGJ5dGVzID0gcmVxdWlyZSgnLi9ieXRlcy5qcycpO1xudmFyIGhhc2hlciA9IHJlcXVpcmUoJy4vaGFzaGVzL2hhc2hlci5qcycpO1xudmFyIGRpZ2VzdCA9IHJlcXVpcmUoJy4vaGFzaGVzL2RpZ2VzdC5qcycpO1xuXG5cblxuZXhwb3J0cy5DSUQgPSBjaWQuQ0lEO1xuZXhwb3J0cy52YXJpbnQgPSB2YXJpbnQ7XG5leHBvcnRzLmJ5dGVzID0gYnl0ZXM7XG5leHBvcnRzLmhhc2hlciA9IGhhc2hlcjtcbmV4cG9ydHMuZGlnZXN0ID0gZGlnZXN0O1xuIiwgIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGlkZW50aXR5ID0gcmVxdWlyZSgnLi9iYXNlcy9pZGVudGl0eS5qcycpO1xudmFyIGJhc2UyID0gcmVxdWlyZSgnLi9iYXNlcy9iYXNlMi5qcycpO1xudmFyIGJhc2U4ID0gcmVxdWlyZSgnLi9iYXNlcy9iYXNlOC5qcycpO1xudmFyIGJhc2UxMCA9IHJlcXVpcmUoJy4vYmFzZXMvYmFzZTEwLmpzJyk7XG52YXIgYmFzZTE2ID0gcmVxdWlyZSgnLi9iYXNlcy9iYXNlMTYuanMnKTtcbnZhciBiYXNlMzIgPSByZXF1aXJlKCcuL2Jhc2VzL2Jhc2UzMi5qcycpO1xudmFyIGJhc2UzNiA9IHJlcXVpcmUoJy4vYmFzZXMvYmFzZTM2LmpzJyk7XG52YXIgYmFzZTU4ID0gcmVxdWlyZSgnLi9iYXNlcy9iYXNlNTguanMnKTtcbnZhciBiYXNlNjQgPSByZXF1aXJlKCcuL2Jhc2VzL2Jhc2U2NC5qcycpO1xudmFyIGJhc2UyNTZlbW9qaSA9IHJlcXVpcmUoJy4vYmFzZXMvYmFzZTI1NmVtb2ppLmpzJyk7XG52YXIgc2hhMiA9IHJlcXVpcmUoJy4vaGFzaGVzL3NoYTIuanMnKTtcbnZhciBpZGVudGl0eSQxID0gcmVxdWlyZSgnLi9oYXNoZXMvaWRlbnRpdHkuanMnKTtcbnZhciByYXcgPSByZXF1aXJlKCcuL2NvZGVjcy9yYXcuanMnKTtcbnZhciBqc29uID0gcmVxdWlyZSgnLi9jb2RlY3MvanNvbi5qcycpO1xucmVxdWlyZSgnLi9pbmRleC5qcycpO1xudmFyIGNpZCA9IHJlcXVpcmUoJy4vY2lkLmpzJyk7XG52YXIgaGFzaGVyID0gcmVxdWlyZSgnLi9oYXNoZXMvaGFzaGVyLmpzJyk7XG52YXIgZGlnZXN0ID0gcmVxdWlyZSgnLi9oYXNoZXMvZGlnZXN0LmpzJyk7XG52YXIgdmFyaW50ID0gcmVxdWlyZSgnLi92YXJpbnQuanMnKTtcbnZhciBieXRlcyA9IHJlcXVpcmUoJy4vYnl0ZXMuanMnKTtcblxuY29uc3QgYmFzZXMgPSB7XG4gIC4uLmlkZW50aXR5LFxuICAuLi5iYXNlMixcbiAgLi4uYmFzZTgsXG4gIC4uLmJhc2UxMCxcbiAgLi4uYmFzZTE2LFxuICAuLi5iYXNlMzIsXG4gIC4uLmJhc2UzNixcbiAgLi4uYmFzZTU4LFxuICAuLi5iYXNlNjQsXG4gIC4uLmJhc2UyNTZlbW9qaVxufTtcbmNvbnN0IGhhc2hlcyA9IHtcbiAgLi4uc2hhMixcbiAgLi4uaWRlbnRpdHkkMVxufTtcbmNvbnN0IGNvZGVjcyA9IHtcbiAgcmF3LFxuICBqc29uXG59O1xuXG5leHBvcnRzLkNJRCA9IGNpZC5DSUQ7XG5leHBvcnRzLmhhc2hlciA9IGhhc2hlcjtcbmV4cG9ydHMuZGlnZXN0ID0gZGlnZXN0O1xuZXhwb3J0cy52YXJpbnQgPSB2YXJpbnQ7XG5leHBvcnRzLmJ5dGVzID0gYnl0ZXM7XG5leHBvcnRzLmJhc2VzID0gYmFzZXM7XG5leHBvcnRzLmNvZGVjcyA9IGNvZGVjcztcbmV4cG9ydHMuaGFzaGVzID0gaGFzaGVzO1xuIiwgIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuZnVuY3Rpb24gYXNVaW50OEFycmF5KGJ1Zikge1xuICBpZiAoZ2xvYmFsVGhpcy5CdWZmZXIgIT0gbnVsbCkge1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShidWYuYnVmZmVyLCBidWYuYnl0ZU9mZnNldCwgYnVmLmJ5dGVMZW5ndGgpO1xuICB9XG4gIHJldHVybiBidWY7XG59XG5cbmV4cG9ydHMuYXNVaW50OEFycmF5ID0gYXNVaW50OEFycmF5O1xuIiwgIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGFzVWludDhhcnJheSA9IHJlcXVpcmUoJy4vdXRpbC9hcy11aW50OGFycmF5LmpzJyk7XG5cbmZ1bmN0aW9uIGFsbG9jKHNpemUgPSAwKSB7XG4gIGlmIChnbG9iYWxUaGlzLkJ1ZmZlciAhPSBudWxsICYmIGdsb2JhbFRoaXMuQnVmZmVyLmFsbG9jICE9IG51bGwpIHtcbiAgICByZXR1cm4gYXNVaW50OGFycmF5LmFzVWludDhBcnJheShnbG9iYWxUaGlzLkJ1ZmZlci5hbGxvYyhzaXplKSk7XG4gIH1cbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHNpemUpO1xufVxuZnVuY3Rpb24gYWxsb2NVbnNhZmUoc2l6ZSA9IDApIHtcbiAgaWYgKGdsb2JhbFRoaXMuQnVmZmVyICE9IG51bGwgJiYgZ2xvYmFsVGhpcy5CdWZmZXIuYWxsb2NVbnNhZmUgIT0gbnVsbCkge1xuICAgIHJldHVybiBhc1VpbnQ4YXJyYXkuYXNVaW50OEFycmF5KGdsb2JhbFRoaXMuQnVmZmVyLmFsbG9jVW5zYWZlKHNpemUpKTtcbiAgfVxuICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoc2l6ZSk7XG59XG5cbmV4cG9ydHMuYWxsb2MgPSBhbGxvYztcbmV4cG9ydHMuYWxsb2NVbnNhZmUgPSBhbGxvY1Vuc2FmZTtcbiIsICIndXNlIHN0cmljdCc7XG5cbnZhciBiYXNpY3MgPSByZXF1aXJlKCdtdWx0aWZvcm1hdHMvYmFzaWNzJyk7XG52YXIgYWxsb2MgPSByZXF1aXJlKCcuLi9hbGxvYy5qcycpO1xuXG5mdW5jdGlvbiBjcmVhdGVDb2RlYyhuYW1lLCBwcmVmaXgsIGVuY29kZSwgZGVjb2RlKSB7XG4gIHJldHVybiB7XG4gICAgbmFtZSxcbiAgICBwcmVmaXgsXG4gICAgZW5jb2Rlcjoge1xuICAgICAgbmFtZSxcbiAgICAgIHByZWZpeCxcbiAgICAgIGVuY29kZVxuICAgIH0sXG4gICAgZGVjb2RlcjogeyBkZWNvZGUgfVxuICB9O1xufVxuY29uc3Qgc3RyaW5nID0gY3JlYXRlQ29kZWMoJ3V0ZjgnLCAndScsIGJ1ZiA9PiB7XG4gIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoJ3V0ZjgnKTtcbiAgcmV0dXJuICd1JyArIGRlY29kZXIuZGVjb2RlKGJ1Zik7XG59LCBzdHIgPT4ge1xuICBjb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gIHJldHVybiBlbmNvZGVyLmVuY29kZShzdHIuc3Vic3RyaW5nKDEpKTtcbn0pO1xuY29uc3QgYXNjaWkgPSBjcmVhdGVDb2RlYygnYXNjaWknLCAnYScsIGJ1ZiA9PiB7XG4gIGxldCBzdHJpbmcgPSAnYSc7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmLmxlbmd0aDsgaSsrKSB7XG4gICAgc3RyaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKTtcbiAgfVxuICByZXR1cm4gc3RyaW5nO1xufSwgc3RyID0+IHtcbiAgc3RyID0gc3RyLnN1YnN0cmluZygxKTtcbiAgY29uc3QgYnVmID0gYWxsb2MuYWxsb2NVbnNhZmUoc3RyLmxlbmd0aCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgYnVmW2ldID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gIH1cbiAgcmV0dXJuIGJ1Zjtcbn0pO1xuY29uc3QgQkFTRVMgPSB7XG4gIHV0Zjg6IHN0cmluZyxcbiAgJ3V0Zi04Jzogc3RyaW5nLFxuICBoZXg6IGJhc2ljcy5iYXNlcy5iYXNlMTYsXG4gIGxhdGluMTogYXNjaWksXG4gIGFzY2lpOiBhc2NpaSxcbiAgYmluYXJ5OiBhc2NpaSxcbiAgLi4uYmFzaWNzLmJhc2VzXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJBU0VTO1xuIiwgIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGJhc2VzID0gcmVxdWlyZSgnLi91dGlsL2Jhc2VzLmpzJyk7XG52YXIgYXNVaW50OGFycmF5ID0gcmVxdWlyZSgnLi91dGlsL2FzLXVpbnQ4YXJyYXkuanMnKTtcblxuZnVuY3Rpb24gZnJvbVN0cmluZyhzdHJpbmcsIGVuY29kaW5nID0gJ3V0ZjgnKSB7XG4gIGNvbnN0IGJhc2UgPSBiYXNlc1tlbmNvZGluZ107XG4gIGlmICghYmFzZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZW5jb2RpbmcgXCIkeyBlbmNvZGluZyB9XCJgKTtcbiAgfVxuICBpZiAoKGVuY29kaW5nID09PSAndXRmOCcgfHwgZW5jb2RpbmcgPT09ICd1dGYtOCcpICYmIGdsb2JhbFRoaXMuQnVmZmVyICE9IG51bGwgJiYgZ2xvYmFsVGhpcy5CdWZmZXIuZnJvbSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIGFzVWludDhhcnJheS5hc1VpbnQ4QXJyYXkoZ2xvYmFsVGhpcy5CdWZmZXIuZnJvbShzdHJpbmcsICd1dGYtOCcpKTtcbiAgfVxuICByZXR1cm4gYmFzZS5kZWNvZGVyLmRlY29kZShgJHsgYmFzZS5wcmVmaXggfSR7IHN0cmluZyB9YCk7XG59XG5cbmV4cG9ydHMuZnJvbVN0cmluZyA9IGZyb21TdHJpbmc7XG4iLCAiJ3VzZSBzdHJpY3QnXG5cbi8vIEB0cy1pZ25vcmVcbmNvbnN0IFNwYXJzZUFycmF5ID0gcmVxdWlyZSgnc3BhcnNlLWFycmF5JylcbmNvbnN0IHsgZnJvbVN0cmluZzogdWludDhBcnJheUZyb21TdHJpbmcgfSA9IHJlcXVpcmUoJ3VpbnQ4YXJyYXlzL2Zyb20tc3RyaW5nJylcblxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuL2NvbnN1bWFibGUtaGFzaCcpLkluZmluaXRlSGFzaH0gSW5maW5pdGVIYXNoXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi8nKS5Vc2VyQnVja2V0T3B0aW9uc30gVXNlckJ1Y2tldE9wdGlvbnNcbiAqL1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBWXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBCdWNrZXRDaGlsZDxWPlxuICogQHByb3BlcnR5IHtzdHJpbmd9IGtleVxuICogQHByb3BlcnR5IHtWfSB2YWx1ZVxuICogQHByb3BlcnR5IHtJbmZpbml0ZUhhc2h9IGhhc2hcbiAqL1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBCXG4gKlxuICogQHR5cGVkZWYge29iamVjdH0gU0E8Qj5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBsZW5ndGhcbiAqIEBwcm9wZXJ0eSB7KCkgPT4gQltdfSBjb21wYWN0QXJyYXlcbiAqIEBwcm9wZXJ0eSB7KGk6IG51bWJlcikgPT4gQn0gZ2V0XG4gKiBAcHJvcGVydHkgeyhpOiBudW1iZXIsIHZhbHVlOiBCKSA9PiB2b2lkfSBzZXRcbiAqIEBwcm9wZXJ0eSB7PEE+IChmbjogKGFjYzogQSwgY3VycjogQiwgaW5kZXg6IG51bWJlcikgPT4gQSwgaW5pdGlhbDogQSkgPT4gQn0gcmVkdWNlXG4gKiBAcHJvcGVydHkgeyhmbjogKGl0ZW06IEIpID0+IGJvb2xlYW4pID0+IEIgfCB1bmRlZmluZWR9IGZpbmRcbiAqIEBwcm9wZXJ0eSB7KCkgPT4gbnVtYmVyW119IGJpdEZpZWxkXG4gKiBAcHJvcGVydHkgeyhpOiBudW1iZXIpID0+IHZvaWR9IHVuc2V0XG4gKi9cblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICpcbiAqIEB0eXBlZGVmIHtvYmplY3R9IEJ1Y2tldFBvc2l0aW9uPFQ+XG4gKiBAcHJvcGVydHkge0J1Y2tldDxUPn0gYnVja2V0XG4gKiBAcHJvcGVydHkge251bWJlcn0gcG9zXG4gKiBAcHJvcGVydHkge0luZmluaXRlSGFzaH0gaGFzaFxuICogQHByb3BlcnR5IHtCdWNrZXRDaGlsZDxUPn0gW2V4aXN0aW5nQ2hpbGRdXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBCdWNrZXRPcHRpb25zXG4gKiBAcHJvcGVydHkge251bWJlcn0gYml0c1xuICogQHByb3BlcnR5IHsodmFsdWU6IFVpbnQ4QXJyYXkgfCBJbmZpbml0ZUhhc2gpID0+IEluZmluaXRlSGFzaH0gaGFzaFxuICovXG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqL1xuY2xhc3MgQnVja2V0IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7QnVja2V0T3B0aW9uc30gb3B0aW9uc1xuICAgKiBAcGFyYW0ge0J1Y2tldDxUPn0gW3BhcmVudF1cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtwb3NBdFBhcmVudD0wXVxuICAgKi9cbiAgY29uc3RydWN0b3IgKG9wdGlvbnMsIHBhcmVudCwgcG9zQXRQYXJlbnQgPSAwKSB7XG4gICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnNcbiAgICB0aGlzLl9wb3BDb3VudCA9IDBcbiAgICB0aGlzLl9wYXJlbnQgPSBwYXJlbnRcbiAgICB0aGlzLl9wb3NBdFBhcmVudCA9IHBvc0F0UGFyZW50XG5cbiAgICAvKiogQHR5cGUge1NBPEJ1Y2tldDxUPiB8IEJ1Y2tldENoaWxkPFQ+Pn0gKi9cbiAgICB0aGlzLl9jaGlsZHJlbiA9IG5ldyBTcGFyc2VBcnJheSgpXG5cbiAgICAvKiogQHR5cGUge3N0cmluZyB8IG51bGx9ICovXG4gICAgdGhpcy5rZXkgPSBudWxsXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgKiBAcGFyYW0ge1R9IHZhbHVlXG4gICAqL1xuICBhc3luYyBwdXQgKGtleSwgdmFsdWUpIHtcbiAgICBjb25zdCBwbGFjZSA9IGF3YWl0IHRoaXMuX2ZpbmROZXdCdWNrZXRBbmRQb3Moa2V5KVxuXG4gICAgYXdhaXQgcGxhY2UuYnVja2V0Ll9wdXRBdChwbGFjZSwga2V5LCB2YWx1ZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAqL1xuICBhc3luYyBnZXQgKGtleSkge1xuICAgIGNvbnN0IGNoaWxkID0gYXdhaXQgdGhpcy5fZmluZENoaWxkKGtleSlcblxuICAgIGlmIChjaGlsZCkge1xuICAgICAgcmV0dXJuIGNoaWxkLnZhbHVlXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICovXG4gIGFzeW5jIGRlbCAoa2V5KSB7XG4gICAgY29uc3QgcGxhY2UgPSBhd2FpdCB0aGlzLl9maW5kUGxhY2Uoa2V5KVxuICAgIGNvbnN0IGNoaWxkID0gcGxhY2UuYnVja2V0Ll9hdChwbGFjZS5wb3MpXG5cbiAgICBpZiAoY2hpbGQgJiYgY2hpbGQua2V5ID09PSBrZXkpIHtcbiAgICAgIHBsYWNlLmJ1Y2tldC5fZGVsQXQocGxhY2UucG9zKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKi9cbiAgbGVhZkNvdW50ICgpIHtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuLmNvbXBhY3RBcnJheSgpXG5cbiAgICByZXR1cm4gY2hpbGRyZW4ucmVkdWNlKChhY2MsIGNoaWxkKSA9PiB7XG4gICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBCdWNrZXQpIHtcbiAgICAgICAgcmV0dXJuIGFjYyArIGNoaWxkLmxlYWZDb3VudCgpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhY2MgKyAxXG4gICAgfSwgMClcbiAgfVxuXG4gIGNoaWxkcmVuQ291bnQgKCkge1xuICAgIHJldHVybiB0aGlzLl9jaGlsZHJlbi5sZW5ndGhcbiAgfVxuXG4gIG9ubHlDaGlsZCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NoaWxkcmVuLmdldCgwKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtJdGVyYWJsZTxCdWNrZXRDaGlsZDxUPj59XG4gICAqL1xuICAqIGVhY2hMZWFmU2VyaWVzICgpIHtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuLmNvbXBhY3RBcnJheSgpXG5cbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGNoaWxkcmVuKSB7XG4gICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBCdWNrZXQpIHtcbiAgICAgICAgeWllbGQgKiBjaGlsZC5lYWNoTGVhZlNlcmllcygpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB5aWVsZCBjaGlsZFxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2UgdHNjIHJlcXVpcmVzIGEgQHJldHVybiBhbm5vdGF0aW9uIGFzIGl0XG4gICAgLy8gY2FuJ3QgZGVyaXZlIGEgcmV0dXJuIHR5cGUgZHVlIHRvIHRoZSByZWN1cnNpb24sIGFuZCBlc2xpbnQgcmVxdWlyZXNcbiAgICAvLyBhIHJldHVybiBzdGF0ZW1lbnQgd2hlbiB0aGVyZSBpcyBhIEByZXR1cm4gYW5ub3RhdGlvblxuICAgIHJldHVybiBbXVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7KHZhbHVlOiBCdWNrZXRDaGlsZDxUPiwgaW5kZXg6IG51bWJlcikgPT4gVH0gbWFwXG4gICAqIEBwYXJhbSB7KHJlZHVjZWQ6IGFueSkgPT4gYW55fSByZWR1Y2VcbiAgICovXG4gIHNlcmlhbGl6ZSAobWFwLCByZWR1Y2UpIHtcbiAgICAvKiogQHR5cGUge1RbXX0gKi9cbiAgICBjb25zdCBhY2MgPSBbXVxuICAgIC8vIHNlcmlhbGl6ZSB0byBhIGN1c3RvbSBub24tc3BhcnNlIHJlcHJlc2VudGF0aW9uXG4gICAgcmV0dXJuIHJlZHVjZSh0aGlzLl9jaGlsZHJlbi5yZWR1Y2UoKGFjYywgY2hpbGQsIGluZGV4KSA9PiB7XG4gICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgQnVja2V0KSB7XG4gICAgICAgICAgYWNjLnB1c2goY2hpbGQuc2VyaWFsaXplKG1hcCwgcmVkdWNlKSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhY2MucHVzaChtYXAoY2hpbGQsIGluZGV4KSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGFjY1xuICAgIH0sIGFjYykpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHsodmFsdWU6IEJ1Y2tldENoaWxkPFQ+KSA9PiBQcm9taXNlPFRbXT59IGFzeW5jTWFwXG4gICAqIEBwYXJhbSB7KHJlZHVjZWQ6IGFueSkgPT4gUHJvbWlzZTxhbnk+fSBhc3luY1JlZHVjZVxuICAgKi9cbiAgYXN5bmNUcmFuc2Zvcm0gKGFzeW5jTWFwLCBhc3luY1JlZHVjZSkge1xuICAgIHJldHVybiBhc3luY1RyYW5zZm9ybUJ1Y2tldCh0aGlzLCBhc3luY01hcCwgYXN5bmNSZWR1Y2UpXG4gIH1cblxuICB0b0pTT04gKCkge1xuICAgIHJldHVybiB0aGlzLnNlcmlhbGl6ZShtYXBOb2RlLCByZWR1Y2VOb2RlcylcbiAgfVxuXG4gIHByZXR0eVByaW50ICgpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy50b0pTT04oKSwgbnVsbCwgJyAgJylcbiAgfVxuXG4gIHRhYmxlU2l6ZSAoKSB7XG4gICAgcmV0dXJuIE1hdGgucG93KDIsIHRoaXMuX29wdGlvbnMuYml0cylcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEJ1Y2tldENoaWxkPFQ+IHwgdW5kZWZpbmVkPn1cbiAgICovXG4gIGFzeW5jIF9maW5kQ2hpbGQgKGtleSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuX2ZpbmRQbGFjZShrZXkpXG4gICAgY29uc3QgY2hpbGQgPSByZXN1bHQuYnVja2V0Ll9hdChyZXN1bHQucG9zKVxuXG4gICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgQnVja2V0KSB7XG4gICAgICAvLyBzaG91bGQgbm90IGJlIHBvc3NpYmxlLCB0aGlzLl9maW5kUGxhY2Ugc2hvdWxkIGFsd2F5c1xuICAgICAgLy8gcmV0dXJuIGEgbG9jYXRpb24gZm9yIGEgY2hpbGQsIG5vdCBhIGJ1Y2tldFxuICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgIH1cblxuICAgIGlmIChjaGlsZCAmJiBjaGlsZC5rZXkgPT09IGtleSkge1xuICAgICAgcmV0dXJuIGNoaWxkXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgSW5maW5pdGVIYXNofSBrZXlcbiAgICogQHJldHVybnMge1Byb21pc2U8QnVja2V0UG9zaXRpb248VD4+fVxuICAgKi9cbiAgYXN5bmMgX2ZpbmRQbGFjZSAoa2V5KSB7XG4gICAgY29uc3QgaGFzaFZhbHVlID0gdGhpcy5fb3B0aW9ucy5oYXNoKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnID8gdWludDhBcnJheUZyb21TdHJpbmcoa2V5KSA6IGtleSlcbiAgICBjb25zdCBpbmRleCA9IGF3YWl0IGhhc2hWYWx1ZS50YWtlKHRoaXMuX29wdGlvbnMuYml0cylcblxuICAgIGNvbnN0IGNoaWxkID0gdGhpcy5fY2hpbGRyZW4uZ2V0KGluZGV4KVxuXG4gICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgQnVja2V0KSB7XG4gICAgICByZXR1cm4gY2hpbGQuX2ZpbmRQbGFjZShoYXNoVmFsdWUpXG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGJ1Y2tldDogdGhpcyxcbiAgICAgIHBvczogaW5kZXgsXG4gICAgICBoYXNoOiBoYXNoVmFsdWUsXG4gICAgICBleGlzdGluZ0NoaWxkOiBjaGlsZFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IEluZmluaXRlSGFzaH0ga2V5XG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEJ1Y2tldFBvc2l0aW9uPFQ+Pn1cbiAgICovXG4gIGFzeW5jIF9maW5kTmV3QnVja2V0QW5kUG9zIChrZXkpIHtcbiAgICBjb25zdCBwbGFjZSA9IGF3YWl0IHRoaXMuX2ZpbmRQbGFjZShrZXkpXG5cbiAgICBpZiAocGxhY2UuZXhpc3RpbmdDaGlsZCAmJiBwbGFjZS5leGlzdGluZ0NoaWxkLmtleSAhPT0ga2V5KSB7XG4gICAgICAvLyBjb25mbGljdFxuICAgICAgY29uc3QgYnVja2V0ID0gbmV3IEJ1Y2tldCh0aGlzLl9vcHRpb25zLCBwbGFjZS5idWNrZXQsIHBsYWNlLnBvcylcbiAgICAgIHBsYWNlLmJ1Y2tldC5fcHV0T2JqZWN0QXQocGxhY2UucG9zLCBidWNrZXQpXG5cbiAgICAgIC8vIHB1dCB0aGUgcHJldmlvdXMgdmFsdWVcbiAgICAgIGNvbnN0IG5ld1BsYWNlID0gYXdhaXQgYnVja2V0Ll9maW5kUGxhY2UocGxhY2UuZXhpc3RpbmdDaGlsZC5oYXNoKVxuICAgICAgbmV3UGxhY2UuYnVja2V0Ll9wdXRBdChuZXdQbGFjZSwgcGxhY2UuZXhpc3RpbmdDaGlsZC5rZXksIHBsYWNlLmV4aXN0aW5nQ2hpbGQudmFsdWUpXG5cbiAgICAgIHJldHVybiBidWNrZXQuX2ZpbmROZXdCdWNrZXRBbmRQb3MocGxhY2UuaGFzaClcbiAgICB9XG5cbiAgICAvLyBubyBjb25mbGljdCwgd2UgZm91bmQgdGhlIHBsYWNlXG4gICAgcmV0dXJuIHBsYWNlXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtCdWNrZXRQb3NpdGlvbjxUPn0gcGxhY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgKiBAcGFyYW0ge1R9IHZhbHVlXG4gICAqL1xuICBfcHV0QXQgKHBsYWNlLCBrZXksIHZhbHVlKSB7XG4gICAgdGhpcy5fcHV0T2JqZWN0QXQocGxhY2UucG9zLCB7XG4gICAgICBrZXk6IGtleSxcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGhhc2g6IHBsYWNlLmhhc2hcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwb3NcbiAgICogQHBhcmFtIHtCdWNrZXQ8VD4gfCBCdWNrZXRDaGlsZDxUPn0gb2JqZWN0XG4gICAqL1xuICBfcHV0T2JqZWN0QXQgKHBvcywgb2JqZWN0KSB7XG4gICAgaWYgKCF0aGlzLl9jaGlsZHJlbi5nZXQocG9zKSkge1xuICAgICAgdGhpcy5fcG9wQ291bnQrK1xuICAgIH1cbiAgICB0aGlzLl9jaGlsZHJlbi5zZXQocG9zLCBvYmplY3QpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHBvc1xuICAgKi9cbiAgX2RlbEF0IChwb3MpIHtcbiAgICBpZiAocG9zID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHBvc2l0aW9uJylcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fY2hpbGRyZW4uZ2V0KHBvcykpIHtcbiAgICAgIHRoaXMuX3BvcENvdW50LS1cbiAgICB9XG4gICAgdGhpcy5fY2hpbGRyZW4udW5zZXQocG9zKVxuICAgIHRoaXMuX2xldmVsKClcbiAgfVxuXG4gIF9sZXZlbCAoKSB7XG4gICAgaWYgKHRoaXMuX3BhcmVudCAmJiB0aGlzLl9wb3BDb3VudCA8PSAxKSB7XG4gICAgICBpZiAodGhpcy5fcG9wQ291bnQgPT09IDEpIHtcbiAgICAgICAgLy8gcmVtb3ZlIG15c2VsZiBmcm9tIHBhcmVudCwgcmVwbGFjaW5nIG1lIHdpdGggbXkgb25seSBjaGlsZFxuICAgICAgICBjb25zdCBvbmx5Q2hpbGQgPSB0aGlzLl9jaGlsZHJlbi5maW5kKGV4aXN0cylcblxuICAgICAgICBpZiAob25seUNoaWxkICYmICEob25seUNoaWxkIGluc3RhbmNlb2YgQnVja2V0KSkge1xuICAgICAgICAgIGNvbnN0IGhhc2ggPSBvbmx5Q2hpbGQuaGFzaFxuICAgICAgICAgIGhhc2gudW50YWtlKHRoaXMuX29wdGlvbnMuYml0cylcbiAgICAgICAgICBjb25zdCBwbGFjZSA9IHtcbiAgICAgICAgICAgIHBvczogdGhpcy5fcG9zQXRQYXJlbnQsXG4gICAgICAgICAgICBoYXNoOiBoYXNoLFxuICAgICAgICAgICAgYnVja2V0OiB0aGlzLl9wYXJlbnRcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fcGFyZW50Ll9wdXRBdChwbGFjZSwgb25seUNoaWxkLmtleSwgb25seUNoaWxkLnZhbHVlKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9wYXJlbnQuX2RlbEF0KHRoaXMuX3Bvc0F0UGFyZW50KVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICogQHJldHVybnMge0J1Y2tldENoaWxkPFQ+IHwgQnVja2V0PFQ+IHwgdW5kZWZpbmVkfVxuICAgKi9cbiAgX2F0IChpbmRleCkge1xuICAgIHJldHVybiB0aGlzLl9jaGlsZHJlbi5nZXQoaW5kZXgpXG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gb1xuICovXG5mdW5jdGlvbiBleGlzdHMgKG8pIHtcbiAgcmV0dXJuIEJvb2xlYW4obylcbn1cblxuLyoqXG4gKlxuICogQHBhcmFtIHsqfSBub2RlXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqL1xuZnVuY3Rpb24gbWFwTm9kZSAobm9kZSwgaW5kZXgpIHtcbiAgcmV0dXJuIG5vZGUua2V5XG59XG5cbi8qKlxuICogQHBhcmFtIHsqfSBub2Rlc1xuICovXG5mdW5jdGlvbiByZWR1Y2VOb2RlcyAobm9kZXMpIHtcbiAgcmV0dXJuIG5vZGVzXG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqXG4gKiBAcGFyYW0ge0J1Y2tldDxUPn0gYnVja2V0XG4gKiBAcGFyYW0geyh2YWx1ZTogQnVja2V0Q2hpbGQ8VD4pID0+IFByb21pc2U8VFtdPn0gYXN5bmNNYXBcbiAqIEBwYXJhbSB7KHJlZHVjZWQ6IGFueSkgPT4gUHJvbWlzZTxhbnk+fSBhc3luY1JlZHVjZVxuICovXG5hc3luYyBmdW5jdGlvbiBhc3luY1RyYW5zZm9ybUJ1Y2tldCAoYnVja2V0LCBhc3luY01hcCwgYXN5bmNSZWR1Y2UpIHtcbiAgY29uc3Qgb3V0cHV0ID0gW11cblxuICBmb3IgKGNvbnN0IGNoaWxkIG9mIGJ1Y2tldC5fY2hpbGRyZW4uY29tcGFjdEFycmF5KCkpIHtcbiAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBCdWNrZXQpIHtcbiAgICAgIGF3YWl0IGFzeW5jVHJhbnNmb3JtQnVja2V0KGNoaWxkLCBhc3luY01hcCwgYXN5bmNSZWR1Y2UpXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG1hcHBlZENoaWxkcmVuID0gYXdhaXQgYXN5bmNNYXAoY2hpbGQpXG5cbiAgICAgIG91dHB1dC5wdXNoKHtcbiAgICAgICAgYml0RmllbGQ6IGJ1Y2tldC5fY2hpbGRyZW4uYml0RmllbGQoKSxcbiAgICAgICAgY2hpbGRyZW46IG1hcHBlZENoaWxkcmVuXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBhc3luY1JlZHVjZShvdXRwdXQpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gQnVja2V0XG4iLCAiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IFNUQVJUX01BU0tTID0gW1xuICAwYjExMTExMTExLFxuICAwYjExMTExMTEwLFxuICAwYjExMTExMTAwLFxuICAwYjExMTExMDAwLFxuICAwYjExMTEwMDAwLFxuICAwYjExMTAwMDAwLFxuICAwYjExMDAwMDAwLFxuICAwYjEwMDAwMDAwXG5dXG5cbmNvbnN0IFNUT1BfTUFTS1MgPSBbXG4gIDBiMDAwMDAwMDEsXG4gIDBiMDAwMDAwMTEsXG4gIDBiMDAwMDAxMTEsXG4gIDBiMDAwMDExMTEsXG4gIDBiMDAwMTExMTEsXG4gIDBiMDAxMTExMTEsXG4gIDBiMDExMTExMTEsXG4gIDBiMTExMTExMTFcbl1cblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBDb25zdW1hYmxlQnVmZmVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7VWludDhBcnJheX0gdmFsdWVcbiAgICovXG4gIGNvbnN0cnVjdG9yICh2YWx1ZSkge1xuICAgIHRoaXMuX3ZhbHVlID0gdmFsdWVcbiAgICB0aGlzLl9jdXJyZW50Qnl0ZVBvcyA9IHZhbHVlLmxlbmd0aCAtIDFcbiAgICB0aGlzLl9jdXJyZW50Qml0UG9zID0gN1xuICB9XG5cbiAgYXZhaWxhYmxlQml0cyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRCaXRQb3MgKyAxICsgdGhpcy5fY3VycmVudEJ5dGVQb3MgKiA4XG4gIH1cblxuICB0b3RhbEJpdHMgKCkge1xuICAgIHJldHVybiB0aGlzLl92YWx1ZS5sZW5ndGggKiA4XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IGJpdHNcbiAgICovXG4gIHRha2UgKGJpdHMpIHtcbiAgICBsZXQgcGVuZGluZ0JpdHMgPSBiaXRzXG4gICAgbGV0IHJlc3VsdCA9IDBcbiAgICB3aGlsZSAocGVuZGluZ0JpdHMgJiYgdGhpcy5faGF2ZUJpdHMoKSkge1xuICAgICAgY29uc3QgYnl0ZSA9IHRoaXMuX3ZhbHVlW3RoaXMuX2N1cnJlbnRCeXRlUG9zXVxuICAgICAgY29uc3QgYXZhaWxhYmxlQml0cyA9IHRoaXMuX2N1cnJlbnRCaXRQb3MgKyAxXG4gICAgICBjb25zdCB0YWtpbmcgPSBNYXRoLm1pbihhdmFpbGFibGVCaXRzLCBwZW5kaW5nQml0cylcbiAgICAgIGNvbnN0IHZhbHVlID0gYnl0ZUJpdHNUb0ludChieXRlLCBhdmFpbGFibGVCaXRzIC0gdGFraW5nLCB0YWtpbmcpXG4gICAgICByZXN1bHQgPSAocmVzdWx0IDw8IHRha2luZykgKyB2YWx1ZVxuXG4gICAgICBwZW5kaW5nQml0cyAtPSB0YWtpbmdcblxuICAgICAgdGhpcy5fY3VycmVudEJpdFBvcyAtPSB0YWtpbmdcbiAgICAgIGlmICh0aGlzLl9jdXJyZW50Qml0UG9zIDwgMCkge1xuICAgICAgICB0aGlzLl9jdXJyZW50Qml0UG9zID0gN1xuICAgICAgICB0aGlzLl9jdXJyZW50Qnl0ZVBvcy0tXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRzXG4gICAqL1xuICB1bnRha2UgKGJpdHMpIHtcbiAgICB0aGlzLl9jdXJyZW50Qml0UG9zICs9IGJpdHNcbiAgICB3aGlsZSAodGhpcy5fY3VycmVudEJpdFBvcyA+IDcpIHtcbiAgICAgIHRoaXMuX2N1cnJlbnRCaXRQb3MgLT0gOFxuICAgICAgdGhpcy5fY3VycmVudEJ5dGVQb3MgKz0gMVxuICAgIH1cbiAgfVxuXG4gIF9oYXZlQml0cyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRCeXRlUG9zID49IDBcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBieXRlXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhcnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGhcbiAqL1xuZnVuY3Rpb24gYnl0ZUJpdHNUb0ludCAoYnl0ZSwgc3RhcnQsIGxlbmd0aCkge1xuICBjb25zdCBtYXNrID0gbWFza0ZvcihzdGFydCwgbGVuZ3RoKVxuICByZXR1cm4gKGJ5dGUgJiBtYXNrKSA+Pj4gc3RhcnRcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhcnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGhcbiAqL1xuZnVuY3Rpb24gbWFza0ZvciAoc3RhcnQsIGxlbmd0aCkge1xuICByZXR1cm4gU1RBUlRfTUFTS1Nbc3RhcnRdICYgU1RPUF9NQVNLU1tNYXRoLm1pbihsZW5ndGggKyBzdGFydCAtIDEsIDcpXVxufVxuIiwgIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGFsbG9jID0gcmVxdWlyZSgnLi9hbGxvYy5qcycpO1xudmFyIGFzVWludDhhcnJheSA9IHJlcXVpcmUoJy4vdXRpbC9hcy11aW50OGFycmF5LmpzJyk7XG5cbmZ1bmN0aW9uIGNvbmNhdChhcnJheXMsIGxlbmd0aCkge1xuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IGFycmF5cy5yZWR1Y2UoKGFjYywgY3VycikgPT4gYWNjICsgY3Vyci5sZW5ndGgsIDApO1xuICB9XG4gIGNvbnN0IG91dHB1dCA9IGFsbG9jLmFsbG9jVW5zYWZlKGxlbmd0aCk7XG4gIGxldCBvZmZzZXQgPSAwO1xuICBmb3IgKGNvbnN0IGFyciBvZiBhcnJheXMpIHtcbiAgICBvdXRwdXQuc2V0KGFyciwgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gYXJyLmxlbmd0aDtcbiAgfVxuICByZXR1cm4gYXNVaW50OGFycmF5LmFzVWludDhBcnJheShvdXRwdXQpO1xufVxuXG5leHBvcnRzLmNvbmNhdCA9IGNvbmNhdDtcbiIsICIndXNlIHN0cmljdCdcblxuY29uc3QgQ29uc3VtYWJsZUJ1ZmZlciA9IHJlcXVpcmUoJy4vY29uc3VtYWJsZS1idWZmZXInKVxuY29uc3QgeyBjb25jYXQ6IHVpbnQ4QXJyYXlDb25jYXQgfSA9IHJlcXVpcmUoJ3VpbnQ4YXJyYXlzL2NvbmNhdCcpXG5cbi8qKlxuICogQHBhcmFtIHsodmFsdWU6IFVpbnQ4QXJyYXkpID0+IFByb21pc2U8VWludDhBcnJheT59IGhhc2hGblxuICovXG5mdW5jdGlvbiB3cmFwSGFzaCAoaGFzaEZuKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0luZmluaXRlSGFzaCB8IFVpbnQ4QXJyYXl9IHZhbHVlXG4gICAqL1xuICBmdW5jdGlvbiBoYXNoaW5nICh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEluZmluaXRlSGFzaCkge1xuICAgICAgLy8gYWxyZWFkeSBhIGhhc2guIHJldHVybiBpdFxuICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgSW5maW5pdGVIYXNoKHZhbHVlLCBoYXNoRm4pXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGhhc2hpbmdcbn1cblxuY2xhc3MgSW5maW5pdGVIYXNoIHtcbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7VWludDhBcnJheX0gdmFsdWVcbiAgICogQHBhcmFtIHsodmFsdWU6IFVpbnQ4QXJyYXkpID0+IFByb21pc2U8VWludDhBcnJheT59IGhhc2hGblxuICAgKi9cbiAgY29uc3RydWN0b3IgKHZhbHVlLCBoYXNoRm4pIHtcbiAgICBpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NhbiBvbmx5IGhhc2ggVWludDhBcnJheXMnKVxuICAgIH1cblxuICAgIHRoaXMuX3ZhbHVlID0gdmFsdWVcbiAgICB0aGlzLl9oYXNoRm4gPSBoYXNoRm5cbiAgICB0aGlzLl9kZXB0aCA9IC0xXG4gICAgdGhpcy5fYXZhaWxhYmxlQml0cyA9IDBcbiAgICB0aGlzLl9jdXJyZW50QnVmZmVySW5kZXggPSAwXG5cbiAgICAvKiogQHR5cGUge0NvbnN1bWFibGVCdWZmZXJbXX0gKi9cbiAgICB0aGlzLl9idWZmZXJzID0gW11cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gYml0c1xuICAgKi9cbiAgYXN5bmMgdGFrZSAoYml0cykge1xuICAgIGxldCBwZW5kaW5nQml0cyA9IGJpdHNcblxuICAgIHdoaWxlICh0aGlzLl9hdmFpbGFibGVCaXRzIDwgcGVuZGluZ0JpdHMpIHtcbiAgICAgIGF3YWl0IHRoaXMuX3Byb2R1Y2VNb3JlQml0cygpXG4gICAgfVxuXG4gICAgbGV0IHJlc3VsdCA9IDBcblxuICAgIHdoaWxlIChwZW5kaW5nQml0cyA+IDApIHtcbiAgICAgIGNvbnN0IGhhc2ggPSB0aGlzLl9idWZmZXJzW3RoaXMuX2N1cnJlbnRCdWZmZXJJbmRleF1cbiAgICAgIGNvbnN0IGF2YWlsYWJsZSA9IE1hdGgubWluKGhhc2guYXZhaWxhYmxlQml0cygpLCBwZW5kaW5nQml0cylcbiAgICAgIGNvbnN0IHRvb2sgPSBoYXNoLnRha2UoYXZhaWxhYmxlKVxuICAgICAgcmVzdWx0ID0gKHJlc3VsdCA8PCBhdmFpbGFibGUpICsgdG9va1xuICAgICAgcGVuZGluZ0JpdHMgLT0gYXZhaWxhYmxlXG4gICAgICB0aGlzLl9hdmFpbGFibGVCaXRzIC09IGF2YWlsYWJsZVxuXG4gICAgICBpZiAoaGFzaC5hdmFpbGFibGVCaXRzKCkgPT09IDApIHtcbiAgICAgICAgdGhpcy5fY3VycmVudEJ1ZmZlckluZGV4KytcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IGJpdHNcbiAgICovXG4gIHVudGFrZSAoYml0cykge1xuICAgIGxldCBwZW5kaW5nQml0cyA9IGJpdHNcblxuICAgIHdoaWxlIChwZW5kaW5nQml0cyA+IDApIHtcbiAgICAgIGNvbnN0IGhhc2ggPSB0aGlzLl9idWZmZXJzW3RoaXMuX2N1cnJlbnRCdWZmZXJJbmRleF1cbiAgICAgIGNvbnN0IGF2YWlsYWJsZUZvclVudGFrZSA9IE1hdGgubWluKGhhc2gudG90YWxCaXRzKCkgLSBoYXNoLmF2YWlsYWJsZUJpdHMoKSwgcGVuZGluZ0JpdHMpXG4gICAgICBoYXNoLnVudGFrZShhdmFpbGFibGVGb3JVbnRha2UpXG4gICAgICBwZW5kaW5nQml0cyAtPSBhdmFpbGFibGVGb3JVbnRha2VcbiAgICAgIHRoaXMuX2F2YWlsYWJsZUJpdHMgKz0gYXZhaWxhYmxlRm9yVW50YWtlXG5cbiAgICAgIGlmICh0aGlzLl9jdXJyZW50QnVmZmVySW5kZXggPiAwICYmIGhhc2gudG90YWxCaXRzKCkgPT09IGhhc2guYXZhaWxhYmxlQml0cygpKSB7XG4gICAgICAgIHRoaXMuX2RlcHRoLS1cbiAgICAgICAgdGhpcy5fY3VycmVudEJ1ZmZlckluZGV4LS1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBhc3luYyBfcHJvZHVjZU1vcmVCaXRzICgpIHtcbiAgICB0aGlzLl9kZXB0aCsrXG5cbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMuX2RlcHRoID8gdWludDhBcnJheUNvbmNhdChbdGhpcy5fdmFsdWUsIFVpbnQ4QXJyYXkuZnJvbShbdGhpcy5fZGVwdGhdKV0pIDogdGhpcy5fdmFsdWVcbiAgICBjb25zdCBoYXNoVmFsdWUgPSBhd2FpdCB0aGlzLl9oYXNoRm4odmFsdWUpXG4gICAgY29uc3QgYnVmZmVyID0gbmV3IENvbnN1bWFibGVCdWZmZXIoaGFzaFZhbHVlKVxuXG4gICAgdGhpcy5fYnVmZmVycy5wdXNoKGJ1ZmZlcilcbiAgICB0aGlzLl9hdmFpbGFibGVCaXRzICs9IGJ1ZmZlci5hdmFpbGFibGVCaXRzKClcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHdyYXBIYXNoXG5tb2R1bGUuZXhwb3J0cy5JbmZpbml0ZUhhc2ggPSBJbmZpbml0ZUhhc2hcbiIsICIndXNlIHN0cmljdCdcblxuY29uc3QgQnVja2V0ID0gcmVxdWlyZSgnLi9idWNrZXQnKVxuY29uc3Qgd3JhcEhhc2ggPSByZXF1aXJlKCcuL2NvbnN1bWFibGUtaGFzaCcpXG5cbi8qKlxuICogQHR5cGVkZWYge29iamVjdH0gVXNlckJ1Y2tldE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7KHZhbHVlOiBVaW50OEFycmF5KSA9PiBQcm9taXNlPFVpbnQ4QXJyYXk+fSBoYXNoRm5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbYml0cz04XVxuICovXG5cbi8qKlxuICogQHBhcmFtIHtVc2VyQnVja2V0T3B0aW9uc30gb3B0aW9uc1xuICovXG5mdW5jdGlvbiBjcmVhdGVIQU1UIChvcHRpb25zKSB7XG4gIGlmICghb3B0aW9ucyB8fCAhb3B0aW9ucy5oYXNoRm4pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3BsZWFzZSBkZWZpbmUgYW4gb3B0aW9ucy5oYXNoRm4nKVxuICB9XG5cbiAgY29uc3QgYnVja2V0T3B0aW9ucyA9IHtcbiAgICBiaXRzOiBvcHRpb25zLmJpdHMgfHwgOCxcbiAgICBoYXNoOiB3cmFwSGFzaChvcHRpb25zLmhhc2hGbilcbiAgfVxuXG4gIHJldHVybiBuZXcgQnVja2V0KGJ1Y2tldE9wdGlvbnMpXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjcmVhdGVIQU1ULFxuICBCdWNrZXRcbn1cbiIsICIndXNlIHN0cmljdCdcblxuLyoqXG4gKiBUdXJucyBhIGJyb3dzZXIgcmVhZGFibGUgc3RyZWFtIGludG8gYW4gYXN5bmMgaXRlcmFibGUuIEFzeW5jIGl0ZXJhdGlvbiBvdmVyXG4gKiByZXR1cm5lZCBpdGVyYWJsZSB3aWxsIGxvY2sgZ2l2ZSBzdHJlYW0sIHByZXZlbnRpbmcgYW55IG90aGVyIGNvbnN1bWVyIGZyb21cbiAqIGFjcXVpcmluZyBhIHJlYWRlci4gVGhlIGxvY2sgd2lsbCBiZSByZWxlYXNlZCBpZiBpdGVyYXRpb24gbG9vcCBpcyBicm9rZW4uIFRvXG4gKiBwcmV2ZW50IHN0cmVhbSBjYW5jZWxsaW5nIG9wdGlvbmFsIGB7IHByZXZlbnRDYW5jZWw6IHRydWUgfWAgY291bGQgYmUgcGFzc2VkXG4gKiBhcyBhIHNlY29uZCBhcmd1bWVudC5cbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge1JlYWRhYmxlU3RyZWFtPFQ+fSBzdHJlYW1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMucHJldmVudENhbmNlbD1ib29sZWFuXVxuICogQHJldHVybnMge0FzeW5jSXRlcmFibGU8VD59XG4gKi9cbmFzeW5jIGZ1bmN0aW9uICogYnJvd3NlclJlYWRhYmxlU3RyZWFtVG9JdCAoc3RyZWFtLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3QgcmVhZGVyID0gc3RyZWFtLmdldFJlYWRlcigpXG5cbiAgdHJ5IHtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVhZGVyLnJlYWQoKVxuXG4gICAgICBpZiAocmVzdWx0LmRvbmUpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIHlpZWxkIHJlc3VsdC52YWx1ZVxuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICBpZiAob3B0aW9ucy5wcmV2ZW50Q2FuY2VsICE9PSB0cnVlKSB7XG4gICAgICByZWFkZXIuY2FuY2VsKClcbiAgICB9XG5cbiAgICByZWFkZXIucmVsZWFzZUxvY2soKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYnJvd3NlclJlYWRhYmxlU3RyZWFtVG9JdFxuIiwgIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4ndXNlIHN0cmljdCdcblxuY29uc3QgYnJvd3NlclJlYWRhYmxlU3RyZWFtVG9JdCA9IHJlcXVpcmUoJ2Jyb3dzZXItcmVhZGFibGVzdHJlYW0tdG8taXQnKVxuXG4vKipcbiAqIEBwYXJhbSB7QmxvYn0gYmxvYlxuICogQHJldHVybnMge0FzeW5jSXRlcmFibGU8VWludDhBcnJheT59XG4gKi9cbmZ1bmN0aW9uIGJsb2JUb0l0IChibG9iKSB7XG4gIGlmICh0eXBlb2YgYmxvYi5zdHJlYW0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBAdHMtaWdub3JlIG1pc3Npbmcgc29tZSBwcm9wZXJ0aWVzXG4gICAgcmV0dXJuIGJyb3dzZXJSZWFkYWJsZVN0cmVhbVRvSXQoYmxvYi5zdHJlYW0oKSlcbiAgfVxuXG4gIC8vIGZpcmVmb3ggPCA2OSBkb2VzIG5vdCBzdXBwb3J0IGJsb2Iuc3RyZWFtKClcbiAgLy8gQHRzLWlnbm9yZSAtIHJlc3BvbnNlLmJvZHkgaXMgb3B0aW9uYWwsIGJ1dCBpbiBwcmFjdGljZSBpdCdzIGEgc3RyZWFtLlxuICByZXR1cm4gYnJvd3NlclJlYWRhYmxlU3RyZWFtVG9JdChuZXcgUmVzcG9uc2UoYmxvYikuYm9keSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBibG9iVG9JdFxuIiwgIid1c2Ugc3RyaWN0J1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBQZWVrXG4gKiBAcHJvcGVydHkgeygpID0+IEl0ZXJhdG9yUmVzdWx0PFQsIHZvaWQ+fSBwZWVrXG4gKi9cblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHR5cGVkZWYge09iamVjdH0gQXN5bmNQZWVrXG4gKiBAcHJvcGVydHkgeygpID0+IFByb21pc2U8SXRlcmF0b3JSZXN1bHQ8VCwgdm9pZD4+fSBwZWVrXG4gKi9cblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHR5cGVkZWYge09iamVjdH0gUHVzaFxuICogQHByb3BlcnR5IHsodmFsdWU6VCkgPT4gdm9pZH0gcHVzaFxuICovXG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEB0eXBlZGVmIHtJdGVyYWJsZTxUPiAmIFBlZWs8VD4gJiBQdXNoPFQ+ICYgSXRlcmF0b3I8VD59IFBlZWthYmxlPFQ+XG4gKi9cblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHR5cGVkZWYge0FzeW5jSXRlcmFibGU8VD4gJiBBc3luY1BlZWs8VD4gJiBQdXNoPFQ+ICYgQXN5bmNJdGVyYXRvcjxUPn0gQXN5bmNQZWVrYWJsZTxUPlxuICovXG5cbi8qKlxuICogQHRlbXBsYXRlIHtJdGVyYWJsZTxhbnk+IHwgQXN5bmNJdGVyYWJsZTxhbnk+fSBJXG4gKiBAcGFyYW0ge0l9IGl0ZXJhYmxlXG4gKiBAcmV0dXJucyB7SSBleHRlbmRzIEl0ZXJhYmxlPGluZmVyIFQ+XG4gKiAgPyBQZWVrYWJsZTxUPlxuICogIDogSSBleHRlbmRzIEFzeW5jSXRlcmFibGU8aW5mZXIgVD5cbiAqICA/IEFzeW5jUGVla2FibGU8VD5cbiAqICA6IG5ldmVyXG4gKiB9XG4gKi9cbmZ1bmN0aW9uIHBlZWthYmxlSXRlcmF0b3IgKGl0ZXJhYmxlKSB7XG4gIC8vIEB0cy1pZ25vcmVcbiAgY29uc3QgW2l0ZXJhdG9yLCBzeW1ib2xdID0gaXRlcmFibGVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgID8gW2l0ZXJhYmxlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpLCBTeW1ib2wuYXN5bmNJdGVyYXRvcl1cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgOiBbaXRlcmFibGVbU3ltYm9sLml0ZXJhdG9yXSgpLCBTeW1ib2wuaXRlcmF0b3JdXG5cbiAgLyoqIEB0eXBlIHthbnlbXX0gKi9cbiAgY29uc3QgcXVldWUgPSBbXVxuXG4gIC8vIEB0cy1pZ25vcmVcbiAgcmV0dXJuIHtcbiAgICBwZWVrOiAoKSA9PiB7XG4gICAgICByZXR1cm4gaXRlcmF0b3IubmV4dCgpXG4gICAgfSxcbiAgICBwdXNoOiAodmFsdWUpID0+IHtcbiAgICAgIHF1ZXVlLnB1c2godmFsdWUpXG4gICAgfSxcbiAgICBuZXh0OiAoKSA9PiB7XG4gICAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgICAgdmFsdWU6IHF1ZXVlLnNoaWZ0KClcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gaXRlcmF0b3IubmV4dCgpXG4gICAgfSxcbiAgICBbc3ltYm9sXSAoKSB7XG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBlZWthYmxlSXRlcmF0b3JcbiIsICIndXNlIHN0cmljdCdcblxuLyoqXG4gKiBUYWtlcyBhbiAoYXN5bmMpIGl0ZXJhYmxlIGFuZCByZXR1cm5zIG9uZSB3aXRoIGVhY2ggaXRlbSBtYXBwZWQgYnkgdGhlIHBhc3NlZFxuICogZnVuY3Rpb24uXG4gKlxuICogQHRlbXBsYXRlIEksT1xuICogQHBhcmFtIHtBc3luY0l0ZXJhYmxlPEk+fEl0ZXJhYmxlPEk+fSBzb3VyY2VcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oSSk6T3xQcm9taXNlPE8+fSBmdW5jXG4gKiBAcmV0dXJucyB7QXN5bmNJdGVyYWJsZTxPPn1cbiAqL1xuY29uc3QgbWFwID0gYXN5bmMgZnVuY3Rpb24gKiAoc291cmNlLCBmdW5jKSB7XG4gIGZvciBhd2FpdCAoY29uc3QgdmFsIG9mIHNvdXJjZSkge1xuICAgIHlpZWxkIGZ1bmModmFsKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwXG4iLCAiJ3VzZSBzdHJpY3QnXG5cbi8qKlxuICogRHJhaW5zIGFuIChhc3luYykgaXRlcmFibGUgZGlzY2FyZGluZyBpdHMnIGNvbnRlbnQgYW5kIGRvZXMgbm90IHJldHVyblxuICogYW55dGhpbmcuXG4gKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7QXN5bmNJdGVyYWJsZTxUPnxJdGVyYWJsZTxUPn0gc291cmNlXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAqL1xuY29uc3QgZHJhaW4gPSBhc3luYyAoc291cmNlKSA9PiB7XG4gIGZvciBhd2FpdCAoY29uc3QgXyBvZiBzb3VyY2UpIHsgfSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzLG5vLWVtcHR5XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZHJhaW5cbiIsICIndXNlIHN0cmljdCdcblxuLyoqXG4gKiBGaWx0ZXJzIHRoZSBwYXNzZWQgKGFzeW5jKSBpdGVyYWJsZSBieSB1c2luZyB0aGUgZmlsdGVyIGZ1bmN0aW9uXG4gKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7QXN5bmNJdGVyYWJsZTxUPnxJdGVyYWJsZTxUPn0gc291cmNlXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKFQpOmJvb2xlYW58UHJvbWlzZTxib29sZWFuPn0gZm5cbiAqL1xuY29uc3QgZmlsdGVyID0gYXN5bmMgZnVuY3Rpb24gKiAoc291cmNlLCBmbikge1xuICBmb3IgYXdhaXQgKGNvbnN0IGVudHJ5IG9mIHNvdXJjZSkge1xuICAgIGlmIChhd2FpdCBmbihlbnRyeSkpIHtcbiAgICAgIHlpZWxkIGVudHJ5XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZmlsdGVyXG4iLCAiJ3VzZSBzdHJpY3QnXG5cbi8qKlxuICogU3RvcCBpdGVyYXRpb24gYWZ0ZXIgbiBpdGVtcyBoYXZlIGJlZW4gcmVjZWl2ZWQuXG4gKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7QXN5bmNJdGVyYWJsZTxUPnxJdGVyYWJsZTxUPn0gc291cmNlXG4gKiBAcGFyYW0ge251bWJlcn0gbGltaXRcbiAqIEByZXR1cm5zIHtBc3luY0l0ZXJhYmxlPFQ+fVxuICovXG5jb25zdCB0YWtlID0gYXN5bmMgZnVuY3Rpb24gKiAoc291cmNlLCBsaW1pdCkge1xuICBsZXQgaXRlbXMgPSAwXG5cbiAgaWYgKGxpbWl0IDwgMSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgZm9yIGF3YWl0IChjb25zdCBlbnRyeSBvZiBzb3VyY2UpIHtcbiAgICB5aWVsZCBlbnRyeVxuXG4gICAgaXRlbXMrK1xuXG4gICAgaWYgKGl0ZW1zID09PSBsaW1pdCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdGFrZVxuIiwgImZ1bmN0aW9uIHRocm90dGxlZFF1ZXVlKFxuICBtYXhSZXF1ZXN0c1BlckludGVydmFsOiBudW1iZXIsXG4gIGludGVydmFsOiBudW1iZXIsXG4gIGV2ZW5seVNwYWNlZCA9IGZhbHNlLFxuKSB7XG4gIC8qKlxuICAgKiBJZiBhbGwgcmVxdWVzdHMgc2hvdWxkIGJlIGV2ZW5seSBzcGFjZWQsIGFkanVzdCB0byBzdWl0LlxuICAgKi9cbiAgaWYgKGV2ZW5seVNwYWNlZCkge1xuICAgIGludGVydmFsID0gaW50ZXJ2YWwgLyBtYXhSZXF1ZXN0c1BlckludGVydmFsO1xuICAgIG1heFJlcXVlc3RzUGVySW50ZXJ2YWwgPSAxO1xuICB9XG4gIGNvbnN0IHF1ZXVlOiBBcnJheTwoKSA9PiBQcm9taXNlPHZvaWQ+PiA9IFtdO1xuICBsZXQgbGFzdEludGVydmFsU3RhcnQgPSAwO1xuICBsZXQgbnVtUmVxdWVzdHNQZXJJbnRlcnZhbCA9IDA7XG4gIGxldCB0aW1lb3V0OiBOb2RlSlMuVGltZW91dCB8IHVuZGVmaW5lZDtcbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIGF0IGEgc2V0IGludGVydmFsIHRvIHJlbW92ZSBpdGVtcyBmcm9tIHRoZSBxdWV1ZS5cbiAgICogVGhpcyBpcyBhIHNlbGYtYWRqdXN0aW5nIHRpbWVyLCBzaW5jZSB0aGUgYnJvd3NlcidzIHNldFRpbWVvdXQgaXMgaGlnaGx5IGluYWNjdXJhdGUuXG4gICAqL1xuICBjb25zdCBkZXF1ZXVlID0gKCkgPT4ge1xuICAgIGNvbnN0IGludGVydmFsRW5kID0gbGFzdEludGVydmFsU3RhcnQgKyBpbnRlcnZhbDtcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIC8qKlxuICAgICAqIEFkanVzdCB0aGUgdGltZXIgaWYgaXQgd2FzIGNhbGxlZCB0b28gZWFybHkuXG4gICAgICovXG4gICAgaWYgKG5vdyA8IGludGVydmFsRW5kKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hcmd1bWVudFxuICAgICAgdGltZW91dCAhPT0gdW5kZWZpbmVkICYmIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGRlcXVldWUsIGludGVydmFsRW5kIC0gbm93KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGFzdEludGVydmFsU3RhcnQgPSBub3c7XG4gICAgbnVtUmVxdWVzdHNQZXJJbnRlcnZhbCA9IDA7XG4gICAgZm9yIChjb25zdCBjYWxsYmFjayBvZiBxdWV1ZS5zcGxpY2UoMCwgbWF4UmVxdWVzdHNQZXJJbnRlcnZhbCkpIHtcbiAgICAgIG51bVJlcXVlc3RzUGVySW50ZXJ2YWwrKztcbiAgICAgIHZvaWQgY2FsbGJhY2soKTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoZGVxdWV1ZSwgaW50ZXJ2YWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aW1lb3V0ID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gPFJldHVybiA9IHVua25vd24+KGZuOiAoKSA9PiBQcm9taXNlPFJldHVybj4gfCBSZXR1cm4pOiBQcm9taXNlPFJldHVybj4gPT4gbmV3IFByb21pc2U8UmV0dXJuPihcbiAgICAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBjYWxsYmFjayA9ICgpID0+IFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZm4pLnRoZW4ocmVzb2x2ZSkuY2F0Y2gocmVqZWN0KTtcbiAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICBpZiAodGltZW91dCA9PT0gdW5kZWZpbmVkICYmIChub3cgLSBsYXN0SW50ZXJ2YWxTdGFydCkgPiBpbnRlcnZhbCkge1xuICAgICAgICBsYXN0SW50ZXJ2YWxTdGFydCA9IG5vdztcbiAgICAgICAgbnVtUmVxdWVzdHNQZXJJbnRlcnZhbCA9IDA7XG4gICAgICB9XG4gICAgICBpZiAobnVtUmVxdWVzdHNQZXJJbnRlcnZhbCsrIDwgbWF4UmVxdWVzdHNQZXJJbnRlcnZhbCkge1xuICAgICAgICB2b2lkIGNhbGxiYWNrKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZS5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgaWYgKHRpbWVvdXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGRlcXVldWUsIGxhc3RJbnRlcnZhbFN0YXJ0ICsgaW50ZXJ2YWwgLSBub3cpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gdGhyb3R0bGVkUXVldWU7XG5leHBvcnQgZGVmYXVsdCB0aHJvdHRsZWRRdWV1ZTtcblxuIiwgbnVsbCwgIi8vLyA8cmVmZXJlbmNlIGxpYj1cImVzMjAxNS5zeW1ib2xcIiAvPlxuXG5jb25zdCBTeW1ib2xQb2x5ZmlsbDogKGRlc2NyaXB0aW9uPzogc3RyaW5nKSA9PiBzeW1ib2wgPVxuICB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09ICdzeW1ib2wnID9cbiAgICBTeW1ib2wgOlxuICAgIGRlc2NyaXB0aW9uID0+IGBTeW1ib2woJHtkZXNjcmlwdGlvbn0pYCBhcyBhbnkgYXMgc3ltYm9sO1xuXG5leHBvcnQgZGVmYXVsdCBTeW1ib2xQb2x5ZmlsbDtcbiIsICIvLy8gPHJlZmVyZW5jZSBsaWI9XCJkb21cIiAvPlxuXG5leHBvcnQgZnVuY3Rpb24gbm9vcCgpOiB1bmRlZmluZWQge1xuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBnZXRHbG9iYWxzKCkge1xuICBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gd2luZG93O1xuICB9IGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGdsb2JhbDtcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgY29uc3QgZ2xvYmFscyA9IGdldEdsb2JhbHMoKTtcbiIsICJpbXBvcnQgeyBub29wIH0gZnJvbSAnLi4vLi4vdXRpbHMnO1xuaW1wb3J0IHsgQXNzZXJ0aW9uRXJyb3IgfSBmcm9tICcuLi8uLi9zdHViL2Fzc2VydCc7XG5cbmV4cG9ydCBmdW5jdGlvbiB0eXBlSXNPYmplY3QoeDogYW55KTogeCBpcyBvYmplY3Qge1xuICByZXR1cm4gKHR5cGVvZiB4ID09PSAnb2JqZWN0JyAmJiB4ICE9PSBudWxsKSB8fCB0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZXhwb3J0IGNvbnN0IHJldGhyb3dBc3NlcnRpb25FcnJvclJlamVjdGlvbjogKGU6IGFueSkgPT4gdm9pZCA9XG4gIERFQlVHID8gZSA9PiB7XG4gICAgLy8gVXNlZCB0aHJvdWdob3V0IHRoZSByZWZlcmVuY2UgaW1wbGVtZW50YXRpb24sIGFzIGAuY2F0Y2gocmV0aHJvd0Fzc2VydGlvbkVycm9yUmVqZWN0aW9uKWAsIHRvIGVuc3VyZSBhbnkgZXJyb3JzXG4gICAgLy8gZ2V0IHNob3duLiBUaGVyZSBhcmUgcGxhY2VzIGluIHRoZSBzcGVjIHdoZXJlIHdlIGRvIHByb21pc2UgdHJhbnNmb3JtYXRpb25zIGFuZCBwdXJwb3NlZnVsbHkgaWdub3JlIG9yIGRvbid0XG4gICAgLy8gZXhwZWN0IGFueSBlcnJvcnMsIGJ1dCBhc3NlcnRpb24gZXJyb3JzIGFyZSBhbHdheXMgcHJvYmxlbWF0aWMuXG4gICAgaWYgKGUgJiYgZSBpbnN0YW5jZW9mIEFzc2VydGlvbkVycm9yKSB7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH0sIDApO1xuICAgIH1cbiAgfSA6IG5vb3A7XG4iLCAiaW1wb3J0IHsgZ2xvYmFscyB9IGZyb20gJy4uLy4uL3V0aWxzJztcbmltcG9ydCB7IHJldGhyb3dBc3NlcnRpb25FcnJvclJlamVjdGlvbiB9IGZyb20gJy4vbWlzY2VsbGFuZW91cyc7XG5pbXBvcnQgYXNzZXJ0IGZyb20gJy4uLy4uL3N0dWIvYXNzZXJ0JztcblxuY29uc3Qgb3JpZ2luYWxQcm9taXNlID0gUHJvbWlzZTtcbmNvbnN0IG9yaWdpbmFsUHJvbWlzZVRoZW4gPSBQcm9taXNlLnByb3RvdHlwZS50aGVuO1xuY29uc3Qgb3JpZ2luYWxQcm9taXNlUmVzb2x2ZSA9IFByb21pc2UucmVzb2x2ZS5iaW5kKG9yaWdpbmFsUHJvbWlzZSk7XG5jb25zdCBvcmlnaW5hbFByb21pc2VSZWplY3QgPSBQcm9taXNlLnJlamVjdC5iaW5kKG9yaWdpbmFsUHJvbWlzZSk7XG5cbmV4cG9ydCBmdW5jdGlvbiBuZXdQcm9taXNlPFQ+KGV4ZWN1dG9yOiAoXG4gIHJlc29sdmU6ICh2YWx1ZTogVCB8IFByb21pc2VMaWtlPFQ+KSA9PiB2b2lkLFxuICByZWplY3Q6IChyZWFzb24/OiBhbnkpID0+IHZvaWRcbikgPT4gdm9pZCk6IFByb21pc2U8VD4ge1xuICByZXR1cm4gbmV3IG9yaWdpbmFsUHJvbWlzZShleGVjdXRvcik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwcm9taXNlUmVzb2x2ZWRXaXRoPFQ+KHZhbHVlOiBUIHwgUHJvbWlzZUxpa2U8VD4pOiBQcm9taXNlPFQ+IHtcbiAgcmV0dXJuIG9yaWdpbmFsUHJvbWlzZVJlc29sdmUodmFsdWUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcHJvbWlzZVJlamVjdGVkV2l0aDxUID0gbmV2ZXI+KHJlYXNvbjogYW55KTogUHJvbWlzZTxUPiB7XG4gIHJldHVybiBvcmlnaW5hbFByb21pc2VSZWplY3QocmVhc29uKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFBlcmZvcm1Qcm9taXNlVGhlbjxULCBUUmVzdWx0MSA9IFQsIFRSZXN1bHQyID0gbmV2ZXI+KFxuICBwcm9taXNlOiBQcm9taXNlPFQ+LFxuICBvbkZ1bGZpbGxlZD86ICh2YWx1ZTogVCkgPT4gVFJlc3VsdDEgfCBQcm9taXNlTGlrZTxUUmVzdWx0MT4sXG4gIG9uUmVqZWN0ZWQ/OiAocmVhc29uOiBhbnkpID0+IFRSZXN1bHQyIHwgUHJvbWlzZUxpa2U8VFJlc3VsdDI+KTogUHJvbWlzZTxUUmVzdWx0MSB8IFRSZXN1bHQyPiB7XG4gIC8vIFRoZXJlIGRvZXNuJ3QgYXBwZWFyIHRvIGJlIGFueSB3YXkgdG8gY29ycmVjdGx5IGVtdWxhdGUgdGhlIGJlaGF2aW91ciBmcm9tIEphdmFTY3JpcHQsIHNvIHRoaXMgaXMganVzdCBhblxuICAvLyBhcHByb3hpbWF0aW9uLlxuICByZXR1cm4gb3JpZ2luYWxQcm9taXNlVGhlbi5jYWxsKHByb21pc2UsIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSBhcyBQcm9taXNlPFRSZXN1bHQxIHwgVFJlc3VsdDI+O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXBvblByb21pc2U8VD4oXG4gIHByb21pc2U6IFByb21pc2U8VD4sXG4gIG9uRnVsZmlsbGVkPzogKHZhbHVlOiBUKSA9PiB2b2lkIHwgUHJvbWlzZUxpa2U8dm9pZD4sXG4gIG9uUmVqZWN0ZWQ/OiAocmVhc29uOiBhbnkpID0+IHZvaWQgfCBQcm9taXNlTGlrZTx2b2lkPik6IHZvaWQge1xuICBQZXJmb3JtUHJvbWlzZVRoZW4oXG4gICAgUGVyZm9ybVByb21pc2VUaGVuKHByb21pc2UsIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSxcbiAgICB1bmRlZmluZWQsXG4gICAgcmV0aHJvd0Fzc2VydGlvbkVycm9yUmVqZWN0aW9uXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1cG9uRnVsZmlsbG1lbnQ8VD4ocHJvbWlzZTogUHJvbWlzZTxUPiwgb25GdWxmaWxsZWQ6ICh2YWx1ZTogVCkgPT4gdm9pZCB8IFByb21pc2VMaWtlPHZvaWQ+KTogdm9pZCB7XG4gIHVwb25Qcm9taXNlKHByb21pc2UsIG9uRnVsZmlsbGVkKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVwb25SZWplY3Rpb24ocHJvbWlzZTogUHJvbWlzZTx1bmtub3duPiwgb25SZWplY3RlZDogKHJlYXNvbjogYW55KSA9PiB2b2lkIHwgUHJvbWlzZUxpa2U8dm9pZD4pOiB2b2lkIHtcbiAgdXBvblByb21pc2UocHJvbWlzZSwgdW5kZWZpbmVkLCBvblJlamVjdGVkKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybVByb21pc2VXaXRoPFQsIFRSZXN1bHQxID0gVCwgVFJlc3VsdDIgPSBuZXZlcj4oXG4gIHByb21pc2U6IFByb21pc2U8VD4sXG4gIGZ1bGZpbGxtZW50SGFuZGxlcj86ICh2YWx1ZTogVCkgPT4gVFJlc3VsdDEgfCBQcm9taXNlTGlrZTxUUmVzdWx0MT4sXG4gIHJlamVjdGlvbkhhbmRsZXI/OiAocmVhc29uOiBhbnkpID0+IFRSZXN1bHQyIHwgUHJvbWlzZUxpa2U8VFJlc3VsdDI+KTogUHJvbWlzZTxUUmVzdWx0MSB8IFRSZXN1bHQyPiB7XG4gIHJldHVybiBQZXJmb3JtUHJvbWlzZVRoZW4ocHJvbWlzZSwgZnVsZmlsbG1lbnRIYW5kbGVyLCByZWplY3Rpb25IYW5kbGVyKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldFByb21pc2VJc0hhbmRsZWRUb1RydWUocHJvbWlzZTogUHJvbWlzZTx1bmtub3duPik6IHZvaWQge1xuICBQZXJmb3JtUHJvbWlzZVRoZW4ocHJvbWlzZSwgdW5kZWZpbmVkLCByZXRocm93QXNzZXJ0aW9uRXJyb3JSZWplY3Rpb24pO1xufVxuXG5leHBvcnQgY29uc3QgcXVldWVNaWNyb3Rhc2s6IChmbjogKCkgPT4gdm9pZCkgPT4gdm9pZCA9ICgoKSA9PiB7XG4gIGNvbnN0IGdsb2JhbFF1ZXVlTWljcm90YXNrID0gZ2xvYmFscyAmJiBnbG9iYWxzLnF1ZXVlTWljcm90YXNrO1xuICBpZiAodHlwZW9mIGdsb2JhbFF1ZXVlTWljcm90YXNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGdsb2JhbFF1ZXVlTWljcm90YXNrO1xuICB9XG5cbiAgY29uc3QgcmVzb2x2ZWRQcm9taXNlID0gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuICByZXR1cm4gKGZuOiAoKSA9PiB2b2lkKSA9PiBQZXJmb3JtUHJvbWlzZVRoZW4ocmVzb2x2ZWRQcm9taXNlLCBmbik7XG59KSgpO1xuXG5leHBvcnQgZnVuY3Rpb24gcmVmbGVjdENhbGw8VCwgQSBleHRlbmRzIGFueVtdLCBSPihGOiAodGhpczogVCwgLi4uZm5BcmdzOiBBKSA9PiBSLCBWOiBULCBhcmdzOiBBKTogUiB7XG4gIGlmICh0eXBlb2YgRiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG4gIH1cbiAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKEYsIFYsIGFyZ3MpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcHJvbWlzZUNhbGw8VCwgQSBleHRlbmRzIGFueVtdLCBSPihGOiAodGhpczogVCwgLi4uZm5BcmdzOiBBKSA9PiBSIHwgUHJvbWlzZUxpa2U8Uj4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBWOiBULFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogQSk6IFByb21pc2U8Uj4ge1xuICBhc3NlcnQodHlwZW9mIEYgPT09ICdmdW5jdGlvbicpO1xuICBhc3NlcnQoViAhPT0gdW5kZWZpbmVkKTtcbiAgYXNzZXJ0KEFycmF5LmlzQXJyYXkoYXJncykpO1xuICB0cnkge1xuICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZWRXaXRoKHJlZmxlY3RDYWxsKEYsIFYsIGFyZ3MpKTtcbiAgfSBjYXRjaCAodmFsdWUpIHtcbiAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aCh2YWx1ZSk7XG4gIH1cbn1cbiIsICJpbXBvcnQgYXNzZXJ0IGZyb20gJy4uL3N0dWIvYXNzZXJ0JztcblxuLy8gT3JpZ2luYWwgZnJvbSBDaHJvbWl1bVxuLy8gaHR0cHM6Ly9jaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYy8rLzBhZWU0NDM0YTRkYmE0MmE0MmFiYWVhOWJmYmMwY2QxOTZhNjNiYzEvdGhpcmRfcGFydHkvYmxpbmsvcmVuZGVyZXIvY29yZS9zdHJlYW1zL1NpbXBsZVF1ZXVlLmpzXG5cbmNvbnN0IFFVRVVFX01BWF9BUlJBWV9TSVpFID0gMTYzODQ7XG5cbmludGVyZmFjZSBOb2RlPFQ+IHtcbiAgX2VsZW1lbnRzOiBUW107XG4gIF9uZXh0OiBOb2RlPFQ+IHwgdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIFNpbXBsZSBxdWV1ZSBzdHJ1Y3R1cmUuXG4gKlxuICogQXZvaWRzIHNjYWxhYmlsaXR5IGlzc3VlcyB3aXRoIHVzaW5nIGEgcGFja2VkIGFycmF5IGRpcmVjdGx5IGJ5IHVzaW5nXG4gKiBtdWx0aXBsZSBhcnJheXMgaW4gYSBsaW5rZWQgbGlzdCBhbmQga2VlcGluZyB0aGUgYXJyYXkgc2l6ZSBib3VuZGVkLlxuICovXG5leHBvcnQgY2xhc3MgU2ltcGxlUXVldWU8VD4ge1xuICBwcml2YXRlIF9mcm9udDogTm9kZTxUPjtcbiAgcHJpdmF0ZSBfYmFjazogTm9kZTxUPjtcbiAgcHJpdmF0ZSBfY3Vyc29yID0gMDtcbiAgcHJpdmF0ZSBfc2l6ZSA9IDA7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgLy8gX2Zyb250IGFuZCBfYmFjayBhcmUgYWx3YXlzIGRlZmluZWQuXG4gICAgdGhpcy5fZnJvbnQgPSB7XG4gICAgICBfZWxlbWVudHM6IFtdLFxuICAgICAgX25leHQ6IHVuZGVmaW5lZFxuICAgIH07XG4gICAgdGhpcy5fYmFjayA9IHRoaXMuX2Zyb250O1xuICAgIC8vIFRoZSBjdXJzb3IgaXMgdXNlZCB0byBhdm9pZCBjYWxsaW5nIEFycmF5LnNoaWZ0KCkuXG4gICAgLy8gSXQgY29udGFpbnMgdGhlIGluZGV4IG9mIHRoZSBmcm9udCBlbGVtZW50IG9mIHRoZSBhcnJheSBpbnNpZGUgdGhlXG4gICAgLy8gZnJvbnQtbW9zdCBub2RlLiBJdCBpcyBhbHdheXMgaW4gdGhlIHJhbmdlIFswLCBRVUVVRV9NQVhfQVJSQVlfU0laRSkuXG4gICAgdGhpcy5fY3Vyc29yID0gMDtcbiAgICAvLyBXaGVuIHRoZXJlIGlzIG9ubHkgb25lIG5vZGUsIHNpemUgPT09IGVsZW1lbnRzLmxlbmd0aCAtIGN1cnNvci5cbiAgICB0aGlzLl9zaXplID0gMDtcbiAgfVxuXG4gIGdldCBsZW5ndGgoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fc2l6ZTtcbiAgfVxuXG4gIC8vIEZvciBleGNlcHRpb24gc2FmZXR5LCB0aGlzIG1ldGhvZCBpcyBzdHJ1Y3R1cmVkIGluIG9yZGVyOlxuICAvLyAxLiBSZWFkIHN0YXRlXG4gIC8vIDIuIENhbGN1bGF0ZSByZXF1aXJlZCBzdGF0ZSBtdXRhdGlvbnNcbiAgLy8gMy4gUGVyZm9ybSBzdGF0ZSBtdXRhdGlvbnNcbiAgcHVzaChlbGVtZW50OiBUKTogdm9pZCB7XG4gICAgY29uc3Qgb2xkQmFjayA9IHRoaXMuX2JhY2s7XG4gICAgbGV0IG5ld0JhY2sgPSBvbGRCYWNrO1xuICAgIGFzc2VydChvbGRCYWNrLl9uZXh0ID09PSB1bmRlZmluZWQpO1xuICAgIGlmIChvbGRCYWNrLl9lbGVtZW50cy5sZW5ndGggPT09IFFVRVVFX01BWF9BUlJBWV9TSVpFIC0gMSkge1xuICAgICAgbmV3QmFjayA9IHtcbiAgICAgICAgX2VsZW1lbnRzOiBbXSxcbiAgICAgICAgX25leHQ6IHVuZGVmaW5lZFxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBwdXNoKCkgaXMgdGhlIG11dGF0aW9uIG1vc3QgbGlrZWx5IHRvIHRocm93IGFuIGV4Y2VwdGlvbiwgc28gaXRcbiAgICAvLyBnb2VzIGZpcnN0LlxuICAgIG9sZEJhY2suX2VsZW1lbnRzLnB1c2goZWxlbWVudCk7XG4gICAgaWYgKG5ld0JhY2sgIT09IG9sZEJhY2spIHtcbiAgICAgIHRoaXMuX2JhY2sgPSBuZXdCYWNrO1xuICAgICAgb2xkQmFjay5fbmV4dCA9IG5ld0JhY2s7XG4gICAgfVxuICAgICsrdGhpcy5fc2l6ZTtcbiAgfVxuXG4gIC8vIExpa2UgcHVzaCgpLCBzaGlmdCgpIGZvbGxvd3MgdGhlIHJlYWQgLT4gY2FsY3VsYXRlIC0+IG11dGF0ZSBwYXR0ZXJuIGZvclxuICAvLyBleGNlcHRpb24gc2FmZXR5LlxuICBzaGlmdCgpOiBUIHtcbiAgICBhc3NlcnQodGhpcy5fc2l6ZSA+IDApOyAvLyBtdXN0IG5vdCBiZSBjYWxsZWQgb24gYW4gZW1wdHkgcXVldWVcblxuICAgIGNvbnN0IG9sZEZyb250ID0gdGhpcy5fZnJvbnQ7XG4gICAgbGV0IG5ld0Zyb250ID0gb2xkRnJvbnQ7XG4gICAgY29uc3Qgb2xkQ3Vyc29yID0gdGhpcy5fY3Vyc29yO1xuICAgIGxldCBuZXdDdXJzb3IgPSBvbGRDdXJzb3IgKyAxO1xuXG4gICAgY29uc3QgZWxlbWVudHMgPSBvbGRGcm9udC5fZWxlbWVudHM7XG4gICAgY29uc3QgZWxlbWVudCA9IGVsZW1lbnRzW29sZEN1cnNvcl07XG5cbiAgICBpZiAobmV3Q3Vyc29yID09PSBRVUVVRV9NQVhfQVJSQVlfU0laRSkge1xuICAgICAgYXNzZXJ0KGVsZW1lbnRzLmxlbmd0aCA9PT0gUVVFVUVfTUFYX0FSUkFZX1NJWkUpO1xuICAgICAgYXNzZXJ0KG9sZEZyb250Ll9uZXh0ICE9PSB1bmRlZmluZWQpO1xuICAgICAgbmV3RnJvbnQgPSBvbGRGcm9udC5fbmV4dCE7XG4gICAgICBuZXdDdXJzb3IgPSAwO1xuICAgIH1cblxuICAgIC8vIE5vIG11dGF0aW9ucyBiZWZvcmUgdGhpcyBwb2ludC5cbiAgICAtLXRoaXMuX3NpemU7XG4gICAgdGhpcy5fY3Vyc29yID0gbmV3Q3Vyc29yO1xuICAgIGlmIChvbGRGcm9udCAhPT0gbmV3RnJvbnQpIHtcbiAgICAgIHRoaXMuX2Zyb250ID0gbmV3RnJvbnQ7XG4gICAgfVxuXG4gICAgLy8gUGVybWl0IHNoaWZ0ZWQgZWxlbWVudCB0byBiZSBnYXJiYWdlIGNvbGxlY3RlZC5cbiAgICBlbGVtZW50c1tvbGRDdXJzb3JdID0gdW5kZWZpbmVkITtcblxuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG5cbiAgLy8gVGhlIHRyaWNreSB0aGluZyBhYm91dCBmb3JFYWNoKCkgaXMgdGhhdCBpdCBjYW4gYmUgY2FsbGVkXG4gIC8vIHJlLWVudHJhbnRseS4gVGhlIHF1ZXVlIG1heSBiZSBtdXRhdGVkIGluc2lkZSB0aGUgY2FsbGJhY2suIEl0IGlzIGVhc3kgdG9cbiAgLy8gc2VlIHRoYXQgcHVzaCgpIHdpdGhpbiB0aGUgY2FsbGJhY2sgaGFzIG5vIG5lZ2F0aXZlIGVmZmVjdHMgc2luY2UgdGhlIGVuZFxuICAvLyBvZiB0aGUgcXVldWUgaXMgY2hlY2tlZCBmb3Igb24gZXZlcnkgaXRlcmF0aW9uLiBJZiBzaGlmdCgpIGlzIGNhbGxlZFxuICAvLyByZXBlYXRlZGx5IHdpdGhpbiB0aGUgY2FsbGJhY2sgdGhlbiB0aGUgbmV4dCBpdGVyYXRpb24gbWF5IHJldHVybiBhblxuICAvLyBlbGVtZW50IHRoYXQgaGFzIGJlZW4gcmVtb3ZlZC4gSW4gdGhpcyBjYXNlIHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZFxuICAvLyB3aXRoIHVuZGVmaW5lZCB2YWx1ZXMgdW50aWwgd2UgZWl0aGVyIFwiY2F0Y2ggdXBcIiB3aXRoIGVsZW1lbnRzIHRoYXQgc3RpbGxcbiAgLy8gZXhpc3Qgb3IgcmVhY2ggdGhlIGJhY2sgb2YgdGhlIHF1ZXVlLlxuICBmb3JFYWNoKGNhbGxiYWNrOiAoZWxlbWVudDogVCkgPT4gdm9pZCk6IHZvaWQge1xuICAgIGxldCBpID0gdGhpcy5fY3Vyc29yO1xuICAgIGxldCBub2RlID0gdGhpcy5fZnJvbnQ7XG4gICAgbGV0IGVsZW1lbnRzID0gbm9kZS5fZWxlbWVudHM7XG4gICAgd2hpbGUgKGkgIT09IGVsZW1lbnRzLmxlbmd0aCB8fCBub2RlLl9uZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChpID09PSBlbGVtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgYXNzZXJ0KG5vZGUuX25leHQgIT09IHVuZGVmaW5lZCk7XG4gICAgICAgIGFzc2VydChpID09PSBRVUVVRV9NQVhfQVJSQVlfU0laRSk7XG4gICAgICAgIG5vZGUgPSBub2RlLl9uZXh0ITtcbiAgICAgICAgZWxlbWVudHMgPSBub2RlLl9lbGVtZW50cztcbiAgICAgICAgaSA9IDA7XG4gICAgICAgIGlmIChlbGVtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2FsbGJhY2soZWxlbWVudHNbaV0pO1xuICAgICAgKytpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJldHVybiB0aGUgZWxlbWVudCB0aGF0IHdvdWxkIGJlIHJldHVybmVkIGlmIHNoaWZ0KCkgd2FzIGNhbGxlZCBub3csXG4gIC8vIHdpdGhvdXQgbW9kaWZ5aW5nIHRoZSBxdWV1ZS5cbiAgcGVlaygpOiBUIHtcbiAgICBhc3NlcnQodGhpcy5fc2l6ZSA+IDApOyAvLyBtdXN0IG5vdCBiZSBjYWxsZWQgb24gYW4gZW1wdHkgcXVldWVcblxuICAgIGNvbnN0IGZyb250ID0gdGhpcy5fZnJvbnQ7XG4gICAgY29uc3QgY3Vyc29yID0gdGhpcy5fY3Vyc29yO1xuICAgIHJldHVybiBmcm9udC5fZWxlbWVudHNbY3Vyc29yXTtcbiAgfVxufVxuIiwgImltcG9ydCBhc3NlcnQgZnJvbSAnLi4vLi4vc3R1Yi9hc3NlcnQnO1xuaW1wb3J0IHsgUmVhZGFibGVTdHJlYW0sIFJlYWRhYmxlU3RyZWFtQ2FuY2VsLCBSZWFkYWJsZVN0cmVhbVJlYWRlciB9IGZyb20gJy4uL3JlYWRhYmxlLXN0cmVhbSc7XG5pbXBvcnQgeyBuZXdQcm9taXNlLCBzZXRQcm9taXNlSXNIYW5kbGVkVG9UcnVlIH0gZnJvbSAnLi4vaGVscGVycy93ZWJpZGwnO1xuXG5leHBvcnQgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljSW5pdGlhbGl6ZTxSPihyZWFkZXI6IFJlYWRhYmxlU3RyZWFtUmVhZGVyPFI+LCBzdHJlYW06IFJlYWRhYmxlU3RyZWFtPFI+KSB7XG4gIHJlYWRlci5fb3duZXJSZWFkYWJsZVN0cmVhbSA9IHN0cmVhbTtcbiAgc3RyZWFtLl9yZWFkZXIgPSByZWFkZXI7XG5cbiAgaWYgKHN0cmVhbS5fc3RhdGUgPT09ICdyZWFkYWJsZScpIHtcbiAgICBkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemUocmVhZGVyKTtcbiAgfSBlbHNlIGlmIChzdHJlYW0uX3N0YXRlID09PSAnY2xvc2VkJykge1xuICAgIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZUFzUmVzb2x2ZWQocmVhZGVyKTtcbiAgfSBlbHNlIHtcbiAgICBhc3NlcnQoc3RyZWFtLl9zdGF0ZSA9PT0gJ2Vycm9yZWQnKTtcblxuICAgIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZUFzUmVqZWN0ZWQocmVhZGVyLCBzdHJlYW0uX3N0b3JlZEVycm9yKTtcbiAgfVxufVxuXG4vLyBBIGNsaWVudCBvZiBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIgYW5kIFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlciBtYXkgdXNlIHRoZXNlIGZ1bmN0aW9ucyBkaXJlY3RseSB0byBieXBhc3Mgc3RhdGVcbi8vIGNoZWNrLlxuXG5leHBvcnQgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljQ2FuY2VsKHJlYWRlcjogUmVhZGFibGVTdHJlYW1SZWFkZXI8YW55PiwgcmVhc29uOiBhbnkpOiBQcm9taXNlPHVuZGVmaW5lZD4ge1xuICBjb25zdCBzdHJlYW0gPSByZWFkZXIuX293bmVyUmVhZGFibGVTdHJlYW07XG4gIGFzc2VydChzdHJlYW0gIT09IHVuZGVmaW5lZCk7XG4gIHJldHVybiBSZWFkYWJsZVN0cmVhbUNhbmNlbChzdHJlYW0sIHJlYXNvbik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNSZWxlYXNlKHJlYWRlcjogUmVhZGFibGVTdHJlYW1SZWFkZXI8YW55Pikge1xuICBhc3NlcnQocmVhZGVyLl9vd25lclJlYWRhYmxlU3RyZWFtICE9PSB1bmRlZmluZWQpO1xuICBhc3NlcnQocmVhZGVyLl9vd25lclJlYWRhYmxlU3RyZWFtLl9yZWFkZXIgPT09IHJlYWRlcik7XG5cbiAgaWYgKHJlYWRlci5fb3duZXJSZWFkYWJsZVN0cmVhbS5fc3RhdGUgPT09ICdyZWFkYWJsZScpIHtcbiAgICBkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZVJlamVjdChcbiAgICAgIHJlYWRlcixcbiAgICAgIG5ldyBUeXBlRXJyb3IoYFJlYWRlciB3YXMgcmVsZWFzZWQgYW5kIGNhbiBubyBsb25nZXIgYmUgdXNlZCB0byBtb25pdG9yIHRoZSBzdHJlYW0ncyBjbG9zZWRuZXNzYCkpO1xuICB9IGVsc2Uge1xuICAgIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlUmVzZXRUb1JlamVjdGVkKFxuICAgICAgcmVhZGVyLFxuICAgICAgbmV3IFR5cGVFcnJvcihgUmVhZGVyIHdhcyByZWxlYXNlZCBhbmQgY2FuIG5vIGxvbmdlciBiZSB1c2VkIHRvIG1vbml0b3IgdGhlIHN0cmVhbSdzIGNsb3NlZG5lc3NgKSk7XG4gIH1cblxuICByZWFkZXIuX293bmVyUmVhZGFibGVTdHJlYW0uX3JlYWRlciA9IHVuZGVmaW5lZDtcbiAgcmVhZGVyLl9vd25lclJlYWRhYmxlU3RyZWFtID0gdW5kZWZpbmVkITtcbn1cblxuLy8gSGVscGVyIGZ1bmN0aW9ucyBmb3IgdGhlIHJlYWRlcnMuXG5cbmV4cG9ydCBmdW5jdGlvbiByZWFkZXJMb2NrRXhjZXB0aW9uKG5hbWU6IHN0cmluZyk6IFR5cGVFcnJvciB7XG4gIHJldHVybiBuZXcgVHlwZUVycm9yKCdDYW5ub3QgJyArIG5hbWUgKyAnIGEgc3RyZWFtIHVzaW5nIGEgcmVsZWFzZWQgcmVhZGVyJyk7XG59XG5cbi8vIEhlbHBlciBmdW5jdGlvbnMgZm9yIHRoZSBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIuXG5cbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemUocmVhZGVyOiBSZWFkYWJsZVN0cmVhbVJlYWRlcjxhbnk+KSB7XG4gIHJlYWRlci5fY2xvc2VkUHJvbWlzZSA9IG5ld1Byb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHJlYWRlci5fY2xvc2VkUHJvbWlzZV9yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICByZWFkZXIuX2Nsb3NlZFByb21pc2VfcmVqZWN0ID0gcmVqZWN0O1xuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZUFzUmVqZWN0ZWQocmVhZGVyOiBSZWFkYWJsZVN0cmVhbVJlYWRlcjxhbnk+LCByZWFzb246IGFueSkge1xuICBkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemUocmVhZGVyKTtcbiAgZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VSZWplY3QocmVhZGVyLCByZWFzb24pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VJbml0aWFsaXplQXNSZXNvbHZlZChyZWFkZXI6IFJlYWRhYmxlU3RyZWFtUmVhZGVyPGFueT4pIHtcbiAgZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VJbml0aWFsaXplKHJlYWRlcik7XG4gIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlUmVzb2x2ZShyZWFkZXIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VSZWplY3QocmVhZGVyOiBSZWFkYWJsZVN0cmVhbVJlYWRlcjxhbnk+LCByZWFzb246IGFueSkge1xuICBpZiAocmVhZGVyLl9jbG9zZWRQcm9taXNlX3JlamVjdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc2V0UHJvbWlzZUlzSGFuZGxlZFRvVHJ1ZShyZWFkZXIuX2Nsb3NlZFByb21pc2UpO1xuICByZWFkZXIuX2Nsb3NlZFByb21pc2VfcmVqZWN0KHJlYXNvbik7XG4gIHJlYWRlci5fY2xvc2VkUHJvbWlzZV9yZXNvbHZlID0gdW5kZWZpbmVkO1xuICByZWFkZXIuX2Nsb3NlZFByb21pc2VfcmVqZWN0ID0gdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VSZXNldFRvUmVqZWN0ZWQocmVhZGVyOiBSZWFkYWJsZVN0cmVhbVJlYWRlcjxhbnk+LCByZWFzb246IGFueSkge1xuICBhc3NlcnQocmVhZGVyLl9jbG9zZWRQcm9taXNlX3Jlc29sdmUgPT09IHVuZGVmaW5lZCk7XG4gIGFzc2VydChyZWFkZXIuX2Nsb3NlZFByb21pc2VfcmVqZWN0ID09PSB1bmRlZmluZWQpO1xuXG4gIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZUFzUmVqZWN0ZWQocmVhZGVyLCByZWFzb24pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VSZXNvbHZlKHJlYWRlcjogUmVhZGFibGVTdHJlYW1SZWFkZXI8YW55Pikge1xuICBpZiAocmVhZGVyLl9jbG9zZWRQcm9taXNlX3Jlc29sdmUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHJlYWRlci5fY2xvc2VkUHJvbWlzZV9yZXNvbHZlKHVuZGVmaW5lZCk7XG4gIHJlYWRlci5fY2xvc2VkUHJvbWlzZV9yZXNvbHZlID0gdW5kZWZpbmVkO1xuICByZWFkZXIuX2Nsb3NlZFByb21pc2VfcmVqZWN0ID0gdW5kZWZpbmVkO1xufVxuIiwgImV4cG9ydCBjb25zdCBBYm9ydFN0ZXBzID0gU3ltYm9sKCdbW0Fib3J0U3RlcHNdXScpO1xuZXhwb3J0IGNvbnN0IEVycm9yU3RlcHMgPSBTeW1ib2woJ1tbRXJyb3JTdGVwc11dJyk7XG5leHBvcnQgY29uc3QgQ2FuY2VsU3RlcHMgPSBTeW1ib2woJ1tbQ2FuY2VsU3RlcHNdXScpO1xuZXhwb3J0IGNvbnN0IFB1bGxTdGVwcyA9IFN5bWJvbCgnW1tQdWxsU3RlcHNdXScpO1xuIiwgIi8vLyA8cmVmZXJlbmNlIGxpYj1cImVzMjAxNS5jb3JlXCIgLz5cblxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTnVtYmVyL2lzRmluaXRlI1BvbHlmaWxsXG5jb25zdCBOdW1iZXJJc0Zpbml0ZTogdHlwZW9mIE51bWJlci5pc0Zpbml0ZSA9IE51bWJlci5pc0Zpbml0ZSB8fCBmdW5jdGlvbiAoeCkge1xuICByZXR1cm4gdHlwZW9mIHggPT09ICdudW1iZXInICYmIGlzRmluaXRlKHgpO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgTnVtYmVySXNGaW5pdGU7XG4iLCAiLy8vIDxyZWZlcmVuY2UgbGliPVwiZXMyMDE1LmNvcmVcIiAvPlxuXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL3RydW5jI1BvbHlmaWxsXG5jb25zdCBNYXRoVHJ1bmM6IHR5cGVvZiBNYXRoLnRydW5jID0gTWF0aC50cnVuYyB8fCBmdW5jdGlvbiAodikge1xuICByZXR1cm4gdiA8IDAgPyBNYXRoLmNlaWwodikgOiBNYXRoLmZsb29yKHYpO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgTWF0aFRydW5jO1xuIiwgImltcG9ydCBOdW1iZXJJc0Zpbml0ZSBmcm9tICcuLi8uLi9zdHViL251bWJlci1pc2Zpbml0ZSc7XG5pbXBvcnQgTWF0aFRydW5jIGZyb20gJy4uLy4uL3N0dWIvbWF0aC10cnVuYyc7XG5cbi8vIGh0dHBzOi8vaGV5Y2FtLmdpdGh1Yi5pby93ZWJpZGwvI2lkbC1kaWN0aW9uYXJpZXNcbmV4cG9ydCBmdW5jdGlvbiBpc0RpY3Rpb25hcnkoeDogYW55KTogeCBpcyBvYmplY3QgfCBudWxsIHtcbiAgcmV0dXJuIHR5cGVvZiB4ID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydERpY3Rpb25hcnkob2JqOiB1bmtub3duLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dDogc3RyaW5nKTogYXNzZXJ0cyBvYmogaXMgb2JqZWN0IHwgbnVsbCB8IHVuZGVmaW5lZCB7XG4gIGlmIChvYmogIT09IHVuZGVmaW5lZCAmJiAhaXNEaWN0aW9uYXJ5KG9iaikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke2NvbnRleHR9IGlzIG5vdCBhbiBvYmplY3QuYCk7XG4gIH1cbn1cblxuZXhwb3J0IHR5cGUgQW55RnVuY3Rpb24gPSAoLi4uYXJnczogYW55W10pID0+IGFueTtcblxuLy8gaHR0cHM6Ly9oZXljYW0uZ2l0aHViLmlvL3dlYmlkbC8jaWRsLWNhbGxiYWNrLWZ1bmN0aW9uc1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydEZ1bmN0aW9uKHg6IHVua25vd24sIGNvbnRleHQ6IHN0cmluZyk6IGFzc2VydHMgeCBpcyBBbnlGdW5jdGlvbiB7XG4gIGlmICh0eXBlb2YgeCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7Y29udGV4dH0gaXMgbm90IGEgZnVuY3Rpb24uYCk7XG4gIH1cbn1cblxuLy8gaHR0cHM6Ly9oZXljYW0uZ2l0aHViLmlvL3dlYmlkbC8jaWRsLW9iamVjdFxuZXhwb3J0IGZ1bmN0aW9uIGlzT2JqZWN0KHg6IGFueSk6IHggaXMgb2JqZWN0IHtcbiAgcmV0dXJuICh0eXBlb2YgeCA9PT0gJ29iamVjdCcgJiYgeCAhPT0gbnVsbCkgfHwgdHlwZW9mIHggPT09ICdmdW5jdGlvbic7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRPYmplY3QoeDogdW5rbm93bixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dDogc3RyaW5nKTogYXNzZXJ0cyB4IGlzIG9iamVjdCB7XG4gIGlmICghaXNPYmplY3QoeCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke2NvbnRleHR9IGlzIG5vdCBhbiBvYmplY3QuYCk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydFJlcXVpcmVkQXJndW1lbnQ8VCBleHRlbmRzIGFueT4oeDogVCB8IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBudW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiBzdHJpbmcpOiBhc3NlcnRzIHggaXMgVCB7XG4gIGlmICh4ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBQYXJhbWV0ZXIgJHtwb3NpdGlvbn0gaXMgcmVxdWlyZWQgaW4gJyR7Y29udGV4dH0nLmApO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRSZXF1aXJlZEZpZWxkPFQgZXh0ZW5kcyBhbnk+KHg6IFQgfCB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWVsZDogc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dDogc3RyaW5nKTogYXNzZXJ0cyB4IGlzIFQge1xuICBpZiAoeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtmaWVsZH0gaXMgcmVxdWlyZWQgaW4gJyR7Y29udGV4dH0nLmApO1xuICB9XG59XG5cbi8vIGh0dHBzOi8vaGV5Y2FtLmdpdGh1Yi5pby93ZWJpZGwvI2lkbC11bnJlc3RyaWN0ZWQtZG91YmxlXG5leHBvcnQgZnVuY3Rpb24gY29udmVydFVucmVzdHJpY3RlZERvdWJsZSh2YWx1ZTogdW5rbm93bik6IG51bWJlciB7XG4gIHJldHVybiBOdW1iZXIodmFsdWUpO1xufVxuXG5mdW5jdGlvbiBjZW5zb3JOZWdhdGl2ZVplcm8oeDogbnVtYmVyKTogbnVtYmVyIHtcbiAgcmV0dXJuIHggPT09IDAgPyAwIDogeDtcbn1cblxuZnVuY3Rpb24gaW50ZWdlclBhcnQoeDogbnVtYmVyKTogbnVtYmVyIHtcbiAgcmV0dXJuIGNlbnNvck5lZ2F0aXZlWmVybyhNYXRoVHJ1bmMoeCkpO1xufVxuXG4vLyBodHRwczovL2hleWNhbS5naXRodWIuaW8vd2ViaWRsLyNpZGwtdW5zaWduZWQtbG9uZy1sb25nXG5leHBvcnQgZnVuY3Rpb24gY29udmVydFVuc2lnbmVkTG9uZ0xvbmdXaXRoRW5mb3JjZVJhbmdlKHZhbHVlOiB1bmtub3duLCBjb250ZXh0OiBzdHJpbmcpOiBudW1iZXIge1xuICBjb25zdCBsb3dlckJvdW5kID0gMDtcbiAgY29uc3QgdXBwZXJCb3VuZCA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuXG4gIGxldCB4ID0gTnVtYmVyKHZhbHVlKTtcbiAgeCA9IGNlbnNvck5lZ2F0aXZlWmVybyh4KTtcblxuICBpZiAoIU51bWJlcklzRmluaXRlKHgpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtjb250ZXh0fSBpcyBub3QgYSBmaW5pdGUgbnVtYmVyYCk7XG4gIH1cblxuICB4ID0gaW50ZWdlclBhcnQoeCk7XG5cbiAgaWYgKHggPCBsb3dlckJvdW5kIHx8IHggPiB1cHBlckJvdW5kKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtjb250ZXh0fSBpcyBvdXRzaWRlIHRoZSBhY2NlcHRlZCByYW5nZSBvZiAke2xvd2VyQm91bmR9IHRvICR7dXBwZXJCb3VuZH0sIGluY2x1c2l2ZWApO1xuICB9XG5cbiAgaWYgKCFOdW1iZXJJc0Zpbml0ZSh4KSB8fCB4ID09PSAwKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICAvLyBUT0RPIFVzZSBCaWdJbnQgaWYgc3VwcG9ydGVkP1xuICAvLyBsZXQgeEJpZ0ludCA9IEJpZ0ludChpbnRlZ2VyUGFydCh4KSk7XG4gIC8vIHhCaWdJbnQgPSBCaWdJbnQuYXNVaW50Tig2NCwgeEJpZ0ludCk7XG4gIC8vIHJldHVybiBOdW1iZXIoeEJpZ0ludCk7XG5cbiAgcmV0dXJuIHg7XG59XG4iLCAiaW1wb3J0IHsgSXNSZWFkYWJsZVN0cmVhbSwgUmVhZGFibGVTdHJlYW0gfSBmcm9tICcuLi9yZWFkYWJsZS1zdHJlYW0nO1xuXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0UmVhZGFibGVTdHJlYW0oeDogdW5rbm93biwgY29udGV4dDogc3RyaW5nKTogYXNzZXJ0cyB4IGlzIFJlYWRhYmxlU3RyZWFtIHtcbiAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtKHgpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtjb250ZXh0fSBpcyBub3QgYSBSZWFkYWJsZVN0cmVhbS5gKTtcbiAgfVxufVxuIiwgImltcG9ydCBhc3NlcnQgZnJvbSAnLi4vLi4vc3R1Yi9hc3NlcnQnO1xuaW1wb3J0IHsgU2ltcGxlUXVldWUgfSBmcm9tICcuLi9zaW1wbGUtcXVldWUnO1xuaW1wb3J0IHtcbiAgUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljQ2FuY2VsLFxuICBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNJbml0aWFsaXplLFxuICBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNSZWxlYXNlLFxuICByZWFkZXJMb2NrRXhjZXB0aW9uXG59IGZyb20gJy4vZ2VuZXJpYy1yZWFkZXInO1xuaW1wb3J0IHsgSXNSZWFkYWJsZVN0cmVhbUxvY2tlZCwgUmVhZGFibGVTdHJlYW0gfSBmcm9tICcuLi9yZWFkYWJsZS1zdHJlYW0nO1xuaW1wb3J0IHsgdHlwZUlzT2JqZWN0IH0gZnJvbSAnLi4vaGVscGVycy9taXNjZWxsYW5lb3VzJztcbmltcG9ydCB7IFB1bGxTdGVwcyB9IGZyb20gJy4uL2Fic3RyYWN0LW9wcy9pbnRlcm5hbC1tZXRob2RzJztcbmltcG9ydCB7IG5ld1Byb21pc2UsIHByb21pc2VSZWplY3RlZFdpdGggfSBmcm9tICcuLi9oZWxwZXJzL3dlYmlkbCc7XG5pbXBvcnQgeyBhc3NlcnRSZXF1aXJlZEFyZ3VtZW50IH0gZnJvbSAnLi4vdmFsaWRhdG9ycy9iYXNpYyc7XG5pbXBvcnQgeyBhc3NlcnRSZWFkYWJsZVN0cmVhbSB9IGZyb20gJy4uL3ZhbGlkYXRvcnMvcmVhZGFibGUtc3RyZWFtJztcblxuLyoqXG4gKiBBIHJlc3VsdCByZXR1cm5lZCBieSB7QGxpbmsgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyLnJlYWR9LlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IHR5cGUgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZFJlc3VsdDxUPiA9IHtcbiAgZG9uZTogZmFsc2U7XG4gIHZhbHVlOiBUO1xufSB8IHtcbiAgZG9uZTogdHJ1ZTtcbiAgdmFsdWU/OiB1bmRlZmluZWQ7XG59XG5cbi8vIEFic3RyYWN0IG9wZXJhdGlvbnMgZm9yIHRoZSBSZWFkYWJsZVN0cmVhbS5cblxuZXhwb3J0IGZ1bmN0aW9uIEFjcXVpcmVSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXI8Uj4oc3RyZWFtOiBSZWFkYWJsZVN0cmVhbSk6IFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcjxSPiB7XG4gIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyKHN0cmVhbSk7XG59XG5cbi8vIFJlYWRhYmxlU3RyZWFtIEFQSSBleHBvc2VkIGZvciBjb250cm9sbGVycy5cblxuZXhwb3J0IGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtQWRkUmVhZFJlcXVlc3Q8Uj4oc3RyZWFtOiBSZWFkYWJsZVN0cmVhbTxSPixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRSZXF1ZXN0OiBSZWFkUmVxdWVzdDxSPik6IHZvaWQge1xuICBhc3NlcnQoSXNSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIoc3RyZWFtLl9yZWFkZXIpKTtcbiAgYXNzZXJ0KHN0cmVhbS5fc3RhdGUgPT09ICdyZWFkYWJsZScpO1xuXG4gIChzdHJlYW0uX3JlYWRlciEgYXMgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyPFI+KS5fcmVhZFJlcXVlc3RzLnB1c2gocmVhZFJlcXVlc3QpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1GdWxmaWxsUmVhZFJlcXVlc3Q8Uj4oc3RyZWFtOiBSZWFkYWJsZVN0cmVhbTxSPiwgY2h1bms6IFIgfCB1bmRlZmluZWQsIGRvbmU6IGJvb2xlYW4pIHtcbiAgY29uc3QgcmVhZGVyID0gc3RyZWFtLl9yZWFkZXIgYXMgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyPFI+O1xuXG4gIGFzc2VydChyZWFkZXIuX3JlYWRSZXF1ZXN0cy5sZW5ndGggPiAwKTtcblxuICBjb25zdCByZWFkUmVxdWVzdCA9IHJlYWRlci5fcmVhZFJlcXVlc3RzLnNoaWZ0KCkhO1xuICBpZiAoZG9uZSkge1xuICAgIHJlYWRSZXF1ZXN0Ll9jbG9zZVN0ZXBzKCk7XG4gIH0gZWxzZSB7XG4gICAgcmVhZFJlcXVlc3QuX2NodW5rU3RlcHMoY2h1bmshKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1HZXROdW1SZWFkUmVxdWVzdHM8Uj4oc3RyZWFtOiBSZWFkYWJsZVN0cmVhbTxSPik6IG51bWJlciB7XG4gIHJldHVybiAoc3RyZWFtLl9yZWFkZXIgYXMgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyPFI+KS5fcmVhZFJlcXVlc3RzLmxlbmd0aDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtSGFzRGVmYXVsdFJlYWRlcihzdHJlYW06IFJlYWRhYmxlU3RyZWFtKTogYm9vbGVhbiB7XG4gIGNvbnN0IHJlYWRlciA9IHN0cmVhbS5fcmVhZGVyO1xuXG4gIGlmIChyZWFkZXIgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICghSXNSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIocmVhZGVyKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG4vLyBSZWFkZXJzXG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVhZFJlcXVlc3Q8Uj4ge1xuICBfY2h1bmtTdGVwcyhjaHVuazogUik6IHZvaWQ7XG5cbiAgX2Nsb3NlU3RlcHMoKTogdm9pZDtcblxuICBfZXJyb3JTdGVwcyhlOiBhbnkpOiB2b2lkO1xufVxuXG4vKipcbiAqIEEgZGVmYXVsdCByZWFkZXIgdmVuZGVkIGJ5IGEge0BsaW5rIFJlYWRhYmxlU3RyZWFtfS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXI8UiA9IGFueT4ge1xuICAvKiogQGludGVybmFsICovXG4gIF9vd25lclJlYWRhYmxlU3RyZWFtITogUmVhZGFibGVTdHJlYW08Uj47XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2Nsb3NlZFByb21pc2UhOiBQcm9taXNlPHVuZGVmaW5lZD47XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2Nsb3NlZFByb21pc2VfcmVzb2x2ZT86ICh2YWx1ZT86IHVuZGVmaW5lZCkgPT4gdm9pZDtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfY2xvc2VkUHJvbWlzZV9yZWplY3Q/OiAocmVhc29uOiBhbnkpID0+IHZvaWQ7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3JlYWRSZXF1ZXN0czogU2ltcGxlUXVldWU8UmVhZFJlcXVlc3Q8Uj4+O1xuXG4gIGNvbnN0cnVjdG9yKHN0cmVhbTogUmVhZGFibGVTdHJlYW08Uj4pIHtcbiAgICBhc3NlcnRSZXF1aXJlZEFyZ3VtZW50KHN0cmVhbSwgMSwgJ1JlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcicpO1xuICAgIGFzc2VydFJlYWRhYmxlU3RyZWFtKHN0cmVhbSwgJ0ZpcnN0IHBhcmFtZXRlcicpO1xuXG4gICAgaWYgKElzUmVhZGFibGVTdHJlYW1Mb2NrZWQoc3RyZWFtKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhpcyBzdHJlYW0gaGFzIGFscmVhZHkgYmVlbiBsb2NrZWQgZm9yIGV4Y2x1c2l2ZSByZWFkaW5nIGJ5IGFub3RoZXIgcmVhZGVyJyk7XG4gICAgfVxuXG4gICAgUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljSW5pdGlhbGl6ZSh0aGlzLCBzdHJlYW0pO1xuXG4gICAgdGhpcy5fcmVhZFJlcXVlc3RzID0gbmV3IFNpbXBsZVF1ZXVlKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHByb21pc2UgdGhhdCB3aWxsIGJlIGZ1bGZpbGxlZCB3aGVuIHRoZSBzdHJlYW0gYmVjb21lcyBjbG9zZWQsXG4gICAqIG9yIHJlamVjdGVkIGlmIHRoZSBzdHJlYW0gZXZlciBlcnJvcnMgb3IgdGhlIHJlYWRlcidzIGxvY2sgaXMgcmVsZWFzZWQgYmVmb3JlIHRoZSBzdHJlYW0gZmluaXNoZXMgY2xvc2luZy5cbiAgICovXG4gIGdldCBjbG9zZWQoKTogUHJvbWlzZTx1bmRlZmluZWQ+IHtcbiAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyKHRoaXMpKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChkZWZhdWx0UmVhZGVyQnJhbmRDaGVja0V4Y2VwdGlvbignY2xvc2VkJykpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9jbG9zZWRQcm9taXNlO1xuICB9XG5cbiAgLyoqXG4gICAqIElmIHRoZSByZWFkZXIgaXMgYWN0aXZlLCBiZWhhdmVzIHRoZSBzYW1lIGFzIHtAbGluayBSZWFkYWJsZVN0cmVhbS5jYW5jZWwgfCBzdHJlYW0uY2FuY2VsKHJlYXNvbil9LlxuICAgKi9cbiAgY2FuY2VsKHJlYXNvbjogYW55ID0gdW5kZWZpbmVkKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcih0aGlzKSkge1xuICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoZGVmYXVsdFJlYWRlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ2NhbmNlbCcpKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fb3duZXJSZWFkYWJsZVN0cmVhbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChyZWFkZXJMb2NrRXhjZXB0aW9uKCdjYW5jZWwnKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY0NhbmNlbCh0aGlzLCByZWFzb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBwcm9taXNlIHRoYXQgYWxsb3dzIGFjY2VzcyB0byB0aGUgbmV4dCBjaHVuayBmcm9tIHRoZSBzdHJlYW0ncyBpbnRlcm5hbCBxdWV1ZSwgaWYgYXZhaWxhYmxlLlxuICAgKlxuICAgKiBJZiByZWFkaW5nIGEgY2h1bmsgY2F1c2VzIHRoZSBxdWV1ZSB0byBiZWNvbWUgZW1wdHksIG1vcmUgZGF0YSB3aWxsIGJlIHB1bGxlZCBmcm9tIHRoZSB1bmRlcmx5aW5nIHNvdXJjZS5cbiAgICovXG4gIHJlYWQoKTogUHJvbWlzZTxSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkUmVzdWx0PFI+PiB7XG4gICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcih0aGlzKSkge1xuICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoZGVmYXVsdFJlYWRlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ3JlYWQnKSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX293bmVyUmVhZGFibGVTdHJlYW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgocmVhZGVyTG9ja0V4Y2VwdGlvbigncmVhZCBmcm9tJykpO1xuICAgIH1cblxuICAgIGxldCByZXNvbHZlUHJvbWlzZSE6IChyZXN1bHQ6IFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRSZXN1bHQ8Uj4pID0+IHZvaWQ7XG4gICAgbGV0IHJlamVjdFByb21pc2UhOiAocmVhc29uOiBhbnkpID0+IHZvaWQ7XG4gICAgY29uc3QgcHJvbWlzZSA9IG5ld1Byb21pc2U8UmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZFJlc3VsdDxSPj4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgcmVzb2x2ZVByb21pc2UgPSByZXNvbHZlO1xuICAgICAgcmVqZWN0UHJvbWlzZSA9IHJlamVjdDtcbiAgICB9KTtcbiAgICBjb25zdCByZWFkUmVxdWVzdDogUmVhZFJlcXVlc3Q8Uj4gPSB7XG4gICAgICBfY2h1bmtTdGVwczogY2h1bmsgPT4gcmVzb2x2ZVByb21pc2UoeyB2YWx1ZTogY2h1bmssIGRvbmU6IGZhbHNlIH0pLFxuICAgICAgX2Nsb3NlU3RlcHM6ICgpID0+IHJlc29sdmVQcm9taXNlKHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9KSxcbiAgICAgIF9lcnJvclN0ZXBzOiBlID0+IHJlamVjdFByb21pc2UoZSlcbiAgICB9O1xuICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlclJlYWQodGhpcywgcmVhZFJlcXVlc3QpO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbGVhc2VzIHRoZSByZWFkZXIncyBsb2NrIG9uIHRoZSBjb3JyZXNwb25kaW5nIHN0cmVhbS4gQWZ0ZXIgdGhlIGxvY2sgaXMgcmVsZWFzZWQsIHRoZSByZWFkZXIgaXMgbm8gbG9uZ2VyIGFjdGl2ZS5cbiAgICogSWYgdGhlIGFzc29jaWF0ZWQgc3RyZWFtIGlzIGVycm9yZWQgd2hlbiB0aGUgbG9jayBpcyByZWxlYXNlZCwgdGhlIHJlYWRlciB3aWxsIGFwcGVhciBlcnJvcmVkIGluIHRoZSBzYW1lIHdheVxuICAgKiBmcm9tIG5vdyBvbjsgb3RoZXJ3aXNlLCB0aGUgcmVhZGVyIHdpbGwgYXBwZWFyIGNsb3NlZC5cbiAgICpcbiAgICogQSByZWFkZXIncyBsb2NrIGNhbm5vdCBiZSByZWxlYXNlZCB3aGlsZSBpdCBzdGlsbCBoYXMgYSBwZW5kaW5nIHJlYWQgcmVxdWVzdCwgaS5lLiwgaWYgYSBwcm9taXNlIHJldHVybmVkIGJ5XG4gICAqIHRoZSByZWFkZXIncyB7QGxpbmsgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyLnJlYWQgfCByZWFkKCl9IG1ldGhvZCBoYXMgbm90IHlldCBiZWVuIHNldHRsZWQuIEF0dGVtcHRpbmcgdG9cbiAgICogZG8gc28gd2lsbCB0aHJvdyBhIGBUeXBlRXJyb3JgIGFuZCBsZWF2ZSB0aGUgcmVhZGVyIGxvY2tlZCB0byB0aGUgc3RyZWFtLlxuICAgKi9cbiAgcmVsZWFzZUxvY2soKTogdm9pZCB7XG4gICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcih0aGlzKSkge1xuICAgICAgdGhyb3cgZGVmYXVsdFJlYWRlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ3JlbGVhc2VMb2NrJyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX293bmVyUmVhZGFibGVTdHJlYW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9yZWFkUmVxdWVzdHMubGVuZ3RoID4gMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVHJpZWQgdG8gcmVsZWFzZSBhIHJlYWRlciBsb2NrIHdoZW4gdGhhdCByZWFkZXIgaGFzIHBlbmRpbmcgcmVhZCgpIGNhbGxzIHVuLXNldHRsZWQnKTtcbiAgICB9XG5cbiAgICBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNSZWxlYXNlKHRoaXMpO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlci5wcm90b3R5cGUsIHtcbiAgY2FuY2VsOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgcmVhZDogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gIHJlbGVhc2VMb2NrOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgY2xvc2VkOiB7IGVudW1lcmFibGU6IHRydWUgfVxufSk7XG5pZiAodHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlci5wcm90b3R5cGUsIFN5bWJvbC50b1N0cmluZ1RhZywge1xuICAgIHZhbHVlOiAnUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyJyxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbi8vIEFic3RyYWN0IG9wZXJhdGlvbnMgZm9yIHRoZSByZWFkZXJzLlxuXG5leHBvcnQgZnVuY3Rpb24gSXNSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXI8UiA9IGFueT4oeDogYW55KTogeCBpcyBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXI8Uj4ge1xuICBpZiAoIXR5cGVJc09iamVjdCh4KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdfcmVhZFJlcXVlc3RzJykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4geCBpbnN0YW5jZW9mIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlclJlYWQ8Uj4ocmVhZGVyOiBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXI8Uj4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkUmVxdWVzdDogUmVhZFJlcXVlc3Q8Uj4pOiB2b2lkIHtcbiAgY29uc3Qgc3RyZWFtID0gcmVhZGVyLl9vd25lclJlYWRhYmxlU3RyZWFtO1xuXG4gIGFzc2VydChzdHJlYW0gIT09IHVuZGVmaW5lZCk7XG5cbiAgc3RyZWFtLl9kaXN0dXJiZWQgPSB0cnVlO1xuXG4gIGlmIChzdHJlYW0uX3N0YXRlID09PSAnY2xvc2VkJykge1xuICAgIHJlYWRSZXF1ZXN0Ll9jbG9zZVN0ZXBzKCk7XG4gIH0gZWxzZSBpZiAoc3RyZWFtLl9zdGF0ZSA9PT0gJ2Vycm9yZWQnKSB7XG4gICAgcmVhZFJlcXVlc3QuX2Vycm9yU3RlcHMoc3RyZWFtLl9zdG9yZWRFcnJvcik7XG4gIH0gZWxzZSB7XG4gICAgYXNzZXJ0KHN0cmVhbS5fc3RhdGUgPT09ICdyZWFkYWJsZScpO1xuICAgIHN0cmVhbS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyW1B1bGxTdGVwc10ocmVhZFJlcXVlc3QgYXMgUmVhZFJlcXVlc3Q8YW55Pik7XG4gIH1cbn1cblxuLy8gSGVscGVyIGZ1bmN0aW9ucyBmb3IgdGhlIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlci5cblxuZnVuY3Rpb24gZGVmYXVsdFJlYWRlckJyYW5kQ2hlY2tFeGNlcHRpb24obmFtZTogc3RyaW5nKTogVHlwZUVycm9yIHtcbiAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoXG4gICAgYFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlci5wcm90b3R5cGUuJHtuYW1lfSBjYW4gb25seSBiZSB1c2VkIG9uIGEgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyYCk7XG59XG4iLCAiLy8vIDxyZWZlcmVuY2UgbGliPVwiZXMyMDE4LmFzeW5jaXRlcmFibGVcIiAvPlxuXG5leHBvcnQgbGV0IEFzeW5jSXRlcmF0b3JQcm90b3R5cGU6IEFzeW5jSXRlcmFibGU8YW55PiB8IHVuZGVmaW5lZDtcblxuaWYgKHR5cGVvZiBTeW1ib2wuYXN5bmNJdGVyYXRvciA9PT0gJ3N5bWJvbCcpIHtcbiAgLy8gV2UncmUgcnVubmluZyBpbnNpZGUgYSBFUzIwMTgrIGVudmlyb25tZW50LCBidXQgd2UncmUgY29tcGlsaW5nIHRvIGFuIG9sZGVyIHN5bnRheC5cbiAgLy8gV2UgY2Fubm90IGFjY2VzcyAlQXN5bmNJdGVyYXRvclByb3RvdHlwZSUgd2l0aG91dCBub24tRVMyMDE4IHN5bnRheCwgYnV0IHdlIGNhbiByZS1jcmVhdGUgaXQuXG4gIEFzeW5jSXRlcmF0b3JQcm90b3R5cGUgPSB7XG4gICAgLy8gMjUuMS4zLjEgJUFzeW5jSXRlcmF0b3JQcm90b3R5cGUlIFsgQEBhc3luY0l0ZXJhdG9yIF0gKCApXG4gICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXN5bmNpdGVyYXRvcnByb3RvdHlwZS1hc3luY2l0ZXJhdG9yXG4gICAgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSh0aGlzOiBBc3luY0l0ZXJhdG9yPGFueT4pIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFzeW5jSXRlcmF0b3JQcm90b3R5cGUsIFN5bWJvbC5hc3luY0l0ZXJhdG9yLCB7IGVudW1lcmFibGU6IGZhbHNlIH0pO1xufVxuIiwgIi8vLyA8cmVmZXJlbmNlIGxpYj1cImVzMjAxOC5hc3luY2l0ZXJhYmxlXCIgLz5cblxuaW1wb3J0IHsgUmVhZGFibGVTdHJlYW0gfSBmcm9tICcuLi9yZWFkYWJsZS1zdHJlYW0nO1xuaW1wb3J0IHtcbiAgQWNxdWlyZVJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcixcbiAgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyLFxuICBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXJSZWFkLFxuICBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkUmVzdWx0LFxuICBSZWFkUmVxdWVzdFxufSBmcm9tICcuL2RlZmF1bHQtcmVhZGVyJztcbmltcG9ydCB7XG4gIFJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY0NhbmNlbCxcbiAgUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljUmVsZWFzZSxcbiAgcmVhZGVyTG9ja0V4Y2VwdGlvblxufSBmcm9tICcuL2dlbmVyaWMtcmVhZGVyJztcbmltcG9ydCBhc3NlcnQgZnJvbSAnLi4vLi4vc3R1Yi9hc3NlcnQnO1xuaW1wb3J0IHsgQXN5bmNJdGVyYXRvclByb3RvdHlwZSB9IGZyb20gJ0BAdGFyZ2V0L3N0dWIvYXN5bmMtaXRlcmF0b3ItcHJvdG90eXBlJztcbmltcG9ydCB7IHR5cGVJc09iamVjdCB9IGZyb20gJy4uL2hlbHBlcnMvbWlzY2VsbGFuZW91cyc7XG5pbXBvcnQge1xuICBuZXdQcm9taXNlLFxuICBwcm9taXNlUmVqZWN0ZWRXaXRoLFxuICBwcm9taXNlUmVzb2x2ZWRXaXRoLFxuICBxdWV1ZU1pY3JvdGFzayxcbiAgdHJhbnNmb3JtUHJvbWlzZVdpdGhcbn0gZnJvbSAnLi4vaGVscGVycy93ZWJpZGwnO1xuXG4vKipcbiAqIEFuIGFzeW5jIGl0ZXJhdG9yIHJldHVybmVkIGJ5IHtAbGluayBSZWFkYWJsZVN0cmVhbS52YWx1ZXN9LlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3I8Uj4gZXh0ZW5kcyBBc3luY0l0ZXJhdG9yPFI+IHtcbiAgbmV4dCgpOiBQcm9taXNlPEl0ZXJhdG9yUmVzdWx0PFIsIHVuZGVmaW5lZD4+O1xuXG4gIHJldHVybih2YWx1ZT86IGFueSk6IFByb21pc2U8SXRlcmF0b3JSZXN1bHQ8YW55Pj47XG59XG5cbmV4cG9ydCBjbGFzcyBSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3JJbXBsPFI+IHtcbiAgcHJpdmF0ZSByZWFkb25seSBfcmVhZGVyOiBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXI8Uj47XG4gIHByaXZhdGUgcmVhZG9ubHkgX3ByZXZlbnRDYW5jZWw6IGJvb2xlYW47XG4gIHByaXZhdGUgX29uZ29pbmdQcm9taXNlOiBQcm9taXNlPFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRSZXN1bHQ8Uj4+IHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICBwcml2YXRlIF9pc0ZpbmlzaGVkID0gZmFsc2U7XG5cbiAgY29uc3RydWN0b3IocmVhZGVyOiBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXI8Uj4sIHByZXZlbnRDYW5jZWw6IGJvb2xlYW4pIHtcbiAgICB0aGlzLl9yZWFkZXIgPSByZWFkZXI7XG4gICAgdGhpcy5fcHJldmVudENhbmNlbCA9IHByZXZlbnRDYW5jZWw7XG4gIH1cblxuICBuZXh0KCk6IFByb21pc2U8UmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZFJlc3VsdDxSPj4ge1xuICAgIGNvbnN0IG5leHRTdGVwcyA9ICgpID0+IHRoaXMuX25leHRTdGVwcygpO1xuICAgIHRoaXMuX29uZ29pbmdQcm9taXNlID0gdGhpcy5fb25nb2luZ1Byb21pc2UgP1xuICAgICAgdHJhbnNmb3JtUHJvbWlzZVdpdGgodGhpcy5fb25nb2luZ1Byb21pc2UsIG5leHRTdGVwcywgbmV4dFN0ZXBzKSA6XG4gICAgICBuZXh0U3RlcHMoKTtcbiAgICByZXR1cm4gdGhpcy5fb25nb2luZ1Byb21pc2U7XG4gIH1cblxuICByZXR1cm4odmFsdWU6IGFueSk6IFByb21pc2U8UmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZFJlc3VsdDxhbnk+PiB7XG4gICAgY29uc3QgcmV0dXJuU3RlcHMgPSAoKSA9PiB0aGlzLl9yZXR1cm5TdGVwcyh2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXMuX29uZ29pbmdQcm9taXNlID9cbiAgICAgIHRyYW5zZm9ybVByb21pc2VXaXRoKHRoaXMuX29uZ29pbmdQcm9taXNlLCByZXR1cm5TdGVwcywgcmV0dXJuU3RlcHMpIDpcbiAgICAgIHJldHVyblN0ZXBzKCk7XG4gIH1cblxuICBwcml2YXRlIF9uZXh0U3RlcHMoKTogUHJvbWlzZTxSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkUmVzdWx0PFI+PiB7XG4gICAgaWYgKHRoaXMuX2lzRmluaXNoZWQpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoeyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IHJlYWRlciA9IHRoaXMuX3JlYWRlcjtcbiAgICBpZiAocmVhZGVyLl9vd25lclJlYWRhYmxlU3RyZWFtID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKHJlYWRlckxvY2tFeGNlcHRpb24oJ2l0ZXJhdGUnKSk7XG4gICAgfVxuXG4gICAgbGV0IHJlc29sdmVQcm9taXNlITogKHJlc3VsdDogUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZFJlc3VsdDxSPikgPT4gdm9pZDtcbiAgICBsZXQgcmVqZWN0UHJvbWlzZSE6IChyZWFzb246IGFueSkgPT4gdm9pZDtcbiAgICBjb25zdCBwcm9taXNlID0gbmV3UHJvbWlzZTxSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkUmVzdWx0PFI+PigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICByZXNvbHZlUHJvbWlzZSA9IHJlc29sdmU7XG4gICAgICByZWplY3RQcm9taXNlID0gcmVqZWN0O1xuICAgIH0pO1xuICAgIGNvbnN0IHJlYWRSZXF1ZXN0OiBSZWFkUmVxdWVzdDxSPiA9IHtcbiAgICAgIF9jaHVua1N0ZXBzOiBjaHVuayA9PiB7XG4gICAgICAgIHRoaXMuX29uZ29pbmdQcm9taXNlID0gdW5kZWZpbmVkO1xuICAgICAgICAvLyBUaGlzIG5lZWRzIHRvIGJlIGRlbGF5ZWQgYnkgb25lIG1pY3JvdGFzaywgb3RoZXJ3aXNlIHdlIHN0b3AgcHVsbGluZyB0b28gZWFybHkgd2hpY2ggYnJlYWtzIGEgdGVzdC5cbiAgICAgICAgLy8gRklYTUUgSXMgdGhpcyBhIGJ1ZyBpbiB0aGUgc3BlY2lmaWNhdGlvbiwgb3IgaW4gdGhlIHRlc3Q/XG4gICAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHJlc29sdmVQcm9taXNlKHsgdmFsdWU6IGNodW5rLCBkb25lOiBmYWxzZSB9KSk7XG4gICAgICB9LFxuICAgICAgX2Nsb3NlU3RlcHM6ICgpID0+IHtcbiAgICAgICAgdGhpcy5fb25nb2luZ1Byb21pc2UgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX2lzRmluaXNoZWQgPSB0cnVlO1xuICAgICAgICBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNSZWxlYXNlKHJlYWRlcik7XG4gICAgICAgIHJlc29sdmVQcm9taXNlKHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9KTtcbiAgICAgIH0sXG4gICAgICBfZXJyb3JTdGVwczogcmVhc29uID0+IHtcbiAgICAgICAgdGhpcy5fb25nb2luZ1Byb21pc2UgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX2lzRmluaXNoZWQgPSB0cnVlO1xuICAgICAgICBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNSZWxlYXNlKHJlYWRlcik7XG4gICAgICAgIHJlamVjdFByb21pc2UocmVhc29uKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlclJlYWQocmVhZGVyLCByZWFkUmVxdWVzdCk7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cblxuICBwcml2YXRlIF9yZXR1cm5TdGVwcyh2YWx1ZTogYW55KTogUHJvbWlzZTxSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkUmVzdWx0PGFueT4+IHtcbiAgICBpZiAodGhpcy5faXNGaW5pc2hlZCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7IHZhbHVlLCBkb25lOiB0cnVlIH0pO1xuICAgIH1cbiAgICB0aGlzLl9pc0ZpbmlzaGVkID0gdHJ1ZTtcblxuICAgIGNvbnN0IHJlYWRlciA9IHRoaXMuX3JlYWRlcjtcbiAgICBpZiAocmVhZGVyLl9vd25lclJlYWRhYmxlU3RyZWFtID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKHJlYWRlckxvY2tFeGNlcHRpb24oJ2ZpbmlzaCBpdGVyYXRpbmcnKSk7XG4gICAgfVxuXG4gICAgYXNzZXJ0KHJlYWRlci5fcmVhZFJlcXVlc3RzLmxlbmd0aCA9PT0gMCk7XG5cbiAgICBpZiAoIXRoaXMuX3ByZXZlbnRDYW5jZWwpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IFJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY0NhbmNlbChyZWFkZXIsIHZhbHVlKTtcbiAgICAgIFJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY1JlbGVhc2UocmVhZGVyKTtcbiAgICAgIHJldHVybiB0cmFuc2Zvcm1Qcm9taXNlV2l0aChyZXN1bHQsICgpID0+ICh7IHZhbHVlLCBkb25lOiB0cnVlIH0pKTtcbiAgICB9XG5cbiAgICBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNSZWxlYXNlKHJlYWRlcik7XG4gICAgcmV0dXJuIHByb21pc2VSZXNvbHZlZFdpdGgoeyB2YWx1ZSwgZG9uZTogdHJ1ZSB9KTtcbiAgfVxufVxuXG5kZWNsYXJlIGNsYXNzIFJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvckluc3RhbmNlPFI+IGltcGxlbWVudHMgUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yPFI+IHtcbiAgLyoqIEBpbnRlcmFsICovXG4gIF9hc3luY0l0ZXJhdG9ySW1wbDogUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9ySW1wbDxSPjtcblxuICBuZXh0KCk6IFByb21pc2U8SXRlcmF0b3JSZXN1bHQ8UiwgdW5kZWZpbmVkPj47XG5cbiAgcmV0dXJuKHZhbHVlPzogYW55KTogUHJvbWlzZTxJdGVyYXRvclJlc3VsdDxhbnk+Pjtcbn1cblxuY29uc3QgUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yUHJvdG90eXBlOiBSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3JJbnN0YW5jZTxhbnk+ID0ge1xuICBuZXh0KHRoaXM6IFJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvckluc3RhbmNlPGFueT4pOiBQcm9taXNlPFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRSZXN1bHQ8YW55Pj4ge1xuICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IodGhpcykpIHtcbiAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKHN0cmVhbUFzeW5jSXRlcmF0b3JCcmFuZENoZWNrRXhjZXB0aW9uKCduZXh0JykpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fYXN5bmNJdGVyYXRvckltcGwubmV4dCgpO1xuICB9LFxuXG4gIHJldHVybih0aGlzOiBSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3JJbnN0YW5jZTxhbnk+LCB2YWx1ZTogYW55KTogUHJvbWlzZTxSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkUmVzdWx0PGFueT4+IHtcbiAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yKHRoaXMpKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChzdHJlYW1Bc3luY0l0ZXJhdG9yQnJhbmRDaGVja0V4Y2VwdGlvbigncmV0dXJuJykpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fYXN5bmNJdGVyYXRvckltcGwucmV0dXJuKHZhbHVlKTtcbiAgfVxufSBhcyBhbnk7XG5pZiAoQXN5bmNJdGVyYXRvclByb3RvdHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3JQcm90b3R5cGUsIEFzeW5jSXRlcmF0b3JQcm90b3R5cGUpO1xufVxuXG4vLyBBYnN0cmFjdCBvcGVyYXRpb25zIGZvciB0aGUgUmVhZGFibGVTdHJlYW0uXG5cbmV4cG9ydCBmdW5jdGlvbiBBY3F1aXJlUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yPFI+KHN0cmVhbTogUmVhZGFibGVTdHJlYW08Uj4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2ZW50Q2FuY2VsOiBib29sZWFuKTogUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yPFI+IHtcbiAgY29uc3QgcmVhZGVyID0gQWNxdWlyZVJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcjxSPihzdHJlYW0pO1xuICBjb25zdCBpbXBsID0gbmV3IFJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvckltcGwocmVhZGVyLCBwcmV2ZW50Q2FuY2VsKTtcbiAgY29uc3QgaXRlcmF0b3I6IFJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvckluc3RhbmNlPFI+ID0gT2JqZWN0LmNyZWF0ZShSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3JQcm90b3R5cGUpO1xuICBpdGVyYXRvci5fYXN5bmNJdGVyYXRvckltcGwgPSBpbXBsO1xuICByZXR1cm4gaXRlcmF0b3I7XG59XG5cbmZ1bmN0aW9uIElzUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yPFIgPSBhbnk+KHg6IGFueSk6IHggaXMgUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yPFI+IHtcbiAgaWYgKCF0eXBlSXNPYmplY3QoeCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnX2FzeW5jSXRlcmF0b3JJbXBsJykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB0cnkge1xuICAgIC8vIG5vaW5zcGVjdGlvbiBTdXNwaWNpb3VzVHlwZU9mR3VhcmRcbiAgICByZXR1cm4gKHggYXMgUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9ySW5zdGFuY2U8YW55PikuX2FzeW5jSXRlcmF0b3JJbXBsIGluc3RhbmNlb2ZcbiAgICAgIFJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvckltcGw7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vLyBIZWxwZXIgZnVuY3Rpb25zIGZvciB0aGUgUmVhZGFibGVTdHJlYW0uXG5cbmZ1bmN0aW9uIHN0cmVhbUFzeW5jSXRlcmF0b3JCcmFuZENoZWNrRXhjZXB0aW9uKG5hbWU6IHN0cmluZyk6IFR5cGVFcnJvciB7XG4gIHJldHVybiBuZXcgVHlwZUVycm9yKGBSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IuJHtuYW1lfSBjYW4gb25seSBiZSB1c2VkIG9uIGEgUmVhZGFibGVTdGVhbUFzeW5jSXRlcmF0b3JgKTtcbn1cbiIsICIvLy8gPHJlZmVyZW5jZSBsaWI9XCJlczIwMTUuY29yZVwiIC8+XG5cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL051bWJlci9pc05hTiNQb2x5ZmlsbFxuY29uc3QgTnVtYmVySXNOYU46IHR5cGVvZiBOdW1iZXIuaXNOYU4gPSBOdW1iZXIuaXNOYU4gfHwgZnVuY3Rpb24gKHgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICByZXR1cm4geCAhPT0geDtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IE51bWJlcklzTmFOO1xuIiwgImV4cG9ydCBmdW5jdGlvbiBDcmVhdGVBcnJheUZyb21MaXN0PFQgZXh0ZW5kcyBhbnlbXT4oZWxlbWVudHM6IFQpOiBUIHtcbiAgLy8gV2UgdXNlIGFycmF5cyB0byByZXByZXNlbnQgbGlzdHMsIHNvIHRoaXMgaXMgYmFzaWNhbGx5IGEgbm8tb3AuXG4gIC8vIERvIGEgc2xpY2UgdGhvdWdoIGp1c3QgaW4gY2FzZSB3ZSBoYXBwZW4gdG8gZGVwZW5kIG9uIHRoZSB1bmlxdWUtbmVzcy5cbiAgcmV0dXJuIGVsZW1lbnRzLnNsaWNlKCkgYXMgVDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIENvcHlEYXRhQmxvY2tCeXRlcyhkZXN0OiBBcnJheUJ1ZmZlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzdE9mZnNldDogbnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmM6IEFycmF5QnVmZmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmNPZmZzZXQ6IG51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbjogbnVtYmVyKSB7XG4gIG5ldyBVaW50OEFycmF5KGRlc3QpLnNldChuZXcgVWludDhBcnJheShzcmMsIHNyY09mZnNldCwgbiksIGRlc3RPZmZzZXQpO1xufVxuXG4vLyBOb3QgaW1wbGVtZW50ZWQgY29ycmVjdGx5XG5leHBvcnQgZnVuY3Rpb24gVHJhbnNmZXJBcnJheUJ1ZmZlcjxUIGV4dGVuZHMgQXJyYXlCdWZmZXJMaWtlPihPOiBUKTogVCB7XG4gIHJldHVybiBPO1xufVxuXG4vLyBOb3QgaW1wbGVtZW50ZWQgY29ycmVjdGx5XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG5leHBvcnQgZnVuY3Rpb24gQ2FuVHJhbnNmZXJBcnJheUJ1ZmZlcihPOiBBcnJheUJ1ZmZlckxpa2UpOiBib29sZWFuIHtcbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIE5vdCBpbXBsZW1lbnRlZCBjb3JyZWN0bHlcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbmV4cG9ydCBmdW5jdGlvbiBJc0RldGFjaGVkQnVmZmVyKE86IEFycmF5QnVmZmVyTGlrZSk6IGJvb2xlYW4ge1xuICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBBcnJheUJ1ZmZlclNsaWNlKGJ1ZmZlcjogQXJyYXlCdWZmZXJMaWtlLCBiZWdpbjogbnVtYmVyLCBlbmQ6IG51bWJlcik6IEFycmF5QnVmZmVyTGlrZSB7XG4gIC8vIEFycmF5QnVmZmVyLnByb3RvdHlwZS5zbGljZSBpcyBub3QgYXZhaWxhYmxlIG9uIElFMTBcbiAgLy8gaHR0cHM6Ly93d3cuY2FuaXVzZS5jb20vbWRuLWphdmFzY3JpcHRfYnVpbHRpbnNfYXJyYXlidWZmZXJfc2xpY2VcbiAgaWYgKGJ1ZmZlci5zbGljZSkge1xuICAgIHJldHVybiBidWZmZXIuc2xpY2UoYmVnaW4sIGVuZCk7XG4gIH1cbiAgY29uc3QgbGVuZ3RoID0gZW5kIC0gYmVnaW47XG4gIGNvbnN0IHNsaWNlID0gbmV3IEFycmF5QnVmZmVyKGxlbmd0aCk7XG4gIENvcHlEYXRhQmxvY2tCeXRlcyhzbGljZSwgMCwgYnVmZmVyLCBiZWdpbiwgbGVuZ3RoKTtcbiAgcmV0dXJuIHNsaWNlO1xufVxuIiwgImltcG9ydCBOdW1iZXJJc05hTiBmcm9tICcuLi8uLi9zdHViL251bWJlci1pc25hbic7XG5pbXBvcnQgeyBBcnJheUJ1ZmZlclNsaWNlIH0gZnJvbSAnLi9lY21hc2NyaXB0JztcblxuZXhwb3J0IGZ1bmN0aW9uIElzTm9uTmVnYXRpdmVOdW1iZXIodjogbnVtYmVyKTogYm9vbGVhbiB7XG4gIGlmICh0eXBlb2YgdiAhPT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoTnVtYmVySXNOYU4odikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAodiA8IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIENsb25lQXNVaW50OEFycmF5KE86IEFycmF5QnVmZmVyVmlldyk6IFVpbnQ4QXJyYXkge1xuICBjb25zdCBidWZmZXIgPSBBcnJheUJ1ZmZlclNsaWNlKE8uYnVmZmVyLCBPLmJ5dGVPZmZzZXQsIE8uYnl0ZU9mZnNldCArIE8uYnl0ZUxlbmd0aCk7XG4gIHJldHVybiBuZXcgVWludDhBcnJheShidWZmZXIpO1xufVxuIiwgImltcG9ydCBhc3NlcnQgZnJvbSAnLi4vLi4vc3R1Yi9hc3NlcnQnO1xuaW1wb3J0IHsgU2ltcGxlUXVldWUgfSBmcm9tICcuLi9zaW1wbGUtcXVldWUnO1xuaW1wb3J0IHsgSXNOb25OZWdhdGl2ZU51bWJlciB9IGZyb20gJy4vbWlzY2VsbGFuZW91cyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUXVldWVDb250YWluZXI8VD4ge1xuICBfcXVldWU6IFNpbXBsZVF1ZXVlPFQ+O1xuICBfcXVldWVUb3RhbFNpemU6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBRdWV1ZVBhaXI8VD4ge1xuICB2YWx1ZTogVDtcbiAgc2l6ZTogbnVtYmVyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gRGVxdWV1ZVZhbHVlPFQ+KGNvbnRhaW5lcjogUXVldWVDb250YWluZXI8UXVldWVQYWlyPFQ+Pik6IFQge1xuICBhc3NlcnQoJ19xdWV1ZScgaW4gY29udGFpbmVyICYmICdfcXVldWVUb3RhbFNpemUnIGluIGNvbnRhaW5lcik7XG4gIGFzc2VydChjb250YWluZXIuX3F1ZXVlLmxlbmd0aCA+IDApO1xuXG4gIGNvbnN0IHBhaXIgPSBjb250YWluZXIuX3F1ZXVlLnNoaWZ0KCkhO1xuICBjb250YWluZXIuX3F1ZXVlVG90YWxTaXplIC09IHBhaXIuc2l6ZTtcbiAgaWYgKGNvbnRhaW5lci5fcXVldWVUb3RhbFNpemUgPCAwKSB7XG4gICAgY29udGFpbmVyLl9xdWV1ZVRvdGFsU2l6ZSA9IDA7XG4gIH1cblxuICByZXR1cm4gcGFpci52YWx1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIEVucXVldWVWYWx1ZVdpdGhTaXplPFQ+KGNvbnRhaW5lcjogUXVldWVDb250YWluZXI8UXVldWVQYWlyPFQ+PiwgdmFsdWU6IFQsIHNpemU6IG51bWJlcikge1xuICBhc3NlcnQoJ19xdWV1ZScgaW4gY29udGFpbmVyICYmICdfcXVldWVUb3RhbFNpemUnIGluIGNvbnRhaW5lcik7XG5cbiAgaWYgKCFJc05vbk5lZ2F0aXZlTnVtYmVyKHNpemUpIHx8IHNpemUgPT09IEluZmluaXR5KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1NpemUgbXVzdCBiZSBhIGZpbml0ZSwgbm9uLU5hTiwgbm9uLW5lZ2F0aXZlIG51bWJlci4nKTtcbiAgfVxuXG4gIGNvbnRhaW5lci5fcXVldWUucHVzaCh7IHZhbHVlLCBzaXplIH0pO1xuICBjb250YWluZXIuX3F1ZXVlVG90YWxTaXplICs9IHNpemU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBQZWVrUXVldWVWYWx1ZTxUPihjb250YWluZXI6IFF1ZXVlQ29udGFpbmVyPFF1ZXVlUGFpcjxUPj4pOiBUIHtcbiAgYXNzZXJ0KCdfcXVldWUnIGluIGNvbnRhaW5lciAmJiAnX3F1ZXVlVG90YWxTaXplJyBpbiBjb250YWluZXIpO1xuICBhc3NlcnQoY29udGFpbmVyLl9xdWV1ZS5sZW5ndGggPiAwKTtcblxuICBjb25zdCBwYWlyID0gY29udGFpbmVyLl9xdWV1ZS5wZWVrKCk7XG4gIHJldHVybiBwYWlyLnZhbHVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gUmVzZXRRdWV1ZTxUPihjb250YWluZXI6IFF1ZXVlQ29udGFpbmVyPFQ+KSB7XG4gIGFzc2VydCgnX3F1ZXVlJyBpbiBjb250YWluZXIgJiYgJ19xdWV1ZVRvdGFsU2l6ZScgaW4gY29udGFpbmVyKTtcblxuICBjb250YWluZXIuX3F1ZXVlID0gbmV3IFNpbXBsZVF1ZXVlPFQ+KCk7XG4gIGNvbnRhaW5lci5fcXVldWVUb3RhbFNpemUgPSAwO1xufVxuIiwgImltcG9ydCBhc3NlcnQgZnJvbSAnLi4vLi4vc3R1Yi9hc3NlcnQnO1xuaW1wb3J0IHsgU2ltcGxlUXVldWUgfSBmcm9tICcuLi9zaW1wbGUtcXVldWUnO1xuaW1wb3J0IHsgUmVzZXRRdWV1ZSB9IGZyb20gJy4uL2Fic3RyYWN0LW9wcy9xdWV1ZS13aXRoLXNpemVzJztcbmltcG9ydCB7XG4gIFJlYWRhYmxlU3RyZWFtQWRkUmVhZFJlcXVlc3QsXG4gIFJlYWRhYmxlU3RyZWFtRnVsZmlsbFJlYWRSZXF1ZXN0LFxuICBSZWFkYWJsZVN0cmVhbUdldE51bVJlYWRSZXF1ZXN0cyxcbiAgUmVhZGFibGVTdHJlYW1IYXNEZWZhdWx0UmVhZGVyLFxuICBSZWFkUmVxdWVzdFxufSBmcm9tICcuL2RlZmF1bHQtcmVhZGVyJztcbmltcG9ydCB7XG4gIFJlYWRhYmxlU3RyZWFtQWRkUmVhZEludG9SZXF1ZXN0LFxuICBSZWFkYWJsZVN0cmVhbUZ1bGZpbGxSZWFkSW50b1JlcXVlc3QsXG4gIFJlYWRhYmxlU3RyZWFtR2V0TnVtUmVhZEludG9SZXF1ZXN0cyxcbiAgUmVhZGFibGVTdHJlYW1IYXNCWU9CUmVhZGVyLFxuICBSZWFkSW50b1JlcXVlc3Rcbn0gZnJvbSAnLi9ieW9iLXJlYWRlcic7XG5pbXBvcnQgTnVtYmVySXNJbnRlZ2VyIGZyb20gJy4uLy4uL3N0dWIvbnVtYmVyLWlzaW50ZWdlcic7XG5pbXBvcnQge1xuICBJc1JlYWRhYmxlU3RyZWFtTG9ja2VkLFxuICBSZWFkYWJsZUJ5dGVTdHJlYW0sXG4gIFJlYWRhYmxlU3RyZWFtQ2xvc2UsXG4gIFJlYWRhYmxlU3RyZWFtRXJyb3Jcbn0gZnJvbSAnLi4vcmVhZGFibGUtc3RyZWFtJztcbmltcG9ydCB7IFZhbGlkYXRlZFVuZGVybHlpbmdCeXRlU291cmNlIH0gZnJvbSAnLi91bmRlcmx5aW5nLXNvdXJjZSc7XG5pbXBvcnQgeyB0eXBlSXNPYmplY3QgfSBmcm9tICcuLi9oZWxwZXJzL21pc2NlbGxhbmVvdXMnO1xuaW1wb3J0IHtcbiAgQXJyYXlCdWZmZXJTbGljZSxcbiAgQ2FuVHJhbnNmZXJBcnJheUJ1ZmZlcixcbiAgQ29weURhdGFCbG9ja0J5dGVzLFxuICBJc0RldGFjaGVkQnVmZmVyLFxuICBUcmFuc2ZlckFycmF5QnVmZmVyXG59IGZyb20gJy4uL2Fic3RyYWN0LW9wcy9lY21hc2NyaXB0JztcbmltcG9ydCB7IENhbmNlbFN0ZXBzLCBQdWxsU3RlcHMgfSBmcm9tICcuLi9hYnN0cmFjdC1vcHMvaW50ZXJuYWwtbWV0aG9kcyc7XG5pbXBvcnQgeyBwcm9taXNlUmVzb2x2ZWRXaXRoLCB1cG9uUHJvbWlzZSB9IGZyb20gJy4uL2hlbHBlcnMvd2ViaWRsJztcbmltcG9ydCB7IGFzc2VydFJlcXVpcmVkQXJndW1lbnQsIGNvbnZlcnRVbnNpZ25lZExvbmdMb25nV2l0aEVuZm9yY2VSYW5nZSB9IGZyb20gJy4uL3ZhbGlkYXRvcnMvYmFzaWMnO1xuXG4vKipcbiAqIEEgcHVsbC1pbnRvIHJlcXVlc3QgaW4gYSB7QGxpbmsgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcn0uXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdCB7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2Fzc29jaWF0ZWRSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyITogUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcjtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfdmlldyE6IEFycmF5QnVmZmVyVmlldyB8IG51bGw7XG5cbiAgcHJpdmF0ZSBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbGxlZ2FsIGNvbnN0cnVjdG9yJyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdmlldyBmb3Igd3JpdGluZyBpbiB0bywgb3IgYG51bGxgIGlmIHRoZSBCWU9CIHJlcXVlc3QgaGFzIGFscmVhZHkgYmVlbiByZXNwb25kZWQgdG8uXG4gICAqL1xuICBnZXQgdmlldygpOiBBcnJheUJ1ZmZlclZpZXcgfCBudWxsIHtcbiAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdCh0aGlzKSkge1xuICAgICAgdGhyb3cgYnlvYlJlcXVlc3RCcmFuZENoZWNrRXhjZXB0aW9uKCd2aWV3Jyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3ZpZXc7XG4gIH1cblxuICAvKipcbiAgICogSW5kaWNhdGVzIHRvIHRoZSBhc3NvY2lhdGVkIHJlYWRhYmxlIGJ5dGUgc3RyZWFtIHRoYXQgYGJ5dGVzV3JpdHRlbmAgYnl0ZXMgd2VyZSB3cml0dGVuIGludG9cbiAgICoge0BsaW5rIFJlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QudmlldyB8IHZpZXd9LCBjYXVzaW5nIHRoZSByZXN1bHQgYmUgc3VyZmFjZWQgdG8gdGhlIGNvbnN1bWVyLlxuICAgKlxuICAgKiBBZnRlciB0aGlzIG1ldGhvZCBpcyBjYWxsZWQsIHtAbGluayBSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0LnZpZXcgfCB2aWV3fSB3aWxsIGJlIHRyYW5zZmVycmVkIGFuZCBubyBsb25nZXJcbiAgICogbW9kaWZpYWJsZS5cbiAgICovXG4gIHJlc3BvbmQoYnl0ZXNXcml0dGVuOiBudW1iZXIpOiB2b2lkO1xuICByZXNwb25kKGJ5dGVzV3JpdHRlbjogbnVtYmVyIHwgdW5kZWZpbmVkKTogdm9pZCB7XG4gICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QodGhpcykpIHtcbiAgICAgIHRocm93IGJ5b2JSZXF1ZXN0QnJhbmRDaGVja0V4Y2VwdGlvbigncmVzcG9uZCcpO1xuICAgIH1cbiAgICBhc3NlcnRSZXF1aXJlZEFyZ3VtZW50KGJ5dGVzV3JpdHRlbiwgMSwgJ3Jlc3BvbmQnKTtcbiAgICBieXRlc1dyaXR0ZW4gPSBjb252ZXJ0VW5zaWduZWRMb25nTG9uZ1dpdGhFbmZvcmNlUmFuZ2UoYnl0ZXNXcml0dGVuLCAnRmlyc3QgcGFyYW1ldGVyJyk7XG5cbiAgICBpZiAodGhpcy5fYXNzb2NpYXRlZFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhpcyBCWU9CIHJlcXVlc3QgaGFzIGJlZW4gaW52YWxpZGF0ZWQnKTtcbiAgICB9XG5cbiAgICBpZiAoSXNEZXRhY2hlZEJ1ZmZlcih0aGlzLl92aWV3IS5idWZmZXIpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgQllPQiByZXF1ZXN0J3MgYnVmZmVyIGhhcyBiZWVuIGRldGFjaGVkIGFuZCBzbyBjYW5ub3QgYmUgdXNlZCBhcyBhIHJlc3BvbnNlYCk7XG4gICAgfVxuXG4gICAgYXNzZXJ0KHRoaXMuX3ZpZXchLmJ5dGVMZW5ndGggPiAwKTtcbiAgICBhc3NlcnQodGhpcy5fdmlldyEuYnVmZmVyLmJ5dGVMZW5ndGggPiAwKTtcblxuICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kKHRoaXMuX2Fzc29jaWF0ZWRSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyLCBieXRlc1dyaXR0ZW4pO1xuICB9XG5cbiAgLyoqXG4gICAqIEluZGljYXRlcyB0byB0aGUgYXNzb2NpYXRlZCByZWFkYWJsZSBieXRlIHN0cmVhbSB0aGF0IGluc3RlYWQgb2Ygd3JpdGluZyBpbnRvXG4gICAqIHtAbGluayBSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0LnZpZXcgfCB2aWV3fSwgdGhlIHVuZGVybHlpbmcgYnl0ZSBzb3VyY2UgaXMgcHJvdmlkaW5nIGEgbmV3IGBBcnJheUJ1ZmZlclZpZXdgLFxuICAgKiB3aGljaCB3aWxsIGJlIGdpdmVuIHRvIHRoZSBjb25zdW1lciBvZiB0aGUgcmVhZGFibGUgYnl0ZSBzdHJlYW0uXG4gICAqXG4gICAqIEFmdGVyIHRoaXMgbWV0aG9kIGlzIGNhbGxlZCwgYHZpZXdgIHdpbGwgYmUgdHJhbnNmZXJyZWQgYW5kIG5vIGxvbmdlciBtb2RpZmlhYmxlLlxuICAgKi9cbiAgcmVzcG9uZFdpdGhOZXdWaWV3KHZpZXc6IEFycmF5QnVmZmVyVmlldyk6IHZvaWQ7XG4gIHJlc3BvbmRXaXRoTmV3Vmlldyh2aWV3OiBBcnJheUJ1ZmZlclZpZXcgfCB1bmRlZmluZWQpOiB2b2lkIHtcbiAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdCh0aGlzKSkge1xuICAgICAgdGhyb3cgYnlvYlJlcXVlc3RCcmFuZENoZWNrRXhjZXB0aW9uKCdyZXNwb25kV2l0aE5ld1ZpZXcnKTtcbiAgICB9XG4gICAgYXNzZXJ0UmVxdWlyZWRBcmd1bWVudCh2aWV3LCAxLCAncmVzcG9uZFdpdGhOZXdWaWV3Jyk7XG5cbiAgICBpZiAoIUFycmF5QnVmZmVyLmlzVmlldyh2aWV3KSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignWW91IGNhbiBvbmx5IHJlc3BvbmQgd2l0aCBhcnJheSBidWZmZXIgdmlld3MnKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fYXNzb2NpYXRlZFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhpcyBCWU9CIHJlcXVlc3QgaGFzIGJlZW4gaW52YWxpZGF0ZWQnKTtcbiAgICB9XG5cbiAgICBpZiAoSXNEZXRhY2hlZEJ1ZmZlcih2aWV3LmJ1ZmZlcikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBnaXZlbiB2aWV3XFwncyBidWZmZXIgaGFzIGJlZW4gZGV0YWNoZWQgYW5kIHNvIGNhbm5vdCBiZSB1c2VkIGFzIGEgcmVzcG9uc2UnKTtcbiAgICB9XG5cbiAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZFdpdGhOZXdWaWV3KHRoaXMuX2Fzc29jaWF0ZWRSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyLCB2aWV3KTtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0LnByb3RvdHlwZSwge1xuICByZXNwb25kOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgcmVzcG9uZFdpdGhOZXdWaWV3OiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgdmlldzogeyBlbnVtZXJhYmxlOiB0cnVlIH1cbn0pO1xuaWYgKHR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWcgPT09ICdzeW1ib2wnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0LnByb3RvdHlwZSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7XG4gICAgdmFsdWU6ICdSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0JyxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbmludGVyZmFjZSBBcnJheUJ1ZmZlclZpZXdDb25zdHJ1Y3RvcjxUIGV4dGVuZHMgQXJyYXlCdWZmZXJWaWV3ID0gQXJyYXlCdWZmZXJWaWV3PiB7XG4gIG5ldyhidWZmZXI6IEFycmF5QnVmZmVyTGlrZSwgYnl0ZU9mZnNldDogbnVtYmVyLCBsZW5ndGg/OiBudW1iZXIpOiBUO1xuXG4gIHJlYWRvbmx5IHByb3RvdHlwZTogVDtcbiAgcmVhZG9ubHkgQllURVNfUEVSX0VMRU1FTlQ6IG51bWJlcjtcbn1cblxuaW50ZXJmYWNlIEJ5dGVRdWV1ZUVsZW1lbnQge1xuICBidWZmZXI6IEFycmF5QnVmZmVyTGlrZTtcbiAgYnl0ZU9mZnNldDogbnVtYmVyO1xuICBieXRlTGVuZ3RoOiBudW1iZXI7XG59XG5cbnR5cGUgUHVsbEludG9EZXNjcmlwdG9yPFQgZXh0ZW5kcyBBcnJheUJ1ZmZlclZpZXcgPSBBcnJheUJ1ZmZlclZpZXc+ID1cbiAgRGVmYXVsdFB1bGxJbnRvRGVzY3JpcHRvclxuICB8IEJZT0JQdWxsSW50b0Rlc2NyaXB0b3I8VD47XG5cbmludGVyZmFjZSBEZWZhdWx0UHVsbEludG9EZXNjcmlwdG9yIHtcbiAgYnVmZmVyOiBBcnJheUJ1ZmZlckxpa2U7XG4gIGJ1ZmZlckJ5dGVMZW5ndGg6IG51bWJlcjtcbiAgYnl0ZU9mZnNldDogbnVtYmVyO1xuICBieXRlTGVuZ3RoOiBudW1iZXI7XG4gIGJ5dGVzRmlsbGVkOiBudW1iZXI7XG4gIGVsZW1lbnRTaXplOiBudW1iZXI7XG4gIHZpZXdDb25zdHJ1Y3RvcjogQXJyYXlCdWZmZXJWaWV3Q29uc3RydWN0b3I8VWludDhBcnJheT47XG4gIHJlYWRlclR5cGU6ICdkZWZhdWx0Jztcbn1cblxuaW50ZXJmYWNlIEJZT0JQdWxsSW50b0Rlc2NyaXB0b3I8VCBleHRlbmRzIEFycmF5QnVmZmVyVmlldyA9IEFycmF5QnVmZmVyVmlldz4ge1xuICBidWZmZXI6IEFycmF5QnVmZmVyTGlrZTtcbiAgYnVmZmVyQnl0ZUxlbmd0aDogbnVtYmVyO1xuICBieXRlT2Zmc2V0OiBudW1iZXI7XG4gIGJ5dGVMZW5ndGg6IG51bWJlcjtcbiAgYnl0ZXNGaWxsZWQ6IG51bWJlcjtcbiAgZWxlbWVudFNpemU6IG51bWJlcjtcbiAgdmlld0NvbnN0cnVjdG9yOiBBcnJheUJ1ZmZlclZpZXdDb25zdHJ1Y3RvcjxUPjtcbiAgcmVhZGVyVHlwZTogJ2J5b2InO1xufVxuXG4vKipcbiAqIEFsbG93cyBjb250cm9sIG9mIGEge0BsaW5rIFJlYWRhYmxlU3RyZWFtIHwgcmVhZGFibGUgYnl0ZSBzdHJlYW19J3Mgc3RhdGUgYW5kIGludGVybmFsIHF1ZXVlLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNsYXNzIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIge1xuICAvKiogQGludGVybmFsICovXG4gIF9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtITogUmVhZGFibGVCeXRlU3RyZWFtO1xuICAvKiogQGludGVybmFsICovXG4gIF9xdWV1ZSE6IFNpbXBsZVF1ZXVlPEJ5dGVRdWV1ZUVsZW1lbnQ+O1xuICAvKiogQGludGVybmFsICovXG4gIF9xdWV1ZVRvdGFsU2l6ZSE6IG51bWJlcjtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfc3RhcnRlZCE6IGJvb2xlYW47XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2Nsb3NlUmVxdWVzdGVkITogYm9vbGVhbjtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfcHVsbEFnYWluITogYm9vbGVhbjtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfcHVsbGluZyAhOiBib29sZWFuO1xuICAvKiogQGludGVybmFsICovXG4gIF9zdHJhdGVneUhXTSE6IG51bWJlcjtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfcHVsbEFsZ29yaXRobSE6ICgpID0+IFByb21pc2U8dm9pZD47XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2NhbmNlbEFsZ29yaXRobSE6IChyZWFzb246IGFueSkgPT4gUHJvbWlzZTx2b2lkPjtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXV0b0FsbG9jYXRlQ2h1bmtTaXplOiBudW1iZXIgfCB1bmRlZmluZWQ7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2J5b2JSZXF1ZXN0OiBSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0IHwgbnVsbDtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfcGVuZGluZ1B1bGxJbnRvcyE6IFNpbXBsZVF1ZXVlPFB1bGxJbnRvRGVzY3JpcHRvcj47XG5cbiAgcHJpdmF0ZSBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbGxlZ2FsIGNvbnN0cnVjdG9yJyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBCWU9CIHB1bGwgcmVxdWVzdCwgb3IgYG51bGxgIGlmIHRoZXJlIGlzbid0IG9uZS5cbiAgICovXG4gIGdldCBieW9iUmVxdWVzdCgpOiBSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0IHwgbnVsbCB7XG4gICAgaWYgKCFJc1JlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIodGhpcykpIHtcbiAgICAgIHRocm93IGJ5dGVTdHJlYW1Db250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbignYnlvYlJlcXVlc3QnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckdldEJZT0JSZXF1ZXN0KHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGRlc2lyZWQgc2l6ZSB0byBmaWxsIHRoZSBjb250cm9sbGVkIHN0cmVhbSdzIGludGVybmFsIHF1ZXVlLiBJdCBjYW4gYmUgbmVnYXRpdmUsIGlmIHRoZSBxdWV1ZSBpc1xuICAgKiBvdmVyLWZ1bGwuIEFuIHVuZGVybHlpbmcgYnl0ZSBzb3VyY2Ugb3VnaHQgdG8gdXNlIHRoaXMgaW5mb3JtYXRpb24gdG8gZGV0ZXJtaW5lIHdoZW4gYW5kIGhvdyB0byBhcHBseSBiYWNrcHJlc3N1cmUuXG4gICAqL1xuICBnZXQgZGVzaXJlZFNpemUoKTogbnVtYmVyIHwgbnVsbCB7XG4gICAgaWYgKCFJc1JlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIodGhpcykpIHtcbiAgICAgIHRocm93IGJ5dGVTdHJlYW1Db250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbignZGVzaXJlZFNpemUnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckdldERlc2lyZWRTaXplKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENsb3NlcyB0aGUgY29udHJvbGxlZCByZWFkYWJsZSBzdHJlYW0uIENvbnN1bWVycyB3aWxsIHN0aWxsIGJlIGFibGUgdG8gcmVhZCBhbnkgcHJldmlvdXNseS1lbnF1ZXVlZCBjaHVua3MgZnJvbVxuICAgKiB0aGUgc3RyZWFtLCBidXQgb25jZSB0aG9zZSBhcmUgcmVhZCwgdGhlIHN0cmVhbSB3aWxsIGJlY29tZSBjbG9zZWQuXG4gICAqL1xuICBjbG9zZSgpOiB2b2lkIHtcbiAgICBpZiAoIUlzUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcih0aGlzKSkge1xuICAgICAgdGhyb3cgYnl0ZVN0cmVhbUNvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdjbG9zZScpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9jbG9zZVJlcXVlc3RlZCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIHN0cmVhbSBoYXMgYWxyZWFkeSBiZWVuIGNsb3NlZDsgZG8gbm90IGNsb3NlIGl0IGFnYWluIScpO1xuICAgIH1cblxuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbS5fc3RhdGU7XG4gICAgaWYgKHN0YXRlICE9PSAncmVhZGFibGUnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgc3RyZWFtIChpbiAke3N0YXRlfSBzdGF0ZSkgaXMgbm90IGluIHRoZSByZWFkYWJsZSBzdGF0ZSBhbmQgY2Fubm90IGJlIGNsb3NlZGApO1xuICAgIH1cblxuICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDbG9zZSh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbnF1ZXVlcyB0aGUgZ2l2ZW4gY2h1bmsgY2h1bmsgaW4gdGhlIGNvbnRyb2xsZWQgcmVhZGFibGUgc3RyZWFtLlxuICAgKiBUaGUgY2h1bmsgaGFzIHRvIGJlIGFuIGBBcnJheUJ1ZmZlclZpZXdgIGluc3RhbmNlLCBvciBlbHNlIGEgYFR5cGVFcnJvcmAgd2lsbCBiZSB0aHJvd24uXG4gICAqL1xuICBlbnF1ZXVlKGNodW5rOiBBcnJheUJ1ZmZlclZpZXcpOiB2b2lkO1xuICBlbnF1ZXVlKGNodW5rOiBBcnJheUJ1ZmZlclZpZXcgfCB1bmRlZmluZWQpOiB2b2lkIHtcbiAgICBpZiAoIUlzUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcih0aGlzKSkge1xuICAgICAgdGhyb3cgYnl0ZVN0cmVhbUNvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdlbnF1ZXVlJyk7XG4gICAgfVxuXG4gICAgYXNzZXJ0UmVxdWlyZWRBcmd1bWVudChjaHVuaywgMSwgJ2VucXVldWUnKTtcbiAgICBpZiAoIUFycmF5QnVmZmVyLmlzVmlldyhjaHVuaykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NodW5rIG11c3QgYmUgYW4gYXJyYXkgYnVmZmVyIHZpZXcnKTtcbiAgICB9XG4gICAgaWYgKGNodW5rLmJ5dGVMZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NodW5rIG11c3QgaGF2ZSBub24temVybyBieXRlTGVuZ3RoJyk7XG4gICAgfVxuICAgIGlmIChjaHVuay5idWZmZXIuYnl0ZUxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgY2h1bmsncyBidWZmZXIgbXVzdCBoYXZlIG5vbi16ZXJvIGJ5dGVMZW5ndGhgKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fY2xvc2VSZXF1ZXN0ZWQpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3N0cmVhbSBpcyBjbG9zZWQgb3IgZHJhaW5pbmcnKTtcbiAgICB9XG5cbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW0uX3N0YXRlO1xuICAgIGlmIChzdGF0ZSAhPT0gJ3JlYWRhYmxlJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIHN0cmVhbSAoaW4gJHtzdGF0ZX0gc3RhdGUpIGlzIG5vdCBpbiB0aGUgcmVhZGFibGUgc3RhdGUgYW5kIGNhbm5vdCBiZSBlbnF1ZXVlZCB0b2ApO1xuICAgIH1cblxuICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFbnF1ZXVlKHRoaXMsIGNodW5rKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFcnJvcnMgdGhlIGNvbnRyb2xsZWQgcmVhZGFibGUgc3RyZWFtLCBtYWtpbmcgYWxsIGZ1dHVyZSBpbnRlcmFjdGlvbnMgd2l0aCBpdCBmYWlsIHdpdGggdGhlIGdpdmVuIGVycm9yIGBlYC5cbiAgICovXG4gIGVycm9yKGU6IGFueSA9IHVuZGVmaW5lZCk6IHZvaWQge1xuICAgIGlmICghSXNSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyKHRoaXMpKSB7XG4gICAgICB0aHJvdyBieXRlU3RyZWFtQ29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ2Vycm9yJyk7XG4gICAgfVxuXG4gICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVycm9yKHRoaXMsIGUpO1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBbQ2FuY2VsU3RlcHNdKHJlYXNvbjogYW55KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNsZWFyUGVuZGluZ1B1bGxJbnRvcyh0aGlzKTtcblxuICAgIFJlc2V0UXVldWUodGhpcyk7XG5cbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9jYW5jZWxBbGdvcml0aG0ocmVhc29uKTtcbiAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKHRoaXMpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIFtQdWxsU3RlcHNdKHJlYWRSZXF1ZXN0OiBSZWFkUmVxdWVzdDxVaW50OEFycmF5Pik6IHZvaWQge1xuICAgIGNvbnN0IHN0cmVhbSA9IHRoaXMuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW07XG4gICAgYXNzZXJ0KFJlYWRhYmxlU3RyZWFtSGFzRGVmYXVsdFJlYWRlcihzdHJlYW0pKTtcblxuICAgIGlmICh0aGlzLl9xdWV1ZVRvdGFsU2l6ZSA+IDApIHtcbiAgICAgIGFzc2VydChSZWFkYWJsZVN0cmVhbUdldE51bVJlYWRSZXF1ZXN0cyhzdHJlYW0pID09PSAwKTtcblxuICAgICAgY29uc3QgZW50cnkgPSB0aGlzLl9xdWV1ZS5zaGlmdCgpITtcbiAgICAgIHRoaXMuX3F1ZXVlVG90YWxTaXplIC09IGVudHJ5LmJ5dGVMZW5ndGg7XG5cbiAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJIYW5kbGVRdWV1ZURyYWluKHRoaXMpO1xuXG4gICAgICBjb25zdCB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoZW50cnkuYnVmZmVyLCBlbnRyeS5ieXRlT2Zmc2V0LCBlbnRyeS5ieXRlTGVuZ3RoKTtcblxuICAgICAgcmVhZFJlcXVlc3QuX2NodW5rU3RlcHModmlldyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgYXV0b0FsbG9jYXRlQ2h1bmtTaXplID0gdGhpcy5fYXV0b0FsbG9jYXRlQ2h1bmtTaXplO1xuICAgIGlmIChhdXRvQWxsb2NhdGVDaHVua1NpemUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgbGV0IGJ1ZmZlcjogQXJyYXlCdWZmZXI7XG4gICAgICB0cnkge1xuICAgICAgICBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoYXV0b0FsbG9jYXRlQ2h1bmtTaXplKTtcbiAgICAgIH0gY2F0Y2ggKGJ1ZmZlckUpIHtcbiAgICAgICAgcmVhZFJlcXVlc3QuX2Vycm9yU3RlcHMoYnVmZmVyRSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcHVsbEludG9EZXNjcmlwdG9yOiBEZWZhdWx0UHVsbEludG9EZXNjcmlwdG9yID0ge1xuICAgICAgICBidWZmZXIsXG4gICAgICAgIGJ1ZmZlckJ5dGVMZW5ndGg6IGF1dG9BbGxvY2F0ZUNodW5rU2l6ZSxcbiAgICAgICAgYnl0ZU9mZnNldDogMCxcbiAgICAgICAgYnl0ZUxlbmd0aDogYXV0b0FsbG9jYXRlQ2h1bmtTaXplLFxuICAgICAgICBieXRlc0ZpbGxlZDogMCxcbiAgICAgICAgZWxlbWVudFNpemU6IDEsXG4gICAgICAgIHZpZXdDb25zdHJ1Y3RvcjogVWludDhBcnJheSxcbiAgICAgICAgcmVhZGVyVHlwZTogJ2RlZmF1bHQnXG4gICAgICB9O1xuXG4gICAgICB0aGlzLl9wZW5kaW5nUHVsbEludG9zLnB1c2gocHVsbEludG9EZXNjcmlwdG9yKTtcbiAgICB9XG5cbiAgICBSZWFkYWJsZVN0cmVhbUFkZFJlYWRSZXF1ZXN0KHN0cmVhbSwgcmVhZFJlcXVlc3QpO1xuICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDYWxsUHVsbElmTmVlZGVkKHRoaXMpO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLCB7XG4gIGNsb3NlOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgZW5xdWV1ZTogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gIGVycm9yOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgYnlvYlJlcXVlc3Q6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICBkZXNpcmVkU2l6ZTogeyBlbnVtZXJhYmxlOiB0cnVlIH1cbn0pO1xuaWYgKHR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWcgPT09ICdzeW1ib2wnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7XG4gICAgdmFsdWU6ICdSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyJyxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbi8vIEFic3RyYWN0IG9wZXJhdGlvbnMgZm9yIHRoZSBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyLlxuXG5leHBvcnQgZnVuY3Rpb24gSXNSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyKHg6IGFueSk6IHggaXMgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlciB7XG4gIGlmICghdHlwZUlzT2JqZWN0KHgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ19jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtJykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4geCBpbnN0YW5jZW9mIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXI7XG59XG5cbmZ1bmN0aW9uIElzUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdCh4OiBhbnkpOiB4IGlzIFJlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3Qge1xuICBpZiAoIXR5cGVJc09iamVjdCh4KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdfYXNzb2NpYXRlZFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXInKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB4IGluc3RhbmNlb2YgUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdDtcbn1cblxuZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNhbGxQdWxsSWZOZWVkZWQoY29udHJvbGxlcjogUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcik6IHZvaWQge1xuICBjb25zdCBzaG91bGRQdWxsID0gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclNob3VsZENhbGxQdWxsKGNvbnRyb2xsZXIpO1xuICBpZiAoIXNob3VsZFB1bGwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoY29udHJvbGxlci5fcHVsbGluZykge1xuICAgIGNvbnRyb2xsZXIuX3B1bGxBZ2FpbiA9IHRydWU7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgYXNzZXJ0KCFjb250cm9sbGVyLl9wdWxsQWdhaW4pO1xuXG4gIGNvbnRyb2xsZXIuX3B1bGxpbmcgPSB0cnVlO1xuXG4gIC8vIFRPRE86IFRlc3QgY29udHJvbGxlciBhcmd1bWVudFxuICBjb25zdCBwdWxsUHJvbWlzZSA9IGNvbnRyb2xsZXIuX3B1bGxBbGdvcml0aG0oKTtcbiAgdXBvblByb21pc2UoXG4gICAgcHVsbFByb21pc2UsXG4gICAgKCkgPT4ge1xuICAgICAgY29udHJvbGxlci5fcHVsbGluZyA9IGZhbHNlO1xuXG4gICAgICBpZiAoY29udHJvbGxlci5fcHVsbEFnYWluKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuX3B1bGxBZ2FpbiA9IGZhbHNlO1xuICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2FsbFB1bGxJZk5lZWRlZChjb250cm9sbGVyKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGUgPT4ge1xuICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVycm9yKGNvbnRyb2xsZXIsIGUpO1xuICAgIH1cbiAgKTtcbn1cblxuZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNsZWFyUGVuZGluZ1B1bGxJbnRvcyhjb250cm9sbGVyOiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyKSB7XG4gIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJJbnZhbGlkYXRlQllPQlJlcXVlc3QoY29udHJvbGxlcik7XG4gIGNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MgPSBuZXcgU2ltcGxlUXVldWUoKTtcbn1cblxuZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNvbW1pdFB1bGxJbnRvRGVzY3JpcHRvcjxUIGV4dGVuZHMgQXJyYXlCdWZmZXJWaWV3PihcbiAgc3RyZWFtOiBSZWFkYWJsZUJ5dGVTdHJlYW0sXG4gIHB1bGxJbnRvRGVzY3JpcHRvcjogUHVsbEludG9EZXNjcmlwdG9yPFQ+XG4pIHtcbiAgYXNzZXJ0KHN0cmVhbS5fc3RhdGUgIT09ICdlcnJvcmVkJyk7XG5cbiAgbGV0IGRvbmUgPSBmYWxzZTtcbiAgaWYgKHN0cmVhbS5fc3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICAgYXNzZXJ0KHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlc0ZpbGxlZCA9PT0gMCk7XG4gICAgZG9uZSA9IHRydWU7XG4gIH1cblxuICBjb25zdCBmaWxsZWRWaWV3ID0gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNvbnZlcnRQdWxsSW50b0Rlc2NyaXB0b3I8VD4ocHVsbEludG9EZXNjcmlwdG9yKTtcbiAgaWYgKHB1bGxJbnRvRGVzY3JpcHRvci5yZWFkZXJUeXBlID09PSAnZGVmYXVsdCcpIHtcbiAgICBSZWFkYWJsZVN0cmVhbUZ1bGZpbGxSZWFkUmVxdWVzdChzdHJlYW0sIGZpbGxlZFZpZXcgYXMgdW5rbm93biBhcyBVaW50OEFycmF5LCBkb25lKTtcbiAgfSBlbHNlIHtcbiAgICBhc3NlcnQocHVsbEludG9EZXNjcmlwdG9yLnJlYWRlclR5cGUgPT09ICdieW9iJyk7XG4gICAgUmVhZGFibGVTdHJlYW1GdWxmaWxsUmVhZEludG9SZXF1ZXN0KHN0cmVhbSwgZmlsbGVkVmlldywgZG9uZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNvbnZlcnRQdWxsSW50b0Rlc2NyaXB0b3I8VCBleHRlbmRzIEFycmF5QnVmZmVyVmlldz4oXG4gIHB1bGxJbnRvRGVzY3JpcHRvcjogUHVsbEludG9EZXNjcmlwdG9yPFQ+XG4pOiBUIHtcbiAgY29uc3QgYnl0ZXNGaWxsZWQgPSBwdWxsSW50b0Rlc2NyaXB0b3IuYnl0ZXNGaWxsZWQ7XG4gIGNvbnN0IGVsZW1lbnRTaXplID0gcHVsbEludG9EZXNjcmlwdG9yLmVsZW1lbnRTaXplO1xuXG4gIGFzc2VydChieXRlc0ZpbGxlZCA8PSBwdWxsSW50b0Rlc2NyaXB0b3IuYnl0ZUxlbmd0aCk7XG4gIGFzc2VydChieXRlc0ZpbGxlZCAlIGVsZW1lbnRTaXplID09PSAwKTtcblxuICByZXR1cm4gbmV3IHB1bGxJbnRvRGVzY3JpcHRvci52aWV3Q29uc3RydWN0b3IoXG4gICAgcHVsbEludG9EZXNjcmlwdG9yLmJ1ZmZlciwgcHVsbEludG9EZXNjcmlwdG9yLmJ5dGVPZmZzZXQsIGJ5dGVzRmlsbGVkIC8gZWxlbWVudFNpemUpIGFzIFQ7XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFbnF1ZXVlQ2h1bmtUb1F1ZXVlKGNvbnRyb2xsZXI6IFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXI6IEFycmF5QnVmZmVyTGlrZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVPZmZzZXQ6IG51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVMZW5ndGg6IG51bWJlcikge1xuICBjb250cm9sbGVyLl9xdWV1ZS5wdXNoKHsgYnVmZmVyLCBieXRlT2Zmc2V0LCBieXRlTGVuZ3RoIH0pO1xuICBjb250cm9sbGVyLl9xdWV1ZVRvdGFsU2l6ZSArPSBieXRlTGVuZ3RoO1xufVxuXG5mdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRmlsbFB1bGxJbnRvRGVzY3JpcHRvckZyb21RdWV1ZShjb250cm9sbGVyOiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHVsbEludG9EZXNjcmlwdG9yOiBQdWxsSW50b0Rlc2NyaXB0b3IpIHtcbiAgY29uc3QgZWxlbWVudFNpemUgPSBwdWxsSW50b0Rlc2NyaXB0b3IuZWxlbWVudFNpemU7XG5cbiAgY29uc3QgY3VycmVudEFsaWduZWRCeXRlcyA9IHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlc0ZpbGxlZCAtIHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlc0ZpbGxlZCAlIGVsZW1lbnRTaXplO1xuXG4gIGNvbnN0IG1heEJ5dGVzVG9Db3B5ID0gTWF0aC5taW4oY29udHJvbGxlci5fcXVldWVUb3RhbFNpemUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHVsbEludG9EZXNjcmlwdG9yLmJ5dGVMZW5ndGggLSBwdWxsSW50b0Rlc2NyaXB0b3IuYnl0ZXNGaWxsZWQpO1xuICBjb25zdCBtYXhCeXRlc0ZpbGxlZCA9IHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlc0ZpbGxlZCArIG1heEJ5dGVzVG9Db3B5O1xuICBjb25zdCBtYXhBbGlnbmVkQnl0ZXMgPSBtYXhCeXRlc0ZpbGxlZCAtIG1heEJ5dGVzRmlsbGVkICUgZWxlbWVudFNpemU7XG5cbiAgbGV0IHRvdGFsQnl0ZXNUb0NvcHlSZW1haW5pbmcgPSBtYXhCeXRlc1RvQ29weTtcbiAgbGV0IHJlYWR5ID0gZmFsc2U7XG4gIGlmIChtYXhBbGlnbmVkQnl0ZXMgPiBjdXJyZW50QWxpZ25lZEJ5dGVzKSB7XG4gICAgdG90YWxCeXRlc1RvQ29weVJlbWFpbmluZyA9IG1heEFsaWduZWRCeXRlcyAtIHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlc0ZpbGxlZDtcbiAgICByZWFkeSA9IHRydWU7XG4gIH1cblxuICBjb25zdCBxdWV1ZSA9IGNvbnRyb2xsZXIuX3F1ZXVlO1xuXG4gIHdoaWxlICh0b3RhbEJ5dGVzVG9Db3B5UmVtYWluaW5nID4gMCkge1xuICAgIGNvbnN0IGhlYWRPZlF1ZXVlID0gcXVldWUucGVlaygpO1xuXG4gICAgY29uc3QgYnl0ZXNUb0NvcHkgPSBNYXRoLm1pbih0b3RhbEJ5dGVzVG9Db3B5UmVtYWluaW5nLCBoZWFkT2ZRdWV1ZS5ieXRlTGVuZ3RoKTtcblxuICAgIGNvbnN0IGRlc3RTdGFydCA9IHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlT2Zmc2V0ICsgcHVsbEludG9EZXNjcmlwdG9yLmJ5dGVzRmlsbGVkO1xuICAgIENvcHlEYXRhQmxvY2tCeXRlcyhwdWxsSW50b0Rlc2NyaXB0b3IuYnVmZmVyLCBkZXN0U3RhcnQsIGhlYWRPZlF1ZXVlLmJ1ZmZlciwgaGVhZE9mUXVldWUuYnl0ZU9mZnNldCwgYnl0ZXNUb0NvcHkpO1xuXG4gICAgaWYgKGhlYWRPZlF1ZXVlLmJ5dGVMZW5ndGggPT09IGJ5dGVzVG9Db3B5KSB7XG4gICAgICBxdWV1ZS5zaGlmdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBoZWFkT2ZRdWV1ZS5ieXRlT2Zmc2V0ICs9IGJ5dGVzVG9Db3B5O1xuICAgICAgaGVhZE9mUXVldWUuYnl0ZUxlbmd0aCAtPSBieXRlc1RvQ29weTtcbiAgICB9XG4gICAgY29udHJvbGxlci5fcXVldWVUb3RhbFNpemUgLT0gYnl0ZXNUb0NvcHk7XG5cbiAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRmlsbEhlYWRQdWxsSW50b0Rlc2NyaXB0b3IoY29udHJvbGxlciwgYnl0ZXNUb0NvcHksIHB1bGxJbnRvRGVzY3JpcHRvcik7XG5cbiAgICB0b3RhbEJ5dGVzVG9Db3B5UmVtYWluaW5nIC09IGJ5dGVzVG9Db3B5O1xuICB9XG5cbiAgaWYgKCFyZWFkeSkge1xuICAgIGFzc2VydChjb250cm9sbGVyLl9xdWV1ZVRvdGFsU2l6ZSA9PT0gMCk7XG4gICAgYXNzZXJ0KHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlc0ZpbGxlZCA+IDApO1xuICAgIGFzc2VydChwdWxsSW50b0Rlc2NyaXB0b3IuYnl0ZXNGaWxsZWQgPCBwdWxsSW50b0Rlc2NyaXB0b3IuZWxlbWVudFNpemUpO1xuICB9XG5cbiAgcmV0dXJuIHJlYWR5O1xufVxuXG5mdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRmlsbEhlYWRQdWxsSW50b0Rlc2NyaXB0b3IoY29udHJvbGxlcjogUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaXplOiBudW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHVsbEludG9EZXNjcmlwdG9yOiBQdWxsSW50b0Rlc2NyaXB0b3IpIHtcbiAgYXNzZXJ0KGNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MubGVuZ3RoID09PSAwIHx8IGNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MucGVlaygpID09PSBwdWxsSW50b0Rlc2NyaXB0b3IpO1xuICBhc3NlcnQoY29udHJvbGxlci5fYnlvYlJlcXVlc3QgPT09IG51bGwpO1xuICBwdWxsSW50b0Rlc2NyaXB0b3IuYnl0ZXNGaWxsZWQgKz0gc2l6ZTtcbn1cblxuZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckhhbmRsZVF1ZXVlRHJhaW4oY29udHJvbGxlcjogUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcikge1xuICBhc3NlcnQoY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbS5fc3RhdGUgPT09ICdyZWFkYWJsZScpO1xuXG4gIGlmIChjb250cm9sbGVyLl9xdWV1ZVRvdGFsU2l6ZSA9PT0gMCAmJiBjb250cm9sbGVyLl9jbG9zZVJlcXVlc3RlZCkge1xuICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDbGVhckFsZ29yaXRobXMoY29udHJvbGxlcik7XG4gICAgUmVhZGFibGVTdHJlYW1DbG9zZShjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtKTtcbiAgfSBlbHNlIHtcbiAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2FsbFB1bGxJZk5lZWRlZChjb250cm9sbGVyKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVySW52YWxpZGF0ZUJZT0JSZXF1ZXN0KGNvbnRyb2xsZXI6IFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIpIHtcbiAgaWYgKGNvbnRyb2xsZXIuX2J5b2JSZXF1ZXN0ID09PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29udHJvbGxlci5fYnlvYlJlcXVlc3QuX2Fzc29jaWF0ZWRSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyID0gdW5kZWZpbmVkITtcbiAgY29udHJvbGxlci5fYnlvYlJlcXVlc3QuX3ZpZXcgPSBudWxsITtcbiAgY29udHJvbGxlci5fYnlvYlJlcXVlc3QgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUHJvY2Vzc1B1bGxJbnRvRGVzY3JpcHRvcnNVc2luZ1F1ZXVlKGNvbnRyb2xsZXI6IFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIpIHtcbiAgYXNzZXJ0KCFjb250cm9sbGVyLl9jbG9zZVJlcXVlc3RlZCk7XG5cbiAgd2hpbGUgKGNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MubGVuZ3RoID4gMCkge1xuICAgIGlmIChjb250cm9sbGVyLl9xdWV1ZVRvdGFsU2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHB1bGxJbnRvRGVzY3JpcHRvciA9IGNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MucGVlaygpO1xuXG4gICAgaWYgKFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJGaWxsUHVsbEludG9EZXNjcmlwdG9yRnJvbVF1ZXVlKGNvbnRyb2xsZXIsIHB1bGxJbnRvRGVzY3JpcHRvcikpIHtcbiAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJTaGlmdFBlbmRpbmdQdWxsSW50byhjb250cm9sbGVyKTtcblxuICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNvbW1pdFB1bGxJbnRvRGVzY3JpcHRvcihcbiAgICAgICAgY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbSxcbiAgICAgICAgcHVsbEludG9EZXNjcmlwdG9yXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclB1bGxJbnRvPFQgZXh0ZW5kcyBBcnJheUJ1ZmZlclZpZXc+KFxuICBjb250cm9sbGVyOiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyLFxuICB2aWV3OiBULFxuICByZWFkSW50b1JlcXVlc3Q6IFJlYWRJbnRvUmVxdWVzdDxUPlxuKTogdm9pZCB7XG4gIGNvbnN0IHN0cmVhbSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW07XG5cbiAgbGV0IGVsZW1lbnRTaXplID0gMTtcbiAgaWYgKHZpZXcuY29uc3RydWN0b3IgIT09IERhdGFWaWV3KSB7XG4gICAgZWxlbWVudFNpemUgPSAodmlldy5jb25zdHJ1Y3RvciBhcyBBcnJheUJ1ZmZlclZpZXdDb25zdHJ1Y3RvcjxUPikuQllURVNfUEVSX0VMRU1FTlQ7XG4gIH1cblxuICBjb25zdCBjdG9yID0gdmlldy5jb25zdHJ1Y3RvciBhcyBBcnJheUJ1ZmZlclZpZXdDb25zdHJ1Y3RvcjxUPjtcblxuICAvLyB0cnkge1xuICBjb25zdCBidWZmZXIgPSBUcmFuc2ZlckFycmF5QnVmZmVyKHZpZXcuYnVmZmVyKTtcbiAgLy8gfSBjYXRjaCAoZSkge1xuICAvLyAgIHJlYWRJbnRvUmVxdWVzdC5fZXJyb3JTdGVwcyhlKTtcbiAgLy8gICByZXR1cm47XG4gIC8vIH1cblxuICBjb25zdCBwdWxsSW50b0Rlc2NyaXB0b3I6IEJZT0JQdWxsSW50b0Rlc2NyaXB0b3I8VD4gPSB7XG4gICAgYnVmZmVyLFxuICAgIGJ1ZmZlckJ5dGVMZW5ndGg6IGJ1ZmZlci5ieXRlTGVuZ3RoLFxuICAgIGJ5dGVPZmZzZXQ6IHZpZXcuYnl0ZU9mZnNldCxcbiAgICBieXRlTGVuZ3RoOiB2aWV3LmJ5dGVMZW5ndGgsXG4gICAgYnl0ZXNGaWxsZWQ6IDAsXG4gICAgZWxlbWVudFNpemUsXG4gICAgdmlld0NvbnN0cnVjdG9yOiBjdG9yLFxuICAgIHJlYWRlclR5cGU6ICdieW9iJ1xuICB9O1xuXG4gIGlmIChjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLmxlbmd0aCA+IDApIHtcbiAgICBjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLnB1c2gocHVsbEludG9EZXNjcmlwdG9yKTtcblxuICAgIC8vIE5vIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDYWxsUHVsbElmTmVlZGVkKCkgY2FsbCBzaW5jZTpcbiAgICAvLyAtIE5vIGNoYW5nZSBoYXBwZW5zIG9uIGRlc2lyZWRTaXplXG4gICAgLy8gLSBUaGUgc291cmNlIGhhcyBhbHJlYWR5IGJlZW4gbm90aWZpZWQgb2YgdGhhdCB0aGVyZSdzIGF0IGxlYXN0IDEgcGVuZGluZyByZWFkKHZpZXcpXG5cbiAgICBSZWFkYWJsZVN0cmVhbUFkZFJlYWRJbnRvUmVxdWVzdChzdHJlYW0sIHJlYWRJbnRvUmVxdWVzdCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHN0cmVhbS5fc3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICAgY29uc3QgZW1wdHlWaWV3ID0gbmV3IGN0b3IocHVsbEludG9EZXNjcmlwdG9yLmJ1ZmZlciwgcHVsbEludG9EZXNjcmlwdG9yLmJ5dGVPZmZzZXQsIDApO1xuICAgIHJlYWRJbnRvUmVxdWVzdC5fY2xvc2VTdGVwcyhlbXB0eVZpZXcpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChjb250cm9sbGVyLl9xdWV1ZVRvdGFsU2l6ZSA+IDApIHtcbiAgICBpZiAoUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckZpbGxQdWxsSW50b0Rlc2NyaXB0b3JGcm9tUXVldWUoY29udHJvbGxlciwgcHVsbEludG9EZXNjcmlwdG9yKSkge1xuICAgICAgY29uc3QgZmlsbGVkVmlldyA9IFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDb252ZXJ0UHVsbEludG9EZXNjcmlwdG9yPFQ+KHB1bGxJbnRvRGVzY3JpcHRvcik7XG5cbiAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJIYW5kbGVRdWV1ZURyYWluKGNvbnRyb2xsZXIpO1xuXG4gICAgICByZWFkSW50b1JlcXVlc3QuX2NodW5rU3RlcHMoZmlsbGVkVmlldyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGNvbnRyb2xsZXIuX2Nsb3NlUmVxdWVzdGVkKSB7XG4gICAgICBjb25zdCBlID0gbmV3IFR5cGVFcnJvcignSW5zdWZmaWNpZW50IGJ5dGVzIHRvIGZpbGwgZWxlbWVudHMgaW4gdGhlIGdpdmVuIGJ1ZmZlcicpO1xuICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVycm9yKGNvbnRyb2xsZXIsIGUpO1xuXG4gICAgICByZWFkSW50b1JlcXVlc3QuX2Vycm9yU3RlcHMoZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5wdXNoKHB1bGxJbnRvRGVzY3JpcHRvcik7XG5cbiAgUmVhZGFibGVTdHJlYW1BZGRSZWFkSW50b1JlcXVlc3Q8VD4oc3RyZWFtLCByZWFkSW50b1JlcXVlc3QpO1xuICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2FsbFB1bGxJZk5lZWRlZChjb250cm9sbGVyKTtcbn1cblxuZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmRJbkNsb3NlZFN0YXRlKGNvbnRyb2xsZXI6IFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3REZXNjcmlwdG9yOiBQdWxsSW50b0Rlc2NyaXB0b3IpIHtcbiAgYXNzZXJ0KGZpcnN0RGVzY3JpcHRvci5ieXRlc0ZpbGxlZCA9PT0gMCk7XG5cbiAgY29uc3Qgc3RyZWFtID0gY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbTtcbiAgaWYgKFJlYWRhYmxlU3RyZWFtSGFzQllPQlJlYWRlcihzdHJlYW0pKSB7XG4gICAgd2hpbGUgKFJlYWRhYmxlU3RyZWFtR2V0TnVtUmVhZEludG9SZXF1ZXN0cyhzdHJlYW0pID4gMCkge1xuICAgICAgY29uc3QgcHVsbEludG9EZXNjcmlwdG9yID0gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclNoaWZ0UGVuZGluZ1B1bGxJbnRvKGNvbnRyb2xsZXIpO1xuICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNvbW1pdFB1bGxJbnRvRGVzY3JpcHRvcihzdHJlYW0sIHB1bGxJbnRvRGVzY3JpcHRvcik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kSW5SZWFkYWJsZVN0YXRlKGNvbnRyb2xsZXI6IFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBieXRlc1dyaXR0ZW46IG51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1bGxJbnRvRGVzY3JpcHRvcjogUHVsbEludG9EZXNjcmlwdG9yKSB7XG4gIGFzc2VydChwdWxsSW50b0Rlc2NyaXB0b3IuYnl0ZXNGaWxsZWQgKyBieXRlc1dyaXR0ZW4gPD0gcHVsbEludG9EZXNjcmlwdG9yLmJ5dGVMZW5ndGgpO1xuXG4gIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJGaWxsSGVhZFB1bGxJbnRvRGVzY3JpcHRvcihjb250cm9sbGVyLCBieXRlc1dyaXR0ZW4sIHB1bGxJbnRvRGVzY3JpcHRvcik7XG5cbiAgaWYgKHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlc0ZpbGxlZCA8IHB1bGxJbnRvRGVzY3JpcHRvci5lbGVtZW50U2l6ZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJTaGlmdFBlbmRpbmdQdWxsSW50byhjb250cm9sbGVyKTtcblxuICBjb25zdCByZW1haW5kZXJTaXplID0gcHVsbEludG9EZXNjcmlwdG9yLmJ5dGVzRmlsbGVkICUgcHVsbEludG9EZXNjcmlwdG9yLmVsZW1lbnRTaXplO1xuICBpZiAocmVtYWluZGVyU2l6ZSA+IDApIHtcbiAgICBjb25zdCBlbmQgPSBwdWxsSW50b0Rlc2NyaXB0b3IuYnl0ZU9mZnNldCArIHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlc0ZpbGxlZDtcbiAgICBjb25zdCByZW1haW5kZXIgPSBBcnJheUJ1ZmZlclNsaWNlKHB1bGxJbnRvRGVzY3JpcHRvci5idWZmZXIsIGVuZCAtIHJlbWFpbmRlclNpemUsIGVuZCk7XG4gICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVucXVldWVDaHVua1RvUXVldWUoY29udHJvbGxlciwgcmVtYWluZGVyLCAwLCByZW1haW5kZXIuYnl0ZUxlbmd0aCk7XG4gIH1cblxuICBwdWxsSW50b0Rlc2NyaXB0b3IuYnl0ZXNGaWxsZWQgLT0gcmVtYWluZGVyU2l6ZTtcbiAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNvbW1pdFB1bGxJbnRvRGVzY3JpcHRvcihjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtLCBwdWxsSW50b0Rlc2NyaXB0b3IpO1xuXG4gIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJQcm9jZXNzUHVsbEludG9EZXNjcmlwdG9yc1VzaW5nUXVldWUoY29udHJvbGxlcik7XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kSW50ZXJuYWwoY29udHJvbGxlcjogUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlciwgYnl0ZXNXcml0dGVuOiBudW1iZXIpIHtcbiAgY29uc3QgZmlyc3REZXNjcmlwdG9yID0gY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5wZWVrKCk7XG4gIGFzc2VydChDYW5UcmFuc2ZlckFycmF5QnVmZmVyKGZpcnN0RGVzY3JpcHRvci5idWZmZXIpKTtcblxuICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVySW52YWxpZGF0ZUJZT0JSZXF1ZXN0KGNvbnRyb2xsZXIpO1xuXG4gIGNvbnN0IHN0YXRlID0gY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbS5fc3RhdGU7XG4gIGlmIChzdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICBhc3NlcnQoYnl0ZXNXcml0dGVuID09PSAwKTtcbiAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZEluQ2xvc2VkU3RhdGUoY29udHJvbGxlciwgZmlyc3REZXNjcmlwdG9yKTtcbiAgfSBlbHNlIHtcbiAgICBhc3NlcnQoc3RhdGUgPT09ICdyZWFkYWJsZScpO1xuICAgIGFzc2VydChieXRlc1dyaXR0ZW4gPiAwKTtcbiAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZEluUmVhZGFibGVTdGF0ZShjb250cm9sbGVyLCBieXRlc1dyaXR0ZW4sIGZpcnN0RGVzY3JpcHRvcik7XG4gIH1cblxuICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2FsbFB1bGxJZk5lZWRlZChjb250cm9sbGVyKTtcbn1cblxuZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclNoaWZ0UGVuZGluZ1B1bGxJbnRvKFxuICBjb250cm9sbGVyOiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyXG4pOiBQdWxsSW50b0Rlc2NyaXB0b3Ige1xuICBhc3NlcnQoY29udHJvbGxlci5fYnlvYlJlcXVlc3QgPT09IG51bGwpO1xuICBjb25zdCBkZXNjcmlwdG9yID0gY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5zaGlmdCgpITtcbiAgcmV0dXJuIGRlc2NyaXB0b3I7XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJTaG91bGRDYWxsUHVsbChjb250cm9sbGVyOiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyKTogYm9vbGVhbiB7XG4gIGNvbnN0IHN0cmVhbSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW07XG5cbiAgaWYgKHN0cmVhbS5fc3RhdGUgIT09ICdyZWFkYWJsZScpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoY29udHJvbGxlci5fY2xvc2VSZXF1ZXN0ZWQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoIWNvbnRyb2xsZXIuX3N0YXJ0ZWQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoUmVhZGFibGVTdHJlYW1IYXNEZWZhdWx0UmVhZGVyKHN0cmVhbSkgJiYgUmVhZGFibGVTdHJlYW1HZXROdW1SZWFkUmVxdWVzdHMoc3RyZWFtKSA+IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChSZWFkYWJsZVN0cmVhbUhhc0JZT0JSZWFkZXIoc3RyZWFtKSAmJiBSZWFkYWJsZVN0cmVhbUdldE51bVJlYWRJbnRvUmVxdWVzdHMoc3RyZWFtKSA+IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGNvbnN0IGRlc2lyZWRTaXplID0gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckdldERlc2lyZWRTaXplKGNvbnRyb2xsZXIpO1xuICBhc3NlcnQoZGVzaXJlZFNpemUgIT09IG51bGwpO1xuICBpZiAoZGVzaXJlZFNpemUhID4gMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKGNvbnRyb2xsZXI6IFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIpIHtcbiAgY29udHJvbGxlci5fcHVsbEFsZ29yaXRobSA9IHVuZGVmaW5lZCE7XG4gIGNvbnRyb2xsZXIuX2NhbmNlbEFsZ29yaXRobSA9IHVuZGVmaW5lZCE7XG59XG5cbi8vIEEgY2xpZW50IG9mIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIgbWF5IHVzZSB0aGVzZSBmdW5jdGlvbnMgZGlyZWN0bHkgdG8gYnlwYXNzIHN0YXRlIGNoZWNrLlxuXG5leHBvcnQgZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNsb3NlKGNvbnRyb2xsZXI6IFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIpIHtcbiAgY29uc3Qgc3RyZWFtID0gY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbTtcblxuICBpZiAoY29udHJvbGxlci5fY2xvc2VSZXF1ZXN0ZWQgfHwgc3RyZWFtLl9zdGF0ZSAhPT0gJ3JlYWRhYmxlJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChjb250cm9sbGVyLl9xdWV1ZVRvdGFsU2l6ZSA+IDApIHtcbiAgICBjb250cm9sbGVyLl9jbG9zZVJlcXVlc3RlZCA9IHRydWU7XG5cbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgZmlyc3RQZW5kaW5nUHVsbEludG8gPSBjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLnBlZWsoKTtcbiAgICBpZiAoZmlyc3RQZW5kaW5nUHVsbEludG8uYnl0ZXNGaWxsZWQgPiAwKSB7XG4gICAgICBjb25zdCBlID0gbmV3IFR5cGVFcnJvcignSW5zdWZmaWNpZW50IGJ5dGVzIHRvIGZpbGwgZWxlbWVudHMgaW4gdGhlIGdpdmVuIGJ1ZmZlcicpO1xuICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVycm9yKGNvbnRyb2xsZXIsIGUpO1xuXG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgfVxuXG4gIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDbGVhckFsZ29yaXRobXMoY29udHJvbGxlcik7XG4gIFJlYWRhYmxlU3RyZWFtQ2xvc2Uoc3RyZWFtKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFbnF1ZXVlKGNvbnRyb2xsZXI6IFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIsIGNodW5rOiBBcnJheUJ1ZmZlclZpZXcpIHtcbiAgY29uc3Qgc3RyZWFtID0gY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbTtcblxuICBpZiAoY29udHJvbGxlci5fY2xvc2VSZXF1ZXN0ZWQgfHwgc3RyZWFtLl9zdGF0ZSAhPT0gJ3JlYWRhYmxlJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IGJ1ZmZlciA9IGNodW5rLmJ1ZmZlcjtcbiAgY29uc3QgYnl0ZU9mZnNldCA9IGNodW5rLmJ5dGVPZmZzZXQ7XG4gIGNvbnN0IGJ5dGVMZW5ndGggPSBjaHVuay5ieXRlTGVuZ3RoO1xuICBpZiAoSXNEZXRhY2hlZEJ1ZmZlcihidWZmZXIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2h1bmtcXCdzIGJ1ZmZlciBpcyBkZXRhY2hlZCBhbmQgc28gY2Fubm90IGJlIGVucXVldWVkJyk7XG4gIH1cbiAgY29uc3QgdHJhbnNmZXJyZWRCdWZmZXIgPSBUcmFuc2ZlckFycmF5QnVmZmVyKGJ1ZmZlcik7XG5cbiAgaWYgKGNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IGZpcnN0UGVuZGluZ1B1bGxJbnRvID0gY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5wZWVrKCk7XG4gICAgaWYgKElzRGV0YWNoZWRCdWZmZXIoZmlyc3RQZW5kaW5nUHVsbEludG8uYnVmZmVyKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ1RoZSBCWU9CIHJlcXVlc3RcXCdzIGJ1ZmZlciBoYXMgYmVlbiBkZXRhY2hlZCBhbmQgc28gY2Fubm90IGJlIGZpbGxlZCB3aXRoIGFuIGVucXVldWVkIGNodW5rJ1xuICAgICAgKTtcbiAgICB9XG4gICAgZmlyc3RQZW5kaW5nUHVsbEludG8uYnVmZmVyID0gVHJhbnNmZXJBcnJheUJ1ZmZlcihmaXJzdFBlbmRpbmdQdWxsSW50by5idWZmZXIpO1xuICB9XG5cbiAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckludmFsaWRhdGVCWU9CUmVxdWVzdChjb250cm9sbGVyKTtcblxuICBpZiAoUmVhZGFibGVTdHJlYW1IYXNEZWZhdWx0UmVhZGVyKHN0cmVhbSkpIHtcbiAgICBpZiAoUmVhZGFibGVTdHJlYW1HZXROdW1SZWFkUmVxdWVzdHMoc3RyZWFtKSA9PT0gMCkge1xuICAgICAgYXNzZXJ0KGNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MubGVuZ3RoID09PSAwKTtcbiAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFbnF1ZXVlQ2h1bmtUb1F1ZXVlKGNvbnRyb2xsZXIsIHRyYW5zZmVycmVkQnVmZmVyLCBieXRlT2Zmc2V0LCBieXRlTGVuZ3RoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzZXJ0KGNvbnRyb2xsZXIuX3F1ZXVlLmxlbmd0aCA9PT0gMCk7XG4gICAgICBpZiAoY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGFzc2VydChjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLnBlZWsoKS5yZWFkZXJUeXBlID09PSAnZGVmYXVsdCcpO1xuICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyU2hpZnRQZW5kaW5nUHVsbEludG8oY29udHJvbGxlcik7XG4gICAgICB9XG4gICAgICBjb25zdCB0cmFuc2ZlcnJlZFZpZXcgPSBuZXcgVWludDhBcnJheSh0cmFuc2ZlcnJlZEJ1ZmZlciwgYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aCk7XG4gICAgICBSZWFkYWJsZVN0cmVhbUZ1bGZpbGxSZWFkUmVxdWVzdChzdHJlYW0sIHRyYW5zZmVycmVkVmlldywgZmFsc2UpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChSZWFkYWJsZVN0cmVhbUhhc0JZT0JSZWFkZXIoc3RyZWFtKSkge1xuICAgIC8vIFRPRE86IElkZWFsbHkgaW4gdGhpcyBicmFuY2ggZGV0YWNoaW5nIHNob3VsZCBoYXBwZW4gb25seSBpZiB0aGUgYnVmZmVyIGlzIG5vdCBjb25zdW1lZCBmdWxseS5cbiAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRW5xdWV1ZUNodW5rVG9RdWV1ZShjb250cm9sbGVyLCB0cmFuc2ZlcnJlZEJ1ZmZlciwgYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aCk7XG4gICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclByb2Nlc3NQdWxsSW50b0Rlc2NyaXB0b3JzVXNpbmdRdWV1ZShjb250cm9sbGVyKTtcbiAgfSBlbHNlIHtcbiAgICBhc3NlcnQoIUlzUmVhZGFibGVTdHJlYW1Mb2NrZWQoc3RyZWFtKSk7XG4gICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVucXVldWVDaHVua1RvUXVldWUoY29udHJvbGxlciwgdHJhbnNmZXJyZWRCdWZmZXIsIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGgpO1xuICB9XG5cbiAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNhbGxQdWxsSWZOZWVkZWQoY29udHJvbGxlcik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRXJyb3IoY29udHJvbGxlcjogUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlciwgZTogYW55KSB7XG4gIGNvbnN0IHN0cmVhbSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW07XG5cbiAgaWYgKHN0cmVhbS5fc3RhdGUgIT09ICdyZWFkYWJsZScpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2xlYXJQZW5kaW5nUHVsbEludG9zKGNvbnRyb2xsZXIpO1xuXG4gIFJlc2V0UXVldWUoY29udHJvbGxlcik7XG4gIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDbGVhckFsZ29yaXRobXMoY29udHJvbGxlcik7XG4gIFJlYWRhYmxlU3RyZWFtRXJyb3Ioc3RyZWFtLCBlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJHZXRCWU9CUmVxdWVzdChcbiAgY29udHJvbGxlcjogUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclxuKTogUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdCB8IG51bGwge1xuICBpZiAoY29udHJvbGxlci5fYnlvYlJlcXVlc3QgPT09IG51bGwgJiYgY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgZmlyc3REZXNjcmlwdG9yID0gY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5wZWVrKCk7XG4gICAgY29uc3QgdmlldyA9IG5ldyBVaW50OEFycmF5KGZpcnN0RGVzY3JpcHRvci5idWZmZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0RGVzY3JpcHRvci5ieXRlT2Zmc2V0ICsgZmlyc3REZXNjcmlwdG9yLmJ5dGVzRmlsbGVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXJzdERlc2NyaXB0b3IuYnl0ZUxlbmd0aCAtIGZpcnN0RGVzY3JpcHRvci5ieXRlc0ZpbGxlZCk7XG5cbiAgICBjb25zdCBieW9iUmVxdWVzdDogUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdCA9IE9iamVjdC5jcmVhdGUoUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdC5wcm90b3R5cGUpO1xuICAgIFNldFVwUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdChieW9iUmVxdWVzdCwgY29udHJvbGxlciwgdmlldyk7XG4gICAgY29udHJvbGxlci5fYnlvYlJlcXVlc3QgPSBieW9iUmVxdWVzdDtcbiAgfVxuICByZXR1cm4gY29udHJvbGxlci5fYnlvYlJlcXVlc3Q7XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJHZXREZXNpcmVkU2l6ZShjb250cm9sbGVyOiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyKTogbnVtYmVyIHwgbnVsbCB7XG4gIGNvbnN0IHN0YXRlID0gY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbS5fc3RhdGU7XG5cbiAgaWYgKHN0YXRlID09PSAnZXJyb3JlZCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoc3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICByZXR1cm4gY29udHJvbGxlci5fc3RyYXRlZ3lIV00gLSBjb250cm9sbGVyLl9xdWV1ZVRvdGFsU2l6ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kKGNvbnRyb2xsZXI6IFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIsIGJ5dGVzV3JpdHRlbjogbnVtYmVyKSB7XG4gIGFzc2VydChjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLmxlbmd0aCA+IDApO1xuXG4gIGNvbnN0IGZpcnN0RGVzY3JpcHRvciA9IGNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MucGVlaygpO1xuICBjb25zdCBzdGF0ZSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW0uX3N0YXRlO1xuXG4gIGlmIChzdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICBpZiAoYnl0ZXNXcml0dGVuICE9PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdieXRlc1dyaXR0ZW4gbXVzdCBiZSAwIHdoZW4gY2FsbGluZyByZXNwb25kKCkgb24gYSBjbG9zZWQgc3RyZWFtJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGFzc2VydChzdGF0ZSA9PT0gJ3JlYWRhYmxlJyk7XG4gICAgaWYgKGJ5dGVzV3JpdHRlbiA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYnl0ZXNXcml0dGVuIG11c3QgYmUgZ3JlYXRlciB0aGFuIDAgd2hlbiBjYWxsaW5nIHJlc3BvbmQoKSBvbiBhIHJlYWRhYmxlIHN0cmVhbScpO1xuICAgIH1cbiAgICBpZiAoZmlyc3REZXNjcmlwdG9yLmJ5dGVzRmlsbGVkICsgYnl0ZXNXcml0dGVuID4gZmlyc3REZXNjcmlwdG9yLmJ5dGVMZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdieXRlc1dyaXR0ZW4gb3V0IG9mIHJhbmdlJyk7XG4gICAgfVxuICB9XG5cbiAgZmlyc3REZXNjcmlwdG9yLmJ1ZmZlciA9IFRyYW5zZmVyQXJyYXlCdWZmZXIoZmlyc3REZXNjcmlwdG9yLmJ1ZmZlcik7XG5cbiAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmRJbnRlcm5hbChjb250cm9sbGVyLCBieXRlc1dyaXR0ZW4pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmRXaXRoTmV3Vmlldyhjb250cm9sbGVyOiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlldzogQXJyYXlCdWZmZXJWaWV3KSB7XG4gIGFzc2VydChjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLmxlbmd0aCA+IDApO1xuICBhc3NlcnQoIUlzRGV0YWNoZWRCdWZmZXIodmlldy5idWZmZXIpKTtcblxuICBjb25zdCBmaXJzdERlc2NyaXB0b3IgPSBjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLnBlZWsoKTtcbiAgY29uc3Qgc3RhdGUgPSBjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtLl9zdGF0ZTtcblxuICBpZiAoc3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICAgaWYgKHZpZXcuYnl0ZUxlbmd0aCAhPT0gMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIHZpZXdcXCdzIGxlbmd0aCBtdXN0IGJlIDAgd2hlbiBjYWxsaW5nIHJlc3BvbmRXaXRoTmV3VmlldygpIG9uIGEgY2xvc2VkIHN0cmVhbScpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBhc3NlcnQoc3RhdGUgPT09ICdyZWFkYWJsZScpO1xuICAgIGlmICh2aWV3LmJ5dGVMZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICdUaGUgdmlld1xcJ3MgbGVuZ3RoIG11c3QgYmUgZ3JlYXRlciB0aGFuIDAgd2hlbiBjYWxsaW5nIHJlc3BvbmRXaXRoTmV3VmlldygpIG9uIGEgcmVhZGFibGUgc3RyZWFtJ1xuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBpZiAoZmlyc3REZXNjcmlwdG9yLmJ5dGVPZmZzZXQgKyBmaXJzdERlc2NyaXB0b3IuYnl0ZXNGaWxsZWQgIT09IHZpZXcuYnl0ZU9mZnNldCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgcmVnaW9uIHNwZWNpZmllZCBieSB2aWV3IGRvZXMgbm90IG1hdGNoIGJ5b2JSZXF1ZXN0Jyk7XG4gIH1cbiAgaWYgKGZpcnN0RGVzY3JpcHRvci5idWZmZXJCeXRlTGVuZ3RoICE9PSB2aWV3LmJ1ZmZlci5ieXRlTGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSBidWZmZXIgb2YgdmlldyBoYXMgZGlmZmVyZW50IGNhcGFjaXR5IHRoYW4gYnlvYlJlcXVlc3QnKTtcbiAgfVxuICBpZiAoZmlyc3REZXNjcmlwdG9yLmJ5dGVzRmlsbGVkICsgdmlldy5ieXRlTGVuZ3RoID4gZmlyc3REZXNjcmlwdG9yLmJ5dGVMZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHJlZ2lvbiBzcGVjaWZpZWQgYnkgdmlldyBpcyBsYXJnZXIgdGhhbiBieW9iUmVxdWVzdCcpO1xuICB9XG5cbiAgY29uc3Qgdmlld0J5dGVMZW5ndGggPSB2aWV3LmJ5dGVMZW5ndGg7XG4gIGZpcnN0RGVzY3JpcHRvci5idWZmZXIgPSBUcmFuc2ZlckFycmF5QnVmZmVyKHZpZXcuYnVmZmVyKTtcbiAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmRJbnRlcm5hbChjb250cm9sbGVyLCB2aWV3Qnl0ZUxlbmd0aCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBTZXRVcFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIoc3RyZWFtOiBSZWFkYWJsZUJ5dGVTdHJlYW0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXI6IFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0QWxnb3JpdGhtOiAoKSA9PiB2b2lkIHwgUHJvbWlzZUxpa2U8dm9pZD4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1bGxBbGdvcml0aG06ICgpID0+IFByb21pc2U8dm9pZD4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbmNlbEFsZ29yaXRobTogKHJlYXNvbjogYW55KSA9PiBQcm9taXNlPHZvaWQ+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaWdoV2F0ZXJNYXJrOiBudW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1dG9BbGxvY2F0ZUNodW5rU2l6ZTogbnVtYmVyIHwgdW5kZWZpbmVkKSB7XG4gIGFzc2VydChzdHJlYW0uX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciA9PT0gdW5kZWZpbmVkKTtcbiAgaWYgKGF1dG9BbGxvY2F0ZUNodW5rU2l6ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgYXNzZXJ0KE51bWJlcklzSW50ZWdlcihhdXRvQWxsb2NhdGVDaHVua1NpemUpKTtcbiAgICBhc3NlcnQoYXV0b0FsbG9jYXRlQ2h1bmtTaXplID4gMCk7XG4gIH1cblxuICBjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtID0gc3RyZWFtO1xuXG4gIGNvbnRyb2xsZXIuX3B1bGxBZ2FpbiA9IGZhbHNlO1xuICBjb250cm9sbGVyLl9wdWxsaW5nID0gZmFsc2U7XG5cbiAgY29udHJvbGxlci5fYnlvYlJlcXVlc3QgPSBudWxsO1xuXG4gIC8vIE5lZWQgdG8gc2V0IHRoZSBzbG90cyBzbyB0aGF0IHRoZSBhc3NlcnQgZG9lc24ndCBmaXJlLiBJbiB0aGUgc3BlYyB0aGUgc2xvdHMgYWxyZWFkeSBleGlzdCBpbXBsaWNpdGx5LlxuICBjb250cm9sbGVyLl9xdWV1ZSA9IGNvbnRyb2xsZXIuX3F1ZXVlVG90YWxTaXplID0gdW5kZWZpbmVkITtcbiAgUmVzZXRRdWV1ZShjb250cm9sbGVyKTtcblxuICBjb250cm9sbGVyLl9jbG9zZVJlcXVlc3RlZCA9IGZhbHNlO1xuICBjb250cm9sbGVyLl9zdGFydGVkID0gZmFsc2U7XG5cbiAgY29udHJvbGxlci5fc3RyYXRlZ3lIV00gPSBoaWdoV2F0ZXJNYXJrO1xuXG4gIGNvbnRyb2xsZXIuX3B1bGxBbGdvcml0aG0gPSBwdWxsQWxnb3JpdGhtO1xuICBjb250cm9sbGVyLl9jYW5jZWxBbGdvcml0aG0gPSBjYW5jZWxBbGdvcml0aG07XG5cbiAgY29udHJvbGxlci5fYXV0b0FsbG9jYXRlQ2h1bmtTaXplID0gYXV0b0FsbG9jYXRlQ2h1bmtTaXplO1xuXG4gIGNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MgPSBuZXcgU2ltcGxlUXVldWUoKTtcblxuICBzdHJlYW0uX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciA9IGNvbnRyb2xsZXI7XG5cbiAgY29uc3Qgc3RhcnRSZXN1bHQgPSBzdGFydEFsZ29yaXRobSgpO1xuICB1cG9uUHJvbWlzZShcbiAgICBwcm9taXNlUmVzb2x2ZWRXaXRoKHN0YXJ0UmVzdWx0KSxcbiAgICAoKSA9PiB7XG4gICAgICBjb250cm9sbGVyLl9zdGFydGVkID0gdHJ1ZTtcblxuICAgICAgYXNzZXJ0KCFjb250cm9sbGVyLl9wdWxsaW5nKTtcbiAgICAgIGFzc2VydCghY29udHJvbGxlci5fcHVsbEFnYWluKTtcblxuICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNhbGxQdWxsSWZOZWVkZWQoY29udHJvbGxlcik7XG4gICAgfSxcbiAgICByID0+IHtcbiAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFcnJvcihjb250cm9sbGVyLCByKTtcbiAgICB9XG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBTZXRVcFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJGcm9tVW5kZXJseWluZ1NvdXJjZShcbiAgc3RyZWFtOiBSZWFkYWJsZUJ5dGVTdHJlYW0sXG4gIHVuZGVybHlpbmdCeXRlU291cmNlOiBWYWxpZGF0ZWRVbmRlcmx5aW5nQnl0ZVNvdXJjZSxcbiAgaGlnaFdhdGVyTWFyazogbnVtYmVyXG4pIHtcbiAgY29uc3QgY29udHJvbGxlcjogUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlciA9IE9iamVjdC5jcmVhdGUoUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUpO1xuXG4gIGxldCBzdGFydEFsZ29yaXRobTogKCkgPT4gdm9pZCB8IFByb21pc2VMaWtlPHZvaWQ+ID0gKCkgPT4gdW5kZWZpbmVkO1xuICBsZXQgcHVsbEFsZ29yaXRobTogKCkgPT4gUHJvbWlzZTx2b2lkPiA9ICgpID0+IHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcbiAgbGV0IGNhbmNlbEFsZ29yaXRobTogKHJlYXNvbjogYW55KSA9PiBQcm9taXNlPHZvaWQ+ID0gKCkgPT4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuXG4gIGlmICh1bmRlcmx5aW5nQnl0ZVNvdXJjZS5zdGFydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnRBbGdvcml0aG0gPSAoKSA9PiB1bmRlcmx5aW5nQnl0ZVNvdXJjZS5zdGFydCEoY29udHJvbGxlcik7XG4gIH1cbiAgaWYgKHVuZGVybHlpbmdCeXRlU291cmNlLnB1bGwgIT09IHVuZGVmaW5lZCkge1xuICAgIHB1bGxBbGdvcml0aG0gPSAoKSA9PiB1bmRlcmx5aW5nQnl0ZVNvdXJjZS5wdWxsIShjb250cm9sbGVyKTtcbiAgfVxuICBpZiAodW5kZXJseWluZ0J5dGVTb3VyY2UuY2FuY2VsICE9PSB1bmRlZmluZWQpIHtcbiAgICBjYW5jZWxBbGdvcml0aG0gPSByZWFzb24gPT4gdW5kZXJseWluZ0J5dGVTb3VyY2UuY2FuY2VsIShyZWFzb24pO1xuICB9XG5cbiAgY29uc3QgYXV0b0FsbG9jYXRlQ2h1bmtTaXplID0gdW5kZXJseWluZ0J5dGVTb3VyY2UuYXV0b0FsbG9jYXRlQ2h1bmtTaXplO1xuICBpZiAoYXV0b0FsbG9jYXRlQ2h1bmtTaXplID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXV0b0FsbG9jYXRlQ2h1bmtTaXplIG11c3QgYmUgZ3JlYXRlciB0aGFuIDAnKTtcbiAgfVxuXG4gIFNldFVwUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcihcbiAgICBzdHJlYW0sIGNvbnRyb2xsZXIsIHN0YXJ0QWxnb3JpdGhtLCBwdWxsQWxnb3JpdGhtLCBjYW5jZWxBbGdvcml0aG0sIGhpZ2hXYXRlck1hcmssIGF1dG9BbGxvY2F0ZUNodW5rU2l6ZVxuICApO1xufVxuXG5mdW5jdGlvbiBTZXRVcFJlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QocmVxdWVzdDogUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyOiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZXc6IEFycmF5QnVmZmVyVmlldykge1xuICBhc3NlcnQoSXNSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyKGNvbnRyb2xsZXIpKTtcbiAgYXNzZXJ0KHR5cGVvZiB2aWV3ID09PSAnb2JqZWN0Jyk7XG4gIGFzc2VydChBcnJheUJ1ZmZlci5pc1ZpZXcodmlldykpO1xuICBhc3NlcnQoIUlzRGV0YWNoZWRCdWZmZXIodmlldy5idWZmZXIpKTtcbiAgcmVxdWVzdC5fYXNzb2NpYXRlZFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIgPSBjb250cm9sbGVyO1xuICByZXF1ZXN0Ll92aWV3ID0gdmlldztcbn1cblxuLy8gSGVscGVyIGZ1bmN0aW9ucyBmb3IgdGhlIFJlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QuXG5cbmZ1bmN0aW9uIGJ5b2JSZXF1ZXN0QnJhbmRDaGVja0V4Y2VwdGlvbihuYW1lOiBzdHJpbmcpOiBUeXBlRXJyb3Ige1xuICByZXR1cm4gbmV3IFR5cGVFcnJvcihcbiAgICBgUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdC5wcm90b3R5cGUuJHtuYW1lfSBjYW4gb25seSBiZSB1c2VkIG9uIGEgUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdGApO1xufVxuXG4vLyBIZWxwZXIgZnVuY3Rpb25zIGZvciB0aGUgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlci5cblxuZnVuY3Rpb24gYnl0ZVN0cmVhbUNvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uKG5hbWU6IHN0cmluZyk6IFR5cGVFcnJvciB7XG4gIHJldHVybiBuZXcgVHlwZUVycm9yKFxuICAgIGBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZS4ke25hbWV9IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyYCk7XG59XG4iLCAiaW1wb3J0IGFzc2VydCBmcm9tICcuLi8uLi9zdHViL2Fzc2VydCc7XG5pbXBvcnQgeyBTaW1wbGVRdWV1ZSB9IGZyb20gJy4uL3NpbXBsZS1xdWV1ZSc7XG5pbXBvcnQge1xuICBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNDYW5jZWwsXG4gIFJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY0luaXRpYWxpemUsXG4gIFJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY1JlbGVhc2UsXG4gIHJlYWRlckxvY2tFeGNlcHRpb25cbn0gZnJvbSAnLi9nZW5lcmljLXJlYWRlcic7XG5pbXBvcnQgeyBJc1JlYWRhYmxlU3RyZWFtTG9ja2VkLCBSZWFkYWJsZUJ5dGVTdHJlYW0sIFJlYWRhYmxlU3RyZWFtIH0gZnJvbSAnLi4vcmVhZGFibGUtc3RyZWFtJztcbmltcG9ydCB7XG4gIElzUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcixcbiAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcixcbiAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclB1bGxJbnRvXG59IGZyb20gJy4vYnl0ZS1zdHJlYW0tY29udHJvbGxlcic7XG5pbXBvcnQgeyB0eXBlSXNPYmplY3QgfSBmcm9tICcuLi9oZWxwZXJzL21pc2NlbGxhbmVvdXMnO1xuaW1wb3J0IHsgbmV3UHJvbWlzZSwgcHJvbWlzZVJlamVjdGVkV2l0aCB9IGZyb20gJy4uL2hlbHBlcnMvd2ViaWRsJztcbmltcG9ydCB7IGFzc2VydFJlcXVpcmVkQXJndW1lbnQgfSBmcm9tICcuLi92YWxpZGF0b3JzL2Jhc2ljJztcbmltcG9ydCB7IGFzc2VydFJlYWRhYmxlU3RyZWFtIH0gZnJvbSAnLi4vdmFsaWRhdG9ycy9yZWFkYWJsZS1zdHJlYW0nO1xuaW1wb3J0IHsgSXNEZXRhY2hlZEJ1ZmZlciB9IGZyb20gJy4uL2Fic3RyYWN0LW9wcy9lY21hc2NyaXB0JztcblxuLyoqXG4gKiBBIHJlc3VsdCByZXR1cm5lZCBieSB7QGxpbmsgUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyLnJlYWR9LlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IHR5cGUgUmVhZGFibGVTdHJlYW1CWU9CUmVhZFJlc3VsdDxUIGV4dGVuZHMgQXJyYXlCdWZmZXJWaWV3PiA9IHtcbiAgZG9uZTogZmFsc2U7XG4gIHZhbHVlOiBUO1xufSB8IHtcbiAgZG9uZTogdHJ1ZTtcbiAgdmFsdWU6IFQgfCB1bmRlZmluZWQ7XG59O1xuXG4vLyBBYnN0cmFjdCBvcGVyYXRpb25zIGZvciB0aGUgUmVhZGFibGVTdHJlYW0uXG5cbmV4cG9ydCBmdW5jdGlvbiBBY3F1aXJlUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyKHN0cmVhbTogUmVhZGFibGVCeXRlU3RyZWFtKTogUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyIHtcbiAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIoc3RyZWFtKTtcbn1cblxuLy8gUmVhZGFibGVTdHJlYW0gQVBJIGV4cG9zZWQgZm9yIGNvbnRyb2xsZXJzLlxuXG5leHBvcnQgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1BZGRSZWFkSW50b1JlcXVlc3Q8VCBleHRlbmRzIEFycmF5QnVmZmVyVmlldz4oc3RyZWFtOiBSZWFkYWJsZUJ5dGVTdHJlYW0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZEludG9SZXF1ZXN0OiBSZWFkSW50b1JlcXVlc3Q8VD4pOiB2b2lkIHtcbiAgYXNzZXJ0KElzUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyKHN0cmVhbS5fcmVhZGVyKSk7XG4gIGFzc2VydChzdHJlYW0uX3N0YXRlID09PSAncmVhZGFibGUnIHx8IHN0cmVhbS5fc3RhdGUgPT09ICdjbG9zZWQnKTtcblxuICAoc3RyZWFtLl9yZWFkZXIhIGFzIFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlcikuX3JlYWRJbnRvUmVxdWVzdHMucHVzaChyZWFkSW50b1JlcXVlc3QpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1GdWxmaWxsUmVhZEludG9SZXF1ZXN0KHN0cmVhbTogUmVhZGFibGVCeXRlU3RyZWFtLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaHVuazogQXJyYXlCdWZmZXJWaWV3LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lOiBib29sZWFuKSB7XG4gIGNvbnN0IHJlYWRlciA9IHN0cmVhbS5fcmVhZGVyIGFzIFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlcjtcblxuICBhc3NlcnQocmVhZGVyLl9yZWFkSW50b1JlcXVlc3RzLmxlbmd0aCA+IDApO1xuXG4gIGNvbnN0IHJlYWRJbnRvUmVxdWVzdCA9IHJlYWRlci5fcmVhZEludG9SZXF1ZXN0cy5zaGlmdCgpITtcbiAgaWYgKGRvbmUpIHtcbiAgICByZWFkSW50b1JlcXVlc3QuX2Nsb3NlU3RlcHMoY2h1bmspO1xuICB9IGVsc2Uge1xuICAgIHJlYWRJbnRvUmVxdWVzdC5fY2h1bmtTdGVwcyhjaHVuayk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtR2V0TnVtUmVhZEludG9SZXF1ZXN0cyhzdHJlYW06IFJlYWRhYmxlQnl0ZVN0cmVhbSk6IG51bWJlciB7XG4gIHJldHVybiAoc3RyZWFtLl9yZWFkZXIgYXMgUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyKS5fcmVhZEludG9SZXF1ZXN0cy5sZW5ndGg7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbUhhc0JZT0JSZWFkZXIoc3RyZWFtOiBSZWFkYWJsZUJ5dGVTdHJlYW0pOiBib29sZWFuIHtcbiAgY29uc3QgcmVhZGVyID0gc3RyZWFtLl9yZWFkZXI7XG5cbiAgaWYgKHJlYWRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtQllPQlJlYWRlcihyZWFkZXIpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIFJlYWRlcnNcblxuZXhwb3J0IGludGVyZmFjZSBSZWFkSW50b1JlcXVlc3Q8VCBleHRlbmRzIEFycmF5QnVmZmVyVmlldz4ge1xuICBfY2h1bmtTdGVwcyhjaHVuazogVCk6IHZvaWQ7XG5cbiAgX2Nsb3NlU3RlcHMoY2h1bms6IFQgfCB1bmRlZmluZWQpOiB2b2lkO1xuXG4gIF9lcnJvclN0ZXBzKGU6IGFueSk6IHZvaWQ7XG59XG5cbi8qKlxuICogQSBCWU9CIHJlYWRlciB2ZW5kZWQgYnkgYSB7QGxpbmsgUmVhZGFibGVTdHJlYW19LlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNsYXNzIFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlciB7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX293bmVyUmVhZGFibGVTdHJlYW0hOiBSZWFkYWJsZUJ5dGVTdHJlYW07XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2Nsb3NlZFByb21pc2UhOiBQcm9taXNlPHVuZGVmaW5lZD47XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2Nsb3NlZFByb21pc2VfcmVzb2x2ZT86ICh2YWx1ZT86IHVuZGVmaW5lZCkgPT4gdm9pZDtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfY2xvc2VkUHJvbWlzZV9yZWplY3Q/OiAocmVhc29uOiBhbnkpID0+IHZvaWQ7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3JlYWRJbnRvUmVxdWVzdHM6IFNpbXBsZVF1ZXVlPFJlYWRJbnRvUmVxdWVzdDxhbnk+PjtcblxuICBjb25zdHJ1Y3RvcihzdHJlYW06IFJlYWRhYmxlQnl0ZVN0cmVhbSkge1xuICAgIGFzc2VydFJlcXVpcmVkQXJndW1lbnQoc3RyZWFtLCAxLCAnUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyJyk7XG4gICAgYXNzZXJ0UmVhZGFibGVTdHJlYW0oc3RyZWFtLCAnRmlyc3QgcGFyYW1ldGVyJyk7XG5cbiAgICBpZiAoSXNSZWFkYWJsZVN0cmVhbUxvY2tlZChzdHJlYW0pKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGlzIHN0cmVhbSBoYXMgYWxyZWFkeSBiZWVuIGxvY2tlZCBmb3IgZXhjbHVzaXZlIHJlYWRpbmcgYnkgYW5vdGhlciByZWFkZXInKTtcbiAgICB9XG5cbiAgICBpZiAoIUlzUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcihzdHJlYW0uX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjb25zdHJ1Y3QgYSBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIgZm9yIGEgc3RyZWFtIG5vdCBjb25zdHJ1Y3RlZCB3aXRoIGEgYnl0ZSAnICtcbiAgICAgICAgJ3NvdXJjZScpO1xuICAgIH1cblxuICAgIFJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY0luaXRpYWxpemUodGhpcywgc3RyZWFtKTtcblxuICAgIHRoaXMuX3JlYWRJbnRvUmVxdWVzdHMgPSBuZXcgU2ltcGxlUXVldWUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHdpbGwgYmUgZnVsZmlsbGVkIHdoZW4gdGhlIHN0cmVhbSBiZWNvbWVzIGNsb3NlZCwgb3IgcmVqZWN0ZWQgaWYgdGhlIHN0cmVhbSBldmVyIGVycm9ycyBvclxuICAgKiB0aGUgcmVhZGVyJ3MgbG9jayBpcyByZWxlYXNlZCBiZWZvcmUgdGhlIHN0cmVhbSBmaW5pc2hlcyBjbG9zaW5nLlxuICAgKi9cbiAgZ2V0IGNsb3NlZCgpOiBQcm9taXNlPHVuZGVmaW5lZD4ge1xuICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIodGhpcykpIHtcbiAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGJ5b2JSZWFkZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdjbG9zZWQnKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX2Nsb3NlZFByb21pc2U7XG4gIH1cblxuICAvKipcbiAgICogSWYgdGhlIHJlYWRlciBpcyBhY3RpdmUsIGJlaGF2ZXMgdGhlIHNhbWUgYXMge0BsaW5rIFJlYWRhYmxlU3RyZWFtLmNhbmNlbCB8IHN0cmVhbS5jYW5jZWwocmVhc29uKX0uXG4gICAqL1xuICBjYW5jZWwocmVhc29uOiBhbnkgPSB1bmRlZmluZWQpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyKHRoaXMpKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChieW9iUmVhZGVyQnJhbmRDaGVja0V4Y2VwdGlvbignY2FuY2VsJykpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9vd25lclJlYWRhYmxlU3RyZWFtID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKHJlYWRlckxvY2tFeGNlcHRpb24oJ2NhbmNlbCcpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljQ2FuY2VsKHRoaXMsIHJlYXNvbik7XG4gIH1cblxuICAvKipcbiAgICogQXR0ZW1wdHMgdG8gcmVhZHMgYnl0ZXMgaW50byB2aWV3LCBhbmQgcmV0dXJucyBhIHByb21pc2UgcmVzb2x2ZWQgd2l0aCB0aGUgcmVzdWx0LlxuICAgKlxuICAgKiBJZiByZWFkaW5nIGEgY2h1bmsgY2F1c2VzIHRoZSBxdWV1ZSB0byBiZWNvbWUgZW1wdHksIG1vcmUgZGF0YSB3aWxsIGJlIHB1bGxlZCBmcm9tIHRoZSB1bmRlcmx5aW5nIHNvdXJjZS5cbiAgICovXG4gIHJlYWQ8VCBleHRlbmRzIEFycmF5QnVmZmVyVmlldz4odmlldzogVCk6IFByb21pc2U8UmVhZGFibGVTdHJlYW1CWU9CUmVhZFJlc3VsdDxUPj4ge1xuICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIodGhpcykpIHtcbiAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGJ5b2JSZWFkZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdyZWFkJykpO1xuICAgIH1cblxuICAgIGlmICghQXJyYXlCdWZmZXIuaXNWaWV3KHZpZXcpKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChuZXcgVHlwZUVycm9yKCd2aWV3IG11c3QgYmUgYW4gYXJyYXkgYnVmZmVyIHZpZXcnKSk7XG4gICAgfVxuICAgIGlmICh2aWV3LmJ5dGVMZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKG5ldyBUeXBlRXJyb3IoJ3ZpZXcgbXVzdCBoYXZlIG5vbi16ZXJvIGJ5dGVMZW5ndGgnKSk7XG4gICAgfVxuICAgIGlmICh2aWV3LmJ1ZmZlci5ieXRlTGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChuZXcgVHlwZUVycm9yKGB2aWV3J3MgYnVmZmVyIG11c3QgaGF2ZSBub24temVybyBieXRlTGVuZ3RoYCkpO1xuICAgIH1cbiAgICBpZiAoSXNEZXRhY2hlZEJ1ZmZlcih2aWV3LmJ1ZmZlcikpIHtcbiAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKG5ldyBUeXBlRXJyb3IoJ3ZpZXdcXCdzIGJ1ZmZlciBoYXMgYmVlbiBkZXRhY2hlZCcpKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fb3duZXJSZWFkYWJsZVN0cmVhbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChyZWFkZXJMb2NrRXhjZXB0aW9uKCdyZWFkIGZyb20nKSk7XG4gICAgfVxuXG4gICAgbGV0IHJlc29sdmVQcm9taXNlITogKHJlc3VsdDogUmVhZGFibGVTdHJlYW1CWU9CUmVhZFJlc3VsdDxUPikgPT4gdm9pZDtcbiAgICBsZXQgcmVqZWN0UHJvbWlzZSE6IChyZWFzb246IGFueSkgPT4gdm9pZDtcbiAgICBjb25zdCBwcm9taXNlID0gbmV3UHJvbWlzZTxSZWFkYWJsZVN0cmVhbUJZT0JSZWFkUmVzdWx0PFQ+PigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICByZXNvbHZlUHJvbWlzZSA9IHJlc29sdmU7XG4gICAgICByZWplY3RQcm9taXNlID0gcmVqZWN0O1xuICAgIH0pO1xuICAgIGNvbnN0IHJlYWRJbnRvUmVxdWVzdDogUmVhZEludG9SZXF1ZXN0PFQ+ID0ge1xuICAgICAgX2NodW5rU3RlcHM6IGNodW5rID0+IHJlc29sdmVQcm9taXNlKHsgdmFsdWU6IGNodW5rLCBkb25lOiBmYWxzZSB9KSxcbiAgICAgIF9jbG9zZVN0ZXBzOiBjaHVuayA9PiByZXNvbHZlUHJvbWlzZSh7IHZhbHVlOiBjaHVuaywgZG9uZTogdHJ1ZSB9KSxcbiAgICAgIF9lcnJvclN0ZXBzOiBlID0+IHJlamVjdFByb21pc2UoZSlcbiAgICB9O1xuICAgIFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlclJlYWQodGhpcywgdmlldywgcmVhZEludG9SZXF1ZXN0KTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWxlYXNlcyB0aGUgcmVhZGVyJ3MgbG9jayBvbiB0aGUgY29ycmVzcG9uZGluZyBzdHJlYW0uIEFmdGVyIHRoZSBsb2NrIGlzIHJlbGVhc2VkLCB0aGUgcmVhZGVyIGlzIG5vIGxvbmdlciBhY3RpdmUuXG4gICAqIElmIHRoZSBhc3NvY2lhdGVkIHN0cmVhbSBpcyBlcnJvcmVkIHdoZW4gdGhlIGxvY2sgaXMgcmVsZWFzZWQsIHRoZSByZWFkZXIgd2lsbCBhcHBlYXIgZXJyb3JlZCBpbiB0aGUgc2FtZSB3YXlcbiAgICogZnJvbSBub3cgb247IG90aGVyd2lzZSwgdGhlIHJlYWRlciB3aWxsIGFwcGVhciBjbG9zZWQuXG4gICAqXG4gICAqIEEgcmVhZGVyJ3MgbG9jayBjYW5ub3QgYmUgcmVsZWFzZWQgd2hpbGUgaXQgc3RpbGwgaGFzIGEgcGVuZGluZyByZWFkIHJlcXVlc3QsIGkuZS4sIGlmIGEgcHJvbWlzZSByZXR1cm5lZCBieVxuICAgKiB0aGUgcmVhZGVyJ3Mge0BsaW5rIFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlci5yZWFkIHwgcmVhZCgpfSBtZXRob2QgaGFzIG5vdCB5ZXQgYmVlbiBzZXR0bGVkLiBBdHRlbXB0aW5nIHRvXG4gICAqIGRvIHNvIHdpbGwgdGhyb3cgYSBgVHlwZUVycm9yYCBhbmQgbGVhdmUgdGhlIHJlYWRlciBsb2NrZWQgdG8gdGhlIHN0cmVhbS5cbiAgICovXG4gIHJlbGVhc2VMb2NrKCk6IHZvaWQge1xuICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIodGhpcykpIHtcbiAgICAgIHRocm93IGJ5b2JSZWFkZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdyZWxlYXNlTG9jaycpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9vd25lclJlYWRhYmxlU3RyZWFtID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcmVhZEludG9SZXF1ZXN0cy5sZW5ndGggPiAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUcmllZCB0byByZWxlYXNlIGEgcmVhZGVyIGxvY2sgd2hlbiB0aGF0IHJlYWRlciBoYXMgcGVuZGluZyByZWFkKCkgY2FsbHMgdW4tc2V0dGxlZCcpO1xuICAgIH1cblxuICAgIFJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY1JlbGVhc2UodGhpcyk7XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyLnByb3RvdHlwZSwge1xuICBjYW5jZWw6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICByZWFkOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgcmVsZWFzZUxvY2s6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICBjbG9zZWQ6IHsgZW51bWVyYWJsZTogdHJ1ZSB9XG59KTtcbmlmICh0eXBlb2YgU3ltYm9sLnRvU3RyaW5nVGFnID09PSAnc3ltYm9sJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyLnByb3RvdHlwZSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7XG4gICAgdmFsdWU6ICdSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXInLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuLy8gQWJzdHJhY3Qgb3BlcmF0aW9ucyBmb3IgdGhlIHJlYWRlcnMuXG5cbmV4cG9ydCBmdW5jdGlvbiBJc1JlYWRhYmxlU3RyZWFtQllPQlJlYWRlcih4OiBhbnkpOiB4IGlzIFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlciB7XG4gIGlmICghdHlwZUlzT2JqZWN0KHgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ19yZWFkSW50b1JlcXVlc3RzJykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4geCBpbnN0YW5jZW9mIFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlclJlYWQ8VCBleHRlbmRzIEFycmF5QnVmZmVyVmlldz4oXG4gIHJlYWRlcjogUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyLFxuICB2aWV3OiBULFxuICByZWFkSW50b1JlcXVlc3Q6IFJlYWRJbnRvUmVxdWVzdDxUPlxuKTogdm9pZCB7XG4gIGNvbnN0IHN0cmVhbSA9IHJlYWRlci5fb3duZXJSZWFkYWJsZVN0cmVhbTtcblxuICBhc3NlcnQoc3RyZWFtICE9PSB1bmRlZmluZWQpO1xuXG4gIHN0cmVhbS5fZGlzdHVyYmVkID0gdHJ1ZTtcblxuICBpZiAoc3RyZWFtLl9zdGF0ZSA9PT0gJ2Vycm9yZWQnKSB7XG4gICAgcmVhZEludG9SZXF1ZXN0Ll9lcnJvclN0ZXBzKHN0cmVhbS5fc3RvcmVkRXJyb3IpO1xuICB9IGVsc2Uge1xuICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJQdWxsSW50byhcbiAgICAgIHN0cmVhbS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyIGFzIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIsXG4gICAgICB2aWV3LFxuICAgICAgcmVhZEludG9SZXF1ZXN0XG4gICAgKTtcbiAgfVxufVxuXG4vLyBIZWxwZXIgZnVuY3Rpb25zIGZvciB0aGUgUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyLlxuXG5mdW5jdGlvbiBieW9iUmVhZGVyQnJhbmRDaGVja0V4Y2VwdGlvbihuYW1lOiBzdHJpbmcpOiBUeXBlRXJyb3Ige1xuICByZXR1cm4gbmV3IFR5cGVFcnJvcihcbiAgICBgUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyLnByb3RvdHlwZS4ke25hbWV9IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXJgKTtcbn1cbiIsICJpbXBvcnQgeyBRdWV1aW5nU3RyYXRlZ3ksIFF1ZXVpbmdTdHJhdGVneVNpemVDYWxsYmFjayB9IGZyb20gJy4uL3F1ZXVpbmctc3RyYXRlZ3knO1xuaW1wb3J0IE51bWJlcklzTmFOIGZyb20gJy4uLy4uL3N0dWIvbnVtYmVyLWlzbmFuJztcblxuZXhwb3J0IGZ1bmN0aW9uIEV4dHJhY3RIaWdoV2F0ZXJNYXJrKHN0cmF0ZWd5OiBRdWV1aW5nU3RyYXRlZ3ksIGRlZmF1bHRIV006IG51bWJlcik6IG51bWJlciB7XG4gIGNvbnN0IHsgaGlnaFdhdGVyTWFyayB9ID0gc3RyYXRlZ3k7XG5cbiAgaWYgKGhpZ2hXYXRlck1hcmsgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBkZWZhdWx0SFdNO1xuICB9XG5cbiAgaWYgKE51bWJlcklzTmFOKGhpZ2hXYXRlck1hcmspIHx8IGhpZ2hXYXRlck1hcmsgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgaGlnaFdhdGVyTWFyaycpO1xuICB9XG5cbiAgcmV0dXJuIGhpZ2hXYXRlck1hcms7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBFeHRyYWN0U2l6ZUFsZ29yaXRobTxUPihzdHJhdGVneTogUXVldWluZ1N0cmF0ZWd5PFQ+KTogUXVldWluZ1N0cmF0ZWd5U2l6ZUNhbGxiYWNrPFQ+IHtcbiAgY29uc3QgeyBzaXplIH0gPSBzdHJhdGVneTtcblxuICBpZiAoIXNpemUpIHtcbiAgICByZXR1cm4gKCkgPT4gMTtcbiAgfVxuXG4gIHJldHVybiBzaXplO1xufVxuIiwgImltcG9ydCB7IFF1ZXVpbmdTdHJhdGVneSwgUXVldWluZ1N0cmF0ZWd5U2l6ZUNhbGxiYWNrIH0gZnJvbSAnLi4vcXVldWluZy1zdHJhdGVneSc7XG5pbXBvcnQgeyBhc3NlcnREaWN0aW9uYXJ5LCBhc3NlcnRGdW5jdGlvbiwgY29udmVydFVucmVzdHJpY3RlZERvdWJsZSB9IGZyb20gJy4vYmFzaWMnO1xuXG5leHBvcnQgZnVuY3Rpb24gY29udmVydFF1ZXVpbmdTdHJhdGVneTxUPihpbml0OiBRdWV1aW5nU3RyYXRlZ3k8VD4gfCBudWxsIHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dDogc3RyaW5nKTogUXVldWluZ1N0cmF0ZWd5PFQ+IHtcbiAgYXNzZXJ0RGljdGlvbmFyeShpbml0LCBjb250ZXh0KTtcbiAgY29uc3QgaGlnaFdhdGVyTWFyayA9IGluaXQ/LmhpZ2hXYXRlck1hcms7XG4gIGNvbnN0IHNpemUgPSBpbml0Py5zaXplO1xuICByZXR1cm4ge1xuICAgIGhpZ2hXYXRlck1hcms6IGhpZ2hXYXRlck1hcmsgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IGNvbnZlcnRVbnJlc3RyaWN0ZWREb3VibGUoaGlnaFdhdGVyTWFyayksXG4gICAgc2l6ZTogc2l6ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogY29udmVydFF1ZXVpbmdTdHJhdGVneVNpemUoc2l6ZSwgYCR7Y29udGV4dH0gaGFzIG1lbWJlciAnc2l6ZScgdGhhdGApXG4gIH07XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRRdWV1aW5nU3RyYXRlZ3lTaXplPFQ+KGZuOiBRdWV1aW5nU3RyYXRlZ3lTaXplQ2FsbGJhY2s8VD4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiBzdHJpbmcpOiBRdWV1aW5nU3RyYXRlZ3lTaXplQ2FsbGJhY2s8VD4ge1xuICBhc3NlcnRGdW5jdGlvbihmbiwgY29udGV4dCk7XG4gIHJldHVybiBjaHVuayA9PiBjb252ZXJ0VW5yZXN0cmljdGVkRG91YmxlKGZuKGNodW5rKSk7XG59XG4iLCAiaW1wb3J0IHsgYXNzZXJ0RGljdGlvbmFyeSwgYXNzZXJ0RnVuY3Rpb24gfSBmcm9tICcuL2Jhc2ljJztcbmltcG9ydCB7IHByb21pc2VDYWxsLCByZWZsZWN0Q2FsbCB9IGZyb20gJy4uL2hlbHBlcnMvd2ViaWRsJztcbmltcG9ydCB7XG4gIFVuZGVybHlpbmdTaW5rLFxuICBVbmRlcmx5aW5nU2lua0Fib3J0Q2FsbGJhY2ssXG4gIFVuZGVybHlpbmdTaW5rQ2xvc2VDYWxsYmFjayxcbiAgVW5kZXJseWluZ1NpbmtTdGFydENhbGxiYWNrLFxuICBVbmRlcmx5aW5nU2lua1dyaXRlQ2FsbGJhY2ssXG4gIFZhbGlkYXRlZFVuZGVybHlpbmdTaW5rXG59IGZyb20gJy4uL3dyaXRhYmxlLXN0cmVhbS91bmRlcmx5aW5nLXNpbmsnO1xuaW1wb3J0IHsgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlciB9IGZyb20gJy4uL3dyaXRhYmxlLXN0cmVhbSc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0VW5kZXJseWluZ1Npbms8Vz4ob3JpZ2luYWw6IFVuZGVybHlpbmdTaW5rPFc+IHwgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dDogc3RyaW5nKTogVmFsaWRhdGVkVW5kZXJseWluZ1Npbms8Vz4ge1xuICBhc3NlcnREaWN0aW9uYXJ5KG9yaWdpbmFsLCBjb250ZXh0KTtcbiAgY29uc3QgYWJvcnQgPSBvcmlnaW5hbD8uYWJvcnQ7XG4gIGNvbnN0IGNsb3NlID0gb3JpZ2luYWw/LmNsb3NlO1xuICBjb25zdCBzdGFydCA9IG9yaWdpbmFsPy5zdGFydDtcbiAgY29uc3QgdHlwZSA9IG9yaWdpbmFsPy50eXBlO1xuICBjb25zdCB3cml0ZSA9IG9yaWdpbmFsPy53cml0ZTtcbiAgcmV0dXJuIHtcbiAgICBhYm9ydDogYWJvcnQgPT09IHVuZGVmaW5lZCA/XG4gICAgICB1bmRlZmluZWQgOlxuICAgICAgY29udmVydFVuZGVybHlpbmdTaW5rQWJvcnRDYWxsYmFjayhhYm9ydCwgb3JpZ2luYWwhLCBgJHtjb250ZXh0fSBoYXMgbWVtYmVyICdhYm9ydCcgdGhhdGApLFxuICAgIGNsb3NlOiBjbG9zZSA9PT0gdW5kZWZpbmVkID9cbiAgICAgIHVuZGVmaW5lZCA6XG4gICAgICBjb252ZXJ0VW5kZXJseWluZ1NpbmtDbG9zZUNhbGxiYWNrKGNsb3NlLCBvcmlnaW5hbCEsIGAke2NvbnRleHR9IGhhcyBtZW1iZXIgJ2Nsb3NlJyB0aGF0YCksXG4gICAgc3RhcnQ6IHN0YXJ0ID09PSB1bmRlZmluZWQgP1xuICAgICAgdW5kZWZpbmVkIDpcbiAgICAgIGNvbnZlcnRVbmRlcmx5aW5nU2lua1N0YXJ0Q2FsbGJhY2soc3RhcnQsIG9yaWdpbmFsISwgYCR7Y29udGV4dH0gaGFzIG1lbWJlciAnc3RhcnQnIHRoYXRgKSxcbiAgICB3cml0ZTogd3JpdGUgPT09IHVuZGVmaW5lZCA/XG4gICAgICB1bmRlZmluZWQgOlxuICAgICAgY29udmVydFVuZGVybHlpbmdTaW5rV3JpdGVDYWxsYmFjayh3cml0ZSwgb3JpZ2luYWwhLCBgJHtjb250ZXh0fSBoYXMgbWVtYmVyICd3cml0ZScgdGhhdGApLFxuICAgIHR5cGVcbiAgfTtcbn1cblxuZnVuY3Rpb24gY29udmVydFVuZGVybHlpbmdTaW5rQWJvcnRDYWxsYmFjayhcbiAgZm46IFVuZGVybHlpbmdTaW5rQWJvcnRDYWxsYmFjayxcbiAgb3JpZ2luYWw6IFVuZGVybHlpbmdTaW5rLFxuICBjb250ZXh0OiBzdHJpbmdcbik6IChyZWFzb246IGFueSkgPT4gUHJvbWlzZTx2b2lkPiB7XG4gIGFzc2VydEZ1bmN0aW9uKGZuLCBjb250ZXh0KTtcbiAgcmV0dXJuIChyZWFzb246IGFueSkgPT4gcHJvbWlzZUNhbGwoZm4sIG9yaWdpbmFsLCBbcmVhc29uXSk7XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRVbmRlcmx5aW5nU2lua0Nsb3NlQ2FsbGJhY2soXG4gIGZuOiBVbmRlcmx5aW5nU2lua0Nsb3NlQ2FsbGJhY2ssXG4gIG9yaWdpbmFsOiBVbmRlcmx5aW5nU2luayxcbiAgY29udGV4dDogc3RyaW5nXG4pOiAoKSA9PiBQcm9taXNlPHZvaWQ+IHtcbiAgYXNzZXJ0RnVuY3Rpb24oZm4sIGNvbnRleHQpO1xuICByZXR1cm4gKCkgPT4gcHJvbWlzZUNhbGwoZm4sIG9yaWdpbmFsLCBbXSk7XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRVbmRlcmx5aW5nU2lua1N0YXJ0Q2FsbGJhY2soXG4gIGZuOiBVbmRlcmx5aW5nU2lua1N0YXJ0Q2FsbGJhY2ssXG4gIG9yaWdpbmFsOiBVbmRlcmx5aW5nU2luayxcbiAgY29udGV4dDogc3RyaW5nXG4pOiBVbmRlcmx5aW5nU2lua1N0YXJ0Q2FsbGJhY2sge1xuICBhc3NlcnRGdW5jdGlvbihmbiwgY29udGV4dCk7XG4gIHJldHVybiAoY29udHJvbGxlcjogV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcikgPT4gcmVmbGVjdENhbGwoZm4sIG9yaWdpbmFsLCBbY29udHJvbGxlcl0pO1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0VW5kZXJseWluZ1NpbmtXcml0ZUNhbGxiYWNrPFc+KFxuICBmbjogVW5kZXJseWluZ1NpbmtXcml0ZUNhbGxiYWNrPFc+LFxuICBvcmlnaW5hbDogVW5kZXJseWluZ1Npbms8Vz4sXG4gIGNvbnRleHQ6IHN0cmluZ1xuKTogKGNodW5rOiBXLCBjb250cm9sbGVyOiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyKSA9PiBQcm9taXNlPHZvaWQ+IHtcbiAgYXNzZXJ0RnVuY3Rpb24oZm4sIGNvbnRleHQpO1xuICByZXR1cm4gKGNodW5rOiBXLCBjb250cm9sbGVyOiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyKSA9PiBwcm9taXNlQ2FsbChmbiwgb3JpZ2luYWwsIFtjaHVuaywgY29udHJvbGxlcl0pO1xufVxuIiwgImltcG9ydCB7IElzV3JpdGFibGVTdHJlYW0sIFdyaXRhYmxlU3RyZWFtIH0gZnJvbSAnLi4vd3JpdGFibGUtc3RyZWFtJztcblxuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydFdyaXRhYmxlU3RyZWFtKHg6IHVua25vd24sIGNvbnRleHQ6IHN0cmluZyk6IGFzc2VydHMgeCBpcyBXcml0YWJsZVN0cmVhbSB7XG4gIGlmICghSXNXcml0YWJsZVN0cmVhbSh4KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7Y29udGV4dH0gaXMgbm90IGEgV3JpdGFibGVTdHJlYW0uYCk7XG4gIH1cbn1cbiIsICIvKipcbiAqIEEgc2lnbmFsIG9iamVjdCB0aGF0IGFsbG93cyB5b3UgdG8gY29tbXVuaWNhdGUgd2l0aCBhIHJlcXVlc3QgYW5kIGFib3J0IGl0IGlmIHJlcXVpcmVkXG4gKiB2aWEgaXRzIGFzc29jaWF0ZWQgYEFib3J0Q29udHJvbGxlcmAgb2JqZWN0LlxuICpcbiAqIEByZW1hcmtzXG4gKiAgIFRoaXMgaW50ZXJmYWNlIGlzIGNvbXBhdGlibGUgd2l0aCB0aGUgYEFib3J0U2lnbmFsYCBpbnRlcmZhY2UgZGVmaW5lZCBpbiBUeXBlU2NyaXB0J3MgRE9NIHR5cGVzLlxuICogICBJdCBpcyByZWRlZmluZWQgaGVyZSwgc28gaXQgY2FuIGJlIHBvbHlmaWxsZWQgd2l0aG91dCBhIERPTSwgZm9yIGV4YW1wbGUgd2l0aFxuICogICB7QGxpbmsgaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvYWJvcnRjb250cm9sbGVyLXBvbHlmaWxsIHwgYWJvcnRjb250cm9sbGVyLXBvbHlmaWxsfSBpbiBhIE5vZGUgZW52aXJvbm1lbnQuXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgaW50ZXJmYWNlIEFib3J0U2lnbmFsIHtcbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIHJlcXVlc3QgaXMgYWJvcnRlZC5cbiAgICovXG4gIHJlYWRvbmx5IGFib3J0ZWQ6IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIEFkZCBhbiBldmVudCBsaXN0ZW5lciB0byBiZSB0cmlnZ2VyZWQgd2hlbiB0aGlzIHNpZ25hbCBiZWNvbWVzIGFib3J0ZWQuXG4gICAqL1xuICBhZGRFdmVudExpc3RlbmVyKHR5cGU6ICdhYm9ydCcsIGxpc3RlbmVyOiAoKSA9PiB2b2lkKTogdm9pZDtcblxuICAvKipcbiAgICogUmVtb3ZlIGFuIGV2ZW50IGxpc3RlbmVyIHRoYXQgd2FzIHByZXZpb3VzbHkgYWRkZWQgd2l0aCB7QGxpbmsgQWJvcnRTaWduYWwuYWRkRXZlbnRMaXN0ZW5lcn0uXG4gICAqL1xuICByZW1vdmVFdmVudExpc3RlbmVyKHR5cGU6ICdhYm9ydCcsIGxpc3RlbmVyOiAoKSA9PiB2b2lkKTogdm9pZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzQWJvcnRTaWduYWwodmFsdWU6IHVua25vd24pOiB2YWx1ZSBpcyBBYm9ydFNpZ25hbCB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHRyeSB7XG4gICAgcmV0dXJuIHR5cGVvZiAodmFsdWUgYXMgQWJvcnRTaWduYWwpLmFib3J0ZWQgPT09ICdib29sZWFuJztcbiAgfSBjYXRjaCB7XG4gICAgLy8gQWJvcnRTaWduYWwucHJvdG90eXBlLmFib3J0ZWQgdGhyb3dzIGlmIGl0cyBicmFuZCBjaGVjayBmYWlsc1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIEEgY29udHJvbGxlciBvYmplY3QgdGhhdCBhbGxvd3MgeW91IHRvIGFib3J0IGFuIGBBYm9ydFNpZ25hbGAgd2hlbiBkZXNpcmVkLlxuICpcbiAqIEByZW1hcmtzXG4gKiAgIFRoaXMgaW50ZXJmYWNlIGlzIGNvbXBhdGlibGUgd2l0aCB0aGUgYEFib3J0Q29udHJvbGxlcmAgaW50ZXJmYWNlIGRlZmluZWQgaW4gVHlwZVNjcmlwdCdzIERPTSB0eXBlcy5cbiAqICAgSXQgaXMgcmVkZWZpbmVkIGhlcmUsIHNvIGl0IGNhbiBiZSBwb2x5ZmlsbGVkIHdpdGhvdXQgYSBET00sIGZvciBleGFtcGxlIHdpdGhcbiAqICAge0BsaW5rIGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL2Fib3J0Y29udHJvbGxlci1wb2x5ZmlsbCB8IGFib3J0Y29udHJvbGxlci1wb2x5ZmlsbH0gaW4gYSBOb2RlIGVudmlyb25tZW50LlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgaW50ZXJmYWNlIEFib3J0Q29udHJvbGxlciB7XG4gIHJlYWRvbmx5IHNpZ25hbDogQWJvcnRTaWduYWw7XG5cbiAgYWJvcnQoKTogdm9pZDtcbn1cblxuaW50ZXJmYWNlIEFib3J0Q29udHJvbGxlckNvbnN0cnVjdG9yIHtcbiAgbmV3KCk6IEFib3J0Q29udHJvbGxlcjtcbn1cblxuY29uc3Qgc3VwcG9ydHNBYm9ydENvbnRyb2xsZXIgPSB0eXBlb2YgKEFib3J0Q29udHJvbGxlciBhcyBhbnkpID09PSAnZnVuY3Rpb24nO1xuXG4vKipcbiAqIENvbnN0cnVjdCBhIG5ldyBBYm9ydENvbnRyb2xsZXIsIGlmIHN1cHBvcnRlZCBieSB0aGUgcGxhdGZvcm0uXG4gKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVBYm9ydENvbnRyb2xsZXIoKTogQWJvcnRDb250cm9sbGVyIHwgdW5kZWZpbmVkIHtcbiAgaWYgKHN1cHBvcnRzQWJvcnRDb250cm9sbGVyKSB7XG4gICAgcmV0dXJuIG5ldyAoQWJvcnRDb250cm9sbGVyIGFzIEFib3J0Q29udHJvbGxlckNvbnN0cnVjdG9yKSgpO1xuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG4iLCAiaW1wb3J0IGFzc2VydCBmcm9tICcuLi9zdHViL2Fzc2VydCc7XG5pbXBvcnQge1xuICBuZXdQcm9taXNlLFxuICBwcm9taXNlUmVqZWN0ZWRXaXRoLFxuICBwcm9taXNlUmVzb2x2ZWRXaXRoLFxuICBzZXRQcm9taXNlSXNIYW5kbGVkVG9UcnVlLFxuICB1cG9uUHJvbWlzZVxufSBmcm9tICcuL2hlbHBlcnMvd2ViaWRsJztcbmltcG9ydCB7XG4gIERlcXVldWVWYWx1ZSxcbiAgRW5xdWV1ZVZhbHVlV2l0aFNpemUsXG4gIFBlZWtRdWV1ZVZhbHVlLFxuICBRdWV1ZVBhaXIsXG4gIFJlc2V0UXVldWVcbn0gZnJvbSAnLi9hYnN0cmFjdC1vcHMvcXVldWUtd2l0aC1zaXplcyc7XG5pbXBvcnQgeyBRdWV1aW5nU3RyYXRlZ3ksIFF1ZXVpbmdTdHJhdGVneVNpemVDYWxsYmFjayB9IGZyb20gJy4vcXVldWluZy1zdHJhdGVneSc7XG5pbXBvcnQgeyBTaW1wbGVRdWV1ZSB9IGZyb20gJy4vc2ltcGxlLXF1ZXVlJztcbmltcG9ydCB7IHR5cGVJc09iamVjdCB9IGZyb20gJy4vaGVscGVycy9taXNjZWxsYW5lb3VzJztcbmltcG9ydCB7IEFib3J0U3RlcHMsIEVycm9yU3RlcHMgfSBmcm9tICcuL2Fic3RyYWN0LW9wcy9pbnRlcm5hbC1tZXRob2RzJztcbmltcG9ydCB7IElzTm9uTmVnYXRpdmVOdW1iZXIgfSBmcm9tICcuL2Fic3RyYWN0LW9wcy9taXNjZWxsYW5lb3VzJztcbmltcG9ydCB7IEV4dHJhY3RIaWdoV2F0ZXJNYXJrLCBFeHRyYWN0U2l6ZUFsZ29yaXRobSB9IGZyb20gJy4vYWJzdHJhY3Qtb3BzL3F1ZXVpbmctc3RyYXRlZ3knO1xuaW1wb3J0IHsgY29udmVydFF1ZXVpbmdTdHJhdGVneSB9IGZyb20gJy4vdmFsaWRhdG9ycy9xdWV1aW5nLXN0cmF0ZWd5JztcbmltcG9ydCB7XG4gIFVuZGVybHlpbmdTaW5rLFxuICBVbmRlcmx5aW5nU2lua0Fib3J0Q2FsbGJhY2ssXG4gIFVuZGVybHlpbmdTaW5rQ2xvc2VDYWxsYmFjayxcbiAgVW5kZXJseWluZ1NpbmtTdGFydENhbGxiYWNrLFxuICBVbmRlcmx5aW5nU2lua1dyaXRlQ2FsbGJhY2ssXG4gIFZhbGlkYXRlZFVuZGVybHlpbmdTaW5rXG59IGZyb20gJy4vd3JpdGFibGUtc3RyZWFtL3VuZGVybHlpbmctc2luayc7XG5pbXBvcnQgeyBhc3NlcnRPYmplY3QsIGFzc2VydFJlcXVpcmVkQXJndW1lbnQgfSBmcm9tICcuL3ZhbGlkYXRvcnMvYmFzaWMnO1xuaW1wb3J0IHsgY29udmVydFVuZGVybHlpbmdTaW5rIH0gZnJvbSAnLi92YWxpZGF0b3JzL3VuZGVybHlpbmctc2luayc7XG5pbXBvcnQgeyBhc3NlcnRXcml0YWJsZVN0cmVhbSB9IGZyb20gJy4vdmFsaWRhdG9ycy93cml0YWJsZS1zdHJlYW0nO1xuaW1wb3J0IHsgQWJvcnRDb250cm9sbGVyLCBBYm9ydFNpZ25hbCwgY3JlYXRlQWJvcnRDb250cm9sbGVyIH0gZnJvbSAnLi9hYm9ydC1zaWduYWwnO1xuXG50eXBlIFdyaXRhYmxlU3RyZWFtU3RhdGUgPSAnd3JpdGFibGUnIHwgJ2Nsb3NlZCcgfCAnZXJyb3JpbmcnIHwgJ2Vycm9yZWQnO1xuXG5pbnRlcmZhY2UgV3JpdGVPckNsb3NlUmVxdWVzdCB7XG4gIF9yZXNvbHZlOiAodmFsdWU/OiB1bmRlZmluZWQpID0+IHZvaWQ7XG4gIF9yZWplY3Q6IChyZWFzb246IGFueSkgPT4gdm9pZDtcbn1cblxudHlwZSBXcml0ZVJlcXVlc3QgPSBXcml0ZU9yQ2xvc2VSZXF1ZXN0O1xudHlwZSBDbG9zZVJlcXVlc3QgPSBXcml0ZU9yQ2xvc2VSZXF1ZXN0O1xuXG5pbnRlcmZhY2UgUGVuZGluZ0Fib3J0UmVxdWVzdCB7XG4gIF9wcm9taXNlOiBQcm9taXNlPHVuZGVmaW5lZD47XG4gIF9yZXNvbHZlOiAodmFsdWU/OiB1bmRlZmluZWQpID0+IHZvaWQ7XG4gIF9yZWplY3Q6IChyZWFzb246IGFueSkgPT4gdm9pZDtcbiAgX3JlYXNvbjogYW55O1xuICBfd2FzQWxyZWFkeUVycm9yaW5nOiBib29sZWFuO1xufVxuXG4vKipcbiAqIEEgd3JpdGFibGUgc3RyZWFtIHJlcHJlc2VudHMgYSBkZXN0aW5hdGlvbiBmb3IgZGF0YSwgaW50byB3aGljaCB5b3UgY2FuIHdyaXRlLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuY2xhc3MgV3JpdGFibGVTdHJlYW08VyA9IGFueT4ge1xuICAvKiogQGludGVybmFsICovXG4gIF9zdGF0ZSE6IFdyaXRhYmxlU3RyZWFtU3RhdGU7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3N0b3JlZEVycm9yOiBhbnk7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3dyaXRlcjogV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyPFc+IHwgdW5kZWZpbmVkO1xuICAvKiogQGludGVybmFsICovXG4gIF93cml0YWJsZVN0cmVhbUNvbnRyb2xsZXIhOiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyPFc+O1xuICAvKiogQGludGVybmFsICovXG4gIF93cml0ZVJlcXVlc3RzITogU2ltcGxlUXVldWU8V3JpdGVSZXF1ZXN0PjtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfaW5GbGlnaHRXcml0ZVJlcXVlc3Q6IFdyaXRlUmVxdWVzdCB8IHVuZGVmaW5lZDtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfY2xvc2VSZXF1ZXN0OiBDbG9zZVJlcXVlc3QgfCB1bmRlZmluZWQ7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2luRmxpZ2h0Q2xvc2VSZXF1ZXN0OiBDbG9zZVJlcXVlc3QgfCB1bmRlZmluZWQ7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3BlbmRpbmdBYm9ydFJlcXVlc3Q6IFBlbmRpbmdBYm9ydFJlcXVlc3QgfCB1bmRlZmluZWQ7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2JhY2twcmVzc3VyZSE6IGJvb2xlYW47XG5cbiAgY29uc3RydWN0b3IodW5kZXJseWluZ1Npbms/OiBVbmRlcmx5aW5nU2luazxXPiwgc3RyYXRlZ3k/OiBRdWV1aW5nU3RyYXRlZ3k8Vz4pO1xuICBjb25zdHJ1Y3RvcihyYXdVbmRlcmx5aW5nU2luazogVW5kZXJseWluZ1Npbms8Vz4gfCBudWxsIHwgdW5kZWZpbmVkID0ge30sXG4gICAgICAgICAgICAgIHJhd1N0cmF0ZWd5OiBRdWV1aW5nU3RyYXRlZ3k8Vz4gfCBudWxsIHwgdW5kZWZpbmVkID0ge30pIHtcbiAgICBpZiAocmF3VW5kZXJseWluZ1NpbmsgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmF3VW5kZXJseWluZ1NpbmsgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NlcnRPYmplY3QocmF3VW5kZXJseWluZ1NpbmssICdGaXJzdCBwYXJhbWV0ZXInKTtcbiAgICB9XG5cbiAgICBjb25zdCBzdHJhdGVneSA9IGNvbnZlcnRRdWV1aW5nU3RyYXRlZ3kocmF3U3RyYXRlZ3ksICdTZWNvbmQgcGFyYW1ldGVyJyk7XG4gICAgY29uc3QgdW5kZXJseWluZ1NpbmsgPSBjb252ZXJ0VW5kZXJseWluZ1NpbmsocmF3VW5kZXJseWluZ1NpbmssICdGaXJzdCBwYXJhbWV0ZXInKTtcblxuICAgIEluaXRpYWxpemVXcml0YWJsZVN0cmVhbSh0aGlzKTtcblxuICAgIGNvbnN0IHR5cGUgPSB1bmRlcmx5aW5nU2luay50eXBlO1xuICAgIGlmICh0eXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHR5cGUgaXMgc3BlY2lmaWVkJyk7XG4gICAgfVxuXG4gICAgY29uc3Qgc2l6ZUFsZ29yaXRobSA9IEV4dHJhY3RTaXplQWxnb3JpdGhtKHN0cmF0ZWd5KTtcbiAgICBjb25zdCBoaWdoV2F0ZXJNYXJrID0gRXh0cmFjdEhpZ2hXYXRlck1hcmsoc3RyYXRlZ3ksIDEpO1xuXG4gICAgU2V0VXBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRnJvbVVuZGVybHlpbmdTaW5rKHRoaXMsIHVuZGVybHlpbmdTaW5rLCBoaWdoV2F0ZXJNYXJrLCBzaXplQWxnb3JpdGhtKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSB3cml0YWJsZSBzdHJlYW0gaXMgbG9ja2VkIHRvIGEgd3JpdGVyLlxuICAgKi9cbiAgZ2V0IGxvY2tlZCgpOiBib29sZWFuIHtcbiAgICBpZiAoIUlzV3JpdGFibGVTdHJlYW0odGhpcykpIHtcbiAgICAgIHRocm93IHN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24oJ2xvY2tlZCcpO1xuICAgIH1cblxuICAgIHJldHVybiBJc1dyaXRhYmxlU3RyZWFtTG9ja2VkKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFib3J0cyB0aGUgc3RyZWFtLCBzaWduYWxpbmcgdGhhdCB0aGUgcHJvZHVjZXIgY2FuIG5vIGxvbmdlciBzdWNjZXNzZnVsbHkgd3JpdGUgdG8gdGhlIHN0cmVhbSBhbmQgaXQgaXMgdG8gYmVcbiAgICogaW1tZWRpYXRlbHkgbW92ZWQgdG8gYW4gZXJyb3JlZCBzdGF0ZSwgd2l0aCBhbnkgcXVldWVkLXVwIHdyaXRlcyBkaXNjYXJkZWQuIFRoaXMgd2lsbCBhbHNvIGV4ZWN1dGUgYW55IGFib3J0XG4gICAqIG1lY2hhbmlzbSBvZiB0aGUgdW5kZXJseWluZyBzaW5rLlxuICAgKlxuICAgKiBUaGUgcmV0dXJuZWQgcHJvbWlzZSB3aWxsIGZ1bGZpbGwgaWYgdGhlIHN0cmVhbSBzaHV0cyBkb3duIHN1Y2Nlc3NmdWxseSwgb3IgcmVqZWN0IGlmIHRoZSB1bmRlcmx5aW5nIHNpbmsgc2lnbmFsZWRcbiAgICogdGhhdCB0aGVyZSB3YXMgYW4gZXJyb3IgZG9pbmcgc28uIEFkZGl0aW9uYWxseSwgaXQgd2lsbCByZWplY3Qgd2l0aCBhIGBUeXBlRXJyb3JgICh3aXRob3V0IGF0dGVtcHRpbmcgdG8gY2FuY2VsXG4gICAqIHRoZSBzdHJlYW0pIGlmIHRoZSBzdHJlYW0gaXMgY3VycmVudGx5IGxvY2tlZC5cbiAgICovXG4gIGFib3J0KHJlYXNvbjogYW55ID0gdW5kZWZpbmVkKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKCFJc1dyaXRhYmxlU3RyZWFtKHRoaXMpKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChzdHJlYW1CcmFuZENoZWNrRXhjZXB0aW9uKCdhYm9ydCcpKTtcbiAgICB9XG5cbiAgICBpZiAoSXNXcml0YWJsZVN0cmVhbUxvY2tlZCh0aGlzKSkge1xuICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgobmV3IFR5cGVFcnJvcignQ2Fubm90IGFib3J0IGEgc3RyZWFtIHRoYXQgYWxyZWFkeSBoYXMgYSB3cml0ZXInKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFdyaXRhYmxlU3RyZWFtQWJvcnQodGhpcywgcmVhc29uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9zZXMgdGhlIHN0cmVhbS4gVGhlIHVuZGVybHlpbmcgc2luayB3aWxsIGZpbmlzaCBwcm9jZXNzaW5nIGFueSBwcmV2aW91c2x5LXdyaXR0ZW4gY2h1bmtzLCBiZWZvcmUgaW52b2tpbmcgaXRzXG4gICAqIGNsb3NlIGJlaGF2aW9yLiBEdXJpbmcgdGhpcyB0aW1lIGFueSBmdXJ0aGVyIGF0dGVtcHRzIHRvIHdyaXRlIHdpbGwgZmFpbCAod2l0aG91dCBlcnJvcmluZyB0aGUgc3RyZWFtKS5cbiAgICpcbiAgICogVGhlIG1ldGhvZCByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHdpbGwgZnVsZmlsbCBpZiBhbGwgcmVtYWluaW5nIGNodW5rcyBhcmUgc3VjY2Vzc2Z1bGx5IHdyaXR0ZW4gYW5kIHRoZSBzdHJlYW1cbiAgICogc3VjY2Vzc2Z1bGx5IGNsb3Nlcywgb3IgcmVqZWN0cyBpZiBhbiBlcnJvciBpcyBlbmNvdW50ZXJlZCBkdXJpbmcgdGhpcyBwcm9jZXNzLiBBZGRpdGlvbmFsbHksIGl0IHdpbGwgcmVqZWN0IHdpdGhcbiAgICogYSBgVHlwZUVycm9yYCAod2l0aG91dCBhdHRlbXB0aW5nIHRvIGNhbmNlbCB0aGUgc3RyZWFtKSBpZiB0aGUgc3RyZWFtIGlzIGN1cnJlbnRseSBsb2NrZWQuXG4gICAqL1xuICBjbG9zZSgpIHtcbiAgICBpZiAoIUlzV3JpdGFibGVTdHJlYW0odGhpcykpIHtcbiAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKHN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24oJ2Nsb3NlJykpO1xuICAgIH1cblxuICAgIGlmIChJc1dyaXRhYmxlU3RyZWFtTG9ja2VkKHRoaXMpKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2xvc2UgYSBzdHJlYW0gdGhhdCBhbHJlYWR5IGhhcyBhIHdyaXRlcicpKTtcbiAgICB9XG5cbiAgICBpZiAoV3JpdGFibGVTdHJlYW1DbG9zZVF1ZXVlZE9ySW5GbGlnaHQodGhpcykpIHtcbiAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjbG9zZSBhbiBhbHJlYWR5LWNsb3Npbmcgc3RyZWFtJykpO1xuICAgIH1cblxuICAgIHJldHVybiBXcml0YWJsZVN0cmVhbUNsb3NlKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSB7QGxpbmsgV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyIHwgd3JpdGVyfSBhbmQgbG9ja3MgdGhlIHN0cmVhbSB0byB0aGUgbmV3IHdyaXRlci4gV2hpbGUgdGhlIHN0cmVhbVxuICAgKiBpcyBsb2NrZWQsIG5vIG90aGVyIHdyaXRlciBjYW4gYmUgYWNxdWlyZWQgdW50aWwgdGhpcyBvbmUgaXMgcmVsZWFzZWQuXG4gICAqXG4gICAqIFRoaXMgZnVuY3Rpb25hbGl0eSBpcyBlc3BlY2lhbGx5IHVzZWZ1bCBmb3IgY3JlYXRpbmcgYWJzdHJhY3Rpb25zIHRoYXQgZGVzaXJlIHRoZSBhYmlsaXR5IHRvIHdyaXRlIHRvIGEgc3RyZWFtXG4gICAqIHdpdGhvdXQgaW50ZXJydXB0aW9uIG9yIGludGVybGVhdmluZy4gQnkgZ2V0dGluZyBhIHdyaXRlciBmb3IgdGhlIHN0cmVhbSwgeW91IGNhbiBlbnN1cmUgbm9ib2R5IGVsc2UgY2FuIHdyaXRlIGF0XG4gICAqIHRoZSBzYW1lIHRpbWUsIHdoaWNoIHdvdWxkIGNhdXNlIHRoZSByZXN1bHRpbmcgd3JpdHRlbiBkYXRhIHRvIGJlIHVucHJlZGljdGFibGUgYW5kIHByb2JhYmx5IHVzZWxlc3MuXG4gICAqL1xuICBnZXRXcml0ZXIoKTogV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyPFc+IHtcbiAgICBpZiAoIUlzV3JpdGFibGVTdHJlYW0odGhpcykpIHtcbiAgICAgIHRocm93IHN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24oJ2dldFdyaXRlcicpO1xuICAgIH1cblxuICAgIHJldHVybiBBY3F1aXJlV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyKHRoaXMpO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFdyaXRhYmxlU3RyZWFtLnByb3RvdHlwZSwge1xuICBhYm9ydDogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gIGNsb3NlOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgZ2V0V3JpdGVyOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgbG9ja2VkOiB7IGVudW1lcmFibGU6IHRydWUgfVxufSk7XG5pZiAodHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlU3RyZWFtLnByb3RvdHlwZSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7XG4gICAgdmFsdWU6ICdXcml0YWJsZVN0cmVhbScsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG5leHBvcnQge1xuICBBY3F1aXJlV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyLFxuICBDcmVhdGVXcml0YWJsZVN0cmVhbSxcbiAgSXNXcml0YWJsZVN0cmVhbSxcbiAgSXNXcml0YWJsZVN0cmVhbUxvY2tlZCxcbiAgV3JpdGFibGVTdHJlYW0sXG4gIFdyaXRhYmxlU3RyZWFtQWJvcnQsXG4gIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcklmTmVlZGVkLFxuICBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJDbG9zZVdpdGhFcnJvclByb3BhZ2F0aW9uLFxuICBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJSZWxlYXNlLFxuICBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJXcml0ZSxcbiAgV3JpdGFibGVTdHJlYW1DbG9zZVF1ZXVlZE9ySW5GbGlnaHQsXG4gIFVuZGVybHlpbmdTaW5rLFxuICBVbmRlcmx5aW5nU2lua1N0YXJ0Q2FsbGJhY2ssXG4gIFVuZGVybHlpbmdTaW5rV3JpdGVDYWxsYmFjayxcbiAgVW5kZXJseWluZ1NpbmtDbG9zZUNhbGxiYWNrLFxuICBVbmRlcmx5aW5nU2lua0Fib3J0Q2FsbGJhY2tcbn07XG5cbi8vIEFic3RyYWN0IG9wZXJhdGlvbnMgZm9yIHRoZSBXcml0YWJsZVN0cmVhbS5cblxuZnVuY3Rpb24gQWNxdWlyZVdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcjxXPihzdHJlYW06IFdyaXRhYmxlU3RyZWFtPFc+KTogV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyPFc+IHtcbiAgcmV0dXJuIG5ldyBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIoc3RyZWFtKTtcbn1cblxuLy8gVGhyb3dzIGlmIGFuZCBvbmx5IGlmIHN0YXJ0QWxnb3JpdGhtIHRocm93cy5cbmZ1bmN0aW9uIENyZWF0ZVdyaXRhYmxlU3RyZWFtPFc+KHN0YXJ0QWxnb3JpdGhtOiAoKSA9PiB2b2lkIHwgUHJvbWlzZUxpa2U8dm9pZD4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3cml0ZUFsZ29yaXRobTogKGNodW5rOiBXKSA9PiBQcm9taXNlPHZvaWQ+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2VBbGdvcml0aG06ICgpID0+IFByb21pc2U8dm9pZD4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhYm9ydEFsZ29yaXRobTogKHJlYXNvbjogYW55KSA9PiBQcm9taXNlPHZvaWQ+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGlnaFdhdGVyTWFyayA9IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaXplQWxnb3JpdGhtOiBRdWV1aW5nU3RyYXRlZ3lTaXplQ2FsbGJhY2s8Vz4gPSAoKSA9PiAxKSB7XG4gIGFzc2VydChJc05vbk5lZ2F0aXZlTnVtYmVyKGhpZ2hXYXRlck1hcmspKTtcblxuICBjb25zdCBzdHJlYW06IFdyaXRhYmxlU3RyZWFtPFc+ID0gT2JqZWN0LmNyZWF0ZShXcml0YWJsZVN0cmVhbS5wcm90b3R5cGUpO1xuICBJbml0aWFsaXplV3JpdGFibGVTdHJlYW0oc3RyZWFtKTtcblxuICBjb25zdCBjb250cm9sbGVyOiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyPFc+ID0gT2JqZWN0LmNyZWF0ZShXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZSk7XG5cbiAgU2V0VXBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyKHN0cmVhbSwgY29udHJvbGxlciwgc3RhcnRBbGdvcml0aG0sIHdyaXRlQWxnb3JpdGhtLCBjbG9zZUFsZ29yaXRobSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFib3J0QWxnb3JpdGhtLCBoaWdoV2F0ZXJNYXJrLCBzaXplQWxnb3JpdGhtKTtcbiAgcmV0dXJuIHN0cmVhbTtcbn1cblxuZnVuY3Rpb24gSW5pdGlhbGl6ZVdyaXRhYmxlU3RyZWFtPFc+KHN0cmVhbTogV3JpdGFibGVTdHJlYW08Vz4pIHtcbiAgc3RyZWFtLl9zdGF0ZSA9ICd3cml0YWJsZSc7XG5cbiAgLy8gVGhlIGVycm9yIHRoYXQgd2lsbCBiZSByZXBvcnRlZCBieSBuZXcgbWV0aG9kIGNhbGxzIG9uY2UgdGhlIHN0YXRlIGJlY29tZXMgZXJyb3JlZC4gT25seSBzZXQgd2hlbiBbW3N0YXRlXV0gaXNcbiAgLy8gJ2Vycm9yaW5nJyBvciAnZXJyb3JlZCcuIE1heSBiZSBzZXQgdG8gYW4gdW5kZWZpbmVkIHZhbHVlLlxuICBzdHJlYW0uX3N0b3JlZEVycm9yID0gdW5kZWZpbmVkO1xuXG4gIHN0cmVhbS5fd3JpdGVyID0gdW5kZWZpbmVkO1xuXG4gIC8vIEluaXRpYWxpemUgdG8gdW5kZWZpbmVkIGZpcnN0IGJlY2F1c2UgdGhlIGNvbnN0cnVjdG9yIG9mIHRoZSBjb250cm9sbGVyIGNoZWNrcyB0aGlzXG4gIC8vIHZhcmlhYmxlIHRvIHZhbGlkYXRlIHRoZSBjYWxsZXIuXG4gIHN0cmVhbS5fd3JpdGFibGVTdHJlYW1Db250cm9sbGVyID0gdW5kZWZpbmVkITtcblxuICAvLyBUaGlzIHF1ZXVlIGlzIHBsYWNlZCBoZXJlIGluc3RlYWQgb2YgdGhlIHdyaXRlciBjbGFzcyBpbiBvcmRlciB0byBhbGxvdyBmb3IgcGFzc2luZyBhIHdyaXRlciB0byB0aGUgbmV4dCBkYXRhXG4gIC8vIHByb2R1Y2VyIHdpdGhvdXQgd2FpdGluZyBmb3IgdGhlIHF1ZXVlZCB3cml0ZXMgdG8gZmluaXNoLlxuICBzdHJlYW0uX3dyaXRlUmVxdWVzdHMgPSBuZXcgU2ltcGxlUXVldWUoKTtcblxuICAvLyBXcml0ZSByZXF1ZXN0cyBhcmUgcmVtb3ZlZCBmcm9tIF93cml0ZVJlcXVlc3RzIHdoZW4gd3JpdGUoKSBpcyBjYWxsZWQgb24gdGhlIHVuZGVybHlpbmcgc2luay4gVGhpcyBwcmV2ZW50c1xuICAvLyB0aGVtIGZyb20gYmVpbmcgZXJyb25lb3VzbHkgcmVqZWN0ZWQgb24gZXJyb3IuIElmIGEgd3JpdGUoKSBjYWxsIGlzIGluLWZsaWdodCwgdGhlIHJlcXVlc3QgaXMgc3RvcmVkIGhlcmUuXG4gIHN0cmVhbS5faW5GbGlnaHRXcml0ZVJlcXVlc3QgPSB1bmRlZmluZWQ7XG5cbiAgLy8gVGhlIHByb21pc2UgdGhhdCB3YXMgcmV0dXJuZWQgZnJvbSB3cml0ZXIuY2xvc2UoKS4gU3RvcmVkIGhlcmUgYmVjYXVzZSBpdCBtYXkgYmUgZnVsZmlsbGVkIGFmdGVyIHRoZSB3cml0ZXJcbiAgLy8gaGFzIGJlZW4gZGV0YWNoZWQuXG4gIHN0cmVhbS5fY2xvc2VSZXF1ZXN0ID0gdW5kZWZpbmVkO1xuXG4gIC8vIENsb3NlIHJlcXVlc3QgaXMgcmVtb3ZlZCBmcm9tIF9jbG9zZVJlcXVlc3Qgd2hlbiBjbG9zZSgpIGlzIGNhbGxlZCBvbiB0aGUgdW5kZXJseWluZyBzaW5rLiBUaGlzIHByZXZlbnRzIGl0XG4gIC8vIGZyb20gYmVpbmcgZXJyb25lb3VzbHkgcmVqZWN0ZWQgb24gZXJyb3IuIElmIGEgY2xvc2UoKSBjYWxsIGlzIGluLWZsaWdodCwgdGhlIHJlcXVlc3QgaXMgc3RvcmVkIGhlcmUuXG4gIHN0cmVhbS5faW5GbGlnaHRDbG9zZVJlcXVlc3QgPSB1bmRlZmluZWQ7XG5cbiAgLy8gVGhlIHByb21pc2UgdGhhdCB3YXMgcmV0dXJuZWQgZnJvbSB3cml0ZXIuYWJvcnQoKS4gVGhpcyBtYXkgYWxzbyBiZSBmdWxmaWxsZWQgYWZ0ZXIgdGhlIHdyaXRlciBoYXMgZGV0YWNoZWQuXG4gIHN0cmVhbS5fcGVuZGluZ0Fib3J0UmVxdWVzdCA9IHVuZGVmaW5lZDtcblxuICAvLyBUaGUgYmFja3ByZXNzdXJlIHNpZ25hbCBzZXQgYnkgdGhlIGNvbnRyb2xsZXIuXG4gIHN0cmVhbS5fYmFja3ByZXNzdXJlID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIElzV3JpdGFibGVTdHJlYW0oeDogdW5rbm93bik6IHggaXMgV3JpdGFibGVTdHJlYW0ge1xuICBpZiAoIXR5cGVJc09iamVjdCh4KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdfd3JpdGFibGVTdHJlYW1Db250cm9sbGVyJykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4geCBpbnN0YW5jZW9mIFdyaXRhYmxlU3RyZWFtO1xufVxuXG5mdW5jdGlvbiBJc1dyaXRhYmxlU3RyZWFtTG9ja2VkKHN0cmVhbTogV3JpdGFibGVTdHJlYW0pOiBib29sZWFuIHtcbiAgYXNzZXJ0KElzV3JpdGFibGVTdHJlYW0oc3RyZWFtKSk7XG5cbiAgaWYgKHN0cmVhbS5fd3JpdGVyID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1BYm9ydChzdHJlYW06IFdyaXRhYmxlU3RyZWFtLCByZWFzb246IGFueSk6IFByb21pc2U8dW5kZWZpbmVkPiB7XG4gIGlmIChzdHJlYW0uX3N0YXRlID09PSAnY2xvc2VkJyB8fCBzdHJlYW0uX3N0YXRlID09PSAnZXJyb3JlZCcpIHtcbiAgICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuICB9XG4gIHN0cmVhbS5fd3JpdGFibGVTdHJlYW1Db250cm9sbGVyLl9hYm9ydFJlYXNvbiA9IHJlYXNvbjtcbiAgc3RyZWFtLl93cml0YWJsZVN0cmVhbUNvbnRyb2xsZXIuX2Fib3J0Q29udHJvbGxlcj8uYWJvcnQoKTtcblxuICAvLyBUeXBlU2NyaXB0IG5hcnJvd3MgdGhlIHR5cGUgb2YgYHN0cmVhbS5fc3RhdGVgIGRvd24gdG8gJ3dyaXRhYmxlJyB8ICdlcnJvcmluZycsXG4gIC8vIGJ1dCBpdCBkb2Vzbid0IGtub3cgdGhhdCBzaWduYWxpbmcgYWJvcnQgcnVucyBhdXRob3IgY29kZSB0aGF0IG1pZ2h0IGhhdmUgY2hhbmdlZCB0aGUgc3RhdGUuXG4gIC8vIFdpZGVuIHRoZSB0eXBlIGFnYWluIGJ5IGNhc3RpbmcgdG8gV3JpdGFibGVTdHJlYW1TdGF0ZS5cbiAgY29uc3Qgc3RhdGUgPSBzdHJlYW0uX3N0YXRlIGFzIFdyaXRhYmxlU3RyZWFtU3RhdGU7XG5cbiAgaWYgKHN0YXRlID09PSAnY2xvc2VkJyB8fCBzdGF0ZSA9PT0gJ2Vycm9yZWQnKSB7XG4gICAgcmV0dXJuIHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcbiAgfVxuICBpZiAoc3RyZWFtLl9wZW5kaW5nQWJvcnRSZXF1ZXN0ICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gc3RyZWFtLl9wZW5kaW5nQWJvcnRSZXF1ZXN0Ll9wcm9taXNlO1xuICB9XG5cbiAgYXNzZXJ0KHN0YXRlID09PSAnd3JpdGFibGUnIHx8IHN0YXRlID09PSAnZXJyb3JpbmcnKTtcblxuICBsZXQgd2FzQWxyZWFkeUVycm9yaW5nID0gZmFsc2U7XG4gIGlmIChzdGF0ZSA9PT0gJ2Vycm9yaW5nJykge1xuICAgIHdhc0FscmVhZHlFcnJvcmluZyA9IHRydWU7XG4gICAgLy8gcmVhc29uIHdpbGwgbm90IGJlIHVzZWQsIHNvIGRvbid0IGtlZXAgYSByZWZlcmVuY2UgdG8gaXQuXG4gICAgcmVhc29uID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgY29uc3QgcHJvbWlzZSA9IG5ld1Byb21pc2U8dW5kZWZpbmVkPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgc3RyZWFtLl9wZW5kaW5nQWJvcnRSZXF1ZXN0ID0ge1xuICAgICAgX3Byb21pc2U6IHVuZGVmaW5lZCEsXG4gICAgICBfcmVzb2x2ZTogcmVzb2x2ZSxcbiAgICAgIF9yZWplY3Q6IHJlamVjdCxcbiAgICAgIF9yZWFzb246IHJlYXNvbixcbiAgICAgIF93YXNBbHJlYWR5RXJyb3Jpbmc6IHdhc0FscmVhZHlFcnJvcmluZ1xuICAgIH07XG4gIH0pO1xuICBzdHJlYW0uX3BlbmRpbmdBYm9ydFJlcXVlc3QhLl9wcm9taXNlID0gcHJvbWlzZTtcblxuICBpZiAoIXdhc0FscmVhZHlFcnJvcmluZykge1xuICAgIFdyaXRhYmxlU3RyZWFtU3RhcnRFcnJvcmluZyhzdHJlYW0sIHJlYXNvbik7XG4gIH1cblxuICByZXR1cm4gcHJvbWlzZTtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1DbG9zZShzdHJlYW06IFdyaXRhYmxlU3RyZWFtPGFueT4pOiBQcm9taXNlPHVuZGVmaW5lZD4ge1xuICBjb25zdCBzdGF0ZSA9IHN0cmVhbS5fc3RhdGU7XG4gIGlmIChzdGF0ZSA9PT0gJ2Nsb3NlZCcgfHwgc3RhdGUgPT09ICdlcnJvcmVkJykge1xuICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKG5ldyBUeXBlRXJyb3IoXG4gICAgICBgVGhlIHN0cmVhbSAoaW4gJHtzdGF0ZX0gc3RhdGUpIGlzIG5vdCBpbiB0aGUgd3JpdGFibGUgc3RhdGUgYW5kIGNhbm5vdCBiZSBjbG9zZWRgKSk7XG4gIH1cblxuICBhc3NlcnQoc3RhdGUgPT09ICd3cml0YWJsZScgfHwgc3RhdGUgPT09ICdlcnJvcmluZycpO1xuICBhc3NlcnQoIVdyaXRhYmxlU3RyZWFtQ2xvc2VRdWV1ZWRPckluRmxpZ2h0KHN0cmVhbSkpO1xuXG4gIGNvbnN0IHByb21pc2UgPSBuZXdQcm9taXNlPHVuZGVmaW5lZD4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IGNsb3NlUmVxdWVzdDogQ2xvc2VSZXF1ZXN0ID0ge1xuICAgICAgX3Jlc29sdmU6IHJlc29sdmUsXG4gICAgICBfcmVqZWN0OiByZWplY3RcbiAgICB9O1xuXG4gICAgc3RyZWFtLl9jbG9zZVJlcXVlc3QgPSBjbG9zZVJlcXVlc3Q7XG4gIH0pO1xuXG4gIGNvbnN0IHdyaXRlciA9IHN0cmVhbS5fd3JpdGVyO1xuICBpZiAod3JpdGVyICE9PSB1bmRlZmluZWQgJiYgc3RyZWFtLl9iYWNrcHJlc3N1cmUgJiYgc3RhdGUgPT09ICd3cml0YWJsZScpIHtcbiAgICBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlUmVzb2x2ZSh3cml0ZXIpO1xuICB9XG5cbiAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsb3NlKHN0cmVhbS5fd3JpdGFibGVTdHJlYW1Db250cm9sbGVyKTtcblxuICByZXR1cm4gcHJvbWlzZTtcbn1cblxuLy8gV3JpdGFibGVTdHJlYW0gQVBJIGV4cG9zZWQgZm9yIGNvbnRyb2xsZXJzLlxuXG5mdW5jdGlvbiBXcml0YWJsZVN0cmVhbUFkZFdyaXRlUmVxdWVzdChzdHJlYW06IFdyaXRhYmxlU3RyZWFtKTogUHJvbWlzZTx1bmRlZmluZWQ+IHtcbiAgYXNzZXJ0KElzV3JpdGFibGVTdHJlYW1Mb2NrZWQoc3RyZWFtKSk7XG4gIGFzc2VydChzdHJlYW0uX3N0YXRlID09PSAnd3JpdGFibGUnKTtcblxuICBjb25zdCBwcm9taXNlID0gbmV3UHJvbWlzZTx1bmRlZmluZWQ+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCB3cml0ZVJlcXVlc3Q6IFdyaXRlUmVxdWVzdCA9IHtcbiAgICAgIF9yZXNvbHZlOiByZXNvbHZlLFxuICAgICAgX3JlamVjdDogcmVqZWN0XG4gICAgfTtcblxuICAgIHN0cmVhbS5fd3JpdGVSZXF1ZXN0cy5wdXNoKHdyaXRlUmVxdWVzdCk7XG4gIH0pO1xuXG4gIHJldHVybiBwcm9taXNlO1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlYWxXaXRoUmVqZWN0aW9uKHN0cmVhbTogV3JpdGFibGVTdHJlYW0sIGVycm9yOiBhbnkpIHtcbiAgY29uc3Qgc3RhdGUgPSBzdHJlYW0uX3N0YXRlO1xuXG4gIGlmIChzdGF0ZSA9PT0gJ3dyaXRhYmxlJykge1xuICAgIFdyaXRhYmxlU3RyZWFtU3RhcnRFcnJvcmluZyhzdHJlYW0sIGVycm9yKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBhc3NlcnQoc3RhdGUgPT09ICdlcnJvcmluZycpO1xuICBXcml0YWJsZVN0cmVhbUZpbmlzaEVycm9yaW5nKHN0cmVhbSk7XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtU3RhcnRFcnJvcmluZyhzdHJlYW06IFdyaXRhYmxlU3RyZWFtLCByZWFzb246IGFueSkge1xuICBhc3NlcnQoc3RyZWFtLl9zdG9yZWRFcnJvciA9PT0gdW5kZWZpbmVkKTtcbiAgYXNzZXJ0KHN0cmVhbS5fc3RhdGUgPT09ICd3cml0YWJsZScpO1xuXG4gIGNvbnN0IGNvbnRyb2xsZXIgPSBzdHJlYW0uX3dyaXRhYmxlU3RyZWFtQ29udHJvbGxlcjtcbiAgYXNzZXJ0KGNvbnRyb2xsZXIgIT09IHVuZGVmaW5lZCk7XG5cbiAgc3RyZWFtLl9zdGF0ZSA9ICdlcnJvcmluZyc7XG4gIHN0cmVhbS5fc3RvcmVkRXJyb3IgPSByZWFzb247XG4gIGNvbnN0IHdyaXRlciA9IHN0cmVhbS5fd3JpdGVyO1xuICBpZiAod3JpdGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJFbnN1cmVSZWFkeVByb21pc2VSZWplY3RlZCh3cml0ZXIsIHJlYXNvbik7XG4gIH1cblxuICBpZiAoIVdyaXRhYmxlU3RyZWFtSGFzT3BlcmF0aW9uTWFya2VkSW5GbGlnaHQoc3RyZWFtKSAmJiBjb250cm9sbGVyLl9zdGFydGVkKSB7XG4gICAgV3JpdGFibGVTdHJlYW1GaW5pc2hFcnJvcmluZyhzdHJlYW0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRmluaXNoRXJyb3Jpbmcoc3RyZWFtOiBXcml0YWJsZVN0cmVhbSkge1xuICBhc3NlcnQoc3RyZWFtLl9zdGF0ZSA9PT0gJ2Vycm9yaW5nJyk7XG4gIGFzc2VydCghV3JpdGFibGVTdHJlYW1IYXNPcGVyYXRpb25NYXJrZWRJbkZsaWdodChzdHJlYW0pKTtcbiAgc3RyZWFtLl9zdGF0ZSA9ICdlcnJvcmVkJztcbiAgc3RyZWFtLl93cml0YWJsZVN0cmVhbUNvbnRyb2xsZXJbRXJyb3JTdGVwc10oKTtcblxuICBjb25zdCBzdG9yZWRFcnJvciA9IHN0cmVhbS5fc3RvcmVkRXJyb3I7XG4gIHN0cmVhbS5fd3JpdGVSZXF1ZXN0cy5mb3JFYWNoKHdyaXRlUmVxdWVzdCA9PiB7XG4gICAgd3JpdGVSZXF1ZXN0Ll9yZWplY3Qoc3RvcmVkRXJyb3IpO1xuICB9KTtcbiAgc3RyZWFtLl93cml0ZVJlcXVlc3RzID0gbmV3IFNpbXBsZVF1ZXVlKCk7XG5cbiAgaWYgKHN0cmVhbS5fcGVuZGluZ0Fib3J0UmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgV3JpdGFibGVTdHJlYW1SZWplY3RDbG9zZUFuZENsb3NlZFByb21pc2VJZk5lZWRlZChzdHJlYW0pO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IGFib3J0UmVxdWVzdCA9IHN0cmVhbS5fcGVuZGluZ0Fib3J0UmVxdWVzdDtcbiAgc3RyZWFtLl9wZW5kaW5nQWJvcnRSZXF1ZXN0ID0gdW5kZWZpbmVkO1xuXG4gIGlmIChhYm9ydFJlcXVlc3QuX3dhc0FscmVhZHlFcnJvcmluZykge1xuICAgIGFib3J0UmVxdWVzdC5fcmVqZWN0KHN0b3JlZEVycm9yKTtcbiAgICBXcml0YWJsZVN0cmVhbVJlamVjdENsb3NlQW5kQ2xvc2VkUHJvbWlzZUlmTmVlZGVkKHN0cmVhbSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgcHJvbWlzZSA9IHN0cmVhbS5fd3JpdGFibGVTdHJlYW1Db250cm9sbGVyW0Fib3J0U3RlcHNdKGFib3J0UmVxdWVzdC5fcmVhc29uKTtcbiAgdXBvblByb21pc2UoXG4gICAgcHJvbWlzZSxcbiAgICAoKSA9PiB7XG4gICAgICBhYm9ydFJlcXVlc3QuX3Jlc29sdmUoKTtcbiAgICAgIFdyaXRhYmxlU3RyZWFtUmVqZWN0Q2xvc2VBbmRDbG9zZWRQcm9taXNlSWZOZWVkZWQoc3RyZWFtKTtcbiAgICB9LFxuICAgIChyZWFzb246IGFueSkgPT4ge1xuICAgICAgYWJvcnRSZXF1ZXN0Ll9yZWplY3QocmVhc29uKTtcbiAgICAgIFdyaXRhYmxlU3RyZWFtUmVqZWN0Q2xvc2VBbmRDbG9zZWRQcm9taXNlSWZOZWVkZWQoc3RyZWFtKTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1GaW5pc2hJbkZsaWdodFdyaXRlKHN0cmVhbTogV3JpdGFibGVTdHJlYW0pIHtcbiAgYXNzZXJ0KHN0cmVhbS5faW5GbGlnaHRXcml0ZVJlcXVlc3QgIT09IHVuZGVmaW5lZCk7XG4gIHN0cmVhbS5faW5GbGlnaHRXcml0ZVJlcXVlc3QhLl9yZXNvbHZlKHVuZGVmaW5lZCk7XG4gIHN0cmVhbS5faW5GbGlnaHRXcml0ZVJlcXVlc3QgPSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRmluaXNoSW5GbGlnaHRXcml0ZVdpdGhFcnJvcihzdHJlYW06IFdyaXRhYmxlU3RyZWFtLCBlcnJvcjogYW55KSB7XG4gIGFzc2VydChzdHJlYW0uX2luRmxpZ2h0V3JpdGVSZXF1ZXN0ICE9PSB1bmRlZmluZWQpO1xuICBzdHJlYW0uX2luRmxpZ2h0V3JpdGVSZXF1ZXN0IS5fcmVqZWN0KGVycm9yKTtcbiAgc3RyZWFtLl9pbkZsaWdodFdyaXRlUmVxdWVzdCA9IHVuZGVmaW5lZDtcblxuICBhc3NlcnQoc3RyZWFtLl9zdGF0ZSA9PT0gJ3dyaXRhYmxlJyB8fCBzdHJlYW0uX3N0YXRlID09PSAnZXJyb3JpbmcnKTtcblxuICBXcml0YWJsZVN0cmVhbURlYWxXaXRoUmVqZWN0aW9uKHN0cmVhbSwgZXJyb3IpO1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0cmVhbUZpbmlzaEluRmxpZ2h0Q2xvc2Uoc3RyZWFtOiBXcml0YWJsZVN0cmVhbSkge1xuICBhc3NlcnQoc3RyZWFtLl9pbkZsaWdodENsb3NlUmVxdWVzdCAhPT0gdW5kZWZpbmVkKTtcbiAgc3RyZWFtLl9pbkZsaWdodENsb3NlUmVxdWVzdCEuX3Jlc29sdmUodW5kZWZpbmVkKTtcbiAgc3RyZWFtLl9pbkZsaWdodENsb3NlUmVxdWVzdCA9IHVuZGVmaW5lZDtcblxuICBjb25zdCBzdGF0ZSA9IHN0cmVhbS5fc3RhdGU7XG5cbiAgYXNzZXJ0KHN0YXRlID09PSAnd3JpdGFibGUnIHx8IHN0YXRlID09PSAnZXJyb3JpbmcnKTtcblxuICBpZiAoc3RhdGUgPT09ICdlcnJvcmluZycpIHtcbiAgICAvLyBUaGUgZXJyb3Igd2FzIHRvbyBsYXRlIHRvIGRvIGFueXRoaW5nLCBzbyBpdCBpcyBpZ25vcmVkLlxuICAgIHN0cmVhbS5fc3RvcmVkRXJyb3IgPSB1bmRlZmluZWQ7XG4gICAgaWYgKHN0cmVhbS5fcGVuZGluZ0Fib3J0UmVxdWVzdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBzdHJlYW0uX3BlbmRpbmdBYm9ydFJlcXVlc3QuX3Jlc29sdmUoKTtcbiAgICAgIHN0cmVhbS5fcGVuZGluZ0Fib3J0UmVxdWVzdCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cblxuICBzdHJlYW0uX3N0YXRlID0gJ2Nsb3NlZCc7XG5cbiAgY29uc3Qgd3JpdGVyID0gc3RyZWFtLl93cml0ZXI7XG4gIGlmICh3cml0ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlUmVzb2x2ZSh3cml0ZXIpO1xuICB9XG5cbiAgYXNzZXJ0KHN0cmVhbS5fcGVuZGluZ0Fib3J0UmVxdWVzdCA9PT0gdW5kZWZpbmVkKTtcbiAgYXNzZXJ0KHN0cmVhbS5fc3RvcmVkRXJyb3IgPT09IHVuZGVmaW5lZCk7XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRmluaXNoSW5GbGlnaHRDbG9zZVdpdGhFcnJvcihzdHJlYW06IFdyaXRhYmxlU3RyZWFtLCBlcnJvcjogYW55KSB7XG4gIGFzc2VydChzdHJlYW0uX2luRmxpZ2h0Q2xvc2VSZXF1ZXN0ICE9PSB1bmRlZmluZWQpO1xuICBzdHJlYW0uX2luRmxpZ2h0Q2xvc2VSZXF1ZXN0IS5fcmVqZWN0KGVycm9yKTtcbiAgc3RyZWFtLl9pbkZsaWdodENsb3NlUmVxdWVzdCA9IHVuZGVmaW5lZDtcblxuICBhc3NlcnQoc3RyZWFtLl9zdGF0ZSA9PT0gJ3dyaXRhYmxlJyB8fCBzdHJlYW0uX3N0YXRlID09PSAnZXJyb3JpbmcnKTtcblxuICAvLyBOZXZlciBleGVjdXRlIHNpbmsgYWJvcnQoKSBhZnRlciBzaW5rIGNsb3NlKCkuXG4gIGlmIChzdHJlYW0uX3BlbmRpbmdBYm9ydFJlcXVlc3QgIT09IHVuZGVmaW5lZCkge1xuICAgIHN0cmVhbS5fcGVuZGluZ0Fib3J0UmVxdWVzdC5fcmVqZWN0KGVycm9yKTtcbiAgICBzdHJlYW0uX3BlbmRpbmdBYm9ydFJlcXVlc3QgPSB1bmRlZmluZWQ7XG4gIH1cbiAgV3JpdGFibGVTdHJlYW1EZWFsV2l0aFJlamVjdGlvbihzdHJlYW0sIGVycm9yKTtcbn1cblxuLy8gVE9ETyhyaWNlYSk6IEZpeCBhbHBoYWJldGljYWwgb3JkZXIuXG5mdW5jdGlvbiBXcml0YWJsZVN0cmVhbUNsb3NlUXVldWVkT3JJbkZsaWdodChzdHJlYW06IFdyaXRhYmxlU3RyZWFtKTogYm9vbGVhbiB7XG4gIGlmIChzdHJlYW0uX2Nsb3NlUmVxdWVzdCA9PT0gdW5kZWZpbmVkICYmIHN0cmVhbS5faW5GbGlnaHRDbG9zZVJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0cmVhbUhhc09wZXJhdGlvbk1hcmtlZEluRmxpZ2h0KHN0cmVhbTogV3JpdGFibGVTdHJlYW0pOiBib29sZWFuIHtcbiAgaWYgKHN0cmVhbS5faW5GbGlnaHRXcml0ZVJlcXVlc3QgPT09IHVuZGVmaW5lZCAmJiBzdHJlYW0uX2luRmxpZ2h0Q2xvc2VSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1NYXJrQ2xvc2VSZXF1ZXN0SW5GbGlnaHQoc3RyZWFtOiBXcml0YWJsZVN0cmVhbSkge1xuICBhc3NlcnQoc3RyZWFtLl9pbkZsaWdodENsb3NlUmVxdWVzdCA9PT0gdW5kZWZpbmVkKTtcbiAgYXNzZXJ0KHN0cmVhbS5fY2xvc2VSZXF1ZXN0ICE9PSB1bmRlZmluZWQpO1xuICBzdHJlYW0uX2luRmxpZ2h0Q2xvc2VSZXF1ZXN0ID0gc3RyZWFtLl9jbG9zZVJlcXVlc3Q7XG4gIHN0cmVhbS5fY2xvc2VSZXF1ZXN0ID0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0cmVhbU1hcmtGaXJzdFdyaXRlUmVxdWVzdEluRmxpZ2h0KHN0cmVhbTogV3JpdGFibGVTdHJlYW0pIHtcbiAgYXNzZXJ0KHN0cmVhbS5faW5GbGlnaHRXcml0ZVJlcXVlc3QgPT09IHVuZGVmaW5lZCk7XG4gIGFzc2VydChzdHJlYW0uX3dyaXRlUmVxdWVzdHMubGVuZ3RoICE9PSAwKTtcbiAgc3RyZWFtLl9pbkZsaWdodFdyaXRlUmVxdWVzdCA9IHN0cmVhbS5fd3JpdGVSZXF1ZXN0cy5zaGlmdCgpO1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0cmVhbVJlamVjdENsb3NlQW5kQ2xvc2VkUHJvbWlzZUlmTmVlZGVkKHN0cmVhbTogV3JpdGFibGVTdHJlYW0pIHtcbiAgYXNzZXJ0KHN0cmVhbS5fc3RhdGUgPT09ICdlcnJvcmVkJyk7XG4gIGlmIChzdHJlYW0uX2Nsb3NlUmVxdWVzdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgYXNzZXJ0KHN0cmVhbS5faW5GbGlnaHRDbG9zZVJlcXVlc3QgPT09IHVuZGVmaW5lZCk7XG5cbiAgICBzdHJlYW0uX2Nsb3NlUmVxdWVzdC5fcmVqZWN0KHN0cmVhbS5fc3RvcmVkRXJyb3IpO1xuICAgIHN0cmVhbS5fY2xvc2VSZXF1ZXN0ID0gdW5kZWZpbmVkO1xuICB9XG4gIGNvbnN0IHdyaXRlciA9IHN0cmVhbS5fd3JpdGVyO1xuICBpZiAod3JpdGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICBkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZVJlamVjdCh3cml0ZXIsIHN0cmVhbS5fc3RvcmVkRXJyb3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtVXBkYXRlQmFja3ByZXNzdXJlKHN0cmVhbTogV3JpdGFibGVTdHJlYW0sIGJhY2twcmVzc3VyZTogYm9vbGVhbikge1xuICBhc3NlcnQoc3RyZWFtLl9zdGF0ZSA9PT0gJ3dyaXRhYmxlJyk7XG4gIGFzc2VydCghV3JpdGFibGVTdHJlYW1DbG9zZVF1ZXVlZE9ySW5GbGlnaHQoc3RyZWFtKSk7XG5cbiAgY29uc3Qgd3JpdGVyID0gc3RyZWFtLl93cml0ZXI7XG4gIGlmICh3cml0ZXIgIT09IHVuZGVmaW5lZCAmJiBiYWNrcHJlc3N1cmUgIT09IHN0cmVhbS5fYmFja3ByZXNzdXJlKSB7XG4gICAgaWYgKGJhY2twcmVzc3VyZSkge1xuICAgICAgZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZVJlc2V0KHdyaXRlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2VydCghYmFja3ByZXNzdXJlKTtcblxuICAgICAgZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZVJlc29sdmUod3JpdGVyKTtcbiAgICB9XG4gIH1cblxuICBzdHJlYW0uX2JhY2twcmVzc3VyZSA9IGJhY2twcmVzc3VyZTtcbn1cblxuLyoqXG4gKiBBIGRlZmF1bHQgd3JpdGVyIHZlbmRlZCBieSBhIHtAbGluayBXcml0YWJsZVN0cmVhbX0uXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyPFcgPSBhbnk+IHtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfb3duZXJXcml0YWJsZVN0cmVhbTogV3JpdGFibGVTdHJlYW08Vz47XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2Nsb3NlZFByb21pc2UhOiBQcm9taXNlPHVuZGVmaW5lZD47XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2Nsb3NlZFByb21pc2VfcmVzb2x2ZT86ICh2YWx1ZT86IHVuZGVmaW5lZCkgPT4gdm9pZDtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfY2xvc2VkUHJvbWlzZV9yZWplY3Q/OiAocmVhc29uOiBhbnkpID0+IHZvaWQ7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2Nsb3NlZFByb21pc2VTdGF0ZSE6ICdwZW5kaW5nJyB8ICdyZXNvbHZlZCcgfCAncmVqZWN0ZWQnO1xuICAvKiogQGludGVybmFsICovXG4gIF9yZWFkeVByb21pc2UhOiBQcm9taXNlPHVuZGVmaW5lZD47XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3JlYWR5UHJvbWlzZV9yZXNvbHZlPzogKHZhbHVlPzogdW5kZWZpbmVkKSA9PiB2b2lkO1xuICAvKiogQGludGVybmFsICovXG4gIF9yZWFkeVByb21pc2VfcmVqZWN0PzogKHJlYXNvbjogYW55KSA9PiB2b2lkO1xuICAvKiogQGludGVybmFsICovXG4gIF9yZWFkeVByb21pc2VTdGF0ZSE6ICdwZW5kaW5nJyB8ICdmdWxmaWxsZWQnIHwgJ3JlamVjdGVkJztcblxuICBjb25zdHJ1Y3RvcihzdHJlYW06IFdyaXRhYmxlU3RyZWFtPFc+KSB7XG4gICAgYXNzZXJ0UmVxdWlyZWRBcmd1bWVudChzdHJlYW0sIDEsICdXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXInKTtcbiAgICBhc3NlcnRXcml0YWJsZVN0cmVhbShzdHJlYW0sICdGaXJzdCBwYXJhbWV0ZXInKTtcblxuICAgIGlmIChJc1dyaXRhYmxlU3RyZWFtTG9ja2VkKHN0cmVhbSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoaXMgc3RyZWFtIGhhcyBhbHJlYWR5IGJlZW4gbG9ja2VkIGZvciBleGNsdXNpdmUgd3JpdGluZyBieSBhbm90aGVyIHdyaXRlcicpO1xuICAgIH1cblxuICAgIHRoaXMuX293bmVyV3JpdGFibGVTdHJlYW0gPSBzdHJlYW07XG4gICAgc3RyZWFtLl93cml0ZXIgPSB0aGlzO1xuXG4gICAgY29uc3Qgc3RhdGUgPSBzdHJlYW0uX3N0YXRlO1xuXG4gICAgaWYgKHN0YXRlID09PSAnd3JpdGFibGUnKSB7XG4gICAgICBpZiAoIVdyaXRhYmxlU3RyZWFtQ2xvc2VRdWV1ZWRPckluRmxpZ2h0KHN0cmVhbSkgJiYgc3RyZWFtLl9iYWNrcHJlc3N1cmUpIHtcbiAgICAgICAgZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZUluaXRpYWxpemUodGhpcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlSW5pdGlhbGl6ZUFzUmVzb2x2ZWQodGhpcyk7XG4gICAgICB9XG5cbiAgICAgIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZSh0aGlzKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlID09PSAnZXJyb3JpbmcnKSB7XG4gICAgICBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlSW5pdGlhbGl6ZUFzUmVqZWN0ZWQodGhpcywgc3RyZWFtLl9zdG9yZWRFcnJvcik7XG4gICAgICBkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemUodGhpcyk7XG4gICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICAgIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VJbml0aWFsaXplQXNSZXNvbHZlZCh0aGlzKTtcbiAgICAgIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZUFzUmVzb2x2ZWQodGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2VydChzdGF0ZSA9PT0gJ2Vycm9yZWQnKTtcblxuICAgICAgY29uc3Qgc3RvcmVkRXJyb3IgPSBzdHJlYW0uX3N0b3JlZEVycm9yO1xuICAgICAgZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZUluaXRpYWxpemVBc1JlamVjdGVkKHRoaXMsIHN0b3JlZEVycm9yKTtcbiAgICAgIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZUFzUmVqZWN0ZWQodGhpcywgc3RvcmVkRXJyb3IpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHdpbGwgYmUgZnVsZmlsbGVkIHdoZW4gdGhlIHN0cmVhbSBiZWNvbWVzIGNsb3NlZCwgb3IgcmVqZWN0ZWQgaWYgdGhlIHN0cmVhbSBldmVyIGVycm9ycyBvclxuICAgKiB0aGUgd3JpdGVy4oCZcyBsb2NrIGlzIHJlbGVhc2VkIGJlZm9yZSB0aGUgc3RyZWFtIGZpbmlzaGVzIGNsb3NpbmcuXG4gICAqL1xuICBnZXQgY2xvc2VkKCk6IFByb21pc2U8dW5kZWZpbmVkPiB7XG4gICAgaWYgKCFJc1dyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcih0aGlzKSkge1xuICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoZGVmYXVsdFdyaXRlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ2Nsb3NlZCcpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fY2xvc2VkUHJvbWlzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBkZXNpcmVkIHNpemUgdG8gZmlsbCB0aGUgc3RyZWFt4oCZcyBpbnRlcm5hbCBxdWV1ZS4gSXQgY2FuIGJlIG5lZ2F0aXZlLCBpZiB0aGUgcXVldWUgaXMgb3Zlci1mdWxsLlxuICAgKiBBIHByb2R1Y2VyIGNhbiB1c2UgdGhpcyBpbmZvcm1hdGlvbiB0byBkZXRlcm1pbmUgdGhlIHJpZ2h0IGFtb3VudCBvZiBkYXRhIHRvIHdyaXRlLlxuICAgKlxuICAgKiBJdCB3aWxsIGJlIGBudWxsYCBpZiB0aGUgc3RyZWFtIGNhbm5vdCBiZSBzdWNjZXNzZnVsbHkgd3JpdHRlbiB0byAoZHVlIHRvIGVpdGhlciBiZWluZyBlcnJvcmVkLCBvciBoYXZpbmcgYW4gYWJvcnRcbiAgICogcXVldWVkIHVwKS4gSXQgd2lsbCByZXR1cm4gemVybyBpZiB0aGUgc3RyZWFtIGlzIGNsb3NlZC4gQW5kIHRoZSBnZXR0ZXIgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24gaWYgaW52b2tlZCB3aGVuXG4gICAqIHRoZSB3cml0ZXLigJlzIGxvY2sgaXMgcmVsZWFzZWQuXG4gICAqL1xuICBnZXQgZGVzaXJlZFNpemUoKTogbnVtYmVyIHwgbnVsbCB7XG4gICAgaWYgKCFJc1dyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcih0aGlzKSkge1xuICAgICAgdGhyb3cgZGVmYXVsdFdyaXRlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ2Rlc2lyZWRTaXplJyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX293bmVyV3JpdGFibGVTdHJlYW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgZGVmYXVsdFdyaXRlckxvY2tFeGNlcHRpb24oJ2Rlc2lyZWRTaXplJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckdldERlc2lyZWRTaXplKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBwcm9taXNlIHRoYXQgd2lsbCBiZSBmdWxmaWxsZWQgd2hlbiB0aGUgZGVzaXJlZCBzaXplIHRvIGZpbGwgdGhlIHN0cmVhbeKAmXMgaW50ZXJuYWwgcXVldWUgdHJhbnNpdGlvbnNcbiAgICogZnJvbSBub24tcG9zaXRpdmUgdG8gcG9zaXRpdmUsIHNpZ25hbGluZyB0aGF0IGl0IGlzIG5vIGxvbmdlciBhcHBseWluZyBiYWNrcHJlc3N1cmUuIE9uY2UgdGhlIGRlc2lyZWQgc2l6ZSBkaXBzXG4gICAqIGJhY2sgdG8gemVybyBvciBiZWxvdywgdGhlIGdldHRlciB3aWxsIHJldHVybiBhIG5ldyBwcm9taXNlIHRoYXQgc3RheXMgcGVuZGluZyB1bnRpbCB0aGUgbmV4dCB0cmFuc2l0aW9uLlxuICAgKlxuICAgKiBJZiB0aGUgc3RyZWFtIGJlY29tZXMgZXJyb3JlZCBvciBhYm9ydGVkLCBvciB0aGUgd3JpdGVy4oCZcyBsb2NrIGlzIHJlbGVhc2VkLCB0aGUgcmV0dXJuZWQgcHJvbWlzZSB3aWxsIGJlY29tZVxuICAgKiByZWplY3RlZC5cbiAgICovXG4gIGdldCByZWFkeSgpOiBQcm9taXNlPHVuZGVmaW5lZD4ge1xuICAgIGlmICghSXNXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIodGhpcykpIHtcbiAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGRlZmF1bHRXcml0ZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdyZWFkeScpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fcmVhZHlQcm9taXNlO1xuICB9XG5cbiAgLyoqXG4gICAqIElmIHRoZSByZWFkZXIgaXMgYWN0aXZlLCBiZWhhdmVzIHRoZSBzYW1lIGFzIHtAbGluayBXcml0YWJsZVN0cmVhbS5hYm9ydCB8IHN0cmVhbS5hYm9ydChyZWFzb24pfS5cbiAgICovXG4gIGFib3J0KHJlYXNvbjogYW55ID0gdW5kZWZpbmVkKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKCFJc1dyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcih0aGlzKSkge1xuICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoZGVmYXVsdFdyaXRlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ2Fib3J0JykpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9vd25lcldyaXRhYmxlU3RyZWFtID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGRlZmF1bHRXcml0ZXJMb2NrRXhjZXB0aW9uKCdhYm9ydCcpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyQWJvcnQodGhpcywgcmVhc29uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJZiB0aGUgcmVhZGVyIGlzIGFjdGl2ZSwgYmVoYXZlcyB0aGUgc2FtZSBhcyB7QGxpbmsgV3JpdGFibGVTdHJlYW0uY2xvc2UgfCBzdHJlYW0uY2xvc2UoKX0uXG4gICAqL1xuICBjbG9zZSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAoIUlzV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyKHRoaXMpKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChkZWZhdWx0V3JpdGVyQnJhbmRDaGVja0V4Y2VwdGlvbignY2xvc2UnKSk7XG4gICAgfVxuXG4gICAgY29uc3Qgc3RyZWFtID0gdGhpcy5fb3duZXJXcml0YWJsZVN0cmVhbTtcblxuICAgIGlmIChzdHJlYW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoZGVmYXVsdFdyaXRlckxvY2tFeGNlcHRpb24oJ2Nsb3NlJykpO1xuICAgIH1cblxuICAgIGlmIChXcml0YWJsZVN0cmVhbUNsb3NlUXVldWVkT3JJbkZsaWdodChzdHJlYW0pKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2xvc2UgYW4gYWxyZWFkeS1jbG9zaW5nIHN0cmVhbScpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyQ2xvc2UodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogUmVsZWFzZXMgdGhlIHdyaXRlcuKAmXMgbG9jayBvbiB0aGUgY29ycmVzcG9uZGluZyBzdHJlYW0uIEFmdGVyIHRoZSBsb2NrIGlzIHJlbGVhc2VkLCB0aGUgd3JpdGVyIGlzIG5vIGxvbmdlciBhY3RpdmUuXG4gICAqIElmIHRoZSBhc3NvY2lhdGVkIHN0cmVhbSBpcyBlcnJvcmVkIHdoZW4gdGhlIGxvY2sgaXMgcmVsZWFzZWQsIHRoZSB3cml0ZXIgd2lsbCBhcHBlYXIgZXJyb3JlZCBpbiB0aGUgc2FtZSB3YXkgZnJvbVxuICAgKiBub3cgb247IG90aGVyd2lzZSwgdGhlIHdyaXRlciB3aWxsIGFwcGVhciBjbG9zZWQuXG4gICAqXG4gICAqIE5vdGUgdGhhdCB0aGUgbG9jayBjYW4gc3RpbGwgYmUgcmVsZWFzZWQgZXZlbiBpZiBzb21lIG9uZ29pbmcgd3JpdGVzIGhhdmUgbm90IHlldCBmaW5pc2hlZCAoaS5lLiBldmVuIGlmIHRoZVxuICAgKiBwcm9taXNlcyByZXR1cm5lZCBmcm9tIHByZXZpb3VzIGNhbGxzIHRvIHtAbGluayBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIud3JpdGUgfCB3cml0ZSgpfSBoYXZlIG5vdCB5ZXQgc2V0dGxlZCkuXG4gICAqIEl04oCZcyBub3QgbmVjZXNzYXJ5IHRvIGhvbGQgdGhlIGxvY2sgb24gdGhlIHdyaXRlciBmb3IgdGhlIGR1cmF0aW9uIG9mIHRoZSB3cml0ZTsgdGhlIGxvY2sgaW5zdGVhZCBzaW1wbHkgcHJldmVudHNcbiAgICogb3RoZXIgcHJvZHVjZXJzIGZyb20gd3JpdGluZyBpbiBhbiBpbnRlcmxlYXZlZCBtYW5uZXIuXG4gICAqL1xuICByZWxlYXNlTG9jaygpOiB2b2lkIHtcbiAgICBpZiAoIUlzV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyKHRoaXMpKSB7XG4gICAgICB0aHJvdyBkZWZhdWx0V3JpdGVyQnJhbmRDaGVja0V4Y2VwdGlvbigncmVsZWFzZUxvY2snKTtcbiAgICB9XG5cbiAgICBjb25zdCBzdHJlYW0gPSB0aGlzLl9vd25lcldyaXRhYmxlU3RyZWFtO1xuXG4gICAgaWYgKHN0cmVhbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgYXNzZXJ0KHN0cmVhbS5fd3JpdGVyICE9PSB1bmRlZmluZWQpO1xuXG4gICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyUmVsZWFzZSh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXcml0ZXMgdGhlIGdpdmVuIGNodW5rIHRvIHRoZSB3cml0YWJsZSBzdHJlYW0sIGJ5IHdhaXRpbmcgdW50aWwgYW55IHByZXZpb3VzIHdyaXRlcyBoYXZlIGZpbmlzaGVkIHN1Y2Nlc3NmdWxseSxcbiAgICogYW5kIHRoZW4gc2VuZGluZyB0aGUgY2h1bmsgdG8gdGhlIHVuZGVybHlpbmcgc2luaydzIHtAbGluayBVbmRlcmx5aW5nU2luay53cml0ZSB8IHdyaXRlKCl9IG1ldGhvZC4gSXQgd2lsbCByZXR1cm5cbiAgICogYSBwcm9taXNlIHRoYXQgZnVsZmlsbHMgd2l0aCB1bmRlZmluZWQgdXBvbiBhIHN1Y2Nlc3NmdWwgd3JpdGUsIG9yIHJlamVjdHMgaWYgdGhlIHdyaXRlIGZhaWxzIG9yIHN0cmVhbSBiZWNvbWVzXG4gICAqIGVycm9yZWQgYmVmb3JlIHRoZSB3cml0aW5nIHByb2Nlc3MgaXMgaW5pdGlhdGVkLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgd2hhdCBcInN1Y2Nlc3NcIiBtZWFucyBpcyB1cCB0byB0aGUgdW5kZXJseWluZyBzaW5rOyBpdCBtaWdodCBpbmRpY2F0ZSBzaW1wbHkgdGhhdCB0aGUgY2h1bmsgaGFzIGJlZW5cbiAgICogYWNjZXB0ZWQsIGFuZCBub3QgbmVjZXNzYXJpbHkgdGhhdCBpdCBpcyBzYWZlbHkgc2F2ZWQgdG8gaXRzIHVsdGltYXRlIGRlc3RpbmF0aW9uLlxuICAgKi9cbiAgd3JpdGUoY2h1bms6IFcpOiBQcm9taXNlPHZvaWQ+O1xuICB3cml0ZShjaHVuazogVyA9IHVuZGVmaW5lZCEpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAoIUlzV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyKHRoaXMpKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChkZWZhdWx0V3JpdGVyQnJhbmRDaGVja0V4Y2VwdGlvbignd3JpdGUnKSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX293bmVyV3JpdGFibGVTdHJlYW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoZGVmYXVsdFdyaXRlckxvY2tFeGNlcHRpb24oJ3dyaXRlIHRvJykpO1xuICAgIH1cblxuICAgIHJldHVybiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJXcml0ZSh0aGlzLCBjaHVuayk7XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyLnByb3RvdHlwZSwge1xuICBhYm9ydDogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gIGNsb3NlOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgcmVsZWFzZUxvY2s6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICB3cml0ZTogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gIGNsb3NlZDogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gIGRlc2lyZWRTaXplOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgcmVhZHk6IHsgZW51bWVyYWJsZTogdHJ1ZSB9XG59KTtcbmlmICh0eXBlb2YgU3ltYm9sLnRvU3RyaW5nVGFnID09PSAnc3ltYm9sJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyLnByb3RvdHlwZSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7XG4gICAgdmFsdWU6ICdXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXInLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuLy8gQWJzdHJhY3Qgb3BlcmF0aW9ucyBmb3IgdGhlIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlci5cblxuZnVuY3Rpb24gSXNXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXI8VyA9IGFueT4oeDogYW55KTogeCBpcyBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXI8Vz4ge1xuICBpZiAoIXR5cGVJc09iamVjdCh4KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdfb3duZXJXcml0YWJsZVN0cmVhbScpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHggaW5zdGFuY2VvZiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXI7XG59XG5cbi8vIEEgY2xpZW50IG9mIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlciBtYXkgdXNlIHRoZXNlIGZ1bmN0aW9ucyBkaXJlY3RseSB0byBieXBhc3Mgc3RhdGUgY2hlY2suXG5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckFib3J0KHdyaXRlcjogV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyLCByZWFzb246IGFueSkge1xuICBjb25zdCBzdHJlYW0gPSB3cml0ZXIuX293bmVyV3JpdGFibGVTdHJlYW07XG5cbiAgYXNzZXJ0KHN0cmVhbSAhPT0gdW5kZWZpbmVkKTtcblxuICByZXR1cm4gV3JpdGFibGVTdHJlYW1BYm9ydChzdHJlYW0sIHJlYXNvbik7XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckNsb3NlKHdyaXRlcjogV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyKTogUHJvbWlzZTx1bmRlZmluZWQ+IHtcbiAgY29uc3Qgc3RyZWFtID0gd3JpdGVyLl9vd25lcldyaXRhYmxlU3RyZWFtO1xuXG4gIGFzc2VydChzdHJlYW0gIT09IHVuZGVmaW5lZCk7XG5cbiAgcmV0dXJuIFdyaXRhYmxlU3RyZWFtQ2xvc2Uoc3RyZWFtKTtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyQ2xvc2VXaXRoRXJyb3JQcm9wYWdhdGlvbih3cml0ZXI6IFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcik6IFByb21pc2U8dW5kZWZpbmVkPiB7XG4gIGNvbnN0IHN0cmVhbSA9IHdyaXRlci5fb3duZXJXcml0YWJsZVN0cmVhbTtcblxuICBhc3NlcnQoc3RyZWFtICE9PSB1bmRlZmluZWQpO1xuXG4gIGNvbnN0IHN0YXRlID0gc3RyZWFtLl9zdGF0ZTtcbiAgaWYgKFdyaXRhYmxlU3RyZWFtQ2xvc2VRdWV1ZWRPckluRmxpZ2h0KHN0cmVhbSkgfHwgc3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICAgcmV0dXJuIHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcbiAgfVxuXG4gIGlmIChzdGF0ZSA9PT0gJ2Vycm9yZWQnKSB7XG4gICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoc3RyZWFtLl9zdG9yZWRFcnJvcik7XG4gIH1cblxuICBhc3NlcnQoc3RhdGUgPT09ICd3cml0YWJsZScgfHwgc3RhdGUgPT09ICdlcnJvcmluZycpO1xuXG4gIHJldHVybiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJDbG9zZSh3cml0ZXIpO1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJFbnN1cmVDbG9zZWRQcm9taXNlUmVqZWN0ZWQod3JpdGVyOiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIsIGVycm9yOiBhbnkpIHtcbiAgaWYgKHdyaXRlci5fY2xvc2VkUHJvbWlzZVN0YXRlID09PSAncGVuZGluZycpIHtcbiAgICBkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZVJlamVjdCh3cml0ZXIsIGVycm9yKTtcbiAgfSBlbHNlIHtcbiAgICBkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZVJlc2V0VG9SZWplY3RlZCh3cml0ZXIsIGVycm9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJFbnN1cmVSZWFkeVByb21pc2VSZWplY3RlZCh3cml0ZXI6IFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlciwgZXJyb3I6IGFueSkge1xuICBpZiAod3JpdGVyLl9yZWFkeVByb21pc2VTdGF0ZSA9PT0gJ3BlbmRpbmcnKSB7XG4gICAgZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZVJlamVjdCh3cml0ZXIsIGVycm9yKTtcbiAgfSBlbHNlIHtcbiAgICBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlUmVzZXRUb1JlamVjdGVkKHdyaXRlciwgZXJyb3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckdldERlc2lyZWRTaXplKHdyaXRlcjogV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyKTogbnVtYmVyIHwgbnVsbCB7XG4gIGNvbnN0IHN0cmVhbSA9IHdyaXRlci5fb3duZXJXcml0YWJsZVN0cmVhbTtcbiAgY29uc3Qgc3RhdGUgPSBzdHJlYW0uX3N0YXRlO1xuXG4gIGlmIChzdGF0ZSA9PT0gJ2Vycm9yZWQnIHx8IHN0YXRlID09PSAnZXJyb3JpbmcnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAoc3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICByZXR1cm4gV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckdldERlc2lyZWRTaXplKHN0cmVhbS5fd3JpdGFibGVTdHJlYW1Db250cm9sbGVyKTtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyUmVsZWFzZSh3cml0ZXI6IFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcikge1xuICBjb25zdCBzdHJlYW0gPSB3cml0ZXIuX293bmVyV3JpdGFibGVTdHJlYW07XG4gIGFzc2VydChzdHJlYW0gIT09IHVuZGVmaW5lZCk7XG4gIGFzc2VydChzdHJlYW0uX3dyaXRlciA9PT0gd3JpdGVyKTtcblxuICBjb25zdCByZWxlYXNlZEVycm9yID0gbmV3IFR5cGVFcnJvcihcbiAgICBgV3JpdGVyIHdhcyByZWxlYXNlZCBhbmQgY2FuIG5vIGxvbmdlciBiZSB1c2VkIHRvIG1vbml0b3IgdGhlIHN0cmVhbSdzIGNsb3NlZG5lc3NgKTtcblxuICBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJFbnN1cmVSZWFkeVByb21pc2VSZWplY3RlZCh3cml0ZXIsIHJlbGVhc2VkRXJyb3IpO1xuXG4gIC8vIFRoZSBzdGF0ZSB0cmFuc2l0aW9ucyB0byBcImVycm9yZWRcIiBiZWZvcmUgdGhlIHNpbmsgYWJvcnQoKSBtZXRob2QgcnVucywgYnV0IHRoZSB3cml0ZXIuY2xvc2VkIHByb21pc2UgaXMgbm90XG4gIC8vIHJlamVjdGVkIHVudGlsIGFmdGVyd2FyZHMuIFRoaXMgbWVhbnMgdGhhdCBzaW1wbHkgdGVzdGluZyBzdGF0ZSB3aWxsIG5vdCB3b3JrLlxuICBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJFbnN1cmVDbG9zZWRQcm9taXNlUmVqZWN0ZWQod3JpdGVyLCByZWxlYXNlZEVycm9yKTtcblxuICBzdHJlYW0uX3dyaXRlciA9IHVuZGVmaW5lZDtcbiAgd3JpdGVyLl9vd25lcldyaXRhYmxlU3RyZWFtID0gdW5kZWZpbmVkITtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyV3JpdGU8Vz4od3JpdGVyOiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXI8Vz4sIGNodW5rOiBXKTogUHJvbWlzZTx1bmRlZmluZWQ+IHtcbiAgY29uc3Qgc3RyZWFtID0gd3JpdGVyLl9vd25lcldyaXRhYmxlU3RyZWFtO1xuXG4gIGFzc2VydChzdHJlYW0gIT09IHVuZGVmaW5lZCk7XG5cbiAgY29uc3QgY29udHJvbGxlciA9IHN0cmVhbS5fd3JpdGFibGVTdHJlYW1Db250cm9sbGVyO1xuXG4gIGNvbnN0IGNodW5rU2l6ZSA9IFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJHZXRDaHVua1NpemUoY29udHJvbGxlciwgY2h1bmspO1xuXG4gIGlmIChzdHJlYW0gIT09IHdyaXRlci5fb3duZXJXcml0YWJsZVN0cmVhbSkge1xuICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGRlZmF1bHRXcml0ZXJMb2NrRXhjZXB0aW9uKCd3cml0ZSB0bycpKTtcbiAgfVxuXG4gIGNvbnN0IHN0YXRlID0gc3RyZWFtLl9zdGF0ZTtcbiAgaWYgKHN0YXRlID09PSAnZXJyb3JlZCcpIHtcbiAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChzdHJlYW0uX3N0b3JlZEVycm9yKTtcbiAgfVxuICBpZiAoV3JpdGFibGVTdHJlYW1DbG9zZVF1ZXVlZE9ySW5GbGlnaHQoc3RyZWFtKSB8fCBzdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChuZXcgVHlwZUVycm9yKCdUaGUgc3RyZWFtIGlzIGNsb3Npbmcgb3IgY2xvc2VkIGFuZCBjYW5ub3QgYmUgd3JpdHRlbiB0bycpKTtcbiAgfVxuICBpZiAoc3RhdGUgPT09ICdlcnJvcmluZycpIHtcbiAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChzdHJlYW0uX3N0b3JlZEVycm9yKTtcbiAgfVxuXG4gIGFzc2VydChzdGF0ZSA9PT0gJ3dyaXRhYmxlJyk7XG5cbiAgY29uc3QgcHJvbWlzZSA9IFdyaXRhYmxlU3RyZWFtQWRkV3JpdGVSZXF1ZXN0KHN0cmVhbSk7XG5cbiAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcldyaXRlKGNvbnRyb2xsZXIsIGNodW5rLCBjaHVua1NpemUpO1xuXG4gIHJldHVybiBwcm9taXNlO1xufVxuXG5jb25zdCBjbG9zZVNlbnRpbmVsOiB1bmlxdWUgc3ltYm9sID0ge30gYXMgYW55O1xuXG50eXBlIFF1ZXVlUmVjb3JkPFc+ID0gVyB8IHR5cGVvZiBjbG9zZVNlbnRpbmVsO1xuXG4vKipcbiAqIEFsbG93cyBjb250cm9sIG9mIGEge0BsaW5rIFdyaXRhYmxlU3RyZWFtIHwgd3JpdGFibGUgc3RyZWFtfSdzIHN0YXRlIGFuZCBpbnRlcm5hbCBxdWV1ZS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyPFcgPSBhbnk+IHtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfY29udHJvbGxlZFdyaXRhYmxlU3RyZWFtITogV3JpdGFibGVTdHJlYW08Vz47XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3F1ZXVlITogU2ltcGxlUXVldWU8UXVldWVQYWlyPFF1ZXVlUmVjb3JkPFc+Pj47XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3F1ZXVlVG90YWxTaXplITogbnVtYmVyO1xuICAvKiogQGludGVybmFsICovXG4gIF9hYm9ydFJlYXNvbjogYW55O1xuICAvKiogQGludGVybmFsICovXG4gIF9hYm9ydENvbnRyb2xsZXI6IEFib3J0Q29udHJvbGxlciB8IHVuZGVmaW5lZDtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfc3RhcnRlZCE6IGJvb2xlYW47XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3N0cmF0ZWd5U2l6ZUFsZ29yaXRobSE6IFF1ZXVpbmdTdHJhdGVneVNpemVDYWxsYmFjazxXPjtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfc3RyYXRlZ3lIV00hOiBudW1iZXI7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3dyaXRlQWxnb3JpdGhtITogKGNodW5rOiBXKSA9PiBQcm9taXNlPHZvaWQ+O1xuICAvKiogQGludGVybmFsICovXG4gIF9jbG9zZUFsZ29yaXRobSE6ICgpID0+IFByb21pc2U8dm9pZD47XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2Fib3J0QWxnb3JpdGhtITogKHJlYXNvbjogYW55KSA9PiBQcm9taXNlPHZvaWQ+O1xuXG4gIHByaXZhdGUgY29uc3RydWN0b3IoKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSWxsZWdhbCBjb25zdHJ1Y3RvcicpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSByZWFzb24gd2hpY2ggd2FzIHBhc3NlZCB0byBgV3JpdGFibGVTdHJlYW0uYWJvcnQocmVhc29uKWAgd2hlbiB0aGUgc3RyZWFtIHdhcyBhYm9ydGVkLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKiAgVGhpcyBwcm9wZXJ0eSBoYXMgYmVlbiByZW1vdmVkIGZyb20gdGhlIHNwZWNpZmljYXRpb24sIHNlZSBodHRwczovL2dpdGh1Yi5jb20vd2hhdHdnL3N0cmVhbXMvcHVsbC8xMTc3LlxuICAgKiAgVXNlIHtAbGluayBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnNpZ25hbH0ncyBgcmVhc29uYCBpbnN0ZWFkLlxuICAgKi9cbiAgZ2V0IGFib3J0UmVhc29uKCk6IGFueSB7XG4gICAgaWYgKCFJc1dyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIodGhpcykpIHtcbiAgICAgIHRocm93IGRlZmF1bHRDb250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbignYWJvcnRSZWFzb24nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2Fib3J0UmVhc29uO1xuICB9XG5cbiAgLyoqXG4gICAqIEFuIGBBYm9ydFNpZ25hbGAgdGhhdCBjYW4gYmUgdXNlZCB0byBhYm9ydCB0aGUgcGVuZGluZyB3cml0ZSBvciBjbG9zZSBvcGVyYXRpb24gd2hlbiB0aGUgc3RyZWFtIGlzIGFib3J0ZWQuXG4gICAqL1xuICBnZXQgc2lnbmFsKCk6IEFib3J0U2lnbmFsIHtcbiAgICBpZiAoIUlzV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcih0aGlzKSkge1xuICAgICAgdGhyb3cgZGVmYXVsdENvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdzaWduYWwnKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2Fib3J0Q29udHJvbGxlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBPbGRlciBicm93c2VycyBvciBvbGRlciBOb2RlIHZlcnNpb25zIG1heSBub3Qgc3VwcG9ydCBgQWJvcnRDb250cm9sbGVyYCBvciBgQWJvcnRTaWduYWxgLlxuICAgICAgLy8gV2UgZG9uJ3Qgd2FudCB0byBidW5kbGUgYW5kIHNoaXAgYW4gYEFib3J0Q29udHJvbGxlcmAgcG9seWZpbGwgdG9nZXRoZXIgd2l0aCBvdXIgcG9seWZpbGwsXG4gICAgICAvLyBzbyBpbnN0ZWFkIHdlIG9ubHkgaW1wbGVtZW50IHN1cHBvcnQgZm9yIGBzaWduYWxgIGlmIHdlIGZpbmQgYSBnbG9iYWwgYEFib3J0Q29udHJvbGxlcmAgY29uc3RydWN0b3IuXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZS5zaWduYWwgaXMgbm90IHN1cHBvcnRlZCcpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fYWJvcnRDb250cm9sbGVyLnNpZ25hbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9zZXMgdGhlIGNvbnRyb2xsZWQgd3JpdGFibGUgc3RyZWFtLCBtYWtpbmcgYWxsIGZ1dHVyZSBpbnRlcmFjdGlvbnMgd2l0aCBpdCBmYWlsIHdpdGggdGhlIGdpdmVuIGVycm9yIGBlYC5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgaXMgcmFyZWx5IHVzZWQsIHNpbmNlIHVzdWFsbHkgaXQgc3VmZmljZXMgdG8gcmV0dXJuIGEgcmVqZWN0ZWQgcHJvbWlzZSBmcm9tIG9uZSBvZiB0aGUgdW5kZXJseWluZ1xuICAgKiBzaW5rJ3MgbWV0aG9kcy4gSG93ZXZlciwgaXQgY2FuIGJlIHVzZWZ1bCBmb3Igc3VkZGVubHkgc2h1dHRpbmcgZG93biBhIHN0cmVhbSBpbiByZXNwb25zZSB0byBhbiBldmVudCBvdXRzaWRlIHRoZVxuICAgKiBub3JtYWwgbGlmZWN5Y2xlIG9mIGludGVyYWN0aW9ucyB3aXRoIHRoZSB1bmRlcmx5aW5nIHNpbmsuXG4gICAqL1xuICBlcnJvcihlOiBhbnkgPSB1bmRlZmluZWQpOiB2b2lkIHtcbiAgICBpZiAoIUlzV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcih0aGlzKSkge1xuICAgICAgdGhyb3cgZGVmYXVsdENvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdlcnJvcicpO1xuICAgIH1cbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuX2NvbnRyb2xsZWRXcml0YWJsZVN0cmVhbS5fc3RhdGU7XG4gICAgaWYgKHN0YXRlICE9PSAnd3JpdGFibGUnKSB7XG4gICAgICAvLyBUaGUgc3RyZWFtIGlzIGNsb3NlZCwgZXJyb3JlZCBvciB3aWxsIGJlIHNvb24uIFRoZSBzaW5rIGNhbid0IGRvIGFueXRoaW5nIHVzZWZ1bCBpZiBpdCBnZXRzIGFuIGVycm9yIGhlcmUsIHNvXG4gICAgICAvLyBqdXN0IHRyZWF0IGl0IGFzIGEgbm8tb3AuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9yKHRoaXMsIGUpO1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBbQWJvcnRTdGVwc10ocmVhc29uOiBhbnkpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9hYm9ydEFsZ29yaXRobShyZWFzb24pO1xuICAgIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbGVhckFsZ29yaXRobXModGhpcyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgW0Vycm9yU3RlcHNdKCkge1xuICAgIFJlc2V0UXVldWUodGhpcyk7XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUsIHtcbiAgYWJvcnRSZWFzb246IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICBzaWduYWw6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICBlcnJvcjogeyBlbnVtZXJhYmxlOiB0cnVlIH1cbn0pO1xuaWYgKHR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWcgPT09ICdzeW1ib2wnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7XG4gICAgdmFsdWU6ICdXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyJyxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbi8vIEFic3RyYWN0IG9wZXJhdGlvbnMgaW1wbGVtZW50aW5nIGludGVyZmFjZSByZXF1aXJlZCBieSB0aGUgV3JpdGFibGVTdHJlYW0uXG5cbmZ1bmN0aW9uIElzV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcih4OiBhbnkpOiB4IGlzIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8YW55PiB7XG4gIGlmICghdHlwZUlzT2JqZWN0KHgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ19jb250cm9sbGVkV3JpdGFibGVTdHJlYW0nKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB4IGluc3RhbmNlb2YgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcjtcbn1cblxuZnVuY3Rpb24gU2V0VXBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyPFc+KHN0cmVhbTogV3JpdGFibGVTdHJlYW08Vz4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlcjogV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxXPixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydEFsZ29yaXRobTogKCkgPT4gdm9pZCB8IFByb21pc2VMaWtlPHZvaWQ+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRlQWxnb3JpdGhtOiAoY2h1bms6IFcpID0+IFByb21pc2U8dm9pZD4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2VBbGdvcml0aG06ICgpID0+IFByb21pc2U8dm9pZD4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWJvcnRBbGdvcml0aG06IChyZWFzb246IGFueSkgPT4gUHJvbWlzZTx2b2lkPixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaWdoV2F0ZXJNYXJrOiBudW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZUFsZ29yaXRobTogUXVldWluZ1N0cmF0ZWd5U2l6ZUNhbGxiYWNrPFc+KSB7XG4gIGFzc2VydChJc1dyaXRhYmxlU3RyZWFtKHN0cmVhbSkpO1xuICBhc3NlcnQoc3RyZWFtLl93cml0YWJsZVN0cmVhbUNvbnRyb2xsZXIgPT09IHVuZGVmaW5lZCk7XG5cbiAgY29udHJvbGxlci5fY29udHJvbGxlZFdyaXRhYmxlU3RyZWFtID0gc3RyZWFtO1xuICBzdHJlYW0uX3dyaXRhYmxlU3RyZWFtQ29udHJvbGxlciA9IGNvbnRyb2xsZXI7XG5cbiAgLy8gTmVlZCB0byBzZXQgdGhlIHNsb3RzIHNvIHRoYXQgdGhlIGFzc2VydCBkb2Vzbid0IGZpcmUuIEluIHRoZSBzcGVjIHRoZSBzbG90cyBhbHJlYWR5IGV4aXN0IGltcGxpY2l0bHkuXG4gIGNvbnRyb2xsZXIuX3F1ZXVlID0gdW5kZWZpbmVkITtcbiAgY29udHJvbGxlci5fcXVldWVUb3RhbFNpemUgPSB1bmRlZmluZWQhO1xuICBSZXNldFF1ZXVlKGNvbnRyb2xsZXIpO1xuXG4gIGNvbnRyb2xsZXIuX2Fib3J0UmVhc29uID0gdW5kZWZpbmVkO1xuICBjb250cm9sbGVyLl9hYm9ydENvbnRyb2xsZXIgPSBjcmVhdGVBYm9ydENvbnRyb2xsZXIoKTtcbiAgY29udHJvbGxlci5fc3RhcnRlZCA9IGZhbHNlO1xuXG4gIGNvbnRyb2xsZXIuX3N0cmF0ZWd5U2l6ZUFsZ29yaXRobSA9IHNpemVBbGdvcml0aG07XG4gIGNvbnRyb2xsZXIuX3N0cmF0ZWd5SFdNID0gaGlnaFdhdGVyTWFyaztcblxuICBjb250cm9sbGVyLl93cml0ZUFsZ29yaXRobSA9IHdyaXRlQWxnb3JpdGhtO1xuICBjb250cm9sbGVyLl9jbG9zZUFsZ29yaXRobSA9IGNsb3NlQWxnb3JpdGhtO1xuICBjb250cm9sbGVyLl9hYm9ydEFsZ29yaXRobSA9IGFib3J0QWxnb3JpdGhtO1xuXG4gIGNvbnN0IGJhY2twcmVzc3VyZSA9IFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJHZXRCYWNrcHJlc3N1cmUoY29udHJvbGxlcik7XG4gIFdyaXRhYmxlU3RyZWFtVXBkYXRlQmFja3ByZXNzdXJlKHN0cmVhbSwgYmFja3ByZXNzdXJlKTtcblxuICBjb25zdCBzdGFydFJlc3VsdCA9IHN0YXJ0QWxnb3JpdGhtKCk7XG4gIGNvbnN0IHN0YXJ0UHJvbWlzZSA9IHByb21pc2VSZXNvbHZlZFdpdGgoc3RhcnRSZXN1bHQpO1xuICB1cG9uUHJvbWlzZShcbiAgICBzdGFydFByb21pc2UsXG4gICAgKCkgPT4ge1xuICAgICAgYXNzZXJ0KHN0cmVhbS5fc3RhdGUgPT09ICd3cml0YWJsZScgfHwgc3RyZWFtLl9zdGF0ZSA9PT0gJ2Vycm9yaW5nJyk7XG4gICAgICBjb250cm9sbGVyLl9zdGFydGVkID0gdHJ1ZTtcbiAgICAgIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJBZHZhbmNlUXVldWVJZk5lZWRlZChjb250cm9sbGVyKTtcbiAgICB9LFxuICAgIHIgPT4ge1xuICAgICAgYXNzZXJ0KHN0cmVhbS5fc3RhdGUgPT09ICd3cml0YWJsZScgfHwgc3RyZWFtLl9zdGF0ZSA9PT0gJ2Vycm9yaW5nJyk7XG4gICAgICBjb250cm9sbGVyLl9zdGFydGVkID0gdHJ1ZTtcbiAgICAgIFdyaXRhYmxlU3RyZWFtRGVhbFdpdGhSZWplY3Rpb24oc3RyZWFtLCByKTtcbiAgICB9XG4gICk7XG59XG5cbmZ1bmN0aW9uIFNldFVwV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckZyb21VbmRlcmx5aW5nU2luazxXPihzdHJlYW06IFdyaXRhYmxlU3RyZWFtPFc+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuZGVybHlpbmdTaW5rOiBWYWxpZGF0ZWRVbmRlcmx5aW5nU2luazxXPixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaWdoV2F0ZXJNYXJrOiBudW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZUFsZ29yaXRobTogUXVldWluZ1N0cmF0ZWd5U2l6ZUNhbGxiYWNrPFc+KSB7XG4gIGNvbnN0IGNvbnRyb2xsZXIgPSBPYmplY3QuY3JlYXRlKFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIucHJvdG90eXBlKTtcblxuICBsZXQgc3RhcnRBbGdvcml0aG06ICgpID0+IHZvaWQgfCBQcm9taXNlTGlrZTx2b2lkPiA9ICgpID0+IHVuZGVmaW5lZDtcbiAgbGV0IHdyaXRlQWxnb3JpdGhtOiAoY2h1bms6IFcpID0+IFByb21pc2U8dm9pZD4gPSAoKSA9PiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG4gIGxldCBjbG9zZUFsZ29yaXRobTogKCkgPT4gUHJvbWlzZTx2b2lkPiA9ICgpID0+IHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcbiAgbGV0IGFib3J0QWxnb3JpdGhtOiAocmVhc29uOiBhbnkpID0+IFByb21pc2U8dm9pZD4gPSAoKSA9PiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG5cbiAgaWYgKHVuZGVybHlpbmdTaW5rLnN0YXJ0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBzdGFydEFsZ29yaXRobSA9ICgpID0+IHVuZGVybHlpbmdTaW5rLnN0YXJ0IShjb250cm9sbGVyKTtcbiAgfVxuICBpZiAodW5kZXJseWluZ1Npbmsud3JpdGUgIT09IHVuZGVmaW5lZCkge1xuICAgIHdyaXRlQWxnb3JpdGhtID0gY2h1bmsgPT4gdW5kZXJseWluZ1Npbmsud3JpdGUhKGNodW5rLCBjb250cm9sbGVyKTtcbiAgfVxuICBpZiAodW5kZXJseWluZ1NpbmsuY2xvc2UgIT09IHVuZGVmaW5lZCkge1xuICAgIGNsb3NlQWxnb3JpdGhtID0gKCkgPT4gdW5kZXJseWluZ1NpbmsuY2xvc2UhKCk7XG4gIH1cbiAgaWYgKHVuZGVybHlpbmdTaW5rLmFib3J0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBhYm9ydEFsZ29yaXRobSA9IHJlYXNvbiA9PiB1bmRlcmx5aW5nU2luay5hYm9ydCEocmVhc29uKTtcbiAgfVxuXG4gIFNldFVwV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcihcbiAgICBzdHJlYW0sIGNvbnRyb2xsZXIsIHN0YXJ0QWxnb3JpdGhtLCB3cml0ZUFsZ29yaXRobSwgY2xvc2VBbGdvcml0aG0sIGFib3J0QWxnb3JpdGhtLCBoaWdoV2F0ZXJNYXJrLCBzaXplQWxnb3JpdGhtXG4gICk7XG59XG5cbi8vIENsZWFyQWxnb3JpdGhtcyBtYXkgYmUgY2FsbGVkIHR3aWNlLiBFcnJvcmluZyB0aGUgc2FtZSBzdHJlYW0gaW4gbXVsdGlwbGUgd2F5cyB3aWxsIG9mdGVuIHJlc3VsdCBpbiByZWR1bmRhbnQgY2FsbHMuXG5mdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKGNvbnRyb2xsZXI6IFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8YW55Pikge1xuICBjb250cm9sbGVyLl93cml0ZUFsZ29yaXRobSA9IHVuZGVmaW5lZCE7XG4gIGNvbnRyb2xsZXIuX2Nsb3NlQWxnb3JpdGhtID0gdW5kZWZpbmVkITtcbiAgY29udHJvbGxlci5fYWJvcnRBbGdvcml0aG0gPSB1bmRlZmluZWQhO1xuICBjb250cm9sbGVyLl9zdHJhdGVneVNpemVBbGdvcml0aG0gPSB1bmRlZmluZWQhO1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xvc2U8Vz4oY29udHJvbGxlcjogV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxXPikge1xuICBFbnF1ZXVlVmFsdWVXaXRoU2l6ZShjb250cm9sbGVyLCBjbG9zZVNlbnRpbmVsLCAwKTtcbiAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckFkdmFuY2VRdWV1ZUlmTmVlZGVkKGNvbnRyb2xsZXIpO1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyR2V0Q2h1bmtTaXplPFc+KGNvbnRyb2xsZXI6IFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8Vz4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rOiBXKTogbnVtYmVyIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gY29udHJvbGxlci5fc3RyYXRlZ3lTaXplQWxnb3JpdGhtKGNodW5rKTtcbiAgfSBjYXRjaCAoY2h1bmtTaXplRSkge1xuICAgIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcklmTmVlZGVkKGNvbnRyb2xsZXIsIGNodW5rU2l6ZUUpO1xuICAgIHJldHVybiAxO1xuICB9XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJHZXREZXNpcmVkU2l6ZShjb250cm9sbGVyOiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyPGFueT4pOiBudW1iZXIge1xuICByZXR1cm4gY29udHJvbGxlci5fc3RyYXRlZ3lIV00gLSBjb250cm9sbGVyLl9xdWV1ZVRvdGFsU2l6ZTtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcldyaXRlPFc+KGNvbnRyb2xsZXI6IFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8Vz4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2h1bms6IFcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmtTaXplOiBudW1iZXIpIHtcbiAgdHJ5IHtcbiAgICBFbnF1ZXVlVmFsdWVXaXRoU2l6ZShjb250cm9sbGVyLCBjaHVuaywgY2h1bmtTaXplKTtcbiAgfSBjYXRjaCAoZW5xdWV1ZUUpIHtcbiAgICBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3JJZk5lZWRlZChjb250cm9sbGVyLCBlbnF1ZXVlRSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3Qgc3RyZWFtID0gY29udHJvbGxlci5fY29udHJvbGxlZFdyaXRhYmxlU3RyZWFtO1xuICBpZiAoIVdyaXRhYmxlU3RyZWFtQ2xvc2VRdWV1ZWRPckluRmxpZ2h0KHN0cmVhbSkgJiYgc3RyZWFtLl9zdGF0ZSA9PT0gJ3dyaXRhYmxlJykge1xuICAgIGNvbnN0IGJhY2twcmVzc3VyZSA9IFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJHZXRCYWNrcHJlc3N1cmUoY29udHJvbGxlcik7XG4gICAgV3JpdGFibGVTdHJlYW1VcGRhdGVCYWNrcHJlc3N1cmUoc3RyZWFtLCBiYWNrcHJlc3N1cmUpO1xuICB9XG5cbiAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckFkdmFuY2VRdWV1ZUlmTmVlZGVkKGNvbnRyb2xsZXIpO1xufVxuXG4vLyBBYnN0cmFjdCBvcGVyYXRpb25zIGZvciB0aGUgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlci5cblxuZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckFkdmFuY2VRdWV1ZUlmTmVlZGVkPFc+KGNvbnRyb2xsZXI6IFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8Vz4pIHtcbiAgY29uc3Qgc3RyZWFtID0gY29udHJvbGxlci5fY29udHJvbGxlZFdyaXRhYmxlU3RyZWFtO1xuXG4gIGlmICghY29udHJvbGxlci5fc3RhcnRlZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChzdHJlYW0uX2luRmxpZ2h0V3JpdGVSZXF1ZXN0ICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBzdGF0ZSA9IHN0cmVhbS5fc3RhdGU7XG4gIGFzc2VydChzdGF0ZSAhPT0gJ2Nsb3NlZCcgJiYgc3RhdGUgIT09ICdlcnJvcmVkJyk7XG4gIGlmIChzdGF0ZSA9PT0gJ2Vycm9yaW5nJykge1xuICAgIFdyaXRhYmxlU3RyZWFtRmluaXNoRXJyb3Jpbmcoc3RyZWFtKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoY29udHJvbGxlci5fcXVldWUubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgdmFsdWUgPSBQZWVrUXVldWVWYWx1ZShjb250cm9sbGVyKTtcbiAgaWYgKHZhbHVlID09PSBjbG9zZVNlbnRpbmVsKSB7XG4gICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlclByb2Nlc3NDbG9zZShjb250cm9sbGVyKTtcbiAgfSBlbHNlIHtcbiAgICBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyUHJvY2Vzc1dyaXRlKGNvbnRyb2xsZXIsIHZhbHVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3JJZk5lZWRlZChjb250cm9sbGVyOiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyPGFueT4sIGVycm9yOiBhbnkpIHtcbiAgaWYgKGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRXcml0YWJsZVN0cmVhbS5fc3RhdGUgPT09ICd3cml0YWJsZScpIHtcbiAgICBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3IoY29udHJvbGxlciwgZXJyb3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJQcm9jZXNzQ2xvc2UoY29udHJvbGxlcjogV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxhbnk+KSB7XG4gIGNvbnN0IHN0cmVhbSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRXcml0YWJsZVN0cmVhbTtcblxuICBXcml0YWJsZVN0cmVhbU1hcmtDbG9zZVJlcXVlc3RJbkZsaWdodChzdHJlYW0pO1xuXG4gIERlcXVldWVWYWx1ZShjb250cm9sbGVyKTtcbiAgYXNzZXJ0KGNvbnRyb2xsZXIuX3F1ZXVlLmxlbmd0aCA9PT0gMCk7XG5cbiAgY29uc3Qgc2lua0Nsb3NlUHJvbWlzZSA9IGNvbnRyb2xsZXIuX2Nsb3NlQWxnb3JpdGhtKCk7XG4gIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbGVhckFsZ29yaXRobXMoY29udHJvbGxlcik7XG4gIHVwb25Qcm9taXNlKFxuICAgIHNpbmtDbG9zZVByb21pc2UsXG4gICAgKCkgPT4ge1xuICAgICAgV3JpdGFibGVTdHJlYW1GaW5pc2hJbkZsaWdodENsb3NlKHN0cmVhbSk7XG4gICAgfSxcbiAgICByZWFzb24gPT4ge1xuICAgICAgV3JpdGFibGVTdHJlYW1GaW5pc2hJbkZsaWdodENsb3NlV2l0aEVycm9yKHN0cmVhbSwgcmVhc29uKTtcbiAgICB9XG4gICk7XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJQcm9jZXNzV3JpdGU8Vz4oY29udHJvbGxlcjogV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxXPiwgY2h1bms6IFcpIHtcbiAgY29uc3Qgc3RyZWFtID0gY29udHJvbGxlci5fY29udHJvbGxlZFdyaXRhYmxlU3RyZWFtO1xuXG4gIFdyaXRhYmxlU3RyZWFtTWFya0ZpcnN0V3JpdGVSZXF1ZXN0SW5GbGlnaHQoc3RyZWFtKTtcblxuICBjb25zdCBzaW5rV3JpdGVQcm9taXNlID0gY29udHJvbGxlci5fd3JpdGVBbGdvcml0aG0oY2h1bmspO1xuICB1cG9uUHJvbWlzZShcbiAgICBzaW5rV3JpdGVQcm9taXNlLFxuICAgICgpID0+IHtcbiAgICAgIFdyaXRhYmxlU3RyZWFtRmluaXNoSW5GbGlnaHRXcml0ZShzdHJlYW0pO1xuXG4gICAgICBjb25zdCBzdGF0ZSA9IHN0cmVhbS5fc3RhdGU7XG4gICAgICBhc3NlcnQoc3RhdGUgPT09ICd3cml0YWJsZScgfHwgc3RhdGUgPT09ICdlcnJvcmluZycpO1xuXG4gICAgICBEZXF1ZXVlVmFsdWUoY29udHJvbGxlcik7XG5cbiAgICAgIGlmICghV3JpdGFibGVTdHJlYW1DbG9zZVF1ZXVlZE9ySW5GbGlnaHQoc3RyZWFtKSAmJiBzdGF0ZSA9PT0gJ3dyaXRhYmxlJykge1xuICAgICAgICBjb25zdCBiYWNrcHJlc3N1cmUgPSBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyR2V0QmFja3ByZXNzdXJlKGNvbnRyb2xsZXIpO1xuICAgICAgICBXcml0YWJsZVN0cmVhbVVwZGF0ZUJhY2twcmVzc3VyZShzdHJlYW0sIGJhY2twcmVzc3VyZSk7XG4gICAgICB9XG5cbiAgICAgIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJBZHZhbmNlUXVldWVJZk5lZWRlZChjb250cm9sbGVyKTtcbiAgICB9LFxuICAgIHJlYXNvbiA9PiB7XG4gICAgICBpZiAoc3RyZWFtLl9zdGF0ZSA9PT0gJ3dyaXRhYmxlJykge1xuICAgICAgICBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKGNvbnRyb2xsZXIpO1xuICAgICAgfVxuICAgICAgV3JpdGFibGVTdHJlYW1GaW5pc2hJbkZsaWdodFdyaXRlV2l0aEVycm9yKHN0cmVhbSwgcmVhc29uKTtcbiAgICB9XG4gICk7XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJHZXRCYWNrcHJlc3N1cmUoY29udHJvbGxlcjogV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxhbnk+KTogYm9vbGVhbiB7XG4gIGNvbnN0IGRlc2lyZWRTaXplID0gV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckdldERlc2lyZWRTaXplKGNvbnRyb2xsZXIpO1xuICByZXR1cm4gZGVzaXJlZFNpemUgPD0gMDtcbn1cblxuLy8gQSBjbGllbnQgb2YgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlciBtYXkgdXNlIHRoZXNlIGZ1bmN0aW9ucyBkaXJlY3RseSB0byBieXBhc3Mgc3RhdGUgY2hlY2suXG5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcihjb250cm9sbGVyOiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyPGFueT4sIGVycm9yOiBhbnkpIHtcbiAgY29uc3Qgc3RyZWFtID0gY29udHJvbGxlci5fY29udHJvbGxlZFdyaXRhYmxlU3RyZWFtO1xuXG4gIGFzc2VydChzdHJlYW0uX3N0YXRlID09PSAnd3JpdGFibGUnKTtcblxuICBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKGNvbnRyb2xsZXIpO1xuICBXcml0YWJsZVN0cmVhbVN0YXJ0RXJyb3Jpbmcoc3RyZWFtLCBlcnJvcik7XG59XG5cbi8vIEhlbHBlciBmdW5jdGlvbnMgZm9yIHRoZSBXcml0YWJsZVN0cmVhbS5cblxuZnVuY3Rpb24gc3RyZWFtQnJhbmRDaGVja0V4Y2VwdGlvbihuYW1lOiBzdHJpbmcpOiBUeXBlRXJyb3Ige1xuICByZXR1cm4gbmV3IFR5cGVFcnJvcihgV3JpdGFibGVTdHJlYW0ucHJvdG90eXBlLiR7bmFtZX0gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIFdyaXRhYmxlU3RyZWFtYCk7XG59XG5cbi8vIEhlbHBlciBmdW5jdGlvbnMgZm9yIHRoZSBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLlxuXG5mdW5jdGlvbiBkZWZhdWx0Q29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24obmFtZTogc3RyaW5nKTogVHlwZUVycm9yIHtcbiAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoXG4gICAgYFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIucHJvdG90eXBlLiR7bmFtZX0gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJgKTtcbn1cblxuXG4vLyBIZWxwZXIgZnVuY3Rpb25zIGZvciB0aGUgV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyLlxuXG5mdW5jdGlvbiBkZWZhdWx0V3JpdGVyQnJhbmRDaGVja0V4Y2VwdGlvbihuYW1lOiBzdHJpbmcpOiBUeXBlRXJyb3Ige1xuICByZXR1cm4gbmV3IFR5cGVFcnJvcihcbiAgICBgV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyLnByb3RvdHlwZS4ke25hbWV9IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJgKTtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdFdyaXRlckxvY2tFeGNlcHRpb24obmFtZTogc3RyaW5nKTogVHlwZUVycm9yIHtcbiAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCAnICsgbmFtZSArICcgYSBzdHJlYW0gdXNpbmcgYSByZWxlYXNlZCB3cml0ZXInKTtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VJbml0aWFsaXplKHdyaXRlcjogV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyKSB7XG4gIHdyaXRlci5fY2xvc2VkUHJvbWlzZSA9IG5ld1Byb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHdyaXRlci5fY2xvc2VkUHJvbWlzZV9yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICB3cml0ZXIuX2Nsb3NlZFByb21pc2VfcmVqZWN0ID0gcmVqZWN0O1xuICAgIHdyaXRlci5fY2xvc2VkUHJvbWlzZVN0YXRlID0gJ3BlbmRpbmcnO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VJbml0aWFsaXplQXNSZWplY3RlZCh3cml0ZXI6IFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlciwgcmVhc29uOiBhbnkpIHtcbiAgZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VJbml0aWFsaXplKHdyaXRlcik7XG4gIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlUmVqZWN0KHdyaXRlciwgcmVhc29uKTtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VJbml0aWFsaXplQXNSZXNvbHZlZCh3cml0ZXI6IFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcikge1xuICBkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemUod3JpdGVyKTtcbiAgZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VSZXNvbHZlKHdyaXRlcik7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlUmVqZWN0KHdyaXRlcjogV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyLCByZWFzb246IGFueSkge1xuICBpZiAod3JpdGVyLl9jbG9zZWRQcm9taXNlX3JlamVjdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGFzc2VydCh3cml0ZXIuX2Nsb3NlZFByb21pc2VTdGF0ZSA9PT0gJ3BlbmRpbmcnKTtcblxuICBzZXRQcm9taXNlSXNIYW5kbGVkVG9UcnVlKHdyaXRlci5fY2xvc2VkUHJvbWlzZSk7XG4gIHdyaXRlci5fY2xvc2VkUHJvbWlzZV9yZWplY3QocmVhc29uKTtcbiAgd3JpdGVyLl9jbG9zZWRQcm9taXNlX3Jlc29sdmUgPSB1bmRlZmluZWQ7XG4gIHdyaXRlci5fY2xvc2VkUHJvbWlzZV9yZWplY3QgPSB1bmRlZmluZWQ7XG4gIHdyaXRlci5fY2xvc2VkUHJvbWlzZVN0YXRlID0gJ3JlamVjdGVkJztcbn1cblxuZnVuY3Rpb24gZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VSZXNldFRvUmVqZWN0ZWQod3JpdGVyOiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIsIHJlYXNvbjogYW55KSB7XG4gIGFzc2VydCh3cml0ZXIuX2Nsb3NlZFByb21pc2VfcmVzb2x2ZSA9PT0gdW5kZWZpbmVkKTtcbiAgYXNzZXJ0KHdyaXRlci5fY2xvc2VkUHJvbWlzZV9yZWplY3QgPT09IHVuZGVmaW5lZCk7XG4gIGFzc2VydCh3cml0ZXIuX2Nsb3NlZFByb21pc2VTdGF0ZSAhPT0gJ3BlbmRpbmcnKTtcblxuICBkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemVBc1JlamVjdGVkKHdyaXRlciwgcmVhc29uKTtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VSZXNvbHZlKHdyaXRlcjogV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyKSB7XG4gIGlmICh3cml0ZXIuX2Nsb3NlZFByb21pc2VfcmVzb2x2ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGFzc2VydCh3cml0ZXIuX2Nsb3NlZFByb21pc2VTdGF0ZSA9PT0gJ3BlbmRpbmcnKTtcblxuICB3cml0ZXIuX2Nsb3NlZFByb21pc2VfcmVzb2x2ZSh1bmRlZmluZWQpO1xuICB3cml0ZXIuX2Nsb3NlZFByb21pc2VfcmVzb2x2ZSA9IHVuZGVmaW5lZDtcbiAgd3JpdGVyLl9jbG9zZWRQcm9taXNlX3JlamVjdCA9IHVuZGVmaW5lZDtcbiAgd3JpdGVyLl9jbG9zZWRQcm9taXNlU3RhdGUgPSAncmVzb2x2ZWQnO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlSW5pdGlhbGl6ZSh3cml0ZXI6IFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcikge1xuICB3cml0ZXIuX3JlYWR5UHJvbWlzZSA9IG5ld1Byb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHdyaXRlci5fcmVhZHlQcm9taXNlX3Jlc29sdmUgPSByZXNvbHZlO1xuICAgIHdyaXRlci5fcmVhZHlQcm9taXNlX3JlamVjdCA9IHJlamVjdDtcbiAgfSk7XG4gIHdyaXRlci5fcmVhZHlQcm9taXNlU3RhdGUgPSAncGVuZGluZyc7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VJbml0aWFsaXplQXNSZWplY3RlZCh3cml0ZXI6IFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlciwgcmVhc29uOiBhbnkpIHtcbiAgZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZUluaXRpYWxpemUod3JpdGVyKTtcbiAgZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZVJlamVjdCh3cml0ZXIsIHJlYXNvbik7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VJbml0aWFsaXplQXNSZXNvbHZlZCh3cml0ZXI6IFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcikge1xuICBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlSW5pdGlhbGl6ZSh3cml0ZXIpO1xuICBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlUmVzb2x2ZSh3cml0ZXIpO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlUmVqZWN0KHdyaXRlcjogV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyLCByZWFzb246IGFueSkge1xuICBpZiAod3JpdGVyLl9yZWFkeVByb21pc2VfcmVqZWN0ID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBzZXRQcm9taXNlSXNIYW5kbGVkVG9UcnVlKHdyaXRlci5fcmVhZHlQcm9taXNlKTtcbiAgd3JpdGVyLl9yZWFkeVByb21pc2VfcmVqZWN0KHJlYXNvbik7XG4gIHdyaXRlci5fcmVhZHlQcm9taXNlX3Jlc29sdmUgPSB1bmRlZmluZWQ7XG4gIHdyaXRlci5fcmVhZHlQcm9taXNlX3JlamVjdCA9IHVuZGVmaW5lZDtcbiAgd3JpdGVyLl9yZWFkeVByb21pc2VTdGF0ZSA9ICdyZWplY3RlZCc7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VSZXNldCh3cml0ZXI6IFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcikge1xuICBhc3NlcnQod3JpdGVyLl9yZWFkeVByb21pc2VfcmVzb2x2ZSA9PT0gdW5kZWZpbmVkKTtcbiAgYXNzZXJ0KHdyaXRlci5fcmVhZHlQcm9taXNlX3JlamVjdCA9PT0gdW5kZWZpbmVkKTtcblxuICBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlSW5pdGlhbGl6ZSh3cml0ZXIpO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlUmVzZXRUb1JlamVjdGVkKHdyaXRlcjogV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyLCByZWFzb246IGFueSkge1xuICBhc3NlcnQod3JpdGVyLl9yZWFkeVByb21pc2VfcmVzb2x2ZSA9PT0gdW5kZWZpbmVkKTtcbiAgYXNzZXJ0KHdyaXRlci5fcmVhZHlQcm9taXNlX3JlamVjdCA9PT0gdW5kZWZpbmVkKTtcblxuICBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlSW5pdGlhbGl6ZUFzUmVqZWN0ZWQod3JpdGVyLCByZWFzb24pO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlUmVzb2x2ZSh3cml0ZXI6IFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcikge1xuICBpZiAod3JpdGVyLl9yZWFkeVByb21pc2VfcmVzb2x2ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgd3JpdGVyLl9yZWFkeVByb21pc2VfcmVzb2x2ZSh1bmRlZmluZWQpO1xuICB3cml0ZXIuX3JlYWR5UHJvbWlzZV9yZXNvbHZlID0gdW5kZWZpbmVkO1xuICB3cml0ZXIuX3JlYWR5UHJvbWlzZV9yZWplY3QgPSB1bmRlZmluZWQ7XG4gIHdyaXRlci5fcmVhZHlQcm9taXNlU3RhdGUgPSAnZnVsZmlsbGVkJztcbn1cbiIsICIvLy8gPHJlZmVyZW5jZSBsaWI9XCJkb21cIiAvPlxuZXhwb3J0IGNvbnN0IE5hdGl2ZURPTUV4Y2VwdGlvbjogdHlwZW9mIERPTUV4Y2VwdGlvbiB8IHVuZGVmaW5lZCA9XG4gIHR5cGVvZiBET01FeGNlcHRpb24gIT09ICd1bmRlZmluZWQnID8gRE9NRXhjZXB0aW9uIDogdW5kZWZpbmVkO1xuIiwgIi8vLyA8cmVmZXJlbmNlIHR5cGVzPVwibm9kZVwiIC8+XG5pbXBvcnQgeyBOYXRpdmVET01FeGNlcHRpb24gfSBmcm9tICcuL25hdGl2ZSc7XG5cbmRlY2xhcmUgY2xhc3MgRE9NRXhjZXB0aW9uQ2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2U/OiBzdHJpbmcsIG5hbWU/OiBzdHJpbmcpO1xuXG4gIG5hbWU6IHN0cmluZztcbiAgbWVzc2FnZTogc3RyaW5nO1xufVxuXG50eXBlIERPTUV4Y2VwdGlvbiA9IERPTUV4Y2VwdGlvbkNsYXNzO1xudHlwZSBET01FeGNlcHRpb25Db25zdHJ1Y3RvciA9IHR5cGVvZiBET01FeGNlcHRpb25DbGFzcztcblxuZnVuY3Rpb24gaXNET01FeGNlcHRpb25Db25zdHJ1Y3RvcihjdG9yOiB1bmtub3duKTogY3RvciBpcyBET01FeGNlcHRpb25Db25zdHJ1Y3RvciB7XG4gIGlmICghKHR5cGVvZiBjdG9yID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBjdG9yID09PSAnb2JqZWN0JykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdHJ5IHtcbiAgICBuZXcgKGN0b3IgYXMgRE9NRXhjZXB0aW9uQ29uc3RydWN0b3IpKCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVET01FeGNlcHRpb25Qb2x5ZmlsbCgpOiBET01FeGNlcHRpb25Db25zdHJ1Y3RvciB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zaGFkb3dcbiAgY29uc3QgY3RvciA9IGZ1bmN0aW9uIERPTUV4Y2VwdGlvbih0aGlzOiBET01FeGNlcHRpb24sIG1lc3NhZ2U/OiBzdHJpbmcsIG5hbWU/OiBzdHJpbmcpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8ICcnO1xuICAgIHRoaXMubmFtZSA9IG5hbWUgfHwgJ0Vycm9yJztcbiAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpO1xuICAgIH1cbiAgfSBhcyBhbnk7XG4gIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3Rvci5wcm90b3R5cGUsICdjb25zdHJ1Y3RvcicsIHsgdmFsdWU6IGN0b3IsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSk7XG4gIHJldHVybiBjdG9yO1xufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG5jb25zdCBET01FeGNlcHRpb246IERPTUV4Y2VwdGlvbkNvbnN0cnVjdG9yID1cbiAgaXNET01FeGNlcHRpb25Db25zdHJ1Y3RvcihOYXRpdmVET01FeGNlcHRpb24pID8gTmF0aXZlRE9NRXhjZXB0aW9uIDogY3JlYXRlRE9NRXhjZXB0aW9uUG9seWZpbGwoKTtcblxuZXhwb3J0IHsgRE9NRXhjZXB0aW9uIH07XG4iLCAiaW1wb3J0IHsgSXNSZWFkYWJsZVN0cmVhbSwgSXNSZWFkYWJsZVN0cmVhbUxvY2tlZCwgUmVhZGFibGVTdHJlYW0sIFJlYWRhYmxlU3RyZWFtQ2FuY2VsIH0gZnJvbSAnLi4vcmVhZGFibGUtc3RyZWFtJztcbmltcG9ydCB7IEFjcXVpcmVSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIsIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlclJlYWQgfSBmcm9tICcuL2RlZmF1bHQtcmVhZGVyJztcbmltcG9ydCB7IFJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY1JlbGVhc2UgfSBmcm9tICcuL2dlbmVyaWMtcmVhZGVyJztcbmltcG9ydCB7XG4gIEFjcXVpcmVXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIsXG4gIElzV3JpdGFibGVTdHJlYW0sXG4gIElzV3JpdGFibGVTdHJlYW1Mb2NrZWQsXG4gIFdyaXRhYmxlU3RyZWFtLFxuICBXcml0YWJsZVN0cmVhbUFib3J0LFxuICBXcml0YWJsZVN0cmVhbUNsb3NlUXVldWVkT3JJbkZsaWdodCxcbiAgV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyQ2xvc2VXaXRoRXJyb3JQcm9wYWdhdGlvbixcbiAgV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyUmVsZWFzZSxcbiAgV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyV3JpdGVcbn0gZnJvbSAnLi4vd3JpdGFibGUtc3RyZWFtJztcbmltcG9ydCBhc3NlcnQgZnJvbSAnLi4vLi4vc3R1Yi9hc3NlcnQnO1xuaW1wb3J0IHtcbiAgbmV3UHJvbWlzZSxcbiAgUGVyZm9ybVByb21pc2VUaGVuLFxuICBwcm9taXNlUmVzb2x2ZWRXaXRoLFxuICBzZXRQcm9taXNlSXNIYW5kbGVkVG9UcnVlLFxuICB1cG9uRnVsZmlsbG1lbnQsXG4gIHVwb25Qcm9taXNlLFxuICB1cG9uUmVqZWN0aW9uXG59IGZyb20gJy4uL2hlbHBlcnMvd2ViaWRsJztcbmltcG9ydCB7IG5vb3AgfSBmcm9tICcuLi8uLi91dGlscyc7XG5pbXBvcnQgeyBBYm9ydFNpZ25hbCwgaXNBYm9ydFNpZ25hbCB9IGZyb20gJy4uL2Fib3J0LXNpZ25hbCc7XG5pbXBvcnQgeyBET01FeGNlcHRpb24gfSBmcm9tICcuLi8uLi9zdHViL2RvbS1leGNlcHRpb24nO1xuXG5leHBvcnQgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1QaXBlVG88VD4oc291cmNlOiBSZWFkYWJsZVN0cmVhbTxUPixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXN0OiBXcml0YWJsZVN0cmVhbTxUPixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2ZW50Q2xvc2U6IGJvb2xlYW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldmVudEFib3J0OiBib29sZWFuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZlbnRDYW5jZWw6IGJvb2xlYW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbCB8IHVuZGVmaW5lZCk6IFByb21pc2U8dW5kZWZpbmVkPiB7XG4gIGFzc2VydChJc1JlYWRhYmxlU3RyZWFtKHNvdXJjZSkpO1xuICBhc3NlcnQoSXNXcml0YWJsZVN0cmVhbShkZXN0KSk7XG4gIGFzc2VydCh0eXBlb2YgcHJldmVudENsb3NlID09PSAnYm9vbGVhbicpO1xuICBhc3NlcnQodHlwZW9mIHByZXZlbnRBYm9ydCA9PT0gJ2Jvb2xlYW4nKTtcbiAgYXNzZXJ0KHR5cGVvZiBwcmV2ZW50Q2FuY2VsID09PSAnYm9vbGVhbicpO1xuICBhc3NlcnQoc2lnbmFsID09PSB1bmRlZmluZWQgfHwgaXNBYm9ydFNpZ25hbChzaWduYWwpKTtcbiAgYXNzZXJ0KCFJc1JlYWRhYmxlU3RyZWFtTG9ja2VkKHNvdXJjZSkpO1xuICBhc3NlcnQoIUlzV3JpdGFibGVTdHJlYW1Mb2NrZWQoZGVzdCkpO1xuXG4gIGNvbnN0IHJlYWRlciA9IEFjcXVpcmVSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXI8VD4oc291cmNlKTtcbiAgY29uc3Qgd3JpdGVyID0gQWNxdWlyZVdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcjxUPihkZXN0KTtcblxuICBzb3VyY2UuX2Rpc3R1cmJlZCA9IHRydWU7XG5cbiAgbGV0IHNodXR0aW5nRG93biA9IGZhbHNlO1xuXG4gIC8vIFRoaXMgaXMgdXNlZCB0byBrZWVwIHRyYWNrIG9mIHRoZSBzcGVjJ3MgcmVxdWlyZW1lbnQgdGhhdCB3ZSB3YWl0IGZvciBvbmdvaW5nIHdyaXRlcyBkdXJpbmcgc2h1dGRvd24uXG4gIGxldCBjdXJyZW50V3JpdGUgPSBwcm9taXNlUmVzb2x2ZWRXaXRoPHZvaWQ+KHVuZGVmaW5lZCk7XG5cbiAgcmV0dXJuIG5ld1Byb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGxldCBhYm9ydEFsZ29yaXRobTogKCkgPT4gdm9pZDtcbiAgICBpZiAoc2lnbmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGFib3J0QWxnb3JpdGhtID0gKCkgPT4ge1xuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBET01FeGNlcHRpb24oJ0Fib3J0ZWQnLCAnQWJvcnRFcnJvcicpO1xuICAgICAgICBjb25zdCBhY3Rpb25zOiBBcnJheTwoKSA9PiBQcm9taXNlPHZvaWQ+PiA9IFtdO1xuICAgICAgICBpZiAoIXByZXZlbnRBYm9ydCkge1xuICAgICAgICAgIGFjdGlvbnMucHVzaCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAoZGVzdC5fc3RhdGUgPT09ICd3cml0YWJsZScpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFdyaXRhYmxlU3RyZWFtQWJvcnQoZGVzdCwgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXByZXZlbnRDYW5jZWwpIHtcbiAgICAgICAgICBhY3Rpb25zLnB1c2goKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHNvdXJjZS5fc3RhdGUgPT09ICdyZWFkYWJsZScpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFJlYWRhYmxlU3RyZWFtQ2FuY2VsKHNvdXJjZSwgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzaHV0ZG93bldpdGhBY3Rpb24oKCkgPT4gUHJvbWlzZS5hbGwoYWN0aW9ucy5tYXAoYWN0aW9uID0+IGFjdGlvbigpKSksIHRydWUsIGVycm9yKTtcbiAgICAgIH07XG5cbiAgICAgIGlmIChzaWduYWwuYWJvcnRlZCkge1xuICAgICAgICBhYm9ydEFsZ29yaXRobSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIGFib3J0QWxnb3JpdGhtKTtcbiAgICB9XG5cbiAgICAvLyBVc2luZyByZWFkZXIgYW5kIHdyaXRlciwgcmVhZCBhbGwgY2h1bmtzIGZyb20gdGhpcyBhbmQgd3JpdGUgdGhlbSB0byBkZXN0XG4gICAgLy8gLSBCYWNrcHJlc3N1cmUgbXVzdCBiZSBlbmZvcmNlZFxuICAgIC8vIC0gU2h1dGRvd24gbXVzdCBzdG9wIGFsbCBhY3Rpdml0eVxuICAgIGZ1bmN0aW9uIHBpcGVMb29wKCkge1xuICAgICAgcmV0dXJuIG5ld1Byb21pc2U8dm9pZD4oKHJlc29sdmVMb29wLCByZWplY3RMb29wKSA9PiB7XG4gICAgICAgIGZ1bmN0aW9uIG5leHQoZG9uZTogYm9vbGVhbikge1xuICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICByZXNvbHZlTG9vcCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBVc2UgYFBlcmZvcm1Qcm9taXNlVGhlbmAgaW5zdGVhZCBvZiBgdXBvblByb21pc2VgIHRvIGF2b2lkXG4gICAgICAgICAgICAvLyBhZGRpbmcgdW5uZWNlc3NhcnkgYC5jYXRjaChyZXRocm93QXNzZXJ0aW9uRXJyb3JSZWplY3Rpb24pYCBoYW5kbGVyc1xuICAgICAgICAgICAgUGVyZm9ybVByb21pc2VUaGVuKHBpcGVTdGVwKCksIG5leHQsIHJlamVjdExvb3ApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG5leHQoZmFsc2UpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGlwZVN0ZXAoKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgICBpZiAoc2h1dHRpbmdEb3duKSB7XG4gICAgICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZWRXaXRoKHRydWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gUGVyZm9ybVByb21pc2VUaGVuKHdyaXRlci5fcmVhZHlQcm9taXNlLCAoKSA9PiB7XG4gICAgICAgIHJldHVybiBuZXdQcm9taXNlPGJvb2xlYW4+KChyZXNvbHZlUmVhZCwgcmVqZWN0UmVhZCkgPT4ge1xuICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlclJlYWQoXG4gICAgICAgICAgICByZWFkZXIsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIF9jaHVua1N0ZXBzOiBjaHVuayA9PiB7XG4gICAgICAgICAgICAgICAgY3VycmVudFdyaXRlID0gUGVyZm9ybVByb21pc2VUaGVuKFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcldyaXRlKHdyaXRlciwgY2h1bmspLCB1bmRlZmluZWQsIG5vb3ApO1xuICAgICAgICAgICAgICAgIHJlc29sdmVSZWFkKGZhbHNlKTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgX2Nsb3NlU3RlcHM6ICgpID0+IHJlc29sdmVSZWFkKHRydWUpLFxuICAgICAgICAgICAgICBfZXJyb3JTdGVwczogcmVqZWN0UmVhZFxuICAgICAgICAgICAgfVxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gRXJyb3JzIG11c3QgYmUgcHJvcGFnYXRlZCBmb3J3YXJkXG4gICAgaXNPckJlY29tZXNFcnJvcmVkKHNvdXJjZSwgcmVhZGVyLl9jbG9zZWRQcm9taXNlLCBzdG9yZWRFcnJvciA9PiB7XG4gICAgICBpZiAoIXByZXZlbnRBYm9ydCkge1xuICAgICAgICBzaHV0ZG93bldpdGhBY3Rpb24oKCkgPT4gV3JpdGFibGVTdHJlYW1BYm9ydChkZXN0LCBzdG9yZWRFcnJvciksIHRydWUsIHN0b3JlZEVycm9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNodXRkb3duKHRydWUsIHN0b3JlZEVycm9yKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIEVycm9ycyBtdXN0IGJlIHByb3BhZ2F0ZWQgYmFja3dhcmRcbiAgICBpc09yQmVjb21lc0Vycm9yZWQoZGVzdCwgd3JpdGVyLl9jbG9zZWRQcm9taXNlLCBzdG9yZWRFcnJvciA9PiB7XG4gICAgICBpZiAoIXByZXZlbnRDYW5jZWwpIHtcbiAgICAgICAgc2h1dGRvd25XaXRoQWN0aW9uKCgpID0+IFJlYWRhYmxlU3RyZWFtQ2FuY2VsKHNvdXJjZSwgc3RvcmVkRXJyb3IpLCB0cnVlLCBzdG9yZWRFcnJvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzaHV0ZG93bih0cnVlLCBzdG9yZWRFcnJvcik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBDbG9zaW5nIG11c3QgYmUgcHJvcGFnYXRlZCBmb3J3YXJkXG4gICAgaXNPckJlY29tZXNDbG9zZWQoc291cmNlLCByZWFkZXIuX2Nsb3NlZFByb21pc2UsICgpID0+IHtcbiAgICAgIGlmICghcHJldmVudENsb3NlKSB7XG4gICAgICAgIHNodXRkb3duV2l0aEFjdGlvbigoKSA9PiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJDbG9zZVdpdGhFcnJvclByb3BhZ2F0aW9uKHdyaXRlcikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2h1dGRvd24oKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIENsb3NpbmcgbXVzdCBiZSBwcm9wYWdhdGVkIGJhY2t3YXJkXG4gICAgaWYgKFdyaXRhYmxlU3RyZWFtQ2xvc2VRdWV1ZWRPckluRmxpZ2h0KGRlc3QpIHx8IGRlc3QuX3N0YXRlID09PSAnY2xvc2VkJykge1xuICAgICAgY29uc3QgZGVzdENsb3NlZCA9IG5ldyBUeXBlRXJyb3IoJ3RoZSBkZXN0aW5hdGlvbiB3cml0YWJsZSBzdHJlYW0gY2xvc2VkIGJlZm9yZSBhbGwgZGF0YSBjb3VsZCBiZSBwaXBlZCB0byBpdCcpO1xuXG4gICAgICBpZiAoIXByZXZlbnRDYW5jZWwpIHtcbiAgICAgICAgc2h1dGRvd25XaXRoQWN0aW9uKCgpID0+IFJlYWRhYmxlU3RyZWFtQ2FuY2VsKHNvdXJjZSwgZGVzdENsb3NlZCksIHRydWUsIGRlc3RDbG9zZWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2h1dGRvd24odHJ1ZSwgZGVzdENsb3NlZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2V0UHJvbWlzZUlzSGFuZGxlZFRvVHJ1ZShwaXBlTG9vcCgpKTtcblxuICAgIGZ1bmN0aW9uIHdhaXRGb3JXcml0ZXNUb0ZpbmlzaCgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgIC8vIEFub3RoZXIgd3JpdGUgbWF5IGhhdmUgc3RhcnRlZCB3aGlsZSB3ZSB3ZXJlIHdhaXRpbmcgb24gdGhpcyBjdXJyZW50V3JpdGUsIHNvIHdlIGhhdmUgdG8gYmUgc3VyZSB0byB3YWl0XG4gICAgICAvLyBmb3IgdGhhdCB0b28uXG4gICAgICBjb25zdCBvbGRDdXJyZW50V3JpdGUgPSBjdXJyZW50V3JpdGU7XG4gICAgICByZXR1cm4gUGVyZm9ybVByb21pc2VUaGVuKFxuICAgICAgICBjdXJyZW50V3JpdGUsXG4gICAgICAgICgpID0+IG9sZEN1cnJlbnRXcml0ZSAhPT0gY3VycmVudFdyaXRlID8gd2FpdEZvcldyaXRlc1RvRmluaXNoKCkgOiB1bmRlZmluZWRcbiAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNPckJlY29tZXNFcnJvcmVkKHN0cmVhbTogUmVhZGFibGVTdHJlYW0gfCBXcml0YWJsZVN0cmVhbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZTogUHJvbWlzZTx2b2lkPixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiAocmVhc29uOiBhbnkpID0+IHZvaWQpIHtcbiAgICAgIGlmIChzdHJlYW0uX3N0YXRlID09PSAnZXJyb3JlZCcpIHtcbiAgICAgICAgYWN0aW9uKHN0cmVhbS5fc3RvcmVkRXJyb3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXBvblJlamVjdGlvbihwcm9taXNlLCBhY3Rpb24pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzT3JCZWNvbWVzQ2xvc2VkKHN0cmVhbTogUmVhZGFibGVTdHJlYW0gfCBXcml0YWJsZVN0cmVhbSwgcHJvbWlzZTogUHJvbWlzZTx2b2lkPiwgYWN0aW9uOiAoKSA9PiB2b2lkKSB7XG4gICAgICBpZiAoc3RyZWFtLl9zdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICAgICAgYWN0aW9uKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cG9uRnVsZmlsbG1lbnQocHJvbWlzZSwgYWN0aW9uKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzaHV0ZG93bldpdGhBY3Rpb24oYWN0aW9uOiAoKSA9PiBQcm9taXNlPHVua25vd24+LCBvcmlnaW5hbElzRXJyb3I/OiBib29sZWFuLCBvcmlnaW5hbEVycm9yPzogYW55KSB7XG4gICAgICBpZiAoc2h1dHRpbmdEb3duKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHNodXR0aW5nRG93biA9IHRydWU7XG5cbiAgICAgIGlmIChkZXN0Ll9zdGF0ZSA9PT0gJ3dyaXRhYmxlJyAmJiAhV3JpdGFibGVTdHJlYW1DbG9zZVF1ZXVlZE9ySW5GbGlnaHQoZGVzdCkpIHtcbiAgICAgICAgdXBvbkZ1bGZpbGxtZW50KHdhaXRGb3JXcml0ZXNUb0ZpbmlzaCgpLCBkb1RoZVJlc3QpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZG9UaGVSZXN0KCk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGRvVGhlUmVzdCgpIHtcbiAgICAgICAgdXBvblByb21pc2UoXG4gICAgICAgICAgYWN0aW9uKCksXG4gICAgICAgICAgKCkgPT4gZmluYWxpemUob3JpZ2luYWxJc0Vycm9yLCBvcmlnaW5hbEVycm9yKSxcbiAgICAgICAgICBuZXdFcnJvciA9PiBmaW5hbGl6ZSh0cnVlLCBuZXdFcnJvcilcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzaHV0ZG93bihpc0Vycm9yPzogYm9vbGVhbiwgZXJyb3I/OiBhbnkpIHtcbiAgICAgIGlmIChzaHV0dGluZ0Rvd24pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc2h1dHRpbmdEb3duID0gdHJ1ZTtcblxuICAgICAgaWYgKGRlc3QuX3N0YXRlID09PSAnd3JpdGFibGUnICYmICFXcml0YWJsZVN0cmVhbUNsb3NlUXVldWVkT3JJbkZsaWdodChkZXN0KSkge1xuICAgICAgICB1cG9uRnVsZmlsbG1lbnQod2FpdEZvcldyaXRlc1RvRmluaXNoKCksICgpID0+IGZpbmFsaXplKGlzRXJyb3IsIGVycm9yKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmaW5hbGl6ZShpc0Vycm9yLCBlcnJvcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmluYWxpemUoaXNFcnJvcj86IGJvb2xlYW4sIGVycm9yPzogYW55KSB7XG4gICAgICBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJSZWxlYXNlKHdyaXRlcik7XG4gICAgICBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNSZWxlYXNlKHJlYWRlcik7XG5cbiAgICAgIGlmIChzaWduYWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydEFsZ29yaXRobSk7XG4gICAgICB9XG4gICAgICBpZiAoaXNFcnJvcikge1xuICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzb2x2ZSh1bmRlZmluZWQpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG4iLCAiaW1wb3J0IHsgUXVldWluZ1N0cmF0ZWd5U2l6ZUNhbGxiYWNrIH0gZnJvbSAnLi4vcXVldWluZy1zdHJhdGVneSc7XG5pbXBvcnQgYXNzZXJ0IGZyb20gJy4uLy4uL3N0dWIvYXNzZXJ0JztcbmltcG9ydCB7IERlcXVldWVWYWx1ZSwgRW5xdWV1ZVZhbHVlV2l0aFNpemUsIFF1ZXVlUGFpciwgUmVzZXRRdWV1ZSB9IGZyb20gJy4uL2Fic3RyYWN0LW9wcy9xdWV1ZS13aXRoLXNpemVzJztcbmltcG9ydCB7XG4gIFJlYWRhYmxlU3RyZWFtQWRkUmVhZFJlcXVlc3QsXG4gIFJlYWRhYmxlU3RyZWFtRnVsZmlsbFJlYWRSZXF1ZXN0LFxuICBSZWFkYWJsZVN0cmVhbUdldE51bVJlYWRSZXF1ZXN0cyxcbiAgUmVhZFJlcXVlc3Rcbn0gZnJvbSAnLi9kZWZhdWx0LXJlYWRlcic7XG5pbXBvcnQgeyBTaW1wbGVRdWV1ZSB9IGZyb20gJy4uL3NpbXBsZS1xdWV1ZSc7XG5pbXBvcnQgeyBJc1JlYWRhYmxlU3RyZWFtTG9ja2VkLCBSZWFkYWJsZVN0cmVhbSwgUmVhZGFibGVTdHJlYW1DbG9zZSwgUmVhZGFibGVTdHJlYW1FcnJvciB9IGZyb20gJy4uL3JlYWRhYmxlLXN0cmVhbSc7XG5pbXBvcnQgeyBWYWxpZGF0ZWRVbmRlcmx5aW5nU291cmNlIH0gZnJvbSAnLi91bmRlcmx5aW5nLXNvdXJjZSc7XG5pbXBvcnQgeyB0eXBlSXNPYmplY3QgfSBmcm9tICcuLi9oZWxwZXJzL21pc2NlbGxhbmVvdXMnO1xuaW1wb3J0IHsgQ2FuY2VsU3RlcHMsIFB1bGxTdGVwcyB9IGZyb20gJy4uL2Fic3RyYWN0LW9wcy9pbnRlcm5hbC1tZXRob2RzJztcbmltcG9ydCB7IHByb21pc2VSZXNvbHZlZFdpdGgsIHVwb25Qcm9taXNlIH0gZnJvbSAnLi4vaGVscGVycy93ZWJpZGwnO1xuXG4vKipcbiAqIEFsbG93cyBjb250cm9sIG9mIGEge0BsaW5rIFJlYWRhYmxlU3RyZWFtIHwgcmVhZGFibGUgc3RyZWFtfSdzIHN0YXRlIGFuZCBpbnRlcm5hbCBxdWV1ZS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyPFI+IHtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfY29udHJvbGxlZFJlYWRhYmxlU3RyZWFtITogUmVhZGFibGVTdHJlYW08Uj47XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3F1ZXVlITogU2ltcGxlUXVldWU8UXVldWVQYWlyPFI+PjtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfcXVldWVUb3RhbFNpemUhOiBudW1iZXI7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3N0YXJ0ZWQhOiBib29sZWFuO1xuICAvKiogQGludGVybmFsICovXG4gIF9jbG9zZVJlcXVlc3RlZCE6IGJvb2xlYW47XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3B1bGxBZ2FpbiE6IGJvb2xlYW47XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3B1bGxpbmcgITogYm9vbGVhbjtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfc3RyYXRlZ3lTaXplQWxnb3JpdGhtITogUXVldWluZ1N0cmF0ZWd5U2l6ZUNhbGxiYWNrPFI+O1xuICAvKiogQGludGVybmFsICovXG4gIF9zdHJhdGVneUhXTSE6IG51bWJlcjtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfcHVsbEFsZ29yaXRobSE6ICgpID0+IFByb21pc2U8dm9pZD47XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2NhbmNlbEFsZ29yaXRobSE6IChyZWFzb246IGFueSkgPT4gUHJvbWlzZTx2b2lkPjtcblxuICBwcml2YXRlIGNvbnN0cnVjdG9yKCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0lsbGVnYWwgY29uc3RydWN0b3InKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBkZXNpcmVkIHNpemUgdG8gZmlsbCB0aGUgY29udHJvbGxlZCBzdHJlYW0ncyBpbnRlcm5hbCBxdWV1ZS4gSXQgY2FuIGJlIG5lZ2F0aXZlLCBpZiB0aGUgcXVldWUgaXNcbiAgICogb3Zlci1mdWxsLiBBbiB1bmRlcmx5aW5nIHNvdXJjZSBvdWdodCB0byB1c2UgdGhpcyBpbmZvcm1hdGlvbiB0byBkZXRlcm1pbmUgd2hlbiBhbmQgaG93IHRvIGFwcGx5IGJhY2twcmVzc3VyZS5cbiAgICovXG4gIGdldCBkZXNpcmVkU2l6ZSgpOiBudW1iZXIgfCBudWxsIHtcbiAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcih0aGlzKSkge1xuICAgICAgdGhyb3cgZGVmYXVsdENvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdkZXNpcmVkU2l6ZScpO1xuICAgIH1cblxuICAgIHJldHVybiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyR2V0RGVzaXJlZFNpemUodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogQ2xvc2VzIHRoZSBjb250cm9sbGVkIHJlYWRhYmxlIHN0cmVhbS4gQ29uc3VtZXJzIHdpbGwgc3RpbGwgYmUgYWJsZSB0byByZWFkIGFueSBwcmV2aW91c2x5LWVucXVldWVkIGNodW5rcyBmcm9tXG4gICAqIHRoZSBzdHJlYW0sIGJ1dCBvbmNlIHRob3NlIGFyZSByZWFkLCB0aGUgc3RyZWFtIHdpbGwgYmVjb21lIGNsb3NlZC5cbiAgICovXG4gIGNsb3NlKCk6IHZvaWQge1xuICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyKHRoaXMpKSB7XG4gICAgICB0aHJvdyBkZWZhdWx0Q29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ2Nsb3NlJyk7XG4gICAgfVxuXG4gICAgaWYgKCFSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2FuQ2xvc2VPckVucXVldWUodGhpcykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBzdHJlYW0gaXMgbm90IGluIGEgc3RhdGUgdGhhdCBwZXJtaXRzIGNsb3NlJyk7XG4gICAgfVxuXG4gICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsb3NlKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEVucXVldWVzIHRoZSBnaXZlbiBjaHVuayBgY2h1bmtgIGluIHRoZSBjb250cm9sbGVkIHJlYWRhYmxlIHN0cmVhbS5cbiAgICovXG4gIGVucXVldWUoY2h1bms6IFIpOiB2b2lkO1xuICBlbnF1ZXVlKGNodW5rOiBSID0gdW5kZWZpbmVkISk6IHZvaWQge1xuICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyKHRoaXMpKSB7XG4gICAgICB0aHJvdyBkZWZhdWx0Q29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ2VucXVldWUnKTtcbiAgICB9XG5cbiAgICBpZiAoIVJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDYW5DbG9zZU9yRW5xdWV1ZSh0aGlzKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIHN0cmVhbSBpcyBub3QgaW4gYSBzdGF0ZSB0aGF0IHBlcm1pdHMgZW5xdWV1ZScpO1xuICAgIH1cblxuICAgIHJldHVybiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRW5xdWV1ZSh0aGlzLCBjaHVuayk7XG4gIH1cblxuICAvKipcbiAgICogRXJyb3JzIHRoZSBjb250cm9sbGVkIHJlYWRhYmxlIHN0cmVhbSwgbWFraW5nIGFsbCBmdXR1cmUgaW50ZXJhY3Rpb25zIHdpdGggaXQgZmFpbCB3aXRoIHRoZSBnaXZlbiBlcnJvciBgZWAuXG4gICAqL1xuICBlcnJvcihlOiBhbnkgPSB1bmRlZmluZWQpOiB2b2lkIHtcbiAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcih0aGlzKSkge1xuICAgICAgdGhyb3cgZGVmYXVsdENvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdlcnJvcicpO1xuICAgIH1cblxuICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcih0aGlzLCBlKTtcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgW0NhbmNlbFN0ZXBzXShyZWFzb246IGFueSk6IFByb21pc2U8dm9pZD4ge1xuICAgIFJlc2V0UXVldWUodGhpcyk7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fY2FuY2VsQWxnb3JpdGhtKHJlYXNvbik7XG4gICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyh0aGlzKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBbUHVsbFN0ZXBzXShyZWFkUmVxdWVzdDogUmVhZFJlcXVlc3Q8Uj4pOiB2b2lkIHtcbiAgICBjb25zdCBzdHJlYW0gPSB0aGlzLl9jb250cm9sbGVkUmVhZGFibGVTdHJlYW07XG5cbiAgICBpZiAodGhpcy5fcXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgY2h1bmsgPSBEZXF1ZXVlVmFsdWUodGhpcyk7XG5cbiAgICAgIGlmICh0aGlzLl9jbG9zZVJlcXVlc3RlZCAmJiB0aGlzLl9xdWV1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyh0aGlzKTtcbiAgICAgICAgUmVhZGFibGVTdHJlYW1DbG9zZShzdHJlYW0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNhbGxQdWxsSWZOZWVkZWQodGhpcyk7XG4gICAgICB9XG5cbiAgICAgIHJlYWRSZXF1ZXN0Ll9jaHVua1N0ZXBzKGNodW5rKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhZGFibGVTdHJlYW1BZGRSZWFkUmVxdWVzdChzdHJlYW0sIHJlYWRSZXF1ZXN0KTtcbiAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDYWxsUHVsbElmTmVlZGVkKHRoaXMpO1xuICAgIH1cbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZSwge1xuICBjbG9zZTogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gIGVucXVldWU6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICBlcnJvcjogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gIGRlc2lyZWRTaXplOiB7IGVudW1lcmFibGU6IHRydWUgfVxufSk7XG5pZiAodHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIucHJvdG90eXBlLCBTeW1ib2wudG9TdHJpbmdUYWcsIHtcbiAgICB2YWx1ZTogJ1JlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXInLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuLy8gQWJzdHJhY3Qgb3BlcmF0aW9ucyBmb3IgdGhlIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIuXG5cbmZ1bmN0aW9uIElzUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxSID0gYW55Pih4OiBhbnkpOiB4IGlzIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8Uj4ge1xuICBpZiAoIXR5cGVJc09iamVjdCh4KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdfY29udHJvbGxlZFJlYWRhYmxlU3RyZWFtJykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4geCBpbnN0YW5jZW9mIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI7XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDYWxsUHVsbElmTmVlZGVkKGNvbnRyb2xsZXI6IFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8YW55Pik6IHZvaWQge1xuICBjb25zdCBzaG91bGRQdWxsID0gUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlclNob3VsZENhbGxQdWxsKGNvbnRyb2xsZXIpO1xuICBpZiAoIXNob3VsZFB1bGwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoY29udHJvbGxlci5fcHVsbGluZykge1xuICAgIGNvbnRyb2xsZXIuX3B1bGxBZ2FpbiA9IHRydWU7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgYXNzZXJ0KCFjb250cm9sbGVyLl9wdWxsQWdhaW4pO1xuXG4gIGNvbnRyb2xsZXIuX3B1bGxpbmcgPSB0cnVlO1xuXG4gIGNvbnN0IHB1bGxQcm9taXNlID0gY29udHJvbGxlci5fcHVsbEFsZ29yaXRobSgpO1xuICB1cG9uUHJvbWlzZShcbiAgICBwdWxsUHJvbWlzZSxcbiAgICAoKSA9PiB7XG4gICAgICBjb250cm9sbGVyLl9wdWxsaW5nID0gZmFsc2U7XG5cbiAgICAgIGlmIChjb250cm9sbGVyLl9wdWxsQWdhaW4pIHtcbiAgICAgICAgY29udHJvbGxlci5fcHVsbEFnYWluID0gZmFsc2U7XG4gICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDYWxsUHVsbElmTmVlZGVkKGNvbnRyb2xsZXIpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZSA9PiB7XG4gICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3IoY29udHJvbGxlciwgZSk7XG4gICAgfVxuICApO1xufVxuXG5mdW5jdGlvbiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyU2hvdWxkQ2FsbFB1bGwoY29udHJvbGxlcjogUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxhbnk+KTogYm9vbGVhbiB7XG4gIGNvbnN0IHN0cmVhbSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZVN0cmVhbTtcblxuICBpZiAoIVJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDYW5DbG9zZU9yRW5xdWV1ZShjb250cm9sbGVyKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICghY29udHJvbGxlci5fc3RhcnRlZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChJc1JlYWRhYmxlU3RyZWFtTG9ja2VkKHN0cmVhbSkgJiYgUmVhZGFibGVTdHJlYW1HZXROdW1SZWFkUmVxdWVzdHMoc3RyZWFtKSA+IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGNvbnN0IGRlc2lyZWRTaXplID0gUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckdldERlc2lyZWRTaXplKGNvbnRyb2xsZXIpO1xuICBhc3NlcnQoZGVzaXJlZFNpemUgIT09IG51bGwpO1xuICBpZiAoZGVzaXJlZFNpemUhID4gMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKGNvbnRyb2xsZXI6IFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8YW55Pikge1xuICBjb250cm9sbGVyLl9wdWxsQWxnb3JpdGhtID0gdW5kZWZpbmVkITtcbiAgY29udHJvbGxlci5fY2FuY2VsQWxnb3JpdGhtID0gdW5kZWZpbmVkITtcbiAgY29udHJvbGxlci5fc3RyYXRlZ3lTaXplQWxnb3JpdGhtID0gdW5kZWZpbmVkITtcbn1cblxuLy8gQSBjbGllbnQgb2YgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlciBtYXkgdXNlIHRoZXNlIGZ1bmN0aW9ucyBkaXJlY3RseSB0byBieXBhc3Mgc3RhdGUgY2hlY2suXG5cbmV4cG9ydCBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xvc2UoY29udHJvbGxlcjogUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxhbnk+KSB7XG4gIGlmICghUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNhbkNsb3NlT3JFbnF1ZXVlKGNvbnRyb2xsZXIpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3Qgc3RyZWFtID0gY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlU3RyZWFtO1xuXG4gIGNvbnRyb2xsZXIuX2Nsb3NlUmVxdWVzdGVkID0gdHJ1ZTtcblxuICBpZiAoY29udHJvbGxlci5fcXVldWUubGVuZ3RoID09PSAwKSB7XG4gICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyhjb250cm9sbGVyKTtcbiAgICBSZWFkYWJsZVN0cmVhbUNsb3NlKHN0cmVhbSk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFbnF1ZXVlPFI+KFxuICBjb250cm9sbGVyOiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyPFI+LFxuICBjaHVuazogUlxuKTogdm9pZCB7XG4gIGlmICghUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNhbkNsb3NlT3JFbnF1ZXVlKGNvbnRyb2xsZXIpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3Qgc3RyZWFtID0gY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlU3RyZWFtO1xuXG4gIGlmIChJc1JlYWRhYmxlU3RyZWFtTG9ja2VkKHN0cmVhbSkgJiYgUmVhZGFibGVTdHJlYW1HZXROdW1SZWFkUmVxdWVzdHMoc3RyZWFtKSA+IDApIHtcbiAgICBSZWFkYWJsZVN0cmVhbUZ1bGZpbGxSZWFkUmVxdWVzdChzdHJlYW0sIGNodW5rLCBmYWxzZSk7XG4gIH0gZWxzZSB7XG4gICAgbGV0IGNodW5rU2l6ZTtcbiAgICB0cnkge1xuICAgICAgY2h1bmtTaXplID0gY29udHJvbGxlci5fc3RyYXRlZ3lTaXplQWxnb3JpdGhtKGNodW5rKTtcbiAgICB9IGNhdGNoIChjaHVua1NpemVFKSB7XG4gICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3IoY29udHJvbGxlciwgY2h1bmtTaXplRSk7XG4gICAgICB0aHJvdyBjaHVua1NpemVFO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBFbnF1ZXVlVmFsdWVXaXRoU2l6ZShjb250cm9sbGVyLCBjaHVuaywgY2h1bmtTaXplKTtcbiAgICB9IGNhdGNoIChlbnF1ZXVlRSkge1xuICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9yKGNvbnRyb2xsZXIsIGVucXVldWVFKTtcbiAgICAgIHRocm93IGVucXVldWVFO1xuICAgIH1cbiAgfVxuXG4gIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDYWxsUHVsbElmTmVlZGVkKGNvbnRyb2xsZXIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9yKGNvbnRyb2xsZXI6IFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8YW55PiwgZTogYW55KSB7XG4gIGNvbnN0IHN0cmVhbSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZVN0cmVhbTtcblxuICBpZiAoc3RyZWFtLl9zdGF0ZSAhPT0gJ3JlYWRhYmxlJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIFJlc2V0UXVldWUoY29udHJvbGxlcik7XG5cbiAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyhjb250cm9sbGVyKTtcbiAgUmVhZGFibGVTdHJlYW1FcnJvcihzdHJlYW0sIGUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckdldERlc2lyZWRTaXplKFxuICBjb250cm9sbGVyOiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyPGFueT5cbik6IG51bWJlciB8IG51bGwge1xuICBjb25zdCBzdGF0ZSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZVN0cmVhbS5fc3RhdGU7XG5cbiAgaWYgKHN0YXRlID09PSAnZXJyb3JlZCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoc3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICByZXR1cm4gY29udHJvbGxlci5fc3RyYXRlZ3lIV00gLSBjb250cm9sbGVyLl9xdWV1ZVRvdGFsU2l6ZTtcbn1cblxuLy8gVGhpcyBpcyB1c2VkIGluIHRoZSBpbXBsZW1lbnRhdGlvbiBvZiBUcmFuc2Zvcm1TdHJlYW0uXG5leHBvcnQgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckhhc0JhY2twcmVzc3VyZShcbiAgY29udHJvbGxlcjogUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxhbnk+XG4pOiBib29sZWFuIHtcbiAgaWYgKFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJTaG91bGRDYWxsUHVsbChjb250cm9sbGVyKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNhbkNsb3NlT3JFbnF1ZXVlKFxuICBjb250cm9sbGVyOiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyPGFueT5cbik6IGJvb2xlYW4ge1xuICBjb25zdCBzdGF0ZSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZVN0cmVhbS5fc3RhdGU7XG5cbiAgaWYgKCFjb250cm9sbGVyLl9jbG9zZVJlcXVlc3RlZCAmJiBzdGF0ZSA9PT0gJ3JlYWRhYmxlJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gU2V0VXBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyPFI+KHN0cmVhbTogUmVhZGFibGVTdHJlYW08Uj4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXI6IFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8Uj4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0QWxnb3JpdGhtOiAoKSA9PiB2b2lkIHwgUHJvbWlzZUxpa2U8dm9pZD4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1bGxBbGdvcml0aG06ICgpID0+IFByb21pc2U8dm9pZD4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbmNlbEFsZ29yaXRobTogKHJlYXNvbjogYW55KSA9PiBQcm9taXNlPHZvaWQ+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaWdoV2F0ZXJNYXJrOiBudW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpemVBbGdvcml0aG06IFF1ZXVpbmdTdHJhdGVneVNpemVDYWxsYmFjazxSPikge1xuICBhc3NlcnQoc3RyZWFtLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIgPT09IHVuZGVmaW5lZCk7XG5cbiAgY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlU3RyZWFtID0gc3RyZWFtO1xuXG4gIGNvbnRyb2xsZXIuX3F1ZXVlID0gdW5kZWZpbmVkITtcbiAgY29udHJvbGxlci5fcXVldWVUb3RhbFNpemUgPSB1bmRlZmluZWQhO1xuICBSZXNldFF1ZXVlKGNvbnRyb2xsZXIpO1xuXG4gIGNvbnRyb2xsZXIuX3N0YXJ0ZWQgPSBmYWxzZTtcbiAgY29udHJvbGxlci5fY2xvc2VSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgY29udHJvbGxlci5fcHVsbEFnYWluID0gZmFsc2U7XG4gIGNvbnRyb2xsZXIuX3B1bGxpbmcgPSBmYWxzZTtcblxuICBjb250cm9sbGVyLl9zdHJhdGVneVNpemVBbGdvcml0aG0gPSBzaXplQWxnb3JpdGhtO1xuICBjb250cm9sbGVyLl9zdHJhdGVneUhXTSA9IGhpZ2hXYXRlck1hcms7XG5cbiAgY29udHJvbGxlci5fcHVsbEFsZ29yaXRobSA9IHB1bGxBbGdvcml0aG07XG4gIGNvbnRyb2xsZXIuX2NhbmNlbEFsZ29yaXRobSA9IGNhbmNlbEFsZ29yaXRobTtcblxuICBzdHJlYW0uX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciA9IGNvbnRyb2xsZXI7XG5cbiAgY29uc3Qgc3RhcnRSZXN1bHQgPSBzdGFydEFsZ29yaXRobSgpO1xuICB1cG9uUHJvbWlzZShcbiAgICBwcm9taXNlUmVzb2x2ZWRXaXRoKHN0YXJ0UmVzdWx0KSxcbiAgICAoKSA9PiB7XG4gICAgICBjb250cm9sbGVyLl9zdGFydGVkID0gdHJ1ZTtcblxuICAgICAgYXNzZXJ0KCFjb250cm9sbGVyLl9wdWxsaW5nKTtcbiAgICAgIGFzc2VydCghY29udHJvbGxlci5fcHVsbEFnYWluKTtcblxuICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNhbGxQdWxsSWZOZWVkZWQoY29udHJvbGxlcik7XG4gICAgfSxcbiAgICByID0+IHtcbiAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcihjb250cm9sbGVyLCByKTtcbiAgICB9XG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBTZXRVcFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJGcm9tVW5kZXJseWluZ1NvdXJjZTxSPihcbiAgc3RyZWFtOiBSZWFkYWJsZVN0cmVhbTxSPixcbiAgdW5kZXJseWluZ1NvdXJjZTogVmFsaWRhdGVkVW5kZXJseWluZ1NvdXJjZTxSPixcbiAgaGlnaFdhdGVyTWFyazogbnVtYmVyLFxuICBzaXplQWxnb3JpdGhtOiBRdWV1aW5nU3RyYXRlZ3lTaXplQ2FsbGJhY2s8Uj5cbikge1xuICBjb25zdCBjb250cm9sbGVyOiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyPFI+ID0gT2JqZWN0LmNyZWF0ZShSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZSk7XG5cbiAgbGV0IHN0YXJ0QWxnb3JpdGhtOiAoKSA9PiB2b2lkIHwgUHJvbWlzZUxpa2U8dm9pZD4gPSAoKSA9PiB1bmRlZmluZWQ7XG4gIGxldCBwdWxsQWxnb3JpdGhtOiAoKSA9PiBQcm9taXNlPHZvaWQ+ID0gKCkgPT4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuICBsZXQgY2FuY2VsQWxnb3JpdGhtOiAocmVhc29uOiBhbnkpID0+IFByb21pc2U8dm9pZD4gPSAoKSA9PiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG5cbiAgaWYgKHVuZGVybHlpbmdTb3VyY2Uuc3RhcnQgIT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0QWxnb3JpdGhtID0gKCkgPT4gdW5kZXJseWluZ1NvdXJjZS5zdGFydCEoY29udHJvbGxlcik7XG4gIH1cbiAgaWYgKHVuZGVybHlpbmdTb3VyY2UucHVsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcHVsbEFsZ29yaXRobSA9ICgpID0+IHVuZGVybHlpbmdTb3VyY2UucHVsbCEoY29udHJvbGxlcik7XG4gIH1cbiAgaWYgKHVuZGVybHlpbmdTb3VyY2UuY2FuY2VsICE9PSB1bmRlZmluZWQpIHtcbiAgICBjYW5jZWxBbGdvcml0aG0gPSByZWFzb24gPT4gdW5kZXJseWluZ1NvdXJjZS5jYW5jZWwhKHJlYXNvbik7XG4gIH1cblxuICBTZXRVcFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIoXG4gICAgc3RyZWFtLCBjb250cm9sbGVyLCBzdGFydEFsZ29yaXRobSwgcHVsbEFsZ29yaXRobSwgY2FuY2VsQWxnb3JpdGhtLCBoaWdoV2F0ZXJNYXJrLCBzaXplQWxnb3JpdGhtXG4gICk7XG59XG5cbi8vIEhlbHBlciBmdW5jdGlvbnMgZm9yIHRoZSBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLlxuXG5mdW5jdGlvbiBkZWZhdWx0Q29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24obmFtZTogc3RyaW5nKTogVHlwZUVycm9yIHtcbiAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoXG4gICAgYFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIucHJvdG90eXBlLiR7bmFtZX0gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJgKTtcbn1cbiIsICJpbXBvcnQge1xuICBDcmVhdGVSZWFkYWJsZUJ5dGVTdHJlYW0sXG4gIENyZWF0ZVJlYWRhYmxlU3RyZWFtLFxuICBJc1JlYWRhYmxlU3RyZWFtLFxuICBSZWFkYWJsZUJ5dGVTdHJlYW0sXG4gIFJlYWRhYmxlU3RyZWFtLFxuICBSZWFkYWJsZVN0cmVhbUNhbmNlbCxcbiAgUmVhZGFibGVTdHJlYW1SZWFkZXJcbn0gZnJvbSAnLi4vcmVhZGFibGUtc3RyZWFtJztcbmltcG9ydCB7IFJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY1JlbGVhc2UgfSBmcm9tICcuL2dlbmVyaWMtcmVhZGVyJztcbmltcG9ydCB7XG4gIEFjcXVpcmVSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIsXG4gIElzUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyLFxuICBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXJSZWFkLFxuICBSZWFkUmVxdWVzdFxufSBmcm9tICcuL2RlZmF1bHQtcmVhZGVyJztcbmltcG9ydCB7XG4gIEFjcXVpcmVSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIsXG4gIElzUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyLFxuICBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXJSZWFkLFxuICBSZWFkSW50b1JlcXVlc3Rcbn0gZnJvbSAnLi9ieW9iLXJlYWRlcic7XG5pbXBvcnQgYXNzZXJ0IGZyb20gJy4uLy4uL3N0dWIvYXNzZXJ0JztcbmltcG9ydCB7IG5ld1Byb21pc2UsIHByb21pc2VSZXNvbHZlZFdpdGgsIHF1ZXVlTWljcm90YXNrLCB1cG9uUmVqZWN0aW9uIH0gZnJvbSAnLi4vaGVscGVycy93ZWJpZGwnO1xuaW1wb3J0IHtcbiAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcixcbiAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsb3NlLFxuICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRW5xdWV1ZSxcbiAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9yXG59IGZyb20gJy4vZGVmYXVsdC1jb250cm9sbGVyJztcbmltcG9ydCB7XG4gIElzUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcixcbiAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNsb3NlLFxuICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRW5xdWV1ZSxcbiAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVycm9yLFxuICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyR2V0QllPQlJlcXVlc3QsXG4gIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kLFxuICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZFdpdGhOZXdWaWV3XG59IGZyb20gJy4vYnl0ZS1zdHJlYW0tY29udHJvbGxlcic7XG5pbXBvcnQgeyBDcmVhdGVBcnJheUZyb21MaXN0IH0gZnJvbSAnLi4vYWJzdHJhY3Qtb3BzL2VjbWFzY3JpcHQnO1xuaW1wb3J0IHsgQ2xvbmVBc1VpbnQ4QXJyYXkgfSBmcm9tICcuLi9hYnN0cmFjdC1vcHMvbWlzY2VsbGFuZW91cyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbVRlZTxSPihzdHJlYW06IFJlYWRhYmxlU3RyZWFtPFI+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb25lRm9yQnJhbmNoMjogYm9vbGVhbik6IFtSZWFkYWJsZVN0cmVhbTxSPiwgUmVhZGFibGVTdHJlYW08Uj5dIHtcbiAgYXNzZXJ0KElzUmVhZGFibGVTdHJlYW0oc3RyZWFtKSk7XG4gIGFzc2VydCh0eXBlb2YgY2xvbmVGb3JCcmFuY2gyID09PSAnYm9vbGVhbicpO1xuICBpZiAoSXNSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyKHN0cmVhbS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyKSkge1xuICAgIHJldHVybiBSZWFkYWJsZUJ5dGVTdHJlYW1UZWUoc3RyZWFtIGFzIHVua25vd24gYXMgUmVhZGFibGVCeXRlU3RyZWFtKSBhc1xuICAgICAgdW5rbm93biBhcyBbUmVhZGFibGVTdHJlYW08Uj4sIFJlYWRhYmxlU3RyZWFtPFI+XTtcbiAgfVxuICByZXR1cm4gUmVhZGFibGVTdHJlYW1EZWZhdWx0VGVlKHN0cmVhbSwgY2xvbmVGb3JCcmFuY2gyKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFRlZTxSPihzdHJlYW06IFJlYWRhYmxlU3RyZWFtPFI+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9uZUZvckJyYW5jaDI6IGJvb2xlYW4pOiBbUmVhZGFibGVTdHJlYW08Uj4sIFJlYWRhYmxlU3RyZWFtPFI+XSB7XG4gIGFzc2VydChJc1JlYWRhYmxlU3RyZWFtKHN0cmVhbSkpO1xuICBhc3NlcnQodHlwZW9mIGNsb25lRm9yQnJhbmNoMiA9PT0gJ2Jvb2xlYW4nKTtcblxuICBjb25zdCByZWFkZXIgPSBBY3F1aXJlUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyPFI+KHN0cmVhbSk7XG5cbiAgbGV0IHJlYWRpbmcgPSBmYWxzZTtcbiAgbGV0IHJlYWRBZ2FpbiA9IGZhbHNlO1xuICBsZXQgY2FuY2VsZWQxID0gZmFsc2U7XG4gIGxldCBjYW5jZWxlZDIgPSBmYWxzZTtcbiAgbGV0IHJlYXNvbjE6IGFueTtcbiAgbGV0IHJlYXNvbjI6IGFueTtcbiAgbGV0IGJyYW5jaDE6IFJlYWRhYmxlU3RyZWFtPFI+O1xuICBsZXQgYnJhbmNoMjogUmVhZGFibGVTdHJlYW08Uj47XG5cbiAgbGV0IHJlc29sdmVDYW5jZWxQcm9taXNlOiAodmFsdWU6IHVuZGVmaW5lZCB8IFByb21pc2U8dW5kZWZpbmVkPikgPT4gdm9pZDtcbiAgY29uc3QgY2FuY2VsUHJvbWlzZSA9IG5ld1Byb21pc2U8dW5kZWZpbmVkPihyZXNvbHZlID0+IHtcbiAgICByZXNvbHZlQ2FuY2VsUHJvbWlzZSA9IHJlc29sdmU7XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIHB1bGxBbGdvcml0aG0oKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKHJlYWRpbmcpIHtcbiAgICAgIHJlYWRBZ2FpbiA9IHRydWU7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuICAgIH1cblxuICAgIHJlYWRpbmcgPSB0cnVlO1xuXG4gICAgY29uc3QgcmVhZFJlcXVlc3Q6IFJlYWRSZXF1ZXN0PFI+ID0ge1xuICAgICAgX2NodW5rU3RlcHM6IGNodW5rID0+IHtcbiAgICAgICAgLy8gVGhpcyBuZWVkcyB0byBiZSBkZWxheWVkIGEgbWljcm90YXNrIGJlY2F1c2UgaXQgdGFrZXMgYXQgbGVhc3QgYSBtaWNyb3Rhc2sgdG8gZGV0ZWN0IGVycm9ycyAodXNpbmdcbiAgICAgICAgLy8gcmVhZGVyLl9jbG9zZWRQcm9taXNlIGJlbG93KSwgYW5kIHdlIHdhbnQgZXJyb3JzIGluIHN0cmVhbSB0byBlcnJvciBib3RoIGJyYW5jaGVzIGltbWVkaWF0ZWx5LiBXZSBjYW5ub3QgbGV0XG4gICAgICAgIC8vIHN1Y2Nlc3NmdWwgc3luY2hyb25vdXNseS1hdmFpbGFibGUgcmVhZHMgZ2V0IGFoZWFkIG9mIGFzeW5jaHJvbm91c2x5LWF2YWlsYWJsZSBlcnJvcnMuXG4gICAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgICAgICByZWFkQWdhaW4gPSBmYWxzZTtcbiAgICAgICAgICBjb25zdCBjaHVuazEgPSBjaHVuaztcbiAgICAgICAgICBjb25zdCBjaHVuazIgPSBjaHVuaztcblxuICAgICAgICAgIC8vIFRoZXJlIGlzIG5vIHdheSB0byBhY2Nlc3MgdGhlIGNsb25pbmcgY29kZSByaWdodCBub3cgaW4gdGhlIHJlZmVyZW5jZSBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgICAvLyBJZiB3ZSBhZGQgb25lIHRoZW4gd2UnbGwgbmVlZCBhbiBpbXBsZW1lbnRhdGlvbiBmb3Igc2VyaWFsaXphYmxlIG9iamVjdHMuXG4gICAgICAgICAgLy8gaWYgKCFjYW5jZWxlZDIgJiYgY2xvbmVGb3JCcmFuY2gyKSB7XG4gICAgICAgICAgLy8gICBjaHVuazIgPSBTdHJ1Y3R1cmVkRGVzZXJpYWxpemUoU3RydWN0dXJlZFNlcmlhbGl6ZShjaHVuazIpKTtcbiAgICAgICAgICAvLyB9XG5cbiAgICAgICAgICBpZiAoIWNhbmNlbGVkMSkge1xuICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVucXVldWUoXG4gICAgICAgICAgICAgIGJyYW5jaDEuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciBhcyBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyPFI+LFxuICAgICAgICAgICAgICBjaHVuazFcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghY2FuY2VsZWQyKSB7XG4gICAgICAgICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRW5xdWV1ZShcbiAgICAgICAgICAgICAgYnJhbmNoMi5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyIGFzIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8Uj4sXG4gICAgICAgICAgICAgIGNodW5rMlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZWFkaW5nID0gZmFsc2U7XG4gICAgICAgICAgaWYgKHJlYWRBZ2Fpbikge1xuICAgICAgICAgICAgcHVsbEFsZ29yaXRobSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgX2Nsb3NlU3RlcHM6ICgpID0+IHtcbiAgICAgICAgcmVhZGluZyA9IGZhbHNlO1xuICAgICAgICBpZiAoIWNhbmNlbGVkMSkge1xuICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbG9zZShicmFuY2gxLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIgYXMgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxSPik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjYW5jZWxlZDIpIHtcbiAgICAgICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xvc2UoYnJhbmNoMi5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyIGFzIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8Uj4pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFjYW5jZWxlZDEgfHwgIWNhbmNlbGVkMikge1xuICAgICAgICAgIHJlc29sdmVDYW5jZWxQcm9taXNlKHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBfZXJyb3JTdGVwczogKCkgPT4ge1xuICAgICAgICByZWFkaW5nID0gZmFsc2U7XG4gICAgICB9XG4gICAgfTtcbiAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXJSZWFkKHJlYWRlciwgcmVhZFJlcXVlc3QpO1xuXG4gICAgcmV0dXJuIHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbmNlbDFBbGdvcml0aG0ocmVhc29uOiBhbnkpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjYW5jZWxlZDEgPSB0cnVlO1xuICAgIHJlYXNvbjEgPSByZWFzb247XG4gICAgaWYgKGNhbmNlbGVkMikge1xuICAgICAgY29uc3QgY29tcG9zaXRlUmVhc29uID0gQ3JlYXRlQXJyYXlGcm9tTGlzdChbcmVhc29uMSwgcmVhc29uMl0pO1xuICAgICAgY29uc3QgY2FuY2VsUmVzdWx0ID0gUmVhZGFibGVTdHJlYW1DYW5jZWwoc3RyZWFtLCBjb21wb3NpdGVSZWFzb24pO1xuICAgICAgcmVzb2x2ZUNhbmNlbFByb21pc2UoY2FuY2VsUmVzdWx0KTtcbiAgICB9XG4gICAgcmV0dXJuIGNhbmNlbFByb21pc2U7XG4gIH1cblxuICBmdW5jdGlvbiBjYW5jZWwyQWxnb3JpdGhtKHJlYXNvbjogYW55KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY2FuY2VsZWQyID0gdHJ1ZTtcbiAgICByZWFzb24yID0gcmVhc29uO1xuICAgIGlmIChjYW5jZWxlZDEpIHtcbiAgICAgIGNvbnN0IGNvbXBvc2l0ZVJlYXNvbiA9IENyZWF0ZUFycmF5RnJvbUxpc3QoW3JlYXNvbjEsIHJlYXNvbjJdKTtcbiAgICAgIGNvbnN0IGNhbmNlbFJlc3VsdCA9IFJlYWRhYmxlU3RyZWFtQ2FuY2VsKHN0cmVhbSwgY29tcG9zaXRlUmVhc29uKTtcbiAgICAgIHJlc29sdmVDYW5jZWxQcm9taXNlKGNhbmNlbFJlc3VsdCk7XG4gICAgfVxuICAgIHJldHVybiBjYW5jZWxQcm9taXNlO1xuICB9XG5cbiAgZnVuY3Rpb24gc3RhcnRBbGdvcml0aG0oKSB7XG4gICAgLy8gZG8gbm90aGluZ1xuICB9XG5cbiAgYnJhbmNoMSA9IENyZWF0ZVJlYWRhYmxlU3RyZWFtKHN0YXJ0QWxnb3JpdGhtLCBwdWxsQWxnb3JpdGhtLCBjYW5jZWwxQWxnb3JpdGhtKTtcbiAgYnJhbmNoMiA9IENyZWF0ZVJlYWRhYmxlU3RyZWFtKHN0YXJ0QWxnb3JpdGhtLCBwdWxsQWxnb3JpdGhtLCBjYW5jZWwyQWxnb3JpdGhtKTtcblxuICB1cG9uUmVqZWN0aW9uKHJlYWRlci5fY2xvc2VkUHJvbWlzZSwgKHI6IGFueSkgPT4ge1xuICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcihicmFuY2gxLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIgYXMgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxSPiwgcik7XG4gICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9yKGJyYW5jaDIuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciBhcyBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyPFI+LCByKTtcbiAgICBpZiAoIWNhbmNlbGVkMSB8fCAhY2FuY2VsZWQyKSB7XG4gICAgICByZXNvbHZlQ2FuY2VsUHJvbWlzZSh1bmRlZmluZWQpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIFticmFuY2gxLCBicmFuY2gyXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbVRlZShzdHJlYW06IFJlYWRhYmxlQnl0ZVN0cmVhbSk6IFtSZWFkYWJsZUJ5dGVTdHJlYW0sIFJlYWRhYmxlQnl0ZVN0cmVhbV0ge1xuICBhc3NlcnQoSXNSZWFkYWJsZVN0cmVhbShzdHJlYW0pKTtcbiAgYXNzZXJ0KElzUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcihzdHJlYW0uX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcikpO1xuXG4gIGxldCByZWFkZXI6IFJlYWRhYmxlU3RyZWFtUmVhZGVyPFVpbnQ4QXJyYXk+ID0gQWNxdWlyZVJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcihzdHJlYW0pO1xuICBsZXQgcmVhZGluZyA9IGZhbHNlO1xuICBsZXQgcmVhZEFnYWluRm9yQnJhbmNoMSA9IGZhbHNlO1xuICBsZXQgcmVhZEFnYWluRm9yQnJhbmNoMiA9IGZhbHNlO1xuICBsZXQgY2FuY2VsZWQxID0gZmFsc2U7XG4gIGxldCBjYW5jZWxlZDIgPSBmYWxzZTtcbiAgbGV0IHJlYXNvbjE6IGFueTtcbiAgbGV0IHJlYXNvbjI6IGFueTtcbiAgbGV0IGJyYW5jaDE6IFJlYWRhYmxlQnl0ZVN0cmVhbTtcbiAgbGV0IGJyYW5jaDI6IFJlYWRhYmxlQnl0ZVN0cmVhbTtcblxuICBsZXQgcmVzb2x2ZUNhbmNlbFByb21pc2U6ICh2YWx1ZTogdW5kZWZpbmVkIHwgUHJvbWlzZTx1bmRlZmluZWQ+KSA9PiB2b2lkO1xuICBjb25zdCBjYW5jZWxQcm9taXNlID0gbmV3UHJvbWlzZTx2b2lkPihyZXNvbHZlID0+IHtcbiAgICByZXNvbHZlQ2FuY2VsUHJvbWlzZSA9IHJlc29sdmU7XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIGZvcndhcmRSZWFkZXJFcnJvcih0aGlzUmVhZGVyOiBSZWFkYWJsZVN0cmVhbVJlYWRlcjxVaW50OEFycmF5Pikge1xuICAgIHVwb25SZWplY3Rpb24odGhpc1JlYWRlci5fY2xvc2VkUHJvbWlzZSwgciA9PiB7XG4gICAgICBpZiAodGhpc1JlYWRlciAhPT0gcmVhZGVyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFcnJvcihicmFuY2gxLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIHIpO1xuICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVycm9yKGJyYW5jaDIuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwgcik7XG4gICAgICBpZiAoIWNhbmNlbGVkMSB8fCAhY2FuY2VsZWQyKSB7XG4gICAgICAgIHJlc29sdmVDYW5jZWxQcm9taXNlKHVuZGVmaW5lZCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBwdWxsV2l0aERlZmF1bHRSZWFkZXIoKSB7XG4gICAgaWYgKElzUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyKHJlYWRlcikpIHtcbiAgICAgIGFzc2VydChyZWFkZXIuX3JlYWRJbnRvUmVxdWVzdHMubGVuZ3RoID09PSAwKTtcbiAgICAgIFJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY1JlbGVhc2UocmVhZGVyKTtcblxuICAgICAgcmVhZGVyID0gQWNxdWlyZVJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcihzdHJlYW0pO1xuICAgICAgZm9yd2FyZFJlYWRlckVycm9yKHJlYWRlcik7XG4gICAgfVxuXG4gICAgY29uc3QgcmVhZFJlcXVlc3Q6IFJlYWRSZXF1ZXN0PFVpbnQ4QXJyYXk+ID0ge1xuICAgICAgX2NodW5rU3RlcHM6IGNodW5rID0+IHtcbiAgICAgICAgLy8gVGhpcyBuZWVkcyB0byBiZSBkZWxheWVkIGEgbWljcm90YXNrIGJlY2F1c2UgaXQgdGFrZXMgYXQgbGVhc3QgYSBtaWNyb3Rhc2sgdG8gZGV0ZWN0IGVycm9ycyAodXNpbmdcbiAgICAgICAgLy8gcmVhZGVyLl9jbG9zZWRQcm9taXNlIGJlbG93KSwgYW5kIHdlIHdhbnQgZXJyb3JzIGluIHN0cmVhbSB0byBlcnJvciBib3RoIGJyYW5jaGVzIGltbWVkaWF0ZWx5LiBXZSBjYW5ub3QgbGV0XG4gICAgICAgIC8vIHN1Y2Nlc3NmdWwgc3luY2hyb25vdXNseS1hdmFpbGFibGUgcmVhZHMgZ2V0IGFoZWFkIG9mIGFzeW5jaHJvbm91c2x5LWF2YWlsYWJsZSBlcnJvcnMuXG4gICAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgICAgICByZWFkQWdhaW5Gb3JCcmFuY2gxID0gZmFsc2U7XG4gICAgICAgICAgcmVhZEFnYWluRm9yQnJhbmNoMiA9IGZhbHNlO1xuXG4gICAgICAgICAgY29uc3QgY2h1bmsxID0gY2h1bms7XG4gICAgICAgICAgbGV0IGNodW5rMiA9IGNodW5rO1xuICAgICAgICAgIGlmICghY2FuY2VsZWQxICYmICFjYW5jZWxlZDIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNodW5rMiA9IENsb25lQXNVaW50OEFycmF5KGNodW5rKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGNsb25lRSkge1xuICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRXJyb3IoYnJhbmNoMS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLCBjbG9uZUUpO1xuICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRXJyb3IoYnJhbmNoMi5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLCBjbG9uZUUpO1xuICAgICAgICAgICAgICByZXNvbHZlQ2FuY2VsUHJvbWlzZShSZWFkYWJsZVN0cmVhbUNhbmNlbChzdHJlYW0sIGNsb25lRSkpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFjYW5jZWxlZDEpIHtcbiAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFbnF1ZXVlKGJyYW5jaDEuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwgY2h1bmsxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFjYW5jZWxlZDIpIHtcbiAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFbnF1ZXVlKGJyYW5jaDIuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwgY2h1bmsyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZWFkaW5nID0gZmFsc2U7XG4gICAgICAgICAgaWYgKHJlYWRBZ2FpbkZvckJyYW5jaDEpIHtcbiAgICAgICAgICAgIHB1bGwxQWxnb3JpdGhtKCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChyZWFkQWdhaW5Gb3JCcmFuY2gyKSB7XG4gICAgICAgICAgICBwdWxsMkFsZ29yaXRobSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgX2Nsb3NlU3RlcHM6ICgpID0+IHtcbiAgICAgICAgcmVhZGluZyA9IGZhbHNlO1xuICAgICAgICBpZiAoIWNhbmNlbGVkMSkge1xuICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDbG9zZShicmFuY2gxLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY2FuY2VsZWQyKSB7XG4gICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNsb3NlKGJyYW5jaDIuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJyYW5jaDEuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmQoYnJhbmNoMS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnJhbmNoMi5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZChicmFuY2gyLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIDApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY2FuY2VsZWQxIHx8ICFjYW5jZWxlZDIpIHtcbiAgICAgICAgICByZXNvbHZlQ2FuY2VsUHJvbWlzZSh1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgX2Vycm9yU3RlcHM6ICgpID0+IHtcbiAgICAgICAgcmVhZGluZyA9IGZhbHNlO1xuICAgICAgfVxuICAgIH07XG4gICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyUmVhZChyZWFkZXIsIHJlYWRSZXF1ZXN0KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHB1bGxXaXRoQllPQlJlYWRlcih2aWV3OiBBcnJheUJ1ZmZlclZpZXcsIGZvckJyYW5jaDI6IGJvb2xlYW4pIHtcbiAgICBpZiAoSXNSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXI8VWludDhBcnJheT4ocmVhZGVyKSkge1xuICAgICAgYXNzZXJ0KHJlYWRlci5fcmVhZFJlcXVlc3RzLmxlbmd0aCA9PT0gMCk7XG4gICAgICBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNSZWxlYXNlKHJlYWRlcik7XG5cbiAgICAgIHJlYWRlciA9IEFjcXVpcmVSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIoc3RyZWFtKTtcbiAgICAgIGZvcndhcmRSZWFkZXJFcnJvcihyZWFkZXIpO1xuICAgIH1cblxuICAgIGNvbnN0IGJ5b2JCcmFuY2ggPSBmb3JCcmFuY2gyID8gYnJhbmNoMiA6IGJyYW5jaDE7XG4gICAgY29uc3Qgb3RoZXJCcmFuY2ggPSBmb3JCcmFuY2gyID8gYnJhbmNoMSA6IGJyYW5jaDI7XG5cbiAgICBjb25zdCByZWFkSW50b1JlcXVlc3Q6IFJlYWRJbnRvUmVxdWVzdDxBcnJheUJ1ZmZlclZpZXc+ID0ge1xuICAgICAgX2NodW5rU3RlcHM6IGNodW5rID0+IHtcbiAgICAgICAgLy8gVGhpcyBuZWVkcyB0byBiZSBkZWxheWVkIGEgbWljcm90YXNrIGJlY2F1c2UgaXQgdGFrZXMgYXQgbGVhc3QgYSBtaWNyb3Rhc2sgdG8gZGV0ZWN0IGVycm9ycyAodXNpbmdcbiAgICAgICAgLy8gcmVhZGVyLl9jbG9zZWRQcm9taXNlIGJlbG93KSwgYW5kIHdlIHdhbnQgZXJyb3JzIGluIHN0cmVhbSB0byBlcnJvciBib3RoIGJyYW5jaGVzIGltbWVkaWF0ZWx5LiBXZSBjYW5ub3QgbGV0XG4gICAgICAgIC8vIHN1Y2Nlc3NmdWwgc3luY2hyb25vdXNseS1hdmFpbGFibGUgcmVhZHMgZ2V0IGFoZWFkIG9mIGFzeW5jaHJvbm91c2x5LWF2YWlsYWJsZSBlcnJvcnMuXG4gICAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgICAgICByZWFkQWdhaW5Gb3JCcmFuY2gxID0gZmFsc2U7XG4gICAgICAgICAgcmVhZEFnYWluRm9yQnJhbmNoMiA9IGZhbHNlO1xuXG4gICAgICAgICAgY29uc3QgYnlvYkNhbmNlbGVkID0gZm9yQnJhbmNoMiA/IGNhbmNlbGVkMiA6IGNhbmNlbGVkMTtcbiAgICAgICAgICBjb25zdCBvdGhlckNhbmNlbGVkID0gZm9yQnJhbmNoMiA/IGNhbmNlbGVkMSA6IGNhbmNlbGVkMjtcblxuICAgICAgICAgIGlmICghb3RoZXJDYW5jZWxlZCkge1xuICAgICAgICAgICAgbGV0IGNsb25lZENodW5rO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY2xvbmVkQ2h1bmsgPSBDbG9uZUFzVWludDhBcnJheShjaHVuayk7XG4gICAgICAgICAgICB9IGNhdGNoIChjbG9uZUUpIHtcbiAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVycm9yKGJ5b2JCcmFuY2guX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwgY2xvbmVFKTtcbiAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVycm9yKG90aGVyQnJhbmNoLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIGNsb25lRSk7XG4gICAgICAgICAgICAgIHJlc29sdmVDYW5jZWxQcm9taXNlKFJlYWRhYmxlU3RyZWFtQ2FuY2VsKHN0cmVhbSwgY2xvbmVFKSk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghYnlvYkNhbmNlbGVkKSB7XG4gICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kV2l0aE5ld1ZpZXcoYnlvYkJyYW5jaC5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLCBjaHVuayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRW5xdWV1ZShvdGhlckJyYW5jaC5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLCBjbG9uZWRDaHVuayk7XG4gICAgICAgICAgfSBlbHNlIGlmICghYnlvYkNhbmNlbGVkKSB7XG4gICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZFdpdGhOZXdWaWV3KGJ5b2JCcmFuY2guX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwgY2h1bmspO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICBpZiAocmVhZEFnYWluRm9yQnJhbmNoMSkge1xuICAgICAgICAgICAgcHVsbDFBbGdvcml0aG0oKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHJlYWRBZ2FpbkZvckJyYW5jaDIpIHtcbiAgICAgICAgICAgIHB1bGwyQWxnb3JpdGhtKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBfY2xvc2VTdGVwczogY2h1bmsgPT4ge1xuICAgICAgICByZWFkaW5nID0gZmFsc2U7XG5cbiAgICAgICAgY29uc3QgYnlvYkNhbmNlbGVkID0gZm9yQnJhbmNoMiA/IGNhbmNlbGVkMiA6IGNhbmNlbGVkMTtcbiAgICAgICAgY29uc3Qgb3RoZXJDYW5jZWxlZCA9IGZvckJyYW5jaDIgPyBjYW5jZWxlZDEgOiBjYW5jZWxlZDI7XG5cbiAgICAgICAgaWYgKCFieW9iQ2FuY2VsZWQpIHtcbiAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2xvc2UoYnlvYkJyYW5jaC5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW90aGVyQ2FuY2VsZWQpIHtcbiAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2xvc2Uob3RoZXJCcmFuY2guX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2h1bmsgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGFzc2VydChjaHVuay5ieXRlTGVuZ3RoID09PSAwKTtcblxuICAgICAgICAgIGlmICghYnlvYkNhbmNlbGVkKSB7XG4gICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZFdpdGhOZXdWaWV3KGJ5b2JCcmFuY2guX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwgY2h1bmspO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIW90aGVyQ2FuY2VsZWQgJiYgb3RoZXJCcmFuY2guX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZChvdGhlckJyYW5jaC5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLCAwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWJ5b2JDYW5jZWxlZCB8fCAhb3RoZXJDYW5jZWxlZCkge1xuICAgICAgICAgIHJlc29sdmVDYW5jZWxQcm9taXNlKHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBfZXJyb3JTdGVwczogKCkgPT4ge1xuICAgICAgICByZWFkaW5nID0gZmFsc2U7XG4gICAgICB9XG4gICAgfTtcbiAgICBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXJSZWFkKHJlYWRlciwgdmlldywgcmVhZEludG9SZXF1ZXN0KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHB1bGwxQWxnb3JpdGhtKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmIChyZWFkaW5nKSB7XG4gICAgICByZWFkQWdhaW5Gb3JCcmFuY2gxID0gdHJ1ZTtcbiAgICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG4gICAgfVxuXG4gICAgcmVhZGluZyA9IHRydWU7XG5cbiAgICBjb25zdCBieW9iUmVxdWVzdCA9IFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJHZXRCWU9CUmVxdWVzdChicmFuY2gxLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIpO1xuICAgIGlmIChieW9iUmVxdWVzdCA9PT0gbnVsbCkge1xuICAgICAgcHVsbFdpdGhEZWZhdWx0UmVhZGVyKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHB1bGxXaXRoQllPQlJlYWRlcihieW9iUmVxdWVzdC5fdmlldyEsIGZhbHNlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuICB9XG5cbiAgZnVuY3Rpb24gcHVsbDJBbGdvcml0aG0oKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKHJlYWRpbmcpIHtcbiAgICAgIHJlYWRBZ2FpbkZvckJyYW5jaDIgPSB0cnVlO1xuICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcbiAgICB9XG5cbiAgICByZWFkaW5nID0gdHJ1ZTtcblxuICAgIGNvbnN0IGJ5b2JSZXF1ZXN0ID0gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckdldEJZT0JSZXF1ZXN0KGJyYW5jaDIuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcik7XG4gICAgaWYgKGJ5b2JSZXF1ZXN0ID09PSBudWxsKSB7XG4gICAgICBwdWxsV2l0aERlZmF1bHRSZWFkZXIoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHVsbFdpdGhCWU9CUmVhZGVyKGJ5b2JSZXF1ZXN0Ll92aWV3ISwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbmNlbDFBbGdvcml0aG0ocmVhc29uOiBhbnkpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjYW5jZWxlZDEgPSB0cnVlO1xuICAgIHJlYXNvbjEgPSByZWFzb247XG4gICAgaWYgKGNhbmNlbGVkMikge1xuICAgICAgY29uc3QgY29tcG9zaXRlUmVhc29uID0gQ3JlYXRlQXJyYXlGcm9tTGlzdChbcmVhc29uMSwgcmVhc29uMl0pO1xuICAgICAgY29uc3QgY2FuY2VsUmVzdWx0ID0gUmVhZGFibGVTdHJlYW1DYW5jZWwoc3RyZWFtLCBjb21wb3NpdGVSZWFzb24pO1xuICAgICAgcmVzb2x2ZUNhbmNlbFByb21pc2UoY2FuY2VsUmVzdWx0KTtcbiAgICB9XG4gICAgcmV0dXJuIGNhbmNlbFByb21pc2U7XG4gIH1cblxuICBmdW5jdGlvbiBjYW5jZWwyQWxnb3JpdGhtKHJlYXNvbjogYW55KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY2FuY2VsZWQyID0gdHJ1ZTtcbiAgICByZWFzb24yID0gcmVhc29uO1xuICAgIGlmIChjYW5jZWxlZDEpIHtcbiAgICAgIGNvbnN0IGNvbXBvc2l0ZVJlYXNvbiA9IENyZWF0ZUFycmF5RnJvbUxpc3QoW3JlYXNvbjEsIHJlYXNvbjJdKTtcbiAgICAgIGNvbnN0IGNhbmNlbFJlc3VsdCA9IFJlYWRhYmxlU3RyZWFtQ2FuY2VsKHN0cmVhbSwgY29tcG9zaXRlUmVhc29uKTtcbiAgICAgIHJlc29sdmVDYW5jZWxQcm9taXNlKGNhbmNlbFJlc3VsdCk7XG4gICAgfVxuICAgIHJldHVybiBjYW5jZWxQcm9taXNlO1xuICB9XG5cbiAgZnVuY3Rpb24gc3RhcnRBbGdvcml0aG0oKTogdm9pZCB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgYnJhbmNoMSA9IENyZWF0ZVJlYWRhYmxlQnl0ZVN0cmVhbShzdGFydEFsZ29yaXRobSwgcHVsbDFBbGdvcml0aG0sIGNhbmNlbDFBbGdvcml0aG0pO1xuICBicmFuY2gyID0gQ3JlYXRlUmVhZGFibGVCeXRlU3RyZWFtKHN0YXJ0QWxnb3JpdGhtLCBwdWxsMkFsZ29yaXRobSwgY2FuY2VsMkFsZ29yaXRobSk7XG5cbiAgZm9yd2FyZFJlYWRlckVycm9yKHJlYWRlcik7XG5cbiAgcmV0dXJuIFticmFuY2gxLCBicmFuY2gyXTtcbn1cbiIsICJpbXBvcnQgeyBhc3NlcnREaWN0aW9uYXJ5LCBhc3NlcnRGdW5jdGlvbiwgY29udmVydFVuc2lnbmVkTG9uZ0xvbmdXaXRoRW5mb3JjZVJhbmdlIH0gZnJvbSAnLi9iYXNpYyc7XG5pbXBvcnQge1xuICBSZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsXG4gIFVuZGVybHlpbmdCeXRlU291cmNlLFxuICBVbmRlcmx5aW5nRGVmYXVsdE9yQnl0ZVNvdXJjZSxcbiAgVW5kZXJseWluZ0RlZmF1bHRPckJ5dGVTb3VyY2VQdWxsQ2FsbGJhY2ssXG4gIFVuZGVybHlpbmdEZWZhdWx0T3JCeXRlU291cmNlU3RhcnRDYWxsYmFjayxcbiAgVW5kZXJseWluZ1NvdXJjZSxcbiAgVW5kZXJseWluZ1NvdXJjZUNhbmNlbENhbGxiYWNrLFxuICBWYWxpZGF0ZWRVbmRlcmx5aW5nRGVmYXVsdE9yQnl0ZVNvdXJjZVxufSBmcm9tICcuLi9yZWFkYWJsZS1zdHJlYW0vdW5kZXJseWluZy1zb3VyY2UnO1xuaW1wb3J0IHsgcHJvbWlzZUNhbGwsIHJlZmxlY3RDYWxsIH0gZnJvbSAnLi4vaGVscGVycy93ZWJpZGwnO1xuXG5leHBvcnQgZnVuY3Rpb24gY29udmVydFVuZGVybHlpbmdEZWZhdWx0T3JCeXRlU291cmNlPFI+KFxuICBzb3VyY2U6IFVuZGVybHlpbmdTb3VyY2U8Uj4gfCBVbmRlcmx5aW5nQnl0ZVNvdXJjZSB8IG51bGwsXG4gIGNvbnRleHQ6IHN0cmluZ1xuKTogVmFsaWRhdGVkVW5kZXJseWluZ0RlZmF1bHRPckJ5dGVTb3VyY2U8Uj4ge1xuICBhc3NlcnREaWN0aW9uYXJ5KHNvdXJjZSwgY29udGV4dCk7XG4gIGNvbnN0IG9yaWdpbmFsID0gc291cmNlIGFzIChVbmRlcmx5aW5nRGVmYXVsdE9yQnl0ZVNvdXJjZTxSPiB8IG51bGwpO1xuICBjb25zdCBhdXRvQWxsb2NhdGVDaHVua1NpemUgPSBvcmlnaW5hbD8uYXV0b0FsbG9jYXRlQ2h1bmtTaXplO1xuICBjb25zdCBjYW5jZWwgPSBvcmlnaW5hbD8uY2FuY2VsO1xuICBjb25zdCBwdWxsID0gb3JpZ2luYWw/LnB1bGw7XG4gIGNvbnN0IHN0YXJ0ID0gb3JpZ2luYWw/LnN0YXJ0O1xuICBjb25zdCB0eXBlID0gb3JpZ2luYWw/LnR5cGU7XG4gIHJldHVybiB7XG4gICAgYXV0b0FsbG9jYXRlQ2h1bmtTaXplOiBhdXRvQWxsb2NhdGVDaHVua1NpemUgPT09IHVuZGVmaW5lZCA/XG4gICAgICB1bmRlZmluZWQgOlxuICAgICAgY29udmVydFVuc2lnbmVkTG9uZ0xvbmdXaXRoRW5mb3JjZVJhbmdlKFxuICAgICAgICBhdXRvQWxsb2NhdGVDaHVua1NpemUsXG4gICAgICAgIGAke2NvbnRleHR9IGhhcyBtZW1iZXIgJ2F1dG9BbGxvY2F0ZUNodW5rU2l6ZScgdGhhdGBcbiAgICAgICksXG4gICAgY2FuY2VsOiBjYW5jZWwgPT09IHVuZGVmaW5lZCA/XG4gICAgICB1bmRlZmluZWQgOlxuICAgICAgY29udmVydFVuZGVybHlpbmdTb3VyY2VDYW5jZWxDYWxsYmFjayhjYW5jZWwsIG9yaWdpbmFsISwgYCR7Y29udGV4dH0gaGFzIG1lbWJlciAnY2FuY2VsJyB0aGF0YCksXG4gICAgcHVsbDogcHVsbCA9PT0gdW5kZWZpbmVkID9cbiAgICAgIHVuZGVmaW5lZCA6XG4gICAgICBjb252ZXJ0VW5kZXJseWluZ1NvdXJjZVB1bGxDYWxsYmFjayhwdWxsLCBvcmlnaW5hbCEsIGAke2NvbnRleHR9IGhhcyBtZW1iZXIgJ3B1bGwnIHRoYXRgKSxcbiAgICBzdGFydDogc3RhcnQgPT09IHVuZGVmaW5lZCA/XG4gICAgICB1bmRlZmluZWQgOlxuICAgICAgY29udmVydFVuZGVybHlpbmdTb3VyY2VTdGFydENhbGxiYWNrKHN0YXJ0LCBvcmlnaW5hbCEsIGAke2NvbnRleHR9IGhhcyBtZW1iZXIgJ3N0YXJ0JyB0aGF0YCksXG4gICAgdHlwZTogdHlwZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogY29udmVydFJlYWRhYmxlU3RyZWFtVHlwZSh0eXBlLCBgJHtjb250ZXh0fSBoYXMgbWVtYmVyICd0eXBlJyB0aGF0YClcbiAgfTtcbn1cblxuZnVuY3Rpb24gY29udmVydFVuZGVybHlpbmdTb3VyY2VDYW5jZWxDYWxsYmFjayhcbiAgZm46IFVuZGVybHlpbmdTb3VyY2VDYW5jZWxDYWxsYmFjayxcbiAgb3JpZ2luYWw6IFVuZGVybHlpbmdEZWZhdWx0T3JCeXRlU291cmNlLFxuICBjb250ZXh0OiBzdHJpbmdcbik6IChyZWFzb246IGFueSkgPT4gUHJvbWlzZTx2b2lkPiB7XG4gIGFzc2VydEZ1bmN0aW9uKGZuLCBjb250ZXh0KTtcbiAgcmV0dXJuIChyZWFzb246IGFueSkgPT4gcHJvbWlzZUNhbGwoZm4sIG9yaWdpbmFsLCBbcmVhc29uXSk7XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRVbmRlcmx5aW5nU291cmNlUHVsbENhbGxiYWNrPFI+KFxuICBmbjogVW5kZXJseWluZ0RlZmF1bHRPckJ5dGVTb3VyY2VQdWxsQ2FsbGJhY2s8Uj4sXG4gIG9yaWdpbmFsOiBVbmRlcmx5aW5nRGVmYXVsdE9yQnl0ZVNvdXJjZTxSPixcbiAgY29udGV4dDogc3RyaW5nXG4pOiAoY29udHJvbGxlcjogUmVhZGFibGVTdHJlYW1Db250cm9sbGVyPFI+KSA9PiBQcm9taXNlPHZvaWQ+IHtcbiAgYXNzZXJ0RnVuY3Rpb24oZm4sIGNvbnRleHQpO1xuICByZXR1cm4gKGNvbnRyb2xsZXI6IFJlYWRhYmxlU3RyZWFtQ29udHJvbGxlcjxSPikgPT4gcHJvbWlzZUNhbGwoZm4sIG9yaWdpbmFsLCBbY29udHJvbGxlcl0pO1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0VW5kZXJseWluZ1NvdXJjZVN0YXJ0Q2FsbGJhY2s8Uj4oXG4gIGZuOiBVbmRlcmx5aW5nRGVmYXVsdE9yQnl0ZVNvdXJjZVN0YXJ0Q2FsbGJhY2s8Uj4sXG4gIG9yaWdpbmFsOiBVbmRlcmx5aW5nRGVmYXVsdE9yQnl0ZVNvdXJjZTxSPixcbiAgY29udGV4dDogc3RyaW5nXG4pOiBVbmRlcmx5aW5nRGVmYXVsdE9yQnl0ZVNvdXJjZVN0YXJ0Q2FsbGJhY2s8Uj4ge1xuICBhc3NlcnRGdW5jdGlvbihmbiwgY29udGV4dCk7XG4gIHJldHVybiAoY29udHJvbGxlcjogUmVhZGFibGVTdHJlYW1Db250cm9sbGVyPFI+KSA9PiByZWZsZWN0Q2FsbChmbiwgb3JpZ2luYWwsIFtjb250cm9sbGVyXSk7XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRSZWFkYWJsZVN0cmVhbVR5cGUodHlwZTogc3RyaW5nLCBjb250ZXh0OiBzdHJpbmcpOiAnYnl0ZXMnIHtcbiAgdHlwZSA9IGAke3R5cGV9YDtcbiAgaWYgKHR5cGUgIT09ICdieXRlcycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke2NvbnRleHR9ICcke3R5cGV9JyBpcyBub3QgYSB2YWxpZCBlbnVtZXJhdGlvbiB2YWx1ZSBmb3IgUmVhZGFibGVTdHJlYW1UeXBlYCk7XG4gIH1cbiAgcmV0dXJuIHR5cGU7XG59XG4iLCAiaW1wb3J0IHsgYXNzZXJ0RGljdGlvbmFyeSB9IGZyb20gJy4vYmFzaWMnO1xuaW1wb3J0IHsgUmVhZGFibGVTdHJlYW1HZXRSZWFkZXJPcHRpb25zIH0gZnJvbSAnLi4vcmVhZGFibGUtc3RyZWFtL3JlYWRlci1vcHRpb25zJztcblxuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRSZWFkZXJPcHRpb25zKG9wdGlvbnM6IFJlYWRhYmxlU3RyZWFtR2V0UmVhZGVyT3B0aW9ucyB8IG51bGwgfCB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dDogc3RyaW5nKTogUmVhZGFibGVTdHJlYW1HZXRSZWFkZXJPcHRpb25zIHtcbiAgYXNzZXJ0RGljdGlvbmFyeShvcHRpb25zLCBjb250ZXh0KTtcbiAgY29uc3QgbW9kZSA9IG9wdGlvbnM/Lm1vZGU7XG4gIHJldHVybiB7XG4gICAgbW9kZTogbW9kZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogY29udmVydFJlYWRhYmxlU3RyZWFtUmVhZGVyTW9kZShtb2RlLCBgJHtjb250ZXh0fSBoYXMgbWVtYmVyICdtb2RlJyB0aGF0YClcbiAgfTtcbn1cblxuZnVuY3Rpb24gY29udmVydFJlYWRhYmxlU3RyZWFtUmVhZGVyTW9kZShtb2RlOiBzdHJpbmcsIGNvbnRleHQ6IHN0cmluZyk6ICdieW9iJyB7XG4gIG1vZGUgPSBgJHttb2RlfWA7XG4gIGlmIChtb2RlICE9PSAnYnlvYicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke2NvbnRleHR9ICcke21vZGV9JyBpcyBub3QgYSB2YWxpZCBlbnVtZXJhdGlvbiB2YWx1ZSBmb3IgUmVhZGFibGVTdHJlYW1SZWFkZXJNb2RlYCk7XG4gIH1cbiAgcmV0dXJuIG1vZGU7XG59XG4iLCAiaW1wb3J0IHsgYXNzZXJ0RGljdGlvbmFyeSB9IGZyb20gJy4vYmFzaWMnO1xuaW1wb3J0IHtcbiAgUmVhZGFibGVTdHJlYW1JdGVyYXRvck9wdGlvbnMsXG4gIFZhbGlkYXRlZFJlYWRhYmxlU3RyZWFtSXRlcmF0b3JPcHRpb25zXG59IGZyb20gJy4uL3JlYWRhYmxlLXN0cmVhbS9pdGVyYXRvci1vcHRpb25zJztcblxuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRJdGVyYXRvck9wdGlvbnMob3B0aW9uczogUmVhZGFibGVTdHJlYW1JdGVyYXRvck9wdGlvbnMgfCBudWxsIHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dDogc3RyaW5nKTogVmFsaWRhdGVkUmVhZGFibGVTdHJlYW1JdGVyYXRvck9wdGlvbnMge1xuICBhc3NlcnREaWN0aW9uYXJ5KG9wdGlvbnMsIGNvbnRleHQpO1xuICBjb25zdCBwcmV2ZW50Q2FuY2VsID0gb3B0aW9ucz8ucHJldmVudENhbmNlbDtcbiAgcmV0dXJuIHsgcHJldmVudENhbmNlbDogQm9vbGVhbihwcmV2ZW50Q2FuY2VsKSB9O1xufVxuIiwgImltcG9ydCB7IGFzc2VydERpY3Rpb25hcnkgfSBmcm9tICcuL2Jhc2ljJztcbmltcG9ydCB7IFN0cmVhbVBpcGVPcHRpb25zLCBWYWxpZGF0ZWRTdHJlYW1QaXBlT3B0aW9ucyB9IGZyb20gJy4uL3JlYWRhYmxlLXN0cmVhbS9waXBlLW9wdGlvbnMnO1xuaW1wb3J0IHsgQWJvcnRTaWduYWwsIGlzQWJvcnRTaWduYWwgfSBmcm9tICcuLi9hYm9ydC1zaWduYWwnO1xuXG5leHBvcnQgZnVuY3Rpb24gY29udmVydFBpcGVPcHRpb25zKG9wdGlvbnM6IFN0cmVhbVBpcGVPcHRpb25zIHwgbnVsbCB8IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dDogc3RyaW5nKTogVmFsaWRhdGVkU3RyZWFtUGlwZU9wdGlvbnMge1xuICBhc3NlcnREaWN0aW9uYXJ5KG9wdGlvbnMsIGNvbnRleHQpO1xuICBjb25zdCBwcmV2ZW50QWJvcnQgPSBvcHRpb25zPy5wcmV2ZW50QWJvcnQ7XG4gIGNvbnN0IHByZXZlbnRDYW5jZWwgPSBvcHRpb25zPy5wcmV2ZW50Q2FuY2VsO1xuICBjb25zdCBwcmV2ZW50Q2xvc2UgPSBvcHRpb25zPy5wcmV2ZW50Q2xvc2U7XG4gIGNvbnN0IHNpZ25hbCA9IG9wdGlvbnM/LnNpZ25hbDtcbiAgaWYgKHNpZ25hbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgYXNzZXJ0QWJvcnRTaWduYWwoc2lnbmFsLCBgJHtjb250ZXh0fSBoYXMgbWVtYmVyICdzaWduYWwnIHRoYXRgKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHByZXZlbnRBYm9ydDogQm9vbGVhbihwcmV2ZW50QWJvcnQpLFxuICAgIHByZXZlbnRDYW5jZWw6IEJvb2xlYW4ocHJldmVudENhbmNlbCksXG4gICAgcHJldmVudENsb3NlOiBCb29sZWFuKHByZXZlbnRDbG9zZSksXG4gICAgc2lnbmFsXG4gIH07XG59XG5cbmZ1bmN0aW9uIGFzc2VydEFib3J0U2lnbmFsKHNpZ25hbDogdW5rbm93biwgY29udGV4dDogc3RyaW5nKTogYXNzZXJ0cyBzaWduYWwgaXMgQWJvcnRTaWduYWwge1xuICBpZiAoIWlzQWJvcnRTaWduYWwoc2lnbmFsKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7Y29udGV4dH0gaXMgbm90IGFuIEFib3J0U2lnbmFsLmApO1xuICB9XG59XG4iLCAiaW1wb3J0IHsgYXNzZXJ0RGljdGlvbmFyeSwgYXNzZXJ0UmVxdWlyZWRGaWVsZCB9IGZyb20gJy4vYmFzaWMnO1xuaW1wb3J0IHsgUmVhZGFibGVTdHJlYW0gfSBmcm9tICcuLi9yZWFkYWJsZS1zdHJlYW0nO1xuaW1wb3J0IHsgV3JpdGFibGVTdHJlYW0gfSBmcm9tICcuLi93cml0YWJsZS1zdHJlYW0nO1xuaW1wb3J0IHsgYXNzZXJ0UmVhZGFibGVTdHJlYW0gfSBmcm9tICcuL3JlYWRhYmxlLXN0cmVhbSc7XG5pbXBvcnQgeyBhc3NlcnRXcml0YWJsZVN0cmVhbSB9IGZyb20gJy4vd3JpdGFibGUtc3RyZWFtJztcblxuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRSZWFkYWJsZVdyaXRhYmxlUGFpcjxSUyBleHRlbmRzIFJlYWRhYmxlU3RyZWFtLCBXUyBleHRlbmRzIFdyaXRhYmxlU3RyZWFtPihcbiAgcGFpcjogeyByZWFkYWJsZTogUlM7IHdyaXRhYmxlOiBXUyB9IHwgbnVsbCB8IHVuZGVmaW5lZCxcbiAgY29udGV4dDogc3RyaW5nXG4pOiB7IHJlYWRhYmxlOiBSUzsgd3JpdGFibGU6IFdTIH0ge1xuICBhc3NlcnREaWN0aW9uYXJ5KHBhaXIsIGNvbnRleHQpO1xuXG4gIGNvbnN0IHJlYWRhYmxlID0gcGFpcj8ucmVhZGFibGU7XG4gIGFzc2VydFJlcXVpcmVkRmllbGQocmVhZGFibGUsICdyZWFkYWJsZScsICdSZWFkYWJsZVdyaXRhYmxlUGFpcicpO1xuICBhc3NlcnRSZWFkYWJsZVN0cmVhbShyZWFkYWJsZSwgYCR7Y29udGV4dH0gaGFzIG1lbWJlciAncmVhZGFibGUnIHRoYXRgKTtcblxuICBjb25zdCB3cml0YWJsZSA9IHBhaXI/LndyaXRhYmxlO1xuICBhc3NlcnRSZXF1aXJlZEZpZWxkKHdyaXRhYmxlLCAnd3JpdGFibGUnLCAnUmVhZGFibGVXcml0YWJsZVBhaXInKTtcbiAgYXNzZXJ0V3JpdGFibGVTdHJlYW0od3JpdGFibGUsIGAke2NvbnRleHR9IGhhcyBtZW1iZXIgJ3dyaXRhYmxlJyB0aGF0YCk7XG5cbiAgcmV0dXJuIHsgcmVhZGFibGUsIHdyaXRhYmxlIH07XG59XG4iLCAiaW1wb3J0IGFzc2VydCBmcm9tICcuLi9zdHViL2Fzc2VydCc7XG5pbXBvcnQge1xuICBwcm9taXNlUmVqZWN0ZWRXaXRoLFxuICBwcm9taXNlUmVzb2x2ZWRXaXRoLFxuICBzZXRQcm9taXNlSXNIYW5kbGVkVG9UcnVlLFxuICB0cmFuc2Zvcm1Qcm9taXNlV2l0aFxufSBmcm9tICcuL2hlbHBlcnMvd2ViaWRsJztcbmltcG9ydCB7IFF1ZXVpbmdTdHJhdGVneSwgUXVldWluZ1N0cmF0ZWd5U2l6ZUNhbGxiYWNrIH0gZnJvbSAnLi9xdWV1aW5nLXN0cmF0ZWd5JztcbmltcG9ydCB7IEFjcXVpcmVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IsIFJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvciB9IGZyb20gJy4vcmVhZGFibGUtc3RyZWFtL2FzeW5jLWl0ZXJhdG9yJztcbmltcG9ydCB7IGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlUmVqZWN0LCBkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZVJlc29sdmUgfSBmcm9tICcuL3JlYWRhYmxlLXN0cmVhbS9nZW5lcmljLXJlYWRlcic7XG5pbXBvcnQge1xuICBBY3F1aXJlUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyLFxuICBJc1JlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcixcbiAgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyLFxuICBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkUmVzdWx0XG59IGZyb20gJy4vcmVhZGFibGUtc3RyZWFtL2RlZmF1bHQtcmVhZGVyJztcbmltcG9ydCB7XG4gIEFjcXVpcmVSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIsXG4gIElzUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyLFxuICBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIsXG4gIFJlYWRhYmxlU3RyZWFtQllPQlJlYWRSZXN1bHRcbn0gZnJvbSAnLi9yZWFkYWJsZS1zdHJlYW0vYnlvYi1yZWFkZXInO1xuaW1wb3J0IHsgUmVhZGFibGVTdHJlYW1QaXBlVG8gfSBmcm9tICcuL3JlYWRhYmxlLXN0cmVhbS9waXBlJztcbmltcG9ydCB7IFJlYWRhYmxlU3RyZWFtVGVlIH0gZnJvbSAnLi9yZWFkYWJsZS1zdHJlYW0vdGVlJztcbmltcG9ydCB7IElzV3JpdGFibGVTdHJlYW0sIElzV3JpdGFibGVTdHJlYW1Mb2NrZWQsIFdyaXRhYmxlU3RyZWFtIH0gZnJvbSAnLi93cml0YWJsZS1zdHJlYW0nO1xuaW1wb3J0IHsgU2ltcGxlUXVldWUgfSBmcm9tICcuL3NpbXBsZS1xdWV1ZSc7XG5pbXBvcnQge1xuICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyLFxuICBSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0LFxuICBTZXRVcFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIsXG4gIFNldFVwUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckZyb21VbmRlcmx5aW5nU291cmNlXG59IGZyb20gJy4vcmVhZGFibGUtc3RyZWFtL2J5dGUtc3RyZWFtLWNvbnRyb2xsZXInO1xuaW1wb3J0IHtcbiAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcixcbiAgU2V0VXBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLFxuICBTZXRVcFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJGcm9tVW5kZXJseWluZ1NvdXJjZVxufSBmcm9tICcuL3JlYWRhYmxlLXN0cmVhbS9kZWZhdWx0LWNvbnRyb2xsZXInO1xuaW1wb3J0IHtcbiAgVW5kZXJseWluZ0J5dGVTb3VyY2UsXG4gIFVuZGVybHlpbmdCeXRlU291cmNlUHVsbENhbGxiYWNrLFxuICBVbmRlcmx5aW5nQnl0ZVNvdXJjZVN0YXJ0Q2FsbGJhY2ssXG4gIFVuZGVybHlpbmdTb3VyY2UsXG4gIFVuZGVybHlpbmdTb3VyY2VDYW5jZWxDYWxsYmFjayxcbiAgVW5kZXJseWluZ1NvdXJjZVB1bGxDYWxsYmFjayxcbiAgVW5kZXJseWluZ1NvdXJjZVN0YXJ0Q2FsbGJhY2tcbn0gZnJvbSAnLi9yZWFkYWJsZS1zdHJlYW0vdW5kZXJseWluZy1zb3VyY2UnO1xuaW1wb3J0IHsgbm9vcCB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IHR5cGVJc09iamVjdCB9IGZyb20gJy4vaGVscGVycy9taXNjZWxsYW5lb3VzJztcbmltcG9ydCB7IENyZWF0ZUFycmF5RnJvbUxpc3QgfSBmcm9tICcuL2Fic3RyYWN0LW9wcy9lY21hc2NyaXB0JztcbmltcG9ydCB7IENhbmNlbFN0ZXBzIH0gZnJvbSAnLi9hYnN0cmFjdC1vcHMvaW50ZXJuYWwtbWV0aG9kcyc7XG5pbXBvcnQgeyBJc05vbk5lZ2F0aXZlTnVtYmVyIH0gZnJvbSAnLi9hYnN0cmFjdC1vcHMvbWlzY2VsbGFuZW91cyc7XG5pbXBvcnQgeyBhc3NlcnRPYmplY3QsIGFzc2VydFJlcXVpcmVkQXJndW1lbnQgfSBmcm9tICcuL3ZhbGlkYXRvcnMvYmFzaWMnO1xuaW1wb3J0IHsgY29udmVydFF1ZXVpbmdTdHJhdGVneSB9IGZyb20gJy4vdmFsaWRhdG9ycy9xdWV1aW5nLXN0cmF0ZWd5JztcbmltcG9ydCB7IEV4dHJhY3RIaWdoV2F0ZXJNYXJrLCBFeHRyYWN0U2l6ZUFsZ29yaXRobSB9IGZyb20gJy4vYWJzdHJhY3Qtb3BzL3F1ZXVpbmctc3RyYXRlZ3knO1xuaW1wb3J0IHsgY29udmVydFVuZGVybHlpbmdEZWZhdWx0T3JCeXRlU291cmNlIH0gZnJvbSAnLi92YWxpZGF0b3JzL3VuZGVybHlpbmctc291cmNlJztcbmltcG9ydCB7IFJlYWRhYmxlU3RyZWFtR2V0UmVhZGVyT3B0aW9ucyB9IGZyb20gJy4vcmVhZGFibGUtc3RyZWFtL3JlYWRlci1vcHRpb25zJztcbmltcG9ydCB7IGNvbnZlcnRSZWFkZXJPcHRpb25zIH0gZnJvbSAnLi92YWxpZGF0b3JzL3JlYWRlci1vcHRpb25zJztcbmltcG9ydCB7IFN0cmVhbVBpcGVPcHRpb25zLCBWYWxpZGF0ZWRTdHJlYW1QaXBlT3B0aW9ucyB9IGZyb20gJy4vcmVhZGFibGUtc3RyZWFtL3BpcGUtb3B0aW9ucyc7XG5pbXBvcnQgeyBSZWFkYWJsZVN0cmVhbUl0ZXJhdG9yT3B0aW9ucyB9IGZyb20gJy4vcmVhZGFibGUtc3RyZWFtL2l0ZXJhdG9yLW9wdGlvbnMnO1xuaW1wb3J0IHsgY29udmVydEl0ZXJhdG9yT3B0aW9ucyB9IGZyb20gJy4vdmFsaWRhdG9ycy9pdGVyYXRvci1vcHRpb25zJztcbmltcG9ydCB7IGNvbnZlcnRQaXBlT3B0aW9ucyB9IGZyb20gJy4vdmFsaWRhdG9ycy9waXBlLW9wdGlvbnMnO1xuaW1wb3J0IHsgUmVhZGFibGVXcml0YWJsZVBhaXIgfSBmcm9tICcuL3JlYWRhYmxlLXN0cmVhbS9yZWFkYWJsZS13cml0YWJsZS1wYWlyJztcbmltcG9ydCB7IGNvbnZlcnRSZWFkYWJsZVdyaXRhYmxlUGFpciB9IGZyb20gJy4vdmFsaWRhdG9ycy9yZWFkYWJsZS13cml0YWJsZS1wYWlyJztcblxuZXhwb3J0IHR5cGUgUmVhZGFibGVCeXRlU3RyZWFtID0gUmVhZGFibGVTdHJlYW08VWludDhBcnJheT4gJiB7XG4gIF9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXI6IFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJcbn07XG5cbnR5cGUgUmVhZGFibGVTdHJlYW1TdGF0ZSA9ICdyZWFkYWJsZScgfCAnY2xvc2VkJyB8ICdlcnJvcmVkJztcblxuLyoqXG4gKiBBIHJlYWRhYmxlIHN0cmVhbSByZXByZXNlbnRzIGEgc291cmNlIG9mIGRhdGEsIGZyb20gd2hpY2ggeW91IGNhbiByZWFkLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNsYXNzIFJlYWRhYmxlU3RyZWFtPFIgPSBhbnk+IHtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfc3RhdGUhOiBSZWFkYWJsZVN0cmVhbVN0YXRlO1xuICAvKiogQGludGVybmFsICovXG4gIF9yZWFkZXI6IFJlYWRhYmxlU3RyZWFtUmVhZGVyPFI+IHwgdW5kZWZpbmVkO1xuICAvKiogQGludGVybmFsICovXG4gIF9zdG9yZWRFcnJvcjogYW55O1xuICAvKiogQGludGVybmFsICovXG4gIF9kaXN0dXJiZWQhOiBib29sZWFuO1xuICAvKiogQGludGVybmFsICovXG4gIF9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIhOiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyPFI+IHwgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcjtcblxuICBjb25zdHJ1Y3Rvcih1bmRlcmx5aW5nU291cmNlOiBVbmRlcmx5aW5nQnl0ZVNvdXJjZSwgc3RyYXRlZ3k/OiB7IGhpZ2hXYXRlck1hcms/OiBudW1iZXI7IHNpemU/OiB1bmRlZmluZWQgfSk7XG4gIGNvbnN0cnVjdG9yKHVuZGVybHlpbmdTb3VyY2U/OiBVbmRlcmx5aW5nU291cmNlPFI+LCBzdHJhdGVneT86IFF1ZXVpbmdTdHJhdGVneTxSPik7XG4gIGNvbnN0cnVjdG9yKHJhd1VuZGVybHlpbmdTb3VyY2U6IFVuZGVybHlpbmdTb3VyY2U8Uj4gfCBVbmRlcmx5aW5nQnl0ZVNvdXJjZSB8IG51bGwgfCB1bmRlZmluZWQgPSB7fSxcbiAgICAgICAgICAgICAgcmF3U3RyYXRlZ3k6IFF1ZXVpbmdTdHJhdGVneTxSPiB8IG51bGwgfCB1bmRlZmluZWQgPSB7fSkge1xuICAgIGlmIChyYXdVbmRlcmx5aW5nU291cmNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJhd1VuZGVybHlpbmdTb3VyY2UgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NlcnRPYmplY3QocmF3VW5kZXJseWluZ1NvdXJjZSwgJ0ZpcnN0IHBhcmFtZXRlcicpO1xuICAgIH1cblxuICAgIGNvbnN0IHN0cmF0ZWd5ID0gY29udmVydFF1ZXVpbmdTdHJhdGVneShyYXdTdHJhdGVneSwgJ1NlY29uZCBwYXJhbWV0ZXInKTtcbiAgICBjb25zdCB1bmRlcmx5aW5nU291cmNlID0gY29udmVydFVuZGVybHlpbmdEZWZhdWx0T3JCeXRlU291cmNlKHJhd1VuZGVybHlpbmdTb3VyY2UsICdGaXJzdCBwYXJhbWV0ZXInKTtcblxuICAgIEluaXRpYWxpemVSZWFkYWJsZVN0cmVhbSh0aGlzKTtcblxuICAgIGlmICh1bmRlcmx5aW5nU291cmNlLnR5cGUgPT09ICdieXRlcycpIHtcbiAgICAgIGlmIChzdHJhdGVneS5zaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSBzdHJhdGVneSBmb3IgYSBieXRlIHN0cmVhbSBjYW5ub3QgaGF2ZSBhIHNpemUgZnVuY3Rpb24nKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGhpZ2hXYXRlck1hcmsgPSBFeHRyYWN0SGlnaFdhdGVyTWFyayhzdHJhdGVneSwgMCk7XG4gICAgICBTZXRVcFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJGcm9tVW5kZXJseWluZ1NvdXJjZShcbiAgICAgICAgdGhpcyBhcyB1bmtub3duIGFzIFJlYWRhYmxlQnl0ZVN0cmVhbSxcbiAgICAgICAgdW5kZXJseWluZ1NvdXJjZSxcbiAgICAgICAgaGlnaFdhdGVyTWFya1xuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzZXJ0KHVuZGVybHlpbmdTb3VyY2UudHlwZSA9PT0gdW5kZWZpbmVkKTtcbiAgICAgIGNvbnN0IHNpemVBbGdvcml0aG0gPSBFeHRyYWN0U2l6ZUFsZ29yaXRobShzdHJhdGVneSk7XG4gICAgICBjb25zdCBoaWdoV2F0ZXJNYXJrID0gRXh0cmFjdEhpZ2hXYXRlck1hcmsoc3RyYXRlZ3ksIDEpO1xuICAgICAgU2V0VXBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRnJvbVVuZGVybHlpbmdTb3VyY2UoXG4gICAgICAgIHRoaXMsXG4gICAgICAgIHVuZGVybHlpbmdTb3VyY2UsXG4gICAgICAgIGhpZ2hXYXRlck1hcmssXG4gICAgICAgIHNpemVBbGdvcml0aG1cbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgb3Igbm90IHRoZSByZWFkYWJsZSBzdHJlYW0gaXMgbG9ja2VkIHRvIGEge0BsaW5rIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlciB8IHJlYWRlcn0uXG4gICAqL1xuICBnZXQgbG9ja2VkKCk6IGJvb2xlYW4ge1xuICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbSh0aGlzKSkge1xuICAgICAgdGhyb3cgc3RyZWFtQnJhbmRDaGVja0V4Y2VwdGlvbignbG9ja2VkJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIElzUmVhZGFibGVTdHJlYW1Mb2NrZWQodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogQ2FuY2VscyB0aGUgc3RyZWFtLCBzaWduYWxpbmcgYSBsb3NzIG9mIGludGVyZXN0IGluIHRoZSBzdHJlYW0gYnkgYSBjb25zdW1lci5cbiAgICpcbiAgICogVGhlIHN1cHBsaWVkIGByZWFzb25gIGFyZ3VtZW50IHdpbGwgYmUgZ2l2ZW4gdG8gdGhlIHVuZGVybHlpbmcgc291cmNlJ3Mge0BsaW5rIFVuZGVybHlpbmdTb3VyY2UuY2FuY2VsIHwgY2FuY2VsKCl9XG4gICAqIG1ldGhvZCwgd2hpY2ggbWlnaHQgb3IgbWlnaHQgbm90IHVzZSBpdC5cbiAgICovXG4gIGNhbmNlbChyZWFzb246IGFueSA9IHVuZGVmaW5lZCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbSh0aGlzKSkge1xuICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoc3RyZWFtQnJhbmRDaGVja0V4Y2VwdGlvbignY2FuY2VsJykpO1xuICAgIH1cblxuICAgIGlmIChJc1JlYWRhYmxlU3RyZWFtTG9ja2VkKHRoaXMpKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FuY2VsIGEgc3RyZWFtIHRoYXQgYWxyZWFkeSBoYXMgYSByZWFkZXInKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFJlYWRhYmxlU3RyZWFtQ2FuY2VsKHRoaXMsIHJlYXNvbik7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHtAbGluayBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXJ9IGFuZCBsb2NrcyB0aGUgc3RyZWFtIHRvIHRoZSBuZXcgcmVhZGVyLlxuICAgKlxuICAgKiBUaGlzIGNhbGwgYmVoYXZlcyB0aGUgc2FtZSB3YXkgYXMgdGhlIG5vLWFyZ3VtZW50IHZhcmlhbnQsIGV4Y2VwdCB0aGF0IGl0IG9ubHkgd29ya3Mgb24gcmVhZGFibGUgYnl0ZSBzdHJlYW1zLFxuICAgKiBpLmUuIHN0cmVhbXMgd2hpY2ggd2VyZSBjb25zdHJ1Y3RlZCBzcGVjaWZpY2FsbHkgd2l0aCB0aGUgYWJpbGl0eSB0byBoYW5kbGUgXCJicmluZyB5b3VyIG93biBidWZmZXJcIiByZWFkaW5nLlxuICAgKiBUaGUgcmV0dXJuZWQgQllPQiByZWFkZXIgcHJvdmlkZXMgdGhlIGFiaWxpdHkgdG8gZGlyZWN0bHkgcmVhZCBpbmRpdmlkdWFsIGNodW5rcyBmcm9tIHRoZSBzdHJlYW0gdmlhIGl0c1xuICAgKiB7QGxpbmsgUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyLnJlYWQgfCByZWFkKCl9IG1ldGhvZCwgaW50byBkZXZlbG9wZXItc3VwcGxpZWQgYnVmZmVycywgYWxsb3dpbmcgbW9yZSBwcmVjaXNlXG4gICAqIGNvbnRyb2wgb3ZlciBhbGxvY2F0aW9uLlxuICAgKi9cbiAgZ2V0UmVhZGVyKHsgbW9kZSB9OiB7IG1vZGU6ICdieW9iJyB9KTogUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyO1xuICAvKipcbiAgICogQ3JlYXRlcyBhIHtAbGluayBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXJ9IGFuZCBsb2NrcyB0aGUgc3RyZWFtIHRvIHRoZSBuZXcgcmVhZGVyLlxuICAgKiBXaGlsZSB0aGUgc3RyZWFtIGlzIGxvY2tlZCwgbm8gb3RoZXIgcmVhZGVyIGNhbiBiZSBhY3F1aXJlZCB1bnRpbCB0aGlzIG9uZSBpcyByZWxlYXNlZC5cbiAgICpcbiAgICogVGhpcyBmdW5jdGlvbmFsaXR5IGlzIGVzcGVjaWFsbHkgdXNlZnVsIGZvciBjcmVhdGluZyBhYnN0cmFjdGlvbnMgdGhhdCBkZXNpcmUgdGhlIGFiaWxpdHkgdG8gY29uc3VtZSBhIHN0cmVhbVxuICAgKiBpbiBpdHMgZW50aXJldHkuIEJ5IGdldHRpbmcgYSByZWFkZXIgZm9yIHRoZSBzdHJlYW0sIHlvdSBjYW4gZW5zdXJlIG5vYm9keSBlbHNlIGNhbiBpbnRlcmxlYXZlIHJlYWRzIHdpdGggeW91cnNcbiAgICogb3IgY2FuY2VsIHRoZSBzdHJlYW0sIHdoaWNoIHdvdWxkIGludGVyZmVyZSB3aXRoIHlvdXIgYWJzdHJhY3Rpb24uXG4gICAqL1xuICBnZXRSZWFkZXIoKTogUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyPFI+O1xuICBnZXRSZWFkZXIoXG4gICAgcmF3T3B0aW9uczogUmVhZGFibGVTdHJlYW1HZXRSZWFkZXJPcHRpb25zIHwgbnVsbCB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZFxuICApOiBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXI8Uj4gfCBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIge1xuICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbSh0aGlzKSkge1xuICAgICAgdGhyb3cgc3RyZWFtQnJhbmRDaGVja0V4Y2VwdGlvbignZ2V0UmVhZGVyJyk7XG4gICAgfVxuXG4gICAgY29uc3Qgb3B0aW9ucyA9IGNvbnZlcnRSZWFkZXJPcHRpb25zKHJhd09wdGlvbnMsICdGaXJzdCBwYXJhbWV0ZXInKTtcblxuICAgIGlmIChvcHRpb25zLm1vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIEFjcXVpcmVSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIodGhpcyk7XG4gICAgfVxuXG4gICAgYXNzZXJ0KG9wdGlvbnMubW9kZSA9PT0gJ2J5b2InKTtcbiAgICByZXR1cm4gQWNxdWlyZVJlYWRhYmxlU3RyZWFtQllPQlJlYWRlcih0aGlzIGFzIHVua25vd24gYXMgUmVhZGFibGVCeXRlU3RyZWFtKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm92aWRlcyBhIGNvbnZlbmllbnQsIGNoYWluYWJsZSB3YXkgb2YgcGlwaW5nIHRoaXMgcmVhZGFibGUgc3RyZWFtIHRocm91Z2ggYSB0cmFuc2Zvcm0gc3RyZWFtXG4gICAqIChvciBhbnkgb3RoZXIgYHsgd3JpdGFibGUsIHJlYWRhYmxlIH1gIHBhaXIpLiBJdCBzaW1wbHkge0BsaW5rIFJlYWRhYmxlU3RyZWFtLnBpcGVUbyB8IHBpcGVzfSB0aGUgc3RyZWFtXG4gICAqIGludG8gdGhlIHdyaXRhYmxlIHNpZGUgb2YgdGhlIHN1cHBsaWVkIHBhaXIsIGFuZCByZXR1cm5zIHRoZSByZWFkYWJsZSBzaWRlIGZvciBmdXJ0aGVyIHVzZS5cbiAgICpcbiAgICogUGlwaW5nIGEgc3RyZWFtIHdpbGwgbG9jayBpdCBmb3IgdGhlIGR1cmF0aW9uIG9mIHRoZSBwaXBlLCBwcmV2ZW50aW5nIGFueSBvdGhlciBjb25zdW1lciBmcm9tIGFjcXVpcmluZyBhIHJlYWRlci5cbiAgICovXG4gIHBpcGVUaHJvdWdoPFJTIGV4dGVuZHMgUmVhZGFibGVTdHJlYW0+KFxuICAgIHRyYW5zZm9ybTogeyByZWFkYWJsZTogUlM7IHdyaXRhYmxlOiBXcml0YWJsZVN0cmVhbTxSPiB9LFxuICAgIG9wdGlvbnM/OiBTdHJlYW1QaXBlT3B0aW9uc1xuICApOiBSUztcbiAgcGlwZVRocm91Z2g8UlMgZXh0ZW5kcyBSZWFkYWJsZVN0cmVhbT4oXG4gICAgcmF3VHJhbnNmb3JtOiB7IHJlYWRhYmxlOiBSUzsgd3JpdGFibGU6IFdyaXRhYmxlU3RyZWFtPFI+IH0gfCBudWxsIHwgdW5kZWZpbmVkLFxuICAgIHJhd09wdGlvbnM6IFN0cmVhbVBpcGVPcHRpb25zIHwgbnVsbCB8IHVuZGVmaW5lZCA9IHt9XG4gICk6IFJTIHtcbiAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW0odGhpcykpIHtcbiAgICAgIHRocm93IHN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24oJ3BpcGVUaHJvdWdoJyk7XG4gICAgfVxuICAgIGFzc2VydFJlcXVpcmVkQXJndW1lbnQocmF3VHJhbnNmb3JtLCAxLCAncGlwZVRocm91Z2gnKTtcblxuICAgIGNvbnN0IHRyYW5zZm9ybSA9IGNvbnZlcnRSZWFkYWJsZVdyaXRhYmxlUGFpcihyYXdUcmFuc2Zvcm0sICdGaXJzdCBwYXJhbWV0ZXInKTtcbiAgICBjb25zdCBvcHRpb25zID0gY29udmVydFBpcGVPcHRpb25zKHJhd09wdGlvbnMsICdTZWNvbmQgcGFyYW1ldGVyJyk7XG5cbiAgICBpZiAoSXNSZWFkYWJsZVN0cmVhbUxvY2tlZCh0aGlzKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUmVhZGFibGVTdHJlYW0ucHJvdG90eXBlLnBpcGVUaHJvdWdoIGNhbm5vdCBiZSB1c2VkIG9uIGEgbG9ja2VkIFJlYWRhYmxlU3RyZWFtJyk7XG4gICAgfVxuICAgIGlmIChJc1dyaXRhYmxlU3RyZWFtTG9ja2VkKHRyYW5zZm9ybS53cml0YWJsZSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1JlYWRhYmxlU3RyZWFtLnByb3RvdHlwZS5waXBlVGhyb3VnaCBjYW5ub3QgYmUgdXNlZCBvbiBhIGxvY2tlZCBXcml0YWJsZVN0cmVhbScpO1xuICAgIH1cblxuICAgIGNvbnN0IHByb21pc2UgPSBSZWFkYWJsZVN0cmVhbVBpcGVUbyhcbiAgICAgIHRoaXMsIHRyYW5zZm9ybS53cml0YWJsZSwgb3B0aW9ucy5wcmV2ZW50Q2xvc2UsIG9wdGlvbnMucHJldmVudEFib3J0LCBvcHRpb25zLnByZXZlbnRDYW5jZWwsIG9wdGlvbnMuc2lnbmFsXG4gICAgKTtcblxuICAgIHNldFByb21pc2VJc0hhbmRsZWRUb1RydWUocHJvbWlzZSk7XG5cbiAgICByZXR1cm4gdHJhbnNmb3JtLnJlYWRhYmxlO1xuICB9XG5cbiAgLyoqXG4gICAqIFBpcGVzIHRoaXMgcmVhZGFibGUgc3RyZWFtIHRvIGEgZ2l2ZW4gd3JpdGFibGUgc3RyZWFtLiBUaGUgd2F5IGluIHdoaWNoIHRoZSBwaXBpbmcgcHJvY2VzcyBiZWhhdmVzIHVuZGVyXG4gICAqIHZhcmlvdXMgZXJyb3IgY29uZGl0aW9ucyBjYW4gYmUgY3VzdG9taXplZCB3aXRoIGEgbnVtYmVyIG9mIHBhc3NlZCBvcHRpb25zLiBJdCByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IGZ1bGZpbGxzXG4gICAqIHdoZW4gdGhlIHBpcGluZyBwcm9jZXNzIGNvbXBsZXRlcyBzdWNjZXNzZnVsbHksIG9yIHJlamVjdHMgaWYgYW55IGVycm9ycyB3ZXJlIGVuY291bnRlcmVkLlxuICAgKlxuICAgKiBQaXBpbmcgYSBzdHJlYW0gd2lsbCBsb2NrIGl0IGZvciB0aGUgZHVyYXRpb24gb2YgdGhlIHBpcGUsIHByZXZlbnRpbmcgYW55IG90aGVyIGNvbnN1bWVyIGZyb20gYWNxdWlyaW5nIGEgcmVhZGVyLlxuICAgKi9cbiAgcGlwZVRvKGRlc3RpbmF0aW9uOiBXcml0YWJsZVN0cmVhbTxSPiwgb3B0aW9ucz86IFN0cmVhbVBpcGVPcHRpb25zKTogUHJvbWlzZTx2b2lkPjtcbiAgcGlwZVRvKGRlc3RpbmF0aW9uOiBXcml0YWJsZVN0cmVhbTxSPiB8IG51bGwgfCB1bmRlZmluZWQsXG4gICAgICAgICByYXdPcHRpb25zOiBTdHJlYW1QaXBlT3B0aW9ucyB8IG51bGwgfCB1bmRlZmluZWQgPSB7fSk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbSh0aGlzKSkge1xuICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoc3RyZWFtQnJhbmRDaGVja0V4Y2VwdGlvbigncGlwZVRvJykpO1xuICAgIH1cblxuICAgIGlmIChkZXN0aW5hdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChgUGFyYW1ldGVyIDEgaXMgcmVxdWlyZWQgaW4gJ3BpcGVUbycuYCk7XG4gICAgfVxuICAgIGlmICghSXNXcml0YWJsZVN0cmVhbShkZXN0aW5hdGlvbikpIHtcbiAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKFxuICAgICAgICBuZXcgVHlwZUVycm9yKGBSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGUucGlwZVRvJ3MgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIFdyaXRhYmxlU3RyZWFtYClcbiAgICAgICk7XG4gICAgfVxuXG4gICAgbGV0IG9wdGlvbnM6IFZhbGlkYXRlZFN0cmVhbVBpcGVPcHRpb25zO1xuICAgIHRyeSB7XG4gICAgICBvcHRpb25zID0gY29udmVydFBpcGVPcHRpb25zKHJhd09wdGlvbnMsICdTZWNvbmQgcGFyYW1ldGVyJyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoZSk7XG4gICAgfVxuXG4gICAgaWYgKElzUmVhZGFibGVTdHJlYW1Mb2NrZWQodGhpcykpIHtcbiAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKFxuICAgICAgICBuZXcgVHlwZUVycm9yKCdSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGUucGlwZVRvIGNhbm5vdCBiZSB1c2VkIG9uIGEgbG9ja2VkIFJlYWRhYmxlU3RyZWFtJylcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChJc1dyaXRhYmxlU3RyZWFtTG9ja2VkKGRlc3RpbmF0aW9uKSkge1xuICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoXG4gICAgICAgIG5ldyBUeXBlRXJyb3IoJ1JlYWRhYmxlU3RyZWFtLnByb3RvdHlwZS5waXBlVG8gY2Fubm90IGJlIHVzZWQgb24gYSBsb2NrZWQgV3JpdGFibGVTdHJlYW0nKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gUmVhZGFibGVTdHJlYW1QaXBlVG88Uj4oXG4gICAgICB0aGlzLCBkZXN0aW5hdGlvbiwgb3B0aW9ucy5wcmV2ZW50Q2xvc2UsIG9wdGlvbnMucHJldmVudEFib3J0LCBvcHRpb25zLnByZXZlbnRDYW5jZWwsIG9wdGlvbnMuc2lnbmFsXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUZWVzIHRoaXMgcmVhZGFibGUgc3RyZWFtLCByZXR1cm5pbmcgYSB0d28tZWxlbWVudCBhcnJheSBjb250YWluaW5nIHRoZSB0d28gcmVzdWx0aW5nIGJyYW5jaGVzIGFzXG4gICAqIG5ldyB7QGxpbmsgUmVhZGFibGVTdHJlYW19IGluc3RhbmNlcy5cbiAgICpcbiAgICogVGVlaW5nIGEgc3RyZWFtIHdpbGwgbG9jayBpdCwgcHJldmVudGluZyBhbnkgb3RoZXIgY29uc3VtZXIgZnJvbSBhY3F1aXJpbmcgYSByZWFkZXIuXG4gICAqIFRvIGNhbmNlbCB0aGUgc3RyZWFtLCBjYW5jZWwgYm90aCBvZiB0aGUgcmVzdWx0aW5nIGJyYW5jaGVzOyBhIGNvbXBvc2l0ZSBjYW5jZWxsYXRpb24gcmVhc29uIHdpbGwgdGhlbiBiZVxuICAgKiBwcm9wYWdhdGVkIHRvIHRoZSBzdHJlYW0ncyB1bmRlcmx5aW5nIHNvdXJjZS5cbiAgICpcbiAgICogTm90ZSB0aGF0IHRoZSBjaHVua3Mgc2VlbiBpbiBlYWNoIGJyYW5jaCB3aWxsIGJlIHRoZSBzYW1lIG9iamVjdC4gSWYgdGhlIGNodW5rcyBhcmUgbm90IGltbXV0YWJsZSxcbiAgICogdGhpcyBjb3VsZCBhbGxvdyBpbnRlcmZlcmVuY2UgYmV0d2VlbiB0aGUgdHdvIGJyYW5jaGVzLlxuICAgKi9cbiAgdGVlKCk6IFtSZWFkYWJsZVN0cmVhbTxSPiwgUmVhZGFibGVTdHJlYW08Uj5dIHtcbiAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW0odGhpcykpIHtcbiAgICAgIHRocm93IHN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24oJ3RlZScpO1xuICAgIH1cblxuICAgIGNvbnN0IGJyYW5jaGVzID0gUmVhZGFibGVTdHJlYW1UZWUodGhpcywgZmFsc2UpO1xuICAgIHJldHVybiBDcmVhdGVBcnJheUZyb21MaXN0KGJyYW5jaGVzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBc3luY2hyb25vdXNseSBpdGVyYXRlcyBvdmVyIHRoZSBjaHVua3MgaW4gdGhlIHN0cmVhbSdzIGludGVybmFsIHF1ZXVlLlxuICAgKlxuICAgKiBBc3luY2hyb25vdXNseSBpdGVyYXRpbmcgb3ZlciB0aGUgc3RyZWFtIHdpbGwgbG9jayBpdCwgcHJldmVudGluZyBhbnkgb3RoZXIgY29uc3VtZXIgZnJvbSBhY3F1aXJpbmcgYSByZWFkZXIuXG4gICAqIFRoZSBsb2NrIHdpbGwgYmUgcmVsZWFzZWQgaWYgdGhlIGFzeW5jIGl0ZXJhdG9yJ3Mge0BsaW5rIFJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvci5yZXR1cm4gfCByZXR1cm4oKX0gbWV0aG9kXG4gICAqIGlzIGNhbGxlZCwgZS5nLiBieSBicmVha2luZyBvdXQgb2YgdGhlIGxvb3AuXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIGNhbGxpbmcgdGhlIGFzeW5jIGl0ZXJhdG9yJ3Mge0BsaW5rIFJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvci5yZXR1cm4gfCByZXR1cm4oKX0gbWV0aG9kIHdpbGwgYWxzb1xuICAgKiBjYW5jZWwgdGhlIHN0cmVhbS4gVG8gcHJldmVudCB0aGlzLCB1c2UgdGhlIHN0cmVhbSdzIHtAbGluayBSZWFkYWJsZVN0cmVhbS52YWx1ZXMgfCB2YWx1ZXMoKX0gbWV0aG9kLCBwYXNzaW5nXG4gICAqIGB0cnVlYCBmb3IgdGhlIGBwcmV2ZW50Q2FuY2VsYCBvcHRpb24uXG4gICAqL1xuICB2YWx1ZXMob3B0aW9ucz86IFJlYWRhYmxlU3RyZWFtSXRlcmF0b3JPcHRpb25zKTogUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yPFI+O1xuICB2YWx1ZXMocmF3T3B0aW9uczogUmVhZGFibGVTdHJlYW1JdGVyYXRvck9wdGlvbnMgfCBudWxsIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkKTogUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yPFI+IHtcbiAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW0odGhpcykpIHtcbiAgICAgIHRocm93IHN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24oJ3ZhbHVlcycpO1xuICAgIH1cblxuICAgIGNvbnN0IG9wdGlvbnMgPSBjb252ZXJ0SXRlcmF0b3JPcHRpb25zKHJhd09wdGlvbnMsICdGaXJzdCBwYXJhbWV0ZXInKTtcbiAgICByZXR1cm4gQWNxdWlyZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvcjxSPih0aGlzLCBvcHRpb25zLnByZXZlbnRDYW5jZWwpO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAaW5oZXJpdERvYyBSZWFkYWJsZVN0cmVhbS52YWx1ZXN9XG4gICAqL1xuICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdOiAob3B0aW9ucz86IFJlYWRhYmxlU3RyZWFtSXRlcmF0b3JPcHRpb25zKSA9PiBSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3I8Uj47XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFJlYWRhYmxlU3RyZWFtLnByb3RvdHlwZSwge1xuICBjYW5jZWw6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICBnZXRSZWFkZXI6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICBwaXBlVGhyb3VnaDogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gIHBpcGVUbzogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gIHRlZTogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gIHZhbHVlczogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gIGxvY2tlZDogeyBlbnVtZXJhYmxlOiB0cnVlIH1cbn0pO1xuaWYgKHR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWcgPT09ICdzeW1ib2wnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGUsIFN5bWJvbC50b1N0cmluZ1RhZywge1xuICAgIHZhbHVlOiAnUmVhZGFibGVTdHJlYW0nLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cbmlmICh0eXBlb2YgU3ltYm9sLmFzeW5jSXRlcmF0b3IgPT09ICdzeW1ib2wnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGUsIFN5bWJvbC5hc3luY0l0ZXJhdG9yLCB7XG4gICAgdmFsdWU6IFJlYWRhYmxlU3RyZWFtLnByb3RvdHlwZS52YWx1ZXMsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG5leHBvcnQge1xuICBSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IsXG4gIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRSZXN1bHQsXG4gIFJlYWRhYmxlU3RyZWFtQllPQlJlYWRSZXN1bHQsXG4gIFVuZGVybHlpbmdCeXRlU291cmNlLFxuICBVbmRlcmx5aW5nU291cmNlLFxuICBVbmRlcmx5aW5nU291cmNlU3RhcnRDYWxsYmFjayxcbiAgVW5kZXJseWluZ1NvdXJjZVB1bGxDYWxsYmFjayxcbiAgVW5kZXJseWluZ1NvdXJjZUNhbmNlbENhbGxiYWNrLFxuICBVbmRlcmx5aW5nQnl0ZVNvdXJjZVN0YXJ0Q2FsbGJhY2ssXG4gIFVuZGVybHlpbmdCeXRlU291cmNlUHVsbENhbGxiYWNrLFxuICBTdHJlYW1QaXBlT3B0aW9ucyxcbiAgUmVhZGFibGVXcml0YWJsZVBhaXIsXG4gIFJlYWRhYmxlU3RyZWFtSXRlcmF0b3JPcHRpb25zXG59O1xuXG4vLyBBYnN0cmFjdCBvcGVyYXRpb25zIGZvciB0aGUgUmVhZGFibGVTdHJlYW0uXG5cbi8vIFRocm93cyBpZiBhbmQgb25seSBpZiBzdGFydEFsZ29yaXRobSB0aHJvd3MuXG5leHBvcnQgZnVuY3Rpb24gQ3JlYXRlUmVhZGFibGVTdHJlYW08Uj4oc3RhcnRBbGdvcml0aG06ICgpID0+IHZvaWQgfCBQcm9taXNlTGlrZTx2b2lkPixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdWxsQWxnb3JpdGhtOiAoKSA9PiBQcm9taXNlPHZvaWQ+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbmNlbEFsZ29yaXRobTogKHJlYXNvbjogYW55KSA9PiBQcm9taXNlPHZvaWQ+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpZ2hXYXRlck1hcmsgPSAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpemVBbGdvcml0aG06IFF1ZXVpbmdTdHJhdGVneVNpemVDYWxsYmFjazxSPiA9ICgpID0+IDEpOiBSZWFkYWJsZVN0cmVhbTxSPiB7XG4gIGFzc2VydChJc05vbk5lZ2F0aXZlTnVtYmVyKGhpZ2hXYXRlck1hcmspKTtcblxuICBjb25zdCBzdHJlYW06IFJlYWRhYmxlU3RyZWFtPFI+ID0gT2JqZWN0LmNyZWF0ZShSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGUpO1xuICBJbml0aWFsaXplUmVhZGFibGVTdHJlYW0oc3RyZWFtKTtcblxuICBjb25zdCBjb250cm9sbGVyOiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyPFI+ID0gT2JqZWN0LmNyZWF0ZShSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZSk7XG4gIFNldFVwUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcihcbiAgICBzdHJlYW0sIGNvbnRyb2xsZXIsIHN0YXJ0QWxnb3JpdGhtLCBwdWxsQWxnb3JpdGhtLCBjYW5jZWxBbGdvcml0aG0sIGhpZ2hXYXRlck1hcmssIHNpemVBbGdvcml0aG1cbiAgKTtcblxuICByZXR1cm4gc3RyZWFtO1xufVxuXG4vLyBUaHJvd3MgaWYgYW5kIG9ubHkgaWYgc3RhcnRBbGdvcml0aG0gdGhyb3dzLlxuZXhwb3J0IGZ1bmN0aW9uIENyZWF0ZVJlYWRhYmxlQnl0ZVN0cmVhbShcbiAgc3RhcnRBbGdvcml0aG06ICgpID0+IHZvaWQgfCBQcm9taXNlTGlrZTx2b2lkPixcbiAgcHVsbEFsZ29yaXRobTogKCkgPT4gUHJvbWlzZTx2b2lkPixcbiAgY2FuY2VsQWxnb3JpdGhtOiAocmVhc29uOiBhbnkpID0+IFByb21pc2U8dm9pZD5cbik6IFJlYWRhYmxlQnl0ZVN0cmVhbSB7XG4gIGNvbnN0IHN0cmVhbTogUmVhZGFibGVCeXRlU3RyZWFtID0gT2JqZWN0LmNyZWF0ZShSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGUpO1xuICBJbml0aWFsaXplUmVhZGFibGVTdHJlYW0oc3RyZWFtKTtcblxuICBjb25zdCBjb250cm9sbGVyOiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyID0gT2JqZWN0LmNyZWF0ZShSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZSk7XG4gIFNldFVwUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcihzdHJlYW0sIGNvbnRyb2xsZXIsIHN0YXJ0QWxnb3JpdGhtLCBwdWxsQWxnb3JpdGhtLCBjYW5jZWxBbGdvcml0aG0sIDAsIHVuZGVmaW5lZCk7XG5cbiAgcmV0dXJuIHN0cmVhbTtcbn1cblxuZnVuY3Rpb24gSW5pdGlhbGl6ZVJlYWRhYmxlU3RyZWFtKHN0cmVhbTogUmVhZGFibGVTdHJlYW0pIHtcbiAgc3RyZWFtLl9zdGF0ZSA9ICdyZWFkYWJsZSc7XG4gIHN0cmVhbS5fcmVhZGVyID0gdW5kZWZpbmVkO1xuICBzdHJlYW0uX3N0b3JlZEVycm9yID0gdW5kZWZpbmVkO1xuICBzdHJlYW0uX2Rpc3R1cmJlZCA9IGZhbHNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gSXNSZWFkYWJsZVN0cmVhbSh4OiB1bmtub3duKTogeCBpcyBSZWFkYWJsZVN0cmVhbSB7XG4gIGlmICghdHlwZUlzT2JqZWN0KHgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ19yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXInKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB4IGluc3RhbmNlb2YgUmVhZGFibGVTdHJlYW07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBJc1JlYWRhYmxlU3RyZWFtRGlzdHVyYmVkKHN0cmVhbTogUmVhZGFibGVTdHJlYW0pOiBib29sZWFuIHtcbiAgYXNzZXJ0KElzUmVhZGFibGVTdHJlYW0oc3RyZWFtKSk7XG5cbiAgcmV0dXJuIHN0cmVhbS5fZGlzdHVyYmVkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gSXNSZWFkYWJsZVN0cmVhbUxvY2tlZChzdHJlYW06IFJlYWRhYmxlU3RyZWFtKTogYm9vbGVhbiB7XG4gIGFzc2VydChJc1JlYWRhYmxlU3RyZWFtKHN0cmVhbSkpO1xuXG4gIGlmIChzdHJlYW0uX3JlYWRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIFJlYWRhYmxlU3RyZWFtIEFQSSBleHBvc2VkIGZvciBjb250cm9sbGVycy5cblxuZXhwb3J0IGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtQ2FuY2VsPFI+KHN0cmVhbTogUmVhZGFibGVTdHJlYW08Uj4sIHJlYXNvbjogYW55KTogUHJvbWlzZTx1bmRlZmluZWQ+IHtcbiAgc3RyZWFtLl9kaXN0dXJiZWQgPSB0cnVlO1xuXG4gIGlmIChzdHJlYW0uX3N0YXRlID09PSAnY2xvc2VkJykge1xuICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG4gIH1cbiAgaWYgKHN0cmVhbS5fc3RhdGUgPT09ICdlcnJvcmVkJykge1xuICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKHN0cmVhbS5fc3RvcmVkRXJyb3IpO1xuICB9XG5cbiAgUmVhZGFibGVTdHJlYW1DbG9zZShzdHJlYW0pO1xuXG4gIGNvbnN0IHJlYWRlciA9IHN0cmVhbS5fcmVhZGVyO1xuICBpZiAocmVhZGVyICE9PSB1bmRlZmluZWQgJiYgSXNSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIocmVhZGVyKSkge1xuICAgIHJlYWRlci5fcmVhZEludG9SZXF1ZXN0cy5mb3JFYWNoKHJlYWRJbnRvUmVxdWVzdCA9PiB7XG4gICAgICByZWFkSW50b1JlcXVlc3QuX2Nsb3NlU3RlcHModW5kZWZpbmVkKTtcbiAgICB9KTtcbiAgICByZWFkZXIuX3JlYWRJbnRvUmVxdWVzdHMgPSBuZXcgU2ltcGxlUXVldWUoKTtcbiAgfVxuXG4gIGNvbnN0IHNvdXJjZUNhbmNlbFByb21pc2UgPSBzdHJlYW0uX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcltDYW5jZWxTdGVwc10ocmVhc29uKTtcbiAgcmV0dXJuIHRyYW5zZm9ybVByb21pc2VXaXRoKHNvdXJjZUNhbmNlbFByb21pc2UsIG5vb3ApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1DbG9zZTxSPihzdHJlYW06IFJlYWRhYmxlU3RyZWFtPFI+KTogdm9pZCB7XG4gIGFzc2VydChzdHJlYW0uX3N0YXRlID09PSAncmVhZGFibGUnKTtcblxuICBzdHJlYW0uX3N0YXRlID0gJ2Nsb3NlZCc7XG5cbiAgY29uc3QgcmVhZGVyID0gc3RyZWFtLl9yZWFkZXI7XG5cbiAgaWYgKHJlYWRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VSZXNvbHZlKHJlYWRlcik7XG5cbiAgaWYgKElzUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyPFI+KHJlYWRlcikpIHtcbiAgICByZWFkZXIuX3JlYWRSZXF1ZXN0cy5mb3JFYWNoKHJlYWRSZXF1ZXN0ID0+IHtcbiAgICAgIHJlYWRSZXF1ZXN0Ll9jbG9zZVN0ZXBzKCk7XG4gICAgfSk7XG4gICAgcmVhZGVyLl9yZWFkUmVxdWVzdHMgPSBuZXcgU2ltcGxlUXVldWUoKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1FcnJvcjxSPihzdHJlYW06IFJlYWRhYmxlU3RyZWFtPFI+LCBlOiBhbnkpOiB2b2lkIHtcbiAgYXNzZXJ0KElzUmVhZGFibGVTdHJlYW0oc3RyZWFtKSk7XG4gIGFzc2VydChzdHJlYW0uX3N0YXRlID09PSAncmVhZGFibGUnKTtcblxuICBzdHJlYW0uX3N0YXRlID0gJ2Vycm9yZWQnO1xuICBzdHJlYW0uX3N0b3JlZEVycm9yID0gZTtcblxuICBjb25zdCByZWFkZXIgPSBzdHJlYW0uX3JlYWRlcjtcblxuICBpZiAocmVhZGVyID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZVJlamVjdChyZWFkZXIsIGUpO1xuXG4gIGlmIChJc1JlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcjxSPihyZWFkZXIpKSB7XG4gICAgcmVhZGVyLl9yZWFkUmVxdWVzdHMuZm9yRWFjaChyZWFkUmVxdWVzdCA9PiB7XG4gICAgICByZWFkUmVxdWVzdC5fZXJyb3JTdGVwcyhlKTtcbiAgICB9KTtcblxuICAgIHJlYWRlci5fcmVhZFJlcXVlc3RzID0gbmV3IFNpbXBsZVF1ZXVlKCk7XG4gIH0gZWxzZSB7XG4gICAgYXNzZXJ0KElzUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyKHJlYWRlcikpO1xuXG4gICAgcmVhZGVyLl9yZWFkSW50b1JlcXVlc3RzLmZvckVhY2gocmVhZEludG9SZXF1ZXN0ID0+IHtcbiAgICAgIHJlYWRJbnRvUmVxdWVzdC5fZXJyb3JTdGVwcyhlKTtcbiAgICB9KTtcblxuICAgIHJlYWRlci5fcmVhZEludG9SZXF1ZXN0cyA9IG5ldyBTaW1wbGVRdWV1ZSgpO1xuICB9XG59XG5cbi8vIFJlYWRlcnNcblxuZXhwb3J0IHR5cGUgUmVhZGFibGVTdHJlYW1SZWFkZXI8Uj4gPSBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXI8Uj4gfCBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXI7XG5cbmV4cG9ydCB7XG4gIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcixcbiAgUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyXG59O1xuXG4vLyBDb250cm9sbGVyc1xuXG5leHBvcnQge1xuICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLFxuICBSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0LFxuICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyXG59O1xuXG4vLyBIZWxwZXIgZnVuY3Rpb25zIGZvciB0aGUgUmVhZGFibGVTdHJlYW0uXG5cbmZ1bmN0aW9uIHN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24obmFtZTogc3RyaW5nKTogVHlwZUVycm9yIHtcbiAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoYFJlYWRhYmxlU3RyZWFtLnByb3RvdHlwZS4ke25hbWV9IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBSZWFkYWJsZVN0cmVhbWApO1xufVxuIiwgImltcG9ydCB7IFF1ZXVpbmdTdHJhdGVneUluaXQgfSBmcm9tICcuLi9xdWV1aW5nLXN0cmF0ZWd5JztcbmltcG9ydCB7IGFzc2VydERpY3Rpb25hcnksIGFzc2VydFJlcXVpcmVkRmllbGQsIGNvbnZlcnRVbnJlc3RyaWN0ZWREb3VibGUgfSBmcm9tICcuL2Jhc2ljJztcblxuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRRdWV1aW5nU3RyYXRlZ3lJbml0KGluaXQ6IFF1ZXVpbmdTdHJhdGVneUluaXQgfCBudWxsIHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IHN0cmluZyk6IFF1ZXVpbmdTdHJhdGVneUluaXQge1xuICBhc3NlcnREaWN0aW9uYXJ5KGluaXQsIGNvbnRleHQpO1xuICBjb25zdCBoaWdoV2F0ZXJNYXJrID0gaW5pdD8uaGlnaFdhdGVyTWFyaztcbiAgYXNzZXJ0UmVxdWlyZWRGaWVsZChoaWdoV2F0ZXJNYXJrLCAnaGlnaFdhdGVyTWFyaycsICdRdWV1aW5nU3RyYXRlZ3lJbml0Jyk7XG4gIHJldHVybiB7XG4gICAgaGlnaFdhdGVyTWFyazogY29udmVydFVucmVzdHJpY3RlZERvdWJsZShoaWdoV2F0ZXJNYXJrKVxuICB9O1xufVxuIiwgImltcG9ydCB7IFF1ZXVpbmdTdHJhdGVneSwgUXVldWluZ1N0cmF0ZWd5SW5pdCB9IGZyb20gJy4vcXVldWluZy1zdHJhdGVneSc7XG5pbXBvcnQgeyB0eXBlSXNPYmplY3QgfSBmcm9tICcuL2hlbHBlcnMvbWlzY2VsbGFuZW91cyc7XG5pbXBvcnQgeyBhc3NlcnRSZXF1aXJlZEFyZ3VtZW50IH0gZnJvbSAnLi92YWxpZGF0b3JzL2Jhc2ljJztcbmltcG9ydCB7IGNvbnZlcnRRdWV1aW5nU3RyYXRlZ3lJbml0IH0gZnJvbSAnLi92YWxpZGF0b3JzL3F1ZXVpbmctc3RyYXRlZ3ktaW5pdCc7XG5cbi8vIFRoZSBzaXplIGZ1bmN0aW9uIG11c3Qgbm90IGhhdmUgYSBwcm90b3R5cGUgcHJvcGVydHkgbm9yIGJlIGEgY29uc3RydWN0b3JcbmNvbnN0IGJ5dGVMZW5ndGhTaXplRnVuY3Rpb24gPSAoY2h1bms6IEFycmF5QnVmZmVyVmlldyk6IG51bWJlciA9PiB7XG4gIHJldHVybiBjaHVuay5ieXRlTGVuZ3RoO1xufTtcbnRyeSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShieXRlTGVuZ3RoU2l6ZUZ1bmN0aW9uLCAnbmFtZScsIHtcbiAgICB2YWx1ZTogJ3NpemUnLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn0gY2F0Y2gge1xuICAvLyBUaGlzIHByb3BlcnR5IGlzIG5vbi1jb25maWd1cmFibGUgaW4gb2xkZXIgYnJvd3NlcnMsIHNvIGlnbm9yZSBpZiB0aGlzIHRocm93cy5cbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRnVuY3Rpb24vbmFtZSNicm93c2VyX2NvbXBhdGliaWxpdHlcbn1cblxuLyoqXG4gKiBBIHF1ZXVpbmcgc3RyYXRlZ3kgdGhhdCBjb3VudHMgdGhlIG51bWJlciBvZiBieXRlcyBpbiBlYWNoIGNodW5rLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneSBpbXBsZW1lbnRzIFF1ZXVpbmdTdHJhdGVneTxBcnJheUJ1ZmZlclZpZXc+IHtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICByZWFkb25seSBfYnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneUhpZ2hXYXRlck1hcms6IG51bWJlcjtcblxuICBjb25zdHJ1Y3RvcihvcHRpb25zOiBRdWV1aW5nU3RyYXRlZ3lJbml0KSB7XG4gICAgYXNzZXJ0UmVxdWlyZWRBcmd1bWVudChvcHRpb25zLCAxLCAnQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneScpO1xuICAgIG9wdGlvbnMgPSBjb252ZXJ0UXVldWluZ1N0cmF0ZWd5SW5pdChvcHRpb25zLCAnRmlyc3QgcGFyYW1ldGVyJyk7XG4gICAgdGhpcy5fYnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneUhpZ2hXYXRlck1hcmsgPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaGlnaCB3YXRlciBtYXJrIHByb3ZpZGVkIHRvIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICovXG4gIGdldCBoaWdoV2F0ZXJNYXJrKCk6IG51bWJlciB7XG4gICAgaWYgKCFJc0J5dGVMZW5ndGhRdWV1aW5nU3RyYXRlZ3kodGhpcykpIHtcbiAgICAgIHRocm93IGJ5dGVMZW5ndGhCcmFuZENoZWNrRXhjZXB0aW9uKCdoaWdoV2F0ZXJNYXJrJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9ieXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5SGlnaFdhdGVyTWFyaztcbiAgfVxuXG4gIC8qKlxuICAgKiBNZWFzdXJlcyB0aGUgc2l6ZSBvZiBgY2h1bmtgIGJ5IHJldHVybmluZyB0aGUgdmFsdWUgb2YgaXRzIGBieXRlTGVuZ3RoYCBwcm9wZXJ0eS5cbiAgICovXG4gIGdldCBzaXplKCk6IChjaHVuazogQXJyYXlCdWZmZXJWaWV3KSA9PiBudW1iZXIge1xuICAgIGlmICghSXNCeXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5KHRoaXMpKSB7XG4gICAgICB0aHJvdyBieXRlTGVuZ3RoQnJhbmRDaGVja0V4Y2VwdGlvbignc2l6ZScpO1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZUxlbmd0aFNpemVGdW5jdGlvbjtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhCeXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5LnByb3RvdHlwZSwge1xuICBoaWdoV2F0ZXJNYXJrOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgc2l6ZTogeyBlbnVtZXJhYmxlOiB0cnVlIH1cbn0pO1xuaWYgKHR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWcgPT09ICdzeW1ib2wnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCeXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5LnByb3RvdHlwZSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7XG4gICAgdmFsdWU6ICdCeXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5JyxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbi8vIEhlbHBlciBmdW5jdGlvbnMgZm9yIHRoZSBCeXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5LlxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoQnJhbmRDaGVja0V4Y2VwdGlvbihuYW1lOiBzdHJpbmcpOiBUeXBlRXJyb3Ige1xuICByZXR1cm4gbmV3IFR5cGVFcnJvcihgQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneS5wcm90b3R5cGUuJHtuYW1lfSBjYW4gb25seSBiZSB1c2VkIG9uIGEgQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneWApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gSXNCeXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5KHg6IGFueSk6IHggaXMgQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneSB7XG4gIGlmICghdHlwZUlzT2JqZWN0KHgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ19ieXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5SGlnaFdhdGVyTWFyaycpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHggaW5zdGFuY2VvZiBCeXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5O1xufVxuIiwgImltcG9ydCB7IFF1ZXVpbmdTdHJhdGVneSwgUXVldWluZ1N0cmF0ZWd5SW5pdCB9IGZyb20gJy4vcXVldWluZy1zdHJhdGVneSc7XG5pbXBvcnQgeyB0eXBlSXNPYmplY3QgfSBmcm9tICcuL2hlbHBlcnMvbWlzY2VsbGFuZW91cyc7XG5pbXBvcnQgeyBhc3NlcnRSZXF1aXJlZEFyZ3VtZW50IH0gZnJvbSAnLi92YWxpZGF0b3JzL2Jhc2ljJztcbmltcG9ydCB7IGNvbnZlcnRRdWV1aW5nU3RyYXRlZ3lJbml0IH0gZnJvbSAnLi92YWxpZGF0b3JzL3F1ZXVpbmctc3RyYXRlZ3ktaW5pdCc7XG5cbi8vIFRoZSBzaXplIGZ1bmN0aW9uIG11c3Qgbm90IGhhdmUgYSBwcm90b3R5cGUgcHJvcGVydHkgbm9yIGJlIGEgY29uc3RydWN0b3JcbmNvbnN0IGNvdW50U2l6ZUZ1bmN0aW9uID0gKCk6IDEgPT4ge1xuICByZXR1cm4gMTtcbn07XG50cnkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY291bnRTaXplRnVuY3Rpb24sICduYW1lJywge1xuICAgIHZhbHVlOiAnc2l6ZScsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufSBjYXRjaCB7XG4gIC8vIFRoaXMgcHJvcGVydHkgaXMgbm9uLWNvbmZpZ3VyYWJsZSBpbiBvbGRlciBicm93c2Vycywgc28gaWdub3JlIGlmIHRoaXMgdGhyb3dzLlxuICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9GdW5jdGlvbi9uYW1lI2Jyb3dzZXJfY29tcGF0aWJpbGl0eVxufVxuXG4vKipcbiAqIEEgcXVldWluZyBzdHJhdGVneSB0aGF0IGNvdW50cyB0aGUgbnVtYmVyIG9mIGNodW5rcy5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvdW50UXVldWluZ1N0cmF0ZWd5IGltcGxlbWVudHMgUXVldWluZ1N0cmF0ZWd5PGFueT4ge1xuICAvKiogQGludGVybmFsICovXG4gIHJlYWRvbmx5IF9jb3VudFF1ZXVpbmdTdHJhdGVneUhpZ2hXYXRlck1hcmshOiBudW1iZXI7XG5cbiAgY29uc3RydWN0b3Iob3B0aW9uczogUXVldWluZ1N0cmF0ZWd5SW5pdCkge1xuICAgIGFzc2VydFJlcXVpcmVkQXJndW1lbnQob3B0aW9ucywgMSwgJ0NvdW50UXVldWluZ1N0cmF0ZWd5Jyk7XG4gICAgb3B0aW9ucyA9IGNvbnZlcnRRdWV1aW5nU3RyYXRlZ3lJbml0KG9wdGlvbnMsICdGaXJzdCBwYXJhbWV0ZXInKTtcbiAgICB0aGlzLl9jb3VudFF1ZXVpbmdTdHJhdGVneUhpZ2hXYXRlck1hcmsgPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaGlnaCB3YXRlciBtYXJrIHByb3ZpZGVkIHRvIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICovXG4gIGdldCBoaWdoV2F0ZXJNYXJrKCk6IG51bWJlciB7XG4gICAgaWYgKCFJc0NvdW50UXVldWluZ1N0cmF0ZWd5KHRoaXMpKSB7XG4gICAgICB0aHJvdyBjb3VudEJyYW5kQ2hlY2tFeGNlcHRpb24oJ2hpZ2hXYXRlck1hcmsnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2NvdW50UXVldWluZ1N0cmF0ZWd5SGlnaFdhdGVyTWFyaztcbiAgfVxuXG4gIC8qKlxuICAgKiBNZWFzdXJlcyB0aGUgc2l6ZSBvZiBgY2h1bmtgIGJ5IGFsd2F5cyByZXR1cm5pbmcgMS5cbiAgICogVGhpcyBlbnN1cmVzIHRoYXQgdGhlIHRvdGFsIHF1ZXVlIHNpemUgaXMgYSBjb3VudCBvZiB0aGUgbnVtYmVyIG9mIGNodW5rcyBpbiB0aGUgcXVldWUuXG4gICAqL1xuICBnZXQgc2l6ZSgpOiAoY2h1bms6IGFueSkgPT4gMSB7XG4gICAgaWYgKCFJc0NvdW50UXVldWluZ1N0cmF0ZWd5KHRoaXMpKSB7XG4gICAgICB0aHJvdyBjb3VudEJyYW5kQ2hlY2tFeGNlcHRpb24oJ3NpemUnKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvdW50U2l6ZUZ1bmN0aW9uO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKENvdW50UXVldWluZ1N0cmF0ZWd5LnByb3RvdHlwZSwge1xuICBoaWdoV2F0ZXJNYXJrOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgc2l6ZTogeyBlbnVtZXJhYmxlOiB0cnVlIH1cbn0pO1xuaWYgKHR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWcgPT09ICdzeW1ib2wnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb3VudFF1ZXVpbmdTdHJhdGVneS5wcm90b3R5cGUsIFN5bWJvbC50b1N0cmluZ1RhZywge1xuICAgIHZhbHVlOiAnQ291bnRRdWV1aW5nU3RyYXRlZ3knLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuLy8gSGVscGVyIGZ1bmN0aW9ucyBmb3IgdGhlIENvdW50UXVldWluZ1N0cmF0ZWd5LlxuXG5mdW5jdGlvbiBjb3VudEJyYW5kQ2hlY2tFeGNlcHRpb24obmFtZTogc3RyaW5nKTogVHlwZUVycm9yIHtcbiAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoYENvdW50UXVldWluZ1N0cmF0ZWd5LnByb3RvdHlwZS4ke25hbWV9IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBDb3VudFF1ZXVpbmdTdHJhdGVneWApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gSXNDb3VudFF1ZXVpbmdTdHJhdGVneSh4OiBhbnkpOiB4IGlzIENvdW50UXVldWluZ1N0cmF0ZWd5IHtcbiAgaWYgKCF0eXBlSXNPYmplY3QoeCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnX2NvdW50UXVldWluZ1N0cmF0ZWd5SGlnaFdhdGVyTWFyaycpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHggaW5zdGFuY2VvZiBDb3VudFF1ZXVpbmdTdHJhdGVneTtcbn1cbiIsICJpbXBvcnQgeyBhc3NlcnREaWN0aW9uYXJ5LCBhc3NlcnRGdW5jdGlvbiB9IGZyb20gJy4vYmFzaWMnO1xuaW1wb3J0IHsgcHJvbWlzZUNhbGwsIHJlZmxlY3RDYWxsIH0gZnJvbSAnLi4vaGVscGVycy93ZWJpZGwnO1xuaW1wb3J0IHtcbiAgVHJhbnNmb3JtZXIsXG4gIFRyYW5zZm9ybWVyRmx1c2hDYWxsYmFjayxcbiAgVHJhbnNmb3JtZXJTdGFydENhbGxiYWNrLFxuICBUcmFuc2Zvcm1lclRyYW5zZm9ybUNhbGxiYWNrLFxuICBWYWxpZGF0ZWRUcmFuc2Zvcm1lclxufSBmcm9tICcuLi90cmFuc2Zvcm0tc3RyZWFtL3RyYW5zZm9ybWVyJztcbmltcG9ydCB7IFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyIH0gZnJvbSAnLi4vdHJhbnNmb3JtLXN0cmVhbSc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0VHJhbnNmb3JtZXI8SSwgTz4ob3JpZ2luYWw6IFRyYW5zZm9ybWVyPEksIE8+IHwgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dDogc3RyaW5nKTogVmFsaWRhdGVkVHJhbnNmb3JtZXI8SSwgTz4ge1xuICBhc3NlcnREaWN0aW9uYXJ5KG9yaWdpbmFsLCBjb250ZXh0KTtcbiAgY29uc3QgZmx1c2ggPSBvcmlnaW5hbD8uZmx1c2g7XG4gIGNvbnN0IHJlYWRhYmxlVHlwZSA9IG9yaWdpbmFsPy5yZWFkYWJsZVR5cGU7XG4gIGNvbnN0IHN0YXJ0ID0gb3JpZ2luYWw/LnN0YXJ0O1xuICBjb25zdCB0cmFuc2Zvcm0gPSBvcmlnaW5hbD8udHJhbnNmb3JtO1xuICBjb25zdCB3cml0YWJsZVR5cGUgPSBvcmlnaW5hbD8ud3JpdGFibGVUeXBlO1xuICByZXR1cm4ge1xuICAgIGZsdXNoOiBmbHVzaCA9PT0gdW5kZWZpbmVkID9cbiAgICAgIHVuZGVmaW5lZCA6XG4gICAgICBjb252ZXJ0VHJhbnNmb3JtZXJGbHVzaENhbGxiYWNrKGZsdXNoLCBvcmlnaW5hbCEsIGAke2NvbnRleHR9IGhhcyBtZW1iZXIgJ2ZsdXNoJyB0aGF0YCksXG4gICAgcmVhZGFibGVUeXBlLFxuICAgIHN0YXJ0OiBzdGFydCA9PT0gdW5kZWZpbmVkID9cbiAgICAgIHVuZGVmaW5lZCA6XG4gICAgICBjb252ZXJ0VHJhbnNmb3JtZXJTdGFydENhbGxiYWNrKHN0YXJ0LCBvcmlnaW5hbCEsIGAke2NvbnRleHR9IGhhcyBtZW1iZXIgJ3N0YXJ0JyB0aGF0YCksXG4gICAgdHJhbnNmb3JtOiB0cmFuc2Zvcm0gPT09IHVuZGVmaW5lZCA/XG4gICAgICB1bmRlZmluZWQgOlxuICAgICAgY29udmVydFRyYW5zZm9ybWVyVHJhbnNmb3JtQ2FsbGJhY2sodHJhbnNmb3JtLCBvcmlnaW5hbCEsIGAke2NvbnRleHR9IGhhcyBtZW1iZXIgJ3RyYW5zZm9ybScgdGhhdGApLFxuICAgIHdyaXRhYmxlVHlwZVxuICB9O1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0VHJhbnNmb3JtZXJGbHVzaENhbGxiYWNrPEksIE8+KFxuICBmbjogVHJhbnNmb3JtZXJGbHVzaENhbGxiYWNrPE8+LFxuICBvcmlnaW5hbDogVHJhbnNmb3JtZXI8SSwgTz4sXG4gIGNvbnRleHQ6IHN0cmluZ1xuKTogKGNvbnRyb2xsZXI6IFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyPE8+KSA9PiBQcm9taXNlPHZvaWQ+IHtcbiAgYXNzZXJ0RnVuY3Rpb24oZm4sIGNvbnRleHQpO1xuICByZXR1cm4gKGNvbnRyb2xsZXI6IFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyPE8+KSA9PiBwcm9taXNlQ2FsbChmbiwgb3JpZ2luYWwsIFtjb250cm9sbGVyXSk7XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRUcmFuc2Zvcm1lclN0YXJ0Q2FsbGJhY2s8SSwgTz4oXG4gIGZuOiBUcmFuc2Zvcm1lclN0YXJ0Q2FsbGJhY2s8Tz4sXG4gIG9yaWdpbmFsOiBUcmFuc2Zvcm1lcjxJLCBPPixcbiAgY29udGV4dDogc3RyaW5nXG4pOiBUcmFuc2Zvcm1lclN0YXJ0Q2FsbGJhY2s8Tz4ge1xuICBhc3NlcnRGdW5jdGlvbihmbiwgY29udGV4dCk7XG4gIHJldHVybiAoY29udHJvbGxlcjogVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8Tz4pID0+IHJlZmxlY3RDYWxsKGZuLCBvcmlnaW5hbCwgW2NvbnRyb2xsZXJdKTtcbn1cblxuZnVuY3Rpb24gY29udmVydFRyYW5zZm9ybWVyVHJhbnNmb3JtQ2FsbGJhY2s8SSwgTz4oXG4gIGZuOiBUcmFuc2Zvcm1lclRyYW5zZm9ybUNhbGxiYWNrPEksIE8+LFxuICBvcmlnaW5hbDogVHJhbnNmb3JtZXI8SSwgTz4sXG4gIGNvbnRleHQ6IHN0cmluZ1xuKTogKGNodW5rOiBJLCBjb250cm9sbGVyOiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxPPikgPT4gUHJvbWlzZTx2b2lkPiB7XG4gIGFzc2VydEZ1bmN0aW9uKGZuLCBjb250ZXh0KTtcbiAgcmV0dXJuIChjaHVuazogSSwgY29udHJvbGxlcjogVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8Tz4pID0+IHByb21pc2VDYWxsKGZuLCBvcmlnaW5hbCwgW2NodW5rLCBjb250cm9sbGVyXSk7XG59XG4iLCAiaW1wb3J0IGFzc2VydCBmcm9tICcuLi9zdHViL2Fzc2VydCc7XG5pbXBvcnQgeyBuZXdQcm9taXNlLCBwcm9taXNlUmVqZWN0ZWRXaXRoLCBwcm9taXNlUmVzb2x2ZWRXaXRoLCB0cmFuc2Zvcm1Qcm9taXNlV2l0aCB9IGZyb20gJy4vaGVscGVycy93ZWJpZGwnO1xuaW1wb3J0IHsgQ3JlYXRlUmVhZGFibGVTdHJlYW0sIFJlYWRhYmxlU3RyZWFtLCBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyIH0gZnJvbSAnLi9yZWFkYWJsZS1zdHJlYW0nO1xuaW1wb3J0IHtcbiAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNhbkNsb3NlT3JFbnF1ZXVlLFxuICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xvc2UsXG4gIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFbnF1ZXVlLFxuICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3IsXG4gIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJHZXREZXNpcmVkU2l6ZSxcbiAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckhhc0JhY2twcmVzc3VyZVxufSBmcm9tICcuL3JlYWRhYmxlLXN0cmVhbS9kZWZhdWx0LWNvbnRyb2xsZXInO1xuaW1wb3J0IHsgUXVldWluZ1N0cmF0ZWd5LCBRdWV1aW5nU3RyYXRlZ3lTaXplQ2FsbGJhY2sgfSBmcm9tICcuL3F1ZXVpbmctc3RyYXRlZ3knO1xuaW1wb3J0IHsgQ3JlYXRlV3JpdGFibGVTdHJlYW0sIFdyaXRhYmxlU3RyZWFtLCBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3JJZk5lZWRlZCB9IGZyb20gJy4vd3JpdGFibGUtc3RyZWFtJztcbmltcG9ydCB7IHR5cGVJc09iamVjdCB9IGZyb20gJy4vaGVscGVycy9taXNjZWxsYW5lb3VzJztcbmltcG9ydCB7IElzTm9uTmVnYXRpdmVOdW1iZXIgfSBmcm9tICcuL2Fic3RyYWN0LW9wcy9taXNjZWxsYW5lb3VzJztcbmltcG9ydCB7IGNvbnZlcnRRdWV1aW5nU3RyYXRlZ3kgfSBmcm9tICcuL3ZhbGlkYXRvcnMvcXVldWluZy1zdHJhdGVneSc7XG5pbXBvcnQgeyBFeHRyYWN0SGlnaFdhdGVyTWFyaywgRXh0cmFjdFNpemVBbGdvcml0aG0gfSBmcm9tICcuL2Fic3RyYWN0LW9wcy9xdWV1aW5nLXN0cmF0ZWd5JztcbmltcG9ydCB7XG4gIFRyYW5zZm9ybWVyLFxuICBUcmFuc2Zvcm1lckZsdXNoQ2FsbGJhY2ssXG4gIFRyYW5zZm9ybWVyU3RhcnRDYWxsYmFjayxcbiAgVHJhbnNmb3JtZXJUcmFuc2Zvcm1DYWxsYmFjayxcbiAgVmFsaWRhdGVkVHJhbnNmb3JtZXJcbn0gZnJvbSAnLi90cmFuc2Zvcm0tc3RyZWFtL3RyYW5zZm9ybWVyJztcbmltcG9ydCB7IGNvbnZlcnRUcmFuc2Zvcm1lciB9IGZyb20gJy4vdmFsaWRhdG9ycy90cmFuc2Zvcm1lcic7XG5cbi8vIENsYXNzIFRyYW5zZm9ybVN0cmVhbVxuXG4vKipcbiAqIEEgdHJhbnNmb3JtIHN0cmVhbSBjb25zaXN0cyBvZiBhIHBhaXIgb2Ygc3RyZWFtczogYSB7QGxpbmsgV3JpdGFibGVTdHJlYW0gfCB3cml0YWJsZSBzdHJlYW19LFxuICoga25vd24gYXMgaXRzIHdyaXRhYmxlIHNpZGUsIGFuZCBhIHtAbGluayBSZWFkYWJsZVN0cmVhbSB8IHJlYWRhYmxlIHN0cmVhbX0sIGtub3duIGFzIGl0cyByZWFkYWJsZSBzaWRlLlxuICogSW4gYSBtYW5uZXIgc3BlY2lmaWMgdG8gdGhlIHRyYW5zZm9ybSBzdHJlYW0gaW4gcXVlc3Rpb24sIHdyaXRlcyB0byB0aGUgd3JpdGFibGUgc2lkZSByZXN1bHQgaW4gbmV3IGRhdGEgYmVpbmdcbiAqIG1hZGUgYXZhaWxhYmxlIGZvciByZWFkaW5nIGZyb20gdGhlIHJlYWRhYmxlIHNpZGUuXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgVHJhbnNmb3JtU3RyZWFtPEkgPSBhbnksIE8gPSBhbnk+IHtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfd3JpdGFibGUhOiBXcml0YWJsZVN0cmVhbTxJPjtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfcmVhZGFibGUhOiBSZWFkYWJsZVN0cmVhbTxPPjtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYmFja3ByZXNzdXJlITogYm9vbGVhbjtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYmFja3ByZXNzdXJlQ2hhbmdlUHJvbWlzZSE6IFByb21pc2U8dm9pZD47XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2JhY2twcmVzc3VyZUNoYW5nZVByb21pc2VfcmVzb2x2ZSE6ICgpID0+IHZvaWQ7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3RyYW5zZm9ybVN0cmVhbUNvbnRyb2xsZXIhOiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxPPjtcblxuICBjb25zdHJ1Y3RvcihcbiAgICB0cmFuc2Zvcm1lcj86IFRyYW5zZm9ybWVyPEksIE8+LFxuICAgIHdyaXRhYmxlU3RyYXRlZ3k/OiBRdWV1aW5nU3RyYXRlZ3k8ST4sXG4gICAgcmVhZGFibGVTdHJhdGVneT86IFF1ZXVpbmdTdHJhdGVneTxPPlxuICApO1xuICBjb25zdHJ1Y3RvcihyYXdUcmFuc2Zvcm1lcjogVHJhbnNmb3JtZXI8SSwgTz4gfCBudWxsIHwgdW5kZWZpbmVkID0ge30sXG4gICAgICAgICAgICAgIHJhd1dyaXRhYmxlU3RyYXRlZ3k6IFF1ZXVpbmdTdHJhdGVneTxJPiB8IG51bGwgfCB1bmRlZmluZWQgPSB7fSxcbiAgICAgICAgICAgICAgcmF3UmVhZGFibGVTdHJhdGVneTogUXVldWluZ1N0cmF0ZWd5PE8+IHwgbnVsbCB8IHVuZGVmaW5lZCA9IHt9KSB7XG4gICAgaWYgKHJhd1RyYW5zZm9ybWVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJhd1RyYW5zZm9ybWVyID0gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCB3cml0YWJsZVN0cmF0ZWd5ID0gY29udmVydFF1ZXVpbmdTdHJhdGVneShyYXdXcml0YWJsZVN0cmF0ZWd5LCAnU2Vjb25kIHBhcmFtZXRlcicpO1xuICAgIGNvbnN0IHJlYWRhYmxlU3RyYXRlZ3kgPSBjb252ZXJ0UXVldWluZ1N0cmF0ZWd5KHJhd1JlYWRhYmxlU3RyYXRlZ3ksICdUaGlyZCBwYXJhbWV0ZXInKTtcblxuICAgIGNvbnN0IHRyYW5zZm9ybWVyID0gY29udmVydFRyYW5zZm9ybWVyKHJhd1RyYW5zZm9ybWVyLCAnRmlyc3QgcGFyYW1ldGVyJyk7XG4gICAgaWYgKHRyYW5zZm9ybWVyLnJlYWRhYmxlVHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCByZWFkYWJsZVR5cGUgc3BlY2lmaWVkJyk7XG4gICAgfVxuICAgIGlmICh0cmFuc2Zvcm1lci53cml0YWJsZVR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgd3JpdGFibGVUeXBlIHNwZWNpZmllZCcpO1xuICAgIH1cblxuICAgIGNvbnN0IHJlYWRhYmxlSGlnaFdhdGVyTWFyayA9IEV4dHJhY3RIaWdoV2F0ZXJNYXJrKHJlYWRhYmxlU3RyYXRlZ3ksIDApO1xuICAgIGNvbnN0IHJlYWRhYmxlU2l6ZUFsZ29yaXRobSA9IEV4dHJhY3RTaXplQWxnb3JpdGhtKHJlYWRhYmxlU3RyYXRlZ3kpO1xuICAgIGNvbnN0IHdyaXRhYmxlSGlnaFdhdGVyTWFyayA9IEV4dHJhY3RIaWdoV2F0ZXJNYXJrKHdyaXRhYmxlU3RyYXRlZ3ksIDEpO1xuICAgIGNvbnN0IHdyaXRhYmxlU2l6ZUFsZ29yaXRobSA9IEV4dHJhY3RTaXplQWxnb3JpdGhtKHdyaXRhYmxlU3RyYXRlZ3kpO1xuXG4gICAgbGV0IHN0YXJ0UHJvbWlzZV9yZXNvbHZlITogKHZhbHVlOiB2b2lkIHwgUHJvbWlzZUxpa2U8dm9pZD4pID0+IHZvaWQ7XG4gICAgY29uc3Qgc3RhcnRQcm9taXNlID0gbmV3UHJvbWlzZTx2b2lkPihyZXNvbHZlID0+IHtcbiAgICAgIHN0YXJ0UHJvbWlzZV9yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICB9KTtcblxuICAgIEluaXRpYWxpemVUcmFuc2Zvcm1TdHJlYW0oXG4gICAgICB0aGlzLCBzdGFydFByb21pc2UsIHdyaXRhYmxlSGlnaFdhdGVyTWFyaywgd3JpdGFibGVTaXplQWxnb3JpdGhtLCByZWFkYWJsZUhpZ2hXYXRlck1hcmssIHJlYWRhYmxlU2l6ZUFsZ29yaXRobVxuICAgICk7XG4gICAgU2V0VXBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlckZyb21UcmFuc2Zvcm1lcih0aGlzLCB0cmFuc2Zvcm1lcik7XG5cbiAgICBpZiAodHJhbnNmb3JtZXIuc3RhcnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgc3RhcnRQcm9taXNlX3Jlc29sdmUodHJhbnNmb3JtZXIuc3RhcnQodGhpcy5fdHJhbnNmb3JtU3RyZWFtQ29udHJvbGxlcikpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydFByb21pc2VfcmVzb2x2ZSh1bmRlZmluZWQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgcmVhZGFibGUgc2lkZSBvZiB0aGUgdHJhbnNmb3JtIHN0cmVhbS5cbiAgICovXG4gIGdldCByZWFkYWJsZSgpOiBSZWFkYWJsZVN0cmVhbTxPPiB7XG4gICAgaWYgKCFJc1RyYW5zZm9ybVN0cmVhbSh0aGlzKSkge1xuICAgICAgdGhyb3cgc3RyZWFtQnJhbmRDaGVja0V4Y2VwdGlvbigncmVhZGFibGUnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGU7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHdyaXRhYmxlIHNpZGUgb2YgdGhlIHRyYW5zZm9ybSBzdHJlYW0uXG4gICAqL1xuICBnZXQgd3JpdGFibGUoKTogV3JpdGFibGVTdHJlYW08ST4ge1xuICAgIGlmICghSXNUcmFuc2Zvcm1TdHJlYW0odGhpcykpIHtcbiAgICAgIHRocm93IHN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24oJ3dyaXRhYmxlJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFRyYW5zZm9ybVN0cmVhbS5wcm90b3R5cGUsIHtcbiAgcmVhZGFibGU6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICB3cml0YWJsZTogeyBlbnVtZXJhYmxlOiB0cnVlIH1cbn0pO1xuaWYgKHR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWcgPT09ICdzeW1ib2wnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUcmFuc2Zvcm1TdHJlYW0ucHJvdG90eXBlLCBTeW1ib2wudG9TdHJpbmdUYWcsIHtcbiAgICB2YWx1ZTogJ1RyYW5zZm9ybVN0cmVhbScsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG5leHBvcnQge1xuICBUcmFuc2Zvcm1lcixcbiAgVHJhbnNmb3JtZXJTdGFydENhbGxiYWNrLFxuICBUcmFuc2Zvcm1lckZsdXNoQ2FsbGJhY2ssXG4gIFRyYW5zZm9ybWVyVHJhbnNmb3JtQ2FsbGJhY2tcbn07XG5cbi8vIFRyYW5zZm9ybSBTdHJlYW0gQWJzdHJhY3QgT3BlcmF0aW9uc1xuXG5leHBvcnQgZnVuY3Rpb24gQ3JlYXRlVHJhbnNmb3JtU3RyZWFtPEksIE8+KHN0YXJ0QWxnb3JpdGhtOiAoKSA9PiB2b2lkIHwgUHJvbWlzZUxpa2U8dm9pZD4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybUFsZ29yaXRobTogKGNodW5rOiBJKSA9PiBQcm9taXNlPHZvaWQ+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbHVzaEFsZ29yaXRobTogKCkgPT4gUHJvbWlzZTx2b2lkPixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGFibGVIaWdoV2F0ZXJNYXJrID0gMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGFibGVTaXplQWxnb3JpdGhtOiBRdWV1aW5nU3RyYXRlZ3lTaXplQ2FsbGJhY2s8ST4gPSAoKSA9PiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkYWJsZUhpZ2hXYXRlck1hcmsgPSAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkYWJsZVNpemVBbGdvcml0aG06IFF1ZXVpbmdTdHJhdGVneVNpemVDYWxsYmFjazxPPiA9ICgpID0+IDEpIHtcbiAgYXNzZXJ0KElzTm9uTmVnYXRpdmVOdW1iZXIod3JpdGFibGVIaWdoV2F0ZXJNYXJrKSk7XG4gIGFzc2VydChJc05vbk5lZ2F0aXZlTnVtYmVyKHJlYWRhYmxlSGlnaFdhdGVyTWFyaykpO1xuXG4gIGNvbnN0IHN0cmVhbTogVHJhbnNmb3JtU3RyZWFtPEksIE8+ID0gT2JqZWN0LmNyZWF0ZShUcmFuc2Zvcm1TdHJlYW0ucHJvdG90eXBlKTtcblxuICBsZXQgc3RhcnRQcm9taXNlX3Jlc29sdmUhOiAodmFsdWU6IHZvaWQgfCBQcm9taXNlTGlrZTx2b2lkPikgPT4gdm9pZDtcbiAgY29uc3Qgc3RhcnRQcm9taXNlID0gbmV3UHJvbWlzZTx2b2lkPihyZXNvbHZlID0+IHtcbiAgICBzdGFydFByb21pc2VfcmVzb2x2ZSA9IHJlc29sdmU7XG4gIH0pO1xuXG4gIEluaXRpYWxpemVUcmFuc2Zvcm1TdHJlYW0oc3RyZWFtLCBzdGFydFByb21pc2UsIHdyaXRhYmxlSGlnaFdhdGVyTWFyaywgd3JpdGFibGVTaXplQWxnb3JpdGhtLCByZWFkYWJsZUhpZ2hXYXRlck1hcmssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZGFibGVTaXplQWxnb3JpdGhtKTtcblxuICBjb25zdCBjb250cm9sbGVyOiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxPPiA9IE9iamVjdC5jcmVhdGUoVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIucHJvdG90eXBlKTtcblxuICBTZXRVcFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyKHN0cmVhbSwgY29udHJvbGxlciwgdHJhbnNmb3JtQWxnb3JpdGhtLCBmbHVzaEFsZ29yaXRobSk7XG5cbiAgY29uc3Qgc3RhcnRSZXN1bHQgPSBzdGFydEFsZ29yaXRobSgpO1xuICBzdGFydFByb21pc2VfcmVzb2x2ZShzdGFydFJlc3VsdCk7XG4gIHJldHVybiBzdHJlYW07XG59XG5cbmZ1bmN0aW9uIEluaXRpYWxpemVUcmFuc2Zvcm1TdHJlYW08SSwgTz4oc3RyZWFtOiBUcmFuc2Zvcm1TdHJlYW08SSwgTz4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0UHJvbWlzZTogUHJvbWlzZTx2b2lkPixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGFibGVIaWdoV2F0ZXJNYXJrOiBudW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlU2l6ZUFsZ29yaXRobTogUXVldWluZ1N0cmF0ZWd5U2l6ZUNhbGxiYWNrPEk+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkYWJsZUhpZ2hXYXRlck1hcms6IG51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZGFibGVTaXplQWxnb3JpdGhtOiBRdWV1aW5nU3RyYXRlZ3lTaXplQ2FsbGJhY2s8Tz4pIHtcbiAgZnVuY3Rpb24gc3RhcnRBbGdvcml0aG0oKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgcmV0dXJuIHN0YXJ0UHJvbWlzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdyaXRlQWxnb3JpdGhtKGNodW5rOiBJKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgcmV0dXJuIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRTaW5rV3JpdGVBbGdvcml0aG0oc3RyZWFtLCBjaHVuayk7XG4gIH1cblxuICBmdW5jdGlvbiBhYm9ydEFsZ29yaXRobShyZWFzb246IGFueSk6IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVybiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0U2lua0Fib3J0QWxnb3JpdGhtKHN0cmVhbSwgcmVhc29uKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsb3NlQWxnb3JpdGhtKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVybiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0U2lua0Nsb3NlQWxnb3JpdGhtKHN0cmVhbSk7XG4gIH1cblxuICBzdHJlYW0uX3dyaXRhYmxlID0gQ3JlYXRlV3JpdGFibGVTdHJlYW0oc3RhcnRBbGdvcml0aG0sIHdyaXRlQWxnb3JpdGhtLCBjbG9zZUFsZ29yaXRobSwgYWJvcnRBbGdvcml0aG0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3cml0YWJsZUhpZ2hXYXRlck1hcmssIHdyaXRhYmxlU2l6ZUFsZ29yaXRobSk7XG5cbiAgZnVuY3Rpb24gcHVsbEFsZ29yaXRobSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICByZXR1cm4gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdFNvdXJjZVB1bGxBbGdvcml0aG0oc3RyZWFtKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbmNlbEFsZ29yaXRobShyZWFzb246IGFueSk6IFByb21pc2U8dm9pZD4ge1xuICAgIFRyYW5zZm9ybVN0cmVhbUVycm9yV3JpdGFibGVBbmRVbmJsb2NrV3JpdGUoc3RyZWFtLCByZWFzb24pO1xuICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG4gIH1cblxuICBzdHJlYW0uX3JlYWRhYmxlID0gQ3JlYXRlUmVhZGFibGVTdHJlYW0oc3RhcnRBbGdvcml0aG0sIHB1bGxBbGdvcml0aG0sIGNhbmNlbEFsZ29yaXRobSwgcmVhZGFibGVIaWdoV2F0ZXJNYXJrLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZGFibGVTaXplQWxnb3JpdGhtKTtcblxuICAvLyBUaGUgW1tiYWNrcHJlc3N1cmVdXSBzbG90IGlzIHNldCB0byB1bmRlZmluZWQgc28gdGhhdCBpdCBjYW4gYmUgaW5pdGlhbGlzZWQgYnkgVHJhbnNmb3JtU3RyZWFtU2V0QmFja3ByZXNzdXJlLlxuICBzdHJlYW0uX2JhY2twcmVzc3VyZSA9IHVuZGVmaW5lZCE7XG4gIHN0cmVhbS5fYmFja3ByZXNzdXJlQ2hhbmdlUHJvbWlzZSA9IHVuZGVmaW5lZCE7XG4gIHN0cmVhbS5fYmFja3ByZXNzdXJlQ2hhbmdlUHJvbWlzZV9yZXNvbHZlID0gdW5kZWZpbmVkITtcbiAgVHJhbnNmb3JtU3RyZWFtU2V0QmFja3ByZXNzdXJlKHN0cmVhbSwgdHJ1ZSk7XG5cbiAgc3RyZWFtLl90cmFuc2Zvcm1TdHJlYW1Db250cm9sbGVyID0gdW5kZWZpbmVkITtcbn1cblxuZnVuY3Rpb24gSXNUcmFuc2Zvcm1TdHJlYW0oeDogdW5rbm93bik6IHggaXMgVHJhbnNmb3JtU3RyZWFtIHtcbiAgaWYgKCF0eXBlSXNPYmplY3QoeCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnX3RyYW5zZm9ybVN0cmVhbUNvbnRyb2xsZXInKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB4IGluc3RhbmNlb2YgVHJhbnNmb3JtU3RyZWFtO1xufVxuXG4vLyBUaGlzIGlzIGEgbm8tb3AgaWYgYm90aCBzaWRlcyBhcmUgYWxyZWFkeSBlcnJvcmVkLlxuZnVuY3Rpb24gVHJhbnNmb3JtU3RyZWFtRXJyb3Ioc3RyZWFtOiBUcmFuc2Zvcm1TdHJlYW0sIGU6IGFueSkge1xuICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3IoXG4gICAgc3RyZWFtLl9yZWFkYWJsZS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyIGFzIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8YW55PixcbiAgICBlXG4gICk7XG4gIFRyYW5zZm9ybVN0cmVhbUVycm9yV3JpdGFibGVBbmRVbmJsb2NrV3JpdGUoc3RyZWFtLCBlKTtcbn1cblxuZnVuY3Rpb24gVHJhbnNmb3JtU3RyZWFtRXJyb3JXcml0YWJsZUFuZFVuYmxvY2tXcml0ZShzdHJlYW06IFRyYW5zZm9ybVN0cmVhbSwgZTogYW55KSB7XG4gIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKHN0cmVhbS5fdHJhbnNmb3JtU3RyZWFtQ29udHJvbGxlcik7XG4gIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcklmTmVlZGVkKHN0cmVhbS5fd3JpdGFibGUuX3dyaXRhYmxlU3RyZWFtQ29udHJvbGxlciwgZSk7XG4gIGlmIChzdHJlYW0uX2JhY2twcmVzc3VyZSkge1xuICAgIC8vIFByZXRlbmQgdGhhdCBwdWxsKCkgd2FzIGNhbGxlZCB0byBwZXJtaXQgYW55IHBlbmRpbmcgd3JpdGUoKSBjYWxscyB0byBjb21wbGV0ZS4gVHJhbnNmb3JtU3RyZWFtU2V0QmFja3ByZXNzdXJlKClcbiAgICAvLyBjYW5ub3QgYmUgY2FsbGVkIGZyb20gZW5xdWV1ZSgpIG9yIHB1bGwoKSBvbmNlIHRoZSBSZWFkYWJsZVN0cmVhbSBpcyBlcnJvcmVkLCBzbyB0aGlzIHdpbGwgd2lsbCBiZSB0aGUgZmluYWwgdGltZVxuICAgIC8vIF9iYWNrcHJlc3N1cmUgaXMgc2V0LlxuICAgIFRyYW5zZm9ybVN0cmVhbVNldEJhY2twcmVzc3VyZShzdHJlYW0sIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBUcmFuc2Zvcm1TdHJlYW1TZXRCYWNrcHJlc3N1cmUoc3RyZWFtOiBUcmFuc2Zvcm1TdHJlYW0sIGJhY2twcmVzc3VyZTogYm9vbGVhbikge1xuICAvLyBQYXNzZXMgYWxzbyB3aGVuIGNhbGxlZCBkdXJpbmcgY29uc3RydWN0aW9uLlxuICBhc3NlcnQoc3RyZWFtLl9iYWNrcHJlc3N1cmUgIT09IGJhY2twcmVzc3VyZSk7XG5cbiAgaWYgKHN0cmVhbS5fYmFja3ByZXNzdXJlQ2hhbmdlUHJvbWlzZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgc3RyZWFtLl9iYWNrcHJlc3N1cmVDaGFuZ2VQcm9taXNlX3Jlc29sdmUoKTtcbiAgfVxuXG4gIHN0cmVhbS5fYmFja3ByZXNzdXJlQ2hhbmdlUHJvbWlzZSA9IG5ld1Byb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgc3RyZWFtLl9iYWNrcHJlc3N1cmVDaGFuZ2VQcm9taXNlX3Jlc29sdmUgPSByZXNvbHZlO1xuICB9KTtcblxuICBzdHJlYW0uX2JhY2twcmVzc3VyZSA9IGJhY2twcmVzc3VyZTtcbn1cblxuLy8gQ2xhc3MgVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJcblxuLyoqXG4gKiBBbGxvd3MgY29udHJvbCBvZiB0aGUge0BsaW5rIFJlYWRhYmxlU3RyZWFtfSBhbmQge0BsaW5rIFdyaXRhYmxlU3RyZWFtfSBvZiB0aGUgYXNzb2NpYXRlZCB7QGxpbmsgVHJhbnNmb3JtU3RyZWFtfS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxPPiB7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2NvbnRyb2xsZWRUcmFuc2Zvcm1TdHJlYW06IFRyYW5zZm9ybVN0cmVhbTxhbnksIE8+O1xuICAvKiogQGludGVybmFsICovXG4gIF90cmFuc2Zvcm1BbGdvcml0aG06IChjaHVuazogYW55KSA9PiBQcm9taXNlPHZvaWQ+O1xuICAvKiogQGludGVybmFsICovXG4gIF9mbHVzaEFsZ29yaXRobTogKCkgPT4gUHJvbWlzZTx2b2lkPjtcblxuICBwcml2YXRlIGNvbnN0cnVjdG9yKCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0lsbGVnYWwgY29uc3RydWN0b3InKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBkZXNpcmVkIHNpemUgdG8gZmlsbCB0aGUgcmVhZGFibGUgc2lkZeKAmXMgaW50ZXJuYWwgcXVldWUuIEl0IGNhbiBiZSBuZWdhdGl2ZSwgaWYgdGhlIHF1ZXVlIGlzIG92ZXItZnVsbC5cbiAgICovXG4gIGdldCBkZXNpcmVkU2l6ZSgpOiBudW1iZXIgfCBudWxsIHtcbiAgICBpZiAoIUlzVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIodGhpcykpIHtcbiAgICAgIHRocm93IGRlZmF1bHRDb250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbignZGVzaXJlZFNpemUnKTtcbiAgICB9XG5cbiAgICBjb25zdCByZWFkYWJsZUNvbnRyb2xsZXIgPSB0aGlzLl9jb250cm9sbGVkVHJhbnNmb3JtU3RyZWFtLl9yZWFkYWJsZS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyO1xuICAgIHJldHVybiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyR2V0RGVzaXJlZFNpemUocmVhZGFibGVDb250cm9sbGVyIGFzIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8Tz4pO1xuICB9XG5cbiAgLyoqXG4gICAqIEVucXVldWVzIHRoZSBnaXZlbiBjaHVuayBgY2h1bmtgIGluIHRoZSByZWFkYWJsZSBzaWRlIG9mIHRoZSBjb250cm9sbGVkIHRyYW5zZm9ybSBzdHJlYW0uXG4gICAqL1xuICBlbnF1ZXVlKGNodW5rOiBPKTogdm9pZDtcbiAgZW5xdWV1ZShjaHVuazogTyA9IHVuZGVmaW5lZCEpOiB2b2lkIHtcbiAgICBpZiAoIUlzVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIodGhpcykpIHtcbiAgICAgIHRocm93IGRlZmF1bHRDb250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbignZW5xdWV1ZScpO1xuICAgIH1cblxuICAgIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyRW5xdWV1ZSh0aGlzLCBjaHVuayk7XG4gIH1cblxuICAvKipcbiAgICogRXJyb3JzIGJvdGggdGhlIHJlYWRhYmxlIHNpZGUgYW5kIHRoZSB3cml0YWJsZSBzaWRlIG9mIHRoZSBjb250cm9sbGVkIHRyYW5zZm9ybSBzdHJlYW0sIG1ha2luZyBhbGwgZnV0dXJlXG4gICAqIGludGVyYWN0aW9ucyB3aXRoIGl0IGZhaWwgd2l0aCB0aGUgZ2l2ZW4gZXJyb3IgYGVgLiBBbnkgY2h1bmtzIHF1ZXVlZCBmb3IgdHJhbnNmb3JtYXRpb24gd2lsbCBiZSBkaXNjYXJkZWQuXG4gICAqL1xuICBlcnJvcihyZWFzb246IGFueSA9IHVuZGVmaW5lZCk6IHZvaWQge1xuICAgIGlmICghSXNUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlcih0aGlzKSkge1xuICAgICAgdGhyb3cgZGVmYXVsdENvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdlcnJvcicpO1xuICAgIH1cblxuICAgIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3IodGhpcywgcmVhc29uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9zZXMgdGhlIHJlYWRhYmxlIHNpZGUgYW5kIGVycm9ycyB0aGUgd3JpdGFibGUgc2lkZSBvZiB0aGUgY29udHJvbGxlZCB0cmFuc2Zvcm0gc3RyZWFtLiBUaGlzIGlzIHVzZWZ1bCB3aGVuIHRoZVxuICAgKiB0cmFuc2Zvcm1lciBvbmx5IG5lZWRzIHRvIGNvbnN1bWUgYSBwb3J0aW9uIG9mIHRoZSBjaHVua3Mgd3JpdHRlbiB0byB0aGUgd3JpdGFibGUgc2lkZS5cbiAgICovXG4gIHRlcm1pbmF0ZSgpOiB2b2lkIHtcbiAgICBpZiAoIUlzVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIodGhpcykpIHtcbiAgICAgIHRocm93IGRlZmF1bHRDb250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbigndGVybWluYXRlJyk7XG4gICAgfVxuXG4gICAgVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJUZXJtaW5hdGUodGhpcyk7XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIucHJvdG90eXBlLCB7XG4gIGVucXVldWU6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICBlcnJvcjogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gIHRlcm1pbmF0ZTogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gIGRlc2lyZWRTaXplOiB7IGVudW1lcmFibGU6IHRydWUgfVxufSk7XG5pZiAodHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7XG4gICAgdmFsdWU6ICdUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlcicsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG4vLyBUcmFuc2Zvcm0gU3RyZWFtIERlZmF1bHQgQ29udHJvbGxlciBBYnN0cmFjdCBPcGVyYXRpb25zXG5cbmZ1bmN0aW9uIElzVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8TyA9IGFueT4oeDogYW55KTogeCBpcyBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxPPiB7XG4gIGlmICghdHlwZUlzT2JqZWN0KHgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ19jb250cm9sbGVkVHJhbnNmb3JtU3RyZWFtJykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4geCBpbnN0YW5jZW9mIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyO1xufVxuXG5mdW5jdGlvbiBTZXRVcFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyPEksIE8+KHN0cmVhbTogVHJhbnNmb3JtU3RyZWFtPEksIE8+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyOiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxPPixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtQWxnb3JpdGhtOiAoY2h1bms6IEkpID0+IFByb21pc2U8dm9pZD4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsdXNoQWxnb3JpdGhtOiAoKSA9PiBQcm9taXNlPHZvaWQ+KSB7XG4gIGFzc2VydChJc1RyYW5zZm9ybVN0cmVhbShzdHJlYW0pKTtcbiAgYXNzZXJ0KHN0cmVhbS5fdHJhbnNmb3JtU3RyZWFtQ29udHJvbGxlciA9PT0gdW5kZWZpbmVkKTtcblxuICBjb250cm9sbGVyLl9jb250cm9sbGVkVHJhbnNmb3JtU3RyZWFtID0gc3RyZWFtO1xuICBzdHJlYW0uX3RyYW5zZm9ybVN0cmVhbUNvbnRyb2xsZXIgPSBjb250cm9sbGVyO1xuXG4gIGNvbnRyb2xsZXIuX3RyYW5zZm9ybUFsZ29yaXRobSA9IHRyYW5zZm9ybUFsZ29yaXRobTtcbiAgY29udHJvbGxlci5fZmx1c2hBbGdvcml0aG0gPSBmbHVzaEFsZ29yaXRobTtcbn1cblxuZnVuY3Rpb24gU2V0VXBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlckZyb21UcmFuc2Zvcm1lcjxJLCBPPihzdHJlYW06IFRyYW5zZm9ybVN0cmVhbTxJLCBPPixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtZXI6IFZhbGlkYXRlZFRyYW5zZm9ybWVyPEksIE8+KSB7XG4gIGNvbnN0IGNvbnRyb2xsZXI6IFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyPE8+ID0gT2JqZWN0LmNyZWF0ZShUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUpO1xuXG4gIGxldCB0cmFuc2Zvcm1BbGdvcml0aG0gPSAoY2h1bms6IEkpOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgICB0cnkge1xuICAgICAgVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFbnF1ZXVlKGNvbnRyb2xsZXIsIGNodW5rIGFzIHVua25vd24gYXMgTyk7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuICAgIH0gY2F0Y2ggKHRyYW5zZm9ybVJlc3VsdEUpIHtcbiAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKHRyYW5zZm9ybVJlc3VsdEUpO1xuICAgIH1cbiAgfTtcblxuICBsZXQgZmx1c2hBbGdvcml0aG06ICgpID0+IFByb21pc2U8dm9pZD4gPSAoKSA9PiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG5cbiAgaWYgKHRyYW5zZm9ybWVyLnRyYW5zZm9ybSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdHJhbnNmb3JtQWxnb3JpdGhtID0gY2h1bmsgPT4gdHJhbnNmb3JtZXIudHJhbnNmb3JtIShjaHVuaywgY29udHJvbGxlcik7XG4gIH1cbiAgaWYgKHRyYW5zZm9ybWVyLmZsdXNoICE9PSB1bmRlZmluZWQpIHtcbiAgICBmbHVzaEFsZ29yaXRobSA9ICgpID0+IHRyYW5zZm9ybWVyLmZsdXNoIShjb250cm9sbGVyKTtcbiAgfVxuXG4gIFNldFVwVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIoc3RyZWFtLCBjb250cm9sbGVyLCB0cmFuc2Zvcm1BbGdvcml0aG0sIGZsdXNoQWxnb3JpdGhtKTtcbn1cblxuZnVuY3Rpb24gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbGVhckFsZ29yaXRobXMoY29udHJvbGxlcjogVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8YW55Pikge1xuICBjb250cm9sbGVyLl90cmFuc2Zvcm1BbGdvcml0aG0gPSB1bmRlZmluZWQhO1xuICBjb250cm9sbGVyLl9mbHVzaEFsZ29yaXRobSA9IHVuZGVmaW5lZCE7XG59XG5cbmZ1bmN0aW9uIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyRW5xdWV1ZTxPPihjb250cm9sbGVyOiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxPPiwgY2h1bms6IE8pIHtcbiAgY29uc3Qgc3RyZWFtID0gY29udHJvbGxlci5fY29udHJvbGxlZFRyYW5zZm9ybVN0cmVhbTtcbiAgY29uc3QgcmVhZGFibGVDb250cm9sbGVyID0gc3RyZWFtLl9yZWFkYWJsZS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyIGFzIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8Tz47XG4gIGlmICghUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNhbkNsb3NlT3JFbnF1ZXVlKHJlYWRhYmxlQ29udHJvbGxlcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWFkYWJsZSBzaWRlIGlzIG5vdCBpbiBhIHN0YXRlIHRoYXQgcGVybWl0cyBlbnF1ZXVlJyk7XG4gIH1cblxuICAvLyBXZSB0aHJvdHRsZSB0cmFuc2Zvcm0gaW52b2NhdGlvbnMgYmFzZWQgb24gdGhlIGJhY2twcmVzc3VyZSBvZiB0aGUgUmVhZGFibGVTdHJlYW0sIGJ1dCB3ZSBzdGlsbFxuICAvLyBhY2NlcHQgVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFbnF1ZXVlKCkgY2FsbHMuXG5cbiAgdHJ5IHtcbiAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRW5xdWV1ZShyZWFkYWJsZUNvbnRyb2xsZXIsIGNodW5rKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIFRoaXMgaGFwcGVucyB3aGVuIHJlYWRhYmxlU3RyYXRlZ3kuc2l6ZSgpIHRocm93cy5cbiAgICBUcmFuc2Zvcm1TdHJlYW1FcnJvcldyaXRhYmxlQW5kVW5ibG9ja1dyaXRlKHN0cmVhbSwgZSk7XG5cbiAgICB0aHJvdyBzdHJlYW0uX3JlYWRhYmxlLl9zdG9yZWRFcnJvcjtcbiAgfVxuXG4gIGNvbnN0IGJhY2twcmVzc3VyZSA9IFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJIYXNCYWNrcHJlc3N1cmUocmVhZGFibGVDb250cm9sbGVyKTtcbiAgaWYgKGJhY2twcmVzc3VyZSAhPT0gc3RyZWFtLl9iYWNrcHJlc3N1cmUpIHtcbiAgICBhc3NlcnQoYmFja3ByZXNzdXJlKTtcbiAgICBUcmFuc2Zvcm1TdHJlYW1TZXRCYWNrcHJlc3N1cmUoc3RyZWFtLCB0cnVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9yKGNvbnRyb2xsZXI6IFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyPGFueT4sIGU6IGFueSkge1xuICBUcmFuc2Zvcm1TdHJlYW1FcnJvcihjb250cm9sbGVyLl9jb250cm9sbGVkVHJhbnNmb3JtU3RyZWFtLCBlKTtcbn1cblxuZnVuY3Rpb24gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJQZXJmb3JtVHJhbnNmb3JtPEksIE8+KGNvbnRyb2xsZXI6IFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyPE8+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rOiBJKSB7XG4gIGNvbnN0IHRyYW5zZm9ybVByb21pc2UgPSBjb250cm9sbGVyLl90cmFuc2Zvcm1BbGdvcml0aG0oY2h1bmspO1xuICByZXR1cm4gdHJhbnNmb3JtUHJvbWlzZVdpdGgodHJhbnNmb3JtUHJvbWlzZSwgdW5kZWZpbmVkLCByID0+IHtcbiAgICBUcmFuc2Zvcm1TdHJlYW1FcnJvcihjb250cm9sbGVyLl9jb250cm9sbGVkVHJhbnNmb3JtU3RyZWFtLCByKTtcbiAgICB0aHJvdyByO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJUZXJtaW5hdGU8Tz4oY29udHJvbGxlcjogVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8Tz4pIHtcbiAgY29uc3Qgc3RyZWFtID0gY29udHJvbGxlci5fY29udHJvbGxlZFRyYW5zZm9ybVN0cmVhbTtcbiAgY29uc3QgcmVhZGFibGVDb250cm9sbGVyID0gc3RyZWFtLl9yZWFkYWJsZS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyIGFzIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8Tz47XG5cbiAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsb3NlKHJlYWRhYmxlQ29udHJvbGxlcik7XG5cbiAgY29uc3QgZXJyb3IgPSBuZXcgVHlwZUVycm9yKCdUcmFuc2Zvcm1TdHJlYW0gdGVybWluYXRlZCcpO1xuICBUcmFuc2Zvcm1TdHJlYW1FcnJvcldyaXRhYmxlQW5kVW5ibG9ja1dyaXRlKHN0cmVhbSwgZXJyb3IpO1xufVxuXG4vLyBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0U2luayBBbGdvcml0aG1zXG5cbmZ1bmN0aW9uIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRTaW5rV3JpdGVBbGdvcml0aG08SSwgTz4oc3RyZWFtOiBUcmFuc2Zvcm1TdHJlYW08SSwgTz4sIGNodW5rOiBJKTogUHJvbWlzZTx2b2lkPiB7XG4gIGFzc2VydChzdHJlYW0uX3dyaXRhYmxlLl9zdGF0ZSA9PT0gJ3dyaXRhYmxlJyk7XG5cbiAgY29uc3QgY29udHJvbGxlciA9IHN0cmVhbS5fdHJhbnNmb3JtU3RyZWFtQ29udHJvbGxlcjtcblxuICBpZiAoc3RyZWFtLl9iYWNrcHJlc3N1cmUpIHtcbiAgICBjb25zdCBiYWNrcHJlc3N1cmVDaGFuZ2VQcm9taXNlID0gc3RyZWFtLl9iYWNrcHJlc3N1cmVDaGFuZ2VQcm9taXNlO1xuICAgIGFzc2VydChiYWNrcHJlc3N1cmVDaGFuZ2VQcm9taXNlICE9PSB1bmRlZmluZWQpO1xuICAgIHJldHVybiB0cmFuc2Zvcm1Qcm9taXNlV2l0aChiYWNrcHJlc3N1cmVDaGFuZ2VQcm9taXNlLCAoKSA9PiB7XG4gICAgICBjb25zdCB3cml0YWJsZSA9IHN0cmVhbS5fd3JpdGFibGU7XG4gICAgICBjb25zdCBzdGF0ZSA9IHdyaXRhYmxlLl9zdGF0ZTtcbiAgICAgIGlmIChzdGF0ZSA9PT0gJ2Vycm9yaW5nJykge1xuICAgICAgICB0aHJvdyB3cml0YWJsZS5fc3RvcmVkRXJyb3I7XG4gICAgICB9XG4gICAgICBhc3NlcnQoc3RhdGUgPT09ICd3cml0YWJsZScpO1xuICAgICAgcmV0dXJuIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyUGVyZm9ybVRyYW5zZm9ybTxJLCBPPihjb250cm9sbGVyLCBjaHVuayk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJQZXJmb3JtVHJhbnNmb3JtPEksIE8+KGNvbnRyb2xsZXIsIGNodW5rKTtcbn1cblxuZnVuY3Rpb24gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdFNpbmtBYm9ydEFsZ29yaXRobShzdHJlYW06IFRyYW5zZm9ybVN0cmVhbSwgcmVhc29uOiBhbnkpOiBQcm9taXNlPHZvaWQ+IHtcbiAgLy8gYWJvcnQoKSBpcyBub3QgY2FsbGVkIHN5bmNocm9ub3VzbHksIHNvIGl0IGlzIHBvc3NpYmxlIGZvciBhYm9ydCgpIHRvIGJlIGNhbGxlZCB3aGVuIHRoZSBzdHJlYW0gaXMgYWxyZWFkeVxuICAvLyBlcnJvcmVkLlxuICBUcmFuc2Zvcm1TdHJlYW1FcnJvcihzdHJlYW0sIHJlYXNvbik7XG4gIHJldHVybiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG59XG5cbmZ1bmN0aW9uIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRTaW5rQ2xvc2VBbGdvcml0aG08SSwgTz4oc3RyZWFtOiBUcmFuc2Zvcm1TdHJlYW08SSwgTz4pOiBQcm9taXNlPHZvaWQ+IHtcbiAgLy8gc3RyZWFtLl9yZWFkYWJsZSBjYW5ub3QgY2hhbmdlIGFmdGVyIGNvbnN0cnVjdGlvbiwgc28gY2FjaGluZyBpdCBhY3Jvc3MgYSBjYWxsIHRvIHVzZXIgY29kZSBpcyBzYWZlLlxuICBjb25zdCByZWFkYWJsZSA9IHN0cmVhbS5fcmVhZGFibGU7XG5cbiAgY29uc3QgY29udHJvbGxlciA9IHN0cmVhbS5fdHJhbnNmb3JtU3RyZWFtQ29udHJvbGxlcjtcbiAgY29uc3QgZmx1c2hQcm9taXNlID0gY29udHJvbGxlci5fZmx1c2hBbGdvcml0aG0oKTtcbiAgVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbGVhckFsZ29yaXRobXMoY29udHJvbGxlcik7XG5cbiAgLy8gUmV0dXJuIGEgcHJvbWlzZSB0aGF0IGlzIGZ1bGZpbGxlZCB3aXRoIHVuZGVmaW5lZCBvbiBzdWNjZXNzLlxuICByZXR1cm4gdHJhbnNmb3JtUHJvbWlzZVdpdGgoZmx1c2hQcm9taXNlLCAoKSA9PiB7XG4gICAgaWYgKHJlYWRhYmxlLl9zdGF0ZSA9PT0gJ2Vycm9yZWQnKSB7XG4gICAgICB0aHJvdyByZWFkYWJsZS5fc3RvcmVkRXJyb3I7XG4gICAgfVxuICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbG9zZShyZWFkYWJsZS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyIGFzIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8Tz4pO1xuICB9LCByID0+IHtcbiAgICBUcmFuc2Zvcm1TdHJlYW1FcnJvcihzdHJlYW0sIHIpO1xuICAgIHRocm93IHJlYWRhYmxlLl9zdG9yZWRFcnJvcjtcbiAgfSk7XG59XG5cbi8vIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRTb3VyY2UgQWxnb3JpdGhtc1xuXG5mdW5jdGlvbiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0U291cmNlUHVsbEFsZ29yaXRobShzdHJlYW06IFRyYW5zZm9ybVN0cmVhbSk6IFByb21pc2U8dm9pZD4ge1xuICAvLyBJbnZhcmlhbnQuIEVuZm9yY2VkIGJ5IHRoZSBwcm9taXNlcyByZXR1cm5lZCBieSBzdGFydCgpIGFuZCBwdWxsKCkuXG4gIGFzc2VydChzdHJlYW0uX2JhY2twcmVzc3VyZSk7XG5cbiAgYXNzZXJ0KHN0cmVhbS5fYmFja3ByZXNzdXJlQ2hhbmdlUHJvbWlzZSAhPT0gdW5kZWZpbmVkKTtcblxuICBUcmFuc2Zvcm1TdHJlYW1TZXRCYWNrcHJlc3N1cmUoc3RyZWFtLCBmYWxzZSk7XG5cbiAgLy8gUHJldmVudCB0aGUgbmV4dCBwdWxsKCkgY2FsbCB1bnRpbCB0aGVyZSBpcyBiYWNrcHJlc3N1cmUuXG4gIHJldHVybiBzdHJlYW0uX2JhY2twcmVzc3VyZUNoYW5nZVByb21pc2U7XG59XG5cbi8vIEhlbHBlciBmdW5jdGlvbnMgZm9yIHRoZSBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlci5cblxuZnVuY3Rpb24gZGVmYXVsdENvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uKG5hbWU6IHN0cmluZyk6IFR5cGVFcnJvciB7XG4gIHJldHVybiBuZXcgVHlwZUVycm9yKFxuICAgIGBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUuJHtuYW1lfSBjYW4gb25seSBiZSB1c2VkIG9uIGEgVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJgKTtcbn1cblxuLy8gSGVscGVyIGZ1bmN0aW9ucyBmb3IgdGhlIFRyYW5zZm9ybVN0cmVhbS5cblxuZnVuY3Rpb24gc3RyZWFtQnJhbmRDaGVja0V4Y2VwdGlvbihuYW1lOiBzdHJpbmcpOiBUeXBlRXJyb3Ige1xuICByZXR1cm4gbmV3IFR5cGVFcnJvcihcbiAgICBgVHJhbnNmb3JtU3RyZWFtLnByb3RvdHlwZS4ke25hbWV9IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBUcmFuc2Zvcm1TdHJlYW1gKTtcbn1cbiIsICJ0cnkge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJzdHJlYW0vd2ViXCIpXG59IGNhdGNoIChlcnJvcikge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJ3ZWItc3RyZWFtcy1wb2x5ZmlsbC9wb255ZmlsbFwiKVxufVxuIiwgIi8qKlxuICogQHR5cGVkZWYge29iamVjdH0gUHJpdmF0ZURhdGFcbiAqIEBwcm9wZXJ0eSB7RXZlbnRUYXJnZXR9IGV2ZW50VGFyZ2V0IFRoZSBldmVudCB0YXJnZXQuXG4gKiBAcHJvcGVydHkge3t0eXBlOnN0cmluZ319IGV2ZW50IFRoZSBvcmlnaW5hbCBldmVudCBvYmplY3QuXG4gKiBAcHJvcGVydHkge251bWJlcn0gZXZlbnRQaGFzZSBUaGUgY3VycmVudCBldmVudCBwaGFzZS5cbiAqIEBwcm9wZXJ0eSB7RXZlbnRUYXJnZXR8bnVsbH0gY3VycmVudFRhcmdldCBUaGUgY3VycmVudCBldmVudCB0YXJnZXQuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGNhbmNlbGVkIFRoZSBmbGFnIHRvIHByZXZlbnQgZGVmYXVsdC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gc3RvcHBlZCBUaGUgZmxhZyB0byBzdG9wIHByb3BhZ2F0aW9uLlxuICogQHByb3BlcnR5IHtib29sZWFufSBpbW1lZGlhdGVTdG9wcGVkIFRoZSBmbGFnIHRvIHN0b3AgcHJvcGFnYXRpb24gaW1tZWRpYXRlbHkuXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufG51bGx9IHBhc3NpdmVMaXN0ZW5lciBUaGUgbGlzdGVuZXIgaWYgdGhlIGN1cnJlbnQgbGlzdGVuZXIgaXMgcGFzc2l2ZS4gT3RoZXJ3aXNlIHRoaXMgaXMgbnVsbC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0aW1lU3RhbXAgVGhlIHVuaXggdGltZS5cbiAqIEBwcml2YXRlXG4gKi9cblxuLyoqXG4gKiBQcml2YXRlIGRhdGEgZm9yIGV2ZW50IHdyYXBwZXJzLlxuICogQHR5cGUge1dlYWtNYXA8RXZlbnQsIFByaXZhdGVEYXRhPn1cbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IHByaXZhdGVEYXRhID0gbmV3IFdlYWtNYXAoKVxuXG4vKipcbiAqIENhY2hlIGZvciB3cmFwcGVyIGNsYXNzZXMuXG4gKiBAdHlwZSB7V2Vha01hcDxPYmplY3QsIEZ1bmN0aW9uPn1cbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IHdyYXBwZXJzID0gbmV3IFdlYWtNYXAoKVxuXG4vKipcbiAqIEdldCBwcml2YXRlIGRhdGEuXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudCBUaGUgZXZlbnQgb2JqZWN0IHRvIGdldCBwcml2YXRlIGRhdGEuXG4gKiBAcmV0dXJucyB7UHJpdmF0ZURhdGF9IFRoZSBwcml2YXRlIGRhdGEgb2YgdGhlIGV2ZW50LlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcGQoZXZlbnQpIHtcbiAgICBjb25zdCByZXR2ID0gcHJpdmF0ZURhdGEuZ2V0KGV2ZW50KVxuICAgIGNvbnNvbGUuYXNzZXJ0KFxuICAgICAgICByZXR2ICE9IG51bGwsXG4gICAgICAgIFwiJ3RoaXMnIGlzIGV4cGVjdGVkIGFuIEV2ZW50IG9iamVjdCwgYnV0IGdvdFwiLFxuICAgICAgICBldmVudFxuICAgIClcbiAgICByZXR1cm4gcmV0dlxufVxuXG4vKipcbiAqIGh0dHBzOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jc2V0LXRoZS1jYW5jZWxlZC1mbGFnXG4gKiBAcGFyYW0gZGF0YSB7UHJpdmF0ZURhdGF9IHByaXZhdGUgZGF0YS5cbiAqL1xuZnVuY3Rpb24gc2V0Q2FuY2VsRmxhZyhkYXRhKSB7XG4gICAgaWYgKGRhdGEucGFzc2l2ZUxpc3RlbmVyICE9IG51bGwpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgdHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgICAgIHR5cGVvZiBjb25zb2xlLmVycm9yID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIFwiVW5hYmxlIHRvIHByZXZlbnREZWZhdWx0IGluc2lkZSBwYXNzaXZlIGV2ZW50IGxpc3RlbmVyIGludm9jYXRpb24uXCIsXG4gICAgICAgICAgICAgICAgZGF0YS5wYXNzaXZlTGlzdGVuZXJcbiAgICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgICByZXR1cm5cbiAgICB9XG4gICAgaWYgKCFkYXRhLmV2ZW50LmNhbmNlbGFibGUpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgZGF0YS5jYW5jZWxlZCA9IHRydWVcbiAgICBpZiAodHlwZW9mIGRhdGEuZXZlbnQucHJldmVudERlZmF1bHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBkYXRhLmV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgICB9XG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI2ludGVyZmFjZS1ldmVudFxuICogQHByaXZhdGVcbiAqL1xuLyoqXG4gKiBUaGUgZXZlbnQgd3JhcHBlci5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtFdmVudFRhcmdldH0gZXZlbnRUYXJnZXQgVGhlIGV2ZW50IHRhcmdldCBvZiB0aGlzIGRpc3BhdGNoaW5nLlxuICogQHBhcmFtIHtFdmVudHx7dHlwZTpzdHJpbmd9fSBldmVudCBUaGUgb3JpZ2luYWwgZXZlbnQgdG8gd3JhcC5cbiAqL1xuZnVuY3Rpb24gRXZlbnQoZXZlbnRUYXJnZXQsIGV2ZW50KSB7XG4gICAgcHJpdmF0ZURhdGEuc2V0KHRoaXMsIHtcbiAgICAgICAgZXZlbnRUYXJnZXQsXG4gICAgICAgIGV2ZW50LFxuICAgICAgICBldmVudFBoYXNlOiAyLFxuICAgICAgICBjdXJyZW50VGFyZ2V0OiBldmVudFRhcmdldCxcbiAgICAgICAgY2FuY2VsZWQ6IGZhbHNlLFxuICAgICAgICBzdG9wcGVkOiBmYWxzZSxcbiAgICAgICAgaW1tZWRpYXRlU3RvcHBlZDogZmFsc2UsXG4gICAgICAgIHBhc3NpdmVMaXN0ZW5lcjogbnVsbCxcbiAgICAgICAgdGltZVN0YW1wOiBldmVudC50aW1lU3RhbXAgfHwgRGF0ZS5ub3coKSxcbiAgICB9KVxuXG4gICAgLy8gaHR0cHM6Ly9oZXljYW0uZ2l0aHViLmlvL3dlYmlkbC8jVW5mb3JnZWFibGVcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpc1RydXN0ZWRcIiwgeyB2YWx1ZTogZmFsc2UsIGVudW1lcmFibGU6IHRydWUgfSlcblxuICAgIC8vIERlZmluZSBhY2Nlc3NvcnNcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZXZlbnQpXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGtleXNbaV1cbiAgICAgICAgaWYgKCEoa2V5IGluIHRoaXMpKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywga2V5LCBkZWZpbmVSZWRpcmVjdERlc2NyaXB0b3Ioa2V5KSlcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy8gU2hvdWxkIGJlIGVudW1lcmFibGUsIGJ1dCBjbGFzcyBtZXRob2RzIGFyZSBub3QgZW51bWVyYWJsZS5cbkV2ZW50LnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBvZiB0aGlzIGV2ZW50LlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0IHR5cGUoKSB7XG4gICAgICAgIHJldHVybiBwZCh0aGlzKS5ldmVudC50eXBlXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSB0YXJnZXQgb2YgdGhpcyBldmVudC5cbiAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR9XG4gICAgICovXG4gICAgZ2V0IHRhcmdldCgpIHtcbiAgICAgICAgcmV0dXJuIHBkKHRoaXMpLmV2ZW50VGFyZ2V0XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSB0YXJnZXQgb2YgdGhpcyBldmVudC5cbiAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR9XG4gICAgICovXG4gICAgZ2V0IGN1cnJlbnRUYXJnZXQoKSB7XG4gICAgICAgIHJldHVybiBwZCh0aGlzKS5jdXJyZW50VGFyZ2V0XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtFdmVudFRhcmdldFtdfSBUaGUgY29tcG9zZWQgcGF0aCBvZiB0aGlzIGV2ZW50LlxuICAgICAqL1xuICAgIGNvbXBvc2VkUGF0aCgpIHtcbiAgICAgICAgY29uc3QgY3VycmVudFRhcmdldCA9IHBkKHRoaXMpLmN1cnJlbnRUYXJnZXRcbiAgICAgICAgaWYgKGN1cnJlbnRUYXJnZXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtjdXJyZW50VGFyZ2V0XVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb25zdGFudCBvZiBOT05FLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IE5PTkUoKSB7XG4gICAgICAgIHJldHVybiAwXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnN0YW50IG9mIENBUFRVUklOR19QSEFTRS5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBDQVBUVVJJTkdfUEhBU0UoKSB7XG4gICAgICAgIHJldHVybiAxXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnN0YW50IG9mIEFUX1RBUkdFVC5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBBVF9UQVJHRVQoKSB7XG4gICAgICAgIHJldHVybiAyXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnN0YW50IG9mIEJVQkJMSU5HX1BIQVNFLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IEJVQkJMSU5HX1BIQVNFKCkge1xuICAgICAgICByZXR1cm4gM1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgdGFyZ2V0IG9mIHRoaXMgZXZlbnQuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgZXZlbnRQaGFzZSgpIHtcbiAgICAgICAgcmV0dXJuIHBkKHRoaXMpLmV2ZW50UGhhc2VcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3RvcCBldmVudCBidWJibGluZy5cbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBzdG9wUHJvcGFnYXRpb24oKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBwZCh0aGlzKVxuXG4gICAgICAgIGRhdGEuc3RvcHBlZCA9IHRydWVcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhLmV2ZW50LnN0b3BQcm9wYWdhdGlvbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBkYXRhLmV2ZW50LnN0b3BQcm9wYWdhdGlvbigpXG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3RvcCBldmVudCBidWJibGluZy5cbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBwZCh0aGlzKVxuXG4gICAgICAgIGRhdGEuc3RvcHBlZCA9IHRydWVcbiAgICAgICAgZGF0YS5pbW1lZGlhdGVTdG9wcGVkID0gdHJ1ZVxuICAgICAgICBpZiAodHlwZW9mIGRhdGEuZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGRhdGEuZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKClcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZmxhZyB0byBiZSBidWJibGluZy5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBnZXQgYnViYmxlcygpIHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4ocGQodGhpcykuZXZlbnQuYnViYmxlcylcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIGZsYWcgdG8gYmUgY2FuY2VsYWJsZS5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBnZXQgY2FuY2VsYWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4ocGQodGhpcykuZXZlbnQuY2FuY2VsYWJsZSlcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FuY2VsIHRoaXMgZXZlbnQuXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgcHJldmVudERlZmF1bHQoKSB7XG4gICAgICAgIHNldENhbmNlbEZsYWcocGQodGhpcykpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBmbGFnIHRvIGluZGljYXRlIGNhbmNlbGxhdGlvbiBzdGF0ZS5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBnZXQgZGVmYXVsdFByZXZlbnRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHBkKHRoaXMpLmNhbmNlbGVkXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBmbGFnIHRvIGJlIGNvbXBvc2VkLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIGdldCBjb21wb3NlZCgpIHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4ocGQodGhpcykuZXZlbnQuY29tcG9zZWQpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSB1bml4IHRpbWUgb2YgdGhpcyBldmVudC5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCB0aW1lU3RhbXAoKSB7XG4gICAgICAgIHJldHVybiBwZCh0aGlzKS50aW1lU3RhbXBcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIHRhcmdldCBvZiB0aGlzIGV2ZW50LlxuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH1cbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqL1xuICAgIGdldCBzcmNFbGVtZW50KCkge1xuICAgICAgICByZXR1cm4gcGQodGhpcykuZXZlbnRUYXJnZXRcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIGZsYWcgdG8gc3RvcCBldmVudCBidWJibGluZy5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqL1xuICAgIGdldCBjYW5jZWxCdWJibGUoKSB7XG4gICAgICAgIHJldHVybiBwZCh0aGlzKS5zdG9wcGVkXG4gICAgfSxcbiAgICBzZXQgY2FuY2VsQnViYmxlKHZhbHVlKSB7XG4gICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGEgPSBwZCh0aGlzKVxuXG4gICAgICAgIGRhdGEuc3RvcHBlZCA9IHRydWVcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhLmV2ZW50LmNhbmNlbEJ1YmJsZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgIGRhdGEuZXZlbnQuY2FuY2VsQnViYmxlID0gdHJ1ZVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBmbGFnIHRvIGluZGljYXRlIGNhbmNlbGxhdGlvbiBzdGF0ZS5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqL1xuICAgIGdldCByZXR1cm5WYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuICFwZCh0aGlzKS5jYW5jZWxlZFxuICAgIH0sXG4gICAgc2V0IHJldHVyblZhbHVlKHZhbHVlKSB7XG4gICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgIHNldENhbmNlbEZsYWcocGQodGhpcykpXG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSB0aGlzIGV2ZW50IG9iamVjdC4gQnV0IGRvIG5vdGhpbmcgdW5kZXIgZXZlbnQgZGlzcGF0Y2hpbmcuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgVGhlIGV2ZW50IHR5cGUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbYnViYmxlcz1mYWxzZV0gVGhlIGZsYWcgdG8gYmUgcG9zc2libGUgdG8gYnViYmxlIHVwLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2NhbmNlbGFibGU9ZmFsc2VdIFRoZSBmbGFnIHRvIGJlIHBvc3NpYmxlIHRvIGNhbmNlbC5cbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqL1xuICAgIGluaXRFdmVudCgpIHtcbiAgICAgICAgLy8gRG8gbm90aGluZy5cbiAgICB9LFxufVxuXG4vLyBgY29uc3RydWN0b3JgIGlzIG5vdCBlbnVtZXJhYmxlLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50LnByb3RvdHlwZSwgXCJjb25zdHJ1Y3RvclwiLCB7XG4gICAgdmFsdWU6IEV2ZW50LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbn0pXG5cbi8vIEVuc3VyZSBgZXZlbnQgaW5zdGFuY2VvZiB3aW5kb3cuRXZlbnRgIGlzIGB0cnVlYC5cbmlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiB3aW5kb3cuRXZlbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoRXZlbnQucHJvdG90eXBlLCB3aW5kb3cuRXZlbnQucHJvdG90eXBlKVxuXG4gICAgLy8gTWFrZSBhc3NvY2lhdGlvbiBmb3Igd3JhcHBlcnMuXG4gICAgd3JhcHBlcnMuc2V0KHdpbmRvdy5FdmVudC5wcm90b3R5cGUsIEV2ZW50KVxufVxuXG4vKipcbiAqIEdldCB0aGUgcHJvcGVydHkgZGVzY3JpcHRvciB0byByZWRpcmVjdCBhIGdpdmVuIHByb3BlcnR5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBQcm9wZXJ0eSBuYW1lIHRvIGRlZmluZSBwcm9wZXJ0eSBkZXNjcmlwdG9yLlxuICogQHJldHVybnMge1Byb3BlcnR5RGVzY3JpcHRvcn0gVGhlIHByb3BlcnR5IGRlc2NyaXB0b3IgdG8gcmVkaXJlY3QgdGhlIHByb3BlcnR5LlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZGVmaW5lUmVkaXJlY3REZXNjcmlwdG9yKGtleSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiBwZCh0aGlzKS5ldmVudFtrZXldXG4gICAgICAgIH0sXG4gICAgICAgIHNldCh2YWx1ZSkge1xuICAgICAgICAgICAgcGQodGhpcykuZXZlbnRba2V5XSA9IHZhbHVlXG4gICAgICAgIH0sXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICB9XG59XG5cbi8qKlxuICogR2V0IHRoZSBwcm9wZXJ0eSBkZXNjcmlwdG9yIHRvIGNhbGwgYSBnaXZlbiBtZXRob2QgcHJvcGVydHkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFByb3BlcnR5IG5hbWUgdG8gZGVmaW5lIHByb3BlcnR5IGRlc2NyaXB0b3IuXG4gKiBAcmV0dXJucyB7UHJvcGVydHlEZXNjcmlwdG9yfSBUaGUgcHJvcGVydHkgZGVzY3JpcHRvciB0byBjYWxsIHRoZSBtZXRob2QgcHJvcGVydHkuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBkZWZpbmVDYWxsRGVzY3JpcHRvcihrZXkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZSgpIHtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0gcGQodGhpcykuZXZlbnRcbiAgICAgICAgICAgIHJldHVybiBldmVudFtrZXldLmFwcGx5KGV2ZW50LCBhcmd1bWVudHMpXG4gICAgICAgIH0sXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICB9XG59XG5cbi8qKlxuICogRGVmaW5lIG5ldyB3cmFwcGVyIGNsYXNzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gQmFzZUV2ZW50IFRoZSBiYXNlIHdyYXBwZXIgY2xhc3MuXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvdG8gVGhlIHByb3RvdHlwZSBvZiB0aGUgb3JpZ2luYWwgZXZlbnQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFRoZSBkZWZpbmVkIHdyYXBwZXIgY2xhc3MuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBkZWZpbmVXcmFwcGVyKEJhc2VFdmVudCwgcHJvdG8pIHtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMocHJvdG8pXG4gICAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCYXNlRXZlbnRcbiAgICB9XG5cbiAgICAvKiogQ3VzdG9tRXZlbnQgKi9cbiAgICBmdW5jdGlvbiBDdXN0b21FdmVudChldmVudFRhcmdldCwgZXZlbnQpIHtcbiAgICAgICAgQmFzZUV2ZW50LmNhbGwodGhpcywgZXZlbnRUYXJnZXQsIGV2ZW50KVxuICAgIH1cblxuICAgIEN1c3RvbUV2ZW50LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQmFzZUV2ZW50LnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogQ3VzdG9tRXZlbnQsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSxcbiAgICB9KVxuXG4gICAgLy8gRGVmaW5lIGFjY2Vzc29ycy5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXVxuICAgICAgICBpZiAoIShrZXkgaW4gQmFzZUV2ZW50LnByb3RvdHlwZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHByb3RvLCBrZXkpXG4gICAgICAgICAgICBjb25zdCBpc0Z1bmMgPSB0eXBlb2YgZGVzY3JpcHRvci52YWx1ZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoXG4gICAgICAgICAgICAgICAgQ3VzdG9tRXZlbnQucHJvdG90eXBlLFxuICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICBpc0Z1bmNcbiAgICAgICAgICAgICAgICAgICAgPyBkZWZpbmVDYWxsRGVzY3JpcHRvcihrZXkpXG4gICAgICAgICAgICAgICAgICAgIDogZGVmaW5lUmVkaXJlY3REZXNjcmlwdG9yKGtleSlcbiAgICAgICAgICAgIClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBDdXN0b21FdmVudFxufVxuXG4vKipcbiAqIEdldCB0aGUgd3JhcHBlciBjbGFzcyBvZiBhIGdpdmVuIHByb3RvdHlwZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm90byBUaGUgcHJvdG90eXBlIG9mIHRoZSBvcmlnaW5hbCBldmVudCB0byBnZXQgaXRzIHdyYXBwZXIuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFRoZSB3cmFwcGVyIGNsYXNzLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZ2V0V3JhcHBlcihwcm90bykge1xuICAgIGlmIChwcm90byA9PSBudWxsIHx8IHByb3RvID09PSBPYmplY3QucHJvdG90eXBlKSB7XG4gICAgICAgIHJldHVybiBFdmVudFxuICAgIH1cblxuICAgIGxldCB3cmFwcGVyID0gd3JhcHBlcnMuZ2V0KHByb3RvKVxuICAgIGlmICh3cmFwcGVyID09IG51bGwpIHtcbiAgICAgICAgd3JhcHBlciA9IGRlZmluZVdyYXBwZXIoZ2V0V3JhcHBlcihPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pKSwgcHJvdG8pXG4gICAgICAgIHdyYXBwZXJzLnNldChwcm90bywgd3JhcHBlcilcbiAgICB9XG4gICAgcmV0dXJuIHdyYXBwZXJcbn1cblxuLyoqXG4gKiBXcmFwIGEgZ2l2ZW4gZXZlbnQgdG8gbWFuYWdlbWVudCBhIGRpc3BhdGNoaW5nLlxuICogQHBhcmFtIHtFdmVudFRhcmdldH0gZXZlbnRUYXJnZXQgVGhlIGV2ZW50IHRhcmdldCBvZiB0aGlzIGRpc3BhdGNoaW5nLlxuICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFRoZSBldmVudCB0byB3cmFwLlxuICogQHJldHVybnMge0V2ZW50fSBUaGUgd3JhcHBlciBpbnN0YW5jZS5cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3cmFwRXZlbnQoZXZlbnRUYXJnZXQsIGV2ZW50KSB7XG4gICAgY29uc3QgV3JhcHBlciA9IGdldFdyYXBwZXIoT2JqZWN0LmdldFByb3RvdHlwZU9mKGV2ZW50KSlcbiAgICByZXR1cm4gbmV3IFdyYXBwZXIoZXZlbnRUYXJnZXQsIGV2ZW50KVxufVxuXG4vKipcbiAqIEdldCB0aGUgaW1tZWRpYXRlU3RvcHBlZCBmbGFnIG9mIGEgZ2l2ZW4gZXZlbnQuXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudCBUaGUgZXZlbnQgdG8gZ2V0LlxuICogQHJldHVybnMge2Jvb2xlYW59IFRoZSBmbGFnIHRvIHN0b3AgcHJvcGFnYXRpb24gaW1tZWRpYXRlbHkuXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNTdG9wcGVkKGV2ZW50KSB7XG4gICAgcmV0dXJuIHBkKGV2ZW50KS5pbW1lZGlhdGVTdG9wcGVkXG59XG5cbi8qKlxuICogU2V0IHRoZSBjdXJyZW50IGV2ZW50IHBoYXNlIG9mIGEgZ2l2ZW4gZXZlbnQuXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudCBUaGUgZXZlbnQgdG8gc2V0IGN1cnJlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtudW1iZXJ9IGV2ZW50UGhhc2UgTmV3IGV2ZW50IHBoYXNlLlxuICogQHJldHVybnMge3ZvaWR9XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0RXZlbnRQaGFzZShldmVudCwgZXZlbnRQaGFzZSkge1xuICAgIHBkKGV2ZW50KS5ldmVudFBoYXNlID0gZXZlbnRQaGFzZVxufVxuXG4vKipcbiAqIFNldCB0aGUgY3VycmVudCB0YXJnZXQgb2YgYSBnaXZlbiBldmVudC5cbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IFRoZSBldmVudCB0byBzZXQgY3VycmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fG51bGx9IGN1cnJlbnRUYXJnZXQgTmV3IGN1cnJlbnQgdGFyZ2V0LlxuICogQHJldHVybnMge3ZvaWR9XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0Q3VycmVudFRhcmdldChldmVudCwgY3VycmVudFRhcmdldCkge1xuICAgIHBkKGV2ZW50KS5jdXJyZW50VGFyZ2V0ID0gY3VycmVudFRhcmdldFxufVxuXG4vKipcbiAqIFNldCBhIHBhc3NpdmUgbGlzdGVuZXIgb2YgYSBnaXZlbiBldmVudC5cbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IFRoZSBldmVudCB0byBzZXQgY3VycmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufG51bGx9IHBhc3NpdmVMaXN0ZW5lciBOZXcgcGFzc2l2ZSBsaXN0ZW5lci5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldFBhc3NpdmVMaXN0ZW5lcihldmVudCwgcGFzc2l2ZUxpc3RlbmVyKSB7XG4gICAgcGQoZXZlbnQpLnBhc3NpdmVMaXN0ZW5lciA9IHBhc3NpdmVMaXN0ZW5lclxufVxuIiwgImltcG9ydCB7XG4gICAgaXNTdG9wcGVkLFxuICAgIHNldEN1cnJlbnRUYXJnZXQsXG4gICAgc2V0RXZlbnRQaGFzZSxcbiAgICBzZXRQYXNzaXZlTGlzdGVuZXIsXG4gICAgd3JhcEV2ZW50LFxufSBmcm9tIFwiLi9ldmVudC5tanNcIlxuXG4vKipcbiAqIEB0eXBlZGVmIHtvYmplY3R9IExpc3RlbmVyTm9kZVxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gbGlzdGVuZXJcbiAqIEBwcm9wZXJ0eSB7MXwyfDN9IGxpc3RlbmVyVHlwZVxuICogQHByb3BlcnR5IHtib29sZWFufSBwYXNzaXZlXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IG9uY2VcbiAqIEBwcm9wZXJ0eSB7TGlzdGVuZXJOb2RlfG51bGx9IG5leHRcbiAqIEBwcml2YXRlXG4gKi9cblxuLyoqXG4gKiBAdHlwZSB7V2Vha01hcDxvYmplY3QsIE1hcDxzdHJpbmcsIExpc3RlbmVyTm9kZT4+fVxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgbGlzdGVuZXJzTWFwID0gbmV3IFdlYWtNYXAoKVxuXG4vLyBMaXN0ZW5lciB0eXBlc1xuY29uc3QgQ0FQVFVSRSA9IDFcbmNvbnN0IEJVQkJMRSA9IDJcbmNvbnN0IEFUVFJJQlVURSA9IDNcblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIGEgZ2l2ZW4gdmFsdWUgaXMgYW4gb2JqZWN0IG9yIG5vdC5cbiAqIEBwYXJhbSB7YW55fSB4IFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIHZhbHVlIGlzIGFuIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QoeCkge1xuICAgIHJldHVybiB4ICE9PSBudWxsICYmIHR5cGVvZiB4ID09PSBcIm9iamVjdFwiIC8vZXNsaW50LWRpc2FibGUtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxufVxuXG4vKipcbiAqIEdldCBsaXN0ZW5lcnMuXG4gKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSBldmVudFRhcmdldCBUaGUgZXZlbnQgdGFyZ2V0IHRvIGdldC5cbiAqIEByZXR1cm5zIHtNYXA8c3RyaW5nLCBMaXN0ZW5lck5vZGU+fSBUaGUgbGlzdGVuZXJzLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZ2V0TGlzdGVuZXJzKGV2ZW50VGFyZ2V0KSB7XG4gICAgY29uc3QgbGlzdGVuZXJzID0gbGlzdGVuZXJzTWFwLmdldChldmVudFRhcmdldClcbiAgICBpZiAobGlzdGVuZXJzID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgIFwiJ3RoaXMnIGlzIGV4cGVjdGVkIGFuIEV2ZW50VGFyZ2V0IG9iamVjdCwgYnV0IGdvdCBhbm90aGVyIHZhbHVlLlwiXG4gICAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIGxpc3RlbmVyc1xufVxuXG4vKipcbiAqIEdldCB0aGUgcHJvcGVydHkgZGVzY3JpcHRvciBmb3IgdGhlIGV2ZW50IGF0dHJpYnV0ZSBvZiBhIGdpdmVuIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBUaGUgZXZlbnQgbmFtZSB0byBnZXQgcHJvcGVydHkgZGVzY3JpcHRvci5cbiAqIEByZXR1cm5zIHtQcm9wZXJ0eURlc2NyaXB0b3J9IFRoZSBwcm9wZXJ0eSBkZXNjcmlwdG9yLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZGVmaW5lRXZlbnRBdHRyaWJ1dGVEZXNjcmlwdG9yKGV2ZW50TmFtZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IGdldExpc3RlbmVycyh0aGlzKVxuICAgICAgICAgICAgbGV0IG5vZGUgPSBsaXN0ZW5lcnMuZ2V0KGV2ZW50TmFtZSlcbiAgICAgICAgICAgIHdoaWxlIChub2RlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5saXN0ZW5lclR5cGUgPT09IEFUVFJJQlVURSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5saXN0ZW5lclxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5uZXh0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICB9LFxuXG4gICAgICAgIHNldChsaXN0ZW5lcikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gXCJmdW5jdGlvblwiICYmICFpc09iamVjdChsaXN0ZW5lcikpIHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lciA9IG51bGwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gZ2V0TGlzdGVuZXJzKHRoaXMpXG5cbiAgICAgICAgICAgIC8vIFRyYXZlcnNlIHRvIHRoZSB0YWlsIHdoaWxlIHJlbW92aW5nIG9sZCB2YWx1ZS5cbiAgICAgICAgICAgIGxldCBwcmV2ID0gbnVsbFxuICAgICAgICAgICAgbGV0IG5vZGUgPSBsaXN0ZW5lcnMuZ2V0KGV2ZW50TmFtZSlcbiAgICAgICAgICAgIHdoaWxlIChub2RlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5saXN0ZW5lclR5cGUgPT09IEFUVFJJQlVURSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgb2xkIHZhbHVlLlxuICAgICAgICAgICAgICAgICAgICBpZiAocHJldiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJldi5uZXh0ID0gbm9kZS5uZXh0XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobm9kZS5uZXh0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuc2V0KGV2ZW50TmFtZSwgbm9kZS5uZXh0KVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLmRlbGV0ZShldmVudE5hbWUpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwcmV2ID0gbm9kZVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLm5leHRcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQWRkIG5ldyB2YWx1ZS5cbiAgICAgICAgICAgIGlmIChsaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld05vZGUgPSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLFxuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lclR5cGU6IEFUVFJJQlVURSxcbiAgICAgICAgICAgICAgICAgICAgcGFzc2l2ZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIG9uY2U6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBuZXh0OiBudWxsLFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocHJldiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuc2V0KGV2ZW50TmFtZSwgbmV3Tm9kZSlcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwcmV2Lm5leHQgPSBuZXdOb2RlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgfVxufVxuXG4vKipcbiAqIERlZmluZSBhbiBldmVudCBhdHRyaWJ1dGUgKGUuZy4gYGV2ZW50VGFyZ2V0Lm9uY2xpY2tgKS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFRhcmdldFByb3RvdHlwZSBUaGUgZXZlbnQgdGFyZ2V0IHByb3RvdHlwZSB0byBkZWZpbmUgYW4gZXZlbnQgYXR0cmJpdGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIFRoZSBldmVudCBuYW1lIHRvIGRlZmluZS5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiBkZWZpbmVFdmVudEF0dHJpYnV0ZShldmVudFRhcmdldFByb3RvdHlwZSwgZXZlbnROYW1lKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFxuICAgICAgICBldmVudFRhcmdldFByb3RvdHlwZSxcbiAgICAgICAgYG9uJHtldmVudE5hbWV9YCxcbiAgICAgICAgZGVmaW5lRXZlbnRBdHRyaWJ1dGVEZXNjcmlwdG9yKGV2ZW50TmFtZSlcbiAgICApXG59XG5cbi8qKlxuICogRGVmaW5lIGEgY3VzdG9tIEV2ZW50VGFyZ2V0IHdpdGggZXZlbnQgYXR0cmlidXRlcy5cbiAqIEBwYXJhbSB7c3RyaW5nW119IGV2ZW50TmFtZXMgRXZlbnQgbmFtZXMgZm9yIGV2ZW50IGF0dHJpYnV0ZXMuXG4gKiBAcmV0dXJucyB7RXZlbnRUYXJnZXR9IFRoZSBjdXN0b20gRXZlbnRUYXJnZXQuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBkZWZpbmVDdXN0b21FdmVudFRhcmdldChldmVudE5hbWVzKSB7XG4gICAgLyoqIEN1c3RvbUV2ZW50VGFyZ2V0ICovXG4gICAgZnVuY3Rpb24gQ3VzdG9tRXZlbnRUYXJnZXQoKSB7XG4gICAgICAgIEV2ZW50VGFyZ2V0LmNhbGwodGhpcylcbiAgICB9XG5cbiAgICBDdXN0b21FdmVudFRhcmdldC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEV2ZW50VGFyZ2V0LnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgICAgdmFsdWU6IEN1c3RvbUV2ZW50VGFyZ2V0LFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIH0sXG4gICAgfSlcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXZlbnROYW1lcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBkZWZpbmVFdmVudEF0dHJpYnV0ZShDdXN0b21FdmVudFRhcmdldC5wcm90b3R5cGUsIGV2ZW50TmFtZXNbaV0pXG4gICAgfVxuXG4gICAgcmV0dXJuIEN1c3RvbUV2ZW50VGFyZ2V0XG59XG5cbi8qKlxuICogRXZlbnRUYXJnZXQuXG4gKlxuICogLSBUaGlzIGlzIGNvbnN0cnVjdG9yIGlmIG5vIGFyZ3VtZW50cy5cbiAqIC0gVGhpcyBpcyBhIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYSBDdXN0b21FdmVudFRhcmdldCBjb25zdHJ1Y3RvciBpZiB0aGVyZSBhcmUgYXJndW1lbnRzLlxuICpcbiAqIEZvciBleGFtcGxlOlxuICpcbiAqICAgICBjbGFzcyBBIGV4dGVuZHMgRXZlbnRUYXJnZXQge31cbiAqICAgICBjbGFzcyBCIGV4dGVuZHMgRXZlbnRUYXJnZXQoXCJtZXNzYWdlXCIpIHt9XG4gKiAgICAgY2xhc3MgQyBleHRlbmRzIEV2ZW50VGFyZ2V0KFwibWVzc2FnZVwiLCBcImVycm9yXCIpIHt9XG4gKiAgICAgY2xhc3MgRCBleHRlbmRzIEV2ZW50VGFyZ2V0KFtcIm1lc3NhZ2VcIiwgXCJlcnJvclwiXSkge31cbiAqL1xuZnVuY3Rpb24gRXZlbnRUYXJnZXQoKSB7XG4gICAgLyplc2xpbnQtZGlzYWJsZSBjb25zaXN0ZW50LXJldHVybiAqL1xuICAgIGlmICh0aGlzIGluc3RhbmNlb2YgRXZlbnRUYXJnZXQpIHtcbiAgICAgICAgbGlzdGVuZXJzTWFwLnNldCh0aGlzLCBuZXcgTWFwKCkpXG4gICAgICAgIHJldHVyblxuICAgIH1cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiBBcnJheS5pc0FycmF5KGFyZ3VtZW50c1swXSkpIHtcbiAgICAgICAgcmV0dXJuIGRlZmluZUN1c3RvbUV2ZW50VGFyZ2V0KGFyZ3VtZW50c1swXSlcbiAgICB9XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IHR5cGVzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB0eXBlc1tpXSA9IGFyZ3VtZW50c1tpXVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWZpbmVDdXN0b21FdmVudFRhcmdldCh0eXBlcylcbiAgICB9XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKVxuICAgIC8qZXNsaW50LWVuYWJsZSBjb25zaXN0ZW50LXJldHVybiAqL1xufVxuXG4vLyBTaG91bGQgYmUgZW51bWVyYWJsZSwgYnV0IGNsYXNzIG1ldGhvZHMgYXJlIG5vdCBlbnVtZXJhYmxlLlxuRXZlbnRUYXJnZXQucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIEFkZCBhIGdpdmVuIGxpc3RlbmVyIHRvIHRoaXMgZXZlbnQgdGFyZ2V0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgVGhlIGV2ZW50IG5hbWUgdG8gYWRkLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyIFRoZSBsaXN0ZW5lciB0byBhZGQuXG4gICAgICogQHBhcmFtIHtib29sZWFufHtjYXB0dXJlPzpib29sZWFuLHBhc3NpdmU/OmJvb2xlYW4sb25jZT86Ym9vbGVhbn19IFtvcHRpb25zXSBUaGUgb3B0aW9ucyBmb3IgdGhpcyBsaXN0ZW5lci5cbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBhZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGxpc3RlbmVyID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09IFwiZnVuY3Rpb25cIiAmJiAhaXNPYmplY3QobGlzdGVuZXIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ2xpc3RlbmVyJyBzaG91bGQgYmUgYSBmdW5jdGlvbiBvciBhbiBvYmplY3QuXCIpXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBsaXN0ZW5lcnMgPSBnZXRMaXN0ZW5lcnModGhpcylcbiAgICAgICAgY29uc3Qgb3B0aW9uc0lzT2JqID0gaXNPYmplY3Qob3B0aW9ucylcbiAgICAgICAgY29uc3QgY2FwdHVyZSA9IG9wdGlvbnNJc09ialxuICAgICAgICAgICAgPyBCb29sZWFuKG9wdGlvbnMuY2FwdHVyZSlcbiAgICAgICAgICAgIDogQm9vbGVhbihvcHRpb25zKVxuICAgICAgICBjb25zdCBsaXN0ZW5lclR5cGUgPSBjYXB0dXJlID8gQ0FQVFVSRSA6IEJVQkJMRVxuICAgICAgICBjb25zdCBuZXdOb2RlID0ge1xuICAgICAgICAgICAgbGlzdGVuZXIsXG4gICAgICAgICAgICBsaXN0ZW5lclR5cGUsXG4gICAgICAgICAgICBwYXNzaXZlOiBvcHRpb25zSXNPYmogJiYgQm9vbGVhbihvcHRpb25zLnBhc3NpdmUpLFxuICAgICAgICAgICAgb25jZTogb3B0aW9uc0lzT2JqICYmIEJvb2xlYW4ob3B0aW9ucy5vbmNlKSxcbiAgICAgICAgICAgIG5leHQ6IG51bGwsXG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZXQgaXQgYXMgdGhlIGZpcnN0IG5vZGUgaWYgdGhlIGZpcnN0IG5vZGUgaXMgbnVsbC5cbiAgICAgICAgbGV0IG5vZGUgPSBsaXN0ZW5lcnMuZ2V0KGV2ZW50TmFtZSlcbiAgICAgICAgaWYgKG5vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGlzdGVuZXJzLnNldChldmVudE5hbWUsIG5ld05vZGUpXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRyYXZlcnNlIHRvIHRoZSB0YWlsIHdoaWxlIGNoZWNraW5nIGR1cGxpY2F0aW9uLi5cbiAgICAgICAgbGV0IHByZXYgPSBudWxsXG4gICAgICAgIHdoaWxlIChub2RlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBub2RlLmxpc3RlbmVyID09PSBsaXN0ZW5lciAmJlxuICAgICAgICAgICAgICAgIG5vZGUubGlzdGVuZXJUeXBlID09PSBsaXN0ZW5lclR5cGVcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIC8vIFNob3VsZCBpZ25vcmUgZHVwbGljYXRpb24uXG4gICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmV2ID0gbm9kZVxuICAgICAgICAgICAgbm9kZSA9IG5vZGUubmV4dFxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWRkIGl0LlxuICAgICAgICBwcmV2Lm5leHQgPSBuZXdOb2RlXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhIGdpdmVuIGxpc3RlbmVyIGZyb20gdGhpcyBldmVudCB0YXJnZXQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBUaGUgZXZlbnQgbmFtZSB0byByZW1vdmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgVGhlIGxpc3RlbmVyIHRvIHJlbW92ZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW58e2NhcHR1cmU/OmJvb2xlYW4scGFzc2l2ZT86Ym9vbGVhbixvbmNlPzpib29sZWFufX0gW29wdGlvbnNdIFRoZSBvcHRpb25zIGZvciB0aGlzIGxpc3RlbmVyLlxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lciwgb3B0aW9ucykge1xuICAgICAgICBpZiAobGlzdGVuZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBsaXN0ZW5lcnMgPSBnZXRMaXN0ZW5lcnModGhpcylcbiAgICAgICAgY29uc3QgY2FwdHVyZSA9IGlzT2JqZWN0KG9wdGlvbnMpXG4gICAgICAgICAgICA/IEJvb2xlYW4ob3B0aW9ucy5jYXB0dXJlKVxuICAgICAgICAgICAgOiBCb29sZWFuKG9wdGlvbnMpXG4gICAgICAgIGNvbnN0IGxpc3RlbmVyVHlwZSA9IGNhcHR1cmUgPyBDQVBUVVJFIDogQlVCQkxFXG5cbiAgICAgICAgbGV0IHByZXYgPSBudWxsXG4gICAgICAgIGxldCBub2RlID0gbGlzdGVuZXJzLmdldChldmVudE5hbWUpXG4gICAgICAgIHdoaWxlIChub2RlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBub2RlLmxpc3RlbmVyID09PSBsaXN0ZW5lciAmJlxuICAgICAgICAgICAgICAgIG5vZGUubGlzdGVuZXJUeXBlID09PSBsaXN0ZW5lclR5cGVcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGlmIChwcmV2ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXYubmV4dCA9IG5vZGUubmV4dFxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobm9kZS5uZXh0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy5zZXQoZXZlbnROYW1lLCBub2RlLm5leHQpXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLmRlbGV0ZShldmVudE5hbWUpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwcmV2ID0gbm9kZVxuICAgICAgICAgICAgbm9kZSA9IG5vZGUubmV4dFxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERpc3BhdGNoIGEgZ2l2ZW4gZXZlbnQuXG4gICAgICogQHBhcmFtIHtFdmVudHx7dHlwZTpzdHJpbmd9fSBldmVudCBUaGUgZXZlbnQgdG8gZGlzcGF0Y2guXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IGBmYWxzZWAgaWYgY2FuY2VsZWQuXG4gICAgICovXG4gICAgZGlzcGF0Y2hFdmVudChldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQgPT0gbnVsbCB8fCB0eXBlb2YgZXZlbnQudHlwZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJldmVudC50eXBlXCIgc2hvdWxkIGJlIGEgc3RyaW5nLicpXG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBsaXN0ZW5lcnMgYXJlbid0IHJlZ2lzdGVyZWQsIHRlcm1pbmF0ZS5cbiAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gZ2V0TGlzdGVuZXJzKHRoaXMpXG4gICAgICAgIGNvbnN0IGV2ZW50TmFtZSA9IGV2ZW50LnR5cGVcbiAgICAgICAgbGV0IG5vZGUgPSBsaXN0ZW5lcnMuZ2V0KGV2ZW50TmFtZSlcbiAgICAgICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNpbmNlIHdlIGNhbm5vdCByZXdyaXRlIHNldmVyYWwgcHJvcGVydGllcywgc28gd3JhcCBvYmplY3QuXG4gICAgICAgIGNvbnN0IHdyYXBwZWRFdmVudCA9IHdyYXBFdmVudCh0aGlzLCBldmVudClcblxuICAgICAgICAvLyBUaGlzIGRvZXNuJ3QgcHJvY2VzcyBjYXB0dXJpbmcgcGhhc2UgYW5kIGJ1YmJsaW5nIHBoYXNlLlxuICAgICAgICAvLyBUaGlzIGlzbid0IHBhcnRpY2lwYXRpbmcgaW4gYSB0cmVlLlxuICAgICAgICBsZXQgcHJldiA9IG51bGxcbiAgICAgICAgd2hpbGUgKG5vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoaXMgbGlzdGVuZXIgaWYgaXQncyBvbmNlXG4gICAgICAgICAgICBpZiAobm9kZS5vbmNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByZXYgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldi5uZXh0ID0gbm9kZS5uZXh0XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChub2RlLm5leHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLnNldChldmVudE5hbWUsIG5vZGUubmV4dClcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuZGVsZXRlKGV2ZW50TmFtZSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHByZXYgPSBub2RlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENhbGwgdGhpcyBsaXN0ZW5lclxuICAgICAgICAgICAgc2V0UGFzc2l2ZUxpc3RlbmVyKFxuICAgICAgICAgICAgICAgIHdyYXBwZWRFdmVudCxcbiAgICAgICAgICAgICAgICBub2RlLnBhc3NpdmUgPyBub2RlLmxpc3RlbmVyIDogbnVsbFxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBub2RlLmxpc3RlbmVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBub2RlLmxpc3RlbmVyLmNhbGwodGhpcywgd3JhcHBlZEV2ZW50KVxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGNvbnNvbGUuZXJyb3IgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICBub2RlLmxpc3RlbmVyVHlwZSAhPT0gQVRUUklCVVRFICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIG5vZGUubGlzdGVuZXIuaGFuZGxlRXZlbnQgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5saXN0ZW5lci5oYW5kbGVFdmVudCh3cmFwcGVkRXZlbnQpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEJyZWFrIGlmIGBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb25gIHdhcyBjYWxsZWQuXG4gICAgICAgICAgICBpZiAoaXNTdG9wcGVkKHdyYXBwZWRFdmVudCkpIHtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBub2RlID0gbm9kZS5uZXh0XG4gICAgICAgIH1cbiAgICAgICAgc2V0UGFzc2l2ZUxpc3RlbmVyKHdyYXBwZWRFdmVudCwgbnVsbClcbiAgICAgICAgc2V0RXZlbnRQaGFzZSh3cmFwcGVkRXZlbnQsIDApXG4gICAgICAgIHNldEN1cnJlbnRUYXJnZXQod3JhcHBlZEV2ZW50LCBudWxsKVxuXG4gICAgICAgIHJldHVybiAhd3JhcHBlZEV2ZW50LmRlZmF1bHRQcmV2ZW50ZWRcbiAgICB9LFxufVxuXG4vLyBgY29uc3RydWN0b3JgIGlzIG5vdCBlbnVtZXJhYmxlLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50VGFyZ2V0LnByb3RvdHlwZSwgXCJjb25zdHJ1Y3RvclwiLCB7XG4gICAgdmFsdWU6IEV2ZW50VGFyZ2V0LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbn0pXG5cbi8vIEVuc3VyZSBgZXZlbnRUYXJnZXQgaW5zdGFuY2VvZiB3aW5kb3cuRXZlbnRUYXJnZXRgIGlzIGB0cnVlYC5cbmlmIChcbiAgICB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgdHlwZW9mIHdpbmRvdy5FdmVudFRhcmdldCAhPT0gXCJ1bmRlZmluZWRcIlxuKSB7XG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKEV2ZW50VGFyZ2V0LnByb3RvdHlwZSwgd2luZG93LkV2ZW50VGFyZ2V0LnByb3RvdHlwZSlcbn1cblxuZXhwb3J0IHsgZGVmaW5lRXZlbnRBdHRyaWJ1dGUsIEV2ZW50VGFyZ2V0IH1cbmV4cG9ydCBkZWZhdWx0IEV2ZW50VGFyZ2V0XG4iLCAiaW1wb3J0IHtcbiAgICAvLyBFdmVudCxcbiAgICBFdmVudFRhcmdldCxcbiAgICAvLyBUeXBlLFxuICAgIGRlZmluZUV2ZW50QXR0cmlidXRlLFxufSBmcm9tIFwiZXZlbnQtdGFyZ2V0LXNoaW1cIlxuXG4vLyBLbm93biBMaW1pdGF0aW9uXG4vLyAgIFVzZSBgYW55YCBiZWNhdXNlIHRoZSB0eXBlIG9mIGBBYm9ydFNpZ25hbGAgaW4gYGxpYi5kb20uZC50c2AgaXMgd3JvbmcgYW5kXG4vLyAgIHRvIG1ha2UgYXNzaWduYWJsZSBvdXIgYEFib3J0U2lnbmFsYCBpbnRvIHRoYXQuXG4vLyAgIGh0dHBzOi8vZ2l0aHViLmNvbS9NaWNyb3NvZnQvVFNKUy1saWItZ2VuZXJhdG9yL3B1bGwvNjIzXG50eXBlIEV2ZW50cyA9IHtcbiAgICBhYm9ydDogYW55IC8vIEV2ZW50ICYgVHlwZTxcImFib3J0XCI+XG59XG50eXBlIEV2ZW50QXR0cmlidXRlcyA9IHtcbiAgICBvbmFib3J0OiBhbnkgLy8gRXZlbnQgJiBUeXBlPFwiYWJvcnRcIj5cbn1cblxuLyoqXG4gKiBUaGUgc2lnbmFsIGNsYXNzLlxuICogQHNlZSBodHRwczovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI2Fib3J0c2lnbmFsXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFib3J0U2lnbmFsIGV4dGVuZHMgRXZlbnRUYXJnZXQ8RXZlbnRzLCBFdmVudEF0dHJpYnV0ZXM+IHtcbiAgICAvKipcbiAgICAgKiBBYm9ydFNpZ25hbCBjYW5ub3QgYmUgY29uc3RydWN0ZWQgZGlyZWN0bHkuXG4gICAgICovXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJBYm9ydFNpZ25hbCBjYW5ub3QgYmUgY29uc3RydWN0ZWQgZGlyZWN0bHlcIilcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGlzIGBBYm9ydFNpZ25hbGAncyBgQWJvcnRDb250cm9sbGVyYCBoYXMgc2lnbmFsZWQgdG8gYWJvcnQsIGFuZCBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IGFib3J0ZWQoKTogYm9vbGVhbiB7XG4gICAgICAgIGNvbnN0IGFib3J0ZWQgPSBhYm9ydGVkRmxhZ3MuZ2V0KHRoaXMpXG4gICAgICAgIGlmICh0eXBlb2YgYWJvcnRlZCAhPT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgICAgYEV4cGVjdGVkICd0aGlzJyB0byBiZSBhbiAnQWJvcnRTaWduYWwnIG9iamVjdCwgYnV0IGdvdCAke1xuICAgICAgICAgICAgICAgICAgICB0aGlzID09PSBudWxsID8gXCJudWxsXCIgOiB0eXBlb2YgdGhpc1xuICAgICAgICAgICAgICAgIH1gLFxuICAgICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhYm9ydGVkXG4gICAgfVxufVxuZGVmaW5lRXZlbnRBdHRyaWJ1dGUoQWJvcnRTaWduYWwucHJvdG90eXBlLCBcImFib3J0XCIpXG5cbi8qKlxuICogQ3JlYXRlIGFuIEFib3J0U2lnbmFsIG9iamVjdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUFib3J0U2lnbmFsKCk6IEFib3J0U2lnbmFsIHtcbiAgICBjb25zdCBzaWduYWwgPSBPYmplY3QuY3JlYXRlKEFib3J0U2lnbmFsLnByb3RvdHlwZSlcbiAgICBFdmVudFRhcmdldC5jYWxsKHNpZ25hbClcbiAgICBhYm9ydGVkRmxhZ3Muc2V0KHNpZ25hbCwgZmFsc2UpXG4gICAgcmV0dXJuIHNpZ25hbFxufVxuXG4vKipcbiAqIEFib3J0IGEgZ2l2ZW4gc2lnbmFsLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYWJvcnRTaWduYWwoc2lnbmFsOiBBYm9ydFNpZ25hbCk6IHZvaWQge1xuICAgIGlmIChhYm9ydGVkRmxhZ3MuZ2V0KHNpZ25hbCkgIT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGFib3J0ZWRGbGFncy5zZXQoc2lnbmFsLCB0cnVlKVxuICAgIHNpZ25hbC5kaXNwYXRjaEV2ZW50PFwiYWJvcnRcIj4oeyB0eXBlOiBcImFib3J0XCIgfSlcbn1cblxuLyoqXG4gKiBBYm9ydGVkIGZsYWcgZm9yIGVhY2ggaW5zdGFuY2VzLlxuICovXG5jb25zdCBhYm9ydGVkRmxhZ3MgPSBuZXcgV2Vha01hcDxBYm9ydFNpZ25hbCwgYm9vbGVhbj4oKVxuXG4vLyBQcm9wZXJ0aWVzIHNob3VsZCBiZSBlbnVtZXJhYmxlLlxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQWJvcnRTaWduYWwucHJvdG90eXBlLCB7XG4gICAgYWJvcnRlZDogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG59KVxuXG4vLyBgdG9TdHJpbmcoKWAgc2hvdWxkIHJldHVybiBgXCJbb2JqZWN0IEFib3J0U2lnbmFsXVwiYFxuaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLnRvU3RyaW5nVGFnID09PSBcInN5bWJvbFwiKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFib3J0U2lnbmFsLnByb3RvdHlwZSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IFwiQWJvcnRTaWduYWxcIixcbiAgICB9KVxufVxuIiwgImltcG9ydCBBYm9ydFNpZ25hbCwgeyBhYm9ydFNpZ25hbCwgY3JlYXRlQWJvcnRTaWduYWwgfSBmcm9tIFwiLi9hYm9ydC1zaWduYWxcIlxuXG4vKipcbiAqIFRoZSBBYm9ydENvbnRyb2xsZXIuXG4gKiBAc2VlIGh0dHBzOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jYWJvcnRjb250cm9sbGVyXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFib3J0Q29udHJvbGxlciB7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSB0aGlzIGNvbnRyb2xsZXIuXG4gICAgICovXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzaWduYWxzLnNldCh0aGlzLCBjcmVhdGVBYm9ydFNpZ25hbCgpKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGBBYm9ydFNpZ25hbGAgb2JqZWN0IGFzc29jaWF0ZWQgd2l0aCB0aGlzIG9iamVjdC5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IHNpZ25hbCgpOiBBYm9ydFNpZ25hbCB7XG4gICAgICAgIHJldHVybiBnZXRTaWduYWwodGhpcylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBYm9ydCBhbmQgc2lnbmFsIHRvIGFueSBvYnNlcnZlcnMgdGhhdCB0aGUgYXNzb2NpYXRlZCBhY3Rpdml0eSBpcyB0byBiZSBhYm9ydGVkLlxuICAgICAqL1xuICAgIHB1YmxpYyBhYm9ydCgpOiB2b2lkIHtcbiAgICAgICAgYWJvcnRTaWduYWwoZ2V0U2lnbmFsKHRoaXMpKVxuICAgIH1cbn1cblxuLyoqXG4gKiBBc3NvY2lhdGVkIHNpZ25hbHMuXG4gKi9cbmNvbnN0IHNpZ25hbHMgPSBuZXcgV2Vha01hcDxBYm9ydENvbnRyb2xsZXIsIEFib3J0U2lnbmFsPigpXG5cbi8qKlxuICogR2V0IHRoZSBhc3NvY2lhdGVkIHNpZ25hbCBvZiBhIGdpdmVuIGNvbnRyb2xsZXIuXG4gKi9cbmZ1bmN0aW9uIGdldFNpZ25hbChjb250cm9sbGVyOiBBYm9ydENvbnRyb2xsZXIpOiBBYm9ydFNpZ25hbCB7XG4gICAgY29uc3Qgc2lnbmFsID0gc2lnbmFscy5nZXQoY29udHJvbGxlcilcbiAgICBpZiAoc2lnbmFsID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgIGBFeHBlY3RlZCAndGhpcycgdG8gYmUgYW4gJ0Fib3J0Q29udHJvbGxlcicgb2JqZWN0LCBidXQgZ290ICR7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlciA9PT0gbnVsbCA/IFwibnVsbFwiIDogdHlwZW9mIGNvbnRyb2xsZXJcbiAgICAgICAgICAgIH1gLFxuICAgICAgICApXG4gICAgfVxuICAgIHJldHVybiBzaWduYWxcbn1cblxuLy8gUHJvcGVydGllcyBzaG91bGQgYmUgZW51bWVyYWJsZS5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEFib3J0Q29udHJvbGxlci5wcm90b3R5cGUsIHtcbiAgICBzaWduYWw6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICAgIGFib3J0OiB7IGVudW1lcmFibGU6IHRydWUgfSxcbn0pXG5cbmlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZyA9PT0gXCJzeW1ib2xcIikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYm9ydENvbnRyb2xsZXIucHJvdG90eXBlLCBTeW1ib2wudG9TdHJpbmdUYWcsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogXCJBYm9ydENvbnRyb2xsZXJcIixcbiAgICB9KVxufVxuXG5leHBvcnQgeyBBYm9ydENvbnRyb2xsZXIsIEFib3J0U2lnbmFsIH1cbiIsICJpbXBvcnQgeyBJbnN0cnVjdGlvbiwgUHVia2V5LCBSZXN1bHQsIFNlY3JldCB9IGZyb20gJ0Bzb2xhbmEtc3VpdGUvc2hhcmVkJztcbmltcG9ydCB7IFNwbFRva2VuIH0gZnJvbSAnQHNvbGFuYS1zdWl0ZS9jb3JlJztcblxuZXhwb3J0IG5hbWVzcGFjZSBNZXRhcGxleCB7XG4gIGNvbnN0IE5GVF9BTU9VTlQgPSAxO1xuICBjb25zdCBORlRfREVDSU1BTFMgPSAwO1xuXG4gIGV4cG9ydCBjb25zdCBidXJuID0gKFxuICAgIG1pbnQ6IFB1YmtleSxcbiAgICBvd25lcjogUHVia2V5LFxuICAgIHNpZ25lcjogU2VjcmV0LFxuICAgIGZlZVBheWVyPzogU2VjcmV0XG4gICk6IFJlc3VsdDxJbnN0cnVjdGlvbiwgRXJyb3I+ID0+IHtcbiAgICByZXR1cm4gU3BsVG9rZW4uYnVybihcbiAgICAgIG1pbnQsXG4gICAgICBvd25lcixcbiAgICAgIFtzaWduZXJdLFxuICAgICAgTkZUX0FNT1VOVCxcbiAgICAgIE5GVF9ERUNJTUFMUyxcbiAgICAgIGZlZVBheWVyXG4gICAgKTtcbiAgfTtcbn1cbiIsICJpbXBvcnQge1xuICBJbmZyYVNpZGVJbnB1dCxcbiAgSW5mcmFTaWRlT3V0cHV0LFxuICBPcHRpb24sXG4gIFVzZXJTaWRlSW5wdXQsXG4gIFVzZXJTaWRlT3V0cHV0LFxufSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBuYW1lc3BhY2UgQ29udmVydCB7XG4gIGV4cG9ydCBuYW1lc3BhY2UgQ29sbGVjdGlvbiB7XG4gICAgZXhwb3J0IGNvbnN0IGludG9JbmZyYVNpZGUgPSAoXG4gICAgICBpbnB1dDogT3B0aW9uPFVzZXJTaWRlSW5wdXQuQ29sbGVjdGlvbj4gfCB1bmRlZmluZWQsXG4gICAgKTogT3B0aW9uPEluZnJhU2lkZUlucHV0LkNvbGxlY3Rpb24+ID0+IHtcbiAgICAgIGlmICghaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGtleTogaW5wdXQudG9QdWJsaWNLZXkoKSxcbiAgICAgICAgdmVyaWZpZWQ6IGZhbHNlLFxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgZXhwb3J0IGNvbnN0IGludG9Vc2VyU2lkZSA9IChcbiAgICAgIG91dHB1dDogT3B0aW9uPEluZnJhU2lkZU91dHB1dC5Db2xsZWN0aW9uPixcbiAgICApOiBVc2VyU2lkZU91dHB1dC5Db2xsZWN0aW9uIHwgdW5kZWZpbmVkID0+IHtcbiAgICAgIGlmICghb3V0cHV0KSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGFkZHJlc3M6IG91dHB1dC5rZXkudG9TdHJpbmcoKSxcbiAgICAgICAgdmVyaWZpZWQ6IG91dHB1dC52ZXJpZmllZCxcbiAgICAgIH07XG4gICAgfTtcbiAgfVxufVxuIiwgImltcG9ydCB7XG4gIEluZnJhU2lkZUlucHV0LFxuICBJbmZyYVNpZGVPdXRwdXQsXG4gIE9wdGlvbixcbiAgVXNlclNpZGVJbnB1dCxcbiAgVXNlclNpZGVPdXRwdXQsXG59IGZyb20gJy4uL3R5cGVzJztcblxuZXhwb3J0IG5hbWVzcGFjZSBDb252ZXJ0IHtcbiAgZXhwb3J0IG5hbWVzcGFjZSBDcmVhdG9ycyB7XG4gICAgZXhwb3J0IGNvbnN0IGludG9JbmZyYVNpZGUgPSAoXG4gICAgICBpbnB1dDogT3B0aW9uPFVzZXJTaWRlSW5wdXQuQ3JlYXRvcnNbXT4gfCB1bmRlZmluZWQsXG4gICAgKTogT3B0aW9uPEluZnJhU2lkZUlucHV0LkNyZWF0b3JzW10+ID0+IHtcbiAgICAgIGlmICghaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gaW5wdXQubWFwKChkYXRhKSA9PiB7XG4gICAgICAgIGxldCBtb2RpZnk6IE9wdGlvbjxJbmZyYVNpZGVJbnB1dC5DcmVhdG9ycz4gPSBudWxsO1xuICAgICAgICBtb2RpZnkgPSB7XG4gICAgICAgICAgYWRkcmVzczogZGF0YS5hZGRyZXNzLnRvUHVibGljS2V5KCksXG4gICAgICAgICAgc2hhcmU6IGRhdGEuc2hhcmUsXG4gICAgICAgICAgdmVyaWZpZWQ6IGRhdGEudmVyaWZpZWQsXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIG1vZGlmeTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBleHBvcnQgY29uc3QgaW50b1VzZXJTaWRlID0gKFxuICAgICAgb3V0cHV0OiBPcHRpb248SW5mcmFTaWRlT3V0cHV0LkNyZWF0b3JbXT4sXG4gICAgKTogVXNlclNpZGVPdXRwdXQuQ3JlYXRvcnNbXSB8IHVuZGVmaW5lZCA9PiB7XG4gICAgICBpZiAoIW91dHB1dCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb3V0cHV0Lm1hcCgoZGF0YSkgPT4ge1xuICAgICAgICBjb25zdCBtb2RpZnkgPSB7XG4gICAgICAgICAgYWRkcmVzczogZGF0YS5hZGRyZXNzLnRvU3RyaW5nKCksXG4gICAgICAgICAgc2hhcmU6IGRhdGEuc2hhcmUsXG4gICAgICAgICAgdmVyaWZpZWQ6IGRhdGEudmVyaWZpZWQsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBtb2RpZnk7XG4gICAgICB9KTtcbiAgICB9O1xuICB9XG59XG4iLCAiaW1wb3J0IHsgSW5mcmFTaWRlT3V0cHV0LCBPcHRpb24sIFVzZXJTaWRlT3V0cHV0IH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgbmFtZXNwYWNlIENvbnZlcnQge1xuICBleHBvcnQgbmFtZXNwYWNlIFVzZXMge1xuICAgIGV4cG9ydCBjb25zdCBpbnRvVXNlclNpZGUgPSAoXG4gICAgICBvdXRwdXQ6IE9wdGlvbjxJbmZyYVNpZGVPdXRwdXQuVXNlcz4sXG4gICAgKTogVXNlclNpZGVPdXRwdXQuVXNlcyB8IHVuZGVmaW5lZCA9PiB7XG4gICAgICBpZiAoIW91dHB1dCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9O1xuICB9XG59XG4iLCAiaW1wb3J0IHsgQ29udmVydCBhcyBfQ3JlYXRvcnMgfSBmcm9tICcuL2NyZWF0b3JzJztcbmltcG9ydCB7IENvbnZlcnQgYXMgX1VzZXMgfSBmcm9tICcuL3VzZXMnO1xuaW1wb3J0IHtcbiAgSW5mcmFTaWRlSW5wdXQsXG4gIEluZnJhU2lkZU91dHB1dCxcbiAgVXNlclNpZGVJbnB1dCxcbiAgVXNlclNpZGVPdXRwdXQsXG59IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHsgY29udmVydFRpbWVzdGFtcFRvRGF0ZVRpbWUgfSBmcm9tICdAc29sYW5hLXN1aXRlL3NoYXJlZCc7XG5leHBvcnQgbmFtZXNwYWNlIENvbnZlcnQge1xuICBleHBvcnQgbmFtZXNwYWNlIFRva2VuTWV0YWRhdGEge1xuICAgIGV4cG9ydCBjb25zdCBpbnRvSW5mcmFTaWRlID0gKFxuICAgICAgaW5wdXQ6IFVzZXJTaWRlSW5wdXQuVG9rZW5NZXRhZGF0YSxcbiAgICAgIHVyaTogc3RyaW5nLFxuICAgICAgc2VsbGVyRmVlQmFzaXNQb2ludHM6IG51bWJlcixcbiAgICApOiBJbmZyYVNpZGVJbnB1dC5NZXRhcGxleERhdGFWMiA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiBpbnB1dC5uYW1lLFxuICAgICAgICBzeW1ib2w6IGlucHV0LnN5bWJvbCxcbiAgICAgICAgdXJpLFxuICAgICAgICBzZWxsZXJGZWVCYXNpc1BvaW50cyxcbiAgICAgICAgY3JlYXRvcnM6IF9DcmVhdG9ycy5DcmVhdG9ycy5pbnRvSW5mcmFTaWRlKGlucHV0LmNyZWF0b3JzKSxcbiAgICAgICAgY29sbGVjdGlvbjogbnVsbCxcbiAgICAgICAgdXNlczogaW5wdXQudXNlcyB8fCBudWxsLFxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgZXhwb3J0IGNvbnN0IGludG9Vc2VyU2lkZSA9IChcbiAgICAgIG91dHB1dDogSW5mcmFTaWRlT3V0cHV0Lk9uY2hhaW5BbmRPZmZjaGFpbixcbiAgICAgIHRva2VuQW1vdW50OiBzdHJpbmcsXG4gICAgKTogVXNlclNpZGVPdXRwdXQuVG9rZW5NZXRhZGF0YSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtaW50OiBvdXRwdXQub25jaGFpbi5taW50LnRvU3RyaW5nKCksXG4gICAgICAgIHJveWFsdHk6IG91dHB1dC5vbmNoYWluLmRhdGEuc2VsbGVyRmVlQmFzaXNQb2ludHMsXG4gICAgICAgIG5hbWU6IGRlbGV0ZU51bGxTdHJpbmdzKG91dHB1dC5vbmNoYWluLmRhdGEubmFtZSksXG4gICAgICAgIHN5bWJvbDogZGVsZXRlTnVsbFN0cmluZ3Mob3V0cHV0Lm9uY2hhaW4uZGF0YS5zeW1ib2wpLFxuICAgICAgICB0b2tlbkFtb3VudDogdG9rZW5BbW91bnQsXG4gICAgICAgIHVyaTogZGVsZXRlTnVsbFN0cmluZ3Mob3V0cHV0Lm9uY2hhaW4uZGF0YS51cmkpLFxuICAgICAgICBjcmVhdG9yczogX0NyZWF0b3JzLkNyZWF0b3JzLmludG9Vc2VyU2lkZShvdXRwdXQub25jaGFpbi5kYXRhLmNyZWF0b3JzKSxcbiAgICAgICAgdXNlczogX1VzZXMuVXNlcy5pbnRvVXNlclNpZGUob3V0cHV0Lm9uY2hhaW4udXNlcyksXG4gICAgICAgIGRhdGVUaW1lOiBjb252ZXJ0VGltZXN0YW1wVG9EYXRlVGltZShvdXRwdXQub2ZmY2hhaW4uY3JlYXRlZF9hdCksXG4gICAgICAgIG9mZmNoYWluOiBvdXRwdXQub2ZmY2hhaW4sXG4gICAgICB9O1xuICAgIH07XG4gICAgLy8gZGVsZXRlIE5VTEwoMHgwMCkgc3RyaW5ncyBmdW5jdGlvblxuICAgIGV4cG9ydCBjb25zdCBkZWxldGVOdWxsU3RyaW5ncyA9IChzdHI6IHN0cmluZyk6IHN0cmluZyA9PiB7XG4gICAgICByZXR1cm4gc3RyLnJlcGxhY2UoL1xcMC9nLCAnJyk7XG4gICAgfTtcbiAgfVxufVxuIiwgImltcG9ydCB7IENvbnZlcnQgYXMgX0NvbGxlY3Rpb24gfSBmcm9tICcuL2NvbGxlY3Rpb24nO1xuaW1wb3J0IHsgQ29udmVydCBhcyBfQ3JlYXRvcnMgfSBmcm9tICcuL2NyZWF0b3JzJztcbmltcG9ydCB7IENvbnZlcnQgYXMgX1VzZXMgfSBmcm9tICcuL3VzZXMnO1xuaW1wb3J0IHsgQ29udmVydCBhcyBfVG9rZW4gfSBmcm9tICcuL3Rva2VuLW1ldGFkYXRhJztcbmltcG9ydCB7XG4gIEluZnJhU2lkZUlucHV0LFxuICBJbmZyYVNpZGVPdXRwdXQsXG4gIFVzZXJTaWRlSW5wdXQsXG4gIFVzZXJTaWRlT3V0cHV0LFxufSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7IGNvbnZlcnRUaW1lc3RhbXBUb0RhdGVUaW1lIH0gZnJvbSAnQHNvbGFuYS1zdWl0ZS9zaGFyZWQnO1xuXG5leHBvcnQgbmFtZXNwYWNlIENvbnZlcnQge1xuICBleHBvcnQgbmFtZXNwYWNlIE5mdE1ldGFkYXRhIHtcbiAgICBleHBvcnQgY29uc3QgaW50b0luZnJhU2lkZSA9IChcbiAgICAgIGlucHV0OiBVc2VyU2lkZUlucHV0Lk5mdE1ldGFkYXRhLFxuICAgICAgdXJpOiBzdHJpbmcsXG4gICAgICBzZWxsZXJGZWVCYXNpc1BvaW50czogbnVtYmVyLFxuICAgICk6IEluZnJhU2lkZUlucHV0Lk1ldGFwbGV4RGF0YVYyID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IGlucHV0Lm5hbWUsXG4gICAgICAgIHN5bWJvbDogaW5wdXQuc3ltYm9sLFxuICAgICAgICB1cmksXG4gICAgICAgIHNlbGxlckZlZUJhc2lzUG9pbnRzLFxuICAgICAgICBjcmVhdG9yczogX0NyZWF0b3JzLkNyZWF0b3JzLmludG9JbmZyYVNpZGUoaW5wdXQuY3JlYXRvcnMpLFxuICAgICAgICBjb2xsZWN0aW9uOiBfQ29sbGVjdGlvbi5Db2xsZWN0aW9uLmludG9JbmZyYVNpZGUoaW5wdXQuY29sbGVjdGlvbiksXG4gICAgICAgIHVzZXM6IGlucHV0LnVzZXMgfHwgbnVsbCxcbiAgICAgIH07XG4gICAgfTtcblxuICAgIGV4cG9ydCBjb25zdCBpbnRvVXNlclNpZGUgPSAoXG4gICAgICBvdXRwdXQ6IEluZnJhU2lkZU91dHB1dC5PbmNoYWluQW5kT2ZmY2hhaW4sXG4gICAgICB0b2tlbkFtb3VudDogc3RyaW5nLFxuICAgICk6IFVzZXJTaWRlT3V0cHV0Lk5mdE1ldGFkYXRhID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1pbnQ6IG91dHB1dC5vbmNoYWluLm1pbnQudG9TdHJpbmcoKSxcbiAgICAgICAgdXBkYXRlQXV0aG9yaXR5OiBvdXRwdXQub25jaGFpbi51cGRhdGVBdXRob3JpdHkudG9TdHJpbmcoKSxcbiAgICAgICAgcm95YWx0eTogb3V0cHV0Lm9uY2hhaW4uZGF0YS5zZWxsZXJGZWVCYXNpc1BvaW50cyxcbiAgICAgICAgbmFtZTogX1Rva2VuLlRva2VuTWV0YWRhdGEuZGVsZXRlTnVsbFN0cmluZ3Mob3V0cHV0Lm9uY2hhaW4uZGF0YS5uYW1lKSxcbiAgICAgICAgc3ltYm9sOiBfVG9rZW4uVG9rZW5NZXRhZGF0YS5kZWxldGVOdWxsU3RyaW5ncyhcbiAgICAgICAgICBvdXRwdXQub25jaGFpbi5kYXRhLnN5bWJvbCxcbiAgICAgICAgKSxcbiAgICAgICAgdG9rZW5BbW91bnQ6IHRva2VuQW1vdW50LFxuICAgICAgICB1cmk6IF9Ub2tlbi5Ub2tlbk1ldGFkYXRhLmRlbGV0ZU51bGxTdHJpbmdzKG91dHB1dC5vbmNoYWluLmRhdGEudXJpKSxcbiAgICAgICAgaXNNdXRhYmxlOiBvdXRwdXQub25jaGFpbi5pc011dGFibGUsXG4gICAgICAgIHByaW1hcnlTYWxlSGFwcGVuZWQ6IG91dHB1dC5vbmNoYWluLnByaW1hcnlTYWxlSGFwcGVuZWQsXG4gICAgICAgIGNyZWF0b3JzOiBfQ3JlYXRvcnMuQ3JlYXRvcnMuaW50b1VzZXJTaWRlKG91dHB1dC5vbmNoYWluLmRhdGEuY3JlYXRvcnMpLFxuICAgICAgICBlZGl0aW9uTm9uY2U6IG91dHB1dC5vbmNoYWluLmVkaXRpb25Ob25jZSxcbiAgICAgICAgY29sbGVjdGlvbjogX0NvbGxlY3Rpb24uQ29sbGVjdGlvbi5pbnRvVXNlclNpZGUoXG4gICAgICAgICAgb3V0cHV0Lm9uY2hhaW4uY29sbGVjdGlvbixcbiAgICAgICAgKSxcbiAgICAgICAgdXNlczogX1VzZXMuVXNlcy5pbnRvVXNlclNpZGUob3V0cHV0Lm9uY2hhaW4udXNlcyksXG4gICAgICAgIGRhdGVUaW1lOiBjb252ZXJ0VGltZXN0YW1wVG9EYXRlVGltZShvdXRwdXQub2ZmY2hhaW4uY3JlYXRlZF9hdCksXG4gICAgICAgIG9mZmNoYWluOiBvdXRwdXQub2ZmY2hhaW4sXG4gICAgICB9O1xuICAgIH07XG4gIH1cbn1cbiIsICJpbXBvcnQgeyBvdmVyd3JpdGVPYmplY3QsIFJlc3VsdCwgU2VjcmV0IH0gZnJvbSAnQHNvbGFuYS1zdWl0ZS9zaGFyZWQnO1xuaW1wb3J0IHtcbiAgRmlsZUNvbnRlbnQsXG4gIEluZnJhU2lkZUlucHV0LFxuICBTdG9yYWdlVHlwZSxcbiAgVXNlclNpZGVJbnB1dCxcbn0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgbmFtZXNwYWNlIENvbnZlcnQge1xuICBleHBvcnQgbmFtZXNwYWNlIFByb3BlcnRpZXMge1xuICAgIGV4cG9ydCBjb25zdCBpbnRvSW5mcmFTaWRlID0gYXN5bmMgKFxuICAgICAgaW5wdXQ6IFVzZXJTaWRlSW5wdXQuUHJvcGVydGllcyB8IHVuZGVmaW5lZCxcbiAgICAgIHN0b3JhZ2VGdW5jOiAoXG4gICAgICAgIGRhdGE6IEZpbGVDb250ZW50LFxuICAgICAgICBzdG9yYWdlVHlwZTogU3RvcmFnZVR5cGUsXG4gICAgICAgIGZlZVBheWVyPzogU2VjcmV0LFxuICAgICAgKSA9PiBQcm9taXNlPFJlc3VsdDxzdHJpbmcsIEVycm9yPj4sXG4gICAgICBzdG9yYWdlVHlwZTogU3RvcmFnZVR5cGUsXG4gICAgICBmZWVQYXllcj86IFNlY3JldCxcbiAgICApOiBQcm9taXNlPEluZnJhU2lkZUlucHV0LlByb3BlcnRpZXM+ID0+IHtcbiAgICAgIGlmICghaW5wdXQgfHwgIWlucHV0LmZpbGVzKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZmlsZXMgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgaW5wdXQuZmlsZXMubWFwKGFzeW5jIChmaWxlKSA9PiB7XG4gICAgICAgICAgaWYgKCFmaWxlLmZpbGVQYXRoKSB7XG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHN0b3JhZ2VGdW5jKGZpbGUuZmlsZVBhdGgsIHN0b3JhZ2VUeXBlLCBmZWVQYXllcik7XG4gICAgICAgICAgaWYgKHJlcy5pc0Vycikge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IocmVzLmVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gb3ZlcndyaXRlT2JqZWN0KGZpbGUsIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgZXhpc3RzS2V5OiAnZmlsZVBhdGgnLFxuICAgICAgICAgICAgICB3aWxsOiB7IGtleTogJ3VyaScsIHZhbHVlOiByZXMudmFsdWUgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgXSk7XG4gICAgICAgIH0pLFxuICAgICAgKTtcbiAgICAgIHJldHVybiB7IC4uLmlucHV0LCBmaWxlcyB9IGFzIEluZnJhU2lkZUlucHV0LlByb3BlcnRpZXM7XG4gICAgfTtcbiAgfVxufVxuIiwgImltcG9ydCB7IENvbnZlcnQgYXMgQ29sbGVjdGlvbiB9IGZyb20gJy4vY29sbGVjdGlvbic7XG5pbXBvcnQgeyBDb252ZXJ0IGFzIENyZWF0b3JzIH0gZnJvbSAnLi9jcmVhdG9ycyc7XG5pbXBvcnQgeyBDb252ZXJ0IGFzIE5mdE1ldGFkYXRhIH0gZnJvbSAnLi9uZnQtbWV0YWRhdGEnO1xuaW1wb3J0IHsgQ29udmVydCBhcyBQcm9wZXJ0aWVzIH0gZnJvbSAnLi9wcm9wZXJ0aWVzJztcbmltcG9ydCB7IENvbnZlcnQgYXMgVG9rZW5NZXRhZGF0YSB9IGZyb20gJy4vdG9rZW4tbWV0YWRhdGEnO1xuaW1wb3J0IHsgQ29udmVydCBhcyBVc2VzIH0gZnJvbSAnLi91c2VzJztcblxuZXhwb3J0IGNvbnN0IENvbnZlcnQgPSB7XG4gIC4uLkNvbGxlY3Rpb24sXG4gIC4uLkNyZWF0b3JzLFxuICAuLi5OZnRNZXRhZGF0YSxcbiAgLi4uUHJvcGVydGllcyxcbiAgLi4uVG9rZW5NZXRhZGF0YSxcbiAgLi4uVXNlcyxcbn07XG4iLCAiaW1wb3J0IHsgU3RvcmFnZVR5cGUgfSBmcm9tICcuLi8uLi90eXBlcyc7XG5pbXBvcnQgeyBfU2hhcmVkLCBiaWdudW0sIEZpbGVDb250ZW50IH0gZnJvbSAnLi4vc2hhcmVkJztcbmltcG9ydCB7IFB1YmtleSB9IGZyb20gJ0Bzb2xhbmEtc3VpdGUvc2hhcmVkJztcblxuZXhwb3J0IG5hbWVzcGFjZSBVc2VyU2lkZUlucHV0IHtcbiAgZXhwb3J0IHR5cGUgQ29sbGVjdGlvbiA9IFB1YmtleTtcblxuICBleHBvcnQgdHlwZSBDcmVhdG9ycyA9IHtcbiAgICBhZGRyZXNzOiBQdWJrZXk7XG4gICAgc2hhcmU6IG51bWJlcjtcbiAgICB2ZXJpZmllZDogYm9vbGVhbjtcbiAgfTtcblxuICBleHBvcnQgdHlwZSBQcm9wZXJ0aWVzID0gX1NoYXJlZC5Qcm9wZXJ0aWVzO1xuXG4gIGV4cG9ydCBlbnVtIFRva2VuU3RhbmRhcmQge1xuICAgIE5vbkZ1bmdpYmxlID0gMCxcbiAgICBGdW5naWJsZUFzc2V0ID0gMSxcbiAgICBGdW5naWJsZSA9IDIsXG4gICAgTm9uRnVuZ2libGVFZGl0aW9uID0gMyxcbiAgICBQcm9ncmFtbWFibGVOb25GdW5naWJsZSA9IDQsXG4gIH1cblxuICBleHBvcnQgdHlwZSBOZnRNZXRhZGF0YSA9IHtcbiAgICBuYW1lOiBzdHJpbmc7XG4gICAgc3ltYm9sOiBzdHJpbmc7XG4gICAgcm95YWx0eTogbnVtYmVyO1xuICAgIHN0b3JhZ2VUeXBlPzogU3RvcmFnZVR5cGU7XG4gICAgZmlsZVBhdGg/OiBGaWxlQ29udGVudDtcbiAgICB1cmk/OiBzdHJpbmc7XG4gICAgaXNNdXRhYmxlPzogYm9vbGVhbjtcbiAgICBkZXNjcmlwdGlvbj86IHN0cmluZztcbiAgICBleHRlcm5hbF91cmw/OiBzdHJpbmc7XG4gICAgYXR0cmlidXRlcz86IF9TaGFyZWQuQXR0cmlidXRlW107XG4gICAgcHJvcGVydGllcz86IFByb3BlcnRpZXM7XG4gICAgbWF4U3VwcGx5PzogYmlnbnVtO1xuICAgIGNyZWF0b3JzPzogQ3JlYXRvcnNbXTtcbiAgICB1c2VzPzogX1NoYXJlZC5Vc2VzO1xuICAgIGNvbGxlY3Rpb24/OiBDb2xsZWN0aW9uO1xuICAgIG9wdGlvbnM/OiBfU2hhcmVkLk9wdGlvbnM7XG4gIH07XG5cbiAgZXhwb3J0IHR5cGUgVG9rZW5NZXRhZGF0YSA9IHtcbiAgICBuYW1lOiBzdHJpbmc7XG4gICAgc3ltYm9sOiBzdHJpbmc7XG4gICAgZmlsZVBhdGg/OiBGaWxlQ29udGVudDtcbiAgICB1cmk/OiBzdHJpbmc7XG4gICAgc3RvcmFnZVR5cGU/OiBTdG9yYWdlVHlwZTtcbiAgICBkZXNjcmlwdGlvbj86IHN0cmluZztcbiAgICByb3lhbHR5PzogbnVtYmVyO1xuICAgIHVzZXM/OiBfU2hhcmVkLlVzZXM7XG4gICAgY3JlYXRvcnM/OiBDcmVhdG9yc1tdO1xuICAgIGF0dHJpYnV0ZXM/OiBfU2hhcmVkLkF0dHJpYnV0ZVtdO1xuICAgIG9wdGlvbnM/OiBfU2hhcmVkLk9wdGlvbnM7XG4gIH07XG59XG4iLCAiaW1wb3J0IEJOIGZyb20gJ2JuLmpzJztcblxuZXhwb3J0IHR5cGUgT3B0aW9uPFQ+ID0gVCB8IG51bGw7XG5leHBvcnQgdHlwZSBiaWdudW0gPSBudW1iZXIgfCBCTjtcbmV4cG9ydCB0eXBlIEZpbGVDb250ZW50ID0gc3RyaW5nIHwgQnVmZmVyIHwgVWludDhBcnJheSB8IEFycmF5QnVmZmVyO1xuXG5leHBvcnQgbmFtZXNwYWNlIF9TaGFyZWQge1xuICBleHBvcnQgdHlwZSBQcm9wZXJ0aWVzID0ge1xuICAgIGNyZWF0b3JzPzoge1xuICAgICAgYWRkcmVzcz86IHN0cmluZztcbiAgICAgIHNoYXJlPzogbnVtYmVyO1xuICAgICAgW2tleTogc3RyaW5nXTogdW5rbm93bjtcbiAgICB9W107XG4gICAgZmlsZXM/OiB7XG4gICAgICB0eXBlPzogc3RyaW5nO1xuICAgICAgZmlsZVBhdGg/OiBGaWxlQ29udGVudDtcbiAgICAgIFtrZXk6IHN0cmluZ106IHVua25vd247XG4gICAgfVtdO1xuICAgIFtrZXk6IHN0cmluZ106IHVua25vd247XG4gIH07XG5cbiAgZXhwb3J0IHR5cGUgQXR0cmlidXRlID0ge1xuICAgIHRyYWl0X3R5cGU/OiBzdHJpbmc7XG4gICAgdmFsdWU/OiBzdHJpbmc7XG4gICAgW2tleTogc3RyaW5nXTogdW5rbm93bjtcbiAgfTtcblxuICBleHBvcnQgZW51bSBVc2VNZXRob2Qge1xuICAgIEJ1cm4gPSAwLFxuICAgIE11bHRpcGxlID0gMSxcbiAgICBTaW5nbGUgPSAyLFxuICB9XG5cbiAgZXhwb3J0IHR5cGUgVXNlcyA9IHtcbiAgICB1c2VNZXRob2Q6IFVzZU1ldGhvZDtcbiAgICByZW1haW5pbmc6IGJpZ251bTtcbiAgICB0b3RhbDogYmlnbnVtO1xuICB9O1xuXG4gIGV4cG9ydCB0eXBlIE9wdGlvbnMgPSB7IFtrZXk6IHN0cmluZ106IHVua25vd24gfTtcbn1cbiIsICJpbXBvcnQgeyBQdWJsaWNLZXkgfSBmcm9tICdAc29sYW5hL3dlYjMuanMnO1xuaW1wb3J0IHsgUFJPR1JBTV9JRCB9IGZyb20gJ0BtZXRhcGxleC1mb3VuZGF0aW9uL21wbC10b2tlbi1tZXRhZGF0YSc7XG5pbXBvcnQgeyBQdWJrZXkgfSBmcm9tICdAc29sYW5hLXN1aXRlL3NoYXJlZCc7XG5cbmV4cG9ydCBuYW1lc3BhY2UgUGRhIHtcbiAgZXhwb3J0IGNvbnN0IGdldE1ldGFkYXRhID0gKG1pbnQ6IFB1YmtleSk6IFB1YmxpY0tleSA9PiB7XG4gICAgY29uc3QgW3B1YmxpY0tleV0gPSBQdWJsaWNLZXkuZmluZFByb2dyYW1BZGRyZXNzU3luYyhcbiAgICAgIFtCdWZmZXIuZnJvbSgnbWV0YWRhdGEnKSwgUFJPR1JBTV9JRC50b0J1ZmZlcigpLCBtaW50LnRvUHVibGljS2V5KCkudG9CdWZmZXIoKV0sXG4gICAgICBQUk9HUkFNX0lELFxuICAgICk7XG4gICAgcmV0dXJuIHB1YmxpY0tleTtcbiAgfTtcblxuICBleHBvcnQgY29uc3QgZ2V0TWFzdGVyRWRpdGlvbiA9IChtaW50OiBQdWJrZXkpOiBQdWJsaWNLZXkgPT4ge1xuICAgIGNvbnN0IFtwdWJsaWNLZXldID0gUHVibGljS2V5LmZpbmRQcm9ncmFtQWRkcmVzc1N5bmMoXG4gICAgICBbXG4gICAgICAgIEJ1ZmZlci5mcm9tKCdtZXRhZGF0YScpLFxuICAgICAgICBQUk9HUkFNX0lELnRvQnVmZmVyKCksXG4gICAgICAgIG1pbnQudG9QdWJsaWNLZXkoKS50b0J1ZmZlcigpLFxuICAgICAgICBCdWZmZXIuZnJvbSgnZWRpdGlvbicpLFxuICAgICAgXSxcbiAgICAgIFBST0dSQU1fSUQsXG4gICAgKTtcbiAgICByZXR1cm4gcHVibGljS2V5O1xuICB9O1xufVxuIiwgImltcG9ydCB7IFJlc3VsdCwgVHJ5IH0gZnJvbSAnQHNvbGFuYS1zdWl0ZS9zaGFyZWQnO1xuaW1wb3J0IHsgUm95YWx0eSB9IGZyb20gJy4vcm95YWx0eSc7XG5pbXBvcnQgeyBJbmZyYVNpZGVJbnB1dCwgVXNlclNpZGVJbnB1dCB9IGZyb20gJy4vdHlwZXMvJztcbmltcG9ydCB7IERldGFpbHMsIExpbWl0IH0gZnJvbSAnLi90eXBlcy92YWxpZGF0b3InO1xuXG5leHBvcnQgbmFtZXNwYWNlIFZhbGlkYXRvciB7XG4gIGV4cG9ydCBuYW1lc3BhY2UgTWVzc2FnZSB7XG4gICAgZXhwb3J0IGNvbnN0IFNVQ0NFU1MgPSAnc3VjY2Vzcyc7XG4gICAgZXhwb3J0IGNvbnN0IFNNQUxMX05VTUJFUiA9ICd0b28gc21hbGwnO1xuICAgIGV4cG9ydCBjb25zdCBCSUdfTlVNQkVSID0gJ3RvbyBiaWcnO1xuICAgIGV4cG9ydCBjb25zdCBMT05HX0xFTkdUSCA9ICd0b28gbG9uZyc7XG4gICAgZXhwb3J0IGNvbnN0IEVNUFRZID0gJ2ludmFsaWQgZW1wdHkgdmFsdWUnO1xuICAgIGV4cG9ydCBjb25zdCBJTlZBTElEX1VSTCA9ICdpbnZhbGlkIHVybCc7XG4gICAgZXhwb3J0IGNvbnN0IE9OTFlfTk9ERV9KUyA9ICdgc3RyaW5nYCB0eXBlIGlzIG9ubHkgTm9kZS5qcyc7XG4gIH1cblxuICBleHBvcnQgY29uc3QgTkFNRV9MRU5HVEggPSAzMjtcbiAgZXhwb3J0IGNvbnN0IFNZTUJPTF9MRU5HVEggPSAxMDtcbiAgZXhwb3J0IGNvbnN0IFVSTF9MRU5HVEggPSAyMDA7XG4gIGV4cG9ydCBjb25zdCBST1lBTFRZX01BWCA9IDEwMDtcbiAgZXhwb3J0IGNvbnN0IFNFTExFUl9GRUVfQkFTSVNfUE9JTlRTX01BWCA9IDEwMDAwO1xuICBleHBvcnQgY29uc3QgUk9ZQUxUWV9NSU4gPSAtMTtcblxuICBleHBvcnQgY29uc3QgaXNSb3lhbHR5ID0gKFxuICAgIHJveWFsdHk6IG51bWJlclxuICApOiBSZXN1bHQ8c3RyaW5nLCBWYWxpZGF0b3JFcnJvcj4gPT4ge1xuICAgIHJldHVybiBUcnkoKCkgPT4ge1xuICAgICAgY29uc3Qga2V5ID0gJ3JveWFsdHknO1xuICAgICAgaWYgKHJveWFsdHkgIT09IDAgJiYgIXJveWFsdHkpIHtcbiAgICAgICAgdGhyb3cgY3JlYXRlRXJyb3Ioa2V5LCBNZXNzYWdlLkVNUFRZLCByb3lhbHR5KTtcbiAgICAgIH1cbiAgICAgIGlmIChyb3lhbHR5IDwgUk9ZQUxUWV9NSU4pIHtcbiAgICAgICAgdGhyb3cgY3JlYXRlRXJyb3Ioa2V5LCBNZXNzYWdlLlNNQUxMX05VTUJFUiwgcm95YWx0eSwge1xuICAgICAgICAgIHRocmVzaG9sZDogUk9ZQUxUWV9NSU4sXG4gICAgICAgICAgY29uZGl0aW9uOiAndW5kZXJNaW4nLFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAocm95YWx0eSA+IFJPWUFMVFlfTUFYKSB7XG4gICAgICAgIHRocm93IGNyZWF0ZUVycm9yKGtleSwgTWVzc2FnZS5CSUdfTlVNQkVSLCByb3lhbHR5LCB7XG4gICAgICAgICAgdGhyZXNob2xkOiBST1lBTFRZX01BWCxcbiAgICAgICAgICBjb25kaXRpb246ICdvdmVyTWF4JyxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gTWVzc2FnZS5TVUNDRVNTO1xuICAgIH0pO1xuICB9O1xuXG4gIGV4cG9ydCBjb25zdCBpc1NlbGxlckZlZUJhc2lzUG9pbnRzID0gKFxuICAgIHJveWFsdHk6IG51bWJlclxuICApOiBSZXN1bHQ8c3RyaW5nLCBWYWxpZGF0b3JFcnJvcj4gPT4ge1xuICAgIHJldHVybiBUcnkoKCkgPT4ge1xuICAgICAgY29uc3Qga2V5ID0gJ3NlbGxlckZlZUJhc2lzUG9pbnRzL3NlbGxlcl9mZWVfYmFzaXNfcG9pbnRzJztcbiAgICAgIGlmIChyb3lhbHR5ICE9PSAwICYmICFyb3lhbHR5KSB7XG4gICAgICAgIHRocm93IGNyZWF0ZUVycm9yKGtleSwgTWVzc2FnZS5FTVBUWSwgcm95YWx0eSk7XG4gICAgICB9XG4gICAgICBpZiAocm95YWx0eSA8IFJPWUFMVFlfTUlOKSB7XG4gICAgICAgIHRocm93IGNyZWF0ZUVycm9yKGtleSwgTWVzc2FnZS5TTUFMTF9OVU1CRVIsIHJveWFsdHksIHtcbiAgICAgICAgICB0aHJlc2hvbGQ6IFJPWUFMVFlfTUlOLFxuICAgICAgICAgIGNvbmRpdGlvbjogJ3VuZGVyTWluJyxcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKHJveWFsdHkgPiBST1lBTFRZX01BWCAqIFJveWFsdHkuVEhSRVNIT0xEKSB7XG4gICAgICAgIHRocm93IGNyZWF0ZUVycm9yKGtleSwgTWVzc2FnZS5CSUdfTlVNQkVSLCByb3lhbHR5LCB7XG4gICAgICAgICAgdGhyZXNob2xkOiBTRUxMRVJfRkVFX0JBU0lTX1BPSU5UU19NQVgsXG4gICAgICAgICAgY29uZGl0aW9uOiAnb3Zlck1heCcsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE1lc3NhZ2UuU1VDQ0VTUztcbiAgICB9KTtcbiAgfTtcblxuICBleHBvcnQgY29uc3QgaXNOYW1lID0gKG5hbWU6IHN0cmluZyk6IFJlc3VsdDxzdHJpbmcsIFZhbGlkYXRvckVycm9yPiA9PiB7XG4gICAgcmV0dXJuIFRyeSgoKSA9PiB7XG4gICAgICBjb25zdCBrZXkgPSAnbmFtZSc7XG4gICAgICBpZiAoIW5hbWUpIHtcbiAgICAgICAgdGhyb3cgY3JlYXRlRXJyb3Ioa2V5LCBNZXNzYWdlLkVNUFRZLCBuYW1lKTtcbiAgICAgIH1cbiAgICAgIGlmIChieXRlTGVuZ3RoKG5hbWUpID4gTkFNRV9MRU5HVEgpIHtcbiAgICAgICAgdGhyb3cgY3JlYXRlRXJyb3Ioa2V5LCBNZXNzYWdlLkxPTkdfTEVOR1RILCBuYW1lLCB7XG4gICAgICAgICAgdGhyZXNob2xkOiBOQU1FX0xFTkdUSCxcbiAgICAgICAgICBjb25kaXRpb246ICdvdmVyTWF4JyxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gTWVzc2FnZS5TVUNDRVNTO1xuICAgIH0pO1xuICB9O1xuXG4gIGV4cG9ydCBjb25zdCBpc1N5bWJvbCA9IChzeW1ib2w6IHN0cmluZyk6IFJlc3VsdDxzdHJpbmcsIFZhbGlkYXRvckVycm9yPiA9PiB7XG4gICAgcmV0dXJuIFRyeSgoKSA9PiB7XG4gICAgICBjb25zdCBrZXkgPSAnc3ltYm9sJztcbiAgICAgIGlmICghc3ltYm9sKSB7XG4gICAgICAgIHRocm93IGNyZWF0ZUVycm9yKGtleSwgTWVzc2FnZS5FTVBUWSwgc3ltYm9sKTtcbiAgICAgIH1cbiAgICAgIGlmIChieXRlTGVuZ3RoKHN5bWJvbCkgPiBTWU1CT0xfTEVOR1RIKSB7XG4gICAgICAgIHRocm93IGNyZWF0ZUVycm9yKGtleSwgTWVzc2FnZS5MT05HX0xFTkdUSCwgc3ltYm9sLCB7XG4gICAgICAgICAgdGhyZXNob2xkOiBTWU1CT0xfTEVOR1RILFxuICAgICAgICAgIGNvbmRpdGlvbjogJ292ZXJNYXgnLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBNZXNzYWdlLlNVQ0NFU1M7XG4gICAgfSk7XG4gIH07XG5cbiAgZXhwb3J0IGNvbnN0IGlzSW1hZ2VVcmwgPSAoaW1hZ2U6IHN0cmluZyk6IFJlc3VsdDxzdHJpbmcsIFZhbGlkYXRvckVycm9yPiA9PlxuICAgIGlzVXJpT3JJbWFnZShpbWFnZSwgJ2ltYWdlJyk7XG5cbiAgZXhwb3J0IGNvbnN0IGNoZWNrQWxsID0gPFxuICAgIFQgZXh0ZW5kcyBQaWNrTmZ0U3RvcmFnZSB8IFBpY2tOZnRTdG9yYWdlTWV0YXBsZXggfCBQaWNrTWV0YXBsZXhcbiAgPihcbiAgICBtZXRhZGF0YTogVFxuICApOiBSZXN1bHQ8c3RyaW5nLCBWYWxpZGF0b3JFcnJvcj4gPT4ge1xuICAgIHJldHVybiBUcnkoKCkgPT4ge1xuICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG1ldGFkYXRhKTtcbiAgICAgIGNvbnN0IHJlc3VsdHM6IERldGFpbHNbXSA9IFtdO1xuICAgICAga2V5cy5tYXAoKGtleSkgPT4ge1xuICAgICAgICBsZXQgcmVzITogUmVzdWx0PHN0cmluZywgVmFsaWRhdG9yRXJyb3I+O1xuICAgICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICAgIGNhc2UgJ2ltYWdlJzpcbiAgICAgICAgICAgIGlmIChrZXkgaW4gbWV0YWRhdGEgJiYgbWV0YWRhdGEuaW1hZ2UpIHtcbiAgICAgICAgICAgICAgcmVzID0gaXNJbWFnZVVybChtZXRhZGF0YS5pbWFnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdyb3lhbHR5JzpcbiAgICAgICAgICAgIGlmIChrZXkgaW4gbWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgcmVzID0gaXNSb3lhbHR5KG1ldGFkYXRhLnJveWFsdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnc2VsbGVyX2ZlZV9iYXNpc19wb2ludHMnOlxuICAgICAgICAgICAgaWYgKGtleSBpbiBtZXRhZGF0YSAmJiBtZXRhZGF0YS5zZWxsZXJfZmVlX2Jhc2lzX3BvaW50cykge1xuICAgICAgICAgICAgICByZXMgPSBpc1NlbGxlckZlZUJhc2lzUG9pbnRzKG1ldGFkYXRhLnNlbGxlcl9mZWVfYmFzaXNfcG9pbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3NlbGxlckZlZUJhc2lzUG9pbnRzJzpcbiAgICAgICAgICAgIGlmIChrZXkgaW4gbWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgcmVzID0gaXNTZWxsZXJGZWVCYXNpc1BvaW50cyhtZXRhZGF0YS5zZWxsZXJGZWVCYXNpc1BvaW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICduYW1lJzpcbiAgICAgICAgICAgIGlmIChtZXRhZGF0YS5uYW1lKSB7XG4gICAgICAgICAgICAgIHJlcyA9IGlzTmFtZShtZXRhZGF0YS5uYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3N5bWJvbCc6XG4gICAgICAgICAgICBpZiAobWV0YWRhdGEuc3ltYm9sKSB7XG4gICAgICAgICAgICAgIHJlcyA9IGlzU3ltYm9sKG1ldGFkYXRhLnN5bWJvbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzICYmIHJlcy5pc0Vycikge1xuICAgICAgICAgIHJlc3VsdHMucHVzaCguLi5yZXMuZXJyb3IuZGV0YWlscyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKHJlc3VsdHMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID1cbiAgICAgICAgICAnQ2F1Z2h0IGluIHRoZSB2YWxpZGF0aW9uIGVycm9ycy4gc2VlIGluZm9ybWF0aW9uIGUuZzogZXJyPFZhbGlkYXRvckVycm9yPi5kZXRhaWxzJztcbiAgICAgICAgdGhyb3cgbmV3IFZhbGlkYXRvckVycm9yKG1lc3NhZ2UsIHJlc3VsdHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE1lc3NhZ2UuU1VDQ0VTUztcbiAgICB9KTtcbiAgfTtcblxuICB0eXBlIFBpY2tOZnRTdG9yYWdlID0gUGljazxcbiAgICBJbmZyYVNpZGVJbnB1dC5PZmZjaGFpbixcbiAgICAnbmFtZScgfCAnc3ltYm9sJyB8ICdpbWFnZScgfCAnc2VsbGVyX2ZlZV9iYXNpc19wb2ludHMnXG4gID47XG4gIHR5cGUgUGlja05mdFN0b3JhZ2VNZXRhcGxleCA9IFBpY2s8XG4gICAgVXNlclNpZGVJbnB1dC5OZnRNZXRhZGF0YSxcbiAgICAnbmFtZScgfCAnc3ltYm9sJyB8ICdyb3lhbHR5JyB8ICdmaWxlUGF0aCdcbiAgPjtcbiAgdHlwZSBQaWNrTWV0YXBsZXggPSBQaWNrPFxuICAgIEluZnJhU2lkZUlucHV0Lk1ldGFwbGV4RGF0YVYyLFxuICAgICduYW1lJyB8ICdzeW1ib2wnIHwgJ3VyaScgfCAnc2VsbGVyRmVlQmFzaXNQb2ludHMnXG4gID47XG5cbiAgY29uc3QgYnl0ZUxlbmd0aCA9ICh2YWx1ZTogc3RyaW5nKTogbnVtYmVyID0+IHtcbiAgICBjb25zdCB0ZXh0ID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgcmV0dXJuIHRleHQuZW5jb2RlKHZhbHVlKS5sZW5ndGg7XG4gIH07XG5cbiAgY29uc3QgY3JlYXRlRXJyb3IgPSAoXG4gICAga2V5OiBzdHJpbmcsXG4gICAgbWVzc2FnZTogc3RyaW5nLFxuICAgIGFjdHVhbDogc3RyaW5nIHwgbnVtYmVyLFxuICAgIGxpbWl0PzogTGltaXRcbiAgKTogVmFsaWRhdG9yRXJyb3IgPT4ge1xuICAgIGxldCBlcnJvcjogVmFsaWRhdG9yRXJyb3I7XG4gICAgaWYgKGxpbWl0KSB7XG4gICAgICBlcnJvciA9IG5ldyBWYWxpZGF0b3JFcnJvcihtZXNzYWdlLCBbeyBrZXksIG1lc3NhZ2UsIGFjdHVhbCwgbGltaXQgfV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlcnJvciA9IG5ldyBWYWxpZGF0b3JFcnJvcihtZXNzYWdlLCBbeyBrZXksIG1lc3NhZ2UsIGFjdHVhbCB9XSk7XG4gICAgfVxuICAgIHJldHVybiBlcnJvcjtcbiAgfTtcblxuICBjb25zdCBpc1VyaU9ySW1hZ2UgPSAoXG4gICAgaW1hZ2VPclVyaTogc3RyaW5nLFxuICAgIGtleTogc3RyaW5nXG4gICk6IFJlc3VsdDxzdHJpbmcsIFZhbGlkYXRvckVycm9yPiA9PiB7XG4gICAgcmV0dXJuIFRyeSgoKSA9PiB7XG4gICAgICBpZiAoIWltYWdlT3JVcmkpIHtcbiAgICAgICAgdGhyb3cgY3JlYXRlRXJyb3Ioa2V5LCBNZXNzYWdlLkVNUFRZLCBpbWFnZU9yVXJpKTtcbiAgICAgIH1cbiAgICAgIGlmIChieXRlTGVuZ3RoKGltYWdlT3JVcmkpID4gVVJMX0xFTkdUSCkge1xuICAgICAgICB0aHJvdyBjcmVhdGVFcnJvcihrZXksIE1lc3NhZ2UuTE9OR19MRU5HVEgsIGltYWdlT3JVcmksIHtcbiAgICAgICAgICB0aHJlc2hvbGQ6IFVSTF9MRU5HVEgsXG4gICAgICAgICAgY29uZGl0aW9uOiAnb3Zlck1heCcsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKCEvaHR0cHM/OlxcL1xcL1stXy4hfipcXFxcKClhLXpBLVowLTk7PzomPSssJSNdKy9nLnRlc3QoaW1hZ2VPclVyaSkpIHtcbiAgICAgICAgdGhyb3cgY3JlYXRlRXJyb3Ioa2V5LCBNZXNzYWdlLklOVkFMSURfVVJMLCBpbWFnZU9yVXJpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBNZXNzYWdlLlNVQ0NFU1M7XG4gICAgfSk7XG4gIH07XG59XG5cbmV4cG9ydCBjbGFzcyBWYWxpZGF0b3JFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgZGV0YWlsczogRGV0YWlsc1tdO1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcsIGRldGFpbHM6IERldGFpbHNbXSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMuZGV0YWlscyA9IGRldGFpbHM7XG4gIH1cbn1cbiIsICJleHBvcnQgbmFtZXNwYWNlIFJveWFsdHkge1xuICBleHBvcnQgY29uc3QgVEhSRVNIT0xEID0gMTAwO1xuICBleHBvcnQgY29uc3QgY29udmVydCA9IChwZXJjZW50YWdlOiBudW1iZXIpID0+IHtcbiAgICByZXR1cm4gcGVyY2VudGFnZSAqIFRIUkVTSE9MRDtcbiAgfVxufVxuIiwgImltcG9ydCB7IFB1YmtleSwgUmVzdWx0IH0gZnJvbSAnQHNvbGFuYS1zdWl0ZS9zaGFyZWQnO1xuaW1wb3J0IHsgVXNlclNpZGVJbnB1dCB9IGZyb20gJ2ludGVybmFsL3NoYXJlZC1tZXRhcGxleCc7XG5pbXBvcnQgeyBGaW5kLCBPbkVyciwgT25PaywgU29ydGFibGUsIFNwbFRva2VuIH0gZnJvbSAnQHNvbGFuYS1zdWl0ZS9jb3JlJztcbmltcG9ydCB7IE5mdE1ldGFkYXRhIH0gZnJvbSAnLi4vdHlwZXMvJztcblxuZXhwb3J0IG5hbWVzcGFjZSBNZXRhcGxleCB7XG4gIC8qKlxuICAgKiBGZXRjaCBtaW50ZWQgbWV0YWRhdGEgYnkgb3duZXIgUHVia2V5XG4gICAqXG4gICAqIEBwYXJhbSB7UHVia2V5fSBvd25lclxuICAgKiBAcGFyYW0ge09uT2t9IG9uT2sgY2FsbGJhY2sgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtPbkVycn0gb25FcnIgY2FsbGJhY2sgZnVuY3Rpb25cbiAgICogQHBhcmFtIHt7c29ydGFibGU/OiBTb3J0YWJsZSwgaXNIb2xkZXI/OiBib29sZWFufX0gb3B0aW9ucz9cbiAgICogQHJldHVybiBQcm9taXNlPHZvaWQ+XG4gICAqL1xuICBleHBvcnQgY29uc3QgZmluZEJ5T3duZXIgPSBhc3luYyAoXG4gICAgb3duZXI6IFB1YmtleSxcbiAgICBvbk9rOiBPbk9rPEZpbmQ+LFxuICAgIG9uRXJyOiBPbkVycixcbiAgICBvcHRpb25zPzogeyBzb3J0YWJsZT86IFNvcnRhYmxlOyBpc0hvbGRlcj86IGJvb2xlYW4gfVxuICApOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgICBjb25zdCBzb3J0YWJsZSA9ICFvcHRpb25zPy5zb3J0YWJsZSA/IFNvcnRhYmxlLkRlc2MgOiBvcHRpb25zPy5zb3J0YWJsZTtcbiAgICBjb25zdCBpc0hvbGRlciA9ICFvcHRpb25zPy5pc0hvbGRlciA/IHRydWUgOiBmYWxzZTtcbiAgICBhd2FpdCBTcGxUb2tlbi5nZW5lcmljRmluZEJ5T3duZXI8TmZ0TWV0YWRhdGE+KFxuICAgICAgb3duZXIsXG4gICAgICAocmVzdWx0KSA9PiByZXN1bHQubWF0Y2gob25Paywgb25FcnIpLFxuICAgICAgVXNlclNpZGVJbnB1dC5Ub2tlblN0YW5kYXJkLk5vbkZ1bmdpYmxlLFxuICAgICAgc29ydGFibGUsXG4gICAgICBpc0hvbGRlclxuICAgICk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEZldGNoIG1pbnRlZCBtZXRhZGF0YSBieSBtaW50IGFkZHJlc3NcbiAgICpcbiAgICogQHBhcmFtIHtQdWJrZXl9IG1pbnRcbiAgICogQHJldHVybiBQcm9taXNlPFJlc3VsdDxOZnRNZXRhZGF0YSwgRXJyb3I+PlxuICAgKi9cbiAgZXhwb3J0IGNvbnN0IGZpbmRCeU1pbnQgPSBhc3luYyAoXG4gICAgbWludDogUHVia2V5XG4gICk6IFByb21pc2U8UmVzdWx0PE5mdE1ldGFkYXRhLCBFcnJvcj4+ID0+IHtcbiAgICByZXR1cm4gYXdhaXQgU3BsVG9rZW4uZ2VuZXJpY0ZpbmRCeU1pbnQ8TmZ0TWV0YWRhdGE+KFxuICAgICAgbWludCxcbiAgICAgIFVzZXJTaWRlSW5wdXQuVG9rZW5TdGFuZGFyZC5Ob25GdW5naWJsZVxuICAgICk7XG4gIH07XG59XG4iLCAiaW1wb3J0IHtcbiAgSW5zdHJ1Y3Rpb24sXG4gIEtleXBhaXJBY2NvdW50LFxuICBQdWJrZXksXG4gIFJlc3VsdCxcbiAgU2VjcmV0LFxuICBUcnksXG59IGZyb20gJ0Bzb2xhbmEtc3VpdGUvc2hhcmVkJztcbmltcG9ydCB7IFBkYSB9IGZyb20gJ2ludGVybmFsL3NoYXJlZC1tZXRhcGxleCc7XG5pbXBvcnQgeyBnZXRBc3NvY2lhdGVkVG9rZW5BZGRyZXNzU3luYyB9IGZyb20gJ0Bzb2xhbmEvc3BsLXRva2VuJztcbmltcG9ydCB7IGNyZWF0ZUZyZWV6ZURlbGVnYXRlZEFjY291bnRJbnN0cnVjdGlvbiB9IGZyb20gJ0BtZXRhcGxleC1mb3VuZGF0aW9uL21wbC10b2tlbi1tZXRhZGF0YSc7XG5cbmV4cG9ydCBuYW1lc3BhY2UgTWV0YXBsZXgge1xuICAvKipcbiAgICogRnJlZXppbmcgYSB0YXJnZXQgbmZ0XG4gICAqIGl0IHNob3VsZCBzZXQgdG8gZnJlZXplQXV0aG9yaXR5IHdoZW4gbWludCgpXG4gICAqIEBwYXJhbSB7UHVia2V5fSBtaW50ICAgICAgICAgICAgIC8vIG1pbnQgYWRkcmVzc1xuICAgKiBAcGFyYW0ge1B1YmtleX0gb3duZXIgICAgICAgICAgICAvLyBjdXJyZW50IG93bmVyXG4gICAqIEBwYXJhbSB7U2VjcmV0fSBmcmVlemVBdXRob3JpdHkgIC8vIHNldHRlZCBmcmVlemUgYXV0aG9yaXR5IG9mIG5mdFxuICAgKiBAcGFyYW0ge1NlY3JldH0gZmVlUGF5ZXI/ICAgICAgIC8vIGZlZSBwYXllclxuICAgKi9cbiAgZXhwb3J0IGNvbnN0IGZyZWV6ZSA9IChcbiAgICBtaW50OiBQdWJrZXksXG4gICAgb3duZXI6IFB1YmtleSxcbiAgICBmcmVlemVBdXRob3JpdHk6IFNlY3JldCxcbiAgICBmZWVQYXllcj86IFNlY3JldFxuICApOiBSZXN1bHQ8SW5zdHJ1Y3Rpb24sIEVycm9yPiA9PiB7XG4gICAgY29uc3QgcGF5ZXIgPSBmZWVQYXllciA/IGZlZVBheWVyIDogZnJlZXplQXV0aG9yaXR5O1xuICAgIHJldHVybiBUcnkoKCkgPT4ge1xuICAgICAgY29uc3QgdG9rZW5BY2NvdW50ID0gZ2V0QXNzb2NpYXRlZFRva2VuQWRkcmVzc1N5bmMoXG4gICAgICAgIG1pbnQudG9QdWJsaWNLZXkoKSxcbiAgICAgICAgb3duZXIudG9QdWJsaWNLZXkoKVxuICAgICAgKTtcbiAgICAgIGNvbnN0IGVkaXRpb25BZGRyZXNzID0gUGRhLmdldE1hc3RlckVkaXRpb24obWludCk7XG5cbiAgICAgIGNvbnN0IGluc3QgPSBjcmVhdGVGcmVlemVEZWxlZ2F0ZWRBY2NvdW50SW5zdHJ1Y3Rpb24oe1xuICAgICAgICBkZWxlZ2F0ZTogbmV3IEtleXBhaXJBY2NvdW50KHsgc2VjcmV0OiBmcmVlemVBdXRob3JpdHkgfSkudG9QdWJsaWNLZXkoKSxcbiAgICAgICAgdG9rZW5BY2NvdW50OiB0b2tlbkFjY291bnQsXG4gICAgICAgIGVkaXRpb246IGVkaXRpb25BZGRyZXNzLFxuICAgICAgICBtaW50OiBtaW50LnRvUHVibGljS2V5KCksXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBuZXcgSW5zdHJ1Y3Rpb24oXG4gICAgICAgIFtpbnN0XSxcbiAgICAgICAgW2ZyZWV6ZUF1dGhvcml0eS50b0tleXBhaXIoKV0sXG4gICAgICAgIHBheWVyLnRvS2V5cGFpcigpXG4gICAgICApO1xuICAgIH0pO1xuICB9O1xufVxuIiwgImltcG9ydCB7XG4gIGRlYnVnTG9nLFxuICBLZXlwYWlyQWNjb3VudCxcbiAgTm9kZSxcbiAgUGFydGlhbFNpZ25JbnN0cnVjdGlvbixcbiAgUHVia2V5LFxuICBSZXN1bHQsXG4gIFNlY3JldCxcbiAgVHJ5LFxufSBmcm9tICdAc29sYW5hLXN1aXRlL3NoYXJlZCc7XG5cbmltcG9ydCB7IFRyYW5zYWN0aW9uIH0gZnJvbSAnQHNvbGFuYS93ZWIzLmpzJztcblxuaW1wb3J0IHsgU3RvcmFnZSB9IGZyb20gJ2ludGVybmFsL3N0b3JhZ2UnO1xuXG5pbXBvcnQge1xuICBDb252ZXJ0LFxuICBSb3lhbHR5LFxuICBVc2VyU2lkZUlucHV0LFxuICBWYWxpZGF0b3IsXG59IGZyb20gJ2ludGVybmFsL3NoYXJlZC1tZXRhcGxleCc7XG5cbmltcG9ydCB7IE1ldGFwbGV4IGFzIF9NaW50IH0gZnJvbSAnLi9taW50JztcblxuZXhwb3J0IG5hbWVzcGFjZSBNZXRhcGxleCB7XG4gIC8qKlxuICAgKiBVcGxvYWQgY29udGVudCBhbmQgTkZUIG1pbnQgd2l0aCBQYXJ0aWFsIFNpZ25cbiAgICpcbiAgICogQHBhcmFtIHtQdWJrZXl9IG93bmVyICAgICAgICAgIC8vIGZpcnN0IG1pbnRlZCBvd25lclxuICAgKiBAcGFyYW0ge1NlY3JldH0gc2lnbmVyICAgICAgICAgLy8gb3duZXIncyBTZWNyZXRcbiAgICogQHBhcmFtIHtVc2VyU2lkZUlucHV0Lk5mdE1ldGFkYXRhfSBpbnB1dFxuICAgKiB7XG4gICAqICAgbmFtZTogc3RyaW5nICAgICAgICAgICAgICAgLy8gbmZ0IGNvbnRlbnQgbmFtZVxuICAgKiAgIHN5bWJvbDogc3RyaW5nICAgICAgICAgICAgIC8vIG5mdCB0aWNrZXIgc3ltYm9sXG4gICAqICAgZmlsZVBhdGg6IHN0cmluZyB8IEZpbGUgICAgLy8gbmZ0IHRpY2tlciBzeW1ib2xcbiAgICogICByb3lhbHR5OiBudW1iZXIgICAgICAgICAgICAvLyByb3lhbHR5IHBlcmNlbnRhZ2VcbiAgICogICBzdG9yYWdlVHlwZTogJ2Fyd2VhdmUnfCduZnRTdG9yYWdlJyAvLyByb3lhbHR5IHBlcmNlbnRhZ2VcbiAgICogICBkZXNjcmlwdGlvbj86IHN0cmluZyAgICAgICAvLyBuZnQgY29udGVudCBkZXNjcmlwdGlvblxuICAgKiAgIGV4dGVybmFsX3VybD86IHN0cmluZyAgICAgIC8vIGxhbmRpbmcgcGFnZSwgaG9tZSBwYWdlIHVyaSwgcmVsYXRlZCB1cmxcbiAgICogICBhdHRyaWJ1dGVzPzogTWV0YWRhdGFBdHRyaWJ1dGVbXSAgICAgLy8gZ2FtZSBjaGFyYWN0ZXIgcGFyYW1ldGVyLCBwZXJzb25hbGl0eSwgY2hhcmFjdGVyaXN0aWNzXG4gICAqICAgcHJvcGVydGllcz86IE1ldGFkYXRhUHJvcGVydGllczxVcmk+IC8vIGluY2x1ZGUgZmlsZSBuYW1lLCB1cmksIHN1cHBvcnRlZCBmaWxlIHR5cGVcbiAgICogICBjb2xsZWN0aW9uPzogUHVia2V5ICAgICAgICAgICAvLyBjb2xsZWN0aW9ucyBvZiBkaWZmZXJlbnQgY29sb3JzLCBzaGFwZXMsIGV0Yy5cbiAgICogICBba2V5OiBzdHJpbmddPzogdW5rbm93biAgICAgICAvLyBvcHRpb25hbCBwYXJhbSwgVXN1YWxseSBub3QgdXNlZC5cbiAgICogICBjcmVhdG9ycz86IElucHV0Q3JlYXRvcnNbXSAgICAgICAgICAvLyBvdGhlciBjcmVhdG9ycyB0aGFuIG93bmVyXG4gICAqICAgdXNlcz86IFVzZXMgICAgICAgICAgICAgICAgICAgLy8gdXNhZ2UgZmVhdHVyZTogYnVybiwgc2luZ2xlLCBtdWx0aXBsZVxuICAgKiAgIGlzTXV0YWJsZT86IGJvb2xlYW4gICAgICAgICAgIC8vIGVuYWJsZSB1cGRhdGUoKVxuICAgKiB9XG4gICAqIEBwYXJhbSB7U2VjcmV0fSBmZWVQYXllcj8gICAgICAgICAvLyBmZWUgcGF5ZXJcbiAgICogQHBhcmFtIHtQdWJrZXl9IGZyZWV6ZUF1dGhvcml0eT8gIC8vIGZyZWV6ZSBhdXRob3JpdHlcbiAgICogQHJldHVybiBQcm9taXNlPFJlc3VsdDxQYXJ0aWFsU2lnbkluc3RydWN0aW9uLCBFcnJvcj4+XG4gICAqL1xuICBleHBvcnQgY29uc3QgZmVlUGF5ZXJQYXJ0aWFsU2lnbk1pbnQgPSBhc3luYyAoXG4gICAgb3duZXI6IFB1YmtleSxcbiAgICBzaWduZXI6IFNlY3JldCxcbiAgICBpbnB1dDogVXNlclNpZGVJbnB1dC5OZnRNZXRhZGF0YSxcbiAgICBmZWVQYXllcjogUHVia2V5LFxuICAgIGZyZWV6ZUF1dGhvcml0eT86IFNlY3JldFxuICApOiBQcm9taXNlPFJlc3VsdDxQYXJ0aWFsU2lnbkluc3RydWN0aW9uLCBFcnJvcj4+ID0+IHtcbiAgICByZXR1cm4gVHJ5KGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHZhbGlkID0gVmFsaWRhdG9yLmNoZWNrQWxsPFVzZXJTaWRlSW5wdXQuTmZ0TWV0YWRhdGE+KGlucHV0KTtcbiAgICAgIGlmICh2YWxpZC5pc0Vycikge1xuICAgICAgICB0aHJvdyB2YWxpZC5lcnJvcjtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgc2VsbGVyRmVlQmFzaXNQb2ludHMgPSBSb3lhbHR5LmNvbnZlcnQoaW5wdXQucm95YWx0eSk7XG5cbiAgICAgIC8vLS0tIHBvcnBlcnRpZXMsIFVwbG9hZCBjb250ZW50IC0tLVxuICAgICAgbGV0IHVyaSA9ICcnO1xuICAgICAgaWYgKGlucHV0LmZpbGVQYXRoICYmIGlucHV0LnN0b3JhZ2VUeXBlID09PSAnbmZ0U3RvcmFnZScpIHtcbiAgICAgICAgY29uc3QgcHJvcGVydGllcyA9IGF3YWl0IENvbnZlcnQuUHJvcGVydGllcy5pbnRvSW5mcmFTaWRlKFxuICAgICAgICAgIGlucHV0LnByb3BlcnRpZXMsXG4gICAgICAgICAgU3RvcmFnZS51cGxvYWRDb250ZW50LFxuICAgICAgICAgIGlucHV0LnN0b3JhZ2VUeXBlXG4gICAgICAgICk7XG5cbiAgICAgICAgY29uc3QgbmZ0U3RvcmFnZU1ldGFkYXRhID0gU3RvcmFnZS50b0NvbnZlcnRPZmZjaGFpbmRhdGEoXG4gICAgICAgICAgeyAuLi5pbnB1dCwgcHJvcGVydGllcyB9LFxuICAgICAgICAgIHNlbGxlckZlZUJhc2lzUG9pbnRzXG4gICAgICAgICk7XG5cbiAgICAgICAgY29uc3QgdXBsb2FkZWQgPSBhd2FpdCBTdG9yYWdlLnVwbG9hZE1ldGFBbmRDb250ZW50KFxuICAgICAgICAgIG5mdFN0b3JhZ2VNZXRhZGF0YSxcbiAgICAgICAgICBpbnB1dC5maWxlUGF0aCxcbiAgICAgICAgICBpbnB1dC5zdG9yYWdlVHlwZVxuICAgICAgICApO1xuICAgICAgICBpZiAodXBsb2FkZWQuaXNFcnIpIHtcbiAgICAgICAgICB0aHJvdyB1cGxvYWRlZDtcbiAgICAgICAgfVxuICAgICAgICB1cmkgPSB1cGxvYWRlZC52YWx1ZTtcbiAgICAgICAgZGVidWdMb2coJyMgdXBsb2FkIGNvbnRlbnQgdXJsOiAnLCB1cGxvYWRlZCk7XG4gICAgICB9IGVsc2UgaWYgKGlucHV0LnVyaSkge1xuICAgICAgICB1cmkgPSBpbnB1dC51cmk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBFcnJvcihgTXVzdCBzZXQgJ3N0b3JhZ2VUeXBlPW5mdFN0b3JhZ2UgKyBmaWxlUGF0aCcgb3IgJ3VyaSdgKTtcbiAgICAgIH1cbiAgICAgIC8vLS0tIHBvcnBlcnRpZXMsIFVwbG9hZCBjb250ZW50IC0tLVxuXG4gICAgICBsZXQgZGF0YXYyID0gQ29udmVydC5OZnRNZXRhZGF0YS5pbnRvSW5mcmFTaWRlKFxuICAgICAgICBpbnB1dCxcbiAgICAgICAgdXJpLFxuICAgICAgICBzZWxsZXJGZWVCYXNpc1BvaW50c1xuICAgICAgKTtcblxuICAgICAgLy8tLS0gY29sbGVjdGlvbiAtLS1cbiAgICAgIGxldCBjb2xsZWN0aW9uO1xuICAgICAgaWYgKGlucHV0LmNvbGxlY3Rpb24gJiYgaW5wdXQuY29sbGVjdGlvbikge1xuICAgICAgICBjb2xsZWN0aW9uID0gQ29udmVydC5Db2xsZWN0aW9uLmludG9JbmZyYVNpZGUoaW5wdXQuY29sbGVjdGlvbik7XG4gICAgICAgIGRhdGF2MiA9IHsgLi4uZGF0YXYyLCBjb2xsZWN0aW9uIH07XG4gICAgICB9XG4gICAgICAvLy0tLSBjb2xsZWN0aW9uIC0tLVxuXG4gICAgICBjb25zdCBpc011dGFibGUgPSBpbnB1dC5pc011dGFibGUgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBpbnB1dC5pc011dGFibGU7XG5cbiAgICAgIGRlYnVnTG9nKCcjIGlucHV0OiAnLCBpbnB1dCk7XG4gICAgICBkZWJ1Z0xvZygnIyBzZWxsZXJGZWVCYXNpc1BvaW50czogJywgc2VsbGVyRmVlQmFzaXNQb2ludHMpO1xuICAgICAgZGVidWdMb2coJyMgZGF0YXYyOiAnLCBkYXRhdjIpO1xuXG4gICAgICBjb25zdCBtaW50ID0gS2V5cGFpckFjY291bnQuY3JlYXRlKCk7XG4gICAgICBjb25zdCBpbnN0cyA9IGF3YWl0IF9NaW50LmNyZWF0ZU1pbnRJbnN0cnVjdGlvbnMoXG4gICAgICAgIG1pbnQudG9QdWJsaWNLZXkoKSxcbiAgICAgICAgb3duZXIudG9QdWJsaWNLZXkoKSxcbiAgICAgICAgZGF0YXYyLFxuICAgICAgICBmZWVQYXllci50b1B1YmxpY0tleSgpLFxuICAgICAgICBpc011dGFibGVcbiAgICAgICk7XG5cbiAgICAgIC8vIGZyZWV6ZUF1dGhvcml0eVxuICAgICAgaWYgKGZyZWV6ZUF1dGhvcml0eSkge1xuICAgICAgICBpbnN0cy5wdXNoKFxuICAgICAgICAgIF9NaW50LmNyZWF0ZURlbGVhZ2F0ZUluc3RydWN0aW9uKFxuICAgICAgICAgICAgbWludC50b1B1YmxpY0tleSgpLFxuICAgICAgICAgICAgb3duZXIudG9QdWJsaWNLZXkoKSxcbiAgICAgICAgICAgIGZyZWV6ZUF1dGhvcml0eS50b1B1YmxpY0tleSgpXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBibG9ja2hhc2hPYmogPSBhd2FpdCBOb2RlLmdldENvbm5lY3Rpb24oKS5nZXRMYXRlc3RCbG9ja2hhc2goKTtcbiAgICAgIGNvbnN0IHR4ID0gbmV3IFRyYW5zYWN0aW9uKHtcbiAgICAgICAgbGFzdFZhbGlkQmxvY2tIZWlnaHQ6IGJsb2NraGFzaE9iai5sYXN0VmFsaWRCbG9ja0hlaWdodCxcbiAgICAgICAgYmxvY2toYXNoOiBibG9ja2hhc2hPYmouYmxvY2toYXNoLFxuICAgICAgICBmZWVQYXllcjogZmVlUGF5ZXIudG9QdWJsaWNLZXkoKSxcbiAgICAgIH0pO1xuXG4gICAgICBpbnN0cy5mb3JFYWNoKChpbnN0KSA9PiB0eC5hZGQoaW5zdCkpO1xuICAgICAgdHgucmVjZW50QmxvY2toYXNoID0gYmxvY2toYXNoT2JqLmJsb2NraGFzaDtcbiAgICAgIFtzaWduZXIsIG1pbnRdLmZvckVhY2goKHNpZ25lcikgPT4gdHgucGFydGlhbFNpZ24oc2lnbmVyLnRvS2V5cGFpcigpKSk7XG5cbiAgICAgIGNvbnN0IHNlcmlhbGl6ZWRUeCA9IHR4LnNlcmlhbGl6ZSh7XG4gICAgICAgIHJlcXVpcmVBbGxTaWduYXR1cmVzOiBmYWxzZSxcbiAgICAgIH0pO1xuICAgICAgY29uc3QgaGV4ID0gc2VyaWFsaXplZFR4LnRvU3RyaW5nKCdoZXgnKTtcbiAgICAgIHJldHVybiBuZXcgUGFydGlhbFNpZ25JbnN0cnVjdGlvbihoZXgsIG1pbnQucHVia2V5KTtcbiAgICB9KTtcbiAgfTtcbn1cbiIsICJpbXBvcnQge1xuICBDdXJyZW5jeSxcbiAgTWV0YXBsZXhGaWxlLFxuICB0b01ldGFwbGV4RmlsZSxcbn0gZnJvbSAnQG1ldGFwbGV4LWZvdW5kYXRpb24vanMnO1xuXG5pbXBvcnQge1xuICBkZWJ1Z0xvZyxcbiAgaXNCcm93c2VyLFxuICBpc05vZGUsXG4gIFJlc3VsdCxcbiAgU2VjcmV0LFxuICBUcnksXG59IGZyb20gJ0Bzb2xhbmEtc3VpdGUvc2hhcmVkJztcbmltcG9ydCB7IEZpbGVDb250ZW50LCBJbmZyYVNpZGVJbnB1dCB9IGZyb20gJ2ludGVybmFsL3NoYXJlZC1tZXRhcGxleC8nO1xuaW1wb3J0IHsgQnVuZGxyIH0gZnJvbSAnLi9idW5kbHInO1xuXG5leHBvcnQgaW50ZXJmYWNlIE1ldGFwbGV4RmlsZU9wdGlvbnMge1xuICByZWFkb25seSBkaXNwbGF5TmFtZTogc3RyaW5nO1xuICByZWFkb25seSB1bmlxdWVOYW1lOiBzdHJpbmc7XG4gIHJlYWRvbmx5IGNvbnRlbnRUeXBlOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gIHJlYWRvbmx5IGV4dGVuc2lvbjogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICByZWFkb25seSB0YWdzOiB7IG5hbWU6IHN0cmluZzsgdmFsdWU6IHN0cmluZyB9W107XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgQXJ3ZWF2ZSB7XG4gIGV4cG9ydCBjb25zdCBnZXRVcGxvYWRQcmljZSA9IGFzeW5jIChcbiAgICBmaWxlUGF0aDogRmlsZUNvbnRlbnQsXG4gICAgZmVlUGF5ZXI6IFNlY3JldCxcbiAgKTogUHJvbWlzZTxSZXN1bHQ8eyBwcmljZTogbnVtYmVyOyBjdXJyZW5jeTogQ3VycmVuY3kgfSwgRXJyb3I+PiA9PiB7XG4gICAgcmV0dXJuIFRyeShhc3luYyAoKSA9PiB7XG4gICAgICBsZXQgYnVmZmVyITogQnVmZmVyO1xuICAgICAgaWYgKGlzTm9kZSgpKSB7XG4gICAgICAgIGNvbnN0IGZpbGVwYXRoID0gZmlsZVBhdGggYXMgc3RyaW5nO1xuICAgICAgICBidWZmZXIgPSAoYXdhaXQgaW1wb3J0KCdmcycpKS5yZWFkRmlsZVN5bmMoZmlsZXBhdGgpO1xuICAgICAgfSBlbHNlIGlmIChpc0Jyb3dzZXIoKSkge1xuICAgICAgICBjb25zdCBmaWxlcGF0aCA9IGZpbGVQYXRoO1xuICAgICAgICBidWZmZXIgPSB0b01ldGFwbGV4RmlsZShmaWxlcGF0aCwgJycpLmJ1ZmZlcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IEVycm9yKCdTdXBwb3J0ZWQgZW52aXJvbm1lbnQ6IG9ubHkgTm9kZS5qcyBhbmQgQnJvd3NlciBqcycpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCByZXMgPSBhd2FpdCBCdW5kbHIudXNlU3RvcmFnZShmZWVQYXllci50b0tleXBhaXIoKSkuZ2V0VXBsb2FkUHJpY2UoXG4gICAgICAgIGJ1ZmZlci5sZW5ndGgsXG4gICAgICApO1xuXG4gICAgICBjb25zdCBiYXNpc1BvaW50czogc3RyaW5nID0gcmVzLmJhc2lzUG9pbnRzLnRvU3RyaW5nKCk7XG4gICAgICBkZWJ1Z0xvZyhcbiAgICAgICAgJyMgYnVmZmVyIGxlbmd0aCwgcHJpY2UnLFxuICAgICAgICBidWZmZXIubGVuZ3RoLFxuICAgICAgICBwYXJzZUludChiYXNpc1BvaW50cykudG9Tb2woKSxcbiAgICAgICk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwcmljZTogcGFyc2VJbnQoYmFzaXNQb2ludHMpLnRvU29sKCksXG4gICAgICAgIGN1cnJlbmN5OiByZXMuY3VycmVuY3ksXG4gICAgICB9O1xuICAgIH0pO1xuICB9O1xuXG4gIGV4cG9ydCBjb25zdCB1cGxvYWRDb250ZW50ID0gYXN5bmMgKFxuICAgIGZpbGVQYXRoOiBGaWxlQ29udGVudCxcbiAgICBmZWVQYXllcjogU2VjcmV0LFxuICAgIGZpbGVPcHRpb25zPzogTWV0YXBsZXhGaWxlT3B0aW9ucywgLy8gb25seSBhcndlYXZlLCBub3QgbmZ0LXN0b3JhZ2VcbiAgKTogUHJvbWlzZTxSZXN1bHQ8c3RyaW5nLCBFcnJvcj4+ID0+IHtcbiAgICByZXR1cm4gVHJ5KGFzeW5jICgpID0+IHtcbiAgICAgIGRlYnVnTG9nKCcjIHVwbG9hZCBjb250ZW50OiAnLCBmaWxlUGF0aCk7XG4gICAgICBsZXQgZmlsZSE6IE1ldGFwbGV4RmlsZTtcbiAgICAgIGlmIChpc05vZGUoKSkge1xuICAgICAgICBjb25zdCBmaWxlcGF0aCA9IGZpbGVQYXRoIGFzIHN0cmluZztcbiAgICAgICAgY29uc3QgYnVmZmVyID0gKGF3YWl0IGltcG9ydCgnZnMnKSkucmVhZEZpbGVTeW5jKGZpbGVwYXRoKTtcbiAgICAgICAgaWYgKGZpbGVPcHRpb25zKSB7XG4gICAgICAgICAgZmlsZSA9IHRvTWV0YXBsZXhGaWxlKGJ1ZmZlciwgZmlsZXBhdGgsIGZpbGVPcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmaWxlID0gdG9NZXRhcGxleEZpbGUoYnVmZmVyLCBmaWxlcGF0aCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNCcm93c2VyKCkpIHtcbiAgICAgICAgY29uc3QgZmlsZXBhdGggPSBmaWxlUGF0aDtcbiAgICAgICAgaWYgKGZpbGVPcHRpb25zKSB7XG4gICAgICAgICAgZmlsZSA9IHRvTWV0YXBsZXhGaWxlKGZpbGVwYXRoLCAnJywgZmlsZU9wdGlvbnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZpbGUgPSB0b01ldGFwbGV4RmlsZShmaWxlcGF0aCwgJycpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBFcnJvcignU3VwcG9ydGVkIGVudmlyb25tZW50OiBvbmx5IE5vZGUuanMgYW5kIEJyb3dzZXIganMnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIEJ1bmRsci51c2VTdG9yYWdlKGZlZVBheWVyLnRvS2V5cGFpcigpKS51cGxvYWQoZmlsZSk7XG4gICAgfSk7XG4gIH07XG5cbiAgZXhwb3J0IGNvbnN0IHVwbG9hZE1ldGFkYXRhID0gYXN5bmMgKFxuICAgIG1ldGFkYXRhOiBJbmZyYVNpZGVJbnB1dC5PZmZjaGFpbixcbiAgICBmZWVQYXllcjogU2VjcmV0LFxuICApOiBQcm9taXNlPFJlc3VsdDxzdHJpbmcsIEVycm9yPj4gPT4ge1xuICAgIHJldHVybiBUcnkoYXN5bmMgKCkgPT4ge1xuICAgICAgZGVidWdMb2coJyMgdXBsb2FkIG1ldGEgZGF0YTogJywgbWV0YWRhdGEpO1xuXG4gICAgICBjb25zdCB1cGxvYWRlZCA9IGF3YWl0IEJ1bmRsci5tYWtlKGZlZVBheWVyLnRvS2V5cGFpcigpKVxuICAgICAgICAubmZ0cygpXG4gICAgICAgIC51cGxvYWRNZXRhZGF0YShtZXRhZGF0YSk7XG5cbiAgICAgIHJldHVybiB1cGxvYWRlZC51cmk7XG4gICAgfSk7XG4gIH07XG59XG4iLCAiaW1wb3J0IHtcbiAgTWV0YXBsZXggYXMgTWV0YXBsZXhGb3VuZGF0aW9uLFxuICBrZXlwYWlySWRlbnRpdHksXG4gIGJ1bmRsclN0b3JhZ2UsXG4gIEJ1bmRsclN0b3JhZ2VEcml2ZXIsXG4gIHdhbGxldEFkYXB0ZXJJZGVudGl0eSxcbn0gZnJvbSAnQG1ldGFwbGV4LWZvdW5kYXRpb24vanMnO1xuXG5pbXBvcnQgeyBLZXlwYWlyIH0gZnJvbSAnQHNvbGFuYS93ZWIzLmpzJztcbmltcG9ydCB7IE5vZGUsIENvbnN0YW50cyB9IGZyb20gJ0Bzb2xhbmEtc3VpdGUvc2hhcmVkJztcbmltcG9ydCB7IEJ1bmRsclNpZ25lciwgUGhhbnRvbSB9IGZyb20gJy4vdHlwZXMvYnVuZGxyJztcblxuZXhwb3J0IG5hbWVzcGFjZSBCdW5kbHIge1xuICBjb25zdCBCVU5ETFJfQ09OTkVDVF9USU1FT1VUID0gNjAwMDA7XG5cbiAgZXhwb3J0IGNvbnN0IG1ha2UgPSAoZmVlUGF5ZXI/OiBCdW5kbHJTaWduZXIpOiBNZXRhcGxleEZvdW5kYXRpb24gPT4ge1xuICAgIGNvbnN0IG9iamVjdCA9IE1ldGFwbGV4Rm91bmRhdGlvbi5tYWtlKE5vZGUuZ2V0Q29ubmVjdGlvbigpKS51c2UoXG4gICAgICBidW5kbHJTdG9yYWdlKHtcbiAgICAgICAgYWRkcmVzczogQ29uc3RhbnRzLkJVTkRMUl9ORVRXT1JLX1VSTCxcbiAgICAgICAgcHJvdmlkZXJVcmw6IENvbnN0YW50cy5zd2l0Y2hDbHVzdGVyKHtcbiAgICAgICAgICBjbHVzdGVyOiBDb25zdGFudHMuY3VycmVudENsdXN0ZXIsXG4gICAgICAgIH0pLFxuICAgICAgICB0aW1lb3V0OiBCVU5ETFJfQ09OTkVDVF9USU1FT1VULFxuICAgICAgfSlcbiAgICApO1xuICAgIGlmIChpc0tleXBhaXIoZmVlUGF5ZXIpKSB7XG4gICAgICBvYmplY3QudXNlKGtleXBhaXJJZGVudGl0eShmZWVQYXllcikpO1xuICAgIH0gZWxzZSBpZiAoaXNQaGFudG9tKGZlZVBheWVyKSkge1xuICAgICAgb2JqZWN0LnVzZSh3YWxsZXRBZGFwdGVySWRlbnRpdHkoZmVlUGF5ZXIpKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfTtcblxuICBleHBvcnQgY29uc3QgdXNlU3RvcmFnZSA9IChmZWVQYXllcjogQnVuZGxyU2lnbmVyKTogQnVuZGxyU3RvcmFnZURyaXZlciA9PiB7XG4gICAgcmV0dXJuIG1ha2UoZmVlUGF5ZXIpLnN0b3JhZ2UoKS5kcml2ZXIoKSBhcyBCdW5kbHJTdG9yYWdlRHJpdmVyO1xuICB9O1xuXG4gIGNvbnN0IGlzS2V5cGFpciA9IChwYXllcjogQnVuZGxyU2lnbmVyKTogcGF5ZXIgaXMgS2V5cGFpciA9PiB7XG4gICAgaWYgKCFwYXllcikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gJ3NlY3JldEtleScgaW4gcGF5ZXI7XG4gIH07XG5cbiAgY29uc3QgaXNQaGFudG9tID0gKHBheWVyOiBCdW5kbHJTaWduZXIpOiBwYXllciBpcyBQaGFudG9tID0+IHtcbiAgICBpZiAoIXBheWVyKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiAnY29ubmVjdCcgaW4gcGF5ZXI7XG4gIH07XG59XG4iLCAiaW1wb3J0IHsgTkZUU3RvcmFnZSwgQmxvYiB9IGZyb20gJ25mdC5zdG9yYWdlJztcbmltcG9ydCB7XG4gIENvbnN0YW50cyxcbiAgUmVzdWx0LFxuICBpc05vZGUsXG4gIGlzQnJvd3NlcixcbiAgZGVidWdMb2csXG4gIFRyeSxcbn0gZnJvbSAnQHNvbGFuYS1zdWl0ZS9zaGFyZWQnO1xuXG5pbXBvcnQgeyB0b01ldGFwbGV4RmlsZSB9IGZyb20gJ0BtZXRhcGxleC1mb3VuZGF0aW9uL2pzJztcbmltcG9ydCB7IEluZnJhU2lkZUlucHV0LCBGaWxlQ29udGVudCB9IGZyb20gJ2ludGVybmFsL3NoYXJlZC1tZXRhcGxleCc7XG5cbmV4cG9ydCBuYW1lc3BhY2UgTmZ0U3RvcmFnZSB7XG4gIGxldCBpc0Rpc3BsYXlXYXJuaW5nID0gZmFsc2U7XG4gIGNvbnN0IGdldE5mdFN0b3JhZ2VBcGlLZXkgPSAoKTogc3RyaW5nID0+IHtcbiAgICBpZiAoIUNvbnN0YW50cy5uZnRTdG9yYWdlQXBpS2V5KSB7XG4gICAgICBpZiAoIWlzRGlzcGxheVdhcm5pbmcpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIGBcbiAgICAgICAgW1dhcm5pbmddXG4gICAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIElmIHdpbGwgdXNlIEBzb2xhbmEtc3VpdGUvbmZ0IHBhY2thZ2VcbiAgICAgICAgeW91ciBuZWVkIHRvIHVwZGF0ZSBuZnRTdG9yYWdlLmFwaUtleSBkZWZpbmUgcGFyYW1ldGVyIGluIHNvbGFuYS1zdWl0ZS5qc29uLlxuICAgICAgICBjYW4gZ2V0IGFwaUtleSBmcm9tIGh0dHBzOi8vbmZ0LnN0b3JhZ2UvXG4gICAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIGBcbiAgICAgICAgKTtcbiAgICAgICAgaXNEaXNwbGF5V2FybmluZyA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gQ29uc3RhbnRzLk5GVF9TVE9SQUdFX0FQSV9LRVk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBDb25zdGFudHMubmZ0U3RvcmFnZUFwaUtleTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgY3JlYXRlR2F0ZXdheVVybCA9IChjaWQ6IHN0cmluZyk6IHN0cmluZyA9PlxuICAgIGAke0NvbnN0YW50cy5ORlRfU1RPUkFHRV9HQVRFV0FZX1VSTH0vJHtjaWR9YDtcblxuICBjb25zdCBjb25uZWN0ID0gKCkgPT4gbmV3IE5GVFN0b3JhZ2UoeyB0b2tlbjogZ2V0TmZ0U3RvcmFnZUFwaUtleSgpIH0pO1xuXG4gIGV4cG9ydCBjb25zdCB1cGxvYWRDb250ZW50ID0gYXN5bmMgKFxuICAgIGZpbGVQYXRoOiBGaWxlQ29udGVudFxuICApOiBQcm9taXNlPFJlc3VsdDxzdHJpbmcsIEVycm9yPj4gPT4ge1xuICAgIHJldHVybiBUcnkoYXN5bmMgKCkgPT4ge1xuICAgICAgZGVidWdMb2coJyMgdXBsb2FkIGNvbnRlbnQ6ICcsIGZpbGVQYXRoKTtcbiAgICAgIGxldCBmaWxlITogQnVmZmVyO1xuICAgICAgaWYgKGlzTm9kZSgpKSB7XG4gICAgICAgIGNvbnN0IGZpbGVwYXRoID0gZmlsZVBhdGggYXMgc3RyaW5nO1xuICAgICAgICBmaWxlID0gKGF3YWl0IGltcG9ydCgnZnMnKSkucmVhZEZpbGVTeW5jKGZpbGVwYXRoKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNCcm93c2VyKCkpIHtcbiAgICAgICAgY29uc3QgZmlsZXBhdGggPSBmaWxlUGF0aDtcbiAgICAgICAgZmlsZSA9IHRvTWV0YXBsZXhGaWxlKGZpbGVwYXRoLCAnJykuYnVmZmVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ1N1cHBvcnRlZCBlbnZpcm9ubWVudDogb25seSBOb2RlLmpzIGFuZCBCcm93c2VyIGpzJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGJsb2JJbWFnZSA9IG5ldyBCbG9iKFtmaWxlXSk7XG4gICAgICBjb25zdCByZXMgPSBhd2FpdCBjb25uZWN0KCkuc3RvcmVCbG9iKGJsb2JJbWFnZSk7XG4gICAgICByZXR1cm4gY3JlYXRlR2F0ZXdheVVybChyZXMpO1xuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVcGxvYWQgY29udGVudFxuICAgKlxuICAgKiBAcGFyYW0ge1N0b3JhZ2VNZXRhZGF0YX0gbWV0YWRhdGFcbiAgICoge1xuICAgKiAgIG5hbWU/OiB7c3RyaW5nfSAgICAgICAgICAgICAgICAgICAgICAvLyBuZnQgY29udGVudCBuYW1lXG4gICAqICAgc3ltYm9sPzoge3N0cmluZ30gICAgICAgICAgICAgICAgICAgIC8vIG5mdCB0aWNrZXIgc3ltYm9sXG4gICAqICAgZGVzY3JpcHRpb24/OiB7c3RyaW5nfSAgICAgICAgICAgICAgIC8vIG5mdCBjb250ZW50IGRlc2NyaXB0aW9uXG4gICAqICAgc2VsbGVyRmVlQmFzaXNQb2ludHM/OiBudW1iZXIgICAgICAgIC8vIHJveWFsdHkgcGVyY2VudGFnZVxuICAgKiAgIGltYWdlPzoge3N0cmluZ30gICAgICAgICAgICAgICAgICAgICAvLyB1cGxvYWRlZCB1cmkgb2Ygb3JpZ2luYWwgY29udGVudFxuICAgKiAgIGV4dGVybmFsX3VybD86IHtzdHJpbmd9ICAgICAgICAgICAgICAvLyBsYW5kaW5nIHBhZ2UsIGhvbWUgcGFnZSB1cmksIHJlbGF0ZWQgdXJsXG4gICAqICAgYXR0cmlidXRlcz86IHtKc29uTWV0YWRhdGFBdHRyaWJ1dGVbXX0gICAgIC8vIGdhbWUgY2hhcmFjdGVyIHBhcmFtZXRlciwgcGVyc29uYWxpdHksIGNoYXJhY3RlcmlzdGljc1xuICAgKiAgIHByb3BlcnRpZXM/OiB7SnNvbk1ldGFkYXRhUHJvcGVydGllczxVcmk+fSAvLyBpbmNsdWRlZCBmaWxlIG5hbWUsIHVyaSwgc3VwcG9ydGVkIGZpbGUgdHlwZVxuICAgKiAgIGNvbGxlY3Rpb24/OiBDb2xsZWN0aW9uICAgICAgICAgICAgICAvLyBjb2xsZWN0aW9ucyBvZiBkaWZmZXJlbnQgY29sb3JzLCBzaGFwZXMsIGV0Yy5cbiAgICogICBba2V5OiBzdHJpbmddOiB7dW5rbm93bn0gICAgICAgICAgICAgLy8gb3B0aW9uYWwgcGFyYW0sIFVzdWFsbHkgbm90IHVzZWQuXG4gICAqIH1cbiAgICogQHJldHVybiBQcm9taXNlPFJlc3VsdDxzdHJpbmcsIEVycm9yPj5cbiAgICovXG4gIGV4cG9ydCBjb25zdCB1cGxvYWRNZXRhZGF0YSA9IGFzeW5jIChcbiAgICBtZXRhZGF0YTogSW5mcmFTaWRlSW5wdXQuT2ZmY2hhaW5cbiAgKTogUHJvbWlzZTxSZXN1bHQ8c3RyaW5nLCBFcnJvcj4+ID0+IHtcbiAgICByZXR1cm4gVHJ5KGFzeW5jICgpID0+IHtcbiAgICAgIGRlYnVnTG9nKCcjIHVwbG9hZCBtZXRhZGF0YTogJywgbWV0YWRhdGEpO1xuXG4gICAgICBjb25zdCBibG9iSnNvbiA9IG5ldyBCbG9iKFtKU09OLnN0cmluZ2lmeShtZXRhZGF0YSldKTtcbiAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IGNvbm5lY3QoKS5zdG9yZUJsb2IoYmxvYkpzb24pO1xuICAgICAgcmV0dXJuIGNyZWF0ZUdhdGV3YXlVcmwocmVzKTtcbiAgICB9KTtcbiAgfTtcbn1cbiIsICJpbXBvcnQgeyBSZXN1bHQsIFNlY3JldCB9IGZyb20gJ0Bzb2xhbmEtc3VpdGUvc2hhcmVkJztcbmltcG9ydCB7XG4gIEZpbGVDb250ZW50LFxuICBJbmZyYVNpZGVJbnB1dCxcbiAgU3RvcmFnZVR5cGUsXG4gIFVzZXJTaWRlSW5wdXQsXG59IGZyb20gJ2ludGVybmFsL3NoYXJlZC1tZXRhcGxleCc7XG5cbmltcG9ydCB7IEFyd2VhdmUgfSBmcm9tICcuL2Fyd2VhdmUnO1xuaW1wb3J0IHsgTmZ0U3RvcmFnZSB9IGZyb20gJy4vbmZ0LXN0b3JhZ2UnO1xuXG5leHBvcnQgbmFtZXNwYWNlIFN0b3JhZ2Uge1xuICBleHBvcnQgY29uc3QgdG9Db252ZXJ0T2ZmY2hhaW5kYXRhID0gKFxuICAgIGlucHV0OiBVc2VyU2lkZUlucHV0Lk5mdE1ldGFkYXRhLFxuICAgIHNlbGxlckZlZUJhc2lzUG9pbnRzOiBudW1iZXJcbiAgKTogSW5mcmFTaWRlSW5wdXQuT2ZmY2hhaW4gPT4ge1xuICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICBuYW1lOiBpbnB1dC5uYW1lLFxuICAgICAgc3ltYm9sOiBpbnB1dC5zeW1ib2wsXG4gICAgICBkZXNjcmlwdGlvbjogaW5wdXQuZGVzY3JpcHRpb24sXG4gICAgICBzZWxsZXJfZmVlX2Jhc2lzX3BvaW50czogc2VsbGVyRmVlQmFzaXNQb2ludHMsXG4gICAgICBleHRlcm5hbF91cmw6IGlucHV0LmV4dGVybmFsX3VybCxcbiAgICAgIGF0dHJpYnV0ZXM6IGlucHV0LmF0dHJpYnV0ZXMsXG4gICAgICBwcm9wZXJ0aWVzOiBpbnB1dC5wcm9wZXJ0aWVzLFxuICAgICAgaW1hZ2U6ICcnLFxuICAgICAgb3B0aW9uczogaW5wdXQub3B0aW9ucyxcbiAgICB9O1xuICAgIHJldHVybiBkYXRhO1xuICB9O1xuXG4gIGV4cG9ydCBjb25zdCB1cGxvYWRDb250ZW50ID0gYXN5bmMgKFxuICAgIGZpbGVQYXRoOiBGaWxlQ29udGVudCxcbiAgICBzdG9yYWdlVHlwZTogU3RvcmFnZVR5cGUsXG4gICAgZmVlUGF5ZXI/OiBTZWNyZXRcbiAgKTogUHJvbWlzZTxSZXN1bHQ8c3RyaW5nLCBFcnJvcj4+ID0+IHtcbiAgICBpZiAoc3RvcmFnZVR5cGUgPT09ICdhcndlYXZlJykge1xuICAgICAgaWYgKCFmZWVQYXllcikge1xuICAgICAgICB0aHJvdyBFcnJvcignQXJ3ZWF2ZSBuZWVkcyB0byBoYXZlIGZlZXBheWVyJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXdhaXQgQXJ3ZWF2ZS51cGxvYWRDb250ZW50KGZpbGVQYXRoLCBmZWVQYXllcik7XG4gICAgfSBlbHNlIGlmIChzdG9yYWdlVHlwZSA9PT0gJ25mdFN0b3JhZ2UnKSB7XG4gICAgICByZXR1cm4gYXdhaXQgTmZ0U3RvcmFnZS51cGxvYWRDb250ZW50KGZpbGVQYXRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgRXJyb3IoJ05vdCBmb3VuZCBzdG9yYWdlVHlwZScpO1xuICAgIH1cbiAgfTtcblxuICBleHBvcnQgY29uc3QgdXBsb2FkTWV0YUFuZENvbnRlbnQgPSBhc3luYyAoXG4gICAgaW5wdXQ6IEluZnJhU2lkZUlucHV0Lk9mZmNoYWluLFxuICAgIGZpbGVQYXRoOiBGaWxlQ29udGVudCxcbiAgICBzdG9yYWdlVHlwZTogU3RvcmFnZVR5cGUsXG4gICAgZmVlUGF5ZXI/OiBTZWNyZXRcbiAgKTogUHJvbWlzZTxSZXN1bHQ8c3RyaW5nLCBFcnJvcj4+ID0+IHtcbiAgICBsZXQgc3RvcmFnZTtcbiAgICBpZiAoc3RvcmFnZVR5cGUgPT09ICdhcndlYXZlJykge1xuICAgICAgaWYgKCFmZWVQYXllcikge1xuICAgICAgICB0aHJvdyBFcnJvcignQXJ3ZWF2ZSBuZWVkcyB0byBoYXZlIGZlZXBheWVyJyk7XG4gICAgICB9XG4gICAgICBzdG9yYWdlID0gYXdhaXQgKFxuICAgICAgICBhd2FpdCBBcndlYXZlLnVwbG9hZENvbnRlbnQoZmlsZVBhdGgsIGZlZVBheWVyKVxuICAgICAgKS51bndyYXAoXG4gICAgICAgIGFzeW5jIChvazogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgaW5wdXQuaW1hZ2UgPSBvaztcbiAgICAgICAgICByZXR1cm4gYXdhaXQgQXJ3ZWF2ZS51cGxvYWRNZXRhZGF0YShpbnB1dCwgZmVlUGF5ZXIpO1xuICAgICAgICB9LFxuICAgICAgICAoZXJyOiBFcnJvcikgPT4ge1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKHN0b3JhZ2VUeXBlID09PSAnbmZ0U3RvcmFnZScpIHtcbiAgICAgIHN0b3JhZ2UgPSBhd2FpdCAoXG4gICAgICAgIGF3YWl0IE5mdFN0b3JhZ2UudXBsb2FkQ29udGVudChmaWxlUGF0aClcbiAgICAgICkudW53cmFwKFxuICAgICAgICBhc3luYyAob2s6IHN0cmluZykgPT4ge1xuICAgICAgICAgIGlucHV0LmltYWdlID0gb2s7XG4gICAgICAgICAgcmV0dXJuIGF3YWl0IE5mdFN0b3JhZ2UudXBsb2FkTWV0YWRhdGEoaW5wdXQpO1xuICAgICAgICB9LFxuICAgICAgICAoZXJyOiBFcnJvcikgPT4ge1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgRXJyb3IoJ05vIG1hdGNoIHN0b3JhZ2VUeXBlJyk7XG4gICAgfVxuXG4gICAgaWYgKCFzdG9yYWdlKSB7XG4gICAgICB0aHJvdyBFcnJvcignRW1wdHkgc3RvcmFnZSBvYmplY3QnKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0b3JhZ2U7XG4gIH07XG59XG4iLCAiYXN5bmMgZnVuY3Rpb24qIF9iYXRjaChzaXplLCBpdGVyYWJsZSkge1xuICAgIGxldCBkYXRhQmF0Y2ggPSBbXTtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IGRhdGEgb2YgaXRlcmFibGUpIHtcbiAgICAgICAgZGF0YUJhdGNoLnB1c2goZGF0YSk7XG4gICAgICAgIGlmIChkYXRhQmF0Y2gubGVuZ3RoID09PSBzaXplKSB7XG4gICAgICAgICAgICB5aWVsZCBkYXRhQmF0Y2g7XG4gICAgICAgICAgICBkYXRhQmF0Y2ggPSBbXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZGF0YUJhdGNoLmxlbmd0aCA+IDApIHtcbiAgICAgICAgeWllbGQgZGF0YUJhdGNoO1xuICAgIH1cbn1cbmZ1bmN0aW9uKiBfc3luY0JhdGNoKHNpemUsIGl0ZXJhYmxlKSB7XG4gICAgbGV0IGRhdGFCYXRjaCA9IFtdO1xuICAgIGZvciAoY29uc3QgZGF0YSBvZiBpdGVyYWJsZSkge1xuICAgICAgICBkYXRhQmF0Y2gucHVzaChkYXRhKTtcbiAgICAgICAgaWYgKGRhdGFCYXRjaC5sZW5ndGggPT09IHNpemUpIHtcbiAgICAgICAgICAgIHlpZWxkIGRhdGFCYXRjaDtcbiAgICAgICAgICAgIGRhdGFCYXRjaCA9IFtdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChkYXRhQmF0Y2gubGVuZ3RoID4gMCkge1xuICAgICAgICB5aWVsZCBkYXRhQmF0Y2g7XG4gICAgfVxufVxuZnVuY3Rpb24gYmF0Y2goc2l6ZSwgaXRlcmFibGUpIHtcbiAgICBpZiAoaXRlcmFibGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gY3VycmllZEl0ZXJhYmxlID0+IGJhdGNoKHNpemUsIGN1cnJpZWRJdGVyYWJsZSk7XG4gICAgfVxuICAgIGlmIChpdGVyYWJsZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0pIHtcbiAgICAgICAgcmV0dXJuIF9iYXRjaChzaXplLCBpdGVyYWJsZSk7XG4gICAgfVxuICAgIHJldHVybiBfc3luY0JhdGNoKHNpemUsIGl0ZXJhYmxlKTtcbn1cblxuY29uc3QgVElNRU9VVCA9IFN5bWJvbCgnVElNRU9VVCcpO1xuY29uc3QgY3JlYXRlVGltZXIgPSAoZHVyYXRpb24pID0+IHtcbiAgICBsZXQgdGltZW91dElkO1xuICAgIHJldHVybiBbXG4gICAgICAgIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAgICAgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiByZXNvbHZlKFRJTUVPVVQpLCBkdXJhdGlvbik7XG4gICAgICAgIH0pLFxuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgfSxcbiAgICBdO1xufTtcbi8vIExpa2UgYGJhdGNoYCBidXQgZmx1c2hlcyBlYXJseSBpZiB0aGUgYHRpbWVvdXRgIGlzIHJlYWNoZWRcbi8vIE5PVEU6IFRoZSBzdHJhdGVneSBpcyB0byBvbmx5IGhvbGQgb250byBhIHNpbmdsZSBpdGVtIGZvciBhIG1heGltdW0gb2YgYHRpbWVvdXRgIG1zLlxuYXN5bmMgZnVuY3Rpb24qIF9iYXRjaFdpdGhUaW1lb3V0KHNpemUsIHRpbWVvdXQsIGl0ZXJhYmxlKSB7XG4gICAgY29uc3QgaXRlcmF0b3IgPSBpdGVyYWJsZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKTtcbiAgICBsZXQgcGVuZGluZ0RhdGE7XG4gICAgbGV0IGJhdGNoRGF0YSA9IFtdO1xuICAgIGxldCB0aW1lcjtcbiAgICBsZXQgY2xlYXJUaW1lcjtcbiAgICBjb25zdCBzdGFydFRpbWVyID0gKCkgPT4ge1xuICAgICAgICBkZWxldGVUaW1lcigpO1xuICAgICAgICBbdGltZXIsIGNsZWFyVGltZXJdID0gY3JlYXRlVGltZXIodGltZW91dCk7XG4gICAgfTtcbiAgICBjb25zdCBkZWxldGVUaW1lciA9ICgpID0+IHtcbiAgICAgICAgaWYgKGNsZWFyVGltZXIpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZXIoKTtcbiAgICAgICAgfVxuICAgICAgICB0aW1lciA9IHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIHBlbmRpbmdEYXRhID0gaXRlcmF0b3IubmV4dCgpO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0ICh0aW1lciA/IFByb21pc2UucmFjZShbcGVuZGluZ0RhdGEsIHRpbWVyXSkgOiBwZW5kaW5nRGF0YSk7XG4gICAgICAgIGlmIChyZXMgPT09IFRJTUVPVVQgfHwgcmVzLmRvbmUpIHtcbiAgICAgICAgICAgIC8vIEZsdXNoIGVhcmx5IChiZWZvcmUgd2UgcmVhY2ggdGhlIGJhdGNoIHNpemUpXG4gICAgICAgICAgICBpZiAoYmF0Y2hEYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHlpZWxkIGJhdGNoRGF0YTtcbiAgICAgICAgICAgICAgICBiYXRjaERhdGEgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlbGV0ZVRpbWVyKCk7XG4gICAgICAgICAgICAvLyBBbmQgZXhpdCBhcHByb3ByaWF0ZWx5XG4gICAgICAgICAgICBpZiAocmVzICE9PSBUSU1FT1VUKSB7XG4gICAgICAgICAgICAgICAgLy8gZG9uZVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmV0Y2ggbmV4dCBpdGVtIGVhcmx5IGRvb3JzIChiZWZvcmUgd2UgcG90ZW50aWFsbHkgeWllbGQpXG4gICAgICAgIHBlbmRpbmdEYXRhID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAvLyBUaGVuIGhhbmRsZSB0aGUgdmFsdWVcbiAgICAgICAgYmF0Y2hEYXRhLnB1c2gocmVzLnZhbHVlKTtcbiAgICAgICAgaWYgKGJhdGNoRGF0YS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIC8vIFN0YXJ0IHRpbWVyIG9uY2Ugd2UgaGF2ZSBhdCBsZWFzdCAxIGl0ZW0gcmVhZHkgdG8gZ29cbiAgICAgICAgICAgIHN0YXJ0VGltZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYmF0Y2hEYXRhLmxlbmd0aCA9PT0gc2l6ZSkge1xuICAgICAgICAgICAgeWllbGQgYmF0Y2hEYXRhO1xuICAgICAgICAgICAgYmF0Y2hEYXRhID0gW107XG4gICAgICAgICAgICBkZWxldGVUaW1lcigpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBiYXRjaFdpdGhUaW1lb3V0KHNpemUsIHRpbWVvdXQsIGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGN1cnJpZWRJdGVyYWJsZSA9PiBiYXRjaFdpdGhUaW1lb3V0KHNpemUsIHRpbWVvdXQsIGN1cnJpZWRJdGVyYWJsZSk7XG4gICAgfVxuICAgIGlmIChpdGVyYWJsZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gJiYgdGltZW91dCAhPT0gSW5maW5pdHkpIHtcbiAgICAgICAgcmV0dXJuIF9iYXRjaFdpdGhUaW1lb3V0KHNpemUsIHRpbWVvdXQsIGl0ZXJhYmxlKTtcbiAgICB9XG4gICAgLy8gRm9yIHN5bmMgaXRlcmFibGVzIG9yIGFuIGluZmluaXRlIHRpbWVvdXQsIHRoZSB0aW1lb3V0IGlzIGlycmVsZXZhbnQgc28ganVzdCBmYWxsYmFjayB0byByZWd1bGFyIGBiYXRjaGAuXG4gICAgcmV0dXJuIGJhdGNoKHNpemUsIGl0ZXJhYmxlKTtcbn1cblxuZnVuY3Rpb24gZ2V0SXRlcmF0b3IoaXRlcmFibGUpIHtcbiAgICBpZiAodHlwZW9mIGl0ZXJhYmxlLm5leHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhYmxlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGl0ZXJhYmxlW1N5bWJvbC5pdGVyYXRvcl0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhYmxlW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBpdGVyYWJsZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhYmxlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInZhbHVlc1wiIGRvZXMgbm90IHRvIGNvbmZvcm0gdG8gYW55IG9mIHRoZSBpdGVyYXRvciBvciBpdGVyYWJsZSBwcm90b2NvbHMnKTtcbn1cblxuZnVuY3Rpb24gZGVmZXIoKSB7XG4gICAgbGV0IHJlamVjdDtcbiAgICBsZXQgcmVzb2x2ZTtcbiAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmVGdW5jLCByZWplY3RGdW5jKSA9PiB7XG4gICAgICAgIHJlc29sdmUgPSByZXNvbHZlRnVuYztcbiAgICAgICAgcmVqZWN0ID0gcmVqZWN0RnVuYztcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBwcm9taXNlLFxuICAgICAgICByZWplY3QsXG4gICAgICAgIHJlc29sdmUsXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gX2J1ZmZlcihzaXplLCBpdGVyYWJsZSkge1xuICAgIGNvbnN0IGl0ZXJhdG9yID0gZ2V0SXRlcmF0b3IoaXRlcmFibGUpO1xuICAgIGNvbnN0IHJlc3VsdFF1ZXVlID0gW107XG4gICAgY29uc3QgcmVhZFF1ZXVlID0gW107XG4gICAgbGV0IHJlYWRpbmcgPSBmYWxzZTtcbiAgICBsZXQgZW5kZWQgPSBmYWxzZTtcbiAgICBmdW5jdGlvbiBmdWxmaWxsUmVhZFF1ZXVlKCkge1xuICAgICAgICB3aGlsZSAocmVhZFF1ZXVlLmxlbmd0aCA+IDAgJiYgcmVzdWx0UXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgcmVhZERlZmVycmVkID0gcmVhZFF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICBjb25zdCB7IGVycm9yLCB2YWx1ZSB9ID0gcmVzdWx0UXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJlYWREZWZlcnJlZC5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVhZERlZmVycmVkLnJlc29sdmUoeyBkb25lOiBmYWxzZSwgdmFsdWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHJlYWRRdWV1ZS5sZW5ndGggPiAwICYmIGVuZGVkKSB7XG4gICAgICAgICAgICBjb25zdCB7IHJlc29sdmUgfSA9IHJlYWRRdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgcmVzb2x2ZSh7IGRvbmU6IHRydWUsIHZhbHVlOiB1bmRlZmluZWQgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZnVuY3Rpb24gZmlsbFF1ZXVlKCkge1xuICAgICAgICBpZiAoZW5kZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVhZGluZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHRRdWV1ZS5sZW5ndGggPj0gc2l6ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJlYWRpbmcgPSB0cnVlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICBlbmRlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHRRdWV1ZS5wdXNoKHsgdmFsdWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBlbmRlZCA9IHRydWU7XG4gICAgICAgICAgICByZXN1bHRRdWV1ZS5wdXNoKHsgZXJyb3IgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVsZmlsbFJlYWRRdWV1ZSgpO1xuICAgICAgICByZWFkaW5nID0gZmFsc2U7XG4gICAgICAgIGZpbGxRdWV1ZSgpO1xuICAgIH1cbiAgICBhc3luYyBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICBpZiAocmVzdWx0UXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgeyBlcnJvciwgdmFsdWUgfSA9IHJlc3VsdFF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbGxRdWV1ZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZGVkKSB7XG4gICAgICAgICAgICByZXR1cm4geyBkb25lOiB0cnVlLCB2YWx1ZTogdW5kZWZpbmVkIH07IC8vIHN0dXBpZCB0c1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICAgICAgcmVhZFF1ZXVlLnB1c2goZGVmZXJyZWQpO1xuICAgICAgICBmaWxsUXVldWUoKTtcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgfVxuICAgIGNvbnN0IGFzeW5jSXRlcmFibGVJdGVyYXRvciA9IHtcbiAgICAgICAgbmV4dCxcbiAgICAgICAgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXTogKCkgPT4gYXN5bmNJdGVyYWJsZUl0ZXJhdG9yLFxuICAgIH07XG4gICAgcmV0dXJuIGFzeW5jSXRlcmFibGVJdGVyYXRvcjtcbn1cbmZ1bmN0aW9uKiBzeW5jQnVmZmVyKHNpemUsIGl0ZXJhYmxlKSB7XG4gICAgY29uc3QgdmFsdWVRdWV1ZSA9IFtdO1xuICAgIGxldCBlO1xuICAgIHRyeSB7XG4gICAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgaXRlcmFibGUpIHtcbiAgICAgICAgICAgIHZhbHVlUXVldWUucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAodmFsdWVRdWV1ZS5sZW5ndGggPD0gc2l6ZSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeWllbGQgdmFsdWVRdWV1ZS5zaGlmdCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBlID0gZXJyb3I7XG4gICAgfVxuICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdmFsdWVRdWV1ZSkge1xuICAgICAgICB5aWVsZCB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKGUpIHtcbiAgICAgICAgdGhyb3cgZTtcbiAgICB9XG59XG5mdW5jdGlvbiBidWZmZXIoc2l6ZSwgaXRlcmFibGUpIHtcbiAgICBpZiAoaXRlcmFibGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gY3VycmllZEl0ZXJhYmxlID0+IGJ1ZmZlcihzaXplLCBjdXJyaWVkSXRlcmFibGUpO1xuICAgIH1cbiAgICBpZiAoc2l6ZSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gaXRlcmFibGU7XG4gICAgfVxuICAgIGlmIChpdGVyYWJsZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0pIHtcbiAgICAgICAgcmV0dXJuIF9idWZmZXIoc2l6ZSwgaXRlcmFibGUpO1xuICAgIH1cbiAgICByZXR1cm4gc3luY0J1ZmZlcihzaXplLCBpdGVyYWJsZSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIF9jb2xsZWN0KGl0ZXJhYmxlKSB7XG4gICAgY29uc3QgdmFsdWVzID0gW107XG4gICAgZm9yIGF3YWl0IChjb25zdCB2YWx1ZSBvZiBpdGVyYWJsZSkge1xuICAgICAgICB2YWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZXM7XG59XG5mdW5jdGlvbiBjb2xsZWN0KGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSkge1xuICAgICAgICByZXR1cm4gX2NvbGxlY3QoaXRlcmFibGUpO1xuICAgIH1cbiAgICByZXR1cm4gQXJyYXkuZnJvbShpdGVyYWJsZSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uKiBfY29uY2F0KGl0ZXJhYmxlcykge1xuICAgIGZvciBhd2FpdCAoY29uc3QgaXRlcmFibGUgb2YgaXRlcmFibGVzKSB7XG4gICAgICAgIHlpZWxkKiBpdGVyYWJsZTtcbiAgICB9XG59XG5mdW5jdGlvbiogX3N5bmNDb25jYXQoaXRlcmFibGVzKSB7XG4gICAgZm9yIChjb25zdCBpdGVyYWJsZSBvZiBpdGVyYWJsZXMpIHtcbiAgICAgICAgeWllbGQqIGl0ZXJhYmxlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbmNhdCguLi5pdGVyYWJsZXMpIHtcbiAgICBjb25zdCBoYXNBbnlBc3luYyA9IGl0ZXJhYmxlcy5maW5kKGl0ciA9PiBpdHJbU3ltYm9sLmFzeW5jSXRlcmF0b3JdICE9PSB1bmRlZmluZWQpO1xuICAgIGlmIChoYXNBbnlBc3luYykge1xuICAgICAgICByZXR1cm4gX2NvbmNhdChpdGVyYWJsZXMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIF9zeW5jQ29uY2F0KGl0ZXJhYmxlcyk7XG4gICAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBfY29uc3VtZShpdGVyYWJsZSkge1xuICAgIGZvciBhd2FpdCAoY29uc3QgdmFsIG9mIGl0ZXJhYmxlKSB7XG4gICAgICAgIC8vIGRvIG5vdGhpbmdcbiAgICB9XG59XG5mdW5jdGlvbiBjb25zdW1lKGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSkge1xuICAgICAgICByZXR1cm4gX2NvbnN1bWUoaXRlcmFibGUpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHZhbCBvZiBpdGVyYWJsZSkge1xuICAgICAgICAvLyBkbyBub3RoaW5nXG4gICAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiogX2ZpbHRlcihmaWx0ZXJGdW5jLCBpdGVyYWJsZSkge1xuICAgIGZvciBhd2FpdCAoY29uc3QgZGF0YSBvZiBpdGVyYWJsZSkge1xuICAgICAgICBpZiAoYXdhaXQgZmlsdGVyRnVuYyhkYXRhKSkge1xuICAgICAgICAgICAgeWllbGQgZGF0YTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGZpbHRlcihmaWx0ZXJGdW5jLCBpdGVyYWJsZSkge1xuICAgIGlmIChpdGVyYWJsZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAoY3VycmllZEl0ZXJhYmxlKSA9PiBfZmlsdGVyKGZpbHRlckZ1bmMsIGN1cnJpZWRJdGVyYWJsZSk7XG4gICAgfVxuICAgIHJldHVybiBfZmlsdGVyKGZpbHRlckZ1bmMsIGl0ZXJhYmxlKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24qIGZsYXR0ZW4oaXRlcmFibGUpIHtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IG1heWJlSXRyIG9mIGl0ZXJhYmxlKSB7XG4gICAgICAgIGlmIChtYXliZUl0ciAmJiB0eXBlb2YgbWF5YmVJdHIgIT09ICdzdHJpbmcnICYmIChtYXliZUl0cltTeW1ib2wuaXRlcmF0b3JdIHx8IG1heWJlSXRyW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSkpIHtcbiAgICAgICAgICAgIHlpZWxkKiBmbGF0dGVuKG1heWJlSXRyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHlpZWxkIG1heWJlSXRyO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiogX21hcChmdW5jLCBpdGVyYWJsZSkge1xuICAgIGZvciBhd2FpdCAoY29uc3QgdmFsIG9mIGl0ZXJhYmxlKSB7XG4gICAgICAgIHlpZWxkIGF3YWl0IGZ1bmModmFsKTtcbiAgICB9XG59XG5mdW5jdGlvbiBtYXAoZnVuYywgaXRlcmFibGUpIHtcbiAgICBpZiAoaXRlcmFibGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gY3VycmllZEl0ZXJhYmxlID0+IF9tYXAoZnVuYywgY3VycmllZEl0ZXJhYmxlKTtcbiAgICB9XG4gICAgcmV0dXJuIF9tYXAoZnVuYywgaXRlcmFibGUpO1xufVxuXG5mdW5jdGlvbiBmbGF0TWFwKGZ1bmMsIGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGN1cnJpZWRJdGVyYWJsZSA9PiBmbGF0TWFwKGZ1bmMsIGN1cnJpZWRJdGVyYWJsZSk7XG4gICAgfVxuICAgIHJldHVybiBmaWx0ZXIoaSA9PiBpICE9PSB1bmRlZmluZWQgJiYgaSAhPT0gbnVsbCwgZmxhdHRlbihtYXAoZnVuYywgaXRlcmFibGUpKSk7XG59XG5cbmZ1bmN0aW9uIF9mbGF0VHJhbnNmb3JtKGNvbmN1cnJlbmN5LCBmdW5jLCBpdGVyYWJsZSkge1xuICAgIGNvbnN0IGl0ZXJhdG9yID0gZ2V0SXRlcmF0b3IoaXRlcmFibGUpO1xuICAgIGNvbnN0IHJlc3VsdFF1ZXVlID0gW107XG4gICAgY29uc3QgcmVhZFF1ZXVlID0gW107XG4gICAgbGV0IGVuZGVkID0gZmFsc2U7XG4gICAgbGV0IHJlYWRpbmcgPSBmYWxzZTtcbiAgICBsZXQgaW5mbGlnaHRDb3VudCA9IDA7XG4gICAgbGV0IGxhc3RFcnJvciA9IG51bGw7XG4gICAgZnVuY3Rpb24gZnVsZmlsbFJlYWRRdWV1ZSgpIHtcbiAgICAgICAgd2hpbGUgKHJlYWRRdWV1ZS5sZW5ndGggPiAwICYmIHJlc3VsdFF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcmVzb2x2ZSB9ID0gcmVhZFF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHJlc3VsdFF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICByZXNvbHZlKHsgZG9uZTogZmFsc2UsIHZhbHVlIH0pO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChyZWFkUXVldWUubGVuZ3RoID4gMCAmJiBpbmZsaWdodENvdW50ID09PSAwICYmIGVuZGVkKSB7XG4gICAgICAgICAgICBjb25zdCB7IHJlc29sdmUsIHJlamVjdCB9ID0gcmVhZFF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICBpZiAobGFzdEVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGxhc3RFcnJvcik7XG4gICAgICAgICAgICAgICAgbGFzdEVycm9yID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoeyBkb25lOiB0cnVlLCB2YWx1ZTogdW5kZWZpbmVkIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGZ1bmN0aW9uIGZpbGxRdWV1ZSgpIHtcbiAgICAgICAgaWYgKGVuZGVkKSB7XG4gICAgICAgICAgICBmdWxmaWxsUmVhZFF1ZXVlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlYWRpbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5mbGlnaHRDb3VudCArIHJlc3VsdFF1ZXVlLmxlbmd0aCA+PSBjb25jdXJyZW5jeSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJlYWRpbmcgPSB0cnVlO1xuICAgICAgICBpbmZsaWdodENvdW50Kys7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgIGVuZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpbmZsaWdodENvdW50LS07XG4gICAgICAgICAgICAgICAgZnVsZmlsbFJlYWRRdWV1ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbWFwQW5kUXVldWUodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgZW5kZWQgPSB0cnVlO1xuICAgICAgICAgICAgaW5mbGlnaHRDb3VudC0tO1xuICAgICAgICAgICAgbGFzdEVycm9yID0gZXJyb3I7XG4gICAgICAgICAgICBmdWxmaWxsUmVhZFF1ZXVlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVhZGluZyA9IGZhbHNlO1xuICAgICAgICBmaWxsUXVldWUoKTtcbiAgICB9XG4gICAgYXN5bmMgZnVuY3Rpb24gbWFwQW5kUXVldWUoaXRyVmFsdWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgZnVuYyhpdHJWYWx1ZSk7XG4gICAgICAgICAgICBpZiAodmFsdWUgJiYgdmFsdWVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKSB7XG4gICAgICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBhc3luY1ZhbCBvZiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRRdWV1ZS5wdXNoKGFzeW5jVmFsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHRRdWV1ZS5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGVuZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGxhc3RFcnJvciA9IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGluZmxpZ2h0Q291bnQtLTtcbiAgICAgICAgZnVsZmlsbFJlYWRRdWV1ZSgpO1xuICAgICAgICBmaWxsUXVldWUoKTtcbiAgICB9XG4gICAgYXN5bmMgZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgaWYgKHJlc3VsdFF1ZXVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgY29uc3QgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgICAgICAgICAgcmVhZFF1ZXVlLnB1c2goZGVmZXJyZWQpO1xuICAgICAgICAgICAgZmlsbFF1ZXVlKCk7XG4gICAgICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWx1ZSA9IHJlc3VsdFF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgIGZpbGxRdWV1ZSgpO1xuICAgICAgICByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWUgfTtcbiAgICB9XG4gICAgY29uc3QgYXN5bmNJdGVyYWJsZUl0ZXJhdG9yID0ge1xuICAgICAgICBuZXh0LFxuICAgICAgICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdOiAoKSA9PiBhc3luY0l0ZXJhYmxlSXRlcmF0b3IsXG4gICAgfTtcbiAgICByZXR1cm4gYXN5bmNJdGVyYWJsZUl0ZXJhdG9yO1xufVxuZnVuY3Rpb24gZmxhdFRyYW5zZm9ybShjb25jdXJyZW5jeSwgZnVuYywgaXRlcmFibGUpIHtcbiAgICBpZiAoZnVuYyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAoY3VycmllZEZ1bmMsIGN1cnJpZWRJdGVyYWJsZSkgPT4gY3VycmllZEl0ZXJhYmxlXG4gICAgICAgICAgICA/IGZsYXRUcmFuc2Zvcm0oY29uY3VycmVuY3ksIGN1cnJpZWRGdW5jLCBjdXJyaWVkSXRlcmFibGUpXG4gICAgICAgICAgICA6IGZsYXRUcmFuc2Zvcm0oY29uY3VycmVuY3ksIGN1cnJpZWRGdW5jKTtcbiAgICB9XG4gICAgaWYgKGl0ZXJhYmxlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIChjdXJyaWVkSXRlcmFibGUpID0+IGZsYXRUcmFuc2Zvcm0oY29uY3VycmVuY3ksIGZ1bmMsIGN1cnJpZWRJdGVyYWJsZSk7XG4gICAgfVxuICAgIHJldHVybiBmaWx0ZXIoaSA9PiBpICE9PSB1bmRlZmluZWQgJiYgaSAhPT0gbnVsbCwgZmxhdHRlbihfZmxhdFRyYW5zZm9ybShjb25jdXJyZW5jeSwgZnVuYywgaXRlcmFibGUpKSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIG9uY2VSZWFkYWJsZShzdHJlYW0pIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgIHN0cmVhbS5vbmNlKCdyZWFkYWJsZScsICgpID0+IHtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5hc3luYyBmdW5jdGlvbiogX2Zyb21TdHJlYW0oc3RyZWFtKSB7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IHN0cmVhbS5yZWFkKCk7XG4gICAgICAgIGlmIChkYXRhICE9PSBudWxsKSB7XG4gICAgICAgICAgICB5aWVsZCBkYXRhO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0cmVhbS5fcmVhZGFibGVTdGF0ZS5lbmRlZCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgb25jZVJlYWRhYmxlKHN0cmVhbSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZnJvbVN0cmVhbShzdHJlYW0pIHtcbiAgICBpZiAodHlwZW9mIHN0cmVhbVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHN0cmVhbTtcbiAgICB9XG4gICAgcmV0dXJuIF9mcm9tU3RyZWFtKHN0cmVhbSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uKiBtZXJnZSguLi5pdGVyYWJsZXMpIHtcbiAgICBjb25zdCBzb3VyY2VzID0gbmV3IFNldChpdGVyYWJsZXMubWFwKGdldEl0ZXJhdG9yKSk7XG4gICAgd2hpbGUgKHNvdXJjZXMuc2l6ZSA+IDApIHtcbiAgICAgICAgZm9yIChjb25zdCBpdGVyYXRvciBvZiBzb3VyY2VzKSB7XG4gICAgICAgICAgICBjb25zdCBuZXh0VmFsID0gYXdhaXQgaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgICAgaWYgKG5leHRWYWwuZG9uZSkge1xuICAgICAgICAgICAgICAgIHNvdXJjZXMuZGVsZXRlKGl0ZXJhdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHlpZWxkIG5leHRWYWwudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIHBpcGVsaW5lKGZpcnN0Rm4sIC4uLmZucykge1xuICAgIGxldCBwcmV2aW91c0ZuID0gZmlyc3RGbigpO1xuICAgIGZvciAoY29uc3QgZnVuYyBvZiBmbnMpIHtcbiAgICAgICAgcHJldmlvdXNGbiA9IGZ1bmMocHJldmlvdXNGbik7XG4gICAgfVxuICAgIHJldHVybiBwcmV2aW91c0ZuO1xufVxuXG5hc3luYyBmdW5jdGlvbiogX3BhcmFsbGVsTWFwKGNvbmN1cnJlbmN5LCBmdW5jLCBpdGVyYWJsZSkge1xuICAgIGxldCB0cmFuc2Zvcm1FcnJvciA9IG51bGw7XG4gICAgY29uc3Qgd3JhcEZ1bmMgPSB2YWx1ZSA9PiAoe1xuICAgICAgICB2YWx1ZTogZnVuYyh2YWx1ZSksXG4gICAgfSk7XG4gICAgY29uc3Qgc3RvcE9uRXJyb3IgPSBhc3luYyBmdW5jdGlvbiogKHNvdXJjZSkge1xuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IHZhbHVlIG9mIHNvdXJjZSkge1xuICAgICAgICAgICAgaWYgKHRyYW5zZm9ybUVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeWllbGQgdmFsdWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IG91dHB1dCA9IHBpcGVsaW5lKCgpID0+IGl0ZXJhYmxlLCBidWZmZXIoMSksIHN0b3BPbkVycm9yLCBtYXAod3JhcEZ1bmMpLCBidWZmZXIoY29uY3VycmVuY3kgLSAxKSk7XG4gICAgY29uc3QgaXRyID0gZ2V0SXRlcmF0b3Iob3V0cHV0KTtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBjb25zdCB7IHZhbHVlLCBkb25lIH0gPSBhd2FpdCBpdHIubmV4dCgpO1xuICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHZhbCA9IGF3YWl0IHZhbHVlLnZhbHVlO1xuICAgICAgICAgICAgaWYgKCF0cmFuc2Zvcm1FcnJvcikge1xuICAgICAgICAgICAgICAgIHlpZWxkIHZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybUVycm9yID0gZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRyYW5zZm9ybUVycm9yKSB7XG4gICAgICAgIHRocm93IHRyYW5zZm9ybUVycm9yO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHBhcmFsbGVsTWFwKGNvbmN1cnJlbmN5LCBmdW5jLCBpdGVyYWJsZSkge1xuICAgIGlmIChmdW5jID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIChjdXJyaWVkRnVuYywgY3VycmllZEl0ZXJhYmxlKSA9PiBwYXJhbGxlbE1hcChjb25jdXJyZW5jeSwgY3VycmllZEZ1bmMsIGN1cnJpZWRJdGVyYWJsZSk7XG4gICAgfVxuICAgIGlmIChpdGVyYWJsZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBjdXJyaWVkSXRlcmFibGUgPT4gcGFyYWxsZWxNYXAoY29uY3VycmVuY3ksIGZ1bmMsIGN1cnJpZWRJdGVyYWJsZSk7XG4gICAgfVxuICAgIGlmIChjb25jdXJyZW5jeSA9PT0gMSkge1xuICAgICAgICByZXR1cm4gbWFwKGZ1bmMsIGl0ZXJhYmxlKTtcbiAgICB9XG4gICAgcmV0dXJuIF9wYXJhbGxlbE1hcChjb25jdXJyZW5jeSwgZnVuYywgaXRlcmFibGUpO1xufVxuXG5mdW5jdGlvbiBwYXJhbGxlbEZsYXRNYXAoY29uY3VycmVuY3ksIGZ1bmMsIGl0ZXJhYmxlKSB7XG4gICAgaWYgKGZ1bmMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gKGN1cnJpZWRGdW5jLCBjdXJyaWVkSXRlcmFibGUpID0+IGN1cnJpZWRJdGVyYWJsZVxuICAgICAgICAgICAgPyBwYXJhbGxlbEZsYXRNYXAoY29uY3VycmVuY3ksIGN1cnJpZWRGdW5jLCBjdXJyaWVkSXRlcmFibGUpXG4gICAgICAgICAgICA6IHBhcmFsbGVsRmxhdE1hcChjb25jdXJyZW5jeSwgY3VycmllZEZ1bmMpO1xuICAgIH1cbiAgICBpZiAoaXRlcmFibGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gKGN1cnJpZWRJdGVyYWJsZSkgPT4gcGFyYWxsZWxGbGF0TWFwKGNvbmN1cnJlbmN5LCBmdW5jLCBjdXJyaWVkSXRlcmFibGUpO1xuICAgIH1cbiAgICByZXR1cm4gZmlsdGVyKGkgPT4gaSAhPT0gdW5kZWZpbmVkICYmIGkgIT09IG51bGwsIGZsYXR0ZW4ocGFyYWxsZWxNYXAoY29uY3VycmVuY3ksIGZ1bmMsIGl0ZXJhYmxlKSkpO1xufVxuXG5hc3luYyBmdW5jdGlvbiogcGFyYWxsZWxNZXJnZSguLi5pdGVyYWJsZXMpIHtcbiAgICBjb25zdCBpbnB1dHMgPSBpdGVyYWJsZXMubWFwKGdldEl0ZXJhdG9yKTtcbiAgICBjb25zdCBjb25jdXJyZW50V29yayA9IG5ldyBTZXQoKTtcbiAgICBjb25zdCB2YWx1ZXMgPSBuZXcgTWFwKCk7XG4gICAgbGV0IGxhc3RFcnJvciA9IG51bGw7XG4gICAgbGV0IGVyckNiID0gbnVsbDtcbiAgICBsZXQgdmFsdWVDYiA9IG51bGw7XG4gICAgY29uc3Qgbm90aWZ5RXJyb3IgPSBlcnIgPT4ge1xuICAgICAgICBsYXN0RXJyb3IgPSBlcnI7XG4gICAgICAgIGlmIChlcnJDYikge1xuICAgICAgICAgICAgZXJyQ2IoZXJyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgbm90aWZ5RG9uZSA9IHZhbHVlID0+IHtcbiAgICAgICAgaWYgKHZhbHVlQ2IpIHtcbiAgICAgICAgICAgIHZhbHVlQ2IodmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCB3YWl0Rm9yUXVldWUgPSAoKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGlmIChsYXN0RXJyb3IpIHtcbiAgICAgICAgICAgIHJlamVjdChsYXN0RXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZXMuc2l6ZSA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWVDYiA9IHJlc29sdmU7XG4gICAgICAgIGVyckNiID0gcmVqZWN0O1xuICAgIH0pO1xuICAgIGNvbnN0IHF1ZXVlTmV4dCA9IGlucHV0ID0+IHtcbiAgICAgICAgY29uc3QgbmV4dFZhbCA9IFByb21pc2UucmVzb2x2ZShpbnB1dC5uZXh0KCkpLnRoZW4oYXN5bmMgKHsgZG9uZSwgdmFsdWUgfSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFkb25lKSB7XG4gICAgICAgICAgICAgICAgdmFsdWVzLnNldChpbnB1dCwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uY3VycmVudFdvcmsuZGVsZXRlKG5leHRWYWwpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uY3VycmVudFdvcmsuYWRkKG5leHRWYWwpO1xuICAgICAgICBuZXh0VmFsLnRoZW4obm90aWZ5RG9uZSwgbm90aWZ5RXJyb3IpO1xuICAgIH07XG4gICAgZm9yIChjb25zdCBpbnB1dCBvZiBpbnB1dHMpIHtcbiAgICAgICAgcXVldWVOZXh0KGlucHV0KTtcbiAgICB9XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgLy8gV2UgdGVjaG5pY2FsbHkgZG9uJ3QgaGF2ZSB0byBjaGVjayBgdmFsdWVzLnNpemVgIGFzIHRoZSBmb3IgbG9vcCBzaG91bGQgaGF2ZSBlbXB0aWVkIGl0XG4gICAgICAgIC8vIEhvd2V2ZXIgSSBoYXZlbid0IHlldCBmb3VuZCBzcGVjcyB2ZXJpZnlpbmcgdGhhdCBiZWhhdmlvciwgb25seSB0ZXN0c1xuICAgICAgICAvLyB0aGUgZ3VhcmQgaW4gd2FpdEZvclF1ZXVlKCkgY2hlY2tpbmcgZm9yIHZhbHVlcyBpcyBpbiBwbGFjZSBmb3IgdGhlIHNhbWUgcmVhc29uXG4gICAgICAgIGlmIChjb25jdXJyZW50V29yay5zaXplID09PSAwICYmIHZhbHVlcy5zaXplID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgd2FpdEZvclF1ZXVlKCk7XG4gICAgICAgIGZvciAoY29uc3QgW2lucHV0LCB2YWx1ZV0gb2YgdmFsdWVzKSB7XG4gICAgICAgICAgICB2YWx1ZXMuZGVsZXRlKGlucHV0KTtcbiAgICAgICAgICAgIHlpZWxkIHZhbHVlO1xuICAgICAgICAgICAgcXVldWVOZXh0KGlucHV0KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gX3JlZHVjZShmdW5jLCBzdGFydCwgaXRlcmFibGUpIHtcbiAgICBsZXQgdmFsdWUgPSBzdGFydDtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IG5leHRJdGVtIG9mIGl0ZXJhYmxlKSB7XG4gICAgICAgIHZhbHVlID0gYXdhaXQgZnVuYyh2YWx1ZSwgbmV4dEl0ZW0pO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiByZWR1Y2UoZnVuYywgc3RhcnQsIGl0ZXJhYmxlKSB7XG4gICAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIChjdXJyaWVkU3RhcnQsIGN1cnJpZWRJdGVyYWJsZSkgPT4gY3VycmllZEl0ZXJhYmxlID8gX3JlZHVjZShmdW5jLCBjdXJyaWVkU3RhcnQsIGN1cnJpZWRJdGVyYWJsZSkgOiByZWR1Y2UoZnVuYywgY3VycmllZFN0YXJ0KTtcbiAgICB9XG4gICAgaWYgKGl0ZXJhYmxlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIChjdXJyaWVkSXRlcmFibGUpID0+IHJlZHVjZShmdW5jLCBzdGFydCwgY3VycmllZEl0ZXJhYmxlKTtcbiAgICB9XG4gICAgcmV0dXJuIF9yZWR1Y2UoZnVuYywgc3RhcnQsIGl0ZXJhYmxlKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24qIF90YWtlKGNvdW50LCBpdGVyYWJsZSkge1xuICAgIGxldCB0YWtlbiA9IDA7XG4gICAgZm9yIGF3YWl0IChjb25zdCB2YWwgb2YgaXRlcmFibGUpIHtcbiAgICAgICAgeWllbGQgYXdhaXQgdmFsO1xuICAgICAgICB0YWtlbisrO1xuICAgICAgICBpZiAodGFrZW4gPj0gY291bnQpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24qIF9zeW5jVGFrZShjb3VudCwgaXRlcmFibGUpIHtcbiAgICBsZXQgdGFrZW4gPSAwO1xuICAgIGZvciAoY29uc3QgdmFsIG9mIGl0ZXJhYmxlKSB7XG4gICAgICAgIHlpZWxkIHZhbDtcbiAgICAgICAgdGFrZW4rKztcbiAgICAgICAgaWYgKHRha2VuID49IGNvdW50KSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHRha2UoY291bnQsIGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGN1cnJpZWRJdGVyYWJsZSA9PiB0YWtlKGNvdW50LCBjdXJyaWVkSXRlcmFibGUpO1xuICAgIH1cbiAgICBpZiAoaXRlcmFibGVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKSB7XG4gICAgICAgIHJldHVybiBfdGFrZShjb3VudCwgaXRlcmFibGUpO1xuICAgIH1cbiAgICByZXR1cm4gX3N5bmNUYWtlKGNvdW50LCBpdGVyYWJsZSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uKiBfYXN5bmNUYXAoZnVuYywgaXRlcmFibGUpIHtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IHZhbCBvZiBpdGVyYWJsZSkge1xuICAgICAgICBhd2FpdCBmdW5jKHZhbCk7XG4gICAgICAgIHlpZWxkIHZhbDtcbiAgICB9XG59XG5mdW5jdGlvbiB0YXAoZnVuYywgaXRlcmFibGUpIHtcbiAgICBpZiAoaXRlcmFibGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gKGN1cnJpZWRJdGVyYWJsZSkgPT4gX2FzeW5jVGFwKGZ1bmMsIGN1cnJpZWRJdGVyYWJsZSk7XG4gICAgfVxuICAgIHJldHVybiBfYXN5bmNUYXAoZnVuYywgaXRlcmFibGUpO1xufVxuXG5jb25zdCBzbGVlcCA9IChtcykgPT4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIG1zKSk7XG5mdW5jdGlvbiBfdGhyb3R0bGUobGltaXQsIGludGVydmFsLCBpdGVyYWJsZSkge1xuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKGxpbWl0KSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBgbGltaXRgIHRvIGJlIGEgZmluaXRlIG51bWJlcicpO1xuICAgIH1cbiAgICBpZiAobGltaXQgPD0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBgbGltaXRgIHRvIGJlIGdyZWF0ZXIgdGhhbiAwJyk7XG4gICAgfVxuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKGludGVydmFsKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBgaW50ZXJ2YWxgIHRvIGJlIGEgZmluaXRlIG51bWJlcicpO1xuICAgIH1cbiAgICByZXR1cm4gKGFzeW5jIGZ1bmN0aW9uKiBfX3Rocm90dGxlKCkge1xuICAgICAgICBsZXQgc2VudCA9IDA7XG4gICAgICAgIGxldCB0aW1lO1xuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IHZhbCBvZiBpdGVyYWJsZSkge1xuICAgICAgICAgICAgaWYgKHNlbnQgPCBsaW1pdCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGltZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGltZSA9IERhdGUubm93KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNlbnQrKztcbiAgICAgICAgICAgICAgICB5aWVsZCB2YWw7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBPbmx5IHdhaXQgaWYgdGhlIGludGVydmFsIGhhc24ndCBhbHJlYWR5IHBhc3NlZCB3aGlsZSB3ZSB3ZXJlXG4gICAgICAgICAgICAvLyB5aWVsZGluZyB0aGUgcHJldmlvdXMgdmFsdWVzLlxuICAgICAgICAgICAgY29uc3QgZWxhcHNlZE1zID0gRGF0ZS5ub3coKSAtIHRpbWU7XG4gICAgICAgICAgICBjb25zdCB3YWl0Rm9yID0gaW50ZXJ2YWwgLSBlbGFwc2VkTXM7XG4gICAgICAgICAgICBpZiAod2FpdEZvciA+IDApIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBzbGVlcCh3YWl0Rm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgc2VudCA9IDE7XG4gICAgICAgICAgICB5aWVsZCB2YWw7XG4gICAgICAgIH1cbiAgICB9KSgpO1xufVxuZnVuY3Rpb24gdGhyb3R0bGUobGltaXQsIGludGVydmFsLCBpdGVyYWJsZSkge1xuICAgIGlmIChpdGVyYWJsZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAoY3VycmllZEl0ZXJhYmxlKSA9PiBfdGhyb3R0bGUobGltaXQsIGludGVydmFsLCBjdXJyaWVkSXRlcmFibGUpO1xuICAgIH1cbiAgICByZXR1cm4gX3Rocm90dGxlKGxpbWl0LCBpbnRlcnZhbCwgaXRlcmFibGUpO1xufVxuXG5mdW5jdGlvbiBhZGRUaW1lKGEsIGIpIHtcbiAgICBsZXQgc2Vjb25kcyA9IGFbMF0gKyBiWzBdO1xuICAgIGxldCBuYW5vc2Vjb25kcyA9IGFbMV0gKyBiWzFdO1xuICAgIGlmIChuYW5vc2Vjb25kcyA+PSAxMDAwMDAwMDAwKSB7XG4gICAgICAgIGNvbnN0IHJlbWFpbmRlciA9IG5hbm9zZWNvbmRzICUgMTAwMDAwMDAwMDtcbiAgICAgICAgc2Vjb25kcyArPSAobmFub3NlY29uZHMgLSByZW1haW5kZXIpIC8gMTAwMDAwMDAwMDtcbiAgICAgICAgbmFub3NlY29uZHMgPSByZW1haW5kZXI7XG4gICAgfVxuICAgIHJldHVybiBbc2Vjb25kcywgbmFub3NlY29uZHNdO1xufVxuYXN5bmMgZnVuY3Rpb24qIF9hc3luY1RpbWUoY29uZmlnLCBpdGVyYWJsZSkge1xuICAgIGNvbnN0IGl0ciA9IGl0ZXJhYmxlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpO1xuICAgIGxldCB0b3RhbCA9IFswLCAwXTtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBjb25zdCBzdGFydCA9IHByb2Nlc3MuaHJ0aW1lKCk7XG4gICAgICAgIGNvbnN0IHsgdmFsdWUsIGRvbmUgfSA9IGF3YWl0IGl0ci5uZXh0KCk7XG4gICAgICAgIGNvbnN0IGRlbHRhID0gcHJvY2Vzcy5ocnRpbWUoc3RhcnQpO1xuICAgICAgICB0b3RhbCA9IGFkZFRpbWUodG90YWwsIGRlbHRhKTtcbiAgICAgICAgaWYgKGNvbmZpZy5wcm9ncmVzcykge1xuICAgICAgICAgICAgY29uZmlnLnByb2dyZXNzKGRlbHRhLCB0b3RhbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgIGlmIChjb25maWcudG90YWwpIHtcbiAgICAgICAgICAgICAgICBjb25maWcudG90YWwodG90YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHlpZWxkIHZhbHVlO1xuICAgIH1cbn1cbmZ1bmN0aW9uKiBfc3luY1RpbWUoY29uZmlnLCBpdGVyYWJsZSkge1xuICAgIGNvbnN0IGl0ciA9IGl0ZXJhYmxlW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICBsZXQgdG90YWwgPSBbMCwgMF07XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBwcm9jZXNzLmhydGltZSgpO1xuICAgICAgICBjb25zdCB7IHZhbHVlLCBkb25lIH0gPSBpdHIubmV4dCgpO1xuICAgICAgICBjb25zdCBkZWx0YSA9IHByb2Nlc3MuaHJ0aW1lKHN0YXJ0KTtcbiAgICAgICAgdG90YWwgPSBhZGRUaW1lKHRvdGFsLCBkZWx0YSk7XG4gICAgICAgIGlmIChjb25maWcucHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgIGNvbmZpZy5wcm9ncmVzcyhkZWx0YSwgdG90YWwpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICBpZiAoY29uZmlnLnRvdGFsKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLnRvdGFsKHRvdGFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB5aWVsZCB2YWx1ZTtcbiAgICB9XG59XG5mdW5jdGlvbiB0aW1lKGNvbmZpZyA9IHt9LCBpdGVyYWJsZSkge1xuICAgIGlmIChpdGVyYWJsZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBjdXJyaWVkSXRlcmFibGUgPT4gdGltZShjb25maWcsIGN1cnJpZWRJdGVyYWJsZSk7XG4gICAgfVxuICAgIGlmIChpdGVyYWJsZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gX2FzeW5jVGltZShjb25maWcsIGl0ZXJhYmxlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBfc3luY1RpbWUoY29uZmlnLCBpdGVyYWJsZSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBfdHJhbnNmb3JtKGNvbmN1cnJlbmN5LCBmdW5jLCBpdGVyYWJsZSkge1xuICAgIGNvbnN0IGl0ZXJhdG9yID0gZ2V0SXRlcmF0b3IoaXRlcmFibGUpO1xuICAgIGNvbnN0IHJlc3VsdFF1ZXVlID0gW107XG4gICAgY29uc3QgcmVhZFF1ZXVlID0gW107XG4gICAgbGV0IGVuZGVkID0gZmFsc2U7XG4gICAgbGV0IHJlYWRpbmcgPSBmYWxzZTtcbiAgICBsZXQgaW5mbGlnaHRDb3VudCA9IDA7XG4gICAgbGV0IGxhc3RFcnJvciA9IG51bGw7XG4gICAgZnVuY3Rpb24gZnVsZmlsbFJlYWRRdWV1ZSgpIHtcbiAgICAgICAgd2hpbGUgKHJlYWRRdWV1ZS5sZW5ndGggPiAwICYmIHJlc3VsdFF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcmVzb2x2ZSB9ID0gcmVhZFF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHJlc3VsdFF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICByZXNvbHZlKHsgZG9uZTogZmFsc2UsIHZhbHVlIH0pO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChyZWFkUXVldWUubGVuZ3RoID4gMCAmJiBpbmZsaWdodENvdW50ID09PSAwICYmIGVuZGVkKSB7XG4gICAgICAgICAgICBjb25zdCB7IHJlc29sdmUsIHJlamVjdCB9ID0gcmVhZFF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICBpZiAobGFzdEVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGxhc3RFcnJvcik7XG4gICAgICAgICAgICAgICAgbGFzdEVycm9yID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoeyBkb25lOiB0cnVlLCB2YWx1ZTogdW5kZWZpbmVkIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGZ1bmN0aW9uIGZpbGxRdWV1ZSgpIHtcbiAgICAgICAgaWYgKGVuZGVkKSB7XG4gICAgICAgICAgICBmdWxmaWxsUmVhZFF1ZXVlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlYWRpbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5mbGlnaHRDb3VudCArIHJlc3VsdFF1ZXVlLmxlbmd0aCA+PSBjb25jdXJyZW5jeSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJlYWRpbmcgPSB0cnVlO1xuICAgICAgICBpbmZsaWdodENvdW50Kys7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgIGVuZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpbmZsaWdodENvdW50LS07XG4gICAgICAgICAgICAgICAgZnVsZmlsbFJlYWRRdWV1ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbWFwQW5kUXVldWUodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgZW5kZWQgPSB0cnVlO1xuICAgICAgICAgICAgaW5mbGlnaHRDb3VudC0tO1xuICAgICAgICAgICAgbGFzdEVycm9yID0gZXJyb3I7XG4gICAgICAgICAgICBmdWxmaWxsUmVhZFF1ZXVlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVhZGluZyA9IGZhbHNlO1xuICAgICAgICBmaWxsUXVldWUoKTtcbiAgICB9XG4gICAgYXN5bmMgZnVuY3Rpb24gbWFwQW5kUXVldWUoaXRyVmFsdWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgZnVuYyhpdHJWYWx1ZSk7XG4gICAgICAgICAgICByZXN1bHRRdWV1ZS5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGVuZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGxhc3RFcnJvciA9IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGluZmxpZ2h0Q291bnQtLTtcbiAgICAgICAgZnVsZmlsbFJlYWRRdWV1ZSgpO1xuICAgICAgICBmaWxsUXVldWUoKTtcbiAgICB9XG4gICAgYXN5bmMgZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgaWYgKHJlc3VsdFF1ZXVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgY29uc3QgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgICAgICAgICAgcmVhZFF1ZXVlLnB1c2goZGVmZXJyZWQpO1xuICAgICAgICAgICAgZmlsbFF1ZXVlKCk7XG4gICAgICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWx1ZSA9IHJlc3VsdFF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgIGZpbGxRdWV1ZSgpO1xuICAgICAgICByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWUgfTtcbiAgICB9XG4gICAgY29uc3QgYXN5bmNJdGVyYWJsZUl0ZXJhdG9yID0ge1xuICAgICAgICBuZXh0LFxuICAgICAgICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdOiAoKSA9PiBhc3luY0l0ZXJhYmxlSXRlcmF0b3IsXG4gICAgfTtcbiAgICByZXR1cm4gYXN5bmNJdGVyYWJsZUl0ZXJhdG9yO1xufVxuZnVuY3Rpb24gdHJhbnNmb3JtKGNvbmN1cnJlbmN5LCBmdW5jLCBpdGVyYWJsZSkge1xuICAgIGlmIChmdW5jID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIChjdXJyaWVkRnVuYywgY3VycmllZEl0ZXJhYmxlKSA9PiBjdXJyaWVkSXRlcmFibGVcbiAgICAgICAgICAgID8gdHJhbnNmb3JtKGNvbmN1cnJlbmN5LCBjdXJyaWVkRnVuYywgY3VycmllZEl0ZXJhYmxlKVxuICAgICAgICAgICAgOiB0cmFuc2Zvcm0oY29uY3VycmVuY3ksIGN1cnJpZWRGdW5jKTtcbiAgICB9XG4gICAgaWYgKGl0ZXJhYmxlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIChjdXJyaWVkSXRlcmFibGUpID0+IHRyYW5zZm9ybShjb25jdXJyZW5jeSwgZnVuYywgY3VycmllZEl0ZXJhYmxlKTtcbiAgICB9XG4gICAgcmV0dXJuIF90cmFuc2Zvcm0oY29uY3VycmVuY3ksIGZ1bmMsIGl0ZXJhYmxlKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gX3dyaXRlVG9TdHJlYW0oc3RyZWFtLCBpdGVyYWJsZSkge1xuICAgIGxldCBsYXN0RXJyb3IgPSBudWxsO1xuICAgIGxldCBlcnJDYiA9IG51bGw7XG4gICAgbGV0IGRyYWluQ2IgPSBudWxsO1xuICAgIGNvbnN0IG5vdGlmeUVycm9yID0gZXJyID0+IHtcbiAgICAgICAgbGFzdEVycm9yID0gZXJyO1xuICAgICAgICBpZiAoZXJyQ2IpIHtcbiAgICAgICAgICAgIGVyckNiKGVycik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IG5vdGlmeURyYWluID0gKCkgPT4ge1xuICAgICAgICBpZiAoZHJhaW5DYikge1xuICAgICAgICAgICAgZHJhaW5DYigpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBjbGVhbnVwID0gKCkgPT4ge1xuICAgICAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgbm90aWZ5RXJyb3IpO1xuICAgICAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgbm90aWZ5RHJhaW4pO1xuICAgIH07XG4gICAgc3RyZWFtLm9uY2UoJ2Vycm9yJywgbm90aWZ5RXJyb3IpO1xuICAgIGNvbnN0IHdhaXRGb3JEcmFpbiA9ICgpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgaWYgKGxhc3RFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIHJlamVjdChsYXN0RXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHN0cmVhbS5vbmNlKCdkcmFpbicsIG5vdGlmeURyYWluKTtcbiAgICAgICAgZHJhaW5DYiA9IHJlc29sdmU7XG4gICAgICAgIGVyckNiID0gcmVqZWN0O1xuICAgIH0pO1xuICAgIGZvciBhd2FpdCAoY29uc3QgdmFsdWUgb2YgaXRlcmFibGUpIHtcbiAgICAgICAgaWYgKHN0cmVhbS53cml0ZSh2YWx1ZSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBhd2FpdCB3YWl0Rm9yRHJhaW4oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGFzdEVycm9yKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBjbGVhbnVwKCk7XG4gICAgaWYgKGxhc3RFcnJvcikge1xuICAgICAgICB0aHJvdyBsYXN0RXJyb3I7XG4gICAgfVxufVxuZnVuY3Rpb24gd3JpdGVUb1N0cmVhbShzdHJlYW0sIGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIChjdXJyaWVkSXRlcmFibGUpID0+IF93cml0ZVRvU3RyZWFtKHN0cmVhbSwgY3VycmllZEl0ZXJhYmxlKTtcbiAgICB9XG4gICAgcmV0dXJuIF93cml0ZVRvU3RyZWFtKHN0cmVhbSwgaXRlcmFibGUpO1xufVxuXG5leHBvcnQgeyBiYXRjaCwgYmF0Y2hXaXRoVGltZW91dCwgYnVmZmVyLCBjb2xsZWN0LCBjb25jYXQsIGNvbnN1bWUsIGZpbHRlciwgZmxhdE1hcCwgZmxhdFRyYW5zZm9ybSwgZmxhdHRlbiwgZnJvbVN0cmVhbSwgZ2V0SXRlcmF0b3IsIG1hcCwgbWVyZ2UsIHBhcmFsbGVsRmxhdE1hcCwgcGFyYWxsZWxNYXAsIHBhcmFsbGVsTWVyZ2UsIHBpcGVsaW5lLCByZWR1Y2UsIHRha2UsIHRhcCwgdGhyb3R0bGUsIHRpbWUsIHRyYW5zZm9ybSwgd3JpdGVUb1N0cmVhbSB9O1xuIiwgIi8qKlxuICogQSBjbGllbnQgbGlicmFyeSBmb3IgdGhlIGh0dHBzOi8vbmZ0LnN0b3JhZ2UvIHNlcnZpY2UuIEl0IHByb3ZpZGVzIGEgY29udmVuaWVudFxuICogaW50ZXJmYWNlIGZvciB3b3JraW5nIHdpdGggdGhlIFtSYXcgSFRUUCBBUEldKGh0dHBzOi8vbmZ0LnN0b3JhZ2UvI2FwaS1kb2NzKVxuICogZnJvbSBhIHdlYiBicm93c2VyIG9yIFtOb2RlLmpzXShodHRwczovL25vZGVqcy5vcmcvKSBhbmQgY29tZXMgYnVuZGxlZCB3aXRoXG4gKiBUUyBmb3Igb3V0LW9mLXRoZSBib3ggdHlwZSBpbmZlcmVuY2UgYW5kIGJldHRlciBJbnRlbGxpU2Vuc2UuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiBpbXBvcnQgeyBORlRTdG9yYWdlLCBGaWxlLCBCbG9iIH0gZnJvbSBcIm5mdC5zdG9yYWdlXCJcbiAqIGNvbnN0IGNsaWVudCA9IG5ldyBORlRTdG9yYWdlKHsgdG9rZW46IEFQSV9UT0tFTiB9KVxuICpcbiAqIGNvbnN0IGNpZCA9IGF3YWl0IGNsaWVudC5zdG9yZUJsb2IobmV3IEJsb2IoWydoZWxsbyB3b3JsZCddKSlcbiAqIGBgYFxuICogQG1vZHVsZVxuICovXG5cbmltcG9ydCB7IHRyYW5zZm9ybSB9IGZyb20gJ3N0cmVhbWluZy1pdGVyYWJsZXMnXG5pbXBvcnQgcFJldHJ5LCB7IEFib3J0RXJyb3IgfSBmcm9tICdwLXJldHJ5J1xuaW1wb3J0IHsgVHJlZXdhbGtDYXJTcGxpdHRlciB9IGZyb20gJ2NhcmJpdGVzL3RyZWV3YWxrJ1xuaW1wb3J0IHsgcGFjayB9IGZyb20gJ2lwZnMtY2FyL3BhY2snXG5pbXBvcnQgeyBDSUQgfSBmcm9tICdtdWx0aWZvcm1hdHMvY2lkJ1xuaW1wb3J0IHRocm90dGxlZFF1ZXVlIGZyb20gJ3Rocm90dGxlZC1xdWV1ZSdcbmltcG9ydCAqIGFzIFRva2VuIGZyb20gJy4vdG9rZW4uanMnXG5pbXBvcnQgeyBmZXRjaCwgRmlsZSwgQmxvYiwgRm9ybURhdGEsIEJsb2Nrc3RvcmUgfSBmcm9tICcuL3BsYXRmb3JtLmpzJ1xuaW1wb3J0IHsgdG9HYXRld2F5VVJMIH0gZnJvbSAnLi9nYXRld2F5LmpzJ1xuaW1wb3J0IHsgQmxvY2tzdG9yZUNhclJlYWRlciB9IGZyb20gJy4vYnMtY2FyLXJlYWRlci5qcydcbmltcG9ydCBwaXBlIGZyb20gJ2l0LXBpcGUnXG5cbmNvbnN0IE1BWF9TVE9SRV9SRVRSSUVTID0gNVxuY29uc3QgTUFYX0NPTkNVUlJFTlRfVVBMT0FEUyA9IDNcbmNvbnN0IE1BWF9DSFVOS19TSVpFID0gMTAyNCAqIDEwMjQgKiA1MCAvLyBjaHVuayB0byB+NTBNQiBDQVJzXG5jb25zdCBSQVRFX0xJTUlUX1JFUVVFU1RTID0gMzBcbmNvbnN0IFJBVEVfTElNSVRfUEVSSU9EID0gMTAgKiAxMDAwXG5cbi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnLi9saWIvaW50ZXJmYWNlLmpzJykuU2VydmljZX0gU2VydmljZVxuICogQHR5cGVkZWYge2ltcG9ydCgnLi9saWIvaW50ZXJmYWNlLmpzJykuQ0lEU3RyaW5nfSBDSURTdHJpbmdcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4vbGliL2ludGVyZmFjZS5qcycpLkRlYWx9IERlYWxcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4vbGliL2ludGVyZmFjZS5qcycpLkZpbGVPYmplY3R9IEZpbGVPYmplY3RcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4vbGliL2ludGVyZmFjZS5qcycpLkZpbGVzU291cmNlfSBGaWxlc1NvdXJjZVxuICogQHR5cGVkZWYge2ltcG9ydCgnLi9saWIvaW50ZXJmYWNlLmpzJykuUGlufSBQaW5cbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4vbGliL2ludGVyZmFjZS5qcycpLkNhclJlYWRlcn0gQ2FyUmVhZGVyXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdpcGZzLWNhci9ibG9ja3N0b3JlJykuQmxvY2tzdG9yZX0gQmxvY2tzdG9yZUlcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4vbGliL2ludGVyZmFjZS5qcycpLlJhdGVMaW1pdGVyfSBSYXRlTGltaXRlclxuICogQHR5cGVkZWYge2ltcG9ydCgnLi9saWIvaW50ZXJmYWNlLmpzJykuUmVxdWVzdE9wdGlvbnN9IFJlcXVlc3RPcHRpb25zXG4gKi9cblxuLyoqXG4gKiBAcmV0dXJucyB7UmF0ZUxpbWl0ZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVSYXRlTGltaXRlcigpIHtcbiAgY29uc3QgdGhyb3R0bGUgPSB0aHJvdHRsZWRRdWV1ZShSQVRFX0xJTUlUX1JFUVVFU1RTLCBSQVRFX0xJTUlUX1BFUklPRClcbiAgcmV0dXJuICgpID0+IHRocm90dGxlKCgpID0+IHt9KVxufVxuXG4vKipcbiAqIFJhdGUgbGltaXRlciB1c2VkIGJ5IHN0YXRpYyBBUEkgaWYgbm8gcmF0ZSBsaW1pdGVyIGlzIHBhc3NlZC4gTm90ZSB0aGF0IGVhY2hcbiAqIGluc3RhbmNlIG9mIHRoZSBORlRTdG9yYWdlIGNsYXNzIGdldHMgaXQncyBvd24gbGltaXRlciBpZiBub25lIGlzIHBhc3NlZC5cbiAqIFRoaXMgaXMgYmVjYXVzZSByYXRlIGxpbWl0cyBhcmUgZW5mb3JjZWQgcGVyIEFQSSB0b2tlbi5cbiAqL1xuY29uc3QgZ2xvYmFsUmF0ZUxpbWl0ZXIgPSBjcmVhdGVSYXRlTGltaXRlcigpXG5cbi8qKlxuICogQHRlbXBsYXRlIHtpbXBvcnQoJy4vbGliL2ludGVyZmFjZS5qcycpLlRva2VuSW5wdXR9IFRcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4vbGliL2ludGVyZmFjZS5qcycpLlRva2VuPFQ+fSBUb2tlblR5cGVcbiAqL1xuXG4vKipcbiAqIEBpbXBsZW1lbnRzIHtTZXJ2aWNlfVxuICovXG5jbGFzcyBORlRTdG9yYWdlIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBjbGllbnQgYm91bmQgdG8gdGhlIGdpdmVuIGBvcHRpb25zLnRva2VuYCBhbmRcbiAgICogYG9wdGlvbnMuZW5kcG9pbnRgLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiBpbXBvcnQgeyBORlRTdG9yYWdlLCBGaWxlLCBCbG9iIH0gZnJvbSBcIm5mdC5zdG9yYWdlXCJcbiAgICogY29uc3QgY2xpZW50ID0gbmV3IE5GVFN0b3JhZ2UoeyB0b2tlbjogQVBJX1RPS0VOIH0pXG4gICAqXG4gICAqIGNvbnN0IGNpZCA9IGF3YWl0IGNsaWVudC5zdG9yZUJsb2IobmV3IEJsb2IoWydoZWxsbyB3b3JsZCddKSlcbiAgICogYGBgXG4gICAqIE9wdGlvbmFsbHkgeW91IGNvdWxkIHBhc3MgYW4gYWx0ZXJuYXRpdmUgQVBJIGVuZHBvaW50IChlLmcuIGZvciB0ZXN0aW5nKVxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiBpbXBvcnQgeyBORlRTdG9yYWdlIH0gZnJvbSBcIm5mdC5zdG9yYWdlXCJcbiAgICogY29uc3QgY2xpZW50ID0gbmV3IE5GVFN0b3JhZ2Uoe1xuICAgKiAgIHRva2VuOiBBUElfVE9LRU5cbiAgICogICBlbmRwb2ludDogbmV3IFVSTCgnaHR0cDovL2xvY2FsaG9zdDo4MDgwLycpXG4gICAqIH0pXG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0ge3t0b2tlbjogc3RyaW5nLCBlbmRwb2ludD86IFVSTCwgcmF0ZUxpbWl0ZXI/OiBSYXRlTGltaXRlciwgZGlkPzogc3RyaW5nfX0gb3B0aW9uc1xuICAgKi9cbiAgY29uc3RydWN0b3Ioe1xuICAgIHRva2VuLFxuICAgIGRpZCxcbiAgICBlbmRwb2ludCA9IG5ldyBVUkwoJ2h0dHBzOi8vYXBpLm5mdC5zdG9yYWdlJyksXG4gICAgcmF0ZUxpbWl0ZXIsXG4gIH0pIHtcbiAgICAvKipcbiAgICAgKiBBdXRob3JpemF0aW9uIHRva2VuLlxuICAgICAqXG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG4gICAgdGhpcy50b2tlbiA9IHRva2VuXG4gICAgLyoqXG4gICAgICogU2VydmljZSBBUEkgZW5kcG9pbnQgYFVSTGAuXG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG4gICAgdGhpcy5lbmRwb2ludCA9IGVuZHBvaW50XG4gICAgLyoqXG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG4gICAgdGhpcy5yYXRlTGltaXRlciA9IHJhdGVMaW1pdGVyIHx8IGNyZWF0ZVJhdGVMaW1pdGVyKClcblxuICAgIC8qKlxuICAgICAqIEByZWFkb25seVxuICAgICAqL1xuICAgIHRoaXMuZGlkID0gZGlkXG4gIH1cblxuICAvKipcbiAgICogQGhpZGRlblxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy50b2tlblxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZGlkXVxuICAgKi9cbiAgc3RhdGljIGF1dGgoeyB0b2tlbiwgZGlkIH0pIHtcbiAgICBpZiAoIXRva2VuKSB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgdG9rZW4nKVxuICAgIHJldHVybiB7XG4gICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dG9rZW59YCxcbiAgICAgICdYLUNsaWVudCc6ICduZnQuc3RvcmFnZS9qcycsXG4gICAgICAuLi4oZGlkID8geyAneC1hZ2VudC1kaWQnOiBkaWQgfSA6IHt9KSxcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3RvcmVzIGEgc2luZ2xlIGZpbGUgYW5kIHJldHVybnMgaXRzIENJRC5cbiAgICpcbiAgICogQHBhcmFtIHtTZXJ2aWNlfSBzZXJ2aWNlXG4gICAqIEBwYXJhbSB7QmxvYn0gYmxvYlxuICAgKiBAcGFyYW0ge1JlcXVlc3RPcHRpb25zfSBbb3B0aW9uc11cbiAgICogQHJldHVybnMge1Byb21pc2U8Q0lEU3RyaW5nPn1cbiAgICovXG4gIHN0YXRpYyBhc3luYyBzdG9yZUJsb2Ioc2VydmljZSwgYmxvYiwgb3B0aW9ucykge1xuICAgIGNvbnN0IGJsb2Nrc3RvcmUgPSBuZXcgQmxvY2tzdG9yZSgpXG4gICAgbGV0IGNpZFN0cmluZ1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgY2lkLCBjYXIgfSA9IGF3YWl0IE5GVFN0b3JhZ2UuZW5jb2RlQmxvYihibG9iLCB7IGJsb2Nrc3RvcmUgfSlcbiAgICAgIGF3YWl0IE5GVFN0b3JhZ2Uuc3RvcmVDYXIoc2VydmljZSwgY2FyLCBvcHRpb25zKVxuICAgICAgY2lkU3RyaW5nID0gY2lkLnRvU3RyaW5nKClcbiAgICB9IGZpbmFsbHkge1xuICAgICAgYXdhaXQgYmxvY2tzdG9yZS5jbG9zZSgpXG4gICAgfVxuXG4gICAgcmV0dXJuIGNpZFN0cmluZ1xuICB9XG5cbiAgLyoqXG4gICAqIFN0b3JlcyBhIENBUiBmaWxlIGFuZCByZXR1cm5zIGl0cyByb290IENJRC5cbiAgICpcbiAgICogQHBhcmFtIHtTZXJ2aWNlfSBzZXJ2aWNlXG4gICAqIEBwYXJhbSB7QmxvYnxDYXJSZWFkZXJ9IGNhclxuICAgKiBAcGFyYW0ge2ltcG9ydCgnLi9saWIvaW50ZXJmYWNlLmpzJykuQ2FyU3RvcmVyT3B0aW9uc30gW29wdGlvbnNdXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPENJRFN0cmluZz59XG4gICAqL1xuICBzdGF0aWMgYXN5bmMgc3RvcmVDYXIoXG4gICAgeyBlbmRwb2ludCwgcmF0ZUxpbWl0ZXIgPSBnbG9iYWxSYXRlTGltaXRlciwgLi4udG9rZW4gfSxcbiAgICBjYXIsXG4gICAgeyBvblN0b3JlZENodW5rLCBtYXhSZXRyaWVzLCBtYXhDaHVua1NpemUsIGRlY29kZXJzLCBzaWduYWwgfSA9IHt9XG4gICkge1xuICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoJ3VwbG9hZC8nLCBlbmRwb2ludClcbiAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgLi4uTkZUU3RvcmFnZS5hdXRoKHRva2VuKSxcbiAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vY2FyJyxcbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0U2l6ZSA9IG1heENodW5rU2l6ZSB8fCBNQVhfQ0hVTktfU0laRVxuICAgIGNvbnN0IHNwbGl0dGVyID1cbiAgICAgIGNhciBpbnN0YW5jZW9mIEJsb2JcbiAgICAgICAgPyBhd2FpdCBUcmVld2Fsa0NhclNwbGl0dGVyLmZyb21CbG9iKGNhciwgdGFyZ2V0U2l6ZSwgeyBkZWNvZGVycyB9KVxuICAgICAgICA6IG5ldyBUcmVld2Fsa0NhclNwbGl0dGVyKGNhciwgdGFyZ2V0U2l6ZSwgeyBkZWNvZGVycyB9KVxuXG4gICAgY29uc3QgdXBsb2FkID0gdHJhbnNmb3JtKFxuICAgICAgTUFYX0NPTkNVUlJFTlRfVVBMT0FEUyxcbiAgICAgIGFzeW5jIGZ1bmN0aW9uICgvKiogQHR5cGUge0FzeW5jSXRlcmFibGU8VWludDhBcnJheT59ICovIGNhcikge1xuICAgICAgICBjb25zdCBjYXJQYXJ0cyA9IFtdXG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgcGFydCBvZiBjYXIpIHtcbiAgICAgICAgICBjYXJQYXJ0cy5wdXNoKHBhcnQpXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2FyRmlsZSA9IG5ldyBCbG9iKGNhclBhcnRzLCB7IHR5cGU6ICdhcHBsaWNhdGlvbi9jYXInIH0pXG4gICAgICAgIC8qKiBAdHlwZSB7QmxvYnxBcnJheUJ1ZmZlcn0gKi9cbiAgICAgICAgbGV0IGJvZHkgPSBjYXJGaWxlXG4gICAgICAgIC8vIEZJWE1FOiBzaG91bGQgbm90IGJlIG5lY2Vzc2FyeSB0byBhd2FpdCBhcnJheUJ1ZmZlcigpIVxuICAgICAgICAvLyBOb2RlLmpzIDIwIGhhbmdzIHJlYWRpbmcgdGhlIHN0cmVhbSAoaXQgbmV2ZXIgZW5kcykgYnV0IGluXG4gICAgICAgIC8vIG9sZGVyIG5vZGUgdmVyc2lvbnMgYW5kIHRoZSBicm93c2VyIGl0IGlzIGZpbmUgdG8gcGFzcyBhIGJsb2IuXG4gICAgICAgIC8qIGM4IGlnbm9yZSBuZXh0IDMgKi9cbiAgICAgICAgaWYgKHBhcnNlSW50KGdsb2JhbFRoaXMucHJvY2Vzcz8udmVyc2lvbnM/Lm5vZGUpID4gMTgpIHtcbiAgICAgICAgICBib2R5ID0gYXdhaXQgYm9keS5hcnJheUJ1ZmZlcigpXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2lkID0gYXdhaXQgcFJldHJ5KFxuICAgICAgICAgIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGF3YWl0IHJhdGVMaW1pdGVyKClcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7UmVzcG9uc2V9ICovXG4gICAgICAgICAgICBsZXQgcmVzcG9uc2VcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLnRvU3RyaW5nKCksIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICAgICAgc2lnbmFsLFxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSBjYXRjaCAoLyoqIEB0eXBlIHthbnl9ICovIGVycikge1xuICAgICAgICAgICAgICAvLyBUT0RPOiByZW1vdmUgbWUgYW5kIHRlc3Qgd2hlbiBjbGllbnQgYWNjZXB0cyBjdXN0b20gZmV0Y2ggaW1wbFxuICAgICAgICAgICAgICAvKiBjOCBpZ25vcmUgbmV4dCAxICovXG4gICAgICAgICAgICAgIHRocm93IHNpZ25hbCAmJiBzaWduYWwuYWJvcnRlZCA/IG5ldyBBYm9ydEVycm9yKGVycikgOiBlcnJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBuZXh0IDMgKi9cbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQyOSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JhdGUgbGltaXRlZCcpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKClcbiAgICAgICAgICAgIGlmICghcmVzdWx0Lm9rKSB7XG4gICAgICAgICAgICAgIC8vIGRvIG5vdCByZXRyeSBpZiB1bmF1dGhvcml6ZWQgLSB3aWxsIG5vdCBzdWNjZWVkXG4gICAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwMSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBYm9ydEVycm9yKHJlc3VsdC5lcnJvci5tZXNzYWdlKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihyZXN1bHQuZXJyb3IubWVzc2FnZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQudmFsdWUuY2lkXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICByZXRyaWVzOiBtYXhSZXRyaWVzID09IG51bGwgPyBNQVhfU1RPUkVfUkVUUklFUyA6IG1heFJldHJpZXMsXG4gICAgICAgICAgfVxuICAgICAgICApXG4gICAgICAgIG9uU3RvcmVkQ2h1bmsgJiYgb25TdG9yZWRDaHVuayhjYXJGaWxlLnNpemUpXG4gICAgICAgIHJldHVybiBjaWRcbiAgICAgIH1cbiAgICApXG5cbiAgICBsZXQgcm9vdFxuICAgIGZvciBhd2FpdCAoY29uc3QgY2lkIG9mIHVwbG9hZChzcGxpdHRlci5jYXJzKCkpKSB7XG4gICAgICByb290ID0gY2lkXG4gICAgfVxuXG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7Q0lEU3RyaW5nfSAqLyAocm9vdClcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9yZXMgYSBkaXJlY3Rvcnkgb2YgZmlsZXMgYW5kIHJldHVybnMgYSBDSUQuIFByb3ZpZGVkIGZpbGVzICoqTVVTVCoqXG4gICAqIGJlIHdpdGhpbiB0aGUgc2FtZSBkaXJlY3RvcnksIG90aGVyd2lzZSBlcnJvciBpcyByYWlzZWQgZS5nLiBgZm9vL2Jhci5wbmdgLFxuICAgKiBgZm9vL2JsYS9iYXouanNvbmAgaXMgb2sgYnV0IGBmb28vYmFyLnBuZ2AsIGBibGEvYmF6Lmpzb25gIGlzIG5vdC5cbiAgICpcbiAgICogQHBhcmFtIHtTZXJ2aWNlfSBzZXJ2aWNlXG4gICAqIEBwYXJhbSB7RmlsZXNTb3VyY2V9IGZpbGVzU291cmNlXG4gICAqIEBwYXJhbSB7UmVxdWVzdE9wdGlvbnN9IFtvcHRpb25zXVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDSURTdHJpbmc+fVxuICAgKi9cbiAgc3RhdGljIGFzeW5jIHN0b3JlRGlyZWN0b3J5KHNlcnZpY2UsIGZpbGVzU291cmNlLCBvcHRpb25zKSB7XG4gICAgY29uc3QgYmxvY2tzdG9yZSA9IG5ldyBCbG9ja3N0b3JlKClcbiAgICBsZXQgY2lkU3RyaW5nXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgY2lkLCBjYXIgfSA9IGF3YWl0IE5GVFN0b3JhZ2UuZW5jb2RlRGlyZWN0b3J5KGZpbGVzU291cmNlLCB7XG4gICAgICAgIGJsb2Nrc3RvcmUsXG4gICAgICB9KVxuICAgICAgYXdhaXQgTkZUU3RvcmFnZS5zdG9yZUNhcihzZXJ2aWNlLCBjYXIsIG9wdGlvbnMpXG4gICAgICBjaWRTdHJpbmcgPSBjaWQudG9TdHJpbmcoKVxuICAgIH0gZmluYWxseSB7XG4gICAgICBhd2FpdCBibG9ja3N0b3JlLmNsb3NlKClcbiAgICB9XG5cbiAgICByZXR1cm4gY2lkU3RyaW5nXG4gIH1cblxuICAvKipcbiAgICogU3RvcmVzIHRoZSBnaXZlbiB0b2tlbiBhbmQgYWxsIHJlc291cmNlcyBpdCByZWZlcmVuY2VzIChpbiB0aGUgZm9ybSBvZiBhXG4gICAqIEZpbGUgb3IgYSBCbG9iKSBhbG9uZyB3aXRoIGEgbWV0YWRhdGEgSlNPTiBhcyBzcGVjaWZpY2VkIGluIEVSQy0xMTU1LiBUaGVcbiAgICogYHRva2VuLmltYWdlYCBtdXN0IGJlIGVpdGhlciBhIGBGaWxlYCBvciBhIGBCbG9iYCBpbnN0YW5jZSwgd2hpY2ggd2lsbCBiZVxuICAgKiBzdG9yZWQgYW5kIHRoZSBjb3JyZXNwb25kaW5nIGNvbnRlbnQgYWRkcmVzcyBVUkwgd2lsbCBiZSBzYXZlZCBpbiB0aGVcbiAgICogbWV0YWRhdGEgSlNPTiBmaWxlIHVuZGVyIGBpbWFnZWAgZmllbGQuXG4gICAqXG4gICAqIElmIGB0b2tlbi5wcm9wZXJ0aWVzYCBjb250YWlucyBwcm9wZXJ0aWVzIHdpdGggYEZpbGVgIG9yIGBCbG9iYCB2YWx1ZXMsXG4gICAqIHRob3NlIGFsc28gZ2V0IHN0b3JlZCBhbmQgdGhlaXIgVVJMcyB3aWxsIGJlIHNhdmVkIGluIHRoZSBtZXRhZGF0YSBKU09OXG4gICAqIGZpbGUgaW4gdGhlaXIgcGxhY2UuXG4gICAqXG4gICAqIE5vdGU6IFVSTHMgZm9yIGBGaWxlYCBvYmplY3RzIHdpbGwgcmV0YWluIGZpbGUgbmFtZXMgZS5nLiBpbiBjYXNlIG9mXG4gICAqIGBuZXcgRmlsZShbYnl0ZXNdLCAnY2F0LnBuZycsIHsgdHlwZTogJ2ltYWdlL3BuZycgfSlgIHdpbGwgYmUgdHJhbnNmb3JtZWRcbiAgICogaW50byBhIFVSTCB0aGF0IGxvb2tzIGxpa2UgYGlwZnM6Ly9iYWZ5Li4uaGFzaC9pbWFnZS9jYXQucG5nYC4gRm9yIGBCbG9iYFxuICAgKiBvYmplY3RzLCB0aGUgVVJMIHdpbGwgbm90IGhhdmUgYSBmaWxlIG5hbWUgbmFtZSBvciBtaW1lIHR5cGUsIGluc3RlYWQgaXRcbiAgICogd2lsbCBiZSB0cmFuc2Zvcm1lZCBpbnRvIGEgVVJMIHRoYXQgbG9va3MgbGlrZVxuICAgKiBgaXBmczovL2JhZnkuLi5oYXNoL2ltYWdlL2Jsb2JgLlxuICAgKlxuICAgKiBAdGVtcGxhdGUge2ltcG9ydCgnLi9saWIvaW50ZXJmYWNlLmpzJykuVG9rZW5JbnB1dH0gVFxuICAgKiBAcGFyYW0ge1NlcnZpY2V9IHNlcnZpY2VcbiAgICogQHBhcmFtIHtUfSBtZXRhZGF0YVxuICAgKiBAcGFyYW0ge1JlcXVlc3RPcHRpb25zfSBbb3B0aW9uc11cbiAgICogQHJldHVybnMge1Byb21pc2U8VG9rZW5UeXBlPFQ+Pn1cbiAgICovXG4gIHN0YXRpYyBhc3luYyBzdG9yZShzZXJ2aWNlLCBtZXRhZGF0YSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgdG9rZW4sIGNhciB9ID0gYXdhaXQgTkZUU3RvcmFnZS5lbmNvZGVORlQobWV0YWRhdGEpXG4gICAgYXdhaXQgTkZUU3RvcmFnZS5zdG9yZUNhcihzZXJ2aWNlLCBjYXIsIG9wdGlvbnMpXG4gICAgcmV0dXJuIHRva2VuXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBjdXJyZW50IHN0YXR1cyBvZiB0aGUgc3RvcmVkIE5GVCBieSBpdHMgQ0lELiBOb3RlIHRoZSBORlQgbXVzdFxuICAgKiBoYXZlIHByZXZpb3VzbHkgYmVlbiBzdG9yZWQgYnkgdGhpcyBhY2NvdW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1NlcnZpY2V9IHNlcnZpY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNpZFxuICAgKiBAcGFyYW0ge1JlcXVlc3RPcHRpb25zfSBbb3B0aW9uc11cbiAgICogQHJldHVybnMge1Byb21pc2U8aW1wb3J0KCcuL2xpYi9pbnRlcmZhY2UuanMnKS5TdGF0dXNSZXN1bHQ+fVxuICAgKi9cbiAgc3RhdGljIGFzeW5jIHN0YXR1cyhcbiAgICB7IGVuZHBvaW50LCByYXRlTGltaXRlciA9IGdsb2JhbFJhdGVMaW1pdGVyLCAuLi50b2tlbiB9LFxuICAgIGNpZCxcbiAgICBvcHRpb25zXG4gICkge1xuICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoYCR7Y2lkfS9gLCBlbmRwb2ludClcbiAgICBhd2FpdCByYXRlTGltaXRlcigpXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwudG9TdHJpbmcoKSwge1xuICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgIGhlYWRlcnM6IE5GVFN0b3JhZ2UuYXV0aCh0b2tlbiksXG4gICAgICBzaWduYWw6IG9wdGlvbnMgJiYgb3B0aW9ucy5zaWduYWwsXG4gICAgfSlcbiAgICAvKiBjOCBpZ25vcmUgbmV4dCAzICovXG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDI5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JhdGUgbGltaXRlZCcpXG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKVxuXG4gICAgaWYgKHJlc3VsdC5vaykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY2lkOiByZXN1bHQudmFsdWUuY2lkLFxuICAgICAgICBkZWFsczogZGVjb2RlRGVhbHMocmVzdWx0LnZhbHVlLmRlYWxzKSxcbiAgICAgICAgc2l6ZTogcmVzdWx0LnZhbHVlLnNpemUsXG4gICAgICAgIHBpbjogZGVjb2RlUGluKHJlc3VsdC52YWx1ZS5waW4pLFxuICAgICAgICBjcmVhdGVkOiBuZXcgRGF0ZShyZXN1bHQudmFsdWUuY3JlYXRlZCksXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihyZXN1bHQuZXJyb3IubWVzc2FnZSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSBDSUQgb2YgYW4gTkZUIGlzIGJlaW5nIHN0b3JlZCBieSBORlQuU3RvcmFnZS5cbiAgICpcbiAgICogQHBhcmFtIHtpbXBvcnQoJy4vbGliL2ludGVyZmFjZS5qcycpLlB1YmxpY1NlcnZpY2V9IHNlcnZpY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNpZFxuICAgKiBAcGFyYW0ge1JlcXVlc3RPcHRpb25zfSBbb3B0aW9uc11cbiAgICogQHJldHVybnMge1Byb21pc2U8aW1wb3J0KCcuL2xpYi9pbnRlcmZhY2UuanMnKS5DaGVja1Jlc3VsdD59XG4gICAqL1xuICBzdGF0aWMgYXN5bmMgY2hlY2soXG4gICAgeyBlbmRwb2ludCwgcmF0ZUxpbWl0ZXIgPSBnbG9iYWxSYXRlTGltaXRlciB9LFxuICAgIGNpZCxcbiAgICBvcHRpb25zXG4gICkge1xuICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoYGNoZWNrLyR7Y2lkfS9gLCBlbmRwb2ludClcbiAgICBhd2FpdCByYXRlTGltaXRlcigpXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwudG9TdHJpbmcoKSwge1xuICAgICAgc2lnbmFsOiBvcHRpb25zICYmIG9wdGlvbnMuc2lnbmFsLFxuICAgIH0pXG4gICAgLyogYzggaWdub3JlIG5leHQgMyAqL1xuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQyOSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdyYXRlIGxpbWl0ZWQnKVxuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKClcblxuICAgIGlmIChyZXN1bHQub2spIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNpZDogcmVzdWx0LnZhbHVlLmNpZCxcbiAgICAgICAgZGVhbHM6IGRlY29kZURlYWxzKHJlc3VsdC52YWx1ZS5kZWFscyksXG4gICAgICAgIHBpbjogcmVzdWx0LnZhbHVlLnBpbixcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHJlc3VsdC5lcnJvci5tZXNzYWdlKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIHN0b3JlZCBjb250ZW50IGJ5IGl0cyBDSUQgZnJvbSB0aGlzIGFjY291bnQuIFBsZWFzZSBub3RlIHRoYXRcbiAgICogZXZlbiBpZiBjb250ZW50IGlzIHJlbW92ZWQgZnJvbSB0aGUgc2VydmljZSBvdGhlciBub2RlcyB0aGF0IGhhdmVcbiAgICogcmVwbGljYXRlZCBpdCBtaWdodCBzdGlsbCBjb250aW51ZSBwcm92aWRpbmcgaXQuXG4gICAqXG4gICAqIEBwYXJhbSB7U2VydmljZX0gc2VydmljZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2lkXG4gICAqIEBwYXJhbSB7UmVxdWVzdE9wdGlvbnN9IFtvcHRpb25zXVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICovXG4gIHN0YXRpYyBhc3luYyBkZWxldGUoXG4gICAgeyBlbmRwb2ludCwgcmF0ZUxpbWl0ZXIgPSBnbG9iYWxSYXRlTGltaXRlciwgLi4udG9rZW4gfSxcbiAgICBjaWQsXG4gICAgb3B0aW9uc1xuICApIHtcbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKGAke2NpZH0vYCwgZW5kcG9pbnQpXG4gICAgYXdhaXQgcmF0ZUxpbWl0ZXIoKVxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLnRvU3RyaW5nKCksIHtcbiAgICAgIG1ldGhvZDogJ0RFTEVURScsXG4gICAgICBoZWFkZXJzOiBORlRTdG9yYWdlLmF1dGgodG9rZW4pLFxuICAgICAgc2lnbmFsOiBvcHRpb25zICYmIG9wdGlvbnMuc2lnbmFsLFxuICAgIH0pXG4gICAgLyogYzggaWdub3JlIG5leHQgMyAqL1xuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQyOSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdyYXRlIGxpbWl0ZWQnKVxuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKClcbiAgICBpZiAoIXJlc3VsdC5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHJlc3VsdC5lcnJvci5tZXNzYWdlKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBFbmNvZGVzIHRoZSBnaXZlbiB0b2tlbiBhbmQgYWxsIHJlc291cmNlcyBpdCByZWZlcmVuY2VzIChpbiB0aGUgZm9ybSBvZiBhXG4gICAqIEZpbGUgb3IgYSBCbG9iKSBhbG9uZyB3aXRoIGEgbWV0YWRhdGEgSlNPTiBhcyBzcGVjaWZpY2VkIGluIEVSQy0xMTU1IHRvIGFcbiAgICogQ0FSIGZpbGUuIFRoZSBgdG9rZW4uaW1hZ2VgIG11c3QgYmUgZWl0aGVyIGEgYEZpbGVgIG9yIGEgYEJsb2JgIGluc3RhbmNlLFxuICAgKiB3aGljaCB3aWxsIGJlIHN0b3JlZCBhbmQgdGhlIGNvcnJlc3BvbmRpbmcgY29udGVudCBhZGRyZXNzIFVSTCB3aWxsIGJlXG4gICAqIHNhdmVkIGluIHRoZSBtZXRhZGF0YSBKU09OIGZpbGUgdW5kZXIgYGltYWdlYCBmaWVsZC5cbiAgICpcbiAgICogSWYgYHRva2VuLnByb3BlcnRpZXNgIGNvbnRhaW5zIHByb3BlcnRpZXMgd2l0aCBgRmlsZWAgb3IgYEJsb2JgIHZhbHVlcyxcbiAgICogdGhvc2UgYWxzbyBnZXQgc3RvcmVkIGFuZCB0aGVpciBVUkxzIHdpbGwgYmUgc2F2ZWQgaW4gdGhlIG1ldGFkYXRhIEpTT05cbiAgICogZmlsZSBpbiB0aGVpciBwbGFjZS5cbiAgICpcbiAgICogTm90ZTogVVJMcyBmb3IgYEZpbGVgIG9iamVjdHMgd2lsbCByZXRhaW4gZmlsZSBuYW1lcyBlLmcuIGluIGNhc2Ugb2ZcbiAgICogYG5ldyBGaWxlKFtieXRlc10sICdjYXQucG5nJywgeyB0eXBlOiAnaW1hZ2UvcG5nJyB9KWAgd2lsbCBiZSB0cmFuc2Zvcm1lZFxuICAgKiBpbnRvIGEgVVJMIHRoYXQgbG9va3MgbGlrZSBgaXBmczovL2JhZnkuLi5oYXNoL2ltYWdlL2NhdC5wbmdgLiBGb3IgYEJsb2JgXG4gICAqIG9iamVjdHMsIHRoZSBVUkwgd2lsbCBub3QgaGF2ZSBhIGZpbGUgbmFtZSBuYW1lIG9yIG1pbWUgdHlwZSwgaW5zdGVhZCBpdFxuICAgKiB3aWxsIGJlIHRyYW5zZm9ybWVkIGludG8gYSBVUkwgdGhhdCBsb29rcyBsaWtlXG4gICAqIGBpcGZzOi8vYmFmeS4uLmhhc2gvaW1hZ2UvYmxvYmAuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IHsgdG9rZW4sIGNhciB9ID0gYXdhaXQgTkZUU3RvcmFnZS5lbmNvZGVORlQoe1xuICAgKiAgIG5hbWU6ICduZnQuc3RvcmFnZSBzdG9yZSB0ZXN0JyxcbiAgICogICBkZXNjcmlwdGlvbjogJ1Rlc3QgRVJDLTExNTUgY29tcGF0aWJsZSBtZXRhZGF0YS4nLFxuICAgKiAgIGltYWdlOiBuZXcgRmlsZShbJzxEQVRBPiddLCAncGlucGllLmpwZycsIHsgdHlwZTogJ2ltYWdlL2pwZycgfSksXG4gICAqICAgcHJvcGVydGllczoge1xuICAgKiAgICAgY3VzdG9tOiAnQ3VzdG9tIGRhdGEgY2FuIGFwcGVhciBoZXJlLCBmaWxlcyBhcmUgYXV0byB1cGxvYWRlZC4nLFxuICAgKiAgICAgZmlsZTogbmV3IEZpbGUoWyc8REFUQT4nXSwgJ1JFQURNRS5tZCcsIHsgdHlwZTogJ3RleHQvcGxhaW4nIH0pLFxuICAgKiAgIH1cbiAgICogfSlcbiAgICpcbiAgICogY29uc29sZS5sb2coJ0lQRlMgVVJMIGZvciB0aGUgbWV0YWRhdGE6JywgdG9rZW4udXJsKVxuICAgKiBjb25zb2xlLmxvZygnbWV0YWRhdGEuanNvbiBjb250ZW50czpcXG4nLCB0b2tlbi5kYXRhKVxuICAgKiBjb25zb2xlLmxvZygnbWV0YWRhdGEuanNvbiB3aXRoIElQRlMgZ2F0ZXdheSBVUkxzOlxcbicsIHRva2VuLmVtYmVkKCkpXG4gICAqXG4gICAqIC8vIE5vdyBzdG9yZSB0aGUgQ0FSIGZpbGUgb24gTkZULlN0b3JhZ2VcbiAgICogYXdhaXQgY2xpZW50LnN0b3JlQ2FyKGNhcilcbiAgICogYGBgXG4gICAqXG4gICAqIEB0ZW1wbGF0ZSB7aW1wb3J0KCcuL2xpYi9pbnRlcmZhY2UuanMnKS5Ub2tlbklucHV0fSBUXG4gICAqIEBwYXJhbSB7VH0gaW5wdXRcbiAgICogQHJldHVybnMge1Byb21pc2U8eyBjaWQ6IENJRCwgdG9rZW46IFRva2VuVHlwZTxUPiwgY2FyOiBDYXJSZWFkZXIgfT59XG4gICAqL1xuICBzdGF0aWMgYXN5bmMgZW5jb2RlTkZUKGlucHV0KSB7XG4gICAgdmFsaWRhdGVFUkMxMTU1KGlucHV0KVxuICAgIHJldHVybiBUb2tlbi5Ub2tlbi5lbmNvZGUoaW5wdXQpXG4gIH1cblxuICAvKipcbiAgICogRW5jb2RlcyBhIHNpbmdsZSBmaWxlIHRvIGEgQ0FSIGZpbGUgYW5kIGFsc28gcmV0dXJucyBpdHMgcm9vdCBDSUQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IGNvbnRlbnQgPSBuZXcgQmxvYihbJ2hlbGxvIHdvcmxkJ10pXG4gICAqIGNvbnN0IHsgY2lkLCBjYXIgfSA9IGF3YWl0IE5GVFN0b3JhZ2UuZW5jb2RlQmxvYihjb250ZW50KVxuICAgKlxuICAgKiAvLyBSb290IENJRCBvZiB0aGUgZmlsZVxuICAgKiBjb25zb2xlLmxvZyhjaWQudG9TdHJpbmcoKSlcbiAgICpcbiAgICogLy8gTm93IHN0b3JlIHRoZSBDQVIgZmlsZSBvbiBORlQuU3RvcmFnZVxuICAgKiBhd2FpdCBjbGllbnQuc3RvcmVDYXIoY2FyKVxuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIHtCbG9ifSBibG9iXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAgICogQHBhcmFtIHtCbG9ja3N0b3JlSX0gW29wdGlvbnMuYmxvY2tzdG9yZV1cbiAgICogQHJldHVybnMge1Byb21pc2U8eyBjaWQ6IENJRCwgY2FyOiBDYXJSZWFkZXIgfT59XG4gICAqL1xuICBzdGF0aWMgYXN5bmMgZW5jb2RlQmxvYihibG9iLCB7IGJsb2Nrc3RvcmUgfSA9IHt9KSB7XG4gICAgaWYgKGJsb2Iuc2l6ZSA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb250ZW50IHNpemUgaXMgMCwgbWFrZSBzdXJlIHRvIHByb3ZpZGUgc29tZSBjb250ZW50JylcbiAgICB9XG4gICAgcmV0dXJuIHBhY2tDYXIoW3RvSW1wb3J0Q2FuZGlkYXRlKCdibG9iJywgYmxvYildLCB7XG4gICAgICBibG9ja3N0b3JlLFxuICAgICAgd3JhcFdpdGhEaXJlY3Rvcnk6IGZhbHNlLFxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogRW5jb2RlcyBhIGRpcmVjdG9yeSBvZiBmaWxlcyB0byBhIENBUiBmaWxlIGFuZCBhbHNvIHJldHVybnMgdGhlIHJvb3QgQ0lELlxuICAgKiBQcm92aWRlZCBmaWxlcyAqKk1VU1QqKiBiZSB3aXRoaW4gdGhlIHNhbWUgZGlyZWN0b3J5LCBvdGhlcndpc2UgZXJyb3IgaXNcbiAgICogcmFpc2VkIGUuZy4gYGZvby9iYXIucG5nYCwgYGZvby9ibGEvYmF6Lmpzb25gIGlzIG9rIGJ1dCBgZm9vL2Jhci5wbmdgLFxuICAgKiBgYmxhL2Jhei5qc29uYCBpcyBub3QuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IHsgY2lkLCBjYXIgfSA9IGF3YWl0IE5GVFN0b3JhZ2UuZW5jb2RlRGlyZWN0b3J5KFtcbiAgICogICBuZXcgRmlsZShbJ2hlbGxvIHdvcmxkJ10sICdoZWxsby50eHQnKSxcbiAgICogICBuZXcgRmlsZShbSlNPTi5zdHJpbmdpZnkoeydmcm9tJzogJ2luY29nbml0byd9LCBudWxsLCAyKV0sICdtZXRhZGF0YS5qc29uJylcbiAgICogXSlcbiAgICpcbiAgICogLy8gUm9vdCBDSUQgb2YgdGhlIGRpcmVjdG9yeVxuICAgKiBjb25zb2xlLmxvZyhjaWQudG9TdHJpbmcoKSlcbiAgICpcbiAgICogLy8gTm93IHN0b3JlIHRoZSBDQVIgZmlsZSBvbiBORlQuU3RvcmFnZVxuICAgKiBhd2FpdCBjbGllbnQuc3RvcmVDYXIoY2FyKVxuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIHtGaWxlc1NvdXJjZX0gZmlsZXNcbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICAgKiBAcGFyYW0ge0Jsb2Nrc3RvcmVJfSBbb3B0aW9ucy5ibG9ja3N0b3JlXVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx7IGNpZDogQ0lELCBjYXI6IENhclJlYWRlciB9Pn1cbiAgICovXG4gIHN0YXRpYyBhc3luYyBlbmNvZGVEaXJlY3RvcnkoZmlsZXMsIHsgYmxvY2tzdG9yZSB9ID0ge30pIHtcbiAgICBsZXQgc2l6ZSA9IDBcbiAgICBjb25zdCBpbnB1dCA9IHBpcGUoZmlsZXMsIGFzeW5jIGZ1bmN0aW9uKiAoZmlsZXMpIHtcbiAgICAgIGZvciBhd2FpdCAoY29uc3QgZmlsZSBvZiBmaWxlcykge1xuICAgICAgICB5aWVsZCB0b0ltcG9ydENhbmRpZGF0ZShmaWxlLm5hbWUsIGZpbGUpXG4gICAgICAgIHNpemUgKz0gZmlsZS5zaXplXG4gICAgICB9XG4gICAgfSlcbiAgICBjb25zdCBwYWNrZWQgPSBhd2FpdCBwYWNrQ2FyKGlucHV0LCB7XG4gICAgICBibG9ja3N0b3JlLFxuICAgICAgd3JhcFdpdGhEaXJlY3Rvcnk6IHRydWUsXG4gICAgfSlcbiAgICBpZiAoc2l6ZSA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnVG90YWwgc2l6ZSBvZiBmaWxlcyBzaG91bGQgZXhjZWVkIDAsIG1ha2Ugc3VyZSB0byBwcm92aWRlIHNvbWUgY29udGVudCdcbiAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIHBhY2tlZFxuICB9XG5cbiAgLy8gSnVzdCBhIHN1Z2FyIHNvIHlvdSBkb24ndCBoYXZlIHRvIHBhc3MgYXJvdW5kIGVuZHBvaW50IGFuZCB0b2tlbiBhcm91bmQuXG5cbiAgLyoqXG4gICAqIFN0b3JlcyBhIHNpbmdsZSBmaWxlIGFuZCByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIENvbnRlbnQgSWRlbnRpZmllciAoQ0lEKS5cbiAgICogVGFrZXMgYSBbQmxvYl0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0Jsb2IvQmxvYilcbiAgICogb3IgYSBbRmlsZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0ZpbGUpLiBOb3RlXG4gICAqIHRoYXQgbm8gZmlsZSBuYW1lIG9yIGZpbGUgbWV0YWRhdGEgaXMgcmV0YWluZWQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IGNvbnRlbnQgPSBuZXcgQmxvYihbJ2hlbGxvIHdvcmxkJ10pXG4gICAqIGNvbnN0IGNpZCA9IGF3YWl0IGNsaWVudC5zdG9yZUJsb2IoY29udGVudClcbiAgICogY2lkIC8vPiAnemRqN1duOUZRQVVSQ1A2TWJ3Y1d1emk3dTY1a0FzWENkak5Ua2hiSmNvYVhCdXNxOSdcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSB7QmxvYn0gYmxvYlxuICAgKiBAcGFyYW0ge1JlcXVlc3RPcHRpb25zfSBbb3B0aW9uc11cbiAgICovXG4gIHN0b3JlQmxvYihibG9iLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIE5GVFN0b3JhZ2Uuc3RvcmVCbG9iKHRoaXMsIGJsb2IsIG9wdGlvbnMpXG4gIH1cblxuICAvKipcbiAgICogU3RvcmVzIGZpbGVzIGVuY29kZWQgYXMgYSBzaW5nbGUgW0NvbnRlbnQgQWRkcmVzc2VkIEFyY2hpdmVcbiAgICogKENBUildKGh0dHBzOi8vZ2l0aHViLmNvbS9pcGxkL3NwZWNzL2Jsb2IvbWFzdGVyL2Jsb2NrLWxheWVyL2NvbnRlbnQtYWRkcmVzc2FibGUtYXJjaGl2ZXMubWQpLlxuICAgKlxuICAgKiBUYWtlcyBhIFtCbG9iXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQmxvYi9CbG9iKVxuICAgKiBvciBhIFtGaWxlXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRmlsZSkuXG4gICAqXG4gICAqIFJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgQ29udGVudCBJZGVudGlmaWVyIChDSUQpLlxuICAgKlxuICAgKiBTZWUgdGhlIFtgaXBmcy1jYXJgIGRvY3NdKGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL2lwZnMtY2FyKSBmb3IgbW9yZVxuICAgKiBkZXRhaWxzIG9uIHBhY2tpbmcgYSBDQVIgZmlsZS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICogaW1wb3J0IHsgcGFjayB9IGZyb20gJ2lwZnMtY2FyL3BhY2snXG4gICAqIGltcG9ydCB7IENhclJlYWRlciB9IGZyb20gJ0BpcGxkL2NhcidcbiAgICogY29uc3QgeyBvdXQsIHJvb3QgfSA9IGF3YWl0IHBhY2soe1xuICAgKiAgaW5wdXQ6IGZzLmNyZWF0ZVJlYWRTdHJlYW0oJ3BpbnBpZS5wZGYnKVxuICAgKiB9KVxuICAgKiBjb25zdCBleHBlY3RlZENpZCA9IHJvb3QudG9TdHJpbmcoKVxuICAgKiBjb25zdCBjYXJSZWFkZXIgPSBhd2FpdCBDYXJSZWFkZXIuZnJvbUl0ZXJhYmxlKG91dClcbiAgICogY29uc3QgY2lkID0gYXdhaXQgc3RvcmFnZS5zdG9yZUNhcihjYXJSZWFkZXIpXG4gICAqIGNvbnNvbGUuYXNzZXJ0KGNpZCA9PT0gZXhwZWN0ZWRDaWQpXG4gICAqIGBgYFxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBcbiAgICogaW1wb3J0IHsgcGFja1RvQmxvYiB9IGZyb20gJ2lwZnMtY2FyL3BhY2svYmxvYidcbiAgICogY29uc3QgZGF0YSA9ICdIZWxsbyB3b3JsZCdcbiAgICogY29uc3QgeyByb290LCBjYXIgfSA9IGF3YWl0IHBhY2tUb0Jsb2IoeyBpbnB1dDogW25ldyBUZXh0RW5jb2RlcigpLmVuY29kZShkYXRhKV0gfSlcbiAgICogY29uc3QgZXhwZWN0ZWRDaWQgPSByb290LnRvU3RyaW5nKClcbiAgICogY29uc3QgY2lkID0gYXdhaXQgY2xpZW50LnN0b3JlQ2FyKGNhcilcbiAgICogY29uc29sZS5hc3NlcnQoY2lkID09PSBleHBlY3RlZENpZClcbiAgICogYGBgXG4gICAqIEBwYXJhbSB7QmxvYnxDYXJSZWFkZXJ9IGNhclxuICAgKiBAcGFyYW0ge2ltcG9ydCgnLi9saWIvaW50ZXJmYWNlLmpzJykuQ2FyU3RvcmVyT3B0aW9uc30gW29wdGlvbnNdXG4gICAqL1xuICBzdG9yZUNhcihjYXIsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gTkZUU3RvcmFnZS5zdG9yZUNhcih0aGlzLCBjYXIsIG9wdGlvbnMpXG4gIH1cblxuICAvKipcbiAgICogU3RvcmVzIGEgZGlyZWN0b3J5IG9mIGZpbGVzIGFuZCByZXR1cm5zIGEgQ0lEIGZvciB0aGUgZGlyZWN0b3J5LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiBjb25zdCBjaWQgPSBhd2FpdCBjbGllbnQuc3RvcmVEaXJlY3RvcnkoW1xuICAgKiAgIG5ldyBGaWxlKFsnaGVsbG8gd29ybGQnXSwgJ2hlbGxvLnR4dCcpLFxuICAgKiAgIG5ldyBGaWxlKFtKU09OLnN0cmluZ2lmeSh7J2Zyb20nOiAnaW5jb2duaXRvJ30sIG51bGwsIDIpXSwgJ21ldGFkYXRhLmpzb24nKVxuICAgKiBdKVxuICAgKiBjaWQgLy8+XG4gICAqIGBgYFxuICAgKlxuICAgKiBBcmd1bWVudCBjYW4gYmUgYSBbRmlsZUxpc3RdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9GaWxlTGlzdClcbiAgICogaW5zdGFuY2UgYXMgd2VsbCwgaW4gd2hpY2ggY2FzZSBkaXJlY3Rvcnkgc3RydWN0dXJlIHdpbGwgYmUgcmV0YWluZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7RmlsZXNTb3VyY2V9IGZpbGVzXG4gICAqIEBwYXJhbSB7UmVxdWVzdE9wdGlvbnN9IFtvcHRpb25zXVxuICAgKi9cbiAgc3RvcmVEaXJlY3RvcnkoZmlsZXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gTkZUU3RvcmFnZS5zdG9yZURpcmVjdG9yeSh0aGlzLCBmaWxlcywgb3B0aW9ucylcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGN1cnJlbnQgc3RhdHVzIG9mIHRoZSBzdG9yZWQgTkZUIGJ5IGl0cyBDSUQuIE5vdGUgdGhlIE5GVCBtdXN0XG4gICAqIGhhdmUgcHJldmlvdXNseSBiZWVuIHN0b3JlZCBieSB0aGlzIGFjY291bnQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IHN0YXR1cyA9IGF3YWl0IGNsaWVudC5zdGF0dXMoJ3pkajdXbjlGUUFVUkNQNk1id2NXdXppN3U2NWtBc1hDZGpOVGtoYkpjb2FYQnVzcTknKVxuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNpZFxuICAgKiBAcGFyYW0ge1JlcXVlc3RPcHRpb25zfSBbb3B0aW9uc11cbiAgICovXG4gIHN0YXR1cyhjaWQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gTkZUU3RvcmFnZS5zdGF0dXModGhpcywgY2lkLCBvcHRpb25zKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgc3RvcmVkIGNvbnRlbnQgYnkgaXRzIENJRCBmcm9tIHRoZSBzZXJ2aWNlLlxuICAgKlxuICAgKiA+IFBsZWFzZSBub3RlIHRoYXQgZXZlbiBpZiBjb250ZW50IGlzIHJlbW92ZWQgZnJvbSB0aGUgc2VydmljZSBvdGhlciBub2Rlc1xuICAgKiB0aGF0IGhhdmUgcmVwbGljYXRlZCBpdCBtaWdodCBzdGlsbCBjb250aW51ZSBwcm92aWRpbmcgaXQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIGF3YWl0IGNsaWVudC5kZWxldGUoJ3pkajdXbjlGUUFVUkNQNk1id2NXdXppN3U2NWtBc1hDZGpOVGtoYkpjb2FYQnVzcTknKVxuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNpZFxuICAgKiBAcGFyYW0ge1JlcXVlc3RPcHRpb25zfSBbb3B0aW9uc11cbiAgICovXG4gIGRlbGV0ZShjaWQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gTkZUU3RvcmFnZS5kZWxldGUodGhpcywgY2lkLCBvcHRpb25zKVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgQ0lEIG9mIGFuIE5GVCBpcyBiZWluZyBzdG9yZWQgYnkgbmZ0LnN0b3JhZ2UuIFRocm93cyBpZiB0aGUgTkZUXG4gICAqIHdhcyBub3QgZm91bmQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IHN0YXR1cyA9IGF3YWl0IGNsaWVudC5jaGVjaygnemRqN1duOUZRQVVSQ1A2TWJ3Y1d1emk3dTY1a0FzWENkak5Ua2hiSmNvYVhCdXNxOScpXG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2lkXG4gICAqIEBwYXJhbSB7UmVxdWVzdE9wdGlvbnN9IFtvcHRpb25zXVxuICAgKi9cbiAgY2hlY2soY2lkLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIE5GVFN0b3JhZ2UuY2hlY2sodGhpcywgY2lkLCBvcHRpb25zKVxuICB9XG5cbiAgLyoqXG4gICAqIFN0b3JlcyB0aGUgZ2l2ZW4gdG9rZW4gYW5kIGFsbCByZXNvdXJjZXMgaXQgcmVmZXJlbmNlcyAoaW4gdGhlIGZvcm0gb2YgYVxuICAgKiBGaWxlIG9yIGEgQmxvYikgYWxvbmcgd2l0aCBhIG1ldGFkYXRhIEpTT04gYXMgc3BlY2lmaWNlZCBpblxuICAgKiBbRVJDLTExNTVdKGh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtMTE1NSNtZXRhZGF0YSkuIFRoZVxuICAgKiBgdG9rZW4uaW1hZ2VgIG11c3QgYmUgZWl0aGVyIGEgYEZpbGVgIG9yIGEgYEJsb2JgIGluc3RhbmNlLCB3aGljaCB3aWxsIGJlXG4gICAqIHN0b3JlZCBhbmQgdGhlIGNvcnJlc3BvbmRpbmcgY29udGVudCBhZGRyZXNzIFVSTCB3aWxsIGJlIHNhdmVkIGluIHRoZVxuICAgKiBtZXRhZGF0YSBKU09OIGZpbGUgdW5kZXIgYGltYWdlYCBmaWVsZC5cbiAgICpcbiAgICogSWYgYHRva2VuLnByb3BlcnRpZXNgIGNvbnRhaW5zIHByb3BlcnRpZXMgd2l0aCBgRmlsZWAgb3IgYEJsb2JgIHZhbHVlcyxcbiAgICogdGhvc2UgYWxzbyBnZXQgc3RvcmVkIGFuZCB0aGVpciBVUkxzIHdpbGwgYmUgc2F2ZWQgaW4gdGhlIG1ldGFkYXRhIEpTT05cbiAgICogZmlsZSBpbiB0aGVpciBwbGFjZS5cbiAgICpcbiAgICogTm90ZTogVVJMcyBmb3IgYEZpbGVgIG9iamVjdHMgd2lsbCByZXRhaW4gZmlsZSBuYW1lcyBlLmcuIGluIGNhc2Ugb2ZcbiAgICogYG5ldyBGaWxlKFtieXRlc10sICdjYXQucG5nJywgeyB0eXBlOiAnaW1hZ2UvcG5nJyB9KWAgd2lsbCBiZSB0cmFuc2Zvcm1lZFxuICAgKiBpbnRvIGEgVVJMIHRoYXQgbG9va3MgbGlrZSBgaXBmczovL2JhZnkuLi5oYXNoL2ltYWdlL2NhdC5wbmdgLiBGb3IgYEJsb2JgXG4gICAqIG9iamVjdHMsIHRoZSBVUkwgd2lsbCBub3QgaGF2ZSBhIGZpbGUgbmFtZSBuYW1lIG9yIG1pbWUgdHlwZSwgaW5zdGVhZCBpdFxuICAgKiB3aWxsIGJlIHRyYW5zZm9ybWVkIGludG8gYSBVUkwgdGhhdCBsb29rcyBsaWtlXG4gICAqIGBpcGZzOi8vYmFmeS4uLmhhc2gvaW1hZ2UvYmxvYmAuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IG1ldGFkYXRhID0gYXdhaXQgY2xpZW50LnN0b3JlKHtcbiAgICogICBuYW1lOiAnbmZ0LnN0b3JhZ2Ugc3RvcmUgdGVzdCcsXG4gICAqICAgZGVzY3JpcHRpb246ICdUZXN0IEVSQy0xMTU1IGNvbXBhdGlibGUgbWV0YWRhdGEuJyxcbiAgICogICBpbWFnZTogbmV3IEZpbGUoWyc8REFUQT4nXSwgJ3BpbnBpZS5qcGcnLCB7IHR5cGU6ICdpbWFnZS9qcGcnIH0pLFxuICAgKiAgIHByb3BlcnRpZXM6IHtcbiAgICogICAgIGN1c3RvbTogJ0N1c3RvbSBkYXRhIGNhbiBhcHBlYXIgaGVyZSwgZmlsZXMgYXJlIGF1dG8gdXBsb2FkZWQuJyxcbiAgICogICAgIGZpbGU6IG5ldyBGaWxlKFsnPERBVEE+J10sICdSRUFETUUubWQnLCB7IHR5cGU6ICd0ZXh0L3BsYWluJyB9KSxcbiAgICogICB9XG4gICAqIH0pXG4gICAqXG4gICAqIGNvbnNvbGUubG9nKCdJUEZTIFVSTCBmb3IgdGhlIG1ldGFkYXRhOicsIG1ldGFkYXRhLnVybClcbiAgICogY29uc29sZS5sb2coJ21ldGFkYXRhLmpzb24gY29udGVudHM6XFxuJywgbWV0YWRhdGEuZGF0YSlcbiAgICogY29uc29sZS5sb2coJ21ldGFkYXRhLmpzb24gd2l0aCBJUEZTIGdhdGV3YXkgVVJMczpcXG4nLCBtZXRhZGF0YS5lbWJlZCgpKVxuICAgKiBgYGBcbiAgICpcbiAgICogQHRlbXBsYXRlIHtpbXBvcnQoJy4vbGliL2ludGVyZmFjZS5qcycpLlRva2VuSW5wdXR9IFRcbiAgICogQHBhcmFtIHtUfSB0b2tlblxuICAgKiBAcGFyYW0ge1JlcXVlc3RPcHRpb25zfSBbb3B0aW9uc11cbiAgICovXG4gIHN0b3JlKHRva2VuLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIE5GVFN0b3JhZ2Uuc3RvcmUodGhpcywgdG9rZW4sIG9wdGlvbnMpXG4gIH1cbn1cblxuLyoqXG4gKiBDYXN0IGFuIGl0ZXJhYmxlIHRvIGFuIGFzeW5jSXRlcmFibGVcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge0l0ZXJhYmxlPFQ+fSBpdGVyYWJsZVxuICogQHJldHVybnMge0FzeW5jSXRlcmFibGU8VD59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0FzeW5jSXRlcmFibGUoaXRlcmFibGUpIHtcbiAgcmV0dXJuIChhc3luYyBmdW5jdGlvbiogKCkge1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBpdGVyYWJsZSkge1xuICAgICAgeWllbGQgaXRlbVxuICAgIH1cbiAgfSkoKVxufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSB7aW1wb3J0KCcuL2xpYi9pbnRlcmZhY2UuanMnKS5Ub2tlbklucHV0fSBUXG4gKiBAcGFyYW0ge1R9IG1ldGFkYXRhXG4gKi9cbmNvbnN0IHZhbGlkYXRlRVJDMTE1NSA9ICh7IG5hbWUsIGRlc2NyaXB0aW9uLCBpbWFnZSwgZGVjaW1hbHMgfSkgPT4ge1xuICAvLyBKdXN0IHZhbGlkYXRlIHRoYXQgZXhwZWN0ZWQgZmllbGRzIGFyZSBwcmVzZW50XG4gIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ3N0cmluZyBwcm9wZXJ0eSBgbmFtZWAgaWRlbnRpZnlpbmcgdGhlIGFzc2V0IGlzIHJlcXVpcmVkJ1xuICAgIClcbiAgfVxuICBpZiAodHlwZW9mIGRlc2NyaXB0aW9uICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnc3RyaW5nIHByb3BlcnR5IGBkZXNjcmlwdGlvbmAgZGVzY3JpYmluZyBhc3NldCBpcyByZXF1aXJlZCdcbiAgICApXG4gIH1cbiAgaWYgKCEoaW1hZ2UgaW5zdGFuY2VvZiBCbG9iKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3Byb3BlcnR5IGBpbWFnZWAgbXVzdCBiZSBhIEJsb2Igb3IgRmlsZSBvYmplY3QnKVxuICB9IGVsc2UgaWYgKCFpbWFnZS50eXBlLnN0YXJ0c1dpdGgoJ2ltYWdlLycpKSB7XG4gICAgY29uc29sZS53YXJuKGBBY2NvcmRpbmcgdG8gRVJDNzIxIE1ldGFkYXRhIEpTT04gU2NoZW1hICdpbWFnZScgbXVzdCBoYXZlICdpbWFnZS8qJyBtaW1lIHR5cGUuXG5cbkZvciBiZXR0ZXIgaW50ZXJvcGVyYWJpbGl0eSB3ZSB3b3VsZCBoaWdobHkgcmVjb21tZW5kIHN0b3JpbmcgY29udGVudCB3aXRoIGRpZmZlcmVudCBtaW1lIHR5cGUgdW5kZXIgJ3Byb3BlcnRpZXMnIG5hbWVzcGFjZSBlLmcuIFxcYHByb3BlcnRpZXM6IHsgdmlkZW86IGZpbGUgfVxcYCBhbmQgdXNpbmcgJ2ltYWdlJyBmaWVsZCBmb3Igc3RvcmluZyBhIHByZXZpZXcgaW1hZ2UgZm9yIGl0IGluc3RlYWQuXG5cbkZvciBtb3JlIGNvbnRleHQgcGxlYXNlIHNlZSBFUkMtNzIxIHNwZWNpZmljYXRpb24gaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC03MjFgKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBkZWNpbWFscyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRlY2ltYWxzICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3Byb3BlcnR5IGBkZWNpbWFsc2AgbXVzdCBiZSBhbiBpbnRlZ2VyIHZhbHVlJylcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCdpcGZzLWNhci9wYWNrJykuSW1wb3J0Q2FuZGlkYXRlU3RyZWFtfEFycmF5PHsgcGF0aDogc3RyaW5nLCBjb250ZW50OiBpbXBvcnQoJy4vcGxhdGZvcm0uanMnKS5SZWFkYWJsZVN0cmVhbSB9Pn0gaW5wdXRcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7QmxvY2tzdG9yZUl9IFtvcHRpb25zLmJsb2Nrc3RvcmVdXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLndyYXBXaXRoRGlyZWN0b3J5XVxuICovXG5jb25zdCBwYWNrQ2FyID0gYXN5bmMgKGlucHV0LCB7IGJsb2Nrc3RvcmUsIHdyYXBXaXRoRGlyZWN0b3J5IH0gPSB7fSkgPT4ge1xuICAvKiBjOCBpZ25vcmUgbmV4dCAxICovXG4gIGJsb2Nrc3RvcmUgPSBibG9ja3N0b3JlIHx8IG5ldyBCbG9ja3N0b3JlKClcbiAgY29uc3QgeyByb290OiBjaWQgfSA9IGF3YWl0IHBhY2soeyBpbnB1dCwgYmxvY2tzdG9yZSwgd3JhcFdpdGhEaXJlY3RvcnkgfSlcbiAgY29uc3QgY2FyID0gbmV3IEJsb2Nrc3RvcmVDYXJSZWFkZXIoMSwgW2NpZF0sIGJsb2Nrc3RvcmUpXG4gIHJldHVybiB7IGNpZCwgY2FyIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0RlYWxbXX0gZGVhbHNcbiAqIEByZXR1cm5zIHtEZWFsW119XG4gKi9cbmNvbnN0IGRlY29kZURlYWxzID0gKGRlYWxzKSA9PlxuICBkZWFscy5tYXAoKGRlYWwpID0+IHtcbiAgICBjb25zdCB7IGRlYWxBY3RpdmF0aW9uLCBkZWFsRXhwaXJhdGlvbiwgbGFzdENoYW5nZWQgfSA9IHtcbiAgICAgIGRlYWxFeHBpcmF0aW9uOiBudWxsLFxuICAgICAgZGVhbEFjdGl2YXRpb246IG51bGwsXG4gICAgICAuLi5kZWFsLFxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAuLi5kZWFsLFxuICAgICAgbGFzdENoYW5nZWQ6IG5ldyBEYXRlKGxhc3RDaGFuZ2VkKSxcbiAgICAgIC4uLihkZWFsQWN0aXZhdGlvbiAmJiB7IGRlYWxBY3RpdmF0aW9uOiBuZXcgRGF0ZShkZWFsQWN0aXZhdGlvbikgfSksXG4gICAgICAuLi4oZGVhbEV4cGlyYXRpb24gJiYgeyBkZWFsRXhwaXJhdGlvbjogbmV3IERhdGUoZGVhbEV4cGlyYXRpb24pIH0pLFxuICAgIH1cbiAgfSlcblxuLyoqXG4gKiBAcGFyYW0ge1Bpbn0gcGluXG4gKiBAcmV0dXJucyB7UGlufVxuICovXG5jb25zdCBkZWNvZGVQaW4gPSAocGluKSA9PiAoeyAuLi5waW4sIGNyZWF0ZWQ6IG5ldyBEYXRlKHBpbi5jcmVhdGVkKSB9KVxuXG4vKipcbiAqIENvbnZlcnQgdGhlIHBhc3NlZCBibG9iIHRvIGFuIFwiaW1wb3J0IGNhbmRpZGF0ZVwiIC0gYW4gb2JqZWN0IHN1aXRhYmxlIGZvclxuICogcGFzc2luZyB0byB0aGUgaXBmcy11bml4ZnMtaW1wb3J0ZXIuIE5vdGU6IGNvbnRlbnQgaXMgYW4gYWNjZXNzb3Igc28gdGhhdFxuICogdGhlIHN0cmVhbSBpcyBjcmVhdGVkIG9ubHkgd2hlbiBuZWVkZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGhcbiAqIEBwYXJhbSB7UGljazxCbG9iLCAnc3RyZWFtJz58eyBzdHJlYW06ICgpID0+IEFzeW5jSXRlcmFibGU8VWludDhBcnJheT4gfX0gYmxvYlxuICogQHJldHVybnMge2ltcG9ydCgnaXBmcy1jb3JlLXR5cGVzL3NyYy91dGlscy5qcycpLkltcG9ydENhbmRpZGF0ZX1cbiAqL1xuZnVuY3Rpb24gdG9JbXBvcnRDYW5kaWRhdGUocGF0aCwgYmxvYikge1xuICAvKiogQHR5cGUge0FzeW5jSXRlcmFibGU8VWludDhBcnJheT59ICovXG4gIGxldCBzdHJlYW1cbiAgcmV0dXJuIHtcbiAgICBwYXRoLFxuICAgIGdldCBjb250ZW50KCkge1xuICAgICAgc3RyZWFtID0gc3RyZWFtIHx8IGJsb2Iuc3RyZWFtKClcbiAgICAgIHJldHVybiBzdHJlYW1cbiAgICB9LFxuICB9XG59XG5cbmV4cG9ydCB7IE5GVFN0b3JhZ2UsIEZpbGUsIEJsb2IsIEZvcm1EYXRhLCB0b0dhdGV3YXlVUkwsIFRva2VuIH1cbiIsICJpbXBvcnQgZnMgZnJvbSAnZnMnO1xuaW1wb3J0IHsgcHJvbWlzaWZ5IH0gZnJvbSAndXRpbCc7XG5pbXBvcnQgeyBDYXJSZWFkZXIgYXMgQnJvd3NlckNhclJlYWRlciB9IGZyb20gJy4vcmVhZGVyLWJyb3dzZXIuanMnO1xuY29uc3QgZnNyZWFkID0gcHJvbWlzaWZ5KGZzLnJlYWQpO1xuZXhwb3J0IGNsYXNzIENhclJlYWRlciBleHRlbmRzIEJyb3dzZXJDYXJSZWFkZXIge1xuICBzdGF0aWMgYXN5bmMgcmVhZFJhdyhmZCwgYmxvY2tJbmRleCkge1xuICAgIGNvbnN0IHtjaWQsIGJsb2NrTGVuZ3RoLCBibG9ja09mZnNldH0gPSBibG9ja0luZGV4O1xuICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYmxvY2tMZW5ndGgpO1xuICAgIGxldCByZWFkO1xuICAgIGlmICh0eXBlb2YgZmQgPT09ICdudW1iZXInKSB7XG4gICAgICByZWFkID0gKGF3YWl0IGZzcmVhZChmZCwgYnl0ZXMsIDAsIGJsb2NrTGVuZ3RoLCBibG9ja09mZnNldCkpLmJ5dGVzUmVhZDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBmZCA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGZkLnJlYWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJlYWQgPSAoYXdhaXQgZmQucmVhZChieXRlcywgMCwgYmxvY2tMZW5ndGgsIGJsb2NrT2Zmc2V0KSkuYnl0ZXNSZWFkO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCYWQgZmQnKTtcbiAgICB9XG4gICAgaWYgKHJlYWQgIT09IGJsb2NrTGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byByZWFkIGVudGlyZSBibG9jayAoJHsgcmVhZCB9IGluc3RlYWQgb2YgJHsgYmxvY2tMZW5ndGggfSlgKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGNpZCxcbiAgICAgIGJ5dGVzXG4gICAgfTtcbiAgfVxufVxuZXhwb3J0IGNvbnN0IF9fYnJvd3NlciA9IGZhbHNlOyIsICJpbXBvcnQgdmFyaW50IGZyb20gJ3ZhcmludCc7XG5pbXBvcnQgeyBDSUQgfSBmcm9tICdtdWx0aWZvcm1hdHMvY2lkJztcbmltcG9ydCAqIGFzIERpZ2VzdCBmcm9tICdtdWx0aWZvcm1hdHMvaGFzaGVzL2RpZ2VzdCc7XG5pbXBvcnQgeyBkZWNvZGUgYXMgZGVjb2RlRGFnQ2JvciB9IGZyb20gJ0BpcGxkL2RhZy1jYm9yJztcbmNvbnN0IENJRFYwX0JZVEVTID0ge1xuICBTSEEyXzI1NjogMTgsXG4gIExFTkdUSDogMzIsXG4gIERBR19QQjogMTEyXG59O1xuYXN5bmMgZnVuY3Rpb24gcmVhZFZhcmludChyZWFkZXIpIHtcbiAgY29uc3QgYnl0ZXMgPSBhd2FpdCByZWFkZXIudXBUbyg4KTtcbiAgY29uc3QgaSA9IHZhcmludC5kZWNvZGUoYnl0ZXMpO1xuICByZWFkZXIuc2Vlayh2YXJpbnQuZGVjb2RlLmJ5dGVzKTtcbiAgcmV0dXJuIGk7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVhZEhlYWRlcihyZWFkZXIpIHtcbiAgY29uc3QgbGVuZ3RoID0gYXdhaXQgcmVhZFZhcmludChyZWFkZXIpO1xuICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIENBUiBoZWFkZXIgKHplcm8gbGVuZ3RoKScpO1xuICB9XG4gIGNvbnN0IGhlYWRlciA9IGF3YWl0IHJlYWRlci5leGFjdGx5KGxlbmd0aCk7XG4gIHJlYWRlci5zZWVrKGxlbmd0aCk7XG4gIGNvbnN0IGJsb2NrID0gZGVjb2RlRGFnQ2JvcihoZWFkZXIpO1xuICBpZiAoYmxvY2sgPT0gbnVsbCB8fCBBcnJheS5pc0FycmF5KGJsb2NrKSB8fCB0eXBlb2YgYmxvY2sgIT09ICdvYmplY3QnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIENBUiBoZWFkZXIgZm9ybWF0Jyk7XG4gIH1cbiAgaWYgKGJsb2NrLnZlcnNpb24gIT09IDEpIHtcbiAgICBpZiAodHlwZW9mIGJsb2NrLnZlcnNpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgQ0FSIHZlcnNpb246IFwiJHsgYmxvY2sudmVyc2lvbiB9XCJgKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIENBUiB2ZXJzaW9uOiAkeyBibG9jay52ZXJzaW9uIH1gKTtcbiAgfVxuICBpZiAoIUFycmF5LmlzQXJyYXkoYmxvY2sucm9vdHMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIENBUiBoZWFkZXIgZm9ybWF0Jyk7XG4gIH1cbiAgaWYgKE9iamVjdC5rZXlzKGJsb2NrKS5maWx0ZXIocCA9PiBwICE9PSAncm9vdHMnICYmIHAgIT09ICd2ZXJzaW9uJykubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIENBUiBoZWFkZXIgZm9ybWF0Jyk7XG4gIH1cbiAgcmV0dXJuIGJsb2NrO1xufVxuYXN5bmMgZnVuY3Rpb24gcmVhZE11bHRpaGFzaChyZWFkZXIpIHtcbiAgY29uc3QgYnl0ZXMgPSBhd2FpdCByZWFkZXIudXBUbyg4KTtcbiAgdmFyaW50LmRlY29kZShieXRlcyk7XG4gIGNvbnN0IGNvZGVMZW5ndGggPSB2YXJpbnQuZGVjb2RlLmJ5dGVzO1xuICBjb25zdCBsZW5ndGggPSB2YXJpbnQuZGVjb2RlKGJ5dGVzLnN1YmFycmF5KHZhcmludC5kZWNvZGUuYnl0ZXMpKTtcbiAgY29uc3QgbGVuZ3RoTGVuZ3RoID0gdmFyaW50LmRlY29kZS5ieXRlcztcbiAgY29uc3QgbWhMZW5ndGggPSBjb2RlTGVuZ3RoICsgbGVuZ3RoTGVuZ3RoICsgbGVuZ3RoO1xuICBjb25zdCBtdWx0aWhhc2ggPSBhd2FpdCByZWFkZXIuZXhhY3RseShtaExlbmd0aCk7XG4gIHJlYWRlci5zZWVrKG1oTGVuZ3RoKTtcbiAgcmV0dXJuIG11bHRpaGFzaDtcbn1cbmFzeW5jIGZ1bmN0aW9uIHJlYWRDaWQocmVhZGVyKSB7XG4gIGNvbnN0IGZpcnN0ID0gYXdhaXQgcmVhZGVyLmV4YWN0bHkoMik7XG4gIGlmIChmaXJzdFswXSA9PT0gQ0lEVjBfQllURVMuU0hBMl8yNTYgJiYgZmlyc3RbMV0gPT09IENJRFYwX0JZVEVTLkxFTkdUSCkge1xuICAgIGNvbnN0IGJ5dGVzID0gYXdhaXQgcmVhZGVyLmV4YWN0bHkoMzQpO1xuICAgIHJlYWRlci5zZWVrKDM0KTtcbiAgICBjb25zdCBtdWx0aWhhc2ggPSBEaWdlc3QuZGVjb2RlKGJ5dGVzKTtcbiAgICByZXR1cm4gQ0lELmNyZWF0ZSgwLCBDSURWMF9CWVRFUy5EQUdfUEIsIG11bHRpaGFzaCk7XG4gIH1cbiAgY29uc3QgdmVyc2lvbiA9IGF3YWl0IHJlYWRWYXJpbnQocmVhZGVyKTtcbiAgaWYgKHZlcnNpb24gIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgQ0lEIHZlcnNpb24gKCR7IHZlcnNpb24gfSlgKTtcbiAgfVxuICBjb25zdCBjb2RlYyA9IGF3YWl0IHJlYWRWYXJpbnQocmVhZGVyKTtcbiAgY29uc3QgYnl0ZXMgPSBhd2FpdCByZWFkTXVsdGloYXNoKHJlYWRlcik7XG4gIGNvbnN0IG11bHRpaGFzaCA9IERpZ2VzdC5kZWNvZGUoYnl0ZXMpO1xuICByZXR1cm4gQ0lELmNyZWF0ZSh2ZXJzaW9uLCBjb2RlYywgbXVsdGloYXNoKTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZWFkQmxvY2tIZWFkKHJlYWRlcikge1xuICBjb25zdCBzdGFydCA9IHJlYWRlci5wb3M7XG4gIGxldCBsZW5ndGggPSBhd2FpdCByZWFkVmFyaW50KHJlYWRlcik7XG4gIGlmIChsZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgQ0FSIHNlY3Rpb24gKHplcm8gbGVuZ3RoKScpO1xuICB9XG4gIGxlbmd0aCArPSByZWFkZXIucG9zIC0gc3RhcnQ7XG4gIGNvbnN0IGNpZCA9IGF3YWl0IHJlYWRDaWQocmVhZGVyKTtcbiAgY29uc3QgYmxvY2tMZW5ndGggPSBsZW5ndGggLSAocmVhZGVyLnBvcyAtIHN0YXJ0KTtcbiAgcmV0dXJuIHtcbiAgICBjaWQsXG4gICAgbGVuZ3RoLFxuICAgIGJsb2NrTGVuZ3RoXG4gIH07XG59XG5hc3luYyBmdW5jdGlvbiByZWFkQmxvY2socmVhZGVyKSB7XG4gIGNvbnN0IHtjaWQsIGJsb2NrTGVuZ3RofSA9IGF3YWl0IHJlYWRCbG9ja0hlYWQocmVhZGVyKTtcbiAgY29uc3QgYnl0ZXMgPSBhd2FpdCByZWFkZXIuZXhhY3RseShibG9ja0xlbmd0aCk7XG4gIHJlYWRlci5zZWVrKGJsb2NrTGVuZ3RoKTtcbiAgcmV0dXJuIHtcbiAgICBieXRlcyxcbiAgICBjaWRcbiAgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHJlYWRCbG9ja0luZGV4KHJlYWRlcikge1xuICBjb25zdCBvZmZzZXQgPSByZWFkZXIucG9zO1xuICBjb25zdCB7Y2lkLCBsZW5ndGgsIGJsb2NrTGVuZ3RofSA9IGF3YWl0IHJlYWRCbG9ja0hlYWQocmVhZGVyKTtcbiAgY29uc3QgaW5kZXggPSB7XG4gICAgY2lkLFxuICAgIGxlbmd0aCxcbiAgICBibG9ja0xlbmd0aCxcbiAgICBvZmZzZXQsXG4gICAgYmxvY2tPZmZzZXQ6IHJlYWRlci5wb3NcbiAgfTtcbiAgcmVhZGVyLnNlZWsoaW5kZXguYmxvY2tMZW5ndGgpO1xuICByZXR1cm4gaW5kZXg7XG59XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRGVjb2RlcihyZWFkZXIpIHtcbiAgY29uc3QgaGVhZGVyUHJvbWlzZSA9IHJlYWRIZWFkZXIocmVhZGVyKTtcbiAgcmV0dXJuIHtcbiAgICBoZWFkZXI6ICgpID0+IGhlYWRlclByb21pc2UsXG4gICAgYXN5bmMgKmJsb2NrcygpIHtcbiAgICAgIGF3YWl0IGhlYWRlclByb21pc2U7XG4gICAgICB3aGlsZSAoKGF3YWl0IHJlYWRlci51cFRvKDgpKS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHlpZWxkIGF3YWl0IHJlYWRCbG9jayhyZWFkZXIpO1xuICAgICAgfVxuICAgIH0sXG4gICAgYXN5bmMgKmJsb2Nrc0luZGV4KCkge1xuICAgICAgYXdhaXQgaGVhZGVyUHJvbWlzZTtcbiAgICAgIHdoaWxlICgoYXdhaXQgcmVhZGVyLnVwVG8oOCkpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgeWllbGQgYXdhaXQgcmVhZEJsb2NrSW5kZXgocmVhZGVyKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5leHBvcnQgZnVuY3Rpb24gYnl0ZXNSZWFkZXIoYnl0ZXMpIHtcbiAgbGV0IHBvcyA9IDA7XG4gIHJldHVybiB7XG4gICAgYXN5bmMgdXBUbyhsZW5ndGgpIHtcbiAgICAgIHJldHVybiBieXRlcy5zdWJhcnJheShwb3MsIHBvcyArIE1hdGgubWluKGxlbmd0aCwgYnl0ZXMubGVuZ3RoIC0gcG9zKSk7XG4gICAgfSxcbiAgICBhc3luYyBleGFjdGx5KGxlbmd0aCkge1xuICAgICAgaWYgKGxlbmd0aCA+IGJ5dGVzLmxlbmd0aCAtIHBvcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgZW5kIG9mIGRhdGEnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBieXRlcy5zdWJhcnJheShwb3MsIHBvcyArIGxlbmd0aCk7XG4gICAgfSxcbiAgICBzZWVrKGxlbmd0aCkge1xuICAgICAgcG9zICs9IGxlbmd0aDtcbiAgICB9LFxuICAgIGdldCBwb3MoKSB7XG4gICAgICByZXR1cm4gcG9zO1xuICAgIH1cbiAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjaHVua1JlYWRlcihyZWFkQ2h1bmspIHtcbiAgbGV0IHBvcyA9IDA7XG4gIGxldCBoYXZlID0gMDtcbiAgbGV0IG9mZnNldCA9IDA7XG4gIGxldCBjdXJyZW50Q2h1bmsgPSBuZXcgVWludDhBcnJheSgwKTtcbiAgY29uc3QgcmVhZCA9IGFzeW5jIGxlbmd0aCA9PiB7XG4gICAgaGF2ZSA9IGN1cnJlbnRDaHVuay5sZW5ndGggLSBvZmZzZXQ7XG4gICAgY29uc3QgYnVmYSA9IFtjdXJyZW50Q2h1bmsuc3ViYXJyYXkob2Zmc2V0KV07XG4gICAgd2hpbGUgKGhhdmUgPCBsZW5ndGgpIHtcbiAgICAgIGNvbnN0IGNodW5rID0gYXdhaXQgcmVhZENodW5rKCk7XG4gICAgICBpZiAoY2h1bmsgPT0gbnVsbCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChoYXZlIDwgMCkge1xuICAgICAgICBpZiAoY2h1bmsubGVuZ3RoID4gaGF2ZSkge1xuICAgICAgICAgIGJ1ZmEucHVzaChjaHVuay5zdWJhcnJheSgtaGF2ZSkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBidWZhLnB1c2goY2h1bmspO1xuICAgICAgfVxuICAgICAgaGF2ZSArPSBjaHVuay5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRDaHVuayA9IG5ldyBVaW50OEFycmF5KGJ1ZmEucmVkdWNlKChwLCBjKSA9PiBwICsgYy5sZW5ndGgsIDApKTtcbiAgICBsZXQgb2ZmID0gMDtcbiAgICBmb3IgKGNvbnN0IGIgb2YgYnVmYSkge1xuICAgICAgY3VycmVudENodW5rLnNldChiLCBvZmYpO1xuICAgICAgb2ZmICs9IGIubGVuZ3RoO1xuICAgIH1cbiAgICBvZmZzZXQgPSAwO1xuICB9O1xuICByZXR1cm4ge1xuICAgIGFzeW5jIHVwVG8obGVuZ3RoKSB7XG4gICAgICBpZiAoY3VycmVudENodW5rLmxlbmd0aCAtIG9mZnNldCA8IGxlbmd0aCkge1xuICAgICAgICBhd2FpdCByZWFkKGxlbmd0aCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY3VycmVudENodW5rLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgTWF0aC5taW4oY3VycmVudENodW5rLmxlbmd0aCAtIG9mZnNldCwgbGVuZ3RoKSk7XG4gICAgfSxcbiAgICBhc3luYyBleGFjdGx5KGxlbmd0aCkge1xuICAgICAgaWYgKGN1cnJlbnRDaHVuay5sZW5ndGggLSBvZmZzZXQgPCBsZW5ndGgpIHtcbiAgICAgICAgYXdhaXQgcmVhZChsZW5ndGgpO1xuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnRDaHVuay5sZW5ndGggLSBvZmZzZXQgPCBsZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIGVuZCBvZiBkYXRhJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY3VycmVudENodW5rLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgbGVuZ3RoKTtcbiAgICB9LFxuICAgIHNlZWsobGVuZ3RoKSB7XG4gICAgICBwb3MgKz0gbGVuZ3RoO1xuICAgICAgb2Zmc2V0ICs9IGxlbmd0aDtcbiAgICB9LFxuICAgIGdldCBwb3MoKSB7XG4gICAgICByZXR1cm4gcG9zO1xuICAgIH1cbiAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBhc3luY0l0ZXJhYmxlUmVhZGVyKGFzeW5jSXRlcmFibGUpIHtcbiAgY29uc3QgaXRlcmF0b3IgPSBhc3luY0l0ZXJhYmxlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpO1xuICBhc3luYyBmdW5jdGlvbiByZWFkQ2h1bmsoKSB7XG4gICAgY29uc3QgbmV4dCA9IGF3YWl0IGl0ZXJhdG9yLm5leHQoKTtcbiAgICBpZiAobmV4dC5kb25lKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIG5leHQudmFsdWU7XG4gIH1cbiAgcmV0dXJuIGNodW5rUmVhZGVyKHJlYWRDaHVuayk7XG59IiwgInZhciBlbmNvZGVfMSA9IGVuY29kZTtcbnZhciBNU0IgPSAxMjgsIFJFU1QgPSAxMjcsIE1TQkFMTCA9IH5SRVNULCBJTlQgPSBNYXRoLnBvdygyLCAzMSk7XG5mdW5jdGlvbiBlbmNvZGUobnVtLCBvdXQsIG9mZnNldCkge1xuICBvdXQgPSBvdXQgfHwgW107XG4gIG9mZnNldCA9IG9mZnNldCB8fCAwO1xuICB2YXIgb2xkT2Zmc2V0ID0gb2Zmc2V0O1xuICB3aGlsZSAobnVtID49IElOVCkge1xuICAgIG91dFtvZmZzZXQrK10gPSBudW0gJiAyNTUgfCBNU0I7XG4gICAgbnVtIC89IDEyODtcbiAgfVxuICB3aGlsZSAobnVtICYgTVNCQUxMKSB7XG4gICAgb3V0W29mZnNldCsrXSA9IG51bSAmIDI1NSB8IE1TQjtcbiAgICBudW0gPj4+PSA3O1xuICB9XG4gIG91dFtvZmZzZXRdID0gbnVtIHwgMDtcbiAgZW5jb2RlLmJ5dGVzID0gb2Zmc2V0IC0gb2xkT2Zmc2V0ICsgMTtcbiAgcmV0dXJuIG91dDtcbn1cbnZhciBkZWNvZGUgPSByZWFkO1xudmFyIE1TQiQxID0gMTI4LCBSRVNUJDEgPSAxMjc7XG5mdW5jdGlvbiByZWFkKGJ1Ziwgb2Zmc2V0KSB7XG4gIHZhciByZXMgPSAwLCBvZmZzZXQgPSBvZmZzZXQgfHwgMCwgc2hpZnQgPSAwLCBjb3VudGVyID0gb2Zmc2V0LCBiLCBsID0gYnVmLmxlbmd0aDtcbiAgZG8ge1xuICAgIGlmIChjb3VudGVyID49IGwpIHtcbiAgICAgIHJlYWQuYnl0ZXMgPSAwO1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0NvdWxkIG5vdCBkZWNvZGUgdmFyaW50Jyk7XG4gICAgfVxuICAgIGIgPSBidWZbY291bnRlcisrXTtcbiAgICByZXMgKz0gc2hpZnQgPCAyOCA/IChiICYgUkVTVCQxKSA8PCBzaGlmdCA6IChiICYgUkVTVCQxKSAqIE1hdGgucG93KDIsIHNoaWZ0KTtcbiAgICBzaGlmdCArPSA3O1xuICB9IHdoaWxlIChiID49IE1TQiQxKTtcbiAgcmVhZC5ieXRlcyA9IGNvdW50ZXIgLSBvZmZzZXQ7XG4gIHJldHVybiByZXM7XG59XG52YXIgTjEgPSBNYXRoLnBvdygyLCA3KTtcbnZhciBOMiA9IE1hdGgucG93KDIsIDE0KTtcbnZhciBOMyA9IE1hdGgucG93KDIsIDIxKTtcbnZhciBONCA9IE1hdGgucG93KDIsIDI4KTtcbnZhciBONSA9IE1hdGgucG93KDIsIDM1KTtcbnZhciBONiA9IE1hdGgucG93KDIsIDQyKTtcbnZhciBONyA9IE1hdGgucG93KDIsIDQ5KTtcbnZhciBOOCA9IE1hdGgucG93KDIsIDU2KTtcbnZhciBOOSA9IE1hdGgucG93KDIsIDYzKTtcbnZhciBsZW5ndGggPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlIDwgTjEgPyAxIDogdmFsdWUgPCBOMiA/IDIgOiB2YWx1ZSA8IE4zID8gMyA6IHZhbHVlIDwgTjQgPyA0IDogdmFsdWUgPCBONSA/IDUgOiB2YWx1ZSA8IE42ID8gNiA6IHZhbHVlIDwgTjcgPyA3IDogdmFsdWUgPCBOOCA/IDggOiB2YWx1ZSA8IE45ID8gOSA6IDEwO1xufTtcbnZhciB2YXJpbnQgPSB7XG4gIGVuY29kZTogZW5jb2RlXzEsXG4gIGRlY29kZTogZGVjb2RlLFxuICBlbmNvZGluZ0xlbmd0aDogbGVuZ3RoXG59O1xudmFyIF9icnJwX3ZhcmludCA9IHZhcmludDtcbmV4cG9ydCBkZWZhdWx0IF9icnJwX3ZhcmludDsiLCAiaW1wb3J0IHZhcmludCBmcm9tICcuLi92ZW5kb3IvdmFyaW50LmpzJztcbmV4cG9ydCBjb25zdCBkZWNvZGUgPSAoZGF0YSwgb2Zmc2V0ID0gMCkgPT4ge1xuICBjb25zdCBjb2RlID0gdmFyaW50LmRlY29kZShkYXRhLCBvZmZzZXQpO1xuICByZXR1cm4gW1xuICAgIGNvZGUsXG4gICAgdmFyaW50LmRlY29kZS5ieXRlc1xuICBdO1xufTtcbmV4cG9ydCBjb25zdCBlbmNvZGVUbyA9IChpbnQsIHRhcmdldCwgb2Zmc2V0ID0gMCkgPT4ge1xuICB2YXJpbnQuZW5jb2RlKGludCwgdGFyZ2V0LCBvZmZzZXQpO1xuICByZXR1cm4gdGFyZ2V0O1xufTtcbmV4cG9ydCBjb25zdCBlbmNvZGluZ0xlbmd0aCA9IGludCA9PiB7XG4gIHJldHVybiB2YXJpbnQuZW5jb2RpbmdMZW5ndGgoaW50KTtcbn07IiwgImNvbnN0IGVtcHR5ID0gbmV3IFVpbnQ4QXJyYXkoMCk7XG5jb25zdCB0b0hleCA9IGQgPT4gZC5yZWR1Y2UoKGhleCwgYnl0ZSkgPT4gaGV4ICsgYnl0ZS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSwgJycpO1xuY29uc3QgZnJvbUhleCA9IGhleCA9PiB7XG4gIGNvbnN0IGhleGVzID0gaGV4Lm1hdGNoKC8uLi9nKTtcbiAgcmV0dXJuIGhleGVzID8gbmV3IFVpbnQ4QXJyYXkoaGV4ZXMubWFwKGIgPT4gcGFyc2VJbnQoYiwgMTYpKSkgOiBlbXB0eTtcbn07XG5jb25zdCBlcXVhbHMgPSAoYWEsIGJiKSA9PiB7XG4gIGlmIChhYSA9PT0gYmIpXG4gICAgcmV0dXJuIHRydWU7XG4gIGlmIChhYS5ieXRlTGVuZ3RoICE9PSBiYi5ieXRlTGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAobGV0IGlpID0gMDsgaWkgPCBhYS5ieXRlTGVuZ3RoOyBpaSsrKSB7XG4gICAgaWYgKGFhW2lpXSAhPT0gYmJbaWldKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufTtcbmNvbnN0IGNvZXJjZSA9IG8gPT4ge1xuICBpZiAobyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgJiYgby5jb25zdHJ1Y3Rvci5uYW1lID09PSAnVWludDhBcnJheScpXG4gICAgcmV0dXJuIG87XG4gIGlmIChvIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpXG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG8pO1xuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KG8pKSB7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG8uYnVmZmVyLCBvLmJ5dGVPZmZzZXQsIG8uYnl0ZUxlbmd0aCk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHR5cGUsIG11c3QgYmUgYmluYXJ5IHR5cGUnKTtcbn07XG5jb25zdCBpc0JpbmFyeSA9IG8gPT4gbyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8IEFycmF5QnVmZmVyLmlzVmlldyhvKTtcbmNvbnN0IGZyb21TdHJpbmcgPSBzdHIgPT4gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHN0cik7XG5jb25zdCB0b1N0cmluZyA9IGIgPT4gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGIpO1xuZXhwb3J0IHtcbiAgZXF1YWxzLFxuICBjb2VyY2UsXG4gIGlzQmluYXJ5LFxuICBmcm9tSGV4LFxuICB0b0hleCxcbiAgZnJvbVN0cmluZyxcbiAgdG9TdHJpbmcsXG4gIGVtcHR5XG59OyIsICJpbXBvcnQge1xuICBjb2VyY2UsXG4gIGVxdWFscyBhcyBlcXVhbEJ5dGVzXG59IGZyb20gJy4uL2J5dGVzLmpzJztcbmltcG9ydCAqIGFzIHZhcmludCBmcm9tICcuLi92YXJpbnQuanMnO1xuZXhwb3J0IGNvbnN0IGNyZWF0ZSA9IChjb2RlLCBkaWdlc3QpID0+IHtcbiAgY29uc3Qgc2l6ZSA9IGRpZ2VzdC5ieXRlTGVuZ3RoO1xuICBjb25zdCBzaXplT2Zmc2V0ID0gdmFyaW50LmVuY29kaW5nTGVuZ3RoKGNvZGUpO1xuICBjb25zdCBkaWdlc3RPZmZzZXQgPSBzaXplT2Zmc2V0ICsgdmFyaW50LmVuY29kaW5nTGVuZ3RoKHNpemUpO1xuICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGRpZ2VzdE9mZnNldCArIHNpemUpO1xuICB2YXJpbnQuZW5jb2RlVG8oY29kZSwgYnl0ZXMsIDApO1xuICB2YXJpbnQuZW5jb2RlVG8oc2l6ZSwgYnl0ZXMsIHNpemVPZmZzZXQpO1xuICBieXRlcy5zZXQoZGlnZXN0LCBkaWdlc3RPZmZzZXQpO1xuICByZXR1cm4gbmV3IERpZ2VzdChjb2RlLCBzaXplLCBkaWdlc3QsIGJ5dGVzKTtcbn07XG5leHBvcnQgY29uc3QgZGVjb2RlID0gbXVsdGloYXNoID0+IHtcbiAgY29uc3QgYnl0ZXMgPSBjb2VyY2UobXVsdGloYXNoKTtcbiAgY29uc3QgW2NvZGUsIHNpemVPZmZzZXRdID0gdmFyaW50LmRlY29kZShieXRlcyk7XG4gIGNvbnN0IFtzaXplLCBkaWdlc3RPZmZzZXRdID0gdmFyaW50LmRlY29kZShieXRlcy5zdWJhcnJheShzaXplT2Zmc2V0KSk7XG4gIGNvbnN0IGRpZ2VzdCA9IGJ5dGVzLnN1YmFycmF5KHNpemVPZmZzZXQgKyBkaWdlc3RPZmZzZXQpO1xuICBpZiAoZGlnZXN0LmJ5dGVMZW5ndGggIT09IHNpemUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0luY29ycmVjdCBsZW5ndGgnKTtcbiAgfVxuICByZXR1cm4gbmV3IERpZ2VzdChjb2RlLCBzaXplLCBkaWdlc3QsIGJ5dGVzKTtcbn07XG5leHBvcnQgY29uc3QgZXF1YWxzID0gKGEsIGIpID0+IHtcbiAgaWYgKGEgPT09IGIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYS5jb2RlID09PSBiLmNvZGUgJiYgYS5zaXplID09PSBiLnNpemUgJiYgZXF1YWxCeXRlcyhhLmJ5dGVzLCBiLmJ5dGVzKTtcbiAgfVxufTtcbmV4cG9ydCBjbGFzcyBEaWdlc3Qge1xuICBjb25zdHJ1Y3Rvcihjb2RlLCBzaXplLCBkaWdlc3QsIGJ5dGVzKSB7XG4gICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICB0aGlzLnNpemUgPSBzaXplO1xuICAgIHRoaXMuZGlnZXN0ID0gZGlnZXN0O1xuICAgIHRoaXMuYnl0ZXMgPSBieXRlcztcbiAgfVxufSIsICJpbXBvcnQgeyBiYXNlWCB9IGZyb20gJy4vYmFzZS5qcyc7XG5leHBvcnQgY29uc3QgYmFzZTU4YnRjID0gYmFzZVgoe1xuICBuYW1lOiAnYmFzZTU4YnRjJyxcbiAgcHJlZml4OiAneicsXG4gIGFscGhhYmV0OiAnMTIzNDU2Nzg5QUJDREVGR0hKS0xNTlBRUlNUVVZXWFlaYWJjZGVmZ2hpamttbm9wcXJzdHV2d3h5eidcbn0pO1xuZXhwb3J0IGNvbnN0IGJhc2U1OGZsaWNrciA9IGJhc2VYKHtcbiAgbmFtZTogJ2Jhc2U1OGZsaWNrcicsXG4gIHByZWZpeDogJ1onLFxuICBhbHBoYWJldDogJzEyMzQ1Njc4OWFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXpBQkNERUZHSEpLTE1OUFFSU1RVVldYWVonXG59KTsiLCAiZnVuY3Rpb24gYmFzZShBTFBIQUJFVCwgbmFtZSkge1xuICBpZiAoQUxQSEFCRVQubGVuZ3RoID49IDI1NSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FscGhhYmV0IHRvbyBsb25nJyk7XG4gIH1cbiAgdmFyIEJBU0VfTUFQID0gbmV3IFVpbnQ4QXJyYXkoMjU2KTtcbiAgZm9yICh2YXIgaiA9IDA7IGogPCBCQVNFX01BUC5sZW5ndGg7IGorKykge1xuICAgIEJBU0VfTUFQW2pdID0gMjU1O1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgQUxQSEFCRVQubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgeCA9IEFMUEhBQkVULmNoYXJBdChpKTtcbiAgICB2YXIgeGMgPSB4LmNoYXJDb2RlQXQoMCk7XG4gICAgaWYgKEJBU0VfTUFQW3hjXSAhPT0gMjU1KSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHggKyAnIGlzIGFtYmlndW91cycpO1xuICAgIH1cbiAgICBCQVNFX01BUFt4Y10gPSBpO1xuICB9XG4gIHZhciBCQVNFID0gQUxQSEFCRVQubGVuZ3RoO1xuICB2YXIgTEVBREVSID0gQUxQSEFCRVQuY2hhckF0KDApO1xuICB2YXIgRkFDVE9SID0gTWF0aC5sb2coQkFTRSkgLyBNYXRoLmxvZygyNTYpO1xuICB2YXIgaUZBQ1RPUiA9IE1hdGgubG9nKDI1NikgLyBNYXRoLmxvZyhCQVNFKTtcbiAgZnVuY3Rpb24gZW5jb2RlKHNvdXJjZSkge1xuICAgIGlmIChzb3VyY2UgaW5zdGFuY2VvZiBVaW50OEFycmF5KTtcbiAgICBlbHNlIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoc291cmNlKSkge1xuICAgICAgc291cmNlID0gbmV3IFVpbnQ4QXJyYXkoc291cmNlLmJ1ZmZlciwgc291cmNlLmJ5dGVPZmZzZXQsIHNvdXJjZS5ieXRlTGVuZ3RoKTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoc291cmNlKSkge1xuICAgICAgc291cmNlID0gVWludDhBcnJheS5mcm9tKHNvdXJjZSk7XG4gICAgfVxuICAgIGlmICghKHNvdXJjZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBVaW50OEFycmF5Jyk7XG4gICAgfVxuICAgIGlmIChzb3VyY2UubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHZhciB6ZXJvZXMgPSAwO1xuICAgIHZhciBsZW5ndGggPSAwO1xuICAgIHZhciBwYmVnaW4gPSAwO1xuICAgIHZhciBwZW5kID0gc291cmNlLmxlbmd0aDtcbiAgICB3aGlsZSAocGJlZ2luICE9PSBwZW5kICYmIHNvdXJjZVtwYmVnaW5dID09PSAwKSB7XG4gICAgICBwYmVnaW4rKztcbiAgICAgIHplcm9lcysrO1xuICAgIH1cbiAgICB2YXIgc2l6ZSA9IChwZW5kIC0gcGJlZ2luKSAqIGlGQUNUT1IgKyAxID4+PiAwO1xuICAgIHZhciBiNTggPSBuZXcgVWludDhBcnJheShzaXplKTtcbiAgICB3aGlsZSAocGJlZ2luICE9PSBwZW5kKSB7XG4gICAgICB2YXIgY2FycnkgPSBzb3VyY2VbcGJlZ2luXTtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIGZvciAodmFyIGl0MSA9IHNpemUgLSAxOyAoY2FycnkgIT09IDAgfHwgaSA8IGxlbmd0aCkgJiYgaXQxICE9PSAtMTsgaXQxLS0sIGkrKykge1xuICAgICAgICBjYXJyeSArPSAyNTYgKiBiNThbaXQxXSA+Pj4gMDtcbiAgICAgICAgYjU4W2l0MV0gPSBjYXJyeSAlIEJBU0UgPj4+IDA7XG4gICAgICAgIGNhcnJ5ID0gY2FycnkgLyBCQVNFID4+PiAwO1xuICAgICAgfVxuICAgICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm9uLXplcm8gY2FycnknKTtcbiAgICAgIH1cbiAgICAgIGxlbmd0aCA9IGk7XG4gICAgICBwYmVnaW4rKztcbiAgICB9XG4gICAgdmFyIGl0MiA9IHNpemUgLSBsZW5ndGg7XG4gICAgd2hpbGUgKGl0MiAhPT0gc2l6ZSAmJiBiNThbaXQyXSA9PT0gMCkge1xuICAgICAgaXQyKys7XG4gICAgfVxuICAgIHZhciBzdHIgPSBMRUFERVIucmVwZWF0KHplcm9lcyk7XG4gICAgZm9yICg7IGl0MiA8IHNpemU7ICsraXQyKSB7XG4gICAgICBzdHIgKz0gQUxQSEFCRVQuY2hhckF0KGI1OFtpdDJdKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuICBmdW5jdGlvbiBkZWNvZGVVbnNhZmUoc291cmNlKSB7XG4gICAgaWYgKHR5cGVvZiBzb3VyY2UgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBTdHJpbmcnKTtcbiAgICB9XG4gICAgaWYgKHNvdXJjZS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBuZXcgVWludDhBcnJheSgpO1xuICAgIH1cbiAgICB2YXIgcHN6ID0gMDtcbiAgICBpZiAoc291cmNlW3Bzel0gPT09ICcgJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgemVyb2VzID0gMDtcbiAgICB2YXIgbGVuZ3RoID0gMDtcbiAgICB3aGlsZSAoc291cmNlW3Bzel0gPT09IExFQURFUikge1xuICAgICAgemVyb2VzKys7XG4gICAgICBwc3orKztcbiAgICB9XG4gICAgdmFyIHNpemUgPSAoc291cmNlLmxlbmd0aCAtIHBzeikgKiBGQUNUT1IgKyAxID4+PiAwO1xuICAgIHZhciBiMjU2ID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSk7XG4gICAgd2hpbGUgKHNvdXJjZVtwc3pdKSB7XG4gICAgICB2YXIgY2FycnkgPSBCQVNFX01BUFtzb3VyY2UuY2hhckNvZGVBdChwc3opXTtcbiAgICAgIGlmIChjYXJyeSA9PT0gMjU1KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBpID0gMDtcbiAgICAgIGZvciAodmFyIGl0MyA9IHNpemUgLSAxOyAoY2FycnkgIT09IDAgfHwgaSA8IGxlbmd0aCkgJiYgaXQzICE9PSAtMTsgaXQzLS0sIGkrKykge1xuICAgICAgICBjYXJyeSArPSBCQVNFICogYjI1NltpdDNdID4+PiAwO1xuICAgICAgICBiMjU2W2l0M10gPSBjYXJyeSAlIDI1NiA+Pj4gMDtcbiAgICAgICAgY2FycnkgPSBjYXJyeSAvIDI1NiA+Pj4gMDtcbiAgICAgIH1cbiAgICAgIGlmIChjYXJyeSAhPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vbi16ZXJvIGNhcnJ5Jyk7XG4gICAgICB9XG4gICAgICBsZW5ndGggPSBpO1xuICAgICAgcHN6Kys7XG4gICAgfVxuICAgIGlmIChzb3VyY2VbcHN6XSA9PT0gJyAnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBpdDQgPSBzaXplIC0gbGVuZ3RoO1xuICAgIHdoaWxlIChpdDQgIT09IHNpemUgJiYgYjI1NltpdDRdID09PSAwKSB7XG4gICAgICBpdDQrKztcbiAgICB9XG4gICAgdmFyIHZjaCA9IG5ldyBVaW50OEFycmF5KHplcm9lcyArIChzaXplIC0gaXQ0KSk7XG4gICAgdmFyIGogPSB6ZXJvZXM7XG4gICAgd2hpbGUgKGl0NCAhPT0gc2l6ZSkge1xuICAgICAgdmNoW2orK10gPSBiMjU2W2l0NCsrXTtcbiAgICB9XG4gICAgcmV0dXJuIHZjaDtcbiAgfVxuICBmdW5jdGlvbiBkZWNvZGUoc3RyaW5nKSB7XG4gICAgdmFyIGJ1ZmZlciA9IGRlY29kZVVuc2FmZShzdHJpbmcpO1xuICAgIGlmIChidWZmZXIpIHtcbiAgICAgIHJldHVybiBidWZmZXI7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgTm9uLSR7IG5hbWUgfSBjaGFyYWN0ZXJgKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGVuY29kZTogZW5jb2RlLFxuICAgIGRlY29kZVVuc2FmZTogZGVjb2RlVW5zYWZlLFxuICAgIGRlY29kZTogZGVjb2RlXG4gIH07XG59XG52YXIgc3JjID0gYmFzZTtcbnZhciBfYnJycF9fbXVsdGlmb3JtYXRzX3Njb3BlX2Jhc2VYID0gc3JjO1xuZXhwb3J0IGRlZmF1bHQgX2JycnBfX211bHRpZm9ybWF0c19zY29wZV9iYXNlWDsiLCAiaW1wb3J0IGJhc2V4IGZyb20gJy4uLy4uL3ZlbmRvci9iYXNlLXguanMnO1xuaW1wb3J0IHsgY29lcmNlIH0gZnJvbSAnLi4vYnl0ZXMuanMnO1xuY2xhc3MgRW5jb2RlciB7XG4gIGNvbnN0cnVjdG9yKG5hbWUsIHByZWZpeCwgYmFzZUVuY29kZSkge1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5wcmVmaXggPSBwcmVmaXg7XG4gICAgdGhpcy5iYXNlRW5jb2RlID0gYmFzZUVuY29kZTtcbiAgfVxuICBlbmNvZGUoYnl0ZXMpIHtcbiAgICBpZiAoYnl0ZXMgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICByZXR1cm4gYCR7IHRoaXMucHJlZml4IH0keyB0aGlzLmJhc2VFbmNvZGUoYnl0ZXMpIH1gO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBFcnJvcignVW5rbm93biB0eXBlLCBtdXN0IGJlIGJpbmFyeSB0eXBlJyk7XG4gICAgfVxuICB9XG59XG5jbGFzcyBEZWNvZGVyIHtcbiAgY29uc3RydWN0b3IobmFtZSwgcHJlZml4LCBiYXNlRGVjb2RlKSB7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLnByZWZpeCA9IHByZWZpeDtcbiAgICBpZiAocHJlZml4LmNvZGVQb2ludEF0KDApID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwcmVmaXggY2hhcmFjdGVyJyk7XG4gICAgfVxuICAgIHRoaXMucHJlZml4Q29kZVBvaW50ID0gcHJlZml4LmNvZGVQb2ludEF0KDApO1xuICAgIHRoaXMuYmFzZURlY29kZSA9IGJhc2VEZWNvZGU7XG4gIH1cbiAgZGVjb2RlKHRleHQpIHtcbiAgICBpZiAodHlwZW9mIHRleHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAodGV4dC5jb2RlUG9pbnRBdCgwKSAhPT0gdGhpcy5wcmVmaXhDb2RlUG9pbnQpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYFVuYWJsZSB0byBkZWNvZGUgbXVsdGliYXNlIHN0cmluZyAkeyBKU09OLnN0cmluZ2lmeSh0ZXh0KSB9LCAkeyB0aGlzLm5hbWUgfSBkZWNvZGVyIG9ubHkgc3VwcG9ydHMgaW5wdXRzIHByZWZpeGVkIHdpdGggJHsgdGhpcy5wcmVmaXggfWApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuYmFzZURlY29kZSh0ZXh0LnNsaWNlKHRoaXMucHJlZml4Lmxlbmd0aCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBFcnJvcignQ2FuIG9ubHkgbXVsdGliYXNlIGRlY29kZSBzdHJpbmdzJyk7XG4gICAgfVxuICB9XG4gIG9yKGRlY29kZXIpIHtcbiAgICByZXR1cm4gb3IodGhpcywgZGVjb2Rlcik7XG4gIH1cbn1cbmNsYXNzIENvbXBvc2VkRGVjb2RlciB7XG4gIGNvbnN0cnVjdG9yKGRlY29kZXJzKSB7XG4gICAgdGhpcy5kZWNvZGVycyA9IGRlY29kZXJzO1xuICB9XG4gIG9yKGRlY29kZXIpIHtcbiAgICByZXR1cm4gb3IodGhpcywgZGVjb2Rlcik7XG4gIH1cbiAgZGVjb2RlKGlucHV0KSB7XG4gICAgY29uc3QgcHJlZml4ID0gaW5wdXRbMF07XG4gICAgY29uc3QgZGVjb2RlciA9IHRoaXMuZGVjb2RlcnNbcHJlZml4XTtcbiAgICBpZiAoZGVjb2Rlcikge1xuICAgICAgcmV0dXJuIGRlY29kZXIuZGVjb2RlKGlucHV0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgUmFuZ2VFcnJvcihgVW5hYmxlIHRvIGRlY29kZSBtdWx0aWJhc2Ugc3RyaW5nICR7IEpTT04uc3RyaW5naWZ5KGlucHV0KSB9LCBvbmx5IGlucHV0cyBwcmVmaXhlZCB3aXRoICR7IE9iamVjdC5rZXlzKHRoaXMuZGVjb2RlcnMpIH0gYXJlIHN1cHBvcnRlZGApO1xuICAgIH1cbiAgfVxufVxuZXhwb3J0IGNvbnN0IG9yID0gKGxlZnQsIHJpZ2h0KSA9PiBuZXcgQ29tcG9zZWREZWNvZGVyKHtcbiAgLi4ubGVmdC5kZWNvZGVycyB8fCB7IFtsZWZ0LnByZWZpeF06IGxlZnQgfSxcbiAgLi4ucmlnaHQuZGVjb2RlcnMgfHwgeyBbcmlnaHQucHJlZml4XTogcmlnaHQgfVxufSk7XG5leHBvcnQgY2xhc3MgQ29kZWMge1xuICBjb25zdHJ1Y3RvcihuYW1lLCBwcmVmaXgsIGJhc2VFbmNvZGUsIGJhc2VEZWNvZGUpIHtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMucHJlZml4ID0gcHJlZml4O1xuICAgIHRoaXMuYmFzZUVuY29kZSA9IGJhc2VFbmNvZGU7XG4gICAgdGhpcy5iYXNlRGVjb2RlID0gYmFzZURlY29kZTtcbiAgICB0aGlzLmVuY29kZXIgPSBuZXcgRW5jb2RlcihuYW1lLCBwcmVmaXgsIGJhc2VFbmNvZGUpO1xuICAgIHRoaXMuZGVjb2RlciA9IG5ldyBEZWNvZGVyKG5hbWUsIHByZWZpeCwgYmFzZURlY29kZSk7XG4gIH1cbiAgZW5jb2RlKGlucHV0KSB7XG4gICAgcmV0dXJuIHRoaXMuZW5jb2Rlci5lbmNvZGUoaW5wdXQpO1xuICB9XG4gIGRlY29kZShpbnB1dCkge1xuICAgIHJldHVybiB0aGlzLmRlY29kZXIuZGVjb2RlKGlucHV0KTtcbiAgfVxufVxuZXhwb3J0IGNvbnN0IGZyb20gPSAoe25hbWUsIHByZWZpeCwgZW5jb2RlLCBkZWNvZGV9KSA9PiBuZXcgQ29kZWMobmFtZSwgcHJlZml4LCBlbmNvZGUsIGRlY29kZSk7XG5leHBvcnQgY29uc3QgYmFzZVggPSAoe3ByZWZpeCwgbmFtZSwgYWxwaGFiZXR9KSA9PiB7XG4gIGNvbnN0IHtlbmNvZGUsIGRlY29kZX0gPSBiYXNleChhbHBoYWJldCwgbmFtZSk7XG4gIHJldHVybiBmcm9tKHtcbiAgICBwcmVmaXgsXG4gICAgbmFtZSxcbiAgICBlbmNvZGUsXG4gICAgZGVjb2RlOiB0ZXh0ID0+IGNvZXJjZShkZWNvZGUodGV4dCkpXG4gIH0pO1xufTtcbmNvbnN0IGRlY29kZSA9IChzdHJpbmcsIGFscGhhYmV0LCBiaXRzUGVyQ2hhciwgbmFtZSkgPT4ge1xuICBjb25zdCBjb2RlcyA9IHt9O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFscGhhYmV0Lmxlbmd0aDsgKytpKSB7XG4gICAgY29kZXNbYWxwaGFiZXRbaV1dID0gaTtcbiAgfVxuICBsZXQgZW5kID0gc3RyaW5nLmxlbmd0aDtcbiAgd2hpbGUgKHN0cmluZ1tlbmQgLSAxXSA9PT0gJz0nKSB7XG4gICAgLS1lbmQ7XG4gIH1cbiAgY29uc3Qgb3V0ID0gbmV3IFVpbnQ4QXJyYXkoZW5kICogYml0c1BlckNoYXIgLyA4IHwgMCk7XG4gIGxldCBiaXRzID0gMDtcbiAgbGV0IGJ1ZmZlciA9IDA7XG4gIGxldCB3cml0dGVuID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbmQ7ICsraSkge1xuICAgIGNvbnN0IHZhbHVlID0gY29kZXNbc3RyaW5nW2ldXTtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBOb24tJHsgbmFtZSB9IGNoYXJhY3RlcmApO1xuICAgIH1cbiAgICBidWZmZXIgPSBidWZmZXIgPDwgYml0c1BlckNoYXIgfCB2YWx1ZTtcbiAgICBiaXRzICs9IGJpdHNQZXJDaGFyO1xuICAgIGlmIChiaXRzID49IDgpIHtcbiAgICAgIGJpdHMgLT0gODtcbiAgICAgIG91dFt3cml0dGVuKytdID0gMjU1ICYgYnVmZmVyID4+IGJpdHM7XG4gICAgfVxuICB9XG4gIGlmIChiaXRzID49IGJpdHNQZXJDaGFyIHx8IDI1NSAmIGJ1ZmZlciA8PCA4IC0gYml0cykge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignVW5leHBlY3RlZCBlbmQgb2YgZGF0YScpO1xuICB9XG4gIHJldHVybiBvdXQ7XG59O1xuY29uc3QgZW5jb2RlID0gKGRhdGEsIGFscGhhYmV0LCBiaXRzUGVyQ2hhcikgPT4ge1xuICBjb25zdCBwYWQgPSBhbHBoYWJldFthbHBoYWJldC5sZW5ndGggLSAxXSA9PT0gJz0nO1xuICBjb25zdCBtYXNrID0gKDEgPDwgYml0c1BlckNoYXIpIC0gMTtcbiAgbGV0IG91dCA9ICcnO1xuICBsZXQgYml0cyA9IDA7XG4gIGxldCBidWZmZXIgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICBidWZmZXIgPSBidWZmZXIgPDwgOCB8IGRhdGFbaV07XG4gICAgYml0cyArPSA4O1xuICAgIHdoaWxlIChiaXRzID4gYml0c1BlckNoYXIpIHtcbiAgICAgIGJpdHMgLT0gYml0c1BlckNoYXI7XG4gICAgICBvdXQgKz0gYWxwaGFiZXRbbWFzayAmIGJ1ZmZlciA+PiBiaXRzXTtcbiAgICB9XG4gIH1cbiAgaWYgKGJpdHMpIHtcbiAgICBvdXQgKz0gYWxwaGFiZXRbbWFzayAmIGJ1ZmZlciA8PCBiaXRzUGVyQ2hhciAtIGJpdHNdO1xuICB9XG4gIGlmIChwYWQpIHtcbiAgICB3aGlsZSAob3V0Lmxlbmd0aCAqIGJpdHNQZXJDaGFyICYgNykge1xuICAgICAgb3V0ICs9ICc9JztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG91dDtcbn07XG5leHBvcnQgY29uc3QgcmZjNDY0OCA9ICh7bmFtZSwgcHJlZml4LCBiaXRzUGVyQ2hhciwgYWxwaGFiZXR9KSA9PiB7XG4gIHJldHVybiBmcm9tKHtcbiAgICBwcmVmaXgsXG4gICAgbmFtZSxcbiAgICBlbmNvZGUoaW5wdXQpIHtcbiAgICAgIHJldHVybiBlbmNvZGUoaW5wdXQsIGFscGhhYmV0LCBiaXRzUGVyQ2hhcik7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQpIHtcbiAgICAgIHJldHVybiBkZWNvZGUoaW5wdXQsIGFscGhhYmV0LCBiaXRzUGVyQ2hhciwgbmFtZSk7XG4gICAgfVxuICB9KTtcbn07IiwgImltcG9ydCB7IHJmYzQ2NDggfSBmcm9tICcuL2Jhc2UuanMnO1xuZXhwb3J0IGNvbnN0IGJhc2UzMiA9IHJmYzQ2NDgoe1xuICBwcmVmaXg6ICdiJyxcbiAgbmFtZTogJ2Jhc2UzMicsXG4gIGFscGhhYmV0OiAnYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoyMzQ1NjcnLFxuICBiaXRzUGVyQ2hhcjogNVxufSk7XG5leHBvcnQgY29uc3QgYmFzZTMydXBwZXIgPSByZmM0NjQ4KHtcbiAgcHJlZml4OiAnQicsXG4gIG5hbWU6ICdiYXNlMzJ1cHBlcicsXG4gIGFscGhhYmV0OiAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVoyMzQ1NjcnLFxuICBiaXRzUGVyQ2hhcjogNVxufSk7XG5leHBvcnQgY29uc3QgYmFzZTMycGFkID0gcmZjNDY0OCh7XG4gIHByZWZpeDogJ2MnLFxuICBuYW1lOiAnYmFzZTMycGFkJyxcbiAgYWxwaGFiZXQ6ICdhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejIzNDU2Nz0nLFxuICBiaXRzUGVyQ2hhcjogNVxufSk7XG5leHBvcnQgY29uc3QgYmFzZTMycGFkdXBwZXIgPSByZmM0NjQ4KHtcbiAgcHJlZml4OiAnQycsXG4gIG5hbWU6ICdiYXNlMzJwYWR1cHBlcicsXG4gIGFscGhhYmV0OiAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVoyMzQ1Njc9JyxcbiAgYml0c1BlckNoYXI6IDVcbn0pO1xuZXhwb3J0IGNvbnN0IGJhc2UzMmhleCA9IHJmYzQ2NDgoe1xuICBwcmVmaXg6ICd2JyxcbiAgbmFtZTogJ2Jhc2UzMmhleCcsXG4gIGFscGhhYmV0OiAnMDEyMzQ1Njc4OWFiY2RlZmdoaWprbG1ub3BxcnN0dXYnLFxuICBiaXRzUGVyQ2hhcjogNVxufSk7XG5leHBvcnQgY29uc3QgYmFzZTMyaGV4dXBwZXIgPSByZmM0NjQ4KHtcbiAgcHJlZml4OiAnVicsXG4gIG5hbWU6ICdiYXNlMzJoZXh1cHBlcicsXG4gIGFscGhhYmV0OiAnMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVYnLFxuICBiaXRzUGVyQ2hhcjogNVxufSk7XG5leHBvcnQgY29uc3QgYmFzZTMyaGV4cGFkID0gcmZjNDY0OCh7XG4gIHByZWZpeDogJ3QnLFxuICBuYW1lOiAnYmFzZTMyaGV4cGFkJyxcbiAgYWxwaGFiZXQ6ICcwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dj0nLFxuICBiaXRzUGVyQ2hhcjogNVxufSk7XG5leHBvcnQgY29uc3QgYmFzZTMyaGV4cGFkdXBwZXIgPSByZmM0NjQ4KHtcbiAgcHJlZml4OiAnVCcsXG4gIG5hbWU6ICdiYXNlMzJoZXhwYWR1cHBlcicsXG4gIGFscGhhYmV0OiAnMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVY9JyxcbiAgYml0c1BlckNoYXI6IDVcbn0pO1xuZXhwb3J0IGNvbnN0IGJhc2UzMnogPSByZmM0NjQ4KHtcbiAgcHJlZml4OiAnaCcsXG4gIG5hbWU6ICdiYXNlMzJ6JyxcbiAgYWxwaGFiZXQ6ICd5Ym5kcmZnOGVqa21jcHF4b3QxdXdpc3phMzQ1aDc2OScsXG4gIGJpdHNQZXJDaGFyOiA1XG59KTsiLCAiaW1wb3J0ICogYXMgdmFyaW50IGZyb20gJy4vdmFyaW50LmpzJztcbmltcG9ydCAqIGFzIERpZ2VzdCBmcm9tICcuL2hhc2hlcy9kaWdlc3QuanMnO1xuaW1wb3J0IHsgYmFzZTU4YnRjIH0gZnJvbSAnLi9iYXNlcy9iYXNlNTguanMnO1xuaW1wb3J0IHsgYmFzZTMyIH0gZnJvbSAnLi9iYXNlcy9iYXNlMzIuanMnO1xuaW1wb3J0IHsgY29lcmNlIH0gZnJvbSAnLi9ieXRlcy5qcyc7XG5leHBvcnQgY2xhc3MgQ0lEIHtcbiAgY29uc3RydWN0b3IodmVyc2lvbiwgY29kZSwgbXVsdGloYXNoLCBieXRlcykge1xuICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgdGhpcy52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICB0aGlzLm11bHRpaGFzaCA9IG11bHRpaGFzaDtcbiAgICB0aGlzLmJ5dGVzID0gYnl0ZXM7XG4gICAgdGhpcy5ieXRlT2Zmc2V0ID0gYnl0ZXMuYnl0ZU9mZnNldDtcbiAgICB0aGlzLmJ5dGVMZW5ndGggPSBieXRlcy5ieXRlTGVuZ3RoO1xuICAgIHRoaXMuYXNDSUQgPSB0aGlzO1xuICAgIHRoaXMuX2Jhc2VDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICBieXRlT2Zmc2V0OiBoaWRkZW4sXG4gICAgICBieXRlTGVuZ3RoOiBoaWRkZW4sXG4gICAgICBjb2RlOiByZWFkb25seSxcbiAgICAgIHZlcnNpb246IHJlYWRvbmx5LFxuICAgICAgbXVsdGloYXNoOiByZWFkb25seSxcbiAgICAgIGJ5dGVzOiByZWFkb25seSxcbiAgICAgIF9iYXNlQ2FjaGU6IGhpZGRlbixcbiAgICAgIGFzQ0lEOiBoaWRkZW5cbiAgICB9KTtcbiAgfVxuICB0b1YwKCkge1xuICAgIHN3aXRjaCAodGhpcy52ZXJzaW9uKSB7XG4gICAgY2FzZSAwOiB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgY29uc3Qge2NvZGUsIG11bHRpaGFzaH0gPSB0aGlzO1xuICAgICAgICBpZiAoY29kZSAhPT0gREFHX1BCX0NPREUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IGEgbm9uIGRhZy1wYiBDSUQgdG8gQ0lEdjAnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobXVsdGloYXNoLmNvZGUgIT09IFNIQV8yNTZfQ09ERSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNvbnZlcnQgbm9uIHNoYTItMjU2IG11bHRpaGFzaCBDSUQgdG8gQ0lEdjAnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQ0lELmNyZWF0ZVYwKG11bHRpaGFzaCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHRvVjEoKSB7XG4gICAgc3dpdGNoICh0aGlzLnZlcnNpb24pIHtcbiAgICBjYXNlIDA6IHtcbiAgICAgICAgY29uc3Qge2NvZGUsIGRpZ2VzdH0gPSB0aGlzLm11bHRpaGFzaDtcbiAgICAgICAgY29uc3QgbXVsdGloYXNoID0gRGlnZXN0LmNyZWF0ZShjb2RlLCBkaWdlc3QpO1xuICAgICAgICByZXR1cm4gQ0lELmNyZWF0ZVYxKHRoaXMuY29kZSwgbXVsdGloYXNoKTtcbiAgICAgIH1cbiAgICBjYXNlIDE6IHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgICB0aHJvdyBFcnJvcihgQ2FuIG5vdCBjb252ZXJ0IENJRCB2ZXJzaW9uICR7IHRoaXMudmVyc2lvbiB9IHRvIHZlcnNpb24gMC4gVGhpcyBpcyBhIGJ1ZyBwbGVhc2UgcmVwb3J0YCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGVxdWFscyhvdGhlcikge1xuICAgIHJldHVybiBvdGhlciAmJiB0aGlzLmNvZGUgPT09IG90aGVyLmNvZGUgJiYgdGhpcy52ZXJzaW9uID09PSBvdGhlci52ZXJzaW9uICYmIERpZ2VzdC5lcXVhbHModGhpcy5tdWx0aWhhc2gsIG90aGVyLm11bHRpaGFzaCk7XG4gIH1cbiAgdG9TdHJpbmcoYmFzZSkge1xuICAgIGNvbnN0IHtieXRlcywgdmVyc2lvbiwgX2Jhc2VDYWNoZX0gPSB0aGlzO1xuICAgIHN3aXRjaCAodmVyc2lvbikge1xuICAgIGNhc2UgMDpcbiAgICAgIHJldHVybiB0b1N0cmluZ1YwKGJ5dGVzLCBfYmFzZUNhY2hlLCBiYXNlIHx8IGJhc2U1OGJ0Yy5lbmNvZGVyKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHRvU3RyaW5nVjEoYnl0ZXMsIF9iYXNlQ2FjaGUsIGJhc2UgfHwgYmFzZTMyLmVuY29kZXIpO1xuICAgIH1cbiAgfVxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvZGU6IHRoaXMuY29kZSxcbiAgICAgIHZlcnNpb246IHRoaXMudmVyc2lvbixcbiAgICAgIGhhc2g6IHRoaXMubXVsdGloYXNoLmJ5dGVzXG4gICAgfTtcbiAgfVxuICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG4gICAgcmV0dXJuICdDSUQnO1xuICB9XG4gIFtTeW1ib2wuZm9yKCdub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbScpXSgpIHtcbiAgICByZXR1cm4gJ0NJRCgnICsgdGhpcy50b1N0cmluZygpICsgJyknO1xuICB9XG4gIHN0YXRpYyBpc0NJRCh2YWx1ZSkge1xuICAgIGRlcHJlY2F0ZSgvXjBcXC4wLywgSVNfQ0lEX0RFUFJFQ0FUSU9OKTtcbiAgICByZXR1cm4gISEodmFsdWUgJiYgKHZhbHVlW2NpZFN5bWJvbF0gfHwgdmFsdWUuYXNDSUQgPT09IHZhbHVlKSk7XG4gIH1cbiAgZ2V0IHRvQmFzZUVuY29kZWRTdHJpbmcoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdEZXByZWNhdGVkLCB1c2UgLnRvU3RyaW5nKCknKTtcbiAgfVxuICBnZXQgY29kZWMoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdcImNvZGVjXCIgcHJvcGVydHkgaXMgZGVwcmVjYXRlZCwgdXNlIGludGVnZXIgXCJjb2RlXCIgcHJvcGVydHkgaW5zdGVhZCcpO1xuICB9XG4gIGdldCBidWZmZXIoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdEZXByZWNhdGVkIC5idWZmZXIgcHJvcGVydHksIHVzZSAuYnl0ZXMgdG8gZ2V0IFVpbnQ4QXJyYXkgaW5zdGVhZCcpO1xuICB9XG4gIGdldCBtdWx0aWJhc2VOYW1lKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignXCJtdWx0aWJhc2VOYW1lXCIgcHJvcGVydHkgaXMgZGVwcmVjYXRlZCcpO1xuICB9XG4gIGdldCBwcmVmaXgoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdcInByZWZpeFwiIHByb3BlcnR5IGlzIGRlcHJlY2F0ZWQnKTtcbiAgfVxuICBzdGF0aWMgYXNDSUQodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBDSUQpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlICE9IG51bGwgJiYgdmFsdWUuYXNDSUQgPT09IHZhbHVlKSB7XG4gICAgICBjb25zdCB7dmVyc2lvbiwgY29kZSwgbXVsdGloYXNoLCBieXRlc30gPSB2YWx1ZTtcbiAgICAgIHJldHVybiBuZXcgQ0lEKHZlcnNpb24sIGNvZGUsIG11bHRpaGFzaCwgYnl0ZXMgfHwgZW5jb2RlQ0lEKHZlcnNpb24sIGNvZGUsIG11bHRpaGFzaC5ieXRlcykpO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgIT0gbnVsbCAmJiB2YWx1ZVtjaWRTeW1ib2xdID09PSB0cnVlKSB7XG4gICAgICBjb25zdCB7dmVyc2lvbiwgbXVsdGloYXNoLCBjb2RlfSA9IHZhbHVlO1xuICAgICAgY29uc3QgZGlnZXN0ID0gRGlnZXN0LmRlY29kZShtdWx0aWhhc2gpO1xuICAgICAgcmV0dXJuIENJRC5jcmVhdGUodmVyc2lvbiwgY29kZSwgZGlnZXN0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBjcmVhdGUodmVyc2lvbiwgY29kZSwgZGlnZXN0KSB7XG4gICAgaWYgKHR5cGVvZiBjb2RlICE9PSAnbnVtYmVyJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdHJpbmcgY29kZWNzIGFyZSBubyBsb25nZXIgc3VwcG9ydGVkJyk7XG4gICAgfVxuICAgIHN3aXRjaCAodmVyc2lvbikge1xuICAgIGNhc2UgMDoge1xuICAgICAgICBpZiAoY29kZSAhPT0gREFHX1BCX0NPREUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFZlcnNpb24gMCBDSUQgbXVzdCB1c2UgZGFnLXBiIChjb2RlOiAkeyBEQUdfUEJfQ09ERSB9KSBibG9jayBlbmNvZGluZ2ApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBuZXcgQ0lEKHZlcnNpb24sIGNvZGUsIGRpZ2VzdCwgZGlnZXN0LmJ5dGVzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIGNhc2UgMToge1xuICAgICAgICBjb25zdCBieXRlcyA9IGVuY29kZUNJRCh2ZXJzaW9uLCBjb2RlLCBkaWdlc3QuYnl0ZXMpO1xuICAgICAgICByZXR1cm4gbmV3IENJRCh2ZXJzaW9uLCBjb2RlLCBkaWdlc3QsIGJ5dGVzKTtcbiAgICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB2ZXJzaW9uJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHN0YXRpYyBjcmVhdGVWMChkaWdlc3QpIHtcbiAgICByZXR1cm4gQ0lELmNyZWF0ZSgwLCBEQUdfUEJfQ09ERSwgZGlnZXN0KTtcbiAgfVxuICBzdGF0aWMgY3JlYXRlVjEoY29kZSwgZGlnZXN0KSB7XG4gICAgcmV0dXJuIENJRC5jcmVhdGUoMSwgY29kZSwgZGlnZXN0KTtcbiAgfVxuICBzdGF0aWMgZGVjb2RlKGJ5dGVzKSB7XG4gICAgY29uc3QgW2NpZCwgcmVtYWluZGVyXSA9IENJRC5kZWNvZGVGaXJzdChieXRlcyk7XG4gICAgaWYgKHJlbWFpbmRlci5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5jb3JyZWN0IGxlbmd0aCcpO1xuICAgIH1cbiAgICByZXR1cm4gY2lkO1xuICB9XG4gIHN0YXRpYyBkZWNvZGVGaXJzdChieXRlcykge1xuICAgIGNvbnN0IHNwZWNzID0gQ0lELmluc3BlY3RCeXRlcyhieXRlcyk7XG4gICAgY29uc3QgcHJlZml4U2l6ZSA9IHNwZWNzLnNpemUgLSBzcGVjcy5tdWx0aWhhc2hTaXplO1xuICAgIGNvbnN0IG11bHRpaGFzaEJ5dGVzID0gY29lcmNlKGJ5dGVzLnN1YmFycmF5KHByZWZpeFNpemUsIHByZWZpeFNpemUgKyBzcGVjcy5tdWx0aWhhc2hTaXplKSk7XG4gICAgaWYgKG11bHRpaGFzaEJ5dGVzLmJ5dGVMZW5ndGggIT09IHNwZWNzLm11bHRpaGFzaFNpemUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5jb3JyZWN0IGxlbmd0aCcpO1xuICAgIH1cbiAgICBjb25zdCBkaWdlc3RCeXRlcyA9IG11bHRpaGFzaEJ5dGVzLnN1YmFycmF5KHNwZWNzLm11bHRpaGFzaFNpemUgLSBzcGVjcy5kaWdlc3RTaXplKTtcbiAgICBjb25zdCBkaWdlc3QgPSBuZXcgRGlnZXN0LkRpZ2VzdChzcGVjcy5tdWx0aWhhc2hDb2RlLCBzcGVjcy5kaWdlc3RTaXplLCBkaWdlc3RCeXRlcywgbXVsdGloYXNoQnl0ZXMpO1xuICAgIGNvbnN0IGNpZCA9IHNwZWNzLnZlcnNpb24gPT09IDAgPyBDSUQuY3JlYXRlVjAoZGlnZXN0KSA6IENJRC5jcmVhdGVWMShzcGVjcy5jb2RlYywgZGlnZXN0KTtcbiAgICByZXR1cm4gW1xuICAgICAgY2lkLFxuICAgICAgYnl0ZXMuc3ViYXJyYXkoc3BlY3Muc2l6ZSlcbiAgICBdO1xuICB9XG4gIHN0YXRpYyBpbnNwZWN0Qnl0ZXMoaW5pdGlhbEJ5dGVzKSB7XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgY29uc3QgbmV4dCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IFtpLCBsZW5ndGhdID0gdmFyaW50LmRlY29kZShpbml0aWFsQnl0ZXMuc3ViYXJyYXkob2Zmc2V0KSk7XG4gICAgICBvZmZzZXQgKz0gbGVuZ3RoO1xuICAgICAgcmV0dXJuIGk7XG4gICAgfTtcbiAgICBsZXQgdmVyc2lvbiA9IG5leHQoKTtcbiAgICBsZXQgY29kZWMgPSBEQUdfUEJfQ09ERTtcbiAgICBpZiAodmVyc2lvbiA9PT0gMTgpIHtcbiAgICAgIHZlcnNpb24gPSAwO1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9IGVsc2UgaWYgKHZlcnNpb24gPT09IDEpIHtcbiAgICAgIGNvZGVjID0gbmV4dCgpO1xuICAgIH1cbiAgICBpZiAodmVyc2lvbiAhPT0gMCAmJiB2ZXJzaW9uICE9PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgSW52YWxpZCBDSUQgdmVyc2lvbiAkeyB2ZXJzaW9uIH1gKTtcbiAgICB9XG4gICAgY29uc3QgcHJlZml4U2l6ZSA9IG9mZnNldDtcbiAgICBjb25zdCBtdWx0aWhhc2hDb2RlID0gbmV4dCgpO1xuICAgIGNvbnN0IGRpZ2VzdFNpemUgPSBuZXh0KCk7XG4gICAgY29uc3Qgc2l6ZSA9IG9mZnNldCArIGRpZ2VzdFNpemU7XG4gICAgY29uc3QgbXVsdGloYXNoU2l6ZSA9IHNpemUgLSBwcmVmaXhTaXplO1xuICAgIHJldHVybiB7XG4gICAgICB2ZXJzaW9uLFxuICAgICAgY29kZWMsXG4gICAgICBtdWx0aWhhc2hDb2RlLFxuICAgICAgZGlnZXN0U2l6ZSxcbiAgICAgIG11bHRpaGFzaFNpemUsXG4gICAgICBzaXplXG4gICAgfTtcbiAgfVxuICBzdGF0aWMgcGFyc2Uoc291cmNlLCBiYXNlKSB7XG4gICAgY29uc3QgW3ByZWZpeCwgYnl0ZXNdID0gcGFyc2VDSUR0b0J5dGVzKHNvdXJjZSwgYmFzZSk7XG4gICAgY29uc3QgY2lkID0gQ0lELmRlY29kZShieXRlcyk7XG4gICAgY2lkLl9iYXNlQ2FjaGUuc2V0KHByZWZpeCwgc291cmNlKTtcbiAgICByZXR1cm4gY2lkO1xuICB9XG59XG5jb25zdCBwYXJzZUNJRHRvQnl0ZXMgPSAoc291cmNlLCBiYXNlKSA9PiB7XG4gIHN3aXRjaCAoc291cmNlWzBdKSB7XG4gIGNhc2UgJ1EnOiB7XG4gICAgICBjb25zdCBkZWNvZGVyID0gYmFzZSB8fCBiYXNlNThidGM7XG4gICAgICByZXR1cm4gW1xuICAgICAgICBiYXNlNThidGMucHJlZml4LFxuICAgICAgICBkZWNvZGVyLmRlY29kZShgJHsgYmFzZTU4YnRjLnByZWZpeCB9JHsgc291cmNlIH1gKVxuICAgICAgXTtcbiAgICB9XG4gIGNhc2UgYmFzZTU4YnRjLnByZWZpeDoge1xuICAgICAgY29uc3QgZGVjb2RlciA9IGJhc2UgfHwgYmFzZTU4YnRjO1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgYmFzZTU4YnRjLnByZWZpeCxcbiAgICAgICAgZGVjb2Rlci5kZWNvZGUoc291cmNlKVxuICAgICAgXTtcbiAgICB9XG4gIGNhc2UgYmFzZTMyLnByZWZpeDoge1xuICAgICAgY29uc3QgZGVjb2RlciA9IGJhc2UgfHwgYmFzZTMyO1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgYmFzZTMyLnByZWZpeCxcbiAgICAgICAgZGVjb2Rlci5kZWNvZGUoc291cmNlKVxuICAgICAgXTtcbiAgICB9XG4gIGRlZmF1bHQ6IHtcbiAgICAgIGlmIChiYXNlID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ1RvIHBhcnNlIG5vbiBiYXNlMzIgb3IgYmFzZTU4YnRjIGVuY29kZWQgQ0lEIG11bHRpYmFzZSBkZWNvZGVyIG11c3QgYmUgcHJvdmlkZWQnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbXG4gICAgICAgIHNvdXJjZVswXSxcbiAgICAgICAgYmFzZS5kZWNvZGUoc291cmNlKVxuICAgICAgXTtcbiAgICB9XG4gIH1cbn07XG5jb25zdCB0b1N0cmluZ1YwID0gKGJ5dGVzLCBjYWNoZSwgYmFzZSkgPT4ge1xuICBjb25zdCB7cHJlZml4fSA9IGJhc2U7XG4gIGlmIChwcmVmaXggIT09IGJhc2U1OGJ0Yy5wcmVmaXgpIHtcbiAgICB0aHJvdyBFcnJvcihgQ2Fubm90IHN0cmluZyBlbmNvZGUgVjAgaW4gJHsgYmFzZS5uYW1lIH0gZW5jb2RpbmdgKTtcbiAgfVxuICBjb25zdCBjaWQgPSBjYWNoZS5nZXQocHJlZml4KTtcbiAgaWYgKGNpZCA9PSBudWxsKSB7XG4gICAgY29uc3QgY2lkID0gYmFzZS5lbmNvZGUoYnl0ZXMpLnNsaWNlKDEpO1xuICAgIGNhY2hlLnNldChwcmVmaXgsIGNpZCk7XG4gICAgcmV0dXJuIGNpZDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY2lkO1xuICB9XG59O1xuY29uc3QgdG9TdHJpbmdWMSA9IChieXRlcywgY2FjaGUsIGJhc2UpID0+IHtcbiAgY29uc3Qge3ByZWZpeH0gPSBiYXNlO1xuICBjb25zdCBjaWQgPSBjYWNoZS5nZXQocHJlZml4KTtcbiAgaWYgKGNpZCA9PSBudWxsKSB7XG4gICAgY29uc3QgY2lkID0gYmFzZS5lbmNvZGUoYnl0ZXMpO1xuICAgIGNhY2hlLnNldChwcmVmaXgsIGNpZCk7XG4gICAgcmV0dXJuIGNpZDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY2lkO1xuICB9XG59O1xuY29uc3QgREFHX1BCX0NPREUgPSAxMTI7XG5jb25zdCBTSEFfMjU2X0NPREUgPSAxODtcbmNvbnN0IGVuY29kZUNJRCA9ICh2ZXJzaW9uLCBjb2RlLCBtdWx0aWhhc2gpID0+IHtcbiAgY29uc3QgY29kZU9mZnNldCA9IHZhcmludC5lbmNvZGluZ0xlbmd0aCh2ZXJzaW9uKTtcbiAgY29uc3QgaGFzaE9mZnNldCA9IGNvZGVPZmZzZXQgKyB2YXJpbnQuZW5jb2RpbmdMZW5ndGgoY29kZSk7XG4gIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoaGFzaE9mZnNldCArIG11bHRpaGFzaC5ieXRlTGVuZ3RoKTtcbiAgdmFyaW50LmVuY29kZVRvKHZlcnNpb24sIGJ5dGVzLCAwKTtcbiAgdmFyaW50LmVuY29kZVRvKGNvZGUsIGJ5dGVzLCBjb2RlT2Zmc2V0KTtcbiAgYnl0ZXMuc2V0KG11bHRpaGFzaCwgaGFzaE9mZnNldCk7XG4gIHJldHVybiBieXRlcztcbn07XG5jb25zdCBjaWRTeW1ib2wgPSBTeW1ib2wuZm9yKCdAaXBsZC9qcy1jaWQvQ0lEJyk7XG5jb25zdCByZWFkb25seSA9IHtcbiAgd3JpdGFibGU6IGZhbHNlLFxuICBjb25maWd1cmFibGU6IGZhbHNlLFxuICBlbnVtZXJhYmxlOiB0cnVlXG59O1xuY29uc3QgaGlkZGVuID0ge1xuICB3cml0YWJsZTogZmFsc2UsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBjb25maWd1cmFibGU6IGZhbHNlXG59O1xuY29uc3QgdmVyc2lvbiA9ICcwLjAuMC1kZXYnO1xuY29uc3QgZGVwcmVjYXRlID0gKHJhbmdlLCBtZXNzYWdlKSA9PiB7XG4gIGlmIChyYW5nZS50ZXN0KHZlcnNpb24pKSB7XG4gICAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgfVxufTtcbmNvbnN0IElTX0NJRF9ERVBSRUNBVElPTiA9IGBDSUQuaXNDSUQodikgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2UuXG5Gb2xsb3dpbmcgY29kZSBwYXR0ZXJuOlxuXG5pZiAoQ0lELmlzQ0lEKHZhbHVlKSkge1xuICBkb1NvbWV0aGluZ1dpdGhDSUQodmFsdWUpXG59XG5cbklzIHJlcGxhY2VkIHdpdGg6XG5cbmNvbnN0IGNpZCA9IENJRC5hc0NJRCh2YWx1ZSlcbmlmIChjaWQpIHtcbiAgLy8gTWFrZSBzdXJlIHRvIHVzZSBjaWQgaW5zdGVhZCBvZiB2YWx1ZVxuICBkb1NvbWV0aGluZ1dpdGhDSUQoY2lkKVxufVxuYDsiLCAiY29uc3QgdHlwZW9mcyA9IFtcbiAgJ3N0cmluZycsXG4gICdudW1iZXInLFxuICAnYmlnaW50JyxcbiAgJ3N5bWJvbCdcbl07XG5jb25zdCBvYmplY3RUeXBlTmFtZXMgPSBbXG4gICdGdW5jdGlvbicsXG4gICdHZW5lcmF0b3InLFxuICAnQXN5bmNHZW5lcmF0b3InLFxuICAnR2VuZXJhdG9yRnVuY3Rpb24nLFxuICAnQXN5bmNHZW5lcmF0b3JGdW5jdGlvbicsXG4gICdBc3luY0Z1bmN0aW9uJyxcbiAgJ09ic2VydmFibGUnLFxuICAnQXJyYXknLFxuICAnQnVmZmVyJyxcbiAgJ09iamVjdCcsXG4gICdSZWdFeHAnLFxuICAnRGF0ZScsXG4gICdFcnJvcicsXG4gICdNYXAnLFxuICAnU2V0JyxcbiAgJ1dlYWtNYXAnLFxuICAnV2Vha1NldCcsXG4gICdBcnJheUJ1ZmZlcicsXG4gICdTaGFyZWRBcnJheUJ1ZmZlcicsXG4gICdEYXRhVmlldycsXG4gICdQcm9taXNlJyxcbiAgJ1VSTCcsXG4gICdIVE1MRWxlbWVudCcsXG4gICdJbnQ4QXJyYXknLFxuICAnVWludDhBcnJheScsXG4gICdVaW50OENsYW1wZWRBcnJheScsXG4gICdJbnQxNkFycmF5JyxcbiAgJ1VpbnQxNkFycmF5JyxcbiAgJ0ludDMyQXJyYXknLFxuICAnVWludDMyQXJyYXknLFxuICAnRmxvYXQzMkFycmF5JyxcbiAgJ0Zsb2F0NjRBcnJheScsXG4gICdCaWdJbnQ2NEFycmF5JyxcbiAgJ0JpZ1VpbnQ2NEFycmF5J1xuXTtcbmV4cG9ydCBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gJ251bGwnO1xuICB9XG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuICd1bmRlZmluZWQnO1xuICB9XG4gIGlmICh2YWx1ZSA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gJ2Jvb2xlYW4nO1xuICB9XG4gIGNvbnN0IHR5cGVPZiA9IHR5cGVvZiB2YWx1ZTtcbiAgaWYgKHR5cGVvZnMuaW5jbHVkZXModHlwZU9mKSkge1xuICAgIHJldHVybiB0eXBlT2Y7XG4gIH1cbiAgaWYgKHR5cGVPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiAnRnVuY3Rpb24nO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiAnQXJyYXknO1xuICB9XG4gIGlmIChpc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICByZXR1cm4gJ0J1ZmZlcic7XG4gIH1cbiAgY29uc3Qgb2JqZWN0VHlwZSA9IGdldE9iamVjdFR5cGUodmFsdWUpO1xuICBpZiAob2JqZWN0VHlwZSkge1xuICAgIHJldHVybiBvYmplY3RUeXBlO1xuICB9XG4gIHJldHVybiAnT2JqZWN0Jztcbn1cbmZ1bmN0aW9uIGlzQnVmZmVyKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5pc0J1ZmZlciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5pc0J1ZmZlci5jYWxsKG51bGwsIHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGdldE9iamVjdFR5cGUodmFsdWUpIHtcbiAgY29uc3Qgb2JqZWN0VHlwZU5hbWUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLnNsaWNlKDgsIC0xKTtcbiAgaWYgKG9iamVjdFR5cGVOYW1lcy5pbmNsdWRlcyhvYmplY3RUeXBlTmFtZSkpIHtcbiAgICByZXR1cm4gb2JqZWN0VHlwZU5hbWU7XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn0iLCAiY2xhc3MgVHlwZSB7XG4gIGNvbnN0cnVjdG9yKG1ham9yLCBuYW1lLCB0ZXJtaW5hbCkge1xuICAgIHRoaXMubWFqb3IgPSBtYWpvcjtcbiAgICB0aGlzLm1ham9yRW5jb2RlZCA9IG1ham9yIDw8IDU7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLnRlcm1pbmFsID0gdGVybWluYWw7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIGBUeXBlWyR7IHRoaXMubWFqb3IgfV0uJHsgdGhpcy5uYW1lIH1gO1xuICB9XG4gIGNvbXBhcmUodHlwKSB7XG4gICAgcmV0dXJuIHRoaXMubWFqb3IgPCB0eXAubWFqb3IgPyAtMSA6IHRoaXMubWFqb3IgPiB0eXAubWFqb3IgPyAxIDogMDtcbiAgfVxufVxuVHlwZS51aW50ID0gbmV3IFR5cGUoMCwgJ3VpbnQnLCB0cnVlKTtcblR5cGUubmVnaW50ID0gbmV3IFR5cGUoMSwgJ25lZ2ludCcsIHRydWUpO1xuVHlwZS5ieXRlcyA9IG5ldyBUeXBlKDIsICdieXRlcycsIHRydWUpO1xuVHlwZS5zdHJpbmcgPSBuZXcgVHlwZSgzLCAnc3RyaW5nJywgdHJ1ZSk7XG5UeXBlLmFycmF5ID0gbmV3IFR5cGUoNCwgJ2FycmF5JywgZmFsc2UpO1xuVHlwZS5tYXAgPSBuZXcgVHlwZSg1LCAnbWFwJywgZmFsc2UpO1xuVHlwZS50YWcgPSBuZXcgVHlwZSg2LCAndGFnJywgZmFsc2UpO1xuVHlwZS5mbG9hdCA9IG5ldyBUeXBlKDcsICdmbG9hdCcsIHRydWUpO1xuVHlwZS5mYWxzZSA9IG5ldyBUeXBlKDcsICdmYWxzZScsIHRydWUpO1xuVHlwZS50cnVlID0gbmV3IFR5cGUoNywgJ3RydWUnLCB0cnVlKTtcblR5cGUubnVsbCA9IG5ldyBUeXBlKDcsICdudWxsJywgdHJ1ZSk7XG5UeXBlLnVuZGVmaW5lZCA9IG5ldyBUeXBlKDcsICd1bmRlZmluZWQnLCB0cnVlKTtcblR5cGUuYnJlYWsgPSBuZXcgVHlwZSg3LCAnYnJlYWsnLCB0cnVlKTtcbmNsYXNzIFRva2VuIHtcbiAgY29uc3RydWN0b3IodHlwZSwgdmFsdWUsIGVuY29kZWRMZW5ndGgpIHtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLmVuY29kZWRMZW5ndGggPSBlbmNvZGVkTGVuZ3RoO1xuICAgIHRoaXMuZW5jb2RlZEJ5dGVzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYnl0ZVZhbHVlID0gdW5kZWZpbmVkO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBgVG9rZW5bJHsgdGhpcy50eXBlIH1dLiR7IHRoaXMudmFsdWUgfWA7XG4gIH1cbn1cbmV4cG9ydCB7XG4gIFR5cGUsXG4gIFRva2VuXG59OyIsICJleHBvcnQgY29uc3QgdXNlQnVmZmVyID0gZ2xvYmFsVGhpcy5wcm9jZXNzICYmICFnbG9iYWxUaGlzLnByb2Nlc3MuYnJvd3NlciAmJiBnbG9iYWxUaGlzLkJ1ZmZlciAmJiB0eXBlb2YgZ2xvYmFsVGhpcy5CdWZmZXIuaXNCdWZmZXIgPT09ICdmdW5jdGlvbic7XG5jb25zdCB0ZXh0RGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xuY29uc3QgdGV4dEVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbmZ1bmN0aW9uIGlzQnVmZmVyKGJ1Zikge1xuICByZXR1cm4gdXNlQnVmZmVyICYmIGdsb2JhbFRoaXMuQnVmZmVyLmlzQnVmZmVyKGJ1Zik7XG59XG5leHBvcnQgZnVuY3Rpb24gYXNVOEEoYnVmKSB7XG4gIGlmICghKGJ1ZiBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XG4gICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShidWYpO1xuICB9XG4gIHJldHVybiBpc0J1ZmZlcihidWYpID8gbmV3IFVpbnQ4QXJyYXkoYnVmLmJ1ZmZlciwgYnVmLmJ5dGVPZmZzZXQsIGJ1Zi5ieXRlTGVuZ3RoKSA6IGJ1Zjtcbn1cbmV4cG9ydCBjb25zdCB0b1N0cmluZyA9IHVzZUJ1ZmZlciA/IChieXRlcywgc3RhcnQsIGVuZCkgPT4ge1xuICByZXR1cm4gZW5kIC0gc3RhcnQgPiA2NCA/IGdsb2JhbFRoaXMuQnVmZmVyLmZyb20oYnl0ZXMuc3ViYXJyYXkoc3RhcnQsIGVuZCkpLnRvU3RyaW5nKCd1dGY4JykgOiB1dGY4U2xpY2UoYnl0ZXMsIHN0YXJ0LCBlbmQpO1xufSA6IChieXRlcywgc3RhcnQsIGVuZCkgPT4ge1xuICByZXR1cm4gZW5kIC0gc3RhcnQgPiA2NCA/IHRleHREZWNvZGVyLmRlY29kZShieXRlcy5zdWJhcnJheShzdGFydCwgZW5kKSkgOiB1dGY4U2xpY2UoYnl0ZXMsIHN0YXJ0LCBlbmQpO1xufTtcbmV4cG9ydCBjb25zdCBmcm9tU3RyaW5nID0gdXNlQnVmZmVyID8gc3RyaW5nID0+IHtcbiAgcmV0dXJuIHN0cmluZy5sZW5ndGggPiA2NCA/IGdsb2JhbFRoaXMuQnVmZmVyLmZyb20oc3RyaW5nKSA6IHV0ZjhUb0J5dGVzKHN0cmluZyk7XG59IDogc3RyaW5nID0+IHtcbiAgcmV0dXJuIHN0cmluZy5sZW5ndGggPiA2NCA/IHRleHRFbmNvZGVyLmVuY29kZShzdHJpbmcpIDogdXRmOFRvQnl0ZXMoc3RyaW5nKTtcbn07XG5leHBvcnQgY29uc3QgZnJvbUFycmF5ID0gYXJyID0+IHtcbiAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShhcnIpO1xufTtcbmV4cG9ydCBjb25zdCBzbGljZSA9IHVzZUJ1ZmZlciA/IChieXRlcywgc3RhcnQsIGVuZCkgPT4ge1xuICBpZiAoaXNCdWZmZXIoYnl0ZXMpKSB7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ5dGVzLnN1YmFycmF5KHN0YXJ0LCBlbmQpKTtcbiAgfVxuICByZXR1cm4gYnl0ZXMuc2xpY2Uoc3RhcnQsIGVuZCk7XG59IDogKGJ5dGVzLCBzdGFydCwgZW5kKSA9PiB7XG4gIHJldHVybiBieXRlcy5zbGljZShzdGFydCwgZW5kKTtcbn07XG5leHBvcnQgY29uc3QgY29uY2F0ID0gdXNlQnVmZmVyID8gKGNodW5rcywgbGVuZ3RoKSA9PiB7XG4gIGNodW5rcyA9IGNodW5rcy5tYXAoYyA9PiBjIGluc3RhbmNlb2YgVWludDhBcnJheSA/IGMgOiBnbG9iYWxUaGlzLkJ1ZmZlci5mcm9tKGMpKTtcbiAgcmV0dXJuIGFzVThBKGdsb2JhbFRoaXMuQnVmZmVyLmNvbmNhdChjaHVua3MsIGxlbmd0aCkpO1xufSA6IChjaHVua3MsIGxlbmd0aCkgPT4ge1xuICBjb25zdCBvdXQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuICBsZXQgb2ZmID0gMDtcbiAgZm9yIChsZXQgYiBvZiBjaHVua3MpIHtcbiAgICBpZiAob2ZmICsgYi5sZW5ndGggPiBvdXQubGVuZ3RoKSB7XG4gICAgICBiID0gYi5zdWJhcnJheSgwLCBvdXQubGVuZ3RoIC0gb2ZmKTtcbiAgICB9XG4gICAgb3V0LnNldChiLCBvZmYpO1xuICAgIG9mZiArPSBiLmxlbmd0aDtcbiAgfVxuICByZXR1cm4gb3V0O1xufTtcbmV4cG9ydCBjb25zdCBhbGxvYyA9IHVzZUJ1ZmZlciA/IHNpemUgPT4ge1xuICByZXR1cm4gZ2xvYmFsVGhpcy5CdWZmZXIuYWxsb2NVbnNhZmUoc2l6ZSk7XG59IDogc2l6ZSA9PiB7XG4gIHJldHVybiBuZXcgVWludDhBcnJheShzaXplKTtcbn07XG5leHBvcnQgY29uc3QgdG9IZXggPSB1c2VCdWZmZXIgPyBkID0+IHtcbiAgaWYgKHR5cGVvZiBkID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBkO1xuICB9XG4gIHJldHVybiBnbG9iYWxUaGlzLkJ1ZmZlci5mcm9tKHRvQnl0ZXMoZCkpLnRvU3RyaW5nKCdoZXgnKTtcbn0gOiBkID0+IHtcbiAgaWYgKHR5cGVvZiBkID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBkO1xuICB9XG4gIHJldHVybiBBcnJheS5wcm90b3R5cGUucmVkdWNlLmNhbGwodG9CeXRlcyhkKSwgKHAsIGMpID0+IGAkeyBwIH0keyBjLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpIH1gLCAnJyk7XG59O1xuZXhwb3J0IGNvbnN0IGZyb21IZXggPSB1c2VCdWZmZXIgPyBoZXggPT4ge1xuICBpZiAoaGV4IGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgIHJldHVybiBoZXg7XG4gIH1cbiAgcmV0dXJuIGdsb2JhbFRoaXMuQnVmZmVyLmZyb20oaGV4LCAnaGV4Jyk7XG59IDogaGV4ID0+IHtcbiAgaWYgKGhleCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICByZXR1cm4gaGV4O1xuICB9XG4gIGlmICghaGV4Lmxlbmd0aCkge1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheSgwKTtcbiAgfVxuICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoaGV4LnNwbGl0KCcnKS5tYXAoKGMsIGksIGQpID0+IGkgJSAyID09PSAwID8gYDB4JHsgYyB9JHsgZFtpICsgMV0gfWAgOiAnJykuZmlsdGVyKEJvb2xlYW4pLm1hcChlID0+IHBhcnNlSW50KGUsIDE2KSkpO1xufTtcbmZ1bmN0aW9uIHRvQnl0ZXMob2JqKSB7XG4gIGlmIChvYmogaW5zdGFuY2VvZiBVaW50OEFycmF5ICYmIG9iai5jb25zdHJ1Y3Rvci5uYW1lID09PSAnVWludDhBcnJheScpIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG4gIGlmIChvYmogaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShvYmopO1xuICB9XG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcob2JqKSkge1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShvYmouYnVmZmVyLCBvYmouYnl0ZU9mZnNldCwgb2JqLmJ5dGVMZW5ndGgpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcignVW5rbm93biB0eXBlLCBtdXN0IGJlIGJpbmFyeSB0eXBlJyk7XG59XG5leHBvcnQgZnVuY3Rpb24gY29tcGFyZShiMSwgYjIpIHtcbiAgaWYgKGlzQnVmZmVyKGIxKSAmJiBpc0J1ZmZlcihiMikpIHtcbiAgICByZXR1cm4gYjEuY29tcGFyZShiMik7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBiMS5sZW5ndGg7IGkrKykge1xuICAgIGlmIChiMVtpXSA9PT0gYjJbaV0pIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICByZXR1cm4gYjFbaV0gPCBiMltpXSA/IC0xIDogMTtcbiAgfVxuICByZXR1cm4gMDtcbn1cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzKHN0cmluZywgdW5pdHMgPSBJbmZpbml0eSkge1xuICBsZXQgY29kZVBvaW50O1xuICBjb25zdCBsZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuICBsZXQgbGVhZFN1cnJvZ2F0ZSA9IG51bGw7XG4gIGNvbnN0IGJ5dGVzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcbiAgICBpZiAoY29kZVBvaW50ID4gNTUyOTUgJiYgY29kZVBvaW50IDwgNTczNDQpIHtcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICBpZiAoY29kZVBvaW50ID4gNTYzMTkpIHtcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpXG4gICAgICAgICAgICBieXRlcy5wdXNoKDIzOSwgMTkxLCAxODkpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpXG4gICAgICAgICAgICBieXRlcy5wdXNoKDIzOSwgMTkxLCAxODkpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKGNvZGVQb2ludCA8IDU2MzIwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSlcbiAgICAgICAgICBieXRlcy5wdXNoKDIzOSwgMTkxLCAxODkpO1xuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50O1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gNTUyOTYgPDwgMTAgfCBjb2RlUG9pbnQgLSA1NjMyMCkgKyA2NTUzNjtcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSlcbiAgICAgICAgYnl0ZXMucHVzaCgyMzksIDE5MSwgMTg5KTtcbiAgICB9XG4gICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGw7XG4gICAgaWYgKGNvZGVQb2ludCA8IDEyOCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApXG4gICAgICAgIGJyZWFrO1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpO1xuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMjA0OCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApXG4gICAgICAgIGJyZWFrO1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQgPj4gNiB8IDE5MiwgY29kZVBvaW50ICYgNjMgfCAxMjgpO1xuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgNjU1MzYpIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKVxuICAgICAgICBicmVhaztcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50ID4+IDEyIHwgMjI0LCBjb2RlUG9pbnQgPj4gNiAmIDYzIHwgMTI4LCBjb2RlUG9pbnQgJiA2MyB8IDEyOCk7XG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAxMTE0MTEyKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMClcbiAgICAgICAgYnJlYWs7XG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludCA+PiAxOCB8IDI0MCwgY29kZVBvaW50ID4+IDEyICYgNjMgfCAxMjgsIGNvZGVQb2ludCA+PiA2ICYgNjMgfCAxMjgsIGNvZGVQb2ludCAmIDYzIHwgMTI4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJ5dGVzO1xufVxuZnVuY3Rpb24gdXRmOFNsaWNlKGJ1Ziwgb2Zmc2V0LCBlbmQpIHtcbiAgY29uc3QgcmVzID0gW107XG4gIHdoaWxlIChvZmZzZXQgPCBlbmQpIHtcbiAgICBjb25zdCBmaXJzdEJ5dGUgPSBidWZbb2Zmc2V0XTtcbiAgICBsZXQgY29kZVBvaW50ID0gbnVsbDtcbiAgICBsZXQgYnl0ZXNQZXJTZXF1ZW5jZSA9IGZpcnN0Qnl0ZSA+IDIzOSA/IDQgOiBmaXJzdEJ5dGUgPiAyMjMgPyAzIDogZmlyc3RCeXRlID4gMTkxID8gMiA6IDE7XG4gICAgaWYgKG9mZnNldCArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICBsZXQgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50O1xuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIGlmIChmaXJzdEJ5dGUgPCAxMjgpIHtcbiAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGU7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHNlY29uZEJ5dGUgPSBidWZbb2Zmc2V0ICsgMV07XG4gICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDE5MikgPT09IDEyOCkge1xuICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMzEpIDw8IDYgfCBzZWNvbmRCeXRlICYgNjM7XG4gICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAxMjcpIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBzZWNvbmRCeXRlID0gYnVmW29mZnNldCArIDFdO1xuICAgICAgICB0aGlyZEJ5dGUgPSBidWZbb2Zmc2V0ICsgMl07XG4gICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDE5MikgPT09IDEyOCAmJiAodGhpcmRCeXRlICYgMTkyKSA9PT0gMTI4KSB7XG4gICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAxNSkgPDwgMTIgfCAoc2Vjb25kQnl0ZSAmIDYzKSA8PCA2IHwgdGhpcmRCeXRlICYgNjM7XG4gICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAyMDQ3ICYmICh0ZW1wQ29kZVBvaW50IDwgNTUyOTYgfHwgdGVtcENvZGVQb2ludCA+IDU3MzQzKSkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDQ6XG4gICAgICAgIHNlY29uZEJ5dGUgPSBidWZbb2Zmc2V0ICsgMV07XG4gICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltvZmZzZXQgKyAyXTtcbiAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltvZmZzZXQgKyAzXTtcbiAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMTkyKSA9PT0gMTI4ICYmICh0aGlyZEJ5dGUgJiAxOTIpID09PSAxMjggJiYgKGZvdXJ0aEJ5dGUgJiAxOTIpID09PSAxMjgpIHtcbiAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDE1KSA8PCAxOCB8IChzZWNvbmRCeXRlICYgNjMpIDw8IDEyIHwgKHRoaXJkQnl0ZSAmIDYzKSA8PCA2IHwgZm91cnRoQnl0ZSAmIDYzO1xuICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gNjU1MzUgJiYgdGVtcENvZGVQb2ludCA8IDExMTQxMTIpIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgIGNvZGVQb2ludCA9IDY1NTMzO1xuICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDE7XG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiA2NTUzNSkge1xuICAgICAgY29kZVBvaW50IC09IDY1NTM2O1xuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDEwMjMgfCA1NTI5Nik7XG4gICAgICBjb2RlUG9pbnQgPSA1NjMyMCB8IGNvZGVQb2ludCAmIDEwMjM7XG4gICAgfVxuICAgIHJlcy5wdXNoKGNvZGVQb2ludCk7XG4gICAgb2Zmc2V0ICs9IGJ5dGVzUGVyU2VxdWVuY2U7XG4gIH1cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpO1xufVxuY29uc3QgTUFYX0FSR1VNRU5UU19MRU5HVEggPSA0MDk2O1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheShjb2RlUG9pbnRzKSB7XG4gIGNvbnN0IGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoO1xuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKTtcbiAgfVxuICBsZXQgcmVzID0gJyc7XG4gIGxldCBpID0gMDtcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkpO1xuICB9XG4gIHJldHVybiByZXM7XG59IiwgImltcG9ydCB7XG4gIGFsbG9jLFxuICBjb25jYXQsXG4gIHNsaWNlXG59IGZyb20gJy4vYnl0ZS11dGlscy5qcyc7XG5jb25zdCBkZWZhdWx0Q2h1bmtTaXplID0gMjU2O1xuZXhwb3J0IGNsYXNzIEJsIHtcbiAgY29uc3RydWN0b3IoY2h1bmtTaXplID0gZGVmYXVsdENodW5rU2l6ZSkge1xuICAgIHRoaXMuY2h1bmtTaXplID0gY2h1bmtTaXplO1xuICAgIHRoaXMuY3Vyc29yID0gMDtcbiAgICB0aGlzLm1heEN1cnNvciA9IC0xO1xuICAgIHRoaXMuY2h1bmtzID0gW107XG4gICAgdGhpcy5faW5pdFJldXNlQ2h1bmsgPSBudWxsO1xuICB9XG4gIHJlc2V0KCkge1xuICAgIHRoaXMuY3Vyc29yID0gMDtcbiAgICB0aGlzLm1heEN1cnNvciA9IC0xO1xuICAgIGlmICh0aGlzLmNodW5rcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuY2h1bmtzID0gW107XG4gICAgfVxuICAgIGlmICh0aGlzLl9pbml0UmV1c2VDaHVuayAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5jaHVua3MucHVzaCh0aGlzLl9pbml0UmV1c2VDaHVuayk7XG4gICAgICB0aGlzLm1heEN1cnNvciA9IHRoaXMuX2luaXRSZXVzZUNodW5rLmxlbmd0aCAtIDE7XG4gICAgfVxuICB9XG4gIHB1c2goYnl0ZXMpIHtcbiAgICBsZXQgdG9wQ2h1bmsgPSB0aGlzLmNodW5rc1t0aGlzLmNodW5rcy5sZW5ndGggLSAxXTtcbiAgICBjb25zdCBuZXdNYXggPSB0aGlzLmN1cnNvciArIGJ5dGVzLmxlbmd0aDtcbiAgICBpZiAobmV3TWF4IDw9IHRoaXMubWF4Q3Vyc29yICsgMSkge1xuICAgICAgY29uc3QgY2h1bmtQb3MgPSB0b3BDaHVuay5sZW5ndGggLSAodGhpcy5tYXhDdXJzb3IgLSB0aGlzLmN1cnNvcikgLSAxO1xuICAgICAgdG9wQ2h1bmsuc2V0KGJ5dGVzLCBjaHVua1Bvcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0b3BDaHVuaykge1xuICAgICAgICBjb25zdCBjaHVua1BvcyA9IHRvcENodW5rLmxlbmd0aCAtICh0aGlzLm1heEN1cnNvciAtIHRoaXMuY3Vyc29yKSAtIDE7XG4gICAgICAgIGlmIChjaHVua1BvcyA8IHRvcENodW5rLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMuY2h1bmtzW3RoaXMuY2h1bmtzLmxlbmd0aCAtIDFdID0gdG9wQ2h1bmsuc3ViYXJyYXkoMCwgY2h1bmtQb3MpO1xuICAgICAgICAgIHRoaXMubWF4Q3Vyc29yID0gdGhpcy5jdXJzb3IgLSAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoYnl0ZXMubGVuZ3RoIDwgNjQgJiYgYnl0ZXMubGVuZ3RoIDwgdGhpcy5jaHVua1NpemUpIHtcbiAgICAgICAgdG9wQ2h1bmsgPSBhbGxvYyh0aGlzLmNodW5rU2l6ZSk7XG4gICAgICAgIHRoaXMuY2h1bmtzLnB1c2godG9wQ2h1bmspO1xuICAgICAgICB0aGlzLm1heEN1cnNvciArPSB0b3BDaHVuay5sZW5ndGg7XG4gICAgICAgIGlmICh0aGlzLl9pbml0UmV1c2VDaHVuayA9PT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMuX2luaXRSZXVzZUNodW5rID0gdG9wQ2h1bms7XG4gICAgICAgIH1cbiAgICAgICAgdG9wQ2h1bmsuc2V0KGJ5dGVzLCAwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2h1bmtzLnB1c2goYnl0ZXMpO1xuICAgICAgICB0aGlzLm1heEN1cnNvciArPSBieXRlcy5sZW5ndGg7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuY3Vyc29yICs9IGJ5dGVzLmxlbmd0aDtcbiAgfVxuICB0b0J5dGVzKHJlc2V0ID0gZmFsc2UpIHtcbiAgICBsZXQgYnl0cztcbiAgICBpZiAodGhpcy5jaHVua3MubGVuZ3RoID09PSAxKSB7XG4gICAgICBjb25zdCBjaHVuayA9IHRoaXMuY2h1bmtzWzBdO1xuICAgICAgaWYgKHJlc2V0ICYmIHRoaXMuY3Vyc29yID4gY2h1bmsubGVuZ3RoIC8gMikge1xuICAgICAgICBieXRzID0gdGhpcy5jdXJzb3IgPT09IGNodW5rLmxlbmd0aCA/IGNodW5rIDogY2h1bmsuc3ViYXJyYXkoMCwgdGhpcy5jdXJzb3IpO1xuICAgICAgICB0aGlzLl9pbml0UmV1c2VDaHVuayA9IG51bGw7XG4gICAgICAgIHRoaXMuY2h1bmtzID0gW107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBieXRzID0gc2xpY2UoY2h1bmssIDAsIHRoaXMuY3Vyc29yKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYnl0cyA9IGNvbmNhdCh0aGlzLmNodW5rcywgdGhpcy5jdXJzb3IpO1xuICAgIH1cbiAgICBpZiAocmVzZXQpIHtcbiAgICAgIHRoaXMucmVzZXQoKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ5dHM7XG4gIH1cbn0iLCAiY29uc3QgZGVjb2RlRXJyUHJlZml4ID0gJ0NCT1IgZGVjb2RlIGVycm9yOic7XG5jb25zdCBlbmNvZGVFcnJQcmVmaXggPSAnQ0JPUiBlbmNvZGUgZXJyb3I6JztcbmNvbnN0IHVpbnRNaW5vclByZWZpeEJ5dGVzID0gW107XG51aW50TWlub3JQcmVmaXhCeXRlc1syM10gPSAxO1xudWludE1pbm9yUHJlZml4Qnl0ZXNbMjRdID0gMjtcbnVpbnRNaW5vclByZWZpeEJ5dGVzWzI1XSA9IDM7XG51aW50TWlub3JQcmVmaXhCeXRlc1syNl0gPSA1O1xudWludE1pbm9yUHJlZml4Qnl0ZXNbMjddID0gOTtcbmZ1bmN0aW9uIGFzc2VydEVub3VnaERhdGEoZGF0YSwgcG9zLCBuZWVkKSB7XG4gIGlmIChkYXRhLmxlbmd0aCAtIHBvcyA8IG5lZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7IGRlY29kZUVyclByZWZpeCB9IG5vdCBlbm91Z2ggZGF0YSBmb3IgdHlwZWApO1xuICB9XG59XG5leHBvcnQge1xuICBkZWNvZGVFcnJQcmVmaXgsXG4gIGVuY29kZUVyclByZWZpeCxcbiAgdWludE1pbm9yUHJlZml4Qnl0ZXMsXG4gIGFzc2VydEVub3VnaERhdGFcbn07IiwgImltcG9ydCB7XG4gIFRva2VuLFxuICBUeXBlXG59IGZyb20gJy4vdG9rZW4uanMnO1xuaW1wb3J0IHtcbiAgZGVjb2RlRXJyUHJlZml4LFxuICBhc3NlcnRFbm91Z2hEYXRhXG59IGZyb20gJy4vY29tbW9uLmpzJztcbmV4cG9ydCBjb25zdCB1aW50Qm91bmRhcmllcyA9IFtcbiAgMjQsXG4gIDI1NixcbiAgNjU1MzYsXG4gIDQyOTQ5NjcyOTYsXG4gIEJpZ0ludCgnMTg0NDY3NDQwNzM3MDk1NTE2MTYnKVxuXTtcbmV4cG9ydCBmdW5jdGlvbiByZWFkVWludDgoZGF0YSwgb2Zmc2V0LCBvcHRpb25zKSB7XG4gIGFzc2VydEVub3VnaERhdGEoZGF0YSwgb2Zmc2V0LCAxKTtcbiAgY29uc3QgdmFsdWUgPSBkYXRhW29mZnNldF07XG4gIGlmIChvcHRpb25zLnN0cmljdCA9PT0gdHJ1ZSAmJiB2YWx1ZSA8IHVpbnRCb3VuZGFyaWVzWzBdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGAkeyBkZWNvZGVFcnJQcmVmaXggfSBpbnRlZ2VyIGVuY29kZWQgaW4gbW9yZSBieXRlcyB0aGFuIG5lY2Vzc2FyeSAoc3RyaWN0IGRlY29kZSlgKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5leHBvcnQgZnVuY3Rpb24gcmVhZFVpbnQxNihkYXRhLCBvZmZzZXQsIG9wdGlvbnMpIHtcbiAgYXNzZXJ0RW5vdWdoRGF0YShkYXRhLCBvZmZzZXQsIDIpO1xuICBjb25zdCB2YWx1ZSA9IGRhdGFbb2Zmc2V0XSA8PCA4IHwgZGF0YVtvZmZzZXQgKyAxXTtcbiAgaWYgKG9wdGlvbnMuc3RyaWN0ID09PSB0cnVlICYmIHZhbHVlIDwgdWludEJvdW5kYXJpZXNbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7IGRlY29kZUVyclByZWZpeCB9IGludGVnZXIgZW5jb2RlZCBpbiBtb3JlIGJ5dGVzIHRoYW4gbmVjZXNzYXJ5IChzdHJpY3QgZGVjb2RlKWApO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiByZWFkVWludDMyKGRhdGEsIG9mZnNldCwgb3B0aW9ucykge1xuICBhc3NlcnRFbm91Z2hEYXRhKGRhdGEsIG9mZnNldCwgNCk7XG4gIGNvbnN0IHZhbHVlID0gZGF0YVtvZmZzZXRdICogMTY3NzcyMTYgKyAoZGF0YVtvZmZzZXQgKyAxXSA8PCAxNikgKyAoZGF0YVtvZmZzZXQgKyAyXSA8PCA4KSArIGRhdGFbb2Zmc2V0ICsgM107XG4gIGlmIChvcHRpb25zLnN0cmljdCA9PT0gdHJ1ZSAmJiB2YWx1ZSA8IHVpbnRCb3VuZGFyaWVzWzJdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGAkeyBkZWNvZGVFcnJQcmVmaXggfSBpbnRlZ2VyIGVuY29kZWQgaW4gbW9yZSBieXRlcyB0aGFuIG5lY2Vzc2FyeSAoc3RyaWN0IGRlY29kZSlgKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5leHBvcnQgZnVuY3Rpb24gcmVhZFVpbnQ2NChkYXRhLCBvZmZzZXQsIG9wdGlvbnMpIHtcbiAgYXNzZXJ0RW5vdWdoRGF0YShkYXRhLCBvZmZzZXQsIDgpO1xuICBjb25zdCBoaSA9IGRhdGFbb2Zmc2V0XSAqIDE2Nzc3MjE2ICsgKGRhdGFbb2Zmc2V0ICsgMV0gPDwgMTYpICsgKGRhdGFbb2Zmc2V0ICsgMl0gPDwgOCkgKyBkYXRhW29mZnNldCArIDNdO1xuICBjb25zdCBsbyA9IGRhdGFbb2Zmc2V0ICsgNF0gKiAxNjc3NzIxNiArIChkYXRhW29mZnNldCArIDVdIDw8IDE2KSArIChkYXRhW29mZnNldCArIDZdIDw8IDgpICsgZGF0YVtvZmZzZXQgKyA3XTtcbiAgY29uc3QgdmFsdWUgPSAoQmlnSW50KGhpKSA8PCBCaWdJbnQoMzIpKSArIEJpZ0ludChsbyk7XG4gIGlmIChvcHRpb25zLnN0cmljdCA9PT0gdHJ1ZSAmJiB2YWx1ZSA8IHVpbnRCb3VuZGFyaWVzWzNdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGAkeyBkZWNvZGVFcnJQcmVmaXggfSBpbnRlZ2VyIGVuY29kZWQgaW4gbW9yZSBieXRlcyB0aGFuIG5lY2Vzc2FyeSAoc3RyaWN0IGRlY29kZSlgKTtcbiAgfVxuICBpZiAodmFsdWUgPD0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICByZXR1cm4gTnVtYmVyKHZhbHVlKTtcbiAgfVxuICBpZiAob3B0aW9ucy5hbGxvd0JpZ0ludCA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoYCR7IGRlY29kZUVyclByZWZpeCB9IGludGVnZXJzIG91dHNpZGUgb2YgdGhlIHNhZmUgaW50ZWdlciByYW5nZSBhcmUgbm90IHN1cHBvcnRlZGApO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZVVpbnQ4KGRhdGEsIHBvcywgX21pbm9yLCBvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgVG9rZW4oVHlwZS51aW50LCByZWFkVWludDgoZGF0YSwgcG9zICsgMSwgb3B0aW9ucyksIDIpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZVVpbnQxNihkYXRhLCBwb3MsIF9taW5vciwgb3B0aW9ucykge1xuICByZXR1cm4gbmV3IFRva2VuKFR5cGUudWludCwgcmVhZFVpbnQxNihkYXRhLCBwb3MgKyAxLCBvcHRpb25zKSwgMyk7XG59XG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlVWludDMyKGRhdGEsIHBvcywgX21pbm9yLCBvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgVG9rZW4oVHlwZS51aW50LCByZWFkVWludDMyKGRhdGEsIHBvcyArIDEsIG9wdGlvbnMpLCA1KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVVaW50NjQoZGF0YSwgcG9zLCBfbWlub3IsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBUb2tlbihUeXBlLnVpbnQsIHJlYWRVaW50NjQoZGF0YSwgcG9zICsgMSwgb3B0aW9ucyksIDkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZVVpbnQoYnVmLCB0b2tlbikge1xuICByZXR1cm4gZW5jb2RlVWludFZhbHVlKGJ1ZiwgMCwgdG9rZW4udmFsdWUpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZVVpbnRWYWx1ZShidWYsIG1ham9yLCB1aW50KSB7XG4gIGlmICh1aW50IDwgdWludEJvdW5kYXJpZXNbMF0pIHtcbiAgICBjb25zdCBudWludCA9IE51bWJlcih1aW50KTtcbiAgICBidWYucHVzaChbbWFqb3IgfCBudWludF0pO1xuICB9IGVsc2UgaWYgKHVpbnQgPCB1aW50Qm91bmRhcmllc1sxXSkge1xuICAgIGNvbnN0IG51aW50ID0gTnVtYmVyKHVpbnQpO1xuICAgIGJ1Zi5wdXNoKFtcbiAgICAgIG1ham9yIHwgMjQsXG4gICAgICBudWludFxuICAgIF0pO1xuICB9IGVsc2UgaWYgKHVpbnQgPCB1aW50Qm91bmRhcmllc1syXSkge1xuICAgIGNvbnN0IG51aW50ID0gTnVtYmVyKHVpbnQpO1xuICAgIGJ1Zi5wdXNoKFtcbiAgICAgIG1ham9yIHwgMjUsXG4gICAgICBudWludCA+Pj4gOCxcbiAgICAgIG51aW50ICYgMjU1XG4gICAgXSk7XG4gIH0gZWxzZSBpZiAodWludCA8IHVpbnRCb3VuZGFyaWVzWzNdKSB7XG4gICAgY29uc3QgbnVpbnQgPSBOdW1iZXIodWludCk7XG4gICAgYnVmLnB1c2goW1xuICAgICAgbWFqb3IgfCAyNixcbiAgICAgIG51aW50ID4+PiAyNCAmIDI1NSxcbiAgICAgIG51aW50ID4+PiAxNiAmIDI1NSxcbiAgICAgIG51aW50ID4+PiA4ICYgMjU1LFxuICAgICAgbnVpbnQgJiAyNTVcbiAgICBdKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBidWludCA9IEJpZ0ludCh1aW50KTtcbiAgICBpZiAoYnVpbnQgPCB1aW50Qm91bmRhcmllc1s0XSkge1xuICAgICAgY29uc3Qgc2V0ID0gW1xuICAgICAgICBtYWpvciB8IDI3LFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwXG4gICAgICBdO1xuICAgICAgbGV0IGxvID0gTnVtYmVyKGJ1aW50ICYgQmlnSW50KDQyOTQ5NjcyOTUpKTtcbiAgICAgIGxldCBoaSA9IE51bWJlcihidWludCA+PiBCaWdJbnQoMzIpICYgQmlnSW50KDQyOTQ5NjcyOTUpKTtcbiAgICAgIHNldFs4XSA9IGxvICYgMjU1O1xuICAgICAgbG8gPSBsbyA+PiA4O1xuICAgICAgc2V0WzddID0gbG8gJiAyNTU7XG4gICAgICBsbyA9IGxvID4+IDg7XG4gICAgICBzZXRbNl0gPSBsbyAmIDI1NTtcbiAgICAgIGxvID0gbG8gPj4gODtcbiAgICAgIHNldFs1XSA9IGxvICYgMjU1O1xuICAgICAgc2V0WzRdID0gaGkgJiAyNTU7XG4gICAgICBoaSA9IGhpID4+IDg7XG4gICAgICBzZXRbM10gPSBoaSAmIDI1NTtcbiAgICAgIGhpID0gaGkgPj4gODtcbiAgICAgIHNldFsyXSA9IGhpICYgMjU1O1xuICAgICAgaGkgPSBoaSA+PiA4O1xuICAgICAgc2V0WzFdID0gaGkgJiAyNTU7XG4gICAgICBidWYucHVzaChzZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7IGRlY29kZUVyclByZWZpeCB9IGVuY291bnRlcmVkIEJpZ0ludCBsYXJnZXIgdGhhbiBhbGxvd2FibGUgcmFuZ2VgKTtcbiAgICB9XG4gIH1cbn1cbmVuY29kZVVpbnQuZW5jb2RlZFNpemUgPSBmdW5jdGlvbiBlbmNvZGVkU2l6ZSh0b2tlbikge1xuICByZXR1cm4gZW5jb2RlVWludFZhbHVlLmVuY29kZWRTaXplKHRva2VuLnZhbHVlKTtcbn07XG5lbmNvZGVVaW50VmFsdWUuZW5jb2RlZFNpemUgPSBmdW5jdGlvbiBlbmNvZGVkU2l6ZSh1aW50KSB7XG4gIGlmICh1aW50IDwgdWludEJvdW5kYXJpZXNbMF0pIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICBpZiAodWludCA8IHVpbnRCb3VuZGFyaWVzWzFdKSB7XG4gICAgcmV0dXJuIDI7XG4gIH1cbiAgaWYgKHVpbnQgPCB1aW50Qm91bmRhcmllc1syXSkge1xuICAgIHJldHVybiAzO1xuICB9XG4gIGlmICh1aW50IDwgdWludEJvdW5kYXJpZXNbM10pIHtcbiAgICByZXR1cm4gNTtcbiAgfVxuICByZXR1cm4gOTtcbn07XG5lbmNvZGVVaW50LmNvbXBhcmVUb2tlbnMgPSBmdW5jdGlvbiBjb21wYXJlVG9rZW5zKHRvazEsIHRvazIpIHtcbiAgcmV0dXJuIHRvazEudmFsdWUgPCB0b2syLnZhbHVlID8gLTEgOiB0b2sxLnZhbHVlID4gdG9rMi52YWx1ZSA/IDEgOiAwO1xufTsiLCAiaW1wb3J0IHtcbiAgVG9rZW4sXG4gIFR5cGVcbn0gZnJvbSAnLi90b2tlbi5qcyc7XG5pbXBvcnQgKiBhcyB1aW50IGZyb20gJy4vMHVpbnQuanMnO1xuaW1wb3J0IHsgZGVjb2RlRXJyUHJlZml4IH0gZnJvbSAnLi9jb21tb24uanMnO1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZU5lZ2ludDgoZGF0YSwgcG9zLCBfbWlub3IsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBUb2tlbihUeXBlLm5lZ2ludCwgLTEgLSB1aW50LnJlYWRVaW50OChkYXRhLCBwb3MgKyAxLCBvcHRpb25zKSwgMik7XG59XG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlTmVnaW50MTYoZGF0YSwgcG9zLCBfbWlub3IsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBUb2tlbihUeXBlLm5lZ2ludCwgLTEgLSB1aW50LnJlYWRVaW50MTYoZGF0YSwgcG9zICsgMSwgb3B0aW9ucyksIDMpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZU5lZ2ludDMyKGRhdGEsIHBvcywgX21pbm9yLCBvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgVG9rZW4oVHlwZS5uZWdpbnQsIC0xIC0gdWludC5yZWFkVWludDMyKGRhdGEsIHBvcyArIDEsIG9wdGlvbnMpLCA1KTtcbn1cbmNvbnN0IG5lZzFiID0gQmlnSW50KC0xKTtcbmNvbnN0IHBvczFiID0gQmlnSW50KDEpO1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZU5lZ2ludDY0KGRhdGEsIHBvcywgX21pbm9yLCBvcHRpb25zKSB7XG4gIGNvbnN0IGludCA9IHVpbnQucmVhZFVpbnQ2NChkYXRhLCBwb3MgKyAxLCBvcHRpb25zKTtcbiAgaWYgKHR5cGVvZiBpbnQgIT09ICdiaWdpbnQnKSB7XG4gICAgY29uc3QgdmFsdWUgPSAtMSAtIGludDtcbiAgICBpZiAodmFsdWUgPj0gTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIpIHtcbiAgICAgIHJldHVybiBuZXcgVG9rZW4oVHlwZS5uZWdpbnQsIHZhbHVlLCA5KTtcbiAgICB9XG4gIH1cbiAgaWYgKG9wdGlvbnMuYWxsb3dCaWdJbnQgIT09IHRydWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7IGRlY29kZUVyclByZWZpeCB9IGludGVnZXJzIG91dHNpZGUgb2YgdGhlIHNhZmUgaW50ZWdlciByYW5nZSBhcmUgbm90IHN1cHBvcnRlZGApO1xuICB9XG4gIHJldHVybiBuZXcgVG9rZW4oVHlwZS5uZWdpbnQsIG5lZzFiIC0gQmlnSW50KGludCksIDkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZU5lZ2ludChidWYsIHRva2VuKSB7XG4gIGNvbnN0IG5lZ2ludCA9IHRva2VuLnZhbHVlO1xuICBjb25zdCB1bnNpZ25lZCA9IHR5cGVvZiBuZWdpbnQgPT09ICdiaWdpbnQnID8gbmVnaW50ICogbmVnMWIgLSBwb3MxYiA6IG5lZ2ludCAqIC0xIC0gMTtcbiAgdWludC5lbmNvZGVVaW50VmFsdWUoYnVmLCB0b2tlbi50eXBlLm1ham9yRW5jb2RlZCwgdW5zaWduZWQpO1xufVxuZW5jb2RlTmVnaW50LmVuY29kZWRTaXplID0gZnVuY3Rpb24gZW5jb2RlZFNpemUodG9rZW4pIHtcbiAgY29uc3QgbmVnaW50ID0gdG9rZW4udmFsdWU7XG4gIGNvbnN0IHVuc2lnbmVkID0gdHlwZW9mIG5lZ2ludCA9PT0gJ2JpZ2ludCcgPyBuZWdpbnQgKiBuZWcxYiAtIHBvczFiIDogbmVnaW50ICogLTEgLSAxO1xuICBpZiAodW5zaWduZWQgPCB1aW50LnVpbnRCb3VuZGFyaWVzWzBdKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgaWYgKHVuc2lnbmVkIDwgdWludC51aW50Qm91bmRhcmllc1sxXSkge1xuICAgIHJldHVybiAyO1xuICB9XG4gIGlmICh1bnNpZ25lZCA8IHVpbnQudWludEJvdW5kYXJpZXNbMl0pIHtcbiAgICByZXR1cm4gMztcbiAgfVxuICBpZiAodW5zaWduZWQgPCB1aW50LnVpbnRCb3VuZGFyaWVzWzNdKSB7XG4gICAgcmV0dXJuIDU7XG4gIH1cbiAgcmV0dXJuIDk7XG59O1xuZW5jb2RlTmVnaW50LmNvbXBhcmVUb2tlbnMgPSBmdW5jdGlvbiBjb21wYXJlVG9rZW5zKHRvazEsIHRvazIpIHtcbiAgcmV0dXJuIHRvazEudmFsdWUgPCB0b2syLnZhbHVlID8gMSA6IHRvazEudmFsdWUgPiB0b2syLnZhbHVlID8gLTEgOiAwO1xufTsiLCAiaW1wb3J0IHtcbiAgVG9rZW4sXG4gIFR5cGVcbn0gZnJvbSAnLi90b2tlbi5qcyc7XG5pbXBvcnQge1xuICBhc3NlcnRFbm91Z2hEYXRhLFxuICBkZWNvZGVFcnJQcmVmaXhcbn0gZnJvbSAnLi9jb21tb24uanMnO1xuaW1wb3J0ICogYXMgdWludCBmcm9tICcuLzB1aW50LmpzJztcbmltcG9ydCB7XG4gIGNvbXBhcmUsXG4gIGZyb21TdHJpbmcsXG4gIHNsaWNlXG59IGZyb20gJy4vYnl0ZS11dGlscy5qcyc7XG5mdW5jdGlvbiB0b1Rva2VuKGRhdGEsIHBvcywgcHJlZml4LCBsZW5ndGgpIHtcbiAgYXNzZXJ0RW5vdWdoRGF0YShkYXRhLCBwb3MsIHByZWZpeCArIGxlbmd0aCk7XG4gIGNvbnN0IGJ1ZiA9IHNsaWNlKGRhdGEsIHBvcyArIHByZWZpeCwgcG9zICsgcHJlZml4ICsgbGVuZ3RoKTtcbiAgcmV0dXJuIG5ldyBUb2tlbihUeXBlLmJ5dGVzLCBidWYsIHByZWZpeCArIGxlbmd0aCk7XG59XG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlQnl0ZXNDb21wYWN0KGRhdGEsIHBvcywgbWlub3IsIF9vcHRpb25zKSB7XG4gIHJldHVybiB0b1Rva2VuKGRhdGEsIHBvcywgMSwgbWlub3IpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZUJ5dGVzOChkYXRhLCBwb3MsIF9taW5vciwgb3B0aW9ucykge1xuICByZXR1cm4gdG9Ub2tlbihkYXRhLCBwb3MsIDIsIHVpbnQucmVhZFVpbnQ4KGRhdGEsIHBvcyArIDEsIG9wdGlvbnMpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVCeXRlczE2KGRhdGEsIHBvcywgX21pbm9yLCBvcHRpb25zKSB7XG4gIHJldHVybiB0b1Rva2VuKGRhdGEsIHBvcywgMywgdWludC5yZWFkVWludDE2KGRhdGEsIHBvcyArIDEsIG9wdGlvbnMpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVCeXRlczMyKGRhdGEsIHBvcywgX21pbm9yLCBvcHRpb25zKSB7XG4gIHJldHVybiB0b1Rva2VuKGRhdGEsIHBvcywgNSwgdWludC5yZWFkVWludDMyKGRhdGEsIHBvcyArIDEsIG9wdGlvbnMpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVCeXRlczY0KGRhdGEsIHBvcywgX21pbm9yLCBvcHRpb25zKSB7XG4gIGNvbnN0IGwgPSB1aW50LnJlYWRVaW50NjQoZGF0YSwgcG9zICsgMSwgb3B0aW9ucyk7XG4gIGlmICh0eXBlb2YgbCA9PT0gJ2JpZ2ludCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7IGRlY29kZUVyclByZWZpeCB9IDY0LWJpdCBpbnRlZ2VyIGJ5dGVzIGxlbmd0aHMgbm90IHN1cHBvcnRlZGApO1xuICB9XG4gIHJldHVybiB0b1Rva2VuKGRhdGEsIHBvcywgOSwgbCk7XG59XG5mdW5jdGlvbiB0b2tlbkJ5dGVzKHRva2VuKSB7XG4gIGlmICh0b2tlbi5lbmNvZGVkQnl0ZXMgPT09IHVuZGVmaW5lZCkge1xuICAgIHRva2VuLmVuY29kZWRCeXRlcyA9IHRva2VuLnR5cGUgPT09IFR5cGUuc3RyaW5nID8gZnJvbVN0cmluZyh0b2tlbi52YWx1ZSkgOiB0b2tlbi52YWx1ZTtcbiAgfVxuICByZXR1cm4gdG9rZW4uZW5jb2RlZEJ5dGVzO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZUJ5dGVzKGJ1ZiwgdG9rZW4pIHtcbiAgY29uc3QgYnl0ZXMgPSB0b2tlbkJ5dGVzKHRva2VuKTtcbiAgdWludC5lbmNvZGVVaW50VmFsdWUoYnVmLCB0b2tlbi50eXBlLm1ham9yRW5jb2RlZCwgYnl0ZXMubGVuZ3RoKTtcbiAgYnVmLnB1c2goYnl0ZXMpO1xufVxuZW5jb2RlQnl0ZXMuZW5jb2RlZFNpemUgPSBmdW5jdGlvbiBlbmNvZGVkU2l6ZSh0b2tlbikge1xuICBjb25zdCBieXRlcyA9IHRva2VuQnl0ZXModG9rZW4pO1xuICByZXR1cm4gdWludC5lbmNvZGVVaW50VmFsdWUuZW5jb2RlZFNpemUoYnl0ZXMubGVuZ3RoKSArIGJ5dGVzLmxlbmd0aDtcbn07XG5lbmNvZGVCeXRlcy5jb21wYXJlVG9rZW5zID0gZnVuY3Rpb24gY29tcGFyZVRva2Vucyh0b2sxLCB0b2syKSB7XG4gIHJldHVybiBjb21wYXJlQnl0ZXModG9rZW5CeXRlcyh0b2sxKSwgdG9rZW5CeXRlcyh0b2syKSk7XG59O1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXBhcmVCeXRlcyhiMSwgYjIpIHtcbiAgcmV0dXJuIGIxLmxlbmd0aCA8IGIyLmxlbmd0aCA/IC0xIDogYjEubGVuZ3RoID4gYjIubGVuZ3RoID8gMSA6IGNvbXBhcmUoYjEsIGIyKTtcbn0iLCAiaW1wb3J0IHtcbiAgVG9rZW4sXG4gIFR5cGVcbn0gZnJvbSAnLi90b2tlbi5qcyc7XG5pbXBvcnQge1xuICBhc3NlcnRFbm91Z2hEYXRhLFxuICBkZWNvZGVFcnJQcmVmaXhcbn0gZnJvbSAnLi9jb21tb24uanMnO1xuaW1wb3J0ICogYXMgdWludCBmcm9tICcuLzB1aW50LmpzJztcbmltcG9ydCB7IGVuY29kZUJ5dGVzIH0gZnJvbSAnLi8yYnl0ZXMuanMnO1xuaW1wb3J0IHtcbiAgdG9TdHJpbmcsXG4gIHNsaWNlXG59IGZyb20gJy4vYnl0ZS11dGlscy5qcyc7XG5mdW5jdGlvbiB0b1Rva2VuKGRhdGEsIHBvcywgcHJlZml4LCBsZW5ndGgsIG9wdGlvbnMpIHtcbiAgY29uc3QgdG90TGVuZ3RoID0gcHJlZml4ICsgbGVuZ3RoO1xuICBhc3NlcnRFbm91Z2hEYXRhKGRhdGEsIHBvcywgdG90TGVuZ3RoKTtcbiAgY29uc3QgdG9rID0gbmV3IFRva2VuKFR5cGUuc3RyaW5nLCB0b1N0cmluZyhkYXRhLCBwb3MgKyBwcmVmaXgsIHBvcyArIHRvdExlbmd0aCksIHRvdExlbmd0aCk7XG4gIGlmIChvcHRpb25zLnJldGFpblN0cmluZ0J5dGVzID09PSB0cnVlKSB7XG4gICAgdG9rLmJ5dGVWYWx1ZSA9IHNsaWNlKGRhdGEsIHBvcyArIHByZWZpeCwgcG9zICsgdG90TGVuZ3RoKTtcbiAgfVxuICByZXR1cm4gdG9rO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZVN0cmluZ0NvbXBhY3QoZGF0YSwgcG9zLCBtaW5vciwgb3B0aW9ucykge1xuICByZXR1cm4gdG9Ub2tlbihkYXRhLCBwb3MsIDEsIG1pbm9yLCBvcHRpb25zKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVTdHJpbmc4KGRhdGEsIHBvcywgX21pbm9yLCBvcHRpb25zKSB7XG4gIHJldHVybiB0b1Rva2VuKGRhdGEsIHBvcywgMiwgdWludC5yZWFkVWludDgoZGF0YSwgcG9zICsgMSwgb3B0aW9ucyksIG9wdGlvbnMpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZVN0cmluZzE2KGRhdGEsIHBvcywgX21pbm9yLCBvcHRpb25zKSB7XG4gIHJldHVybiB0b1Rva2VuKGRhdGEsIHBvcywgMywgdWludC5yZWFkVWludDE2KGRhdGEsIHBvcyArIDEsIG9wdGlvbnMpLCBvcHRpb25zKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVTdHJpbmczMihkYXRhLCBwb3MsIF9taW5vciwgb3B0aW9ucykge1xuICByZXR1cm4gdG9Ub2tlbihkYXRhLCBwb3MsIDUsIHVpbnQucmVhZFVpbnQzMihkYXRhLCBwb3MgKyAxLCBvcHRpb25zKSwgb3B0aW9ucyk7XG59XG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlU3RyaW5nNjQoZGF0YSwgcG9zLCBfbWlub3IsIG9wdGlvbnMpIHtcbiAgY29uc3QgbCA9IHVpbnQucmVhZFVpbnQ2NChkYXRhLCBwb3MgKyAxLCBvcHRpb25zKTtcbiAgaWYgKHR5cGVvZiBsID09PSAnYmlnaW50Jykge1xuICAgIHRocm93IG5ldyBFcnJvcihgJHsgZGVjb2RlRXJyUHJlZml4IH0gNjQtYml0IGludGVnZXIgc3RyaW5nIGxlbmd0aHMgbm90IHN1cHBvcnRlZGApO1xuICB9XG4gIHJldHVybiB0b1Rva2VuKGRhdGEsIHBvcywgOSwgbCwgb3B0aW9ucyk7XG59XG5leHBvcnQgY29uc3QgZW5jb2RlU3RyaW5nID0gZW5jb2RlQnl0ZXM7IiwgImltcG9ydCB7XG4gIFRva2VuLFxuICBUeXBlXG59IGZyb20gJy4vdG9rZW4uanMnO1xuaW1wb3J0ICogYXMgdWludCBmcm9tICcuLzB1aW50LmpzJztcbmltcG9ydCB7IGRlY29kZUVyclByZWZpeCB9IGZyb20gJy4vY29tbW9uLmpzJztcbmZ1bmN0aW9uIHRvVG9rZW4oX2RhdGEsIF9wb3MsIHByZWZpeCwgbGVuZ3RoKSB7XG4gIHJldHVybiBuZXcgVG9rZW4oVHlwZS5hcnJheSwgbGVuZ3RoLCBwcmVmaXgpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZUFycmF5Q29tcGFjdChkYXRhLCBwb3MsIG1pbm9yLCBfb3B0aW9ucykge1xuICByZXR1cm4gdG9Ub2tlbihkYXRhLCBwb3MsIDEsIG1pbm9yKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVBcnJheTgoZGF0YSwgcG9zLCBfbWlub3IsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHRvVG9rZW4oZGF0YSwgcG9zLCAyLCB1aW50LnJlYWRVaW50OChkYXRhLCBwb3MgKyAxLCBvcHRpb25zKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlQXJyYXkxNihkYXRhLCBwb3MsIF9taW5vciwgb3B0aW9ucykge1xuICByZXR1cm4gdG9Ub2tlbihkYXRhLCBwb3MsIDMsIHVpbnQucmVhZFVpbnQxNihkYXRhLCBwb3MgKyAxLCBvcHRpb25zKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlQXJyYXkzMihkYXRhLCBwb3MsIF9taW5vciwgb3B0aW9ucykge1xuICByZXR1cm4gdG9Ub2tlbihkYXRhLCBwb3MsIDUsIHVpbnQucmVhZFVpbnQzMihkYXRhLCBwb3MgKyAxLCBvcHRpb25zKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlQXJyYXk2NChkYXRhLCBwb3MsIF9taW5vciwgb3B0aW9ucykge1xuICBjb25zdCBsID0gdWludC5yZWFkVWludDY0KGRhdGEsIHBvcyArIDEsIG9wdGlvbnMpO1xuICBpZiAodHlwZW9mIGwgPT09ICdiaWdpbnQnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGAkeyBkZWNvZGVFcnJQcmVmaXggfSA2NC1iaXQgaW50ZWdlciBhcnJheSBsZW5ndGhzIG5vdCBzdXBwb3J0ZWRgKTtcbiAgfVxuICByZXR1cm4gdG9Ub2tlbihkYXRhLCBwb3MsIDksIGwpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZUFycmF5SW5kZWZpbml0ZShkYXRhLCBwb3MsIF9taW5vciwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucy5hbGxvd0luZGVmaW5pdGUgPT09IGZhbHNlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGAkeyBkZWNvZGVFcnJQcmVmaXggfSBpbmRlZmluaXRlIGxlbmd0aCBpdGVtcyBub3QgYWxsb3dlZGApO1xuICB9XG4gIHJldHVybiB0b1Rva2VuKGRhdGEsIHBvcywgMSwgSW5maW5pdHkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZUFycmF5KGJ1ZiwgdG9rZW4pIHtcbiAgdWludC5lbmNvZGVVaW50VmFsdWUoYnVmLCBUeXBlLmFycmF5Lm1ham9yRW5jb2RlZCwgdG9rZW4udmFsdWUpO1xufVxuZW5jb2RlQXJyYXkuY29tcGFyZVRva2VucyA9IHVpbnQuZW5jb2RlVWludC5jb21wYXJlVG9rZW5zO1xuZW5jb2RlQXJyYXkuZW5jb2RlZFNpemUgPSBmdW5jdGlvbiBlbmNvZGVkU2l6ZSh0b2tlbikge1xuICByZXR1cm4gdWludC5lbmNvZGVVaW50VmFsdWUuZW5jb2RlZFNpemUodG9rZW4udmFsdWUpO1xufTsiLCAiaW1wb3J0IHtcbiAgVG9rZW4sXG4gIFR5cGVcbn0gZnJvbSAnLi90b2tlbi5qcyc7XG5pbXBvcnQgKiBhcyB1aW50IGZyb20gJy4vMHVpbnQuanMnO1xuaW1wb3J0IHsgZGVjb2RlRXJyUHJlZml4IH0gZnJvbSAnLi9jb21tb24uanMnO1xuZnVuY3Rpb24gdG9Ub2tlbihfZGF0YSwgX3BvcywgcHJlZml4LCBsZW5ndGgpIHtcbiAgcmV0dXJuIG5ldyBUb2tlbihUeXBlLm1hcCwgbGVuZ3RoLCBwcmVmaXgpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZU1hcENvbXBhY3QoZGF0YSwgcG9zLCBtaW5vciwgX29wdGlvbnMpIHtcbiAgcmV0dXJuIHRvVG9rZW4oZGF0YSwgcG9zLCAxLCBtaW5vcik7XG59XG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlTWFwOChkYXRhLCBwb3MsIF9taW5vciwgb3B0aW9ucykge1xuICByZXR1cm4gdG9Ub2tlbihkYXRhLCBwb3MsIDIsIHVpbnQucmVhZFVpbnQ4KGRhdGEsIHBvcyArIDEsIG9wdGlvbnMpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVNYXAxNihkYXRhLCBwb3MsIF9taW5vciwgb3B0aW9ucykge1xuICByZXR1cm4gdG9Ub2tlbihkYXRhLCBwb3MsIDMsIHVpbnQucmVhZFVpbnQxNihkYXRhLCBwb3MgKyAxLCBvcHRpb25zKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlTWFwMzIoZGF0YSwgcG9zLCBfbWlub3IsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHRvVG9rZW4oZGF0YSwgcG9zLCA1LCB1aW50LnJlYWRVaW50MzIoZGF0YSwgcG9zICsgMSwgb3B0aW9ucykpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZU1hcDY0KGRhdGEsIHBvcywgX21pbm9yLCBvcHRpb25zKSB7XG4gIGNvbnN0IGwgPSB1aW50LnJlYWRVaW50NjQoZGF0YSwgcG9zICsgMSwgb3B0aW9ucyk7XG4gIGlmICh0eXBlb2YgbCA9PT0gJ2JpZ2ludCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7IGRlY29kZUVyclByZWZpeCB9IDY0LWJpdCBpbnRlZ2VyIG1hcCBsZW5ndGhzIG5vdCBzdXBwb3J0ZWRgKTtcbiAgfVxuICByZXR1cm4gdG9Ub2tlbihkYXRhLCBwb3MsIDksIGwpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZU1hcEluZGVmaW5pdGUoZGF0YSwgcG9zLCBfbWlub3IsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMuYWxsb3dJbmRlZmluaXRlID09PSBmYWxzZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgJHsgZGVjb2RlRXJyUHJlZml4IH0gaW5kZWZpbml0ZSBsZW5ndGggaXRlbXMgbm90IGFsbG93ZWRgKTtcbiAgfVxuICByZXR1cm4gdG9Ub2tlbihkYXRhLCBwb3MsIDEsIEluZmluaXR5KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGVNYXAoYnVmLCB0b2tlbikge1xuICB1aW50LmVuY29kZVVpbnRWYWx1ZShidWYsIFR5cGUubWFwLm1ham9yRW5jb2RlZCwgdG9rZW4udmFsdWUpO1xufVxuZW5jb2RlTWFwLmNvbXBhcmVUb2tlbnMgPSB1aW50LmVuY29kZVVpbnQuY29tcGFyZVRva2VucztcbmVuY29kZU1hcC5lbmNvZGVkU2l6ZSA9IGZ1bmN0aW9uIGVuY29kZWRTaXplKHRva2VuKSB7XG4gIHJldHVybiB1aW50LmVuY29kZVVpbnRWYWx1ZS5lbmNvZGVkU2l6ZSh0b2tlbi52YWx1ZSk7XG59OyIsICJpbXBvcnQge1xuICBUb2tlbixcbiAgVHlwZVxufSBmcm9tICcuL3Rva2VuLmpzJztcbmltcG9ydCAqIGFzIHVpbnQgZnJvbSAnLi8wdWludC5qcyc7XG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlVGFnQ29tcGFjdChfZGF0YSwgX3BvcywgbWlub3IsIF9vcHRpb25zKSB7XG4gIHJldHVybiBuZXcgVG9rZW4oVHlwZS50YWcsIG1pbm9yLCAxKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVUYWc4KGRhdGEsIHBvcywgX21pbm9yLCBvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgVG9rZW4oVHlwZS50YWcsIHVpbnQucmVhZFVpbnQ4KGRhdGEsIHBvcyArIDEsIG9wdGlvbnMpLCAyKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVUYWcxNihkYXRhLCBwb3MsIF9taW5vciwgb3B0aW9ucykge1xuICByZXR1cm4gbmV3IFRva2VuKFR5cGUudGFnLCB1aW50LnJlYWRVaW50MTYoZGF0YSwgcG9zICsgMSwgb3B0aW9ucyksIDMpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZVRhZzMyKGRhdGEsIHBvcywgX21pbm9yLCBvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgVG9rZW4oVHlwZS50YWcsIHVpbnQucmVhZFVpbnQzMihkYXRhLCBwb3MgKyAxLCBvcHRpb25zKSwgNSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlVGFnNjQoZGF0YSwgcG9zLCBfbWlub3IsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBUb2tlbihUeXBlLnRhZywgdWludC5yZWFkVWludDY0KGRhdGEsIHBvcyArIDEsIG9wdGlvbnMpLCA5KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGVUYWcoYnVmLCB0b2tlbikge1xuICB1aW50LmVuY29kZVVpbnRWYWx1ZShidWYsIFR5cGUudGFnLm1ham9yRW5jb2RlZCwgdG9rZW4udmFsdWUpO1xufVxuZW5jb2RlVGFnLmNvbXBhcmVUb2tlbnMgPSB1aW50LmVuY29kZVVpbnQuY29tcGFyZVRva2VucztcbmVuY29kZVRhZy5lbmNvZGVkU2l6ZSA9IGZ1bmN0aW9uIGVuY29kZWRTaXplKHRva2VuKSB7XG4gIHJldHVybiB1aW50LmVuY29kZVVpbnRWYWx1ZS5lbmNvZGVkU2l6ZSh0b2tlbi52YWx1ZSk7XG59OyIsICJpbXBvcnQge1xuICBUb2tlbixcbiAgVHlwZVxufSBmcm9tICcuL3Rva2VuLmpzJztcbmltcG9ydCB7IGRlY29kZUVyclByZWZpeCB9IGZyb20gJy4vY29tbW9uLmpzJztcbmltcG9ydCB7IGVuY29kZVVpbnQgfSBmcm9tICcuLzB1aW50LmpzJztcbmNvbnN0IE1JTk9SX0ZBTFNFID0gMjA7XG5jb25zdCBNSU5PUl9UUlVFID0gMjE7XG5jb25zdCBNSU5PUl9OVUxMID0gMjI7XG5jb25zdCBNSU5PUl9VTkRFRklORUQgPSAyMztcbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVVbmRlZmluZWQoX2RhdGEsIF9wb3MsIF9taW5vciwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucy5hbGxvd1VuZGVmaW5lZCA9PT0gZmFsc2UpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7IGRlY29kZUVyclByZWZpeCB9IHVuZGVmaW5lZCB2YWx1ZXMgYXJlIG5vdCBzdXBwb3J0ZWRgKTtcbiAgfSBlbHNlIGlmIChvcHRpb25zLmNvZXJjZVVuZGVmaW5lZFRvTnVsbCA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBuZXcgVG9rZW4oVHlwZS5udWxsLCBudWxsLCAxKTtcbiAgfVxuICByZXR1cm4gbmV3IFRva2VuKFR5cGUudW5kZWZpbmVkLCB1bmRlZmluZWQsIDEpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZUJyZWFrKF9kYXRhLCBfcG9zLCBfbWlub3IsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMuYWxsb3dJbmRlZmluaXRlID09PSBmYWxzZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgJHsgZGVjb2RlRXJyUHJlZml4IH0gaW5kZWZpbml0ZSBsZW5ndGggaXRlbXMgbm90IGFsbG93ZWRgKTtcbiAgfVxuICByZXR1cm4gbmV3IFRva2VuKFR5cGUuYnJlYWssIHVuZGVmaW5lZCwgMSk7XG59XG5mdW5jdGlvbiBjcmVhdGVUb2tlbih2YWx1ZSwgYnl0ZXMsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5hbGxvd05hTiA9PT0gZmFsc2UgJiYgTnVtYmVyLmlzTmFOKHZhbHVlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAkeyBkZWNvZGVFcnJQcmVmaXggfSBOYU4gdmFsdWVzIGFyZSBub3Qgc3VwcG9ydGVkYCk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmFsbG93SW5maW5pdHkgPT09IGZhbHNlICYmICh2YWx1ZSA9PT0gSW5maW5pdHkgfHwgdmFsdWUgPT09IC1JbmZpbml0eSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHsgZGVjb2RlRXJyUHJlZml4IH0gSW5maW5pdHkgdmFsdWVzIGFyZSBub3Qgc3VwcG9ydGVkYCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXcgVG9rZW4oVHlwZS5mbG9hdCwgdmFsdWUsIGJ5dGVzKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVGbG9hdDE2KGRhdGEsIHBvcywgX21pbm9yLCBvcHRpb25zKSB7XG4gIHJldHVybiBjcmVhdGVUb2tlbihyZWFkRmxvYXQxNihkYXRhLCBwb3MgKyAxKSwgMywgb3B0aW9ucyk7XG59XG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlRmxvYXQzMihkYXRhLCBwb3MsIF9taW5vciwgb3B0aW9ucykge1xuICByZXR1cm4gY3JlYXRlVG9rZW4ocmVhZEZsb2F0MzIoZGF0YSwgcG9zICsgMSksIDUsIG9wdGlvbnMpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZUZsb2F0NjQoZGF0YSwgcG9zLCBfbWlub3IsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGNyZWF0ZVRva2VuKHJlYWRGbG9hdDY0KGRhdGEsIHBvcyArIDEpLCA5LCBvcHRpb25zKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGVGbG9hdChidWYsIHRva2VuLCBvcHRpb25zKSB7XG4gIGNvbnN0IGZsb2F0ID0gdG9rZW4udmFsdWU7XG4gIGlmIChmbG9hdCA9PT0gZmFsc2UpIHtcbiAgICBidWYucHVzaChbVHlwZS5mbG9hdC5tYWpvckVuY29kZWQgfCBNSU5PUl9GQUxTRV0pO1xuICB9IGVsc2UgaWYgKGZsb2F0ID09PSB0cnVlKSB7XG4gICAgYnVmLnB1c2goW1R5cGUuZmxvYXQubWFqb3JFbmNvZGVkIHwgTUlOT1JfVFJVRV0pO1xuICB9IGVsc2UgaWYgKGZsb2F0ID09PSBudWxsKSB7XG4gICAgYnVmLnB1c2goW1R5cGUuZmxvYXQubWFqb3JFbmNvZGVkIHwgTUlOT1JfTlVMTF0pO1xuICB9IGVsc2UgaWYgKGZsb2F0ID09PSB1bmRlZmluZWQpIHtcbiAgICBidWYucHVzaChbVHlwZS5mbG9hdC5tYWpvckVuY29kZWQgfCBNSU5PUl9VTkRFRklORURdKTtcbiAgfSBlbHNlIHtcbiAgICBsZXQgZGVjb2RlZDtcbiAgICBsZXQgc3VjY2VzcyA9IGZhbHNlO1xuICAgIGlmICghb3B0aW9ucyB8fCBvcHRpb25zLmZsb2F0NjQgIT09IHRydWUpIHtcbiAgICAgIGVuY29kZUZsb2F0MTYoZmxvYXQpO1xuICAgICAgZGVjb2RlZCA9IHJlYWRGbG9hdDE2KHVpOGEsIDEpO1xuICAgICAgaWYgKGZsb2F0ID09PSBkZWNvZGVkIHx8IE51bWJlci5pc05hTihmbG9hdCkpIHtcbiAgICAgICAgdWk4YVswXSA9IDI0OTtcbiAgICAgICAgYnVmLnB1c2godWk4YS5zbGljZSgwLCAzKSk7XG4gICAgICAgIHN1Y2Nlc3MgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW5jb2RlRmxvYXQzMihmbG9hdCk7XG4gICAgICAgIGRlY29kZWQgPSByZWFkRmxvYXQzMih1aThhLCAxKTtcbiAgICAgICAgaWYgKGZsb2F0ID09PSBkZWNvZGVkKSB7XG4gICAgICAgICAgdWk4YVswXSA9IDI1MDtcbiAgICAgICAgICBidWYucHVzaCh1aThhLnNsaWNlKDAsIDUpKTtcbiAgICAgICAgICBzdWNjZXNzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXN1Y2Nlc3MpIHtcbiAgICAgIGVuY29kZUZsb2F0NjQoZmxvYXQpO1xuICAgICAgZGVjb2RlZCA9IHJlYWRGbG9hdDY0KHVpOGEsIDEpO1xuICAgICAgdWk4YVswXSA9IDI1MTtcbiAgICAgIGJ1Zi5wdXNoKHVpOGEuc2xpY2UoMCwgOSkpO1xuICAgIH1cbiAgfVxufVxuZW5jb2RlRmxvYXQuZW5jb2RlZFNpemUgPSBmdW5jdGlvbiBlbmNvZGVkU2l6ZSh0b2tlbiwgb3B0aW9ucykge1xuICBjb25zdCBmbG9hdCA9IHRva2VuLnZhbHVlO1xuICBpZiAoZmxvYXQgPT09IGZhbHNlIHx8IGZsb2F0ID09PSB0cnVlIHx8IGZsb2F0ID09PSBudWxsIHx8IGZsb2F0ID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICBpZiAoIW9wdGlvbnMgfHwgb3B0aW9ucy5mbG9hdDY0ICE9PSB0cnVlKSB7XG4gICAgZW5jb2RlRmxvYXQxNihmbG9hdCk7XG4gICAgbGV0IGRlY29kZWQgPSByZWFkRmxvYXQxNih1aThhLCAxKTtcbiAgICBpZiAoZmxvYXQgPT09IGRlY29kZWQgfHwgTnVtYmVyLmlzTmFOKGZsb2F0KSkge1xuICAgICAgcmV0dXJuIDM7XG4gICAgfVxuICAgIGVuY29kZUZsb2F0MzIoZmxvYXQpO1xuICAgIGRlY29kZWQgPSByZWFkRmxvYXQzMih1aThhLCAxKTtcbiAgICBpZiAoZmxvYXQgPT09IGRlY29kZWQpIHtcbiAgICAgIHJldHVybiA1O1xuICAgIH1cbiAgfVxuICByZXR1cm4gOTtcbn07XG5jb25zdCBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoOSk7XG5jb25zdCBkYXRhVmlldyA9IG5ldyBEYXRhVmlldyhidWZmZXIsIDEpO1xuY29uc3QgdWk4YSA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlciwgMCk7XG5mdW5jdGlvbiBlbmNvZGVGbG9hdDE2KGlucCkge1xuICBpZiAoaW5wID09PSBJbmZpbml0eSkge1xuICAgIGRhdGFWaWV3LnNldFVpbnQxNigwLCAzMTc0NCwgZmFsc2UpO1xuICB9IGVsc2UgaWYgKGlucCA9PT0gLUluZmluaXR5KSB7XG4gICAgZGF0YVZpZXcuc2V0VWludDE2KDAsIDY0NTEyLCBmYWxzZSk7XG4gIH0gZWxzZSBpZiAoTnVtYmVyLmlzTmFOKGlucCkpIHtcbiAgICBkYXRhVmlldy5zZXRVaW50MTYoMCwgMzIyNTYsIGZhbHNlKTtcbiAgfSBlbHNlIHtcbiAgICBkYXRhVmlldy5zZXRGbG9hdDMyKDAsIGlucCk7XG4gICAgY29uc3QgdmFsdTMyID0gZGF0YVZpZXcuZ2V0VWludDMyKDApO1xuICAgIGNvbnN0IGV4cG9uZW50ID0gKHZhbHUzMiAmIDIxMzkwOTUwNDApID4+IDIzO1xuICAgIGNvbnN0IG1hbnRpc3NhID0gdmFsdTMyICYgODM4ODYwNztcbiAgICBpZiAoZXhwb25lbnQgPT09IDI1NSkge1xuICAgICAgZGF0YVZpZXcuc2V0VWludDE2KDAsIDMxNzQ0LCBmYWxzZSk7XG4gICAgfSBlbHNlIGlmIChleHBvbmVudCA9PT0gMCkge1xuICAgICAgZGF0YVZpZXcuc2V0VWludDE2KDAsIChpbnAgJiAyMTQ3NDgzNjQ4KSA+PiAxNiB8IG1hbnRpc3NhID4+IDEzLCBmYWxzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGxvZ2ljYWxFeHBvbmVudCA9IGV4cG9uZW50IC0gMTI3O1xuICAgICAgaWYgKGxvZ2ljYWxFeHBvbmVudCA8IC0yNCkge1xuICAgICAgICBkYXRhVmlldy5zZXRVaW50MTYoMCwgMCk7XG4gICAgICB9IGVsc2UgaWYgKGxvZ2ljYWxFeHBvbmVudCA8IC0xNCkge1xuICAgICAgICBkYXRhVmlldy5zZXRVaW50MTYoMCwgKHZhbHUzMiAmIDIxNDc0ODM2NDgpID4+IDE2IHwgMSA8PCAyNCArIGxvZ2ljYWxFeHBvbmVudCwgZmFsc2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YVZpZXcuc2V0VWludDE2KDAsICh2YWx1MzIgJiAyMTQ3NDgzNjQ4KSA+PiAxNiB8IGxvZ2ljYWxFeHBvbmVudCArIDE1IDw8IDEwIHwgbWFudGlzc2EgPj4gMTMsIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHJlYWRGbG9hdDE2KHVpOGEsIHBvcykge1xuICBpZiAodWk4YS5sZW5ndGggLSBwb3MgPCAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGAkeyBkZWNvZGVFcnJQcmVmaXggfSBub3QgZW5vdWdoIGRhdGEgZm9yIGZsb2F0MTZgKTtcbiAgfVxuICBjb25zdCBoYWxmID0gKHVpOGFbcG9zXSA8PCA4KSArIHVpOGFbcG9zICsgMV07XG4gIGlmIChoYWxmID09PSAzMTc0NCkge1xuICAgIHJldHVybiBJbmZpbml0eTtcbiAgfVxuICBpZiAoaGFsZiA9PT0gNjQ1MTIpIHtcbiAgICByZXR1cm4gLUluZmluaXR5O1xuICB9XG4gIGlmIChoYWxmID09PSAzMjI1Nikge1xuICAgIHJldHVybiBOYU47XG4gIH1cbiAgY29uc3QgZXhwID0gaGFsZiA+PiAxMCAmIDMxO1xuICBjb25zdCBtYW50ID0gaGFsZiAmIDEwMjM7XG4gIGxldCB2YWw7XG4gIGlmIChleHAgPT09IDApIHtcbiAgICB2YWwgPSBtYW50ICogMiAqKiAtMjQ7XG4gIH0gZWxzZSBpZiAoZXhwICE9PSAzMSkge1xuICAgIHZhbCA9IChtYW50ICsgMTAyNCkgKiAyICoqIChleHAgLSAyNSk7XG4gIH0gZWxzZSB7XG4gICAgdmFsID0gbWFudCA9PT0gMCA/IEluZmluaXR5IDogTmFOO1xuICB9XG4gIHJldHVybiBoYWxmICYgMzI3NjggPyAtdmFsIDogdmFsO1xufVxuZnVuY3Rpb24gZW5jb2RlRmxvYXQzMihpbnApIHtcbiAgZGF0YVZpZXcuc2V0RmxvYXQzMigwLCBpbnAsIGZhbHNlKTtcbn1cbmZ1bmN0aW9uIHJlYWRGbG9hdDMyKHVpOGEsIHBvcykge1xuICBpZiAodWk4YS5sZW5ndGggLSBwb3MgPCA0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGAkeyBkZWNvZGVFcnJQcmVmaXggfSBub3QgZW5vdWdoIGRhdGEgZm9yIGZsb2F0MzJgKTtcbiAgfVxuICBjb25zdCBvZmZzZXQgPSAodWk4YS5ieXRlT2Zmc2V0IHx8IDApICsgcG9zO1xuICByZXR1cm4gbmV3IERhdGFWaWV3KHVpOGEuYnVmZmVyLCBvZmZzZXQsIDQpLmdldEZsb2F0MzIoMCwgZmFsc2UpO1xufVxuZnVuY3Rpb24gZW5jb2RlRmxvYXQ2NChpbnApIHtcbiAgZGF0YVZpZXcuc2V0RmxvYXQ2NCgwLCBpbnAsIGZhbHNlKTtcbn1cbmZ1bmN0aW9uIHJlYWRGbG9hdDY0KHVpOGEsIHBvcykge1xuICBpZiAodWk4YS5sZW5ndGggLSBwb3MgPCA4KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGAkeyBkZWNvZGVFcnJQcmVmaXggfSBub3QgZW5vdWdoIGRhdGEgZm9yIGZsb2F0NjRgKTtcbiAgfVxuICBjb25zdCBvZmZzZXQgPSAodWk4YS5ieXRlT2Zmc2V0IHx8IDApICsgcG9zO1xuICByZXR1cm4gbmV3IERhdGFWaWV3KHVpOGEuYnVmZmVyLCBvZmZzZXQsIDgpLmdldEZsb2F0NjQoMCwgZmFsc2UpO1xufVxuZW5jb2RlRmxvYXQuY29tcGFyZVRva2VucyA9IGVuY29kZVVpbnQuY29tcGFyZVRva2VuczsiLCAiaW1wb3J0IHtcbiAgVG9rZW4sXG4gIFR5cGVcbn0gZnJvbSAnLi90b2tlbi5qcyc7XG5pbXBvcnQgKiBhcyB1aW50IGZyb20gJy4vMHVpbnQuanMnO1xuaW1wb3J0ICogYXMgbmVnaW50IGZyb20gJy4vMW5lZ2ludC5qcyc7XG5pbXBvcnQgKiBhcyBieXRlcyBmcm9tICcuLzJieXRlcy5qcyc7XG5pbXBvcnQgKiBhcyBzdHJpbmcgZnJvbSAnLi8zc3RyaW5nLmpzJztcbmltcG9ydCAqIGFzIGFycmF5IGZyb20gJy4vNGFycmF5LmpzJztcbmltcG9ydCAqIGFzIG1hcCBmcm9tICcuLzVtYXAuanMnO1xuaW1wb3J0ICogYXMgdGFnIGZyb20gJy4vNnRhZy5qcyc7XG5pbXBvcnQgKiBhcyBmbG9hdCBmcm9tICcuLzdmbG9hdC5qcyc7XG5pbXBvcnQgeyBkZWNvZGVFcnJQcmVmaXggfSBmcm9tICcuL2NvbW1vbi5qcyc7XG5pbXBvcnQgeyBmcm9tQXJyYXkgfSBmcm9tICcuL2J5dGUtdXRpbHMuanMnO1xuZnVuY3Rpb24gaW52YWxpZE1pbm9yKGRhdGEsIHBvcywgbWlub3IpIHtcbiAgdGhyb3cgbmV3IEVycm9yKGAkeyBkZWNvZGVFcnJQcmVmaXggfSBlbmNvdW50ZXJlZCBpbnZhbGlkIG1pbm9yICgkeyBtaW5vciB9KSBmb3IgbWFqb3IgJHsgZGF0YVtwb3NdID4+PiA1IH1gKTtcbn1cbmZ1bmN0aW9uIGVycm9yZXIobXNnKSB7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGAkeyBkZWNvZGVFcnJQcmVmaXggfSAkeyBtc2cgfWApO1xuICB9O1xufVxuZXhwb3J0IGNvbnN0IGp1bXAgPSBbXTtcbmZvciAobGV0IGkgPSAwOyBpIDw9IDIzOyBpKyspIHtcbiAganVtcFtpXSA9IGludmFsaWRNaW5vcjtcbn1cbmp1bXBbMjRdID0gdWludC5kZWNvZGVVaW50ODtcbmp1bXBbMjVdID0gdWludC5kZWNvZGVVaW50MTY7XG5qdW1wWzI2XSA9IHVpbnQuZGVjb2RlVWludDMyO1xuanVtcFsyN10gPSB1aW50LmRlY29kZVVpbnQ2NDtcbmp1bXBbMjhdID0gaW52YWxpZE1pbm9yO1xuanVtcFsyOV0gPSBpbnZhbGlkTWlub3I7XG5qdW1wWzMwXSA9IGludmFsaWRNaW5vcjtcbmp1bXBbMzFdID0gaW52YWxpZE1pbm9yO1xuZm9yIChsZXQgaSA9IDMyOyBpIDw9IDU1OyBpKyspIHtcbiAganVtcFtpXSA9IGludmFsaWRNaW5vcjtcbn1cbmp1bXBbNTZdID0gbmVnaW50LmRlY29kZU5lZ2ludDg7XG5qdW1wWzU3XSA9IG5lZ2ludC5kZWNvZGVOZWdpbnQxNjtcbmp1bXBbNThdID0gbmVnaW50LmRlY29kZU5lZ2ludDMyO1xuanVtcFs1OV0gPSBuZWdpbnQuZGVjb2RlTmVnaW50NjQ7XG5qdW1wWzYwXSA9IGludmFsaWRNaW5vcjtcbmp1bXBbNjFdID0gaW52YWxpZE1pbm9yO1xuanVtcFs2Ml0gPSBpbnZhbGlkTWlub3I7XG5qdW1wWzYzXSA9IGludmFsaWRNaW5vcjtcbmZvciAobGV0IGkgPSA2NDsgaSA8PSA4NzsgaSsrKSB7XG4gIGp1bXBbaV0gPSBieXRlcy5kZWNvZGVCeXRlc0NvbXBhY3Q7XG59XG5qdW1wWzg4XSA9IGJ5dGVzLmRlY29kZUJ5dGVzODtcbmp1bXBbODldID0gYnl0ZXMuZGVjb2RlQnl0ZXMxNjtcbmp1bXBbOTBdID0gYnl0ZXMuZGVjb2RlQnl0ZXMzMjtcbmp1bXBbOTFdID0gYnl0ZXMuZGVjb2RlQnl0ZXM2NDtcbmp1bXBbOTJdID0gaW52YWxpZE1pbm9yO1xuanVtcFs5M10gPSBpbnZhbGlkTWlub3I7XG5qdW1wWzk0XSA9IGludmFsaWRNaW5vcjtcbmp1bXBbOTVdID0gZXJyb3JlcignaW5kZWZpbml0ZSBsZW5ndGggYnl0ZXMvc3RyaW5ncyBhcmUgbm90IHN1cHBvcnRlZCcpO1xuZm9yIChsZXQgaSA9IDk2OyBpIDw9IDExOTsgaSsrKSB7XG4gIGp1bXBbaV0gPSBzdHJpbmcuZGVjb2RlU3RyaW5nQ29tcGFjdDtcbn1cbmp1bXBbMTIwXSA9IHN0cmluZy5kZWNvZGVTdHJpbmc4O1xuanVtcFsxMjFdID0gc3RyaW5nLmRlY29kZVN0cmluZzE2O1xuanVtcFsxMjJdID0gc3RyaW5nLmRlY29kZVN0cmluZzMyO1xuanVtcFsxMjNdID0gc3RyaW5nLmRlY29kZVN0cmluZzY0O1xuanVtcFsxMjRdID0gaW52YWxpZE1pbm9yO1xuanVtcFsxMjVdID0gaW52YWxpZE1pbm9yO1xuanVtcFsxMjZdID0gaW52YWxpZE1pbm9yO1xuanVtcFsxMjddID0gZXJyb3JlcignaW5kZWZpbml0ZSBsZW5ndGggYnl0ZXMvc3RyaW5ncyBhcmUgbm90IHN1cHBvcnRlZCcpO1xuZm9yIChsZXQgaSA9IDEyODsgaSA8PSAxNTE7IGkrKykge1xuICBqdW1wW2ldID0gYXJyYXkuZGVjb2RlQXJyYXlDb21wYWN0O1xufVxuanVtcFsxNTJdID0gYXJyYXkuZGVjb2RlQXJyYXk4O1xuanVtcFsxNTNdID0gYXJyYXkuZGVjb2RlQXJyYXkxNjtcbmp1bXBbMTU0XSA9IGFycmF5LmRlY29kZUFycmF5MzI7XG5qdW1wWzE1NV0gPSBhcnJheS5kZWNvZGVBcnJheTY0O1xuanVtcFsxNTZdID0gaW52YWxpZE1pbm9yO1xuanVtcFsxNTddID0gaW52YWxpZE1pbm9yO1xuanVtcFsxNThdID0gaW52YWxpZE1pbm9yO1xuanVtcFsxNTldID0gYXJyYXkuZGVjb2RlQXJyYXlJbmRlZmluaXRlO1xuZm9yIChsZXQgaSA9IDE2MDsgaSA8PSAxODM7IGkrKykge1xuICBqdW1wW2ldID0gbWFwLmRlY29kZU1hcENvbXBhY3Q7XG59XG5qdW1wWzE4NF0gPSBtYXAuZGVjb2RlTWFwODtcbmp1bXBbMTg1XSA9IG1hcC5kZWNvZGVNYXAxNjtcbmp1bXBbMTg2XSA9IG1hcC5kZWNvZGVNYXAzMjtcbmp1bXBbMTg3XSA9IG1hcC5kZWNvZGVNYXA2NDtcbmp1bXBbMTg4XSA9IGludmFsaWRNaW5vcjtcbmp1bXBbMTg5XSA9IGludmFsaWRNaW5vcjtcbmp1bXBbMTkwXSA9IGludmFsaWRNaW5vcjtcbmp1bXBbMTkxXSA9IG1hcC5kZWNvZGVNYXBJbmRlZmluaXRlO1xuZm9yIChsZXQgaSA9IDE5MjsgaSA8PSAyMTU7IGkrKykge1xuICBqdW1wW2ldID0gdGFnLmRlY29kZVRhZ0NvbXBhY3Q7XG59XG5qdW1wWzIxNl0gPSB0YWcuZGVjb2RlVGFnODtcbmp1bXBbMjE3XSA9IHRhZy5kZWNvZGVUYWcxNjtcbmp1bXBbMjE4XSA9IHRhZy5kZWNvZGVUYWczMjtcbmp1bXBbMjE5XSA9IHRhZy5kZWNvZGVUYWc2NDtcbmp1bXBbMjIwXSA9IGludmFsaWRNaW5vcjtcbmp1bXBbMjIxXSA9IGludmFsaWRNaW5vcjtcbmp1bXBbMjIyXSA9IGludmFsaWRNaW5vcjtcbmp1bXBbMjIzXSA9IGludmFsaWRNaW5vcjtcbmZvciAobGV0IGkgPSAyMjQ7IGkgPD0gMjQzOyBpKyspIHtcbiAganVtcFtpXSA9IGVycm9yZXIoJ3NpbXBsZSB2YWx1ZXMgYXJlIG5vdCBzdXBwb3J0ZWQnKTtcbn1cbmp1bXBbMjQ0XSA9IGludmFsaWRNaW5vcjtcbmp1bXBbMjQ1XSA9IGludmFsaWRNaW5vcjtcbmp1bXBbMjQ2XSA9IGludmFsaWRNaW5vcjtcbmp1bXBbMjQ3XSA9IGZsb2F0LmRlY29kZVVuZGVmaW5lZDtcbmp1bXBbMjQ4XSA9IGVycm9yZXIoJ3NpbXBsZSB2YWx1ZXMgYXJlIG5vdCBzdXBwb3J0ZWQnKTtcbmp1bXBbMjQ5XSA9IGZsb2F0LmRlY29kZUZsb2F0MTY7XG5qdW1wWzI1MF0gPSBmbG9hdC5kZWNvZGVGbG9hdDMyO1xuanVtcFsyNTFdID0gZmxvYXQuZGVjb2RlRmxvYXQ2NDtcbmp1bXBbMjUyXSA9IGludmFsaWRNaW5vcjtcbmp1bXBbMjUzXSA9IGludmFsaWRNaW5vcjtcbmp1bXBbMjU0XSA9IGludmFsaWRNaW5vcjtcbmp1bXBbMjU1XSA9IGZsb2F0LmRlY29kZUJyZWFrO1xuZXhwb3J0IGNvbnN0IHF1aWNrID0gW107XG5mb3IgKGxldCBpID0gMDsgaSA8IDI0OyBpKyspIHtcbiAgcXVpY2tbaV0gPSBuZXcgVG9rZW4oVHlwZS51aW50LCBpLCAxKTtcbn1cbmZvciAobGV0IGkgPSAtMTsgaSA+PSAtMjQ7IGktLSkge1xuICBxdWlja1szMSAtIGldID0gbmV3IFRva2VuKFR5cGUubmVnaW50LCBpLCAxKTtcbn1cbnF1aWNrWzY0XSA9IG5ldyBUb2tlbihUeXBlLmJ5dGVzLCBuZXcgVWludDhBcnJheSgwKSwgMSk7XG5xdWlja1s5Nl0gPSBuZXcgVG9rZW4oVHlwZS5zdHJpbmcsICcnLCAxKTtcbnF1aWNrWzEyOF0gPSBuZXcgVG9rZW4oVHlwZS5hcnJheSwgMCwgMSk7XG5xdWlja1sxNjBdID0gbmV3IFRva2VuKFR5cGUubWFwLCAwLCAxKTtcbnF1aWNrWzI0NF0gPSBuZXcgVG9rZW4oVHlwZS5mYWxzZSwgZmFsc2UsIDEpO1xucXVpY2tbMjQ1XSA9IG5ldyBUb2tlbihUeXBlLnRydWUsIHRydWUsIDEpO1xucXVpY2tbMjQ2XSA9IG5ldyBUb2tlbihUeXBlLm51bGwsIG51bGwsIDEpO1xuZXhwb3J0IGZ1bmN0aW9uIHF1aWNrRW5jb2RlVG9rZW4odG9rZW4pIHtcbiAgc3dpdGNoICh0b2tlbi50eXBlKSB7XG4gIGNhc2UgVHlwZS5mYWxzZTpcbiAgICByZXR1cm4gZnJvbUFycmF5KFsyNDRdKTtcbiAgY2FzZSBUeXBlLnRydWU6XG4gICAgcmV0dXJuIGZyb21BcnJheShbMjQ1XSk7XG4gIGNhc2UgVHlwZS5udWxsOlxuICAgIHJldHVybiBmcm9tQXJyYXkoWzI0Nl0pO1xuICBjYXNlIFR5cGUuYnl0ZXM6XG4gICAgaWYgKCF0b2tlbi52YWx1ZS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmcm9tQXJyYXkoWzY0XSk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgY2FzZSBUeXBlLnN0cmluZzpcbiAgICBpZiAodG9rZW4udmFsdWUgPT09ICcnKSB7XG4gICAgICByZXR1cm4gZnJvbUFycmF5KFs5Nl0pO1xuICAgIH1cbiAgICByZXR1cm47XG4gIGNhc2UgVHlwZS5hcnJheTpcbiAgICBpZiAodG9rZW4udmFsdWUgPT09IDApIHtcbiAgICAgIHJldHVybiBmcm9tQXJyYXkoWzEyOF0pO1xuICAgIH1cbiAgICByZXR1cm47XG4gIGNhc2UgVHlwZS5tYXA6XG4gICAgaWYgKHRva2VuLnZhbHVlID09PSAwKSB7XG4gICAgICByZXR1cm4gZnJvbUFycmF5KFsxNjBdKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICBjYXNlIFR5cGUudWludDpcbiAgICBpZiAodG9rZW4udmFsdWUgPCAyNCkge1xuICAgICAgcmV0dXJuIGZyb21BcnJheShbTnVtYmVyKHRva2VuLnZhbHVlKV0pO1xuICAgIH1cbiAgICByZXR1cm47XG4gIGNhc2UgVHlwZS5uZWdpbnQ6XG4gICAgaWYgKHRva2VuLnZhbHVlID49IC0yNCkge1xuICAgICAgcmV0dXJuIGZyb21BcnJheShbMzEgLSBOdW1iZXIodG9rZW4udmFsdWUpXSk7XG4gICAgfVxuICB9XG59IiwgImltcG9ydCB7IGlzIH0gZnJvbSAnLi9pcy5qcyc7XG5pbXBvcnQge1xuICBUb2tlbixcbiAgVHlwZVxufSBmcm9tICcuL3Rva2VuLmpzJztcbmltcG9ydCB7IEJsIH0gZnJvbSAnLi9ibC5qcyc7XG5pbXBvcnQgeyBlbmNvZGVFcnJQcmVmaXggfSBmcm9tICcuL2NvbW1vbi5qcyc7XG5pbXBvcnQgeyBxdWlja0VuY29kZVRva2VuIH0gZnJvbSAnLi9qdW1wLmpzJztcbmltcG9ydCB7IGFzVThBIH0gZnJvbSAnLi9ieXRlLXV0aWxzLmpzJztcbmltcG9ydCB7IGVuY29kZVVpbnQgfSBmcm9tICcuLzB1aW50LmpzJztcbmltcG9ydCB7IGVuY29kZU5lZ2ludCB9IGZyb20gJy4vMW5lZ2ludC5qcyc7XG5pbXBvcnQgeyBlbmNvZGVCeXRlcyB9IGZyb20gJy4vMmJ5dGVzLmpzJztcbmltcG9ydCB7IGVuY29kZVN0cmluZyB9IGZyb20gJy4vM3N0cmluZy5qcyc7XG5pbXBvcnQgeyBlbmNvZGVBcnJheSB9IGZyb20gJy4vNGFycmF5LmpzJztcbmltcG9ydCB7IGVuY29kZU1hcCB9IGZyb20gJy4vNW1hcC5qcyc7XG5pbXBvcnQgeyBlbmNvZGVUYWcgfSBmcm9tICcuLzZ0YWcuanMnO1xuaW1wb3J0IHsgZW5jb2RlRmxvYXQgfSBmcm9tICcuLzdmbG9hdC5qcyc7XG5jb25zdCBkZWZhdWx0RW5jb2RlT3B0aW9ucyA9IHtcbiAgZmxvYXQ2NDogZmFsc2UsXG4gIG1hcFNvcnRlcixcbiAgcXVpY2tFbmNvZGVUb2tlblxufTtcbmV4cG9ydCBmdW5jdGlvbiBtYWtlQ2JvckVuY29kZXJzKCkge1xuICBjb25zdCBlbmNvZGVycyA9IFtdO1xuICBlbmNvZGVyc1tUeXBlLnVpbnQubWFqb3JdID0gZW5jb2RlVWludDtcbiAgZW5jb2RlcnNbVHlwZS5uZWdpbnQubWFqb3JdID0gZW5jb2RlTmVnaW50O1xuICBlbmNvZGVyc1tUeXBlLmJ5dGVzLm1ham9yXSA9IGVuY29kZUJ5dGVzO1xuICBlbmNvZGVyc1tUeXBlLnN0cmluZy5tYWpvcl0gPSBlbmNvZGVTdHJpbmc7XG4gIGVuY29kZXJzW1R5cGUuYXJyYXkubWFqb3JdID0gZW5jb2RlQXJyYXk7XG4gIGVuY29kZXJzW1R5cGUubWFwLm1ham9yXSA9IGVuY29kZU1hcDtcbiAgZW5jb2RlcnNbVHlwZS50YWcubWFqb3JdID0gZW5jb2RlVGFnO1xuICBlbmNvZGVyc1tUeXBlLmZsb2F0Lm1ham9yXSA9IGVuY29kZUZsb2F0O1xuICByZXR1cm4gZW5jb2RlcnM7XG59XG5jb25zdCBjYm9yRW5jb2RlcnMgPSBtYWtlQ2JvckVuY29kZXJzKCk7XG5jb25zdCBidWYgPSBuZXcgQmwoKTtcbmNsYXNzIFJlZiB7XG4gIGNvbnN0cnVjdG9yKG9iaiwgcGFyZW50KSB7XG4gICAgdGhpcy5vYmogPSBvYmo7XG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gIH1cbiAgaW5jbHVkZXMob2JqKSB7XG4gICAgbGV0IHAgPSB0aGlzO1xuICAgIGRvIHtcbiAgICAgIGlmIChwLm9iaiA9PT0gb2JqKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0gd2hpbGUgKHAgPSBwLnBhcmVudCk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHN0YXRpYyBjcmVhdGVDaGVjayhzdGFjaywgb2JqKSB7XG4gICAgaWYgKHN0YWNrICYmIHN0YWNrLmluY2x1ZGVzKG9iaikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHsgZW5jb2RlRXJyUHJlZml4IH0gb2JqZWN0IGNvbnRhaW5zIGNpcmN1bGFyIHJlZmVyZW5jZXNgKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBSZWYob2JqLCBzdGFjayk7XG4gIH1cbn1cbmNvbnN0IHNpbXBsZVRva2VucyA9IHtcbiAgbnVsbDogbmV3IFRva2VuKFR5cGUubnVsbCwgbnVsbCksXG4gIHVuZGVmaW5lZDogbmV3IFRva2VuKFR5cGUudW5kZWZpbmVkLCB1bmRlZmluZWQpLFxuICB0cnVlOiBuZXcgVG9rZW4oVHlwZS50cnVlLCB0cnVlKSxcbiAgZmFsc2U6IG5ldyBUb2tlbihUeXBlLmZhbHNlLCBmYWxzZSksXG4gIGVtcHR5QXJyYXk6IG5ldyBUb2tlbihUeXBlLmFycmF5LCAwKSxcbiAgZW1wdHlNYXA6IG5ldyBUb2tlbihUeXBlLm1hcCwgMClcbn07XG5jb25zdCB0eXBlRW5jb2RlcnMgPSB7XG4gIG51bWJlcihvYmosIF90eXAsIF9vcHRpb25zLCBfcmVmU3RhY2spIHtcbiAgICBpZiAoIU51bWJlci5pc0ludGVnZXIob2JqKSB8fCAhTnVtYmVyLmlzU2FmZUludGVnZXIob2JqKSkge1xuICAgICAgcmV0dXJuIG5ldyBUb2tlbihUeXBlLmZsb2F0LCBvYmopO1xuICAgIH0gZWxzZSBpZiAob2JqID49IDApIHtcbiAgICAgIHJldHVybiBuZXcgVG9rZW4oVHlwZS51aW50LCBvYmopO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IFRva2VuKFR5cGUubmVnaW50LCBvYmopO1xuICAgIH1cbiAgfSxcbiAgYmlnaW50KG9iaiwgX3R5cCwgX29wdGlvbnMsIF9yZWZTdGFjaykge1xuICAgIGlmIChvYmogPj0gQmlnSW50KDApKSB7XG4gICAgICByZXR1cm4gbmV3IFRva2VuKFR5cGUudWludCwgb2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBUb2tlbihUeXBlLm5lZ2ludCwgb2JqKTtcbiAgICB9XG4gIH0sXG4gIFVpbnQ4QXJyYXkob2JqLCBfdHlwLCBfb3B0aW9ucywgX3JlZlN0YWNrKSB7XG4gICAgcmV0dXJuIG5ldyBUb2tlbihUeXBlLmJ5dGVzLCBvYmopO1xuICB9LFxuICBzdHJpbmcob2JqLCBfdHlwLCBfb3B0aW9ucywgX3JlZlN0YWNrKSB7XG4gICAgcmV0dXJuIG5ldyBUb2tlbihUeXBlLnN0cmluZywgb2JqKTtcbiAgfSxcbiAgYm9vbGVhbihvYmosIF90eXAsIF9vcHRpb25zLCBfcmVmU3RhY2spIHtcbiAgICByZXR1cm4gb2JqID8gc2ltcGxlVG9rZW5zLnRydWUgOiBzaW1wbGVUb2tlbnMuZmFsc2U7XG4gIH0sXG4gIG51bGwoX29iaiwgX3R5cCwgX29wdGlvbnMsIF9yZWZTdGFjaykge1xuICAgIHJldHVybiBzaW1wbGVUb2tlbnMubnVsbDtcbiAgfSxcbiAgdW5kZWZpbmVkKF9vYmosIF90eXAsIF9vcHRpb25zLCBfcmVmU3RhY2spIHtcbiAgICByZXR1cm4gc2ltcGxlVG9rZW5zLnVuZGVmaW5lZDtcbiAgfSxcbiAgQXJyYXlCdWZmZXIob2JqLCBfdHlwLCBfb3B0aW9ucywgX3JlZlN0YWNrKSB7XG4gICAgcmV0dXJuIG5ldyBUb2tlbihUeXBlLmJ5dGVzLCBuZXcgVWludDhBcnJheShvYmopKTtcbiAgfSxcbiAgRGF0YVZpZXcob2JqLCBfdHlwLCBfb3B0aW9ucywgX3JlZlN0YWNrKSB7XG4gICAgcmV0dXJuIG5ldyBUb2tlbihUeXBlLmJ5dGVzLCBuZXcgVWludDhBcnJheShvYmouYnVmZmVyLCBvYmouYnl0ZU9mZnNldCwgb2JqLmJ5dGVMZW5ndGgpKTtcbiAgfSxcbiAgQXJyYXkob2JqLCBfdHlwLCBvcHRpb25zLCByZWZTdGFjaykge1xuICAgIGlmICghb2JqLmxlbmd0aCkge1xuICAgICAgaWYgKG9wdGlvbnMuYWRkQnJlYWtUb2tlbnMgPT09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICBzaW1wbGVUb2tlbnMuZW1wdHlBcnJheSxcbiAgICAgICAgICBuZXcgVG9rZW4oVHlwZS5icmVhaylcbiAgICAgICAgXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzaW1wbGVUb2tlbnMuZW1wdHlBcnJheTtcbiAgICB9XG4gICAgcmVmU3RhY2sgPSBSZWYuY3JlYXRlQ2hlY2socmVmU3RhY2ssIG9iaik7XG4gICAgY29uc3QgZW50cmllcyA9IFtdO1xuICAgIGxldCBpID0gMDtcbiAgICBmb3IgKGNvbnN0IGUgb2Ygb2JqKSB7XG4gICAgICBlbnRyaWVzW2krK10gPSBvYmplY3RUb1Rva2VucyhlLCBvcHRpb25zLCByZWZTdGFjayk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmFkZEJyZWFrVG9rZW5zKSB7XG4gICAgICByZXR1cm4gW1xuICAgICAgICBuZXcgVG9rZW4oVHlwZS5hcnJheSwgb2JqLmxlbmd0aCksXG4gICAgICAgIGVudHJpZXMsXG4gICAgICAgIG5ldyBUb2tlbihUeXBlLmJyZWFrKVxuICAgICAgXTtcbiAgICB9XG4gICAgcmV0dXJuIFtcbiAgICAgIG5ldyBUb2tlbihUeXBlLmFycmF5LCBvYmoubGVuZ3RoKSxcbiAgICAgIGVudHJpZXNcbiAgICBdO1xuICB9LFxuICBPYmplY3Qob2JqLCB0eXAsIG9wdGlvbnMsIHJlZlN0YWNrKSB7XG4gICAgY29uc3QgaXNNYXAgPSB0eXAgIT09ICdPYmplY3QnO1xuICAgIGNvbnN0IGtleXMgPSBpc01hcCA/IG9iai5rZXlzKCkgOiBPYmplY3Qua2V5cyhvYmopO1xuICAgIGNvbnN0IGxlbmd0aCA9IGlzTWFwID8gb2JqLnNpemUgOiBrZXlzLmxlbmd0aDtcbiAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgaWYgKG9wdGlvbnMuYWRkQnJlYWtUb2tlbnMgPT09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICBzaW1wbGVUb2tlbnMuZW1wdHlNYXAsXG4gICAgICAgICAgbmV3IFRva2VuKFR5cGUuYnJlYWspXG4gICAgICAgIF07XG4gICAgICB9XG4gICAgICByZXR1cm4gc2ltcGxlVG9rZW5zLmVtcHR5TWFwO1xuICAgIH1cbiAgICByZWZTdGFjayA9IFJlZi5jcmVhdGVDaGVjayhyZWZTdGFjaywgb2JqKTtcbiAgICBjb25zdCBlbnRyaWVzID0gW107XG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgIGVudHJpZXNbaSsrXSA9IFtcbiAgICAgICAgb2JqZWN0VG9Ub2tlbnMoa2V5LCBvcHRpb25zLCByZWZTdGFjayksXG4gICAgICAgIG9iamVjdFRvVG9rZW5zKGlzTWFwID8gb2JqLmdldChrZXkpIDogb2JqW2tleV0sIG9wdGlvbnMsIHJlZlN0YWNrKVxuICAgICAgXTtcbiAgICB9XG4gICAgc29ydE1hcEVudHJpZXMoZW50cmllcywgb3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMuYWRkQnJlYWtUb2tlbnMpIHtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIG5ldyBUb2tlbihUeXBlLm1hcCwgbGVuZ3RoKSxcbiAgICAgICAgZW50cmllcyxcbiAgICAgICAgbmV3IFRva2VuKFR5cGUuYnJlYWspXG4gICAgICBdO1xuICAgIH1cbiAgICByZXR1cm4gW1xuICAgICAgbmV3IFRva2VuKFR5cGUubWFwLCBsZW5ndGgpLFxuICAgICAgZW50cmllc1xuICAgIF07XG4gIH1cbn07XG50eXBlRW5jb2RlcnMuTWFwID0gdHlwZUVuY29kZXJzLk9iamVjdDtcbnR5cGVFbmNvZGVycy5CdWZmZXIgPSB0eXBlRW5jb2RlcnMuVWludDhBcnJheTtcbmZvciAoY29uc3QgdHlwIG9mICdVaW50OENsYW1wZWQgVWludDE2IFVpbnQzMiBJbnQ4IEludDE2IEludDMyIEJpZ1VpbnQ2NCBCaWdJbnQ2NCBGbG9hdDMyIEZsb2F0NjQnLnNwbGl0KCcgJykpIHtcbiAgdHlwZUVuY29kZXJzW2AkeyB0eXAgfUFycmF5YF0gPSB0eXBlRW5jb2RlcnMuRGF0YVZpZXc7XG59XG5mdW5jdGlvbiBvYmplY3RUb1Rva2VucyhvYmosIG9wdGlvbnMgPSB7fSwgcmVmU3RhY2spIHtcbiAgY29uc3QgdHlwID0gaXMob2JqKTtcbiAgY29uc3QgY3VzdG9tVHlwZUVuY29kZXIgPSBvcHRpb25zICYmIG9wdGlvbnMudHlwZUVuY29kZXJzICYmIG9wdGlvbnMudHlwZUVuY29kZXJzW3R5cF0gfHwgdHlwZUVuY29kZXJzW3R5cF07XG4gIGlmICh0eXBlb2YgY3VzdG9tVHlwZUVuY29kZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjb25zdCB0b2tlbnMgPSBjdXN0b21UeXBlRW5jb2RlcihvYmosIHR5cCwgb3B0aW9ucywgcmVmU3RhY2spO1xuICAgIGlmICh0b2tlbnMgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRva2VucztcbiAgICB9XG4gIH1cbiAgY29uc3QgdHlwZUVuY29kZXIgPSB0eXBlRW5jb2RlcnNbdHlwXTtcbiAgaWYgKCF0eXBlRW5jb2Rlcikge1xuICAgIHRocm93IG5ldyBFcnJvcihgJHsgZW5jb2RlRXJyUHJlZml4IH0gdW5zdXBwb3J0ZWQgdHlwZTogJHsgdHlwIH1gKTtcbiAgfVxuICByZXR1cm4gdHlwZUVuY29kZXIob2JqLCB0eXAsIG9wdGlvbnMsIHJlZlN0YWNrKTtcbn1cbmZ1bmN0aW9uIHNvcnRNYXBFbnRyaWVzKGVudHJpZXMsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMubWFwU29ydGVyKSB7XG4gICAgZW50cmllcy5zb3J0KG9wdGlvbnMubWFwU29ydGVyKTtcbiAgfVxufVxuZnVuY3Rpb24gbWFwU29ydGVyKGUxLCBlMikge1xuICBjb25zdCBrZXlUb2tlbjEgPSBBcnJheS5pc0FycmF5KGUxWzBdKSA/IGUxWzBdWzBdIDogZTFbMF07XG4gIGNvbnN0IGtleVRva2VuMiA9IEFycmF5LmlzQXJyYXkoZTJbMF0pID8gZTJbMF1bMF0gOiBlMlswXTtcbiAgaWYgKGtleVRva2VuMS50eXBlICE9PSBrZXlUb2tlbjIudHlwZSkge1xuICAgIHJldHVybiBrZXlUb2tlbjEudHlwZS5jb21wYXJlKGtleVRva2VuMi50eXBlKTtcbiAgfVxuICBjb25zdCBtYWpvciA9IGtleVRva2VuMS50eXBlLm1ham9yO1xuICBjb25zdCB0Y21wID0gY2JvckVuY29kZXJzW21ham9yXS5jb21wYXJlVG9rZW5zKGtleVRva2VuMSwga2V5VG9rZW4yKTtcbiAgaWYgKHRjbXAgPT09IDApIHtcbiAgICBjb25zb2xlLndhcm4oJ1dBUk5JTkc6IGNvbXBsZXgga2V5IHR5cGVzIHVzZWQsIENCT1Iga2V5IHNvcnRpbmcgZ3VhcmFudGVlcyBhcmUgZ29uZScpO1xuICB9XG4gIHJldHVybiB0Y21wO1xufVxuZnVuY3Rpb24gdG9rZW5zVG9FbmNvZGVkKGJ1ZiwgdG9rZW5zLCBlbmNvZGVycywgb3B0aW9ucykge1xuICBpZiAoQXJyYXkuaXNBcnJheSh0b2tlbnMpKSB7XG4gICAgZm9yIChjb25zdCB0b2tlbiBvZiB0b2tlbnMpIHtcbiAgICAgIHRva2Vuc1RvRW5jb2RlZChidWYsIHRva2VuLCBlbmNvZGVycywgb3B0aW9ucyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGVuY29kZXJzW3Rva2Vucy50eXBlLm1ham9yXShidWYsIHRva2Vucywgb3B0aW9ucyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGVuY29kZUN1c3RvbShkYXRhLCBlbmNvZGVycywgb3B0aW9ucykge1xuICBjb25zdCB0b2tlbnMgPSBvYmplY3RUb1Rva2VucyhkYXRhLCBvcHRpb25zKTtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHRva2VucykgJiYgb3B0aW9ucy5xdWlja0VuY29kZVRva2VuKSB7XG4gICAgY29uc3QgcXVpY2tCeXRlcyA9IG9wdGlvbnMucXVpY2tFbmNvZGVUb2tlbih0b2tlbnMpO1xuICAgIGlmIChxdWlja0J5dGVzKSB7XG4gICAgICByZXR1cm4gcXVpY2tCeXRlcztcbiAgICB9XG4gICAgY29uc3QgZW5jb2RlciA9IGVuY29kZXJzW3Rva2Vucy50eXBlLm1ham9yXTtcbiAgICBpZiAoZW5jb2Rlci5lbmNvZGVkU2l6ZSkge1xuICAgICAgY29uc3Qgc2l6ZSA9IGVuY29kZXIuZW5jb2RlZFNpemUodG9rZW5zLCBvcHRpb25zKTtcbiAgICAgIGNvbnN0IGJ1ZiA9IG5ldyBCbChzaXplKTtcbiAgICAgIGVuY29kZXIoYnVmLCB0b2tlbnMsIG9wdGlvbnMpO1xuICAgICAgaWYgKGJ1Zi5jaHVua3MubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBlcnJvcjogcHJlLWNhbGN1bGF0ZWQgbGVuZ3RoIGZvciAkeyB0b2tlbnMgfSB3YXMgd3JvbmdgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhc1U4QShidWYuY2h1bmtzWzBdKTtcbiAgICB9XG4gIH1cbiAgYnVmLnJlc2V0KCk7XG4gIHRva2Vuc1RvRW5jb2RlZChidWYsIHRva2VucywgZW5jb2RlcnMsIG9wdGlvbnMpO1xuICByZXR1cm4gYnVmLnRvQnl0ZXModHJ1ZSk7XG59XG5mdW5jdGlvbiBlbmNvZGUoZGF0YSwgb3B0aW9ucykge1xuICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdEVuY29kZU9wdGlvbnMsIG9wdGlvbnMpO1xuICByZXR1cm4gZW5jb2RlQ3VzdG9tKGRhdGEsIGNib3JFbmNvZGVycywgb3B0aW9ucyk7XG59XG5leHBvcnQge1xuICBvYmplY3RUb1Rva2VucyxcbiAgZW5jb2RlLFxuICBlbmNvZGVDdXN0b20sXG4gIFJlZlxufTsiLCAiaW1wb3J0IHsgZGVjb2RlRXJyUHJlZml4IH0gZnJvbSAnLi9jb21tb24uanMnO1xuaW1wb3J0IHsgVHlwZSB9IGZyb20gJy4vdG9rZW4uanMnO1xuaW1wb3J0IHtcbiAganVtcCxcbiAgcXVpY2tcbn0gZnJvbSAnLi9qdW1wLmpzJztcbmNvbnN0IGRlZmF1bHREZWNvZGVPcHRpb25zID0ge1xuICBzdHJpY3Q6IGZhbHNlLFxuICBhbGxvd0luZGVmaW5pdGU6IHRydWUsXG4gIGFsbG93VW5kZWZpbmVkOiB0cnVlLFxuICBhbGxvd0JpZ0ludDogdHJ1ZVxufTtcbmNsYXNzIFRva2VuaXNlciB7XG4gIGNvbnN0cnVjdG9yKGRhdGEsIG9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMucG9zID0gMDtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH1cbiAgZG9uZSgpIHtcbiAgICByZXR1cm4gdGhpcy5wb3MgPj0gdGhpcy5kYXRhLmxlbmd0aDtcbiAgfVxuICBuZXh0KCkge1xuICAgIGNvbnN0IGJ5dCA9IHRoaXMuZGF0YVt0aGlzLnBvc107XG4gICAgbGV0IHRva2VuID0gcXVpY2tbYnl0XTtcbiAgICBpZiAodG9rZW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgZGVjb2RlciA9IGp1bXBbYnl0XTtcbiAgICAgIGlmICghZGVjb2Rlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7IGRlY29kZUVyclByZWZpeCB9IG5vIGRlY29kZXIgZm9yIG1ham9yIHR5cGUgJHsgYnl0ID4+PiA1IH0gKGJ5dGUgMHgkeyBieXQudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykgfSlgKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1pbm9yID0gYnl0ICYgMzE7XG4gICAgICB0b2tlbiA9IGRlY29kZXIodGhpcy5kYXRhLCB0aGlzLnBvcywgbWlub3IsIHRoaXMub3B0aW9ucyk7XG4gICAgfVxuICAgIHRoaXMucG9zICs9IHRva2VuLmVuY29kZWRMZW5ndGg7XG4gICAgcmV0dXJuIHRva2VuO1xuICB9XG59XG5jb25zdCBET05FID0gU3ltYm9sLmZvcignRE9ORScpO1xuY29uc3QgQlJFQUsgPSBTeW1ib2wuZm9yKCdCUkVBSycpO1xuZnVuY3Rpb24gdG9rZW5Ub0FycmF5KHRva2VuLCB0b2tlbmlzZXIsIG9wdGlvbnMpIHtcbiAgY29uc3QgYXJyID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdG9rZW4udmFsdWU7IGkrKykge1xuICAgIGNvbnN0IHZhbHVlID0gdG9rZW5zVG9PYmplY3QodG9rZW5pc2VyLCBvcHRpb25zKTtcbiAgICBpZiAodmFsdWUgPT09IEJSRUFLKSB7XG4gICAgICBpZiAodG9rZW4udmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGAkeyBkZWNvZGVFcnJQcmVmaXggfSBnb3QgdW5leHBlY3RlZCBicmVhayB0byBsZW5ndGhlZCBhcnJheWApO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPT09IERPTkUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHsgZGVjb2RlRXJyUHJlZml4IH0gZm91bmQgYXJyYXkgYnV0IG5vdCBlbm91Z2ggZW50cmllcyAoZ290ICR7IGkgfSwgZXhwZWN0ZWQgJHsgdG9rZW4udmFsdWUgfSlgKTtcbiAgICB9XG4gICAgYXJyW2ldID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIGFycjtcbn1cbmZ1bmN0aW9uIHRva2VuVG9NYXAodG9rZW4sIHRva2VuaXNlciwgb3B0aW9ucykge1xuICBjb25zdCB1c2VNYXBzID0gb3B0aW9ucy51c2VNYXBzID09PSB0cnVlO1xuICBjb25zdCBvYmogPSB1c2VNYXBzID8gdW5kZWZpbmVkIDoge307XG4gIGNvbnN0IG0gPSB1c2VNYXBzID8gbmV3IE1hcCgpIDogdW5kZWZpbmVkO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHRva2VuLnZhbHVlOyBpKyspIHtcbiAgICBjb25zdCBrZXkgPSB0b2tlbnNUb09iamVjdCh0b2tlbmlzZXIsIG9wdGlvbnMpO1xuICAgIGlmIChrZXkgPT09IEJSRUFLKSB7XG4gICAgICBpZiAodG9rZW4udmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGAkeyBkZWNvZGVFcnJQcmVmaXggfSBnb3QgdW5leHBlY3RlZCBicmVhayB0byBsZW5ndGhlZCBtYXBgKTtcbiAgICB9XG4gICAgaWYgKGtleSA9PT0gRE9ORSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAkeyBkZWNvZGVFcnJQcmVmaXggfSBmb3VuZCBtYXAgYnV0IG5vdCBlbm91Z2ggZW50cmllcyAoZ290ICR7IGkgfSBbbm8ga2V5XSwgZXhwZWN0ZWQgJHsgdG9rZW4udmFsdWUgfSlgKTtcbiAgICB9XG4gICAgaWYgKHVzZU1hcHMgIT09IHRydWUgJiYgdHlwZW9mIGtleSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHsgZGVjb2RlRXJyUHJlZml4IH0gbm9uLXN0cmluZyBrZXlzIG5vdCBzdXBwb3J0ZWQgKGdvdCAkeyB0eXBlb2Yga2V5IH0pYCk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnJlamVjdER1cGxpY2F0ZU1hcEtleXMgPT09IHRydWUpIHtcbiAgICAgIGlmICh1c2VNYXBzICYmIG0uaGFzKGtleSkgfHwgIXVzZU1hcHMgJiYga2V5IGluIG9iaikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7IGRlY29kZUVyclByZWZpeCB9IGZvdW5kIHJlcGVhdCBtYXAga2V5IFwiJHsga2V5IH1cImApO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB2YWx1ZSA9IHRva2Vuc1RvT2JqZWN0KHRva2VuaXNlciwgb3B0aW9ucyk7XG4gICAgaWYgKHZhbHVlID09PSBET05FKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7IGRlY29kZUVyclByZWZpeCB9IGZvdW5kIG1hcCBidXQgbm90IGVub3VnaCBlbnRyaWVzIChnb3QgJHsgaSB9IFtubyB2YWx1ZV0sIGV4cGVjdGVkICR7IHRva2VuLnZhbHVlIH0pYCk7XG4gICAgfVxuICAgIGlmICh1c2VNYXBzKSB7XG4gICAgICBtLnNldChrZXksIHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHVzZU1hcHMgPyBtIDogb2JqO1xufVxuZnVuY3Rpb24gdG9rZW5zVG9PYmplY3QodG9rZW5pc2VyLCBvcHRpb25zKSB7XG4gIGlmICh0b2tlbmlzZXIuZG9uZSgpKSB7XG4gICAgcmV0dXJuIERPTkU7XG4gIH1cbiAgY29uc3QgdG9rZW4gPSB0b2tlbmlzZXIubmV4dCgpO1xuICBpZiAodG9rZW4udHlwZSA9PT0gVHlwZS5icmVhaykge1xuICAgIHJldHVybiBCUkVBSztcbiAgfVxuICBpZiAodG9rZW4udHlwZS50ZXJtaW5hbCkge1xuICAgIHJldHVybiB0b2tlbi52YWx1ZTtcbiAgfVxuICBpZiAodG9rZW4udHlwZSA9PT0gVHlwZS5hcnJheSkge1xuICAgIHJldHVybiB0b2tlblRvQXJyYXkodG9rZW4sIHRva2VuaXNlciwgb3B0aW9ucyk7XG4gIH1cbiAgaWYgKHRva2VuLnR5cGUgPT09IFR5cGUubWFwKSB7XG4gICAgcmV0dXJuIHRva2VuVG9NYXAodG9rZW4sIHRva2VuaXNlciwgb3B0aW9ucyk7XG4gIH1cbiAgaWYgKHRva2VuLnR5cGUgPT09IFR5cGUudGFnKSB7XG4gICAgaWYgKG9wdGlvbnMudGFncyAmJiB0eXBlb2Ygb3B0aW9ucy50YWdzW3Rva2VuLnZhbHVlXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29uc3QgdGFnZ2VkID0gdG9rZW5zVG9PYmplY3QodG9rZW5pc2VyLCBvcHRpb25zKTtcbiAgICAgIHJldHVybiBvcHRpb25zLnRhZ3NbdG9rZW4udmFsdWVdKHRhZ2dlZCk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgJHsgZGVjb2RlRXJyUHJlZml4IH0gdGFnIG5vdCBzdXBwb3J0ZWQgKCR7IHRva2VuLnZhbHVlIH0pYCk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKCd1bnN1cHBvcnRlZCcpO1xufVxuZnVuY3Rpb24gZGVjb2RlKGRhdGEsIG9wdGlvbnMpIHtcbiAgaWYgKCEoZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGAkeyBkZWNvZGVFcnJQcmVmaXggfSBkYXRhIHRvIGRlY29kZSBtdXN0IGJlIGEgVWludDhBcnJheWApO1xuICB9XG4gIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0RGVjb2RlT3B0aW9ucywgb3B0aW9ucyk7XG4gIGNvbnN0IHRva2VuaXNlciA9IG9wdGlvbnMudG9rZW5pemVyIHx8IG5ldyBUb2tlbmlzZXIoZGF0YSwgb3B0aW9ucyk7XG4gIGNvbnN0IGRlY29kZWQgPSB0b2tlbnNUb09iamVjdCh0b2tlbmlzZXIsIG9wdGlvbnMpO1xuICBpZiAoZGVjb2RlZCA9PT0gRE9ORSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgJHsgZGVjb2RlRXJyUHJlZml4IH0gZGlkIG5vdCBmaW5kIGFueSBjb250ZW50IHRvIGRlY29kZWApO1xuICB9XG4gIGlmIChkZWNvZGVkID09PSBCUkVBSykge1xuICAgIHRocm93IG5ldyBFcnJvcihgJHsgZGVjb2RlRXJyUHJlZml4IH0gZ290IHVuZXhwZWN0ZWQgYnJlYWtgKTtcbiAgfVxuICBpZiAoIXRva2VuaXNlci5kb25lKCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7IGRlY29kZUVyclByZWZpeCB9IHRvbyBtYW55IHRlcm1pbmFscywgZGF0YSBtYWtlcyBubyBzZW5zZWApO1xuICB9XG4gIHJldHVybiBkZWNvZGVkO1xufVxuZXhwb3J0IHtcbiAgVG9rZW5pc2VyLFxuICB0b2tlbnNUb09iamVjdCxcbiAgZGVjb2RlXG59OyIsICJpbXBvcnQgKiBhcyBjYm9yZyBmcm9tICdjYm9yZyc7XG5pbXBvcnQgeyBDSUQgfSBmcm9tICdtdWx0aWZvcm1hdHMvY2lkJztcbmNvbnN0IENJRF9DQk9SX1RBRyA9IDQyO1xuZnVuY3Rpb24gY2lkRW5jb2RlcihvYmopIHtcbiAgaWYgKG9iai5hc0NJRCAhPT0gb2JqKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgY2lkID0gQ0lELmFzQ0lEKG9iaik7XG4gIGlmICghY2lkKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShjaWQuYnl0ZXMuYnl0ZUxlbmd0aCArIDEpO1xuICBieXRlcy5zZXQoY2lkLmJ5dGVzLCAxKTtcbiAgcmV0dXJuIFtcbiAgICBuZXcgY2JvcmcuVG9rZW4oY2JvcmcuVHlwZS50YWcsIENJRF9DQk9SX1RBRyksXG4gICAgbmV3IGNib3JnLlRva2VuKGNib3JnLlR5cGUuYnl0ZXMsIGJ5dGVzKVxuICBdO1xufVxuZnVuY3Rpb24gdW5kZWZpbmVkRW5jb2RlcigpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdgdW5kZWZpbmVkYCBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBJUExEIERhdGEgTW9kZWwgYW5kIGNhbm5vdCBiZSBlbmNvZGVkJyk7XG59XG5mdW5jdGlvbiBudW1iZXJFbmNvZGVyKG51bSkge1xuICBpZiAoTnVtYmVyLmlzTmFOKG51bSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2BOYU5gIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIElQTEQgRGF0YSBNb2RlbCBhbmQgY2Fubm90IGJlIGVuY29kZWQnKTtcbiAgfVxuICBpZiAobnVtID09PSBJbmZpbml0eSB8fCBudW0gPT09IC1JbmZpbml0eSkge1xuICAgIHRocm93IG5ldyBFcnJvcignYEluZmluaXR5YCBhbmQgYC1JbmZpbml0eWAgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgSVBMRCBEYXRhIE1vZGVsIGFuZCBjYW5ub3QgYmUgZW5jb2RlZCcpO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuY29uc3QgZW5jb2RlT3B0aW9ucyA9IHtcbiAgZmxvYXQ2NDogdHJ1ZSxcbiAgdHlwZUVuY29kZXJzOiB7XG4gICAgT2JqZWN0OiBjaWRFbmNvZGVyLFxuICAgIHVuZGVmaW5lZDogdW5kZWZpbmVkRW5jb2RlcixcbiAgICBudW1iZXI6IG51bWJlckVuY29kZXJcbiAgfVxufTtcbmZ1bmN0aW9uIGNpZERlY29kZXIoYnl0ZXMpIHtcbiAgaWYgKGJ5dGVzWzBdICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIENJRCBmb3IgQ0JPUiB0YWcgNDI7IGV4cGVjdGVkIGxlYWRpbmcgMHgwMCcpO1xuICB9XG4gIHJldHVybiBDSUQuZGVjb2RlKGJ5dGVzLnN1YmFycmF5KDEpKTtcbn1cbmNvbnN0IGRlY29kZU9wdGlvbnMgPSB7XG4gIGFsbG93SW5kZWZpbml0ZTogZmFsc2UsXG4gIGNvZXJjZVVuZGVmaW5lZFRvTnVsbDogdHJ1ZSxcbiAgYWxsb3dOYU46IGZhbHNlLFxuICBhbGxvd0luZmluaXR5OiBmYWxzZSxcbiAgYWxsb3dCaWdJbnQ6IHRydWUsXG4gIHN0cmljdDogdHJ1ZSxcbiAgdXNlTWFwczogZmFsc2UsXG4gIHRhZ3M6IFtdXG59O1xuZGVjb2RlT3B0aW9ucy50YWdzW0NJRF9DQk9SX1RBR10gPSBjaWREZWNvZGVyO1xuZXhwb3J0IGNvbnN0IG5hbWUgPSAnZGFnLWNib3InO1xuZXhwb3J0IGNvbnN0IGNvZGUgPSAxMTM7XG5leHBvcnQgY29uc3QgZW5jb2RlID0gbm9kZSA9PiBjYm9yZy5lbmNvZGUobm9kZSwgZW5jb2RlT3B0aW9ucyk7XG5leHBvcnQgY29uc3QgZGVjb2RlID0gZGF0YSA9PiBjYm9yZy5kZWNvZGUoZGF0YSwgZGVjb2RlT3B0aW9ucyk7IiwgImltcG9ydCB7XG4gIGFzeW5jSXRlcmFibGVSZWFkZXIsXG4gIGJ5dGVzUmVhZGVyLFxuICBjcmVhdGVEZWNvZGVyXG59IGZyb20gJy4vZGVjb2Rlci5qcyc7XG5leHBvcnQgY2xhc3MgQ2FyUmVhZGVyIHtcbiAgY29uc3RydWN0b3IodmVyc2lvbiwgcm9vdHMsIGJsb2Nrcykge1xuICAgIHRoaXMuX3ZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIHRoaXMuX3Jvb3RzID0gcm9vdHM7XG4gICAgdGhpcy5fYmxvY2tzID0gYmxvY2tzO1xuICAgIHRoaXMuX2tleXMgPSBibG9ja3MubWFwKGIgPT4gYi5jaWQudG9TdHJpbmcoKSk7XG4gIH1cbiAgZ2V0IHZlcnNpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZlcnNpb247XG4gIH1cbiAgYXN5bmMgZ2V0Um9vdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jvb3RzO1xuICB9XG4gIGFzeW5jIGhhcyhrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5fa2V5cy5pbmRleE9mKGtleS50b1N0cmluZygpKSA+IC0xO1xuICB9XG4gIGFzeW5jIGdldChrZXkpIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuX2tleXMuaW5kZXhPZihrZXkudG9TdHJpbmcoKSk7XG4gICAgcmV0dXJuIGluZGV4ID4gLTEgPyB0aGlzLl9ibG9ja3NbaW5kZXhdIDogdW5kZWZpbmVkO1xuICB9XG4gIGFzeW5jICpibG9ja3MoKSB7XG4gICAgZm9yIChjb25zdCBibG9jayBvZiB0aGlzLl9ibG9ja3MpIHtcbiAgICAgIHlpZWxkIGJsb2NrO1xuICAgIH1cbiAgfVxuICBhc3luYyAqY2lkcygpIHtcbiAgICBmb3IgKGNvbnN0IGJsb2NrIG9mIHRoaXMuX2Jsb2Nrcykge1xuICAgICAgeWllbGQgYmxvY2suY2lkO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgYXN5bmMgZnJvbUJ5dGVzKGJ5dGVzKSB7XG4gICAgaWYgKCEoYnl0ZXMgaW5zdGFuY2VvZiBVaW50OEFycmF5KSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZnJvbUJ5dGVzKCkgcmVxdWlyZXMgYSBVaW50OEFycmF5Jyk7XG4gICAgfVxuICAgIHJldHVybiBkZWNvZGVSZWFkZXJDb21wbGV0ZShieXRlc1JlYWRlcihieXRlcykpO1xuICB9XG4gIHN0YXRpYyBhc3luYyBmcm9tSXRlcmFibGUoYXN5bmNJdGVyYWJsZSkge1xuICAgIGlmICghYXN5bmNJdGVyYWJsZSB8fCAhKHR5cGVvZiBhc3luY0l0ZXJhYmxlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2Zyb21JdGVyYWJsZSgpIHJlcXVpcmVzIGFuIGFzeW5jIGl0ZXJhYmxlJyk7XG4gICAgfVxuICAgIHJldHVybiBkZWNvZGVSZWFkZXJDb21wbGV0ZShhc3luY0l0ZXJhYmxlUmVhZGVyKGFzeW5jSXRlcmFibGUpKTtcbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gZGVjb2RlUmVhZGVyQ29tcGxldGUocmVhZGVyKSB7XG4gIGNvbnN0IGRlY29kZXIgPSBjcmVhdGVEZWNvZGVyKHJlYWRlcik7XG4gIGNvbnN0IHt2ZXJzaW9uLCByb290c30gPSBhd2FpdCBkZWNvZGVyLmhlYWRlcigpO1xuICBjb25zdCBibG9ja3MgPSBbXTtcbiAgZm9yIGF3YWl0IChjb25zdCBibG9jayBvZiBkZWNvZGVyLmJsb2NrcygpKSB7XG4gICAgYmxvY2tzLnB1c2goYmxvY2spO1xuICB9XG4gIHJldHVybiBuZXcgQ2FyUmVhZGVyKHZlcnNpb24sIHJvb3RzLCBibG9ja3MpO1xufVxuZXhwb3J0IGNvbnN0IF9fYnJvd3NlciA9IHRydWU7IiwgImltcG9ydCB7XG4gIGFzeW5jSXRlcmFibGVSZWFkZXIsXG4gIGJ5dGVzUmVhZGVyLFxuICBjcmVhdGVEZWNvZGVyXG59IGZyb20gJy4vZGVjb2Rlci5qcyc7XG5leHBvcnQgY2xhc3MgQ2FySW5kZXhlciB7XG4gIGNvbnN0cnVjdG9yKHZlcnNpb24sIHJvb3RzLCBpdGVyYXRvcikge1xuICAgIHRoaXMuX3ZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIHRoaXMuX3Jvb3RzID0gcm9vdHM7XG4gICAgdGhpcy5faXRlcmF0b3IgPSBpdGVyYXRvcjtcbiAgfVxuICBnZXQgdmVyc2lvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fdmVyc2lvbjtcbiAgfVxuICBhc3luYyBnZXRSb290cygpIHtcbiAgICByZXR1cm4gdGhpcy5fcm9vdHM7XG4gIH1cbiAgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcbiAgICByZXR1cm4gdGhpcy5faXRlcmF0b3I7XG4gIH1cbiAgc3RhdGljIGFzeW5jIGZyb21CeXRlcyhieXRlcykge1xuICAgIGlmICghKGJ5dGVzIGluc3RhbmNlb2YgVWludDhBcnJheSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2Zyb21CeXRlcygpIHJlcXVpcmVzIGEgVWludDhBcnJheScpO1xuICAgIH1cbiAgICByZXR1cm4gZGVjb2RlSW5kZXhlckNvbXBsZXRlKGJ5dGVzUmVhZGVyKGJ5dGVzKSk7XG4gIH1cbiAgc3RhdGljIGFzeW5jIGZyb21JdGVyYWJsZShhc3luY0l0ZXJhYmxlKSB7XG4gICAgaWYgKCFhc3luY0l0ZXJhYmxlIHx8ICEodHlwZW9mIGFzeW5jSXRlcmFibGVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID09PSAnZnVuY3Rpb24nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZnJvbUl0ZXJhYmxlKCkgcmVxdWlyZXMgYW4gYXN5bmMgaXRlcmFibGUnKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlY29kZUluZGV4ZXJDb21wbGV0ZShhc3luY0l0ZXJhYmxlUmVhZGVyKGFzeW5jSXRlcmFibGUpKTtcbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gZGVjb2RlSW5kZXhlckNvbXBsZXRlKHJlYWRlcikge1xuICBjb25zdCBkZWNvZGVyID0gY3JlYXRlRGVjb2RlcihyZWFkZXIpO1xuICBjb25zdCB7dmVyc2lvbiwgcm9vdHN9ID0gYXdhaXQgZGVjb2Rlci5oZWFkZXIoKTtcbiAgcmV0dXJuIG5ldyBDYXJJbmRleGVyKHZlcnNpb24sIHJvb3RzLCBkZWNvZGVyLmJsb2Nrc0luZGV4KCkpO1xufSIsICJpbXBvcnQge1xuICBhc3luY0l0ZXJhYmxlUmVhZGVyLFxuICBieXRlc1JlYWRlcixcbiAgY3JlYXRlRGVjb2RlclxufSBmcm9tICcuL2RlY29kZXIuanMnO1xuZXhwb3J0IGNsYXNzIENhckl0ZXJhdG9yQmFzZSB7XG4gIGNvbnN0cnVjdG9yKHZlcnNpb24sIHJvb3RzLCBpdGVyYWJsZSkge1xuICAgIHRoaXMuX3ZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIHRoaXMuX3Jvb3RzID0gcm9vdHM7XG4gICAgdGhpcy5faXRlcmFibGUgPSBpdGVyYWJsZTtcbiAgICB0aGlzLl9kZWNvZGVkID0gZmFsc2U7XG4gIH1cbiAgZ2V0IHZlcnNpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZlcnNpb247XG4gIH1cbiAgYXN5bmMgZ2V0Um9vdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jvb3RzO1xuICB9XG59XG5leHBvcnQgY2xhc3MgQ2FyQmxvY2tJdGVyYXRvciBleHRlbmRzIENhckl0ZXJhdG9yQmFzZSB7XG4gIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG4gICAgaWYgKHRoaXMuX2RlY29kZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGRlY29kZSBtb3JlIHRoYW4gb25jZScpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX2l0ZXJhYmxlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Jsb2NrIGl0ZXJhYmxlIG5vdCBmb3VuZCcpO1xuICAgIH1cbiAgICB0aGlzLl9kZWNvZGVkID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcy5faXRlcmFibGVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCk7XG4gIH1cbiAgc3RhdGljIGFzeW5jIGZyb21CeXRlcyhieXRlcykge1xuICAgIGNvbnN0IHt2ZXJzaW9uLCByb290cywgaXRlcmF0b3J9ID0gYXdhaXQgZnJvbUJ5dGVzKGJ5dGVzKTtcbiAgICByZXR1cm4gbmV3IENhckJsb2NrSXRlcmF0b3IodmVyc2lvbiwgcm9vdHMsIGl0ZXJhdG9yKTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgZnJvbUl0ZXJhYmxlKGFzeW5jSXRlcmFibGUpIHtcbiAgICBjb25zdCB7dmVyc2lvbiwgcm9vdHMsIGl0ZXJhdG9yfSA9IGF3YWl0IGZyb21JdGVyYWJsZShhc3luY0l0ZXJhYmxlKTtcbiAgICByZXR1cm4gbmV3IENhckJsb2NrSXRlcmF0b3IodmVyc2lvbiwgcm9vdHMsIGl0ZXJhdG9yKTtcbiAgfVxufVxuZXhwb3J0IGNsYXNzIENhckNJREl0ZXJhdG9yIGV4dGVuZHMgQ2FySXRlcmF0b3JCYXNlIHtcbiAgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcbiAgICBpZiAodGhpcy5fZGVjb2RlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZGVjb2RlIG1vcmUgdGhhbiBvbmNlJyk7XG4gICAgfVxuICAgIGlmICghdGhpcy5faXRlcmFibGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQmxvY2sgaXRlcmFibGUgbm90IGZvdW5kJyk7XG4gICAgfVxuICAgIHRoaXMuX2RlY29kZWQgPSB0cnVlO1xuICAgIGNvbnN0IGl0ZXJhYmxlID0gdGhpcy5faXRlcmFibGVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFzeW5jIG5leHQoKSB7XG4gICAgICAgIGNvbnN0IG5leHQgPSBhd2FpdCBpdGVyYWJsZS5uZXh0KCk7XG4gICAgICAgIGlmIChuZXh0LmRvbmUpIHtcbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICAgIHZhbHVlOiBuZXh0LnZhbHVlLmNpZFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgc3RhdGljIGFzeW5jIGZyb21CeXRlcyhieXRlcykge1xuICAgIGNvbnN0IHt2ZXJzaW9uLCByb290cywgaXRlcmF0b3J9ID0gYXdhaXQgZnJvbUJ5dGVzKGJ5dGVzKTtcbiAgICByZXR1cm4gbmV3IENhckNJREl0ZXJhdG9yKHZlcnNpb24sIHJvb3RzLCBpdGVyYXRvcik7XG4gIH1cbiAgc3RhdGljIGFzeW5jIGZyb21JdGVyYWJsZShhc3luY0l0ZXJhYmxlKSB7XG4gICAgY29uc3Qge3ZlcnNpb24sIHJvb3RzLCBpdGVyYXRvcn0gPSBhd2FpdCBmcm9tSXRlcmFibGUoYXN5bmNJdGVyYWJsZSk7XG4gICAgcmV0dXJuIG5ldyBDYXJDSURJdGVyYXRvcih2ZXJzaW9uLCByb290cywgaXRlcmF0b3IpO1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiBmcm9tQnl0ZXMoYnl0ZXMpIHtcbiAgaWYgKCEoYnl0ZXMgaW5zdGFuY2VvZiBVaW50OEFycmF5KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2Zyb21CeXRlcygpIHJlcXVpcmVzIGEgVWludDhBcnJheScpO1xuICB9XG4gIHJldHVybiBkZWNvZGVJdGVyYXRvcihieXRlc1JlYWRlcihieXRlcykpO1xufVxuYXN5bmMgZnVuY3Rpb24gZnJvbUl0ZXJhYmxlKGFzeW5jSXRlcmFibGUpIHtcbiAgaWYgKCFhc3luY0l0ZXJhYmxlIHx8ICEodHlwZW9mIGFzeW5jSXRlcmFibGVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID09PSAnZnVuY3Rpb24nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2Zyb21JdGVyYWJsZSgpIHJlcXVpcmVzIGFuIGFzeW5jIGl0ZXJhYmxlJyk7XG4gIH1cbiAgcmV0dXJuIGRlY29kZUl0ZXJhdG9yKGFzeW5jSXRlcmFibGVSZWFkZXIoYXN5bmNJdGVyYWJsZSkpO1xufVxuYXN5bmMgZnVuY3Rpb24gZGVjb2RlSXRlcmF0b3IocmVhZGVyKSB7XG4gIGNvbnN0IGRlY29kZXIgPSBjcmVhdGVEZWNvZGVyKHJlYWRlcik7XG4gIGNvbnN0IHt2ZXJzaW9uLCByb290c30gPSBhd2FpdCBkZWNvZGVyLmhlYWRlcigpO1xuICByZXR1cm4ge1xuICAgIHZlcnNpb24sXG4gICAgcm9vdHMsXG4gICAgaXRlcmF0b3I6IGRlY29kZXIuYmxvY2tzKClcbiAgfTtcbn0iLCAiaW1wb3J0IGZzIGZyb20gJ2ZzJztcbmltcG9ydCB7IHByb21pc2lmeSB9IGZyb20gJ3V0aWwnO1xuaW1wb3J0IHsgQ2FyV3JpdGVyIGFzIEJyb3dzZXJDYXJXcml0ZXIgfSBmcm9tICcuL3dyaXRlci1icm93c2VyLmpzJztcbmltcG9ydCB7XG4gIHJlYWRIZWFkZXIsXG4gIGNodW5rUmVhZGVyXG59IGZyb20gJy4vZGVjb2Rlci5qcyc7XG5pbXBvcnQgeyBjcmVhdGVIZWFkZXIgfSBmcm9tICcuL2VuY29kZXIuanMnO1xuY29uc3QgZnNyZWFkID0gcHJvbWlzaWZ5KGZzLnJlYWQpO1xuY29uc3QgZnN3cml0ZSA9IHByb21pc2lmeShmcy53cml0ZSk7XG5leHBvcnQgY2xhc3MgQ2FyV3JpdGVyIGV4dGVuZHMgQnJvd3NlckNhcldyaXRlciB7XG4gIHN0YXRpYyBhc3luYyB1cGRhdGVSb290c0luRmlsZShmZCwgcm9vdHMpIHtcbiAgICBjb25zdCBjaHVua1NpemUgPSAyNTY7XG4gICAgbGV0IGJ5dGVzO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGxldCByZWFkQ2h1bms7XG4gICAgaWYgKHR5cGVvZiBmZCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJlYWRDaHVuayA9IGFzeW5jICgpID0+IChhd2FpdCBmc3JlYWQoZmQsIGJ5dGVzLCAwLCBjaHVua1NpemUsIG9mZnNldCkpLmJ5dGVzUmVhZDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBmZCA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGZkLnJlYWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJlYWRDaHVuayA9IGFzeW5jICgpID0+IChhd2FpdCBmZC5yZWFkKGJ5dGVzLCAwLCBjaHVua1NpemUsIG9mZnNldCkpLmJ5dGVzUmVhZDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQmFkIGZkJyk7XG4gICAgfVxuICAgIGNvbnN0IGZkUmVhZGVyID0gY2h1bmtSZWFkZXIoYXN5bmMgKCkgPT4ge1xuICAgICAgYnl0ZXMgPSBuZXcgVWludDhBcnJheShjaHVua1NpemUpO1xuICAgICAgY29uc3QgcmVhZCA9IGF3YWl0IHJlYWRDaHVuaygpO1xuICAgICAgb2Zmc2V0ICs9IHJlYWQ7XG4gICAgICByZXR1cm4gcmVhZCA8IGNodW5rU2l6ZSA/IGJ5dGVzLnN1YmFycmF5KDAsIHJlYWQpIDogYnl0ZXM7XG4gICAgfSk7XG4gICAgYXdhaXQgcmVhZEhlYWRlcihmZFJlYWRlcik7XG4gICAgY29uc3QgbmV3SGVhZGVyID0gY3JlYXRlSGVhZGVyKHJvb3RzKTtcbiAgICBpZiAoZmRSZWFkZXIucG9zICE9PSBuZXdIZWFkZXIubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVwZGF0ZVJvb3RzKCkgY2FuIG9ubHkgb3ZlcndyaXRlIGEgaGVhZGVyIG9mIHRoZSBzYW1lIGxlbmd0aCAob2xkIGhlYWRlciBpcyAkeyBmZFJlYWRlci5wb3MgfSBieXRlcywgbmV3IGhlYWRlciBpcyAkeyBuZXdIZWFkZXIubGVuZ3RoIH0gYnl0ZXMpYCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZmQgPT09ICdudW1iZXInKSB7XG4gICAgICBhd2FpdCBmc3dyaXRlKGZkLCBuZXdIZWFkZXIsIDAsIG5ld0hlYWRlci5sZW5ndGgsIDApO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGZkID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgZmQucmVhZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgYXdhaXQgZmQud3JpdGUobmV3SGVhZGVyLCAwLCBuZXdIZWFkZXIubGVuZ3RoLCAwKTtcbiAgICB9XG4gIH1cbn1cbmV4cG9ydCBjb25zdCBfX2Jyb3dzZXIgPSBmYWxzZTsiLCAiaW1wb3J0IHZhcmludCBmcm9tICd2YXJpbnQnO1xuaW1wb3J0IHsgZW5jb2RlIGFzIGRhZ0Nib3JFbmNvZGUgfSBmcm9tICdAaXBsZC9kYWctY2Jvcic7XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlSGVhZGVyKHJvb3RzKSB7XG4gIGNvbnN0IGhlYWRlckJ5dGVzID0gZGFnQ2JvckVuY29kZSh7XG4gICAgdmVyc2lvbjogMSxcbiAgICByb290c1xuICB9KTtcbiAgY29uc3QgdmFyaW50Qnl0ZXMgPSB2YXJpbnQuZW5jb2RlKGhlYWRlckJ5dGVzLmxlbmd0aCk7XG4gIGNvbnN0IGhlYWRlciA9IG5ldyBVaW50OEFycmF5KHZhcmludEJ5dGVzLmxlbmd0aCArIGhlYWRlckJ5dGVzLmxlbmd0aCk7XG4gIGhlYWRlci5zZXQodmFyaW50Qnl0ZXMsIDApO1xuICBoZWFkZXIuc2V0KGhlYWRlckJ5dGVzLCB2YXJpbnRCeXRlcy5sZW5ndGgpO1xuICByZXR1cm4gaGVhZGVyO1xufVxuZnVuY3Rpb24gY3JlYXRlRW5jb2Rlcih3cml0ZXIpIHtcbiAgcmV0dXJuIHtcbiAgICBhc3luYyBzZXRSb290cyhyb290cykge1xuICAgICAgY29uc3QgYnl0ZXMgPSBjcmVhdGVIZWFkZXIocm9vdHMpO1xuICAgICAgYXdhaXQgd3JpdGVyLndyaXRlKGJ5dGVzKTtcbiAgICB9LFxuICAgIGFzeW5jIHdyaXRlQmxvY2soYmxvY2spIHtcbiAgICAgIGNvbnN0IHtjaWQsIGJ5dGVzfSA9IGJsb2NrO1xuICAgICAgYXdhaXQgd3JpdGVyLndyaXRlKG5ldyBVaW50OEFycmF5KHZhcmludC5lbmNvZGUoY2lkLmJ5dGVzLmxlbmd0aCArIGJ5dGVzLmxlbmd0aCkpKTtcbiAgICAgIGF3YWl0IHdyaXRlci53cml0ZShjaWQuYnl0ZXMpO1xuICAgICAgaWYgKGJ5dGVzLmxlbmd0aCkge1xuICAgICAgICBhd2FpdCB3cml0ZXIud3JpdGUoYnl0ZXMpO1xuICAgICAgfVxuICAgIH0sXG4gICAgYXN5bmMgY2xvc2UoKSB7XG4gICAgICByZXR1cm4gd3JpdGVyLmVuZCgpO1xuICAgIH1cbiAgfTtcbn1cbmV4cG9ydCB7XG4gIGNyZWF0ZUVuY29kZXJcbn07IiwgImZ1bmN0aW9uIG5vb3AoKSB7XG59XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlKCkge1xuICBjb25zdCBjaHVua1F1ZXVlID0gW107XG4gIGxldCBkcmFpbmVyID0gbnVsbDtcbiAgbGV0IGRyYWluZXJSZXNvbHZlciA9IG5vb3A7XG4gIGxldCBlbmRlZCA9IGZhbHNlO1xuICBsZXQgb3V0V2FpdCA9IG51bGw7XG4gIGxldCBvdXRXYWl0UmVzb2x2ZXIgPSBub29wO1xuICBjb25zdCBtYWtlRHJhaW5lciA9ICgpID0+IHtcbiAgICBpZiAoIWRyYWluZXIpIHtcbiAgICAgIGRyYWluZXIgPSBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgZHJhaW5lclJlc29sdmVyID0gKCkgPT4ge1xuICAgICAgICAgIGRyYWluZXIgPSBudWxsO1xuICAgICAgICAgIGRyYWluZXJSZXNvbHZlciA9IG5vb3A7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBkcmFpbmVyO1xuICB9O1xuICBjb25zdCB3cml0ZXIgPSB7XG4gICAgd3JpdGUoY2h1bmspIHtcbiAgICAgIGNodW5rUXVldWUucHVzaChjaHVuayk7XG4gICAgICBjb25zdCBkcmFpbmVyID0gbWFrZURyYWluZXIoKTtcbiAgICAgIG91dFdhaXRSZXNvbHZlcigpO1xuICAgICAgcmV0dXJuIGRyYWluZXI7XG4gICAgfSxcbiAgICBhc3luYyBlbmQoKSB7XG4gICAgICBlbmRlZCA9IHRydWU7XG4gICAgICBjb25zdCBkcmFpbmVyID0gbWFrZURyYWluZXIoKTtcbiAgICAgIG91dFdhaXRSZXNvbHZlcigpO1xuICAgICAgcmV0dXJuIGRyYWluZXI7XG4gICAgfVxuICB9O1xuICBjb25zdCBpdGVyYXRvciA9IHtcbiAgICBhc3luYyBuZXh0KCkge1xuICAgICAgY29uc3QgY2h1bmsgPSBjaHVua1F1ZXVlLnNoaWZ0KCk7XG4gICAgICBpZiAoY2h1bmspIHtcbiAgICAgICAgaWYgKGNodW5rUXVldWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgZHJhaW5lclJlc29sdmVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkb25lOiBmYWxzZSxcbiAgICAgICAgICB2YWx1ZTogY2h1bmtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmIChlbmRlZCkge1xuICAgICAgICBkcmFpbmVyUmVzb2x2ZXIoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkb25lOiB0cnVlLFxuICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWRcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmICghb3V0V2FpdCkge1xuICAgICAgICBvdXRXYWl0ID0gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgb3V0V2FpdFJlc29sdmVyID0gKCkgPT4ge1xuICAgICAgICAgICAgb3V0V2FpdCA9IG51bGw7XG4gICAgICAgICAgICBvdXRXYWl0UmVzb2x2ZXIgPSBub29wO1xuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoaXRlcmF0b3IubmV4dCgpKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvdXRXYWl0O1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHtcbiAgICB3cml0ZXIsXG4gICAgaXRlcmF0b3JcbiAgfTtcbn0iLCAiaW1wb3J0IHsgQ0lEIH0gZnJvbSAnbXVsdGlmb3JtYXRzL2NpZCc7XG5pbXBvcnQge1xuICBjcmVhdGVFbmNvZGVyLFxuICBjcmVhdGVIZWFkZXJcbn0gZnJvbSAnLi9lbmNvZGVyLmpzJztcbmltcG9ydCB7IGNyZWF0ZSBhcyBpdGVyYXRvckNoYW5uZWwgfSBmcm9tICcuL2l0ZXJhdG9yLWNoYW5uZWwuanMnO1xuaW1wb3J0IHtcbiAgYnl0ZXNSZWFkZXIsXG4gIHJlYWRIZWFkZXJcbn0gZnJvbSAnLi9kZWNvZGVyLmpzJztcbmV4cG9ydCBjbGFzcyBDYXJXcml0ZXIge1xuICBjb25zdHJ1Y3Rvcihyb290cywgZW5jb2Rlcikge1xuICAgIHRoaXMuX2VuY29kZXIgPSBlbmNvZGVyO1xuICAgIHRoaXMuX211dGV4ID0gZW5jb2Rlci5zZXRSb290cyhyb290cyk7XG4gICAgdGhpcy5fZW5kZWQgPSBmYWxzZTtcbiAgfVxuICBhc3luYyBwdXQoYmxvY2spIHtcbiAgICBpZiAoIShibG9jay5ieXRlcyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHx8ICFibG9jay5jaWQpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NhbiBvbmx5IHdyaXRlIHtjaWQsIGJ5dGVzfSBvYmplY3RzJyk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9lbmRlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBbHJlYWR5IGNsb3NlZCcpO1xuICAgIH1cbiAgICBjb25zdCBjaWQgPSBDSUQuYXNDSUQoYmxvY2suY2lkKTtcbiAgICBpZiAoIWNpZCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2FuIG9ubHkgd3JpdGUge2NpZCwgYnl0ZXN9IG9iamVjdHMnKTtcbiAgICB9XG4gICAgdGhpcy5fbXV0ZXggPSB0aGlzLl9tdXRleC50aGVuKCgpID0+IHRoaXMuX2VuY29kZXIud3JpdGVCbG9jayh7XG4gICAgICBjaWQsXG4gICAgICBieXRlczogYmxvY2suYnl0ZXNcbiAgICB9KSk7XG4gICAgcmV0dXJuIHRoaXMuX211dGV4O1xuICB9XG4gIGFzeW5jIGNsb3NlKCkge1xuICAgIGlmICh0aGlzLl9lbmRlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBbHJlYWR5IGNsb3NlZCcpO1xuICAgIH1cbiAgICBhd2FpdCB0aGlzLl9tdXRleDtcbiAgICB0aGlzLl9lbmRlZCA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXMuX2VuY29kZXIuY2xvc2UoKTtcbiAgfVxuICBzdGF0aWMgY3JlYXRlKHJvb3RzKSB7XG4gICAgcm9vdHMgPSB0b1Jvb3RzKHJvb3RzKTtcbiAgICBjb25zdCB7ZW5jb2RlciwgaXRlcmF0b3J9ID0gZW5jb2RlV3JpdGVyKCk7XG4gICAgY29uc3Qgd3JpdGVyID0gbmV3IENhcldyaXRlcihyb290cywgZW5jb2Rlcik7XG4gICAgY29uc3Qgb3V0ID0gbmV3IENhcldyaXRlck91dChpdGVyYXRvcik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdyaXRlcixcbiAgICAgIG91dFxuICAgIH07XG4gIH1cbiAgc3RhdGljIGNyZWF0ZUFwcGVuZGVyKCkge1xuICAgIGNvbnN0IHtlbmNvZGVyLCBpdGVyYXRvcn0gPSBlbmNvZGVXcml0ZXIoKTtcbiAgICBlbmNvZGVyLnNldFJvb3RzID0gKCkgPT4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgY29uc3Qgd3JpdGVyID0gbmV3IENhcldyaXRlcihbXSwgZW5jb2Rlcik7XG4gICAgY29uc3Qgb3V0ID0gbmV3IENhcldyaXRlck91dChpdGVyYXRvcik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdyaXRlcixcbiAgICAgIG91dFxuICAgIH07XG4gIH1cbiAgc3RhdGljIGFzeW5jIHVwZGF0ZVJvb3RzSW5CeXRlcyhieXRlcywgcm9vdHMpIHtcbiAgICBjb25zdCByZWFkZXIgPSBieXRlc1JlYWRlcihieXRlcyk7XG4gICAgYXdhaXQgcmVhZEhlYWRlcihyZWFkZXIpO1xuICAgIGNvbnN0IG5ld0hlYWRlciA9IGNyZWF0ZUhlYWRlcihyb290cyk7XG4gICAgaWYgKHJlYWRlci5wb3MgIT09IG5ld0hlYWRlci5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdXBkYXRlUm9vdHMoKSBjYW4gb25seSBvdmVyd3JpdGUgYSBoZWFkZXIgb2YgdGhlIHNhbWUgbGVuZ3RoIChvbGQgaGVhZGVyIGlzICR7IHJlYWRlci5wb3MgfSBieXRlcywgbmV3IGhlYWRlciBpcyAkeyBuZXdIZWFkZXIubGVuZ3RoIH0gYnl0ZXMpYCk7XG4gICAgfVxuICAgIGJ5dGVzLnNldChuZXdIZWFkZXIsIDApO1xuICAgIHJldHVybiBieXRlcztcbiAgfVxufVxuZXhwb3J0IGNsYXNzIENhcldyaXRlck91dCB7XG4gIGNvbnN0cnVjdG9yKGl0ZXJhdG9yKSB7XG4gICAgdGhpcy5faXRlcmF0b3IgPSBpdGVyYXRvcjtcbiAgfVxuICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgIGlmICh0aGlzLl9pdGVyYXRpbmcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTXVsdGlwbGUgaXRlcmF0b3Igbm90IHN1cHBvcnRlZCcpO1xuICAgIH1cbiAgICB0aGlzLl9pdGVyYXRpbmcgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzLl9pdGVyYXRvcjtcbiAgfVxufVxuZnVuY3Rpb24gZW5jb2RlV3JpdGVyKCkge1xuICBjb25zdCBpdyA9IGl0ZXJhdG9yQ2hhbm5lbCgpO1xuICBjb25zdCB7d3JpdGVyLCBpdGVyYXRvcn0gPSBpdztcbiAgY29uc3QgZW5jb2RlciA9IGNyZWF0ZUVuY29kZXIod3JpdGVyKTtcbiAgcmV0dXJuIHtcbiAgICBlbmNvZGVyLFxuICAgIGl0ZXJhdG9yXG4gIH07XG59XG5mdW5jdGlvbiB0b1Jvb3RzKHJvb3RzKSB7XG4gIGlmIChyb290cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGlmICghQXJyYXkuaXNBcnJheShyb290cykpIHtcbiAgICBjb25zdCBjaWQgPSBDSUQuYXNDSUQocm9vdHMpO1xuICAgIGlmICghY2lkKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdyb290cyBtdXN0IGJlIGEgc2luZ2xlIENJRCBvciBhbiBhcnJheSBvZiBDSURzJyk7XG4gICAgfVxuICAgIHJldHVybiBbY2lkXTtcbiAgfVxuICBjb25zdCBfcm9vdHMgPSBbXTtcbiAgZm9yIChjb25zdCByb290IG9mIHJvb3RzKSB7XG4gICAgY29uc3QgX3Jvb3QgPSBDSUQuYXNDSUQocm9vdCk7XG4gICAgaWYgKCFfcm9vdCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncm9vdHMgbXVzdCBiZSBhIHNpbmdsZSBDSUQgb3IgYW4gYXJyYXkgb2YgQ0lEcycpO1xuICAgIH1cbiAgICBfcm9vdHMucHVzaChfcm9vdCk7XG4gIH1cbiAgcmV0dXJuIF9yb290cztcbn1cbmV4cG9ydCBjb25zdCBfX2Jyb3dzZXIgPSB0cnVlOyIsICJpbXBvcnQgKiBhcyBEaWdlc3QgZnJvbSAnLi9kaWdlc3QuanMnO1xuZXhwb3J0IGNvbnN0IGZyb20gPSAoe25hbWUsIGNvZGUsIGVuY29kZX0pID0+IG5ldyBIYXNoZXIobmFtZSwgY29kZSwgZW5jb2RlKTtcbmV4cG9ydCBjbGFzcyBIYXNoZXIge1xuICBjb25zdHJ1Y3RvcihuYW1lLCBjb2RlLCBlbmNvZGUpIHtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgdGhpcy5lbmNvZGUgPSBlbmNvZGU7XG4gIH1cbiAgZGlnZXN0KGlucHV0KSB7XG4gICAgaWYgKGlucHV0IGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5lbmNvZGUoaW5wdXQpO1xuICAgICAgcmV0dXJuIHJlc3VsdCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgPyBEaWdlc3QuY3JlYXRlKHRoaXMuY29kZSwgcmVzdWx0KSA6IHJlc3VsdC50aGVuKGRpZ2VzdCA9PiBEaWdlc3QuY3JlYXRlKHRoaXMuY29kZSwgZGlnZXN0KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IEVycm9yKCdVbmtub3duIHR5cGUsIG11c3QgYmUgYmluYXJ5IHR5cGUnKTtcbiAgICB9XG4gIH1cbn0iLCAiaW1wb3J0IHtcbiAgYnl0ZXMgYXMgYmluYXJ5LFxuICBDSURcbn0gZnJvbSAnLi9pbmRleC5qcyc7XG5jb25zdCByZWFkb25seSA9ICh7ZW51bWVyYWJsZSA9IHRydWUsIGNvbmZpZ3VyYWJsZSA9IGZhbHNlfSA9IHt9KSA9PiAoe1xuICBlbnVtZXJhYmxlLFxuICBjb25maWd1cmFibGUsXG4gIHdyaXRhYmxlOiBmYWxzZVxufSk7XG5jb25zdCBsaW5rcyA9IGZ1bmN0aW9uKiAoc291cmNlLCBiYXNlKSB7XG4gIGlmIChzb3VyY2UgPT0gbnVsbClcbiAgICByZXR1cm47XG4gIGlmIChzb3VyY2UgaW5zdGFuY2VvZiBVaW50OEFycmF5KVxuICAgIHJldHVybjtcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoc291cmNlKSkge1xuICAgIGNvbnN0IHBhdGggPSBbXG4gICAgICAuLi5iYXNlLFxuICAgICAga2V5XG4gICAgXTtcbiAgICBpZiAodmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgZm9yIChjb25zdCBbaW5kZXgsIGVsZW1lbnRdIG9mIHZhbHVlLmVudHJpZXMoKSkge1xuICAgICAgICAgIGNvbnN0IGVsZW1lbnRQYXRoID0gW1xuICAgICAgICAgICAgLi4ucGF0aCxcbiAgICAgICAgICAgIGluZGV4XG4gICAgICAgICAgXTtcbiAgICAgICAgICBjb25zdCBjaWQgPSBDSUQuYXNDSUQoZWxlbWVudCk7XG4gICAgICAgICAgaWYgKGNpZCkge1xuICAgICAgICAgICAgeWllbGQgW1xuICAgICAgICAgICAgICBlbGVtZW50UGF0aC5qb2luKCcvJyksXG4gICAgICAgICAgICAgIGNpZFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbGVtZW50ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgeWllbGQqIGxpbmtzKGVsZW1lbnQsIGVsZW1lbnRQYXRoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGNpZCA9IENJRC5hc0NJRCh2YWx1ZSk7XG4gICAgICAgIGlmIChjaWQpIHtcbiAgICAgICAgICB5aWVsZCBbXG4gICAgICAgICAgICBwYXRoLmpvaW4oJy8nKSxcbiAgICAgICAgICAgIGNpZFxuICAgICAgICAgIF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgeWllbGQqIGxpbmtzKHZhbHVlLCBwYXRoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcbmNvbnN0IHRyZWUgPSBmdW5jdGlvbiogKHNvdXJjZSwgYmFzZSkge1xuICBpZiAoc291cmNlID09IG51bGwpXG4gICAgcmV0dXJuO1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhzb3VyY2UpKSB7XG4gICAgY29uc3QgcGF0aCA9IFtcbiAgICAgIC4uLmJhc2UsXG4gICAgICBrZXlcbiAgICBdO1xuICAgIHlpZWxkIHBhdGguam9pbignLycpO1xuICAgIGlmICh2YWx1ZSAhPSBudWxsICYmICEodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmICFDSUQuYXNDSUQodmFsdWUpKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgZm9yIChjb25zdCBbaW5kZXgsIGVsZW1lbnRdIG9mIHZhbHVlLmVudHJpZXMoKSkge1xuICAgICAgICAgIGNvbnN0IGVsZW1lbnRQYXRoID0gW1xuICAgICAgICAgICAgLi4ucGF0aCxcbiAgICAgICAgICAgIGluZGV4XG4gICAgICAgICAgXTtcbiAgICAgICAgICB5aWVsZCBlbGVtZW50UGF0aC5qb2luKCcvJyk7XG4gICAgICAgICAgaWYgKHR5cGVvZiBlbGVtZW50ID09PSAnb2JqZWN0JyAmJiAhQ0lELmFzQ0lEKGVsZW1lbnQpKSB7XG4gICAgICAgICAgICB5aWVsZCogdHJlZShlbGVtZW50LCBlbGVtZW50UGF0aCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB5aWVsZCogdHJlZSh2YWx1ZSwgcGF0aCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuY29uc3QgZ2V0ID0gKHNvdXJjZSwgcGF0aCkgPT4ge1xuICBsZXQgbm9kZSA9IHNvdXJjZTtcbiAgZm9yIChjb25zdCBbaW5kZXgsIGtleV0gb2YgcGF0aC5lbnRyaWVzKCkpIHtcbiAgICBub2RlID0gbm9kZVtrZXldO1xuICAgIGlmIChub2RlID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgT2JqZWN0IGhhcyBubyBwcm9wZXJ0eSBhdCAkeyBwYXRoLnNsaWNlKDAsIGluZGV4ICsgMSkubWFwKHBhcnQgPT4gYFskeyBKU09OLnN0cmluZ2lmeShwYXJ0KSB9XWApLmpvaW4oJycpIH1gKTtcbiAgICB9XG4gICAgY29uc3QgY2lkID0gQ0lELmFzQ0lEKG5vZGUpO1xuICAgIGlmIChjaWQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiBjaWQsXG4gICAgICAgIHJlbWFpbmluZzogcGF0aC5zbGljZShpbmRleCArIDEpLmpvaW4oJy8nKVxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHsgdmFsdWU6IG5vZGUgfTtcbn07XG5jbGFzcyBCbG9jayB7XG4gIGNvbnN0cnVjdG9yKHtjaWQsIGJ5dGVzLCB2YWx1ZX0pIHtcbiAgICBpZiAoIWNpZCB8fCAhYnl0ZXMgfHwgdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJylcbiAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyByZXF1aXJlZCBhcmd1bWVudCcpO1xuICAgIHRoaXMuY2lkID0gY2lkO1xuICAgIHRoaXMuYnl0ZXMgPSBieXRlcztcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy5hc0Jsb2NrID0gdGhpcztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICBjaWQ6IHJlYWRvbmx5KCksXG4gICAgICBieXRlczogcmVhZG9ubHkoKSxcbiAgICAgIHZhbHVlOiByZWFkb25seSgpLFxuICAgICAgYXNCbG9jazogcmVhZG9ubHkoKVxuICAgIH0pO1xuICB9XG4gIGxpbmtzKCkge1xuICAgIHJldHVybiBsaW5rcyh0aGlzLnZhbHVlLCBbXSk7XG4gIH1cbiAgdHJlZSgpIHtcbiAgICByZXR1cm4gdHJlZSh0aGlzLnZhbHVlLCBbXSk7XG4gIH1cbiAgZ2V0KHBhdGggPSAnLycpIHtcbiAgICByZXR1cm4gZ2V0KHRoaXMudmFsdWUsIHBhdGguc3BsaXQoJy8nKS5maWx0ZXIoQm9vbGVhbikpO1xuICB9XG59XG5jb25zdCBlbmNvZGUgPSBhc3luYyAoe3ZhbHVlLCBjb2RlYywgaGFzaGVyfSkgPT4ge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJylcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgcmVxdWlyZWQgYXJndW1lbnQgXCJ2YWx1ZVwiJyk7XG4gIGlmICghY29kZWMgfHwgIWhhc2hlcilcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgcmVxdWlyZWQgYXJndW1lbnQ6IGNvZGVjIG9yIGhhc2hlcicpO1xuICBjb25zdCBieXRlcyA9IGNvZGVjLmVuY29kZSh2YWx1ZSk7XG4gIGNvbnN0IGhhc2ggPSBhd2FpdCBoYXNoZXIuZGlnZXN0KGJ5dGVzKTtcbiAgY29uc3QgY2lkID0gQ0lELmNyZWF0ZSgxLCBjb2RlYy5jb2RlLCBoYXNoKTtcbiAgcmV0dXJuIG5ldyBCbG9jayh7XG4gICAgdmFsdWUsXG4gICAgYnl0ZXMsXG4gICAgY2lkXG4gIH0pO1xufTtcbmNvbnN0IGRlY29kZSA9IGFzeW5jICh7Ynl0ZXMsIGNvZGVjLCBoYXNoZXJ9KSA9PiB7XG4gIGlmICghYnl0ZXMpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHJlcXVpcmVkIGFyZ3VtZW50IFwiYnl0ZXNcIicpO1xuICBpZiAoIWNvZGVjIHx8ICFoYXNoZXIpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHJlcXVpcmVkIGFyZ3VtZW50OiBjb2RlYyBvciBoYXNoZXInKTtcbiAgY29uc3QgdmFsdWUgPSBjb2RlYy5kZWNvZGUoYnl0ZXMpO1xuICBjb25zdCBoYXNoID0gYXdhaXQgaGFzaGVyLmRpZ2VzdChieXRlcyk7XG4gIGNvbnN0IGNpZCA9IENJRC5jcmVhdGUoMSwgY29kZWMuY29kZSwgaGFzaCk7XG4gIHJldHVybiBuZXcgQmxvY2soe1xuICAgIHZhbHVlLFxuICAgIGJ5dGVzLFxuICAgIGNpZFxuICB9KTtcbn07XG5jb25zdCBjcmVhdGVVbnNhZmUgPSAoe1xuICBieXRlcyxcbiAgY2lkLFxuICB2YWx1ZTogbWF5YmVWYWx1ZSxcbiAgY29kZWNcbn0pID0+IHtcbiAgY29uc3QgdmFsdWUgPSBtYXliZVZhbHVlICE9PSB1bmRlZmluZWQgPyBtYXliZVZhbHVlIDogY29kZWMgJiYgY29kZWMuZGVjb2RlKGJ5dGVzKTtcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHJlcXVpcmVkIGFyZ3VtZW50LCBtdXN0IGVpdGhlciBwcm92aWRlIFwidmFsdWVcIiBvciBcImNvZGVjXCInKTtcbiAgcmV0dXJuIG5ldyBCbG9jayh7XG4gICAgY2lkLFxuICAgIGJ5dGVzLFxuICAgIHZhbHVlXG4gIH0pO1xufTtcbmNvbnN0IGNyZWF0ZSA9IGFzeW5jICh7Ynl0ZXMsIGNpZCwgaGFzaGVyLCBjb2RlY30pID0+IHtcbiAgaWYgKCFieXRlcylcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgcmVxdWlyZWQgYXJndW1lbnQgXCJieXRlc1wiJyk7XG4gIGlmICghaGFzaGVyKVxuICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyByZXF1aXJlZCBhcmd1bWVudCBcImhhc2hlclwiJyk7XG4gIGNvbnN0IHZhbHVlID0gY29kZWMuZGVjb2RlKGJ5dGVzKTtcbiAgY29uc3QgaGFzaCA9IGF3YWl0IGhhc2hlci5kaWdlc3QoYnl0ZXMpO1xuICBpZiAoIWJpbmFyeS5lcXVhbHMoY2lkLm11bHRpaGFzaC5ieXRlcywgaGFzaC5ieXRlcykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NJRCBoYXNoIGRvZXMgbm90IG1hdGNoIGJ5dGVzJyk7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZVVuc2FmZSh7XG4gICAgYnl0ZXMsXG4gICAgY2lkLFxuICAgIHZhbHVlLFxuICAgIGNvZGVjXG4gIH0pO1xufTtcbmV4cG9ydCB7XG4gIGVuY29kZSxcbiAgZGVjb2RlLFxuICBjcmVhdGUsXG4gIGNyZWF0ZVVuc2FmZSxcbiAgQmxvY2tcbn07IiwgImltcG9ydCB7IGNvZXJjZSB9IGZyb20gJy4uL2J5dGVzLmpzJztcbmV4cG9ydCBjb25zdCBuYW1lID0gJ3Jhdyc7XG5leHBvcnQgY29uc3QgY29kZSA9IDg1O1xuZXhwb3J0IGNvbnN0IGVuY29kZSA9IG5vZGUgPT4gY29lcmNlKG5vZGUpO1xuZXhwb3J0IGNvbnN0IGRlY29kZSA9IGRhdGEgPT4gY29lcmNlKGRhdGEpOyIsICJpbXBvcnQgKiBhcyBjYm9yZyBmcm9tICdjYm9yZyc7XG5pbXBvcnQgeyBDSUQgfSBmcm9tICdtdWx0aWZvcm1hdHMvY2lkJztcbmNvbnN0IENJRF9DQk9SX1RBRyA9IDQyO1xuZnVuY3Rpb24gY2lkRW5jb2RlcihvYmopIHtcbiAgaWYgKG9iai5hc0NJRCAhPT0gb2JqKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgY2lkID0gQ0lELmFzQ0lEKG9iaik7XG4gIGlmICghY2lkKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShjaWQuYnl0ZXMuYnl0ZUxlbmd0aCArIDEpO1xuICBieXRlcy5zZXQoY2lkLmJ5dGVzLCAxKTtcbiAgcmV0dXJuIFtcbiAgICBuZXcgY2JvcmcuVG9rZW4oY2JvcmcuVHlwZS50YWcsIENJRF9DQk9SX1RBRyksXG4gICAgbmV3IGNib3JnLlRva2VuKGNib3JnLlR5cGUuYnl0ZXMsIGJ5dGVzKVxuICBdO1xufVxuZnVuY3Rpb24gdW5kZWZpbmVkRW5jb2RlcigpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdgdW5kZWZpbmVkYCBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBJUExEIERhdGEgTW9kZWwgYW5kIGNhbm5vdCBiZSBlbmNvZGVkJyk7XG59XG5mdW5jdGlvbiBudW1iZXJFbmNvZGVyKG51bSkge1xuICBpZiAoTnVtYmVyLmlzTmFOKG51bSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2BOYU5gIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIElQTEQgRGF0YSBNb2RlbCBhbmQgY2Fubm90IGJlIGVuY29kZWQnKTtcbiAgfVxuICBpZiAobnVtID09PSBJbmZpbml0eSB8fCBudW0gPT09IC1JbmZpbml0eSkge1xuICAgIHRocm93IG5ldyBFcnJvcignYEluZmluaXR5YCBhbmQgYC1JbmZpbml0eWAgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgSVBMRCBEYXRhIE1vZGVsIGFuZCBjYW5ub3QgYmUgZW5jb2RlZCcpO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuY29uc3QgZW5jb2RlT3B0aW9ucyA9IHtcbiAgZmxvYXQ2NDogdHJ1ZSxcbiAgdHlwZUVuY29kZXJzOiB7XG4gICAgT2JqZWN0OiBjaWRFbmNvZGVyLFxuICAgIHVuZGVmaW5lZDogdW5kZWZpbmVkRW5jb2RlcixcbiAgICBudW1iZXI6IG51bWJlckVuY29kZXJcbiAgfVxufTtcbmZ1bmN0aW9uIGNpZERlY29kZXIoYnl0ZXMpIHtcbiAgaWYgKGJ5dGVzWzBdICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIENJRCBmb3IgQ0JPUiB0YWcgNDI7IGV4cGVjdGVkIGxlYWRpbmcgMHgwMCcpO1xuICB9XG4gIHJldHVybiBDSUQuZGVjb2RlKGJ5dGVzLnN1YmFycmF5KDEpKTtcbn1cbmNvbnN0IGRlY29kZU9wdGlvbnMgPSB7XG4gIGFsbG93SW5kZWZpbml0ZTogZmFsc2UsXG4gIGFsbG93VW5kZWZpbmVkOiBmYWxzZSxcbiAgYWxsb3dOYU46IGZhbHNlLFxuICBhbGxvd0luZmluaXR5OiBmYWxzZSxcbiAgYWxsb3dCaWdJbnQ6IHRydWUsXG4gIHN0cmljdDogdHJ1ZSxcbiAgdXNlTWFwczogZmFsc2UsXG4gIHRhZ3M6IFtdXG59O1xuZGVjb2RlT3B0aW9ucy50YWdzW0NJRF9DQk9SX1RBR10gPSBjaWREZWNvZGVyO1xuZXhwb3J0IGNvbnN0IG5hbWUgPSAnZGFnLWNib3InO1xuZXhwb3J0IGNvbnN0IGNvZGUgPSAxMTM7XG5leHBvcnQgY29uc3QgZW5jb2RlID0gbm9kZSA9PiBjYm9yZy5lbmNvZGUobm9kZSwgZW5jb2RlT3B0aW9ucyk7XG5leHBvcnQgY29uc3QgZGVjb2RlID0gZGF0YSA9PiBjYm9yZy5kZWNvZGUoZGF0YSwgZGVjb2RlT3B0aW9ucyk7IiwgImltcG9ydCB7IENJRCB9IGZyb20gJ211bHRpZm9ybWF0cy9jaWQnO1xuaW1wb3J0IHsgZGVjb2RlTm9kZSB9IGZyb20gJy4vcGItZGVjb2RlLmpzJztcbmltcG9ydCB7IGVuY29kZU5vZGUgfSBmcm9tICcuL3BiLWVuY29kZS5qcyc7XG5pbXBvcnQge1xuICBwcmVwYXJlLFxuICB2YWxpZGF0ZSxcbiAgY3JlYXRlTm9kZSxcbiAgY3JlYXRlTGlua1xufSBmcm9tICcuL3V0aWwuanMnO1xuZXhwb3J0IGNvbnN0IG5hbWUgPSAnZGFnLXBiJztcbmV4cG9ydCBjb25zdCBjb2RlID0gMTEyO1xuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZShub2RlKSB7XG4gIHZhbGlkYXRlKG5vZGUpO1xuICBjb25zdCBwYm4gPSB7fTtcbiAgaWYgKG5vZGUuTGlua3MpIHtcbiAgICBwYm4uTGlua3MgPSBub2RlLkxpbmtzLm1hcChsID0+IHtcbiAgICAgIGNvbnN0IGxpbmsgPSB7fTtcbiAgICAgIGlmIChsLkhhc2gpIHtcbiAgICAgICAgbGluay5IYXNoID0gbC5IYXNoLmJ5dGVzO1xuICAgICAgfVxuICAgICAgaWYgKGwuTmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxpbmsuTmFtZSA9IGwuTmFtZTtcbiAgICAgIH1cbiAgICAgIGlmIChsLlRzaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGluay5Uc2l6ZSA9IGwuVHNpemU7XG4gICAgICB9XG4gICAgICByZXR1cm4gbGluaztcbiAgICB9KTtcbiAgfVxuICBpZiAobm9kZS5EYXRhKSB7XG4gICAgcGJuLkRhdGEgPSBub2RlLkRhdGE7XG4gIH1cbiAgcmV0dXJuIGVuY29kZU5vZGUocGJuKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGUoYnl0ZXMpIHtcbiAgY29uc3QgcGJuID0gZGVjb2RlTm9kZShieXRlcyk7XG4gIGNvbnN0IG5vZGUgPSB7fTtcbiAgaWYgKHBibi5EYXRhKSB7XG4gICAgbm9kZS5EYXRhID0gcGJuLkRhdGE7XG4gIH1cbiAgaWYgKHBibi5MaW5rcykge1xuICAgIG5vZGUuTGlua3MgPSBwYm4uTGlua3MubWFwKGwgPT4ge1xuICAgICAgY29uc3QgbGluayA9IHt9O1xuICAgICAgdHJ5IHtcbiAgICAgICAgbGluay5IYXNoID0gQ0lELmRlY29kZShsLkhhc2gpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgfVxuICAgICAgaWYgKCFsaW5rLkhhc2gpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIEhhc2ggZmllbGQgZm91bmQgaW4gbGluaywgZXhwZWN0ZWQgQ0lEJyk7XG4gICAgICB9XG4gICAgICBpZiAobC5OYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGluay5OYW1lID0gbC5OYW1lO1xuICAgICAgfVxuICAgICAgaWYgKGwuVHNpemUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsaW5rLlRzaXplID0gbC5Uc2l6ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsaW5rO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBub2RlO1xufVxuZXhwb3J0IHtcbiAgcHJlcGFyZSxcbiAgdmFsaWRhdGUsXG4gIGNyZWF0ZU5vZGUsXG4gIGNyZWF0ZUxpbmtcbn07IiwgImNvbnN0IHRleHREZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG5mdW5jdGlvbiBkZWNvZGVWYXJpbnQoYnl0ZXMsIG9mZnNldCkge1xuICBsZXQgdiA9IDA7XG4gIGZvciAobGV0IHNoaWZ0ID0gMDs7IHNoaWZ0ICs9IDcpIHtcbiAgICBpZiAoc2hpZnQgPj0gNjQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncHJvdG9idWY6IHZhcmludCBvdmVyZmxvdycpO1xuICAgIH1cbiAgICBpZiAob2Zmc2V0ID49IGJ5dGVzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdwcm90b2J1ZjogdW5leHBlY3RlZCBlbmQgb2YgZGF0YScpO1xuICAgIH1cbiAgICBjb25zdCBiID0gYnl0ZXNbb2Zmc2V0KytdO1xuICAgIHYgKz0gc2hpZnQgPCAyOCA/IChiICYgMTI3KSA8PCBzaGlmdCA6IChiICYgMTI3KSAqIDIgKiogc2hpZnQ7XG4gICAgaWYgKGIgPCAxMjgpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gW1xuICAgIHYsXG4gICAgb2Zmc2V0XG4gIF07XG59XG5mdW5jdGlvbiBkZWNvZGVCeXRlcyhieXRlcywgb2Zmc2V0KSB7XG4gIGxldCBieXRlTGVuO1xuICBbYnl0ZUxlbiwgb2Zmc2V0XSA9IGRlY29kZVZhcmludChieXRlcywgb2Zmc2V0KTtcbiAgY29uc3QgcG9zdE9mZnNldCA9IG9mZnNldCArIGJ5dGVMZW47XG4gIGlmIChieXRlTGVuIDwgMCB8fCBwb3N0T2Zmc2V0IDwgMCkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvdG9idWY6IGludmFsaWQgbGVuZ3RoJyk7XG4gIH1cbiAgaWYgKHBvc3RPZmZzZXQgPiBieXRlcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb3RvYnVmOiB1bmV4cGVjdGVkIGVuZCBvZiBkYXRhJyk7XG4gIH1cbiAgcmV0dXJuIFtcbiAgICBieXRlcy5zdWJhcnJheShvZmZzZXQsIHBvc3RPZmZzZXQpLFxuICAgIHBvc3RPZmZzZXRcbiAgXTtcbn1cbmZ1bmN0aW9uIGRlY29kZUtleShieXRlcywgaW5kZXgpIHtcbiAgbGV0IHdpcmU7XG4gIFt3aXJlLCBpbmRleF0gPSBkZWNvZGVWYXJpbnQoYnl0ZXMsIGluZGV4KTtcbiAgcmV0dXJuIFtcbiAgICB3aXJlICYgNyxcbiAgICB3aXJlID4+IDMsXG4gICAgaW5kZXhcbiAgXTtcbn1cbmZ1bmN0aW9uIGRlY29kZUxpbmsoYnl0ZXMpIHtcbiAgY29uc3QgbGluayA9IHt9O1xuICBjb25zdCBsID0gYnl0ZXMubGVuZ3RoO1xuICBsZXQgaW5kZXggPSAwO1xuICB3aGlsZSAoaW5kZXggPCBsKSB7XG4gICAgbGV0IHdpcmVUeXBlLCBmaWVsZE51bTtcbiAgICBbd2lyZVR5cGUsIGZpZWxkTnVtLCBpbmRleF0gPSBkZWNvZGVLZXkoYnl0ZXMsIGluZGV4KTtcbiAgICBpZiAoZmllbGROdW0gPT09IDEpIHtcbiAgICAgIGlmIChsaW5rLkhhc2gpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwcm90b2J1ZjogKFBCTGluaykgZHVwbGljYXRlIEhhc2ggc2VjdGlvbicpO1xuICAgICAgfVxuICAgICAgaWYgKHdpcmVUeXBlICE9PSAyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgcHJvdG9idWY6IChQQkxpbmspIHdyb25nIHdpcmVUeXBlICgkeyB3aXJlVHlwZSB9KSBmb3IgSGFzaGApO1xuICAgICAgfVxuICAgICAgaWYgKGxpbmsuTmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncHJvdG9idWY6IChQQkxpbmspIGludmFsaWQgb3JkZXIsIGZvdW5kIE5hbWUgYmVmb3JlIEhhc2gnKTtcbiAgICAgIH1cbiAgICAgIGlmIChsaW5rLlRzaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwcm90b2J1ZjogKFBCTGluaykgaW52YWxpZCBvcmRlciwgZm91bmQgVHNpemUgYmVmb3JlIEhhc2gnKTtcbiAgICAgIH1cbiAgICAgIDtcbiAgICAgIFtsaW5rLkhhc2gsIGluZGV4XSA9IGRlY29kZUJ5dGVzKGJ5dGVzLCBpbmRleCk7XG4gICAgfSBlbHNlIGlmIChmaWVsZE51bSA9PT0gMikge1xuICAgICAgaWYgKGxpbmsuTmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncHJvdG9idWY6IChQQkxpbmspIGR1cGxpY2F0ZSBOYW1lIHNlY3Rpb24nKTtcbiAgICAgIH1cbiAgICAgIGlmICh3aXJlVHlwZSAhPT0gMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHByb3RvYnVmOiAoUEJMaW5rKSB3cm9uZyB3aXJlVHlwZSAoJHsgd2lyZVR5cGUgfSkgZm9yIE5hbWVgKTtcbiAgICAgIH1cbiAgICAgIGlmIChsaW5rLlRzaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwcm90b2J1ZjogKFBCTGluaykgaW52YWxpZCBvcmRlciwgZm91bmQgVHNpemUgYmVmb3JlIE5hbWUnKTtcbiAgICAgIH1cbiAgICAgIGxldCBieXRzO1xuICAgICAgW2J5dHMsIGluZGV4XSA9IGRlY29kZUJ5dGVzKGJ5dGVzLCBpbmRleCk7XG4gICAgICBsaW5rLk5hbWUgPSB0ZXh0RGVjb2Rlci5kZWNvZGUoYnl0cyk7XG4gICAgfSBlbHNlIGlmIChmaWVsZE51bSA9PT0gMykge1xuICAgICAgaWYgKGxpbmsuVHNpemUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb3RvYnVmOiAoUEJMaW5rKSBkdXBsaWNhdGUgVHNpemUgc2VjdGlvbicpO1xuICAgICAgfVxuICAgICAgaWYgKHdpcmVUeXBlICE9PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgcHJvdG9idWY6IChQQkxpbmspIHdyb25nIHdpcmVUeXBlICgkeyB3aXJlVHlwZSB9KSBmb3IgVHNpemVgKTtcbiAgICAgIH1cbiAgICAgIDtcbiAgICAgIFtsaW5rLlRzaXplLCBpbmRleF0gPSBkZWNvZGVWYXJpbnQoYnl0ZXMsIGluZGV4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBwcm90b2J1ZjogKFBCTGluaykgaW52YWxpZCBmaWVsZE51bWJlciwgZXhwZWN0ZWQgMSwgMiBvciAzLCBnb3QgJHsgZmllbGROdW0gfWApO1xuICAgIH1cbiAgfVxuICBpZiAoaW5kZXggPiBsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm90b2J1ZjogKFBCTGluaykgdW5leHBlY3RlZCBlbmQgb2YgZGF0YScpO1xuICB9XG4gIHJldHVybiBsaW5rO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZU5vZGUoYnl0ZXMpIHtcbiAgY29uc3QgbCA9IGJ5dGVzLmxlbmd0aDtcbiAgbGV0IGluZGV4ID0gMDtcbiAgbGV0IGxpbmtzO1xuICBsZXQgbGlua3NCZWZvcmVEYXRhID0gZmFsc2U7XG4gIGxldCBkYXRhO1xuICB3aGlsZSAoaW5kZXggPCBsKSB7XG4gICAgbGV0IHdpcmVUeXBlLCBmaWVsZE51bTtcbiAgICBbd2lyZVR5cGUsIGZpZWxkTnVtLCBpbmRleF0gPSBkZWNvZGVLZXkoYnl0ZXMsIGluZGV4KTtcbiAgICBpZiAod2lyZVR5cGUgIT09IDIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgcHJvdG9idWY6IChQQk5vZGUpIGludmFsaWQgd2lyZVR5cGUsIGV4cGVjdGVkIDIsIGdvdCAkeyB3aXJlVHlwZSB9YCk7XG4gICAgfVxuICAgIGlmIChmaWVsZE51bSA9PT0gMSkge1xuICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwcm90b2J1ZjogKFBCTm9kZSkgZHVwbGljYXRlIERhdGEgc2VjdGlvbicpO1xuICAgICAgfVxuICAgICAgO1xuICAgICAgW2RhdGEsIGluZGV4XSA9IGRlY29kZUJ5dGVzKGJ5dGVzLCBpbmRleCk7XG4gICAgICBpZiAobGlua3MpIHtcbiAgICAgICAgbGlua3NCZWZvcmVEYXRhID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGZpZWxkTnVtID09PSAyKSB7XG4gICAgICBpZiAobGlua3NCZWZvcmVEYXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncHJvdG9idWY6IChQQk5vZGUpIGR1cGxpY2F0ZSBMaW5rcyBzZWN0aW9uJyk7XG4gICAgICB9IGVsc2UgaWYgKCFsaW5rcykge1xuICAgICAgICBsaW5rcyA9IFtdO1xuICAgICAgfVxuICAgICAgbGV0IGJ5dHM7XG4gICAgICBbYnl0cywgaW5kZXhdID0gZGVjb2RlQnl0ZXMoYnl0ZXMsIGluZGV4KTtcbiAgICAgIGxpbmtzLnB1c2goZGVjb2RlTGluayhieXRzKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgcHJvdG9idWY6IChQQk5vZGUpIGludmFsaWQgZmllbGROdW1iZXIsIGV4cGVjdGVkIDEgb3IgMiwgZ290ICR7IGZpZWxkTnVtIH1gKTtcbiAgICB9XG4gIH1cbiAgaWYgKGluZGV4ID4gbCkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvdG9idWY6IChQQk5vZGUpIHVuZXhwZWN0ZWQgZW5kIG9mIGRhdGEnKTtcbiAgfVxuICBjb25zdCBub2RlID0ge307XG4gIGlmIChkYXRhKSB7XG4gICAgbm9kZS5EYXRhID0gZGF0YTtcbiAgfVxuICBub2RlLkxpbmtzID0gbGlua3MgfHwgW107XG4gIHJldHVybiBub2RlO1xufSIsICJjb25zdCB0ZXh0RW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuY29uc3QgbWF4SW50MzIgPSAyICoqIDMyO1xuY29uc3QgbWF4VUludDMyID0gMiAqKiAzMTtcbmZ1bmN0aW9uIGVuY29kZUxpbmsobGluaywgYnl0ZXMpIHtcbiAgbGV0IGkgPSBieXRlcy5sZW5ndGg7XG4gIGlmICh0eXBlb2YgbGluay5Uc2l6ZSA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAobGluay5Uc2l6ZSA8IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVHNpemUgY2Fubm90IGJlIG5lZ2F0aXZlJyk7XG4gICAgfVxuICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIobGluay5Uc2l6ZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVHNpemUgdG9vIGxhcmdlIGZvciBlbmNvZGluZycpO1xuICAgIH1cbiAgICBpID0gZW5jb2RlVmFyaW50KGJ5dGVzLCBpLCBsaW5rLlRzaXplKSAtIDE7XG4gICAgYnl0ZXNbaV0gPSAyNDtcbiAgfVxuICBpZiAodHlwZW9mIGxpbmsuTmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICBjb25zdCBuYW1lQnl0ZXMgPSB0ZXh0RW5jb2Rlci5lbmNvZGUobGluay5OYW1lKTtcbiAgICBpIC09IG5hbWVCeXRlcy5sZW5ndGg7XG4gICAgYnl0ZXMuc2V0KG5hbWVCeXRlcywgaSk7XG4gICAgaSA9IGVuY29kZVZhcmludChieXRlcywgaSwgbmFtZUJ5dGVzLmxlbmd0aCkgLSAxO1xuICAgIGJ5dGVzW2ldID0gMTg7XG4gIH1cbiAgaWYgKGxpbmsuSGFzaCkge1xuICAgIGkgLT0gbGluay5IYXNoLmxlbmd0aDtcbiAgICBieXRlcy5zZXQobGluay5IYXNoLCBpKTtcbiAgICBpID0gZW5jb2RlVmFyaW50KGJ5dGVzLCBpLCBsaW5rLkhhc2gubGVuZ3RoKSAtIDE7XG4gICAgYnl0ZXNbaV0gPSAxMDtcbiAgfVxuICByZXR1cm4gYnl0ZXMubGVuZ3RoIC0gaTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGVOb2RlKG5vZGUpIHtcbiAgY29uc3Qgc2l6ZSA9IHNpemVOb2RlKG5vZGUpO1xuICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KHNpemUpO1xuICBsZXQgaSA9IHNpemU7XG4gIGlmIChub2RlLkRhdGEpIHtcbiAgICBpIC09IG5vZGUuRGF0YS5sZW5ndGg7XG4gICAgYnl0ZXMuc2V0KG5vZGUuRGF0YSwgaSk7XG4gICAgaSA9IGVuY29kZVZhcmludChieXRlcywgaSwgbm9kZS5EYXRhLmxlbmd0aCkgLSAxO1xuICAgIGJ5dGVzW2ldID0gMTA7XG4gIH1cbiAgaWYgKG5vZGUuTGlua3MpIHtcbiAgICBmb3IgKGxldCBpbmRleCA9IG5vZGUuTGlua3MubGVuZ3RoIC0gMTsgaW5kZXggPj0gMDsgaW5kZXgtLSkge1xuICAgICAgY29uc3Qgc2l6ZSA9IGVuY29kZUxpbmsobm9kZS5MaW5rc1tpbmRleF0sIGJ5dGVzLnN1YmFycmF5KDAsIGkpKTtcbiAgICAgIGkgLT0gc2l6ZTtcbiAgICAgIGkgPSBlbmNvZGVWYXJpbnQoYnl0ZXMsIGksIHNpemUpIC0gMTtcbiAgICAgIGJ5dGVzW2ldID0gMTg7XG4gICAgfVxuICB9XG4gIHJldHVybiBieXRlcztcbn1cbmZ1bmN0aW9uIHNpemVMaW5rKGxpbmspIHtcbiAgbGV0IG4gPSAwO1xuICBpZiAobGluay5IYXNoKSB7XG4gICAgY29uc3QgbCA9IGxpbmsuSGFzaC5sZW5ndGg7XG4gICAgbiArPSAxICsgbCArIHNvdihsKTtcbiAgfVxuICBpZiAodHlwZW9mIGxpbmsuTmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICBjb25zdCBsID0gdGV4dEVuY29kZXIuZW5jb2RlKGxpbmsuTmFtZSkubGVuZ3RoO1xuICAgIG4gKz0gMSArIGwgKyBzb3YobCk7XG4gIH1cbiAgaWYgKHR5cGVvZiBsaW5rLlRzaXplID09PSAnbnVtYmVyJykge1xuICAgIG4gKz0gMSArIHNvdihsaW5rLlRzaXplKTtcbiAgfVxuICByZXR1cm4gbjtcbn1cbmZ1bmN0aW9uIHNpemVOb2RlKG5vZGUpIHtcbiAgbGV0IG4gPSAwO1xuICBpZiAobm9kZS5EYXRhKSB7XG4gICAgY29uc3QgbCA9IG5vZGUuRGF0YS5sZW5ndGg7XG4gICAgbiArPSAxICsgbCArIHNvdihsKTtcbiAgfVxuICBpZiAobm9kZS5MaW5rcykge1xuICAgIGZvciAoY29uc3QgbGluayBvZiBub2RlLkxpbmtzKSB7XG4gICAgICBjb25zdCBsID0gc2l6ZUxpbmsobGluayk7XG4gICAgICBuICs9IDEgKyBsICsgc292KGwpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbjtcbn1cbmZ1bmN0aW9uIGVuY29kZVZhcmludChieXRlcywgb2Zmc2V0LCB2KSB7XG4gIG9mZnNldCAtPSBzb3Yodik7XG4gIGNvbnN0IGJhc2UgPSBvZmZzZXQ7XG4gIHdoaWxlICh2ID49IG1heFVJbnQzMikge1xuICAgIGJ5dGVzW29mZnNldCsrXSA9IHYgJiAxMjcgfCAxMjg7XG4gICAgdiAvPSAxMjg7XG4gIH1cbiAgd2hpbGUgKHYgPj0gMTI4KSB7XG4gICAgYnl0ZXNbb2Zmc2V0KytdID0gdiAmIDEyNyB8IDEyODtcbiAgICB2ID4+Pj0gNztcbiAgfVxuICBieXRlc1tvZmZzZXRdID0gdjtcbiAgcmV0dXJuIGJhc2U7XG59XG5mdW5jdGlvbiBzb3YoeCkge1xuICBpZiAoeCAlIDIgPT09IDApIHtcbiAgICB4Kys7XG4gIH1cbiAgcmV0dXJuIE1hdGguZmxvb3IoKGxlbjY0KHgpICsgNikgLyA3KTtcbn1cbmZ1bmN0aW9uIGxlbjY0KHgpIHtcbiAgbGV0IG4gPSAwO1xuICBpZiAoeCA+PSBtYXhJbnQzMikge1xuICAgIHggPSBNYXRoLmZsb29yKHggLyBtYXhJbnQzMik7XG4gICAgbiA9IDMyO1xuICB9XG4gIGlmICh4ID49IDEgPDwgMTYpIHtcbiAgICB4ID4+Pj0gMTY7XG4gICAgbiArPSAxNjtcbiAgfVxuICBpZiAoeCA+PSAxIDw8IDgpIHtcbiAgICB4ID4+Pj0gODtcbiAgICBuICs9IDg7XG4gIH1cbiAgcmV0dXJuIG4gKyBsZW44dGFiW3hdO1xufVxuY29uc3QgbGVuOHRhYiA9IFtcbiAgMCxcbiAgMSxcbiAgMixcbiAgMixcbiAgMyxcbiAgMyxcbiAgMyxcbiAgMyxcbiAgNCxcbiAgNCxcbiAgNCxcbiAgNCxcbiAgNCxcbiAgNCxcbiAgNCxcbiAgNCxcbiAgNSxcbiAgNSxcbiAgNSxcbiAgNSxcbiAgNSxcbiAgNSxcbiAgNSxcbiAgNSxcbiAgNSxcbiAgNSxcbiAgNSxcbiAgNSxcbiAgNSxcbiAgNSxcbiAgNSxcbiAgNSxcbiAgNixcbiAgNixcbiAgNixcbiAgNixcbiAgNixcbiAgNixcbiAgNixcbiAgNixcbiAgNixcbiAgNixcbiAgNixcbiAgNixcbiAgNixcbiAgNixcbiAgNixcbiAgNixcbiAgNixcbiAgNixcbiAgNixcbiAgNixcbiAgNixcbiAgNixcbiAgNixcbiAgNixcbiAgNixcbiAgNixcbiAgNixcbiAgNixcbiAgNixcbiAgNixcbiAgNixcbiAgNixcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgNyxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOCxcbiAgOFxuXTsiLCAiaW1wb3J0IHsgQ0lEIH0gZnJvbSAnbXVsdGlmb3JtYXRzL2NpZCc7XG5jb25zdCBwYk5vZGVQcm9wZXJ0aWVzID0gW1xuICAnRGF0YScsXG4gICdMaW5rcydcbl07XG5jb25zdCBwYkxpbmtQcm9wZXJ0aWVzID0gW1xuICAnSGFzaCcsXG4gICdOYW1lJyxcbiAgJ1RzaXplJ1xuXTtcbmNvbnN0IHRleHRFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG5mdW5jdGlvbiBsaW5rQ29tcGFyYXRvcihhLCBiKSB7XG4gIGlmIChhID09PSBiKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgY29uc3QgYWJ1ZiA9IGEuTmFtZSA/IHRleHRFbmNvZGVyLmVuY29kZShhLk5hbWUpIDogW107XG4gIGNvbnN0IGJidWYgPSBiLk5hbWUgPyB0ZXh0RW5jb2Rlci5lbmNvZGUoYi5OYW1lKSA6IFtdO1xuICBsZXQgeCA9IGFidWYubGVuZ3RoO1xuICBsZXQgeSA9IGJidWYubGVuZ3RoO1xuICBmb3IgKGxldCBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhYnVmW2ldICE9PSBiYnVmW2ldKSB7XG4gICAgICB4ID0gYWJ1ZltpXTtcbiAgICAgIHkgPSBiYnVmW2ldO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiB4IDwgeSA/IC0xIDogeSA8IHggPyAxIDogMDtcbn1cbmZ1bmN0aW9uIGhhc09ubHlQcm9wZXJ0aWVzKG5vZGUsIHByb3BlcnRpZXMpIHtcbiAgcmV0dXJuICFPYmplY3Qua2V5cyhub2RlKS5zb21lKHAgPT4gIXByb3BlcnRpZXMuaW5jbHVkZXMocCkpO1xufVxuZnVuY3Rpb24gYXNMaW5rKGxpbmspIHtcbiAgaWYgKHR5cGVvZiBsaW5rLmFzQ0lEID09PSAnb2JqZWN0Jykge1xuICAgIGNvbnN0IEhhc2ggPSBDSUQuYXNDSUQobGluayk7XG4gICAgaWYgKCFIYXNoKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIERBRy1QQiBmb3JtJyk7XG4gICAgfVxuICAgIHJldHVybiB7IEhhc2ggfTtcbiAgfVxuICBpZiAodHlwZW9mIGxpbmsgIT09ICdvYmplY3QnIHx8IEFycmF5LmlzQXJyYXkobGluaykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIERBRy1QQiBmb3JtJyk7XG4gIH1cbiAgY29uc3QgcGJsID0ge307XG4gIGlmIChsaW5rLkhhc2gpIHtcbiAgICBsZXQgY2lkID0gQ0lELmFzQ0lEKGxpbmsuSGFzaCk7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghY2lkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbGluay5IYXNoID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGNpZCA9IENJRC5wYXJzZShsaW5rLkhhc2gpO1xuICAgICAgICB9IGVsc2UgaWYgKGxpbmsuSGFzaCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgICBjaWQgPSBDSUQuZGVjb2RlKGxpbmsuSGFzaCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIERBRy1QQiBmb3JtOiAkeyBlLm1lc3NhZ2UgfWApO1xuICAgIH1cbiAgICBpZiAoY2lkKSB7XG4gICAgICBwYmwuSGFzaCA9IGNpZDtcbiAgICB9XG4gIH1cbiAgaWYgKCFwYmwuSGFzaCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgREFHLVBCIGZvcm0nKTtcbiAgfVxuICBpZiAodHlwZW9mIGxpbmsuTmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICBwYmwuTmFtZSA9IGxpbmsuTmFtZTtcbiAgfVxuICBpZiAodHlwZW9mIGxpbmsuVHNpemUgPT09ICdudW1iZXInKSB7XG4gICAgcGJsLlRzaXplID0gbGluay5Uc2l6ZTtcbiAgfVxuICByZXR1cm4gcGJsO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHByZXBhcmUobm9kZSkge1xuICBpZiAobm9kZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHwgdHlwZW9mIG5vZGUgPT09ICdzdHJpbmcnKSB7XG4gICAgbm9kZSA9IHsgRGF0YTogbm9kZSB9O1xuICB9XG4gIGlmICh0eXBlb2Ygbm9kZSAhPT0gJ29iamVjdCcgfHwgQXJyYXkuaXNBcnJheShub2RlKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgREFHLVBCIGZvcm0nKTtcbiAgfVxuICBjb25zdCBwYm4gPSB7fTtcbiAgaWYgKG5vZGUuRGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiBub2RlLkRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICBwYm4uRGF0YSA9IHRleHRFbmNvZGVyLmVuY29kZShub2RlLkRhdGEpO1xuICAgIH0gZWxzZSBpZiAobm9kZS5EYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgcGJuLkRhdGEgPSBub2RlLkRhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgREFHLVBCIGZvcm0nKTtcbiAgICB9XG4gIH1cbiAgaWYgKG5vZGUuTGlua3MgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG5vZGUuTGlua3MpKSB7XG4gICAgICBwYm4uTGlua3MgPSBub2RlLkxpbmtzLm1hcChhc0xpbmspO1xuICAgICAgcGJuLkxpbmtzLnNvcnQobGlua0NvbXBhcmF0b3IpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIERBRy1QQiBmb3JtJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHBibi5MaW5rcyA9IFtdO1xuICB9XG4gIHJldHVybiBwYm47XG59XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGUobm9kZSkge1xuICBpZiAoIW5vZGUgfHwgdHlwZW9mIG5vZGUgIT09ICdvYmplY3QnIHx8IEFycmF5LmlzQXJyYXkobm9kZSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIERBRy1QQiBmb3JtJyk7XG4gIH1cbiAgaWYgKCFoYXNPbmx5UHJvcGVydGllcyhub2RlLCBwYk5vZGVQcm9wZXJ0aWVzKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgREFHLVBCIGZvcm0gKGV4dHJhbmVvdXMgcHJvcGVydGllcyknKTtcbiAgfVxuICBpZiAobm9kZS5EYXRhICE9PSB1bmRlZmluZWQgJiYgIShub2RlLkRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgREFHLVBCIGZvcm0gKERhdGEgbXVzdCBiZSBhIFVpbnQ4QXJyYXkpJyk7XG4gIH1cbiAgaWYgKCFBcnJheS5pc0FycmF5KG5vZGUuTGlua3MpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBEQUctUEIgZm9ybSAoTGlua3MgbXVzdCBiZSBhbiBhcnJheSknKTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUuTGlua3MubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBsaW5rID0gbm9kZS5MaW5rc1tpXTtcbiAgICBpZiAoIWxpbmsgfHwgdHlwZW9mIGxpbmsgIT09ICdvYmplY3QnIHx8IEFycmF5LmlzQXJyYXkobGluaykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgREFHLVBCIGZvcm0gKGJhZCBsaW5rIG9iamVjdCknKTtcbiAgICB9XG4gICAgaWYgKCFoYXNPbmx5UHJvcGVydGllcyhsaW5rLCBwYkxpbmtQcm9wZXJ0aWVzKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBEQUctUEIgZm9ybSAoZXh0cmFuZW91cyBwcm9wZXJ0aWVzIG9uIGxpbmsgb2JqZWN0KScpO1xuICAgIH1cbiAgICBpZiAoIWxpbmsuSGFzaCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBEQUctUEIgZm9ybSAobGluayBtdXN0IGhhdmUgYSBIYXNoKScpO1xuICAgIH1cbiAgICBpZiAobGluay5IYXNoLmFzQ0lEICE9PSBsaW5rLkhhc2gpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgREFHLVBCIGZvcm0gKGxpbmsgSGFzaCBtdXN0IGJlIGEgQ0lEKScpO1xuICAgIH1cbiAgICBpZiAobGluay5OYW1lICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGxpbmsuTmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgREFHLVBCIGZvcm0gKGxpbmsgTmFtZSBtdXN0IGJlIGEgc3RyaW5nKScpO1xuICAgIH1cbiAgICBpZiAobGluay5Uc2l6ZSAhPT0gdW5kZWZpbmVkICYmICh0eXBlb2YgbGluay5Uc2l6ZSAhPT0gJ251bWJlcicgfHwgbGluay5Uc2l6ZSAlIDEgIT09IDApKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIERBRy1QQiBmb3JtIChsaW5rIFRzaXplIG11c3QgYmUgYW4gaW50ZWdlciknKTtcbiAgICB9XG4gICAgaWYgKGkgPiAwICYmIGxpbmtDb21wYXJhdG9yKGxpbmssIG5vZGUuTGlua3NbaSAtIDFdKSA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgREFHLVBCIGZvcm0gKGxpbmtzIG11c3QgYmUgc29ydGVkIGJ5IE5hbWUgYnl0ZXMpJyk7XG4gICAgfVxuICB9XG59XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTm9kZShkYXRhLCBsaW5rcyA9IFtdKSB7XG4gIHJldHVybiBwcmVwYXJlKHtcbiAgICBEYXRhOiBkYXRhLFxuICAgIExpbmtzOiBsaW5rc1xuICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVMaW5rKG5hbWUsIHNpemUsIGNpZCkge1xuICByZXR1cm4gYXNMaW5rKHtcbiAgICBIYXNoOiBjaWQsXG4gICAgTmFtZTogbmFtZSxcbiAgICBUc2l6ZTogc2l6ZVxuICB9KTtcbn0iLCAiaW1wb3J0IHtcbiAgQ2FyUmVhZGVyLFxuICBDYXJXcml0ZXJcbn0gZnJvbSAnQGlwbGQvY2FyJztcbmltcG9ydCB7IEJsb2NrIH0gZnJvbSAnbXVsdGlmb3JtYXRzL2Jsb2NrJztcbmltcG9ydCAqIGFzIHJhdyBmcm9tICdtdWx0aWZvcm1hdHMvY29kZWNzL3Jhdyc7XG5pbXBvcnQgKiBhcyBjYm9yIGZyb20gJ0BpcGxkL2RhZy1jYm9yJztcbmltcG9ydCAqIGFzIHBiIGZyb20gJ0BpcGxkL2RhZy1wYic7XG5leHBvcnQgY2xhc3MgVHJlZXdhbGtDYXJTcGxpdHRlciB7XG4gIGNvbnN0cnVjdG9yKHJlYWRlciwgdGFyZ2V0U2l6ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKHR5cGVvZiB0YXJnZXRTaXplICE9PSAnbnVtYmVyJyB8fCB0YXJnZXRTaXplIDw9IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCB0YXJnZXQgY2h1bmsgc2l6ZScpO1xuICAgIH1cbiAgICB0aGlzLl9yZWFkZXIgPSByZWFkZXI7XG4gICAgdGhpcy5fdGFyZ2V0U2l6ZSA9IHRhcmdldFNpemU7XG4gICAgdGhpcy5fZGVjb2RlcnMgPSBbXG4gICAgICBwYixcbiAgICAgIHJhdyxcbiAgICAgIGNib3IsXG4gICAgICAuLi5vcHRpb25zLmRlY29kZXJzIHx8IFtdXG4gICAgXTtcbiAgfVxuICBhc3luYyAqY2FycygpIHtcbiAgICBjb25zdCByb290cyA9IGF3YWl0IHRoaXMuX3JlYWRlci5nZXRSb290cygpO1xuICAgIGlmIChyb290cy5sZW5ndGggIT09IDEpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuZXhwZWN0ZWQgbnVtYmVyIG9mIHJvb3RzOiAkeyByb290cy5sZW5ndGggfWApO1xuICAgIGxldCBjaGFubmVsO1xuICAgIGZvciBhd2FpdCAoY29uc3QgdmFsIG9mIHRoaXMuX2NhcnMocm9vdHNbMF0pKSB7XG4gICAgICBjaGFubmVsID0gdmFsLmNoYW5uZWw7XG4gICAgICBpZiAodmFsLm91dClcbiAgICAgICAgeWllbGQgdmFsLm91dDtcbiAgICB9XG4gICAgaWYgKCFjaGFubmVsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgQ0FSIHdyaXRlciBjaGFubmVsJyk7XG4gICAgfVxuICAgIGNoYW5uZWwud3JpdGVyLmNsb3NlKCk7XG4gICAgeWllbGQgY2hhbm5lbC5vdXQ7XG4gIH1cbiAgYXN5bmMgX2dldChjaWQpIHtcbiAgICBjb25zdCByYXdCbG9jayA9IGF3YWl0IHRoaXMuX3JlYWRlci5nZXQoY2lkKTtcbiAgICBpZiAoIXJhd0Jsb2NrKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBtaXNzaW5nIGJsb2NrIGZvciAkeyBjaWQgfWApO1xuICAgIGNvbnN0IHtieXRlc30gPSByYXdCbG9jaztcbiAgICBjb25zdCBkZWNvZGVyID0gdGhpcy5fZGVjb2RlcnMuZmluZChkID0+IGQuY29kZSA9PT0gY2lkLmNvZGUpO1xuICAgIGlmICghZGVjb2RlcilcbiAgICAgIHRocm93IG5ldyBFcnJvcihgbWlzc2luZyBkZWNvZGVyIGZvciAkeyBjaWQuY29kZSB9YCk7XG4gICAgcmV0dXJuIG5ldyBCbG9jayh7XG4gICAgICBjaWQsXG4gICAgICBieXRlcyxcbiAgICAgIHZhbHVlOiBkZWNvZGVyLmRlY29kZShieXRlcylcbiAgICB9KTtcbiAgfVxuICBhc3luYyAqX2NhcnMoY2lkLCBwYXJlbnRzID0gW10sIGNoYW5uZWwgPSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCBibG9jayA9IGF3YWl0IHRoaXMuX2dldChjaWQpO1xuICAgIGNoYW5uZWwgPSBjaGFubmVsIHx8IE9iamVjdC5hc3NpZ24oQ2FyV3JpdGVyLmNyZWF0ZShjaWQpLCB7IHNpemU6IDAgfSk7XG4gICAgaWYgKGNoYW5uZWwuc2l6ZSA+IDAgJiYgY2hhbm5lbC5zaXplICsgYmxvY2suYnl0ZXMuYnl0ZUxlbmd0aCA+PSB0aGlzLl90YXJnZXRTaXplKSB7XG4gICAgICBjaGFubmVsLndyaXRlci5jbG9zZSgpO1xuICAgICAgY29uc3Qge291dH0gPSBjaGFubmVsO1xuICAgICAgY2hhbm5lbCA9IG5ld0NhcihwYXJlbnRzKTtcbiAgICAgIHlpZWxkIHtcbiAgICAgICAgY2hhbm5lbCxcbiAgICAgICAgb3V0XG4gICAgICB9O1xuICAgIH1cbiAgICBwYXJlbnRzID0gcGFyZW50cy5jb25jYXQoYmxvY2spO1xuICAgIGNoYW5uZWwuc2l6ZSArPSBibG9jay5ieXRlcy5ieXRlTGVuZ3RoO1xuICAgIGNoYW5uZWwud3JpdGVyLnB1dChibG9jayk7XG4gICAgZm9yIChjb25zdCBbLCBjaWRdIG9mIGJsb2NrLmxpbmtzKCkpIHtcbiAgICAgIGZvciBhd2FpdCAoY29uc3QgdmFsIG9mIHRoaXMuX2NhcnMoY2lkLCBwYXJlbnRzLCBjaGFubmVsKSkge1xuICAgICAgICBjaGFubmVsID0gdmFsLmNoYW5uZWw7XG4gICAgICAgIHlpZWxkIHZhbDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFjaGFubmVsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgQ0FSIHdyaXRlciBjaGFubmVsJyk7XG4gICAgfVxuICAgIHlpZWxkIHsgY2hhbm5lbCB9O1xuICB9XG4gIHN0YXRpYyBhc3luYyBmcm9tSXRlcmFibGUoaXRlcmFibGUsIHRhcmdldFNpemUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCByZWFkZXIgPSBhd2FpdCBDYXJSZWFkZXIuZnJvbUl0ZXJhYmxlKGl0ZXJhYmxlKTtcbiAgICByZXR1cm4gbmV3IFRyZWV3YWxrQ2FyU3BsaXR0ZXIocmVhZGVyLCB0YXJnZXRTaXplLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgZnJvbUJsb2IoYmxvYiwgdGFyZ2V0U2l6ZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IGJ1ZmZlciA9IGF3YWl0IGJsb2IuYXJyYXlCdWZmZXIoKTtcbiAgICBjb25zdCByZWFkZXIgPSBhd2FpdCBDYXJSZWFkZXIuZnJvbUJ5dGVzKG5ldyBVaW50OEFycmF5KGJ1ZmZlcikpO1xuICAgIHJldHVybiBuZXcgVHJlZXdhbGtDYXJTcGxpdHRlcihyZWFkZXIsIHRhcmdldFNpemUsIG9wdGlvbnMpO1xuICB9XG59XG5mdW5jdGlvbiBuZXdDYXIocGFyZW50cykge1xuICBjb25zdCBjaCA9IE9iamVjdC5hc3NpZ24oQ2FyV3JpdGVyLmNyZWF0ZShwYXJlbnRzWzBdLmNpZCksIHsgc2l6ZTogcGFyZW50cy5yZWR1Y2UoKHNpemUsIGIpID0+IHNpemUgKyBiLmJ5dGVzLmJ5dGVMZW5ndGgsIDApIH0pO1xuICBmb3IgKGNvbnN0IGIgb2YgcGFyZW50cykge1xuICAgIGNoLndyaXRlci5wdXQoYik7XG4gIH1cbiAgcmV0dXJuIGNoO1xufSIsICJpbXBvcnQgbGFzdCBmcm9tICdpdC1sYXN0JztcbmltcG9ydCBwaXBlIGZyb20gJ2l0LXBpcGUnO1xuaW1wb3J0IHsgQ2FyV3JpdGVyIH0gZnJvbSAnQGlwbGQvY2FyJztcbmltcG9ydCB7IGltcG9ydGVyIH0gZnJvbSAnaXBmcy11bml4ZnMtaW1wb3J0ZXInO1xuaW1wb3J0IHsgZ2V0Tm9ybWFsaXNlciB9IGZyb20gXCIuL3V0aWxzL25vcm1hbGlzZS1pbnB1dC5qc1wiO1xuaW1wb3J0IHsgTWVtb3J5QmxvY2tTdG9yZSB9IGZyb20gXCIuLi9ibG9ja3N0b3JlL21lbW9yeS5qc1wiO1xuaW1wb3J0IHsgdW5peGZzSW1wb3J0ZXJPcHRpb25zRGVmYXVsdCB9IGZyb20gXCIuL2NvbnN0YW50cy5qc1wiO1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHBhY2soeyBpbnB1dCwgYmxvY2tzdG9yZTogdXNlckJsb2Nrc3RvcmUsIGhhc2hlciwgbWF4Q2h1bmtTaXplLCBtYXhDaGlsZHJlblBlck5vZGUsIHdyYXBXaXRoRGlyZWN0b3J5LCByYXdMZWF2ZXMgfSkge1xuICAgIGlmICghaW5wdXQgfHwgKEFycmF5LmlzQXJyYXkoaW5wdXQpICYmICFpbnB1dC5sZW5ndGgpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyBpbnB1dCBmaWxlKHMpJyk7XG4gICAgfVxuICAgIGNvbnN0IGJsb2Nrc3RvcmUgPSB1c2VyQmxvY2tzdG9yZSA/IHVzZXJCbG9ja3N0b3JlIDogbmV3IE1lbW9yeUJsb2NrU3RvcmUoKTtcbiAgICAvLyBDb25zdW1lIHRoZSBzb3VyY2VcbiAgICBjb25zdCByb290RW50cnkgPSBhd2FpdCBsYXN0KHBpcGUoZ2V0Tm9ybWFsaXNlcihpbnB1dCksIChzb3VyY2UpID0+IGltcG9ydGVyKHNvdXJjZSwgYmxvY2tzdG9yZSwge1xuICAgICAgICAuLi51bml4ZnNJbXBvcnRlck9wdGlvbnNEZWZhdWx0LFxuICAgICAgICBoYXNoZXI6IGhhc2hlciB8fCB1bml4ZnNJbXBvcnRlck9wdGlvbnNEZWZhdWx0Lmhhc2hlcixcbiAgICAgICAgbWF4Q2h1bmtTaXplOiBtYXhDaHVua1NpemUgfHwgdW5peGZzSW1wb3J0ZXJPcHRpb25zRGVmYXVsdC5tYXhDaHVua1NpemUsXG4gICAgICAgIG1heENoaWxkcmVuUGVyTm9kZTogbWF4Q2hpbGRyZW5QZXJOb2RlIHx8IHVuaXhmc0ltcG9ydGVyT3B0aW9uc0RlZmF1bHQubWF4Q2hpbGRyZW5QZXJOb2RlLFxuICAgICAgICB3cmFwV2l0aERpcmVjdG9yeTogd3JhcFdpdGhEaXJlY3RvcnkgPT09IGZhbHNlID8gZmFsc2UgOiB1bml4ZnNJbXBvcnRlck9wdGlvbnNEZWZhdWx0LndyYXBXaXRoRGlyZWN0b3J5LFxuICAgICAgICByYXdMZWF2ZXM6IHJhd0xlYXZlcyA9PSBudWxsID8gdW5peGZzSW1wb3J0ZXJPcHRpb25zRGVmYXVsdC5yYXdMZWF2ZXMgOiByYXdMZWF2ZXNcbiAgICB9KSkpO1xuICAgIGlmICghcm9vdEVudHJ5IHx8ICFyb290RW50cnkuY2lkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZ2l2ZW4gaW5wdXQgY291bGQgbm90IGJlIHBhcnNlZCBjb3JyZWN0bHknKTtcbiAgICB9XG4gICAgY29uc3Qgcm9vdCA9IHJvb3RFbnRyeS5jaWQ7XG4gICAgY29uc3QgeyB3cml0ZXIsIG91dDogY2FyT3V0IH0gPSBhd2FpdCBDYXJXcml0ZXIuY3JlYXRlKFtyb290XSk7XG4gICAgY29uc3QgY2FyT3V0SXRlciA9IGNhck91dFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKTtcbiAgICBsZXQgd3JpdGluZ1Byb21pc2U7XG4gICAgY29uc3Qgd3JpdGVBbGwgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgYmxvY2sgb2YgYmxvY2tzdG9yZS5ibG9ja3MoKSkge1xuICAgICAgICAgICAgLy8gYGF3YWl0YCB3aWxsIGJsb2NrIHVudGlsIGFsbCBieXRlcyBpbiBgY2FyT3V0YCBhcmUgY29uc3VtZWQgYnkgdGhlIHVzZXJcbiAgICAgICAgICAgIC8vIHNvIHdlIGhhdmUgYmFja3ByZXNzdXJlIGhlcmVcbiAgICAgICAgICAgIGF3YWl0IHdyaXRlci5wdXQoYmxvY2spO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHdyaXRlci5jbG9zZSgpO1xuICAgICAgICBpZiAoIXVzZXJCbG9ja3N0b3JlKSB7XG4gICAgICAgICAgICBhd2FpdCBibG9ja3N0b3JlLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IG91dCA9IHtcbiAgICAgICAgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcbiAgICAgICAgICAgIGlmICh3cml0aW5nUHJvbWlzZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdWx0aXBsZSBpdGVyYXRvciBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBkb24ndCBzdGFydCB3cml0aW5nIHVudGlsIHRoZSB1c2VyIHN0YXJ0cyBjb25zdW1pbmcgdGhlIGl0ZXJhdG9yXG4gICAgICAgICAgICB3cml0aW5nUHJvbWlzZSA9IHdyaXRlQWxsKCk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGFzeW5jIG5leHQoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNhck91dEl0ZXIubmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHdyaXRpbmdQcm9taXNlOyAvLyBhbnkgZXJyb3JzIHdpbGwgcHJvcGFnYXRlIGZyb20gaGVyZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHsgcm9vdCwgb3V0IH07XG59XG4iLCAiaW1wb3J0IHBhcmFsbGVsQmF0Y2ggZnJvbSAnaXQtcGFyYWxsZWwtYmF0Y2gnO1xuaW1wb3J0IGRlZmF1bHRPcHRpb25zIGZyb20gJy4vb3B0aW9ucy5qcyc7XG5pbXBvcnQgZGFnQnVpbGRlckZuIGZyb20gJy4vZGFnLWJ1aWxkZXIvaW5kZXguanMnO1xuaW1wb3J0IHRyZWVCdWlsZGVyRm4gZnJvbSAnLi90cmVlLWJ1aWxkZXIuanMnO1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uKiBpbXBvcnRlcihzb3VyY2UsIGJsb2Nrc3RvcmUsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCBvcHRzID0gZGVmYXVsdE9wdGlvbnMob3B0aW9ucyk7XG4gIGxldCBkYWdCdWlsZGVyO1xuICBpZiAodHlwZW9mIG9wdGlvbnMuZGFnQnVpbGRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGRhZ0J1aWxkZXIgPSBvcHRpb25zLmRhZ0J1aWxkZXI7XG4gIH0gZWxzZSB7XG4gICAgZGFnQnVpbGRlciA9IGRhZ0J1aWxkZXJGbjtcbiAgfVxuICBsZXQgdHJlZUJ1aWxkZXI7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucy50cmVlQnVpbGRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRyZWVCdWlsZGVyID0gb3B0aW9ucy50cmVlQnVpbGRlcjtcbiAgfSBlbHNlIHtcbiAgICB0cmVlQnVpbGRlciA9IHRyZWVCdWlsZGVyRm47XG4gIH1cbiAgbGV0IGNhbmRpZGF0ZXM7XG4gIGlmIChTeW1ib2wuYXN5bmNJdGVyYXRvciBpbiBzb3VyY2UgfHwgU3ltYm9sLml0ZXJhdG9yIGluIHNvdXJjZSkge1xuICAgIGNhbmRpZGF0ZXMgPSBzb3VyY2U7XG4gIH0gZWxzZSB7XG4gICAgY2FuZGlkYXRlcyA9IFtzb3VyY2VdO1xuICB9XG4gIGZvciBhd2FpdCAoY29uc3QgZW50cnkgb2YgdHJlZUJ1aWxkZXIocGFyYWxsZWxCYXRjaChkYWdCdWlsZGVyKGNhbmRpZGF0ZXMsIGJsb2Nrc3RvcmUsIG9wdHMpLCBvcHRzLmZpbGVJbXBvcnRDb25jdXJyZW5jeSksIGJsb2Nrc3RvcmUsIG9wdHMpKSB7XG4gICAgeWllbGQge1xuICAgICAgY2lkOiBlbnRyeS5jaWQsXG4gICAgICBwYXRoOiBlbnRyeS5wYXRoLFxuICAgICAgdW5peGZzOiBlbnRyeS51bml4ZnMsXG4gICAgICBzaXplOiBlbnRyeS5zaXplXG4gICAgfTtcbiAgfVxufSIsICIvKipcbiAqIFRoaW4gRVNNIHdyYXBwZXIgZm9yIENKUyBuYW1lZCBleHBvcnRzLlxuICpcbiAqIFJlZjogaHR0cHM6Ly9yZWRmaW4uZW5naW5lZXJpbmcvbm9kZS1tb2R1bGVzLWF0LXdhci13aHktY29tbW9uanMtYW5kLWVzLW1vZHVsZXMtY2FudC1nZXQtYWxvbmctOTYxNzEzNWVlY2ExXG4gKi9cblxuaW1wb3J0IG1lcmdlT3B0aW9ucyBmcm9tICcuL2luZGV4LmpzJztcbmV4cG9ydCBkZWZhdWx0IG1lcmdlT3B0aW9ucztcbiIsICJpbXBvcnQgY3J5cHRvIGZyb20gJ2NyeXB0byc7XG5pbXBvcnQgeyBmcm9tIH0gZnJvbSAnLi9oYXNoZXIuanMnO1xuaW1wb3J0IHsgY29lcmNlIH0gZnJvbSAnLi4vYnl0ZXMuanMnO1xuZXhwb3J0IGNvbnN0IHNoYTI1NiA9IGZyb20oe1xuICBuYW1lOiAnc2hhMi0yNTYnLFxuICBjb2RlOiAxOCxcbiAgZW5jb2RlOiBpbnB1dCA9PiBjb2VyY2UoY3J5cHRvLmNyZWF0ZUhhc2goJ3NoYTI1NicpLnVwZGF0ZShpbnB1dCkuZGlnZXN0KCkpXG59KTtcbmV4cG9ydCBjb25zdCBzaGE1MTIgPSBmcm9tKHtcbiAgbmFtZTogJ3NoYTItNTEyJyxcbiAgY29kZTogMTksXG4gIGVuY29kZTogaW5wdXQgPT4gY29lcmNlKGNyeXB0by5jcmVhdGVIYXNoKCdzaGE1MTInKS51cGRhdGUoaW5wdXQpLmRpZ2VzdCgpKVxufSk7IiwgImltcG9ydCB7IGZyb20gfSBmcm9tICdtdWx0aWZvcm1hdHMvaGFzaGVzL2hhc2hlcic7XG5pbXBvcnQgeyBieXRlcyB9IGZyb20gJ211bHRpZm9ybWF0cyc7XG5pbXBvcnQgbXVyIGZyb20gJ211cm11cmhhc2gzanMtcmV2aXNpdGVkJztcbmZ1bmN0aW9uIGZyb21OdW1iZXJUbzMyQml0QnVmKG51bWJlcikge1xuICBjb25zdCBieXRlcyA9IG5ldyBBcnJheSg0KTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICBieXRlc1tpXSA9IG51bWJlciAmIDI1NTtcbiAgICBudW1iZXIgPSBudW1iZXIgPj4gODtcbiAgfVxuICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnl0ZXMpO1xufVxuZXhwb3J0IGNvbnN0IG11cm11cjMzMiA9IGZyb20oe1xuICBuYW1lOiAnbXVybXVyMy0zMicsXG4gIGNvZGU6IDM1LFxuICBlbmNvZGU6IGlucHV0ID0+IGZyb21OdW1iZXJUbzMyQml0QnVmKG11ci54ODYuaGFzaDMyKGlucHV0KSlcbn0pO1xuZXhwb3J0IGNvbnN0IG11cm11cjMxMjggPSBmcm9tKHtcbiAgbmFtZTogJ211cm11cjMtMTI4JyxcbiAgY29kZTogMzQsXG4gIGVuY29kZTogaW5wdXQgPT4gYnl0ZXMuZnJvbUhleChtdXIueDY0Lmhhc2gxMjgoaW5wdXQpKVxufSk7IiwgImltcG9ydCBtZXJnZU9wdGlvbnMgZnJvbSAnbWVyZ2Utb3B0aW9ucyc7XG5pbXBvcnQgeyBzaGEyNTYgfSBmcm9tICdtdWx0aWZvcm1hdHMvaGFzaGVzL3NoYTInO1xuaW1wb3J0IHsgbXVybXVyMzEyOCB9IGZyb20gJ0BtdWx0aWZvcm1hdHMvbXVybXVyMyc7XG5hc3luYyBmdW5jdGlvbiBoYW10SGFzaEZuKGJ1Zikge1xuICByZXR1cm4gKGF3YWl0IG11cm11cjMxMjguZW5jb2RlKGJ1ZikpLnNsaWNlKDAsIDgpLnJldmVyc2UoKTtcbn1cbmNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICBjaHVua2VyOiAnZml4ZWQnLFxuICBzdHJhdGVneTogJ2JhbGFuY2VkJyxcbiAgcmF3TGVhdmVzOiBmYWxzZSxcbiAgb25seUhhc2g6IGZhbHNlLFxuICByZWR1Y2VTaW5nbGVMZWFmVG9TZWxmOiB0cnVlLFxuICBoYXNoZXI6IHNoYTI1NixcbiAgbGVhZlR5cGU6ICdmaWxlJyxcbiAgY2lkVmVyc2lvbjogMCxcbiAgcHJvZ3Jlc3M6ICgpID0+ICgpID0+IHtcbiAgfSxcbiAgc2hhcmRTcGxpdFRocmVzaG9sZDogMTAwMCxcbiAgZmlsZUltcG9ydENvbmN1cnJlbmN5OiA1MCxcbiAgYmxvY2tXcml0ZUNvbmN1cnJlbmN5OiAxMCxcbiAgbWluQ2h1bmtTaXplOiAyNjIxNDQsXG4gIG1heENodW5rU2l6ZTogMjYyMTQ0LFxuICBhdmdDaHVua1NpemU6IDI2MjE0NCxcbiAgd2luZG93OiAxNixcbiAgcG9seW5vbWlhbDogMTc0MzcxODAxMzI3NjM2NTIsXG4gIG1heENoaWxkcmVuUGVyTm9kZTogMTc0LFxuICBsYXllclJlcGVhdDogNCxcbiAgd3JhcFdpdGhEaXJlY3Rvcnk6IGZhbHNlLFxuICByZWN1cnNpdmU6IGZhbHNlLFxuICBoaWRkZW46IGZhbHNlLFxuICB0aW1lb3V0OiB1bmRlZmluZWQsXG4gIGhhbXRIYXNoRm4sXG4gIGhhbXRIYXNoQ29kZTogMzQsXG4gIGhhbXRCdWNrZXRCaXRzOiA4XG59O1xuZXhwb3J0IGRlZmF1bHQgKG9wdGlvbnMgPSB7fSkgPT4ge1xuICBjb25zdCBkZWZhdWx0cyA9IG1lcmdlT3B0aW9ucy5iaW5kKHsgaWdub3JlVW5kZWZpbmVkOiB0cnVlIH0pO1xuICByZXR1cm4gZGVmYXVsdHMoZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMpO1xufTsiLCAiaW1wb3J0IGVycmNvZGUgZnJvbSAnZXJyLWNvZGUnO1xuaW1wb3J0ICogYXMgUGIgZnJvbSAnLi91bml4ZnMuanMnO1xuY29uc3QgUEJEYXRhID0gUGIuRGF0YTtcbmNvbnN0IHR5cGVzID0gW1xuICAncmF3JyxcbiAgJ2RpcmVjdG9yeScsXG4gICdmaWxlJyxcbiAgJ21ldGFkYXRhJyxcbiAgJ3N5bWxpbmsnLFxuICAnaGFtdC1zaGFyZGVkLWRpcmVjdG9yeSdcbl07XG5jb25zdCBkaXJUeXBlcyA9IFtcbiAgJ2RpcmVjdG9yeScsXG4gICdoYW10LXNoYXJkZWQtZGlyZWN0b3J5J1xuXTtcbmNvbnN0IERFRkFVTFRfRklMRV9NT0RFID0gcGFyc2VJbnQoJzA2NDQnLCA4KTtcbmNvbnN0IERFRkFVTFRfRElSRUNUT1JZX01PREUgPSBwYXJzZUludCgnMDc1NScsIDgpO1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlTW9kZShtb2RlKSB7XG4gIGlmIChtb2RlID09IG51bGwpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGlmICh0eXBlb2YgbW9kZSA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gbW9kZSAmIDQwOTU7XG4gIH1cbiAgbW9kZSA9IG1vZGUudG9TdHJpbmcoKTtcbiAgaWYgKG1vZGUuc3Vic3RyaW5nKDAsIDEpID09PSAnMCcpIHtcbiAgICByZXR1cm4gcGFyc2VJbnQobW9kZSwgOCkgJiA0MDk1O1xuICB9XG4gIHJldHVybiBwYXJzZUludChtb2RlLCAxMCkgJiA0MDk1O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlTXRpbWUoaW5wdXQpIHtcbiAgaWYgKGlucHV0ID09IG51bGwpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGxldCBtdGltZTtcbiAgaWYgKGlucHV0LnNlY3MgIT0gbnVsbCkge1xuICAgIG10aW1lID0ge1xuICAgICAgc2VjczogaW5wdXQuc2VjcyxcbiAgICAgIG5zZWNzOiBpbnB1dC5uc2Vjc1xuICAgIH07XG4gIH1cbiAgaWYgKGlucHV0LlNlY29uZHMgIT0gbnVsbCkge1xuICAgIG10aW1lID0ge1xuICAgICAgc2VjczogaW5wdXQuU2Vjb25kcyxcbiAgICAgIG5zZWNzOiBpbnB1dC5GcmFjdGlvbmFsTmFub3NlY29uZHNcbiAgICB9O1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgIG10aW1lID0ge1xuICAgICAgc2VjczogaW5wdXRbMF0sXG4gICAgICBuc2VjczogaW5wdXRbMV1cbiAgICB9O1xuICB9XG4gIGlmIChpbnB1dCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICBjb25zdCBtcyA9IGlucHV0LmdldFRpbWUoKTtcbiAgICBjb25zdCBzZWNzID0gTWF0aC5mbG9vcihtcyAvIDEwMDApO1xuICAgIG10aW1lID0ge1xuICAgICAgc2Vjczogc2VjcyxcbiAgICAgIG5zZWNzOiAobXMgLSBzZWNzICogMTAwMCkgKiAxMDAwXG4gICAgfTtcbiAgfVxuICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtdGltZSwgJ3NlY3MnKSkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKG10aW1lICE9IG51bGwgJiYgbXRpbWUubnNlY3MgIT0gbnVsbCAmJiAobXRpbWUubnNlY3MgPCAwIHx8IG10aW1lLm5zZWNzID4gOTk5OTk5OTk5KSkge1xuICAgIHRocm93IGVycmNvZGUobmV3IEVycm9yKCdtdGltZS1uc2VjcyBtdXN0IGJlIHdpdGhpbiB0aGUgcmFuZ2UgWzAsOTk5OTk5OTk5XScpLCAnRVJSX0lOVkFMSURfTVRJTUVfTlNFQ1MnKTtcbiAgfVxuICByZXR1cm4gbXRpbWU7XG59XG5jbGFzcyBVbml4RlMge1xuICBzdGF0aWMgdW5tYXJzaGFsKG1hcnNoYWxlZCkge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBQQkRhdGEuZGVjb2RlKG1hcnNoYWxlZCk7XG4gICAgY29uc3QgZGVjb2RlZCA9IFBCRGF0YS50b09iamVjdChtZXNzYWdlLCB7XG4gICAgICBkZWZhdWx0czogZmFsc2UsXG4gICAgICBhcnJheXM6IHRydWUsXG4gICAgICBsb25nczogTnVtYmVyLFxuICAgICAgb2JqZWN0czogZmFsc2VcbiAgICB9KTtcbiAgICBjb25zdCBkYXRhID0gbmV3IFVuaXhGUyh7XG4gICAgICB0eXBlOiB0eXBlc1tkZWNvZGVkLlR5cGVdLFxuICAgICAgZGF0YTogZGVjb2RlZC5EYXRhLFxuICAgICAgYmxvY2tTaXplczogZGVjb2RlZC5ibG9ja3NpemVzLFxuICAgICAgbW9kZTogZGVjb2RlZC5tb2RlLFxuICAgICAgbXRpbWU6IGRlY29kZWQubXRpbWUgPyB7XG4gICAgICAgIHNlY3M6IGRlY29kZWQubXRpbWUuU2Vjb25kcyxcbiAgICAgICAgbnNlY3M6IGRlY29kZWQubXRpbWUuRnJhY3Rpb25hbE5hbm9zZWNvbmRzXG4gICAgICB9IDogdW5kZWZpbmVkXG4gICAgfSk7XG4gICAgZGF0YS5fb3JpZ2luYWxNb2RlID0gZGVjb2RlZC5tb2RlIHx8IDA7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHsgdHlwZTogJ2ZpbGUnIH0pIHtcbiAgICBjb25zdCB7dHlwZSwgZGF0YSwgYmxvY2tTaXplcywgaGFzaFR5cGUsIGZhbm91dCwgbXRpbWUsIG1vZGV9ID0gb3B0aW9ucztcbiAgICBpZiAodHlwZSAmJiAhdHlwZXMuaW5jbHVkZXModHlwZSkpIHtcbiAgICAgIHRocm93IGVycmNvZGUobmV3IEVycm9yKCdUeXBlOiAnICsgdHlwZSArICcgaXMgbm90IHZhbGlkJyksICdFUlJfSU5WQUxJRF9UWVBFJyk7XG4gICAgfVxuICAgIHRoaXMudHlwZSA9IHR5cGUgfHwgJ2ZpbGUnO1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgdGhpcy5oYXNoVHlwZSA9IGhhc2hUeXBlO1xuICAgIHRoaXMuZmFub3V0ID0gZmFub3V0O1xuICAgIHRoaXMuYmxvY2tTaXplcyA9IGJsb2NrU2l6ZXMgfHwgW107XG4gICAgdGhpcy5fb3JpZ2luYWxNb2RlID0gMDtcbiAgICB0aGlzLm1vZGUgPSBwYXJzZU1vZGUobW9kZSk7XG4gICAgaWYgKG10aW1lKSB7XG4gICAgICB0aGlzLm10aW1lID0gcGFyc2VNdGltZShtdGltZSk7XG4gICAgICBpZiAodGhpcy5tdGltZSAmJiAhdGhpcy5tdGltZS5uc2Vjcykge1xuICAgICAgICB0aGlzLm10aW1lLm5zZWNzID0gMDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgc2V0IG1vZGUobW9kZSkge1xuICAgIHRoaXMuX21vZGUgPSB0aGlzLmlzRGlyZWN0b3J5KCkgPyBERUZBVUxUX0RJUkVDVE9SWV9NT0RFIDogREVGQVVMVF9GSUxFX01PREU7XG4gICAgY29uc3QgcGFyc2VkTW9kZSA9IHBhcnNlTW9kZShtb2RlKTtcbiAgICBpZiAocGFyc2VkTW9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLl9tb2RlID0gcGFyc2VkTW9kZTtcbiAgICB9XG4gIH1cbiAgZ2V0IG1vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21vZGU7XG4gIH1cbiAgaXNEaXJlY3RvcnkoKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4odGhpcy50eXBlICYmIGRpclR5cGVzLmluY2x1ZGVzKHRoaXMudHlwZSkpO1xuICB9XG4gIGFkZEJsb2NrU2l6ZShzaXplKSB7XG4gICAgdGhpcy5ibG9ja1NpemVzLnB1c2goc2l6ZSk7XG4gIH1cbiAgcmVtb3ZlQmxvY2tTaXplKGluZGV4KSB7XG4gICAgdGhpcy5ibG9ja1NpemVzLnNwbGljZShpbmRleCwgMSk7XG4gIH1cbiAgZmlsZVNpemUoKSB7XG4gICAgaWYgKHRoaXMuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGxldCBzdW0gPSAwO1xuICAgIHRoaXMuYmxvY2tTaXplcy5mb3JFYWNoKHNpemUgPT4ge1xuICAgICAgc3VtICs9IHNpemU7XG4gICAgfSk7XG4gICAgaWYgKHRoaXMuZGF0YSkge1xuICAgICAgc3VtICs9IHRoaXMuZGF0YS5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiBzdW07XG4gIH1cbiAgbWFyc2hhbCgpIHtcbiAgICBsZXQgdHlwZTtcbiAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgIGNhc2UgJ3Jhdyc6XG4gICAgICB0eXBlID0gUEJEYXRhLkRhdGFUeXBlLlJhdztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2RpcmVjdG9yeSc6XG4gICAgICB0eXBlID0gUEJEYXRhLkRhdGFUeXBlLkRpcmVjdG9yeTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2ZpbGUnOlxuICAgICAgdHlwZSA9IFBCRGF0YS5EYXRhVHlwZS5GaWxlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnbWV0YWRhdGEnOlxuICAgICAgdHlwZSA9IFBCRGF0YS5EYXRhVHlwZS5NZXRhZGF0YTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3N5bWxpbmsnOlxuICAgICAgdHlwZSA9IFBCRGF0YS5EYXRhVHlwZS5TeW1saW5rO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnaGFtdC1zaGFyZGVkLWRpcmVjdG9yeSc6XG4gICAgICB0eXBlID0gUEJEYXRhLkRhdGFUeXBlLkhBTVRTaGFyZDtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBlcnJjb2RlKG5ldyBFcnJvcignVHlwZTogJyArIHR5cGUgKyAnIGlzIG5vdCB2YWxpZCcpLCAnRVJSX0lOVkFMSURfVFlQRScpO1xuICAgIH1cbiAgICBsZXQgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICBpZiAoIXRoaXMuZGF0YSB8fCAhdGhpcy5kYXRhLmxlbmd0aCkge1xuICAgICAgZGF0YSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgbGV0IG1vZGU7XG4gICAgaWYgKHRoaXMubW9kZSAhPSBudWxsKSB7XG4gICAgICBtb2RlID0gdGhpcy5fb3JpZ2luYWxNb2RlICYgNDI5NDk2MzIwMCB8IChwYXJzZU1vZGUodGhpcy5tb2RlKSB8fCAwKTtcbiAgICAgIGlmIChtb2RlID09PSBERUZBVUxUX0ZJTEVfTU9ERSAmJiAhdGhpcy5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICAgIG1vZGUgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBpZiAobW9kZSA9PT0gREVGQVVMVF9ESVJFQ1RPUllfTU9ERSAmJiB0aGlzLmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgICAgbW9kZSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IG10aW1lO1xuICAgIGlmICh0aGlzLm10aW1lICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlTXRpbWUodGhpcy5tdGltZSk7XG4gICAgICBpZiAocGFyc2VkKSB7XG4gICAgICAgIG10aW1lID0ge1xuICAgICAgICAgIFNlY29uZHM6IHBhcnNlZC5zZWNzLFxuICAgICAgICAgIEZyYWN0aW9uYWxOYW5vc2Vjb25kczogcGFyc2VkLm5zZWNzXG4gICAgICAgIH07XG4gICAgICAgIGlmIChtdGltZS5GcmFjdGlvbmFsTmFub3NlY29uZHMgPT09IDApIHtcbiAgICAgICAgICBkZWxldGUgbXRpbWUuRnJhY3Rpb25hbE5hbm9zZWNvbmRzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHBiRGF0YSA9IHtcbiAgICAgIFR5cGU6IHR5cGUsXG4gICAgICBEYXRhOiBkYXRhLFxuICAgICAgZmlsZXNpemU6IHRoaXMuaXNEaXJlY3RvcnkoKSA/IHVuZGVmaW5lZCA6IHRoaXMuZmlsZVNpemUoKSxcbiAgICAgIGJsb2Nrc2l6ZXM6IHRoaXMuYmxvY2tTaXplcyxcbiAgICAgIGhhc2hUeXBlOiB0aGlzLmhhc2hUeXBlLFxuICAgICAgZmFub3V0OiB0aGlzLmZhbm91dCxcbiAgICAgIG1vZGUsXG4gICAgICBtdGltZVxuICAgIH07XG4gICAgcmV0dXJuIFBCRGF0YS5lbmNvZGUocGJEYXRhKS5maW5pc2goKTtcbiAgfVxufVxuZXhwb3J0IHtcbiAgVW5peEZTXG59OyIsICJpbXBvcnQgJHByb3RvYnVmIGZyb20gJ3Byb3RvYnVmanMvbWluaW1hbC5qcyc7XG5jb25zdCAkUmVhZGVyID0gJHByb3RvYnVmLlJlYWRlciwgJFdyaXRlciA9ICRwcm90b2J1Zi5Xcml0ZXIsICR1dGlsID0gJHByb3RvYnVmLnV0aWw7XG5jb25zdCAkcm9vdCA9ICRwcm90b2J1Zi5yb290c1snaXBmcy11bml4ZnMnXSB8fCAoJHByb3RvYnVmLnJvb3RzWydpcGZzLXVuaXhmcyddID0ge30pO1xuZXhwb3J0IGNvbnN0IERhdGEgPSAkcm9vdC5EYXRhID0gKCgpID0+IHtcbiAgZnVuY3Rpb24gRGF0YShwKSB7XG4gICAgdGhpcy5ibG9ja3NpemVzID0gW107XG4gICAgaWYgKHApXG4gICAgICBmb3IgKHZhciBrcyA9IE9iamVjdC5rZXlzKHApLCBpID0gMDsgaSA8IGtzLmxlbmd0aDsgKytpKVxuICAgICAgICBpZiAocFtrc1tpXV0gIT0gbnVsbClcbiAgICAgICAgICB0aGlzW2tzW2ldXSA9IHBba3NbaV1dO1xuICB9XG4gIERhdGEucHJvdG90eXBlLlR5cGUgPSAwO1xuICBEYXRhLnByb3RvdHlwZS5EYXRhID0gJHV0aWwubmV3QnVmZmVyKFtdKTtcbiAgRGF0YS5wcm90b3R5cGUuZmlsZXNpemUgPSAkdXRpbC5Mb25nID8gJHV0aWwuTG9uZy5mcm9tQml0cygwLCAwLCB0cnVlKSA6IDA7XG4gIERhdGEucHJvdG90eXBlLmJsb2Nrc2l6ZXMgPSAkdXRpbC5lbXB0eUFycmF5O1xuICBEYXRhLnByb3RvdHlwZS5oYXNoVHlwZSA9ICR1dGlsLkxvbmcgPyAkdXRpbC5Mb25nLmZyb21CaXRzKDAsIDAsIHRydWUpIDogMDtcbiAgRGF0YS5wcm90b3R5cGUuZmFub3V0ID0gJHV0aWwuTG9uZyA/ICR1dGlsLkxvbmcuZnJvbUJpdHMoMCwgMCwgdHJ1ZSkgOiAwO1xuICBEYXRhLnByb3RvdHlwZS5tb2RlID0gMDtcbiAgRGF0YS5wcm90b3R5cGUubXRpbWUgPSBudWxsO1xuICBEYXRhLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShtLCB3KSB7XG4gICAgaWYgKCF3KVxuICAgICAgdyA9ICRXcml0ZXIuY3JlYXRlKCk7XG4gICAgdy51aW50MzIoOCkuaW50MzIobS5UeXBlKTtcbiAgICBpZiAobS5EYXRhICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobSwgJ0RhdGEnKSlcbiAgICAgIHcudWludDMyKDE4KS5ieXRlcyhtLkRhdGEpO1xuICAgIGlmIChtLmZpbGVzaXplICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobSwgJ2ZpbGVzaXplJykpXG4gICAgICB3LnVpbnQzMigyNCkudWludDY0KG0uZmlsZXNpemUpO1xuICAgIGlmIChtLmJsb2Nrc2l6ZXMgIT0gbnVsbCAmJiBtLmJsb2Nrc2l6ZXMubGVuZ3RoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG0uYmxvY2tzaXplcy5sZW5ndGg7ICsraSlcbiAgICAgICAgdy51aW50MzIoMzIpLnVpbnQ2NChtLmJsb2Nrc2l6ZXNbaV0pO1xuICAgIH1cbiAgICBpZiAobS5oYXNoVHlwZSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG0sICdoYXNoVHlwZScpKVxuICAgICAgdy51aW50MzIoNDApLnVpbnQ2NChtLmhhc2hUeXBlKTtcbiAgICBpZiAobS5mYW5vdXQgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtLCAnZmFub3V0JykpXG4gICAgICB3LnVpbnQzMig0OCkudWludDY0KG0uZmFub3V0KTtcbiAgICBpZiAobS5tb2RlICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobSwgJ21vZGUnKSlcbiAgICAgIHcudWludDMyKDU2KS51aW50MzIobS5tb2RlKTtcbiAgICBpZiAobS5tdGltZSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG0sICdtdGltZScpKVxuICAgICAgJHJvb3QuVW5peFRpbWUuZW5jb2RlKG0ubXRpbWUsIHcudWludDMyKDY2KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgIHJldHVybiB3O1xuICB9O1xuICBEYXRhLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyLCBsKSB7XG4gICAgaWYgKCEociBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgciA9ICRSZWFkZXIuY3JlYXRlKHIpO1xuICAgIHZhciBjID0gbCA9PT0gdW5kZWZpbmVkID8gci5sZW4gOiByLnBvcyArIGwsIG0gPSBuZXcgJHJvb3QuRGF0YSgpO1xuICAgIHdoaWxlIChyLnBvcyA8IGMpIHtcbiAgICAgIHZhciB0ID0gci51aW50MzIoKTtcbiAgICAgIHN3aXRjaCAodCA+Pj4gMykge1xuICAgICAgY2FzZSAxOlxuICAgICAgICBtLlR5cGUgPSByLmludDMyKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICBtLkRhdGEgPSByLmJ5dGVzKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBtLmZpbGVzaXplID0gci51aW50NjQoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDQ6XG4gICAgICAgIGlmICghKG0uYmxvY2tzaXplcyAmJiBtLmJsb2Nrc2l6ZXMubGVuZ3RoKSlcbiAgICAgICAgICBtLmJsb2Nrc2l6ZXMgPSBbXTtcbiAgICAgICAgaWYgKCh0ICYgNykgPT09IDIpIHtcbiAgICAgICAgICB2YXIgYzIgPSByLnVpbnQzMigpICsgci5wb3M7XG4gICAgICAgICAgd2hpbGUgKHIucG9zIDwgYzIpXG4gICAgICAgICAgICBtLmJsb2Nrc2l6ZXMucHVzaChyLnVpbnQ2NCgpKTtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgbS5ibG9ja3NpemVzLnB1c2goci51aW50NjQoKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA1OlxuICAgICAgICBtLmhhc2hUeXBlID0gci51aW50NjQoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDY6XG4gICAgICAgIG0uZmFub3V0ID0gci51aW50NjQoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDc6XG4gICAgICAgIG0ubW9kZSA9IHIudWludDMyKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA4OlxuICAgICAgICBtLm10aW1lID0gJHJvb3QuVW5peFRpbWUuZGVjb2RlKHIsIHIudWludDMyKCkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHIuc2tpcFR5cGUodCAmIDcpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFtLmhhc093blByb3BlcnR5KCdUeXBlJykpXG4gICAgICB0aHJvdyAkdXRpbC5Qcm90b2NvbEVycm9yKCdtaXNzaW5nIHJlcXVpcmVkIFxcJ1R5cGVcXCcnLCB7IGluc3RhbmNlOiBtIH0pO1xuICAgIHJldHVybiBtO1xuICB9O1xuICBEYXRhLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KGQpIHtcbiAgICBpZiAoZCBpbnN0YW5jZW9mICRyb290LkRhdGEpXG4gICAgICByZXR1cm4gZDtcbiAgICB2YXIgbSA9IG5ldyAkcm9vdC5EYXRhKCk7XG4gICAgc3dpdGNoIChkLlR5cGUpIHtcbiAgICBjYXNlICdSYXcnOlxuICAgIGNhc2UgMDpcbiAgICAgIG0uVHlwZSA9IDA7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdEaXJlY3RvcnknOlxuICAgIGNhc2UgMTpcbiAgICAgIG0uVHlwZSA9IDE7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdGaWxlJzpcbiAgICBjYXNlIDI6XG4gICAgICBtLlR5cGUgPSAyO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnTWV0YWRhdGEnOlxuICAgIGNhc2UgMzpcbiAgICAgIG0uVHlwZSA9IDM7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdTeW1saW5rJzpcbiAgICBjYXNlIDQ6XG4gICAgICBtLlR5cGUgPSA0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnSEFNVFNoYXJkJzpcbiAgICBjYXNlIDU6XG4gICAgICBtLlR5cGUgPSA1O1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChkLkRhdGEgIT0gbnVsbCkge1xuICAgICAgaWYgKHR5cGVvZiBkLkRhdGEgPT09ICdzdHJpbmcnKVxuICAgICAgICAkdXRpbC5iYXNlNjQuZGVjb2RlKGQuRGF0YSwgbS5EYXRhID0gJHV0aWwubmV3QnVmZmVyKCR1dGlsLmJhc2U2NC5sZW5ndGgoZC5EYXRhKSksIDApO1xuICAgICAgZWxzZSBpZiAoZC5EYXRhLmxlbmd0aClcbiAgICAgICAgbS5EYXRhID0gZC5EYXRhO1xuICAgIH1cbiAgICBpZiAoZC5maWxlc2l6ZSAhPSBudWxsKSB7XG4gICAgICBpZiAoJHV0aWwuTG9uZylcbiAgICAgICAgKG0uZmlsZXNpemUgPSAkdXRpbC5Mb25nLmZyb21WYWx1ZShkLmZpbGVzaXplKSkudW5zaWduZWQgPSB0cnVlO1xuICAgICAgZWxzZSBpZiAodHlwZW9mIGQuZmlsZXNpemUgPT09ICdzdHJpbmcnKVxuICAgICAgICBtLmZpbGVzaXplID0gcGFyc2VJbnQoZC5maWxlc2l6ZSwgMTApO1xuICAgICAgZWxzZSBpZiAodHlwZW9mIGQuZmlsZXNpemUgPT09ICdudW1iZXInKVxuICAgICAgICBtLmZpbGVzaXplID0gZC5maWxlc2l6ZTtcbiAgICAgIGVsc2UgaWYgKHR5cGVvZiBkLmZpbGVzaXplID09PSAnb2JqZWN0JylcbiAgICAgICAgbS5maWxlc2l6ZSA9IG5ldyAkdXRpbC5Mb25nQml0cyhkLmZpbGVzaXplLmxvdyA+Pj4gMCwgZC5maWxlc2l6ZS5oaWdoID4+PiAwKS50b051bWJlcih0cnVlKTtcbiAgICB9XG4gICAgaWYgKGQuYmxvY2tzaXplcykge1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGQuYmxvY2tzaXplcykpXG4gICAgICAgIHRocm93IFR5cGVFcnJvcignLkRhdGEuYmxvY2tzaXplczogYXJyYXkgZXhwZWN0ZWQnKTtcbiAgICAgIG0uYmxvY2tzaXplcyA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkLmJsb2Nrc2l6ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKCR1dGlsLkxvbmcpXG4gICAgICAgICAgKG0uYmxvY2tzaXplc1tpXSA9ICR1dGlsLkxvbmcuZnJvbVZhbHVlKGQuYmxvY2tzaXplc1tpXSkpLnVuc2lnbmVkID0gdHJ1ZTtcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGQuYmxvY2tzaXplc1tpXSA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgbS5ibG9ja3NpemVzW2ldID0gcGFyc2VJbnQoZC5ibG9ja3NpemVzW2ldLCAxMCk7XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBkLmJsb2Nrc2l6ZXNbaV0gPT09ICdudW1iZXInKVxuICAgICAgICAgIG0uYmxvY2tzaXplc1tpXSA9IGQuYmxvY2tzaXplc1tpXTtcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGQuYmxvY2tzaXplc1tpXSA9PT0gJ29iamVjdCcpXG4gICAgICAgICAgbS5ibG9ja3NpemVzW2ldID0gbmV3ICR1dGlsLkxvbmdCaXRzKGQuYmxvY2tzaXplc1tpXS5sb3cgPj4+IDAsIGQuYmxvY2tzaXplc1tpXS5oaWdoID4+PiAwKS50b051bWJlcih0cnVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGQuaGFzaFR5cGUgIT0gbnVsbCkge1xuICAgICAgaWYgKCR1dGlsLkxvbmcpXG4gICAgICAgIChtLmhhc2hUeXBlID0gJHV0aWwuTG9uZy5mcm9tVmFsdWUoZC5oYXNoVHlwZSkpLnVuc2lnbmVkID0gdHJ1ZTtcbiAgICAgIGVsc2UgaWYgKHR5cGVvZiBkLmhhc2hUeXBlID09PSAnc3RyaW5nJylcbiAgICAgICAgbS5oYXNoVHlwZSA9IHBhcnNlSW50KGQuaGFzaFR5cGUsIDEwKTtcbiAgICAgIGVsc2UgaWYgKHR5cGVvZiBkLmhhc2hUeXBlID09PSAnbnVtYmVyJylcbiAgICAgICAgbS5oYXNoVHlwZSA9IGQuaGFzaFR5cGU7XG4gICAgICBlbHNlIGlmICh0eXBlb2YgZC5oYXNoVHlwZSA9PT0gJ29iamVjdCcpXG4gICAgICAgIG0uaGFzaFR5cGUgPSBuZXcgJHV0aWwuTG9uZ0JpdHMoZC5oYXNoVHlwZS5sb3cgPj4+IDAsIGQuaGFzaFR5cGUuaGlnaCA+Pj4gMCkudG9OdW1iZXIodHJ1ZSk7XG4gICAgfVxuICAgIGlmIChkLmZhbm91dCAhPSBudWxsKSB7XG4gICAgICBpZiAoJHV0aWwuTG9uZylcbiAgICAgICAgKG0uZmFub3V0ID0gJHV0aWwuTG9uZy5mcm9tVmFsdWUoZC5mYW5vdXQpKS51bnNpZ25lZCA9IHRydWU7XG4gICAgICBlbHNlIGlmICh0eXBlb2YgZC5mYW5vdXQgPT09ICdzdHJpbmcnKVxuICAgICAgICBtLmZhbm91dCA9IHBhcnNlSW50KGQuZmFub3V0LCAxMCk7XG4gICAgICBlbHNlIGlmICh0eXBlb2YgZC5mYW5vdXQgPT09ICdudW1iZXInKVxuICAgICAgICBtLmZhbm91dCA9IGQuZmFub3V0O1xuICAgICAgZWxzZSBpZiAodHlwZW9mIGQuZmFub3V0ID09PSAnb2JqZWN0JylcbiAgICAgICAgbS5mYW5vdXQgPSBuZXcgJHV0aWwuTG9uZ0JpdHMoZC5mYW5vdXQubG93ID4+PiAwLCBkLmZhbm91dC5oaWdoID4+PiAwKS50b051bWJlcih0cnVlKTtcbiAgICB9XG4gICAgaWYgKGQubW9kZSAhPSBudWxsKSB7XG4gICAgICBtLm1vZGUgPSBkLm1vZGUgPj4+IDA7XG4gICAgfVxuICAgIGlmIChkLm10aW1lICE9IG51bGwpIHtcbiAgICAgIGlmICh0eXBlb2YgZC5tdGltZSAhPT0gJ29iamVjdCcpXG4gICAgICAgIHRocm93IFR5cGVFcnJvcignLkRhdGEubXRpbWU6IG9iamVjdCBleHBlY3RlZCcpO1xuICAgICAgbS5tdGltZSA9ICRyb290LlVuaXhUaW1lLmZyb21PYmplY3QoZC5tdGltZSk7XG4gICAgfVxuICAgIHJldHVybiBtO1xuICB9O1xuICBEYXRhLnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobSwgbykge1xuICAgIGlmICghbylcbiAgICAgIG8gPSB7fTtcbiAgICB2YXIgZCA9IHt9O1xuICAgIGlmIChvLmFycmF5cyB8fCBvLmRlZmF1bHRzKSB7XG4gICAgICBkLmJsb2Nrc2l6ZXMgPSBbXTtcbiAgICB9XG4gICAgaWYgKG8uZGVmYXVsdHMpIHtcbiAgICAgIGQuVHlwZSA9IG8uZW51bXMgPT09IFN0cmluZyA/ICdSYXcnIDogMDtcbiAgICAgIGlmIChvLmJ5dGVzID09PSBTdHJpbmcpXG4gICAgICAgIGQuRGF0YSA9ICcnO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGQuRGF0YSA9IFtdO1xuICAgICAgICBpZiAoby5ieXRlcyAhPT0gQXJyYXkpXG4gICAgICAgICAgZC5EYXRhID0gJHV0aWwubmV3QnVmZmVyKGQuRGF0YSk7XG4gICAgICB9XG4gICAgICBpZiAoJHV0aWwuTG9uZykge1xuICAgICAgICB2YXIgbiA9IG5ldyAkdXRpbC5Mb25nKDAsIDAsIHRydWUpO1xuICAgICAgICBkLmZpbGVzaXplID0gby5sb25ncyA9PT0gU3RyaW5nID8gbi50b1N0cmluZygpIDogby5sb25ncyA9PT0gTnVtYmVyID8gbi50b051bWJlcigpIDogbjtcbiAgICAgIH0gZWxzZVxuICAgICAgICBkLmZpbGVzaXplID0gby5sb25ncyA9PT0gU3RyaW5nID8gJzAnIDogMDtcbiAgICAgIGlmICgkdXRpbC5Mb25nKSB7XG4gICAgICAgIHZhciBuID0gbmV3ICR1dGlsLkxvbmcoMCwgMCwgdHJ1ZSk7XG4gICAgICAgIGQuaGFzaFR5cGUgPSBvLmxvbmdzID09PSBTdHJpbmcgPyBuLnRvU3RyaW5nKCkgOiBvLmxvbmdzID09PSBOdW1iZXIgPyBuLnRvTnVtYmVyKCkgOiBuO1xuICAgICAgfSBlbHNlXG4gICAgICAgIGQuaGFzaFR5cGUgPSBvLmxvbmdzID09PSBTdHJpbmcgPyAnMCcgOiAwO1xuICAgICAgaWYgKCR1dGlsLkxvbmcpIHtcbiAgICAgICAgdmFyIG4gPSBuZXcgJHV0aWwuTG9uZygwLCAwLCB0cnVlKTtcbiAgICAgICAgZC5mYW5vdXQgPSBvLmxvbmdzID09PSBTdHJpbmcgPyBuLnRvU3RyaW5nKCkgOiBvLmxvbmdzID09PSBOdW1iZXIgPyBuLnRvTnVtYmVyKCkgOiBuO1xuICAgICAgfSBlbHNlXG4gICAgICAgIGQuZmFub3V0ID0gby5sb25ncyA9PT0gU3RyaW5nID8gJzAnIDogMDtcbiAgICAgIGQubW9kZSA9IDA7XG4gICAgICBkLm10aW1lID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKG0uVHlwZSAhPSBudWxsICYmIG0uaGFzT3duUHJvcGVydHkoJ1R5cGUnKSkge1xuICAgICAgZC5UeXBlID0gby5lbnVtcyA9PT0gU3RyaW5nID8gJHJvb3QuRGF0YS5EYXRhVHlwZVttLlR5cGVdIDogbS5UeXBlO1xuICAgIH1cbiAgICBpZiAobS5EYXRhICE9IG51bGwgJiYgbS5oYXNPd25Qcm9wZXJ0eSgnRGF0YScpKSB7XG4gICAgICBkLkRhdGEgPSBvLmJ5dGVzID09PSBTdHJpbmcgPyAkdXRpbC5iYXNlNjQuZW5jb2RlKG0uRGF0YSwgMCwgbS5EYXRhLmxlbmd0aCkgOiBvLmJ5dGVzID09PSBBcnJheSA/IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG0uRGF0YSkgOiBtLkRhdGE7XG4gICAgfVxuICAgIGlmIChtLmZpbGVzaXplICE9IG51bGwgJiYgbS5oYXNPd25Qcm9wZXJ0eSgnZmlsZXNpemUnKSkge1xuICAgICAgaWYgKHR5cGVvZiBtLmZpbGVzaXplID09PSAnbnVtYmVyJylcbiAgICAgICAgZC5maWxlc2l6ZSA9IG8ubG9uZ3MgPT09IFN0cmluZyA/IFN0cmluZyhtLmZpbGVzaXplKSA6IG0uZmlsZXNpemU7XG4gICAgICBlbHNlXG4gICAgICAgIGQuZmlsZXNpemUgPSBvLmxvbmdzID09PSBTdHJpbmcgPyAkdXRpbC5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG0uZmlsZXNpemUpIDogby5sb25ncyA9PT0gTnVtYmVyID8gbmV3ICR1dGlsLkxvbmdCaXRzKG0uZmlsZXNpemUubG93ID4+PiAwLCBtLmZpbGVzaXplLmhpZ2ggPj4+IDApLnRvTnVtYmVyKHRydWUpIDogbS5maWxlc2l6ZTtcbiAgICB9XG4gICAgaWYgKG0uYmxvY2tzaXplcyAmJiBtLmJsb2Nrc2l6ZXMubGVuZ3RoKSB7XG4gICAgICBkLmJsb2Nrc2l6ZXMgPSBbXTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbS5ibG9ja3NpemVzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbS5ibG9ja3NpemVzW2pdID09PSAnbnVtYmVyJylcbiAgICAgICAgICBkLmJsb2Nrc2l6ZXNbal0gPSBvLmxvbmdzID09PSBTdHJpbmcgPyBTdHJpbmcobS5ibG9ja3NpemVzW2pdKSA6IG0uYmxvY2tzaXplc1tqXTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGQuYmxvY2tzaXplc1tqXSA9IG8ubG9uZ3MgPT09IFN0cmluZyA/ICR1dGlsLkxvbmcucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobS5ibG9ja3NpemVzW2pdKSA6IG8ubG9uZ3MgPT09IE51bWJlciA/IG5ldyAkdXRpbC5Mb25nQml0cyhtLmJsb2Nrc2l6ZXNbal0ubG93ID4+PiAwLCBtLmJsb2Nrc2l6ZXNbal0uaGlnaCA+Pj4gMCkudG9OdW1iZXIodHJ1ZSkgOiBtLmJsb2Nrc2l6ZXNbal07XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChtLmhhc2hUeXBlICE9IG51bGwgJiYgbS5oYXNPd25Qcm9wZXJ0eSgnaGFzaFR5cGUnKSkge1xuICAgICAgaWYgKHR5cGVvZiBtLmhhc2hUeXBlID09PSAnbnVtYmVyJylcbiAgICAgICAgZC5oYXNoVHlwZSA9IG8ubG9uZ3MgPT09IFN0cmluZyA/IFN0cmluZyhtLmhhc2hUeXBlKSA6IG0uaGFzaFR5cGU7XG4gICAgICBlbHNlXG4gICAgICAgIGQuaGFzaFR5cGUgPSBvLmxvbmdzID09PSBTdHJpbmcgPyAkdXRpbC5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG0uaGFzaFR5cGUpIDogby5sb25ncyA9PT0gTnVtYmVyID8gbmV3ICR1dGlsLkxvbmdCaXRzKG0uaGFzaFR5cGUubG93ID4+PiAwLCBtLmhhc2hUeXBlLmhpZ2ggPj4+IDApLnRvTnVtYmVyKHRydWUpIDogbS5oYXNoVHlwZTtcbiAgICB9XG4gICAgaWYgKG0uZmFub3V0ICE9IG51bGwgJiYgbS5oYXNPd25Qcm9wZXJ0eSgnZmFub3V0JykpIHtcbiAgICAgIGlmICh0eXBlb2YgbS5mYW5vdXQgPT09ICdudW1iZXInKVxuICAgICAgICBkLmZhbm91dCA9IG8ubG9uZ3MgPT09IFN0cmluZyA/IFN0cmluZyhtLmZhbm91dCkgOiBtLmZhbm91dDtcbiAgICAgIGVsc2VcbiAgICAgICAgZC5mYW5vdXQgPSBvLmxvbmdzID09PSBTdHJpbmcgPyAkdXRpbC5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG0uZmFub3V0KSA6IG8ubG9uZ3MgPT09IE51bWJlciA/IG5ldyAkdXRpbC5Mb25nQml0cyhtLmZhbm91dC5sb3cgPj4+IDAsIG0uZmFub3V0LmhpZ2ggPj4+IDApLnRvTnVtYmVyKHRydWUpIDogbS5mYW5vdXQ7XG4gICAgfVxuICAgIGlmIChtLm1vZGUgIT0gbnVsbCAmJiBtLmhhc093blByb3BlcnR5KCdtb2RlJykpIHtcbiAgICAgIGQubW9kZSA9IG0ubW9kZTtcbiAgICB9XG4gICAgaWYgKG0ubXRpbWUgIT0gbnVsbCAmJiBtLmhhc093blByb3BlcnR5KCdtdGltZScpKSB7XG4gICAgICBkLm10aW1lID0gJHJvb3QuVW5peFRpbWUudG9PYmplY3QobS5tdGltZSwgbyk7XG4gICAgfVxuICAgIHJldHVybiBkO1xuICB9O1xuICBEYXRhLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcywgJHByb3RvYnVmLnV0aWwudG9KU09OT3B0aW9ucyk7XG4gIH07XG4gIERhdGEuRGF0YVR5cGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3QgdmFsdWVzQnlJZCA9IHt9LCB2YWx1ZXMgPSBPYmplY3QuY3JlYXRlKHZhbHVlc0J5SWQpO1xuICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzBdID0gJ1JhdyddID0gMDtcbiAgICB2YWx1ZXNbdmFsdWVzQnlJZFsxXSA9ICdEaXJlY3RvcnknXSA9IDE7XG4gICAgdmFsdWVzW3ZhbHVlc0J5SWRbMl0gPSAnRmlsZSddID0gMjtcbiAgICB2YWx1ZXNbdmFsdWVzQnlJZFszXSA9ICdNZXRhZGF0YSddID0gMztcbiAgICB2YWx1ZXNbdmFsdWVzQnlJZFs0XSA9ICdTeW1saW5rJ10gPSA0O1xuICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzVdID0gJ0hBTVRTaGFyZCddID0gNTtcbiAgICByZXR1cm4gdmFsdWVzO1xuICB9KCk7XG4gIHJldHVybiBEYXRhO1xufSkoKTtcbmV4cG9ydCBjb25zdCBVbml4VGltZSA9ICRyb290LlVuaXhUaW1lID0gKCgpID0+IHtcbiAgZnVuY3Rpb24gVW5peFRpbWUocCkge1xuICAgIGlmIChwKVxuICAgICAgZm9yICh2YXIga3MgPSBPYmplY3Qua2V5cyhwKSwgaSA9IDA7IGkgPCBrcy5sZW5ndGg7ICsraSlcbiAgICAgICAgaWYgKHBba3NbaV1dICE9IG51bGwpXG4gICAgICAgICAgdGhpc1trc1tpXV0gPSBwW2tzW2ldXTtcbiAgfVxuICBVbml4VGltZS5wcm90b3R5cGUuU2Vjb25kcyA9ICR1dGlsLkxvbmcgPyAkdXRpbC5Mb25nLmZyb21CaXRzKDAsIDAsIGZhbHNlKSA6IDA7XG4gIFVuaXhUaW1lLnByb3RvdHlwZS5GcmFjdGlvbmFsTmFub3NlY29uZHMgPSAwO1xuICBVbml4VGltZS5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUobSwgdykge1xuICAgIGlmICghdylcbiAgICAgIHcgPSAkV3JpdGVyLmNyZWF0ZSgpO1xuICAgIHcudWludDMyKDgpLmludDY0KG0uU2Vjb25kcyk7XG4gICAgaWYgKG0uRnJhY3Rpb25hbE5hbm9zZWNvbmRzICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobSwgJ0ZyYWN0aW9uYWxOYW5vc2Vjb25kcycpKVxuICAgICAgdy51aW50MzIoMjEpLmZpeGVkMzIobS5GcmFjdGlvbmFsTmFub3NlY29uZHMpO1xuICAgIHJldHVybiB3O1xuICB9O1xuICBVbml4VGltZS5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUociwgbCkge1xuICAgIGlmICghKHIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgIHIgPSAkUmVhZGVyLmNyZWF0ZShyKTtcbiAgICB2YXIgYyA9IGwgPT09IHVuZGVmaW5lZCA/IHIubGVuIDogci5wb3MgKyBsLCBtID0gbmV3ICRyb290LlVuaXhUaW1lKCk7XG4gICAgd2hpbGUgKHIucG9zIDwgYykge1xuICAgICAgdmFyIHQgPSByLnVpbnQzMigpO1xuICAgICAgc3dpdGNoICh0ID4+PiAzKSB7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIG0uU2Vjb25kcyA9IHIuaW50NjQoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIG0uRnJhY3Rpb25hbE5hbm9zZWNvbmRzID0gci5maXhlZDMyKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgci5za2lwVHlwZSh0ICYgNyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIW0uaGFzT3duUHJvcGVydHkoJ1NlY29uZHMnKSlcbiAgICAgIHRocm93ICR1dGlsLlByb3RvY29sRXJyb3IoJ21pc3NpbmcgcmVxdWlyZWQgXFwnU2Vjb25kc1xcJycsIHsgaW5zdGFuY2U6IG0gfSk7XG4gICAgcmV0dXJuIG07XG4gIH07XG4gIFVuaXhUaW1lLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KGQpIHtcbiAgICBpZiAoZCBpbnN0YW5jZW9mICRyb290LlVuaXhUaW1lKVxuICAgICAgcmV0dXJuIGQ7XG4gICAgdmFyIG0gPSBuZXcgJHJvb3QuVW5peFRpbWUoKTtcbiAgICBpZiAoZC5TZWNvbmRzICE9IG51bGwpIHtcbiAgICAgIGlmICgkdXRpbC5Mb25nKVxuICAgICAgICAobS5TZWNvbmRzID0gJHV0aWwuTG9uZy5mcm9tVmFsdWUoZC5TZWNvbmRzKSkudW5zaWduZWQgPSBmYWxzZTtcbiAgICAgIGVsc2UgaWYgKHR5cGVvZiBkLlNlY29uZHMgPT09ICdzdHJpbmcnKVxuICAgICAgICBtLlNlY29uZHMgPSBwYXJzZUludChkLlNlY29uZHMsIDEwKTtcbiAgICAgIGVsc2UgaWYgKHR5cGVvZiBkLlNlY29uZHMgPT09ICdudW1iZXInKVxuICAgICAgICBtLlNlY29uZHMgPSBkLlNlY29uZHM7XG4gICAgICBlbHNlIGlmICh0eXBlb2YgZC5TZWNvbmRzID09PSAnb2JqZWN0JylcbiAgICAgICAgbS5TZWNvbmRzID0gbmV3ICR1dGlsLkxvbmdCaXRzKGQuU2Vjb25kcy5sb3cgPj4+IDAsIGQuU2Vjb25kcy5oaWdoID4+PiAwKS50b051bWJlcigpO1xuICAgIH1cbiAgICBpZiAoZC5GcmFjdGlvbmFsTmFub3NlY29uZHMgIT0gbnVsbCkge1xuICAgICAgbS5GcmFjdGlvbmFsTmFub3NlY29uZHMgPSBkLkZyYWN0aW9uYWxOYW5vc2Vjb25kcyA+Pj4gMDtcbiAgICB9XG4gICAgcmV0dXJuIG07XG4gIH07XG4gIFVuaXhUaW1lLnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobSwgbykge1xuICAgIGlmICghbylcbiAgICAgIG8gPSB7fTtcbiAgICB2YXIgZCA9IHt9O1xuICAgIGlmIChvLmRlZmF1bHRzKSB7XG4gICAgICBpZiAoJHV0aWwuTG9uZykge1xuICAgICAgICB2YXIgbiA9IG5ldyAkdXRpbC5Mb25nKDAsIDAsIGZhbHNlKTtcbiAgICAgICAgZC5TZWNvbmRzID0gby5sb25ncyA9PT0gU3RyaW5nID8gbi50b1N0cmluZygpIDogby5sb25ncyA9PT0gTnVtYmVyID8gbi50b051bWJlcigpIDogbjtcbiAgICAgIH0gZWxzZVxuICAgICAgICBkLlNlY29uZHMgPSBvLmxvbmdzID09PSBTdHJpbmcgPyAnMCcgOiAwO1xuICAgICAgZC5GcmFjdGlvbmFsTmFub3NlY29uZHMgPSAwO1xuICAgIH1cbiAgICBpZiAobS5TZWNvbmRzICE9IG51bGwgJiYgbS5oYXNPd25Qcm9wZXJ0eSgnU2Vjb25kcycpKSB7XG4gICAgICBpZiAodHlwZW9mIG0uU2Vjb25kcyA9PT0gJ251bWJlcicpXG4gICAgICAgIGQuU2Vjb25kcyA9IG8ubG9uZ3MgPT09IFN0cmluZyA/IFN0cmluZyhtLlNlY29uZHMpIDogbS5TZWNvbmRzO1xuICAgICAgZWxzZVxuICAgICAgICBkLlNlY29uZHMgPSBvLmxvbmdzID09PSBTdHJpbmcgPyAkdXRpbC5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG0uU2Vjb25kcykgOiBvLmxvbmdzID09PSBOdW1iZXIgPyBuZXcgJHV0aWwuTG9uZ0JpdHMobS5TZWNvbmRzLmxvdyA+Pj4gMCwgbS5TZWNvbmRzLmhpZ2ggPj4+IDApLnRvTnVtYmVyKCkgOiBtLlNlY29uZHM7XG4gICAgfVxuICAgIGlmIChtLkZyYWN0aW9uYWxOYW5vc2Vjb25kcyAhPSBudWxsICYmIG0uaGFzT3duUHJvcGVydHkoJ0ZyYWN0aW9uYWxOYW5vc2Vjb25kcycpKSB7XG4gICAgICBkLkZyYWN0aW9uYWxOYW5vc2Vjb25kcyA9IG0uRnJhY3Rpb25hbE5hbm9zZWNvbmRzO1xuICAgIH1cbiAgICByZXR1cm4gZDtcbiAgfTtcbiAgVW5peFRpbWUucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLCAkcHJvdG9idWYudXRpbC50b0pTT05PcHRpb25zKTtcbiAgfTtcbiAgcmV0dXJuIFVuaXhUaW1lO1xufSkoKTtcbmV4cG9ydCBjb25zdCBNZXRhZGF0YSA9ICRyb290Lk1ldGFkYXRhID0gKCgpID0+IHtcbiAgZnVuY3Rpb24gTWV0YWRhdGEocCkge1xuICAgIGlmIChwKVxuICAgICAgZm9yICh2YXIga3MgPSBPYmplY3Qua2V5cyhwKSwgaSA9IDA7IGkgPCBrcy5sZW5ndGg7ICsraSlcbiAgICAgICAgaWYgKHBba3NbaV1dICE9IG51bGwpXG4gICAgICAgICAgdGhpc1trc1tpXV0gPSBwW2tzW2ldXTtcbiAgfVxuICBNZXRhZGF0YS5wcm90b3R5cGUuTWltZVR5cGUgPSAnJztcbiAgTWV0YWRhdGEuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKG0sIHcpIHtcbiAgICBpZiAoIXcpXG4gICAgICB3ID0gJFdyaXRlci5jcmVhdGUoKTtcbiAgICBpZiAobS5NaW1lVHlwZSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG0sICdNaW1lVHlwZScpKVxuICAgICAgdy51aW50MzIoMTApLnN0cmluZyhtLk1pbWVUeXBlKTtcbiAgICByZXR1cm4gdztcbiAgfTtcbiAgTWV0YWRhdGEuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHIsIGwpIHtcbiAgICBpZiAoIShyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICByID0gJFJlYWRlci5jcmVhdGUocik7XG4gICAgdmFyIGMgPSBsID09PSB1bmRlZmluZWQgPyByLmxlbiA6IHIucG9zICsgbCwgbSA9IG5ldyAkcm9vdC5NZXRhZGF0YSgpO1xuICAgIHdoaWxlIChyLnBvcyA8IGMpIHtcbiAgICAgIHZhciB0ID0gci51aW50MzIoKTtcbiAgICAgIHN3aXRjaCAodCA+Pj4gMykge1xuICAgICAgY2FzZSAxOlxuICAgICAgICBtLk1pbWVUeXBlID0gci5zdHJpbmcoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByLnNraXBUeXBlKHQgJiA3KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtO1xuICB9O1xuICBNZXRhZGF0YS5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChkKSB7XG4gICAgaWYgKGQgaW5zdGFuY2VvZiAkcm9vdC5NZXRhZGF0YSlcbiAgICAgIHJldHVybiBkO1xuICAgIHZhciBtID0gbmV3ICRyb290Lk1ldGFkYXRhKCk7XG4gICAgaWYgKGQuTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgbS5NaW1lVHlwZSA9IFN0cmluZyhkLk1pbWVUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIG07XG4gIH07XG4gIE1ldGFkYXRhLnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobSwgbykge1xuICAgIGlmICghbylcbiAgICAgIG8gPSB7fTtcbiAgICB2YXIgZCA9IHt9O1xuICAgIGlmIChvLmRlZmF1bHRzKSB7XG4gICAgICBkLk1pbWVUeXBlID0gJyc7XG4gICAgfVxuICAgIGlmIChtLk1pbWVUeXBlICE9IG51bGwgJiYgbS5oYXNPd25Qcm9wZXJ0eSgnTWltZVR5cGUnKSkge1xuICAgICAgZC5NaW1lVHlwZSA9IG0uTWltZVR5cGU7XG4gICAgfVxuICAgIHJldHVybiBkO1xuICB9O1xuICBNZXRhZGF0YS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsICRwcm90b2J1Zi51dGlsLnRvSlNPTk9wdGlvbnMpO1xuICB9O1xuICByZXR1cm4gTWV0YWRhdGE7XG59KSgpO1xuZXhwb3J0IHtcbiAgJHJvb3QgYXMgZGVmYXVsdFxufTsiLCAiaW1wb3J0IHsgQ0lEIH0gZnJvbSAnbXVsdGlmb3JtYXRzL2NpZCc7XG5pbXBvcnQgKiBhcyBkYWdQYiBmcm9tICdAaXBsZC9kYWctcGInO1xuaW1wb3J0IHsgc2hhMjU2IH0gZnJvbSAnbXVsdGlmb3JtYXRzL2hhc2hlcy9zaGEyJztcbmNvbnN0IHBlcnNpc3QgPSBhc3luYyAoYnVmZmVyLCBibG9ja3N0b3JlLCBvcHRpb25zKSA9PiB7XG4gIGlmICghb3B0aW9ucy5jb2RlYykge1xuICAgIG9wdGlvbnMuY29kZWMgPSBkYWdQYjtcbiAgfVxuICBpZiAoIW9wdGlvbnMuaGFzaGVyKSB7XG4gICAgb3B0aW9ucy5oYXNoZXIgPSBzaGEyNTY7XG4gIH1cbiAgaWYgKG9wdGlvbnMuY2lkVmVyc2lvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgb3B0aW9ucy5jaWRWZXJzaW9uID0gMTtcbiAgfVxuICBpZiAob3B0aW9ucy5jb2RlYyA9PT0gZGFnUGIgJiYgb3B0aW9ucy5oYXNoZXIgIT09IHNoYTI1Nikge1xuICAgIG9wdGlvbnMuY2lkVmVyc2lvbiA9IDE7XG4gIH1cbiAgY29uc3QgbXVsdGloYXNoID0gYXdhaXQgb3B0aW9ucy5oYXNoZXIuZGlnZXN0KGJ1ZmZlcik7XG4gIGNvbnN0IGNpZCA9IENJRC5jcmVhdGUob3B0aW9ucy5jaWRWZXJzaW9uLCBvcHRpb25zLmNvZGVjLmNvZGUsIG11bHRpaGFzaCk7XG4gIGlmICghb3B0aW9ucy5vbmx5SGFzaCkge1xuICAgIGF3YWl0IGJsb2Nrc3RvcmUucHV0KGNpZCwgYnVmZmVyLCB7IHNpZ25hbDogb3B0aW9ucy5zaWduYWwgfSk7XG4gIH1cbiAgcmV0dXJuIGNpZDtcbn07XG5leHBvcnQgZGVmYXVsdCBwZXJzaXN0OyIsICJpbXBvcnQgeyBVbml4RlMgfSBmcm9tICdpcGZzLXVuaXhmcyc7XG5pbXBvcnQgcGVyc2lzdCBmcm9tICcuLi91dGlscy9wZXJzaXN0LmpzJztcbmltcG9ydCB7XG4gIGVuY29kZSxcbiAgcHJlcGFyZVxufSBmcm9tICdAaXBsZC9kYWctcGInO1xuY29uc3QgZGlyQnVpbGRlciA9IGFzeW5jIChpdGVtLCBibG9ja3N0b3JlLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHVuaXhmcyA9IG5ldyBVbml4RlMoe1xuICAgIHR5cGU6ICdkaXJlY3RvcnknLFxuICAgIG10aW1lOiBpdGVtLm10aW1lLFxuICAgIG1vZGU6IGl0ZW0ubW9kZVxuICB9KTtcbiAgY29uc3QgYnVmZmVyID0gZW5jb2RlKHByZXBhcmUoeyBEYXRhOiB1bml4ZnMubWFyc2hhbCgpIH0pKTtcbiAgY29uc3QgY2lkID0gYXdhaXQgcGVyc2lzdChidWZmZXIsIGJsb2Nrc3RvcmUsIG9wdGlvbnMpO1xuICBjb25zdCBwYXRoID0gaXRlbS5wYXRoO1xuICByZXR1cm4ge1xuICAgIGNpZCxcbiAgICBwYXRoLFxuICAgIHVuaXhmcyxcbiAgICBzaXplOiBidWZmZXIubGVuZ3RoXG4gIH07XG59O1xuZXhwb3J0IGRlZmF1bHQgZGlyQnVpbGRlcjsiLCAiaW1wb3J0IGVyckNvZGUgZnJvbSAnZXJyLWNvZGUnO1xuaW1wb3J0IHsgVW5peEZTIH0gZnJvbSAnaXBmcy11bml4ZnMnO1xuaW1wb3J0IHBlcnNpc3QgZnJvbSAnLi4vLi4vdXRpbHMvcGVyc2lzdC5qcyc7XG5pbXBvcnQge1xuICBlbmNvZGUsXG4gIHByZXBhcmVcbn0gZnJvbSAnQGlwbGQvZGFnLXBiJztcbmltcG9ydCBwYXJhbGxlbEJhdGNoIGZyb20gJ2l0LXBhcmFsbGVsLWJhdGNoJztcbmltcG9ydCAqIGFzIHJhd0NvZGVjIGZyb20gJ211bHRpZm9ybWF0cy9jb2RlY3MvcmF3JztcbmltcG9ydCAqIGFzIGRhZ1BiIGZyb20gJ0BpcGxkL2RhZy1wYic7XG5pbXBvcnQgZGFnRmxhdCBmcm9tICcuL2ZsYXQuanMnO1xuaW1wb3J0IGRhZ0JhbGFuY2VkIGZyb20gJy4vYmFsYW5jZWQuanMnO1xuaW1wb3J0IGRhZ1RyaWNrbGUgZnJvbSAnLi90cmlja2xlLmpzJztcbmltcG9ydCBidWZmZXJJbXBvcnRlckZuIGZyb20gJy4vYnVmZmVyLWltcG9ydGVyLmpzJztcbmNvbnN0IGRhZ0J1aWxkZXJzID0ge1xuICBmbGF0OiBkYWdGbGF0LFxuICBiYWxhbmNlZDogZGFnQmFsYW5jZWQsXG4gIHRyaWNrbGU6IGRhZ1RyaWNrbGVcbn07XG5hc3luYyBmdW5jdGlvbiogYnVpbGRGaWxlQmF0Y2goZmlsZSwgYmxvY2tzdG9yZSwgb3B0aW9ucykge1xuICBsZXQgY291bnQgPSAtMTtcbiAgbGV0IHByZXZpb3VzO1xuICBsZXQgYnVmZmVySW1wb3J0ZXI7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5idWZmZXJJbXBvcnRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGJ1ZmZlckltcG9ydGVyID0gb3B0aW9ucy5idWZmZXJJbXBvcnRlcjtcbiAgfSBlbHNlIHtcbiAgICBidWZmZXJJbXBvcnRlciA9IGJ1ZmZlckltcG9ydGVyRm47XG4gIH1cbiAgZm9yIGF3YWl0IChjb25zdCBlbnRyeSBvZiBwYXJhbGxlbEJhdGNoKGJ1ZmZlckltcG9ydGVyKGZpbGUsIGJsb2Nrc3RvcmUsIG9wdGlvbnMpLCBvcHRpb25zLmJsb2NrV3JpdGVDb25jdXJyZW5jeSkpIHtcbiAgICBjb3VudCsrO1xuICAgIGlmIChjb3VudCA9PT0gMCkge1xuICAgICAgcHJldmlvdXMgPSBlbnRyeTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gZWxzZSBpZiAoY291bnQgPT09IDEgJiYgcHJldmlvdXMpIHtcbiAgICAgIHlpZWxkIHByZXZpb3VzO1xuICAgICAgcHJldmlvdXMgPSBudWxsO1xuICAgIH1cbiAgICB5aWVsZCBlbnRyeTtcbiAgfVxuICBpZiAocHJldmlvdXMpIHtcbiAgICBwcmV2aW91cy5zaW5nbGUgPSB0cnVlO1xuICAgIHlpZWxkIHByZXZpb3VzO1xuICB9XG59XG5jb25zdCByZWR1Y2UgPSAoZmlsZSwgYmxvY2tzdG9yZSwgb3B0aW9ucykgPT4ge1xuICBhc3luYyBmdW5jdGlvbiByZWR1Y2VyKGxlYXZlcykge1xuICAgIGlmIChsZWF2ZXMubGVuZ3RoID09PSAxICYmIGxlYXZlc1swXS5zaW5nbGUgJiYgb3B0aW9ucy5yZWR1Y2VTaW5nbGVMZWFmVG9TZWxmKSB7XG4gICAgICBjb25zdCBsZWFmID0gbGVhdmVzWzBdO1xuICAgICAgaWYgKGZpbGUubXRpbWUgIT09IHVuZGVmaW5lZCB8fCBmaWxlLm1vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgYnVmZmVyID0gYXdhaXQgYmxvY2tzdG9yZS5nZXQobGVhZi5jaWQpO1xuICAgICAgICBsZWFmLnVuaXhmcyA9IG5ldyBVbml4RlMoe1xuICAgICAgICAgIHR5cGU6ICdmaWxlJyxcbiAgICAgICAgICBtdGltZTogZmlsZS5tdGltZSxcbiAgICAgICAgICBtb2RlOiBmaWxlLm1vZGUsXG4gICAgICAgICAgZGF0YTogYnVmZmVyXG4gICAgICAgIH0pO1xuICAgICAgICBidWZmZXIgPSBlbmNvZGUocHJlcGFyZSh7IERhdGE6IGxlYWYudW5peGZzLm1hcnNoYWwoKSB9KSk7XG4gICAgICAgIGxlYWYuY2lkID0gYXdhaXQgcGVyc2lzdChidWZmZXIsIGJsb2Nrc3RvcmUsIHtcbiAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgIGNvZGVjOiBkYWdQYixcbiAgICAgICAgICBoYXNoZXI6IG9wdGlvbnMuaGFzaGVyLFxuICAgICAgICAgIGNpZFZlcnNpb246IG9wdGlvbnMuY2lkVmVyc2lvblxuICAgICAgICB9KTtcbiAgICAgICAgbGVhZi5zaXplID0gYnVmZmVyLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNpZDogbGVhZi5jaWQsXG4gICAgICAgIHBhdGg6IGZpbGUucGF0aCxcbiAgICAgICAgdW5peGZzOiBsZWFmLnVuaXhmcyxcbiAgICAgICAgc2l6ZTogbGVhZi5zaXplXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBmID0gbmV3IFVuaXhGUyh7XG4gICAgICB0eXBlOiAnZmlsZScsXG4gICAgICBtdGltZTogZmlsZS5tdGltZSxcbiAgICAgIG1vZGU6IGZpbGUubW9kZVxuICAgIH0pO1xuICAgIGNvbnN0IGxpbmtzID0gbGVhdmVzLmZpbHRlcihsZWFmID0+IHtcbiAgICAgIGlmIChsZWFmLmNpZC5jb2RlID09PSByYXdDb2RlYy5jb2RlICYmIGxlYWYuc2l6ZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChsZWFmLnVuaXhmcyAmJiAhbGVhZi51bml4ZnMuZGF0YSAmJiBsZWFmLnVuaXhmcy5maWxlU2l6ZSgpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEJvb2xlYW4obGVhZi51bml4ZnMgJiYgbGVhZi51bml4ZnMuZGF0YSAmJiBsZWFmLnVuaXhmcy5kYXRhLmxlbmd0aCk7XG4gICAgfSkubWFwKGxlYWYgPT4ge1xuICAgICAgaWYgKGxlYWYuY2lkLmNvZGUgPT09IHJhd0NvZGVjLmNvZGUpIHtcbiAgICAgICAgZi5hZGRCbG9ja1NpemUobGVhZi5zaXplKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBOYW1lOiAnJyxcbiAgICAgICAgICBUc2l6ZTogbGVhZi5zaXplLFxuICAgICAgICAgIEhhc2g6IGxlYWYuY2lkXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAoIWxlYWYudW5peGZzIHx8ICFsZWFmLnVuaXhmcy5kYXRhKSB7XG4gICAgICAgIGYuYWRkQmxvY2tTaXplKGxlYWYudW5peGZzICYmIGxlYWYudW5peGZzLmZpbGVTaXplKCkgfHwgMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmLmFkZEJsb2NrU2l6ZShsZWFmLnVuaXhmcy5kYXRhLmxlbmd0aCk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBOYW1lOiAnJyxcbiAgICAgICAgVHNpemU6IGxlYWYuc2l6ZSxcbiAgICAgICAgSGFzaDogbGVhZi5jaWRcbiAgICAgIH07XG4gICAgfSk7XG4gICAgY29uc3Qgbm9kZSA9IHtcbiAgICAgIERhdGE6IGYubWFyc2hhbCgpLFxuICAgICAgTGlua3M6IGxpbmtzXG4gICAgfTtcbiAgICBjb25zdCBidWZmZXIgPSBlbmNvZGUocHJlcGFyZShub2RlKSk7XG4gICAgY29uc3QgY2lkID0gYXdhaXQgcGVyc2lzdChidWZmZXIsIGJsb2Nrc3RvcmUsIG9wdGlvbnMpO1xuICAgIHJldHVybiB7XG4gICAgICBjaWQsXG4gICAgICBwYXRoOiBmaWxlLnBhdGgsXG4gICAgICB1bml4ZnM6IGYsXG4gICAgICBzaXplOiBidWZmZXIubGVuZ3RoICsgbm9kZS5MaW5rcy5yZWR1Y2UoKGFjYywgY3VycikgPT4gYWNjICsgY3Vyci5Uc2l6ZSwgMClcbiAgICB9O1xuICB9XG4gIHJldHVybiByZWR1Y2VyO1xufTtcbmZ1bmN0aW9uIGZpbGVCdWlsZGVyKGZpbGUsIGJsb2NrLCBvcHRpb25zKSB7XG4gIGNvbnN0IGRhZ0J1aWxkZXIgPSBkYWdCdWlsZGVyc1tvcHRpb25zLnN0cmF0ZWd5XTtcbiAgaWYgKCFkYWdCdWlsZGVyKSB7XG4gICAgdGhyb3cgZXJyQ29kZShuZXcgRXJyb3IoYFVua25vd24gaW1wb3J0ZXIgYnVpbGQgc3RyYXRlZ3kgbmFtZTogJHsgb3B0aW9ucy5zdHJhdGVneSB9YCksICdFUlJfQkFEX1NUUkFURUdZJyk7XG4gIH1cbiAgcmV0dXJuIGRhZ0J1aWxkZXIoYnVpbGRGaWxlQmF0Y2goZmlsZSwgYmxvY2ssIG9wdGlvbnMpLCByZWR1Y2UoZmlsZSwgYmxvY2ssIG9wdGlvbnMpLCBvcHRpb25zKTtcbn1cbmV4cG9ydCBkZWZhdWx0IGZpbGVCdWlsZGVyOyIsICJpbXBvcnQgYWxsIGZyb20gJ2l0LWFsbCc7XG5hc3luYyBmdW5jdGlvbiBmbGF0KHNvdXJjZSwgcmVkdWNlKSB7XG4gIHJldHVybiByZWR1Y2UoYXdhaXQgYWxsKHNvdXJjZSkpO1xufVxuZXhwb3J0IGRlZmF1bHQgZmxhdDsiLCAiaW1wb3J0IGJhdGNoIGZyb20gJ2l0LWJhdGNoJztcbmZ1bmN0aW9uIGJhbGFuY2VkKHNvdXJjZSwgcmVkdWNlLCBvcHRpb25zKSB7XG4gIHJldHVybiByZWR1Y2VUb1BhcmVudHMoc291cmNlLCByZWR1Y2UsIG9wdGlvbnMpO1xufVxuYXN5bmMgZnVuY3Rpb24gcmVkdWNlVG9QYXJlbnRzKHNvdXJjZSwgcmVkdWNlLCBvcHRpb25zKSB7XG4gIGNvbnN0IHJvb3RzID0gW107XG4gIGZvciBhd2FpdCAoY29uc3QgY2h1bmtlZCBvZiBiYXRjaChzb3VyY2UsIG9wdGlvbnMubWF4Q2hpbGRyZW5QZXJOb2RlKSkge1xuICAgIHJvb3RzLnB1c2goYXdhaXQgcmVkdWNlKGNodW5rZWQpKTtcbiAgfVxuICBpZiAocm9vdHMubGVuZ3RoID4gMSkge1xuICAgIHJldHVybiByZWR1Y2VUb1BhcmVudHMocm9vdHMsIHJlZHVjZSwgb3B0aW9ucyk7XG4gIH1cbiAgcmV0dXJuIHJvb3RzWzBdO1xufVxuZXhwb3J0IGRlZmF1bHQgYmFsYW5jZWQ7IiwgImltcG9ydCBiYXRjaCBmcm9tICdpdC1iYXRjaCc7XG5hc3luYyBmdW5jdGlvbiB0cmlja2xlU3RyZWFtKHNvdXJjZSwgcmVkdWNlLCBvcHRpb25zKSB7XG4gIGNvbnN0IHJvb3QgPSBuZXcgUm9vdChvcHRpb25zLmxheWVyUmVwZWF0KTtcbiAgbGV0IGl0ZXJhdGlvbiA9IDA7XG4gIGxldCBtYXhEZXB0aCA9IDE7XG4gIGxldCBzdWJUcmVlID0gcm9vdDtcbiAgZm9yIGF3YWl0IChjb25zdCBsYXllciBvZiBiYXRjaChzb3VyY2UsIG9wdGlvbnMubWF4Q2hpbGRyZW5QZXJOb2RlKSkge1xuICAgIGlmIChzdWJUcmVlLmlzRnVsbCgpKSB7XG4gICAgICBpZiAoc3ViVHJlZSAhPT0gcm9vdCkge1xuICAgICAgICByb290LmFkZENoaWxkKGF3YWl0IHN1YlRyZWUucmVkdWNlKHJlZHVjZSkpO1xuICAgICAgfVxuICAgICAgaWYgKGl0ZXJhdGlvbiAmJiBpdGVyYXRpb24gJSBvcHRpb25zLmxheWVyUmVwZWF0ID09PSAwKSB7XG4gICAgICAgIG1heERlcHRoKys7XG4gICAgICB9XG4gICAgICBzdWJUcmVlID0gbmV3IFN1YlRyZWUobWF4RGVwdGgsIG9wdGlvbnMubGF5ZXJSZXBlYXQsIGl0ZXJhdGlvbik7XG4gICAgICBpdGVyYXRpb24rKztcbiAgICB9XG4gICAgc3ViVHJlZS5hcHBlbmQobGF5ZXIpO1xuICB9XG4gIGlmIChzdWJUcmVlICYmIHN1YlRyZWUgIT09IHJvb3QpIHtcbiAgICByb290LmFkZENoaWxkKGF3YWl0IHN1YlRyZWUucmVkdWNlKHJlZHVjZSkpO1xuICB9XG4gIHJldHVybiByb290LnJlZHVjZShyZWR1Y2UpO1xufVxuZXhwb3J0IGRlZmF1bHQgdHJpY2tsZVN0cmVhbTtcbmNsYXNzIFN1YlRyZWUge1xuICBjb25zdHJ1Y3RvcihtYXhEZXB0aCwgbGF5ZXJSZXBlYXQsIGl0ZXJhdGlvbiA9IDApIHtcbiAgICB0aGlzLm1heERlcHRoID0gbWF4RGVwdGg7XG4gICAgdGhpcy5sYXllclJlcGVhdCA9IGxheWVyUmVwZWF0O1xuICAgIHRoaXMuY3VycmVudERlcHRoID0gMTtcbiAgICB0aGlzLml0ZXJhdGlvbiA9IGl0ZXJhdGlvbjtcbiAgICB0aGlzLnJvb3QgPSB0aGlzLm5vZGUgPSB0aGlzLnBhcmVudCA9IHtcbiAgICAgIGNoaWxkcmVuOiBbXSxcbiAgICAgIGRlcHRoOiB0aGlzLmN1cnJlbnREZXB0aCxcbiAgICAgIG1heERlcHRoLFxuICAgICAgbWF4Q2hpbGRyZW46ICh0aGlzLm1heERlcHRoIC0gdGhpcy5jdXJyZW50RGVwdGgpICogdGhpcy5sYXllclJlcGVhdFxuICAgIH07XG4gIH1cbiAgaXNGdWxsKCkge1xuICAgIGlmICghdGhpcy5yb290LmRhdGEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuY3VycmVudERlcHRoIDwgdGhpcy5tYXhEZXB0aCAmJiB0aGlzLm5vZGUubWF4Q2hpbGRyZW4pIHtcbiAgICAgIHRoaXMuX2FkZE5leHROb2RlVG9QYXJlbnQodGhpcy5ub2RlKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgZGlzdGFudFJlbGF0aXZlID0gdGhpcy5fZmluZFBhcmVudCh0aGlzLm5vZGUsIHRoaXMuY3VycmVudERlcHRoKTtcbiAgICBpZiAoZGlzdGFudFJlbGF0aXZlKSB7XG4gICAgICB0aGlzLl9hZGROZXh0Tm9kZVRvUGFyZW50KGRpc3RhbnRSZWxhdGl2ZSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIF9hZGROZXh0Tm9kZVRvUGFyZW50KHBhcmVudCkge1xuICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgIGNvbnN0IG5leHROb2RlID0ge1xuICAgICAgY2hpbGRyZW46IFtdLFxuICAgICAgZGVwdGg6IHBhcmVudC5kZXB0aCArIDEsXG4gICAgICBwYXJlbnQsXG4gICAgICBtYXhEZXB0aDogdGhpcy5tYXhEZXB0aCxcbiAgICAgIG1heENoaWxkcmVuOiBNYXRoLmZsb29yKHBhcmVudC5jaGlsZHJlbi5sZW5ndGggLyB0aGlzLmxheWVyUmVwZWF0KSAqIHRoaXMubGF5ZXJSZXBlYXRcbiAgICB9O1xuICAgIHBhcmVudC5jaGlsZHJlbi5wdXNoKG5leHROb2RlKTtcbiAgICB0aGlzLmN1cnJlbnREZXB0aCA9IG5leHROb2RlLmRlcHRoO1xuICAgIHRoaXMubm9kZSA9IG5leHROb2RlO1xuICB9XG4gIGFwcGVuZChsYXllcikge1xuICAgIHRoaXMubm9kZS5kYXRhID0gbGF5ZXI7XG4gIH1cbiAgcmVkdWNlKHJlZHVjZSkge1xuICAgIHJldHVybiB0aGlzLl9yZWR1Y2UodGhpcy5yb290LCByZWR1Y2UpO1xuICB9XG4gIGFzeW5jIF9yZWR1Y2Uobm9kZSwgcmVkdWNlKSB7XG4gICAgbGV0IGNoaWxkcmVuID0gW107XG4gICAgaWYgKG5vZGUuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICBjaGlsZHJlbiA9IGF3YWl0IFByb21pc2UuYWxsKG5vZGUuY2hpbGRyZW4uZmlsdGVyKGNoaWxkID0+IGNoaWxkLmRhdGEpLm1hcChjaGlsZCA9PiB0aGlzLl9yZWR1Y2UoY2hpbGQsIHJlZHVjZSkpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlZHVjZSgobm9kZS5kYXRhIHx8IFtdKS5jb25jYXQoY2hpbGRyZW4pKTtcbiAgfVxuICBfZmluZFBhcmVudChub2RlLCBkZXB0aCkge1xuICAgIGNvbnN0IHBhcmVudCA9IG5vZGUucGFyZW50O1xuICAgIGlmICghcGFyZW50IHx8IHBhcmVudC5kZXB0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAocGFyZW50LmNoaWxkcmVuLmxlbmd0aCA9PT0gcGFyZW50Lm1heENoaWxkcmVuIHx8ICFwYXJlbnQubWF4Q2hpbGRyZW4pIHtcbiAgICAgIHJldHVybiB0aGlzLl9maW5kUGFyZW50KHBhcmVudCwgZGVwdGgpO1xuICAgIH1cbiAgICByZXR1cm4gcGFyZW50O1xuICB9XG59XG5jbGFzcyBSb290IGV4dGVuZHMgU3ViVHJlZSB7XG4gIGNvbnN0cnVjdG9yKGxheWVyUmVwZWF0KSB7XG4gICAgc3VwZXIoMCwgbGF5ZXJSZXBlYXQpO1xuICAgIHRoaXMucm9vdC5kZXB0aCA9IDA7XG4gICAgdGhpcy5jdXJyZW50RGVwdGggPSAxO1xuICB9XG4gIGFkZENoaWxkKGNoaWxkKSB7XG4gICAgdGhpcy5yb290LmNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICB9XG4gIHJlZHVjZShyZWR1Y2UpIHtcbiAgICByZXR1cm4gcmVkdWNlKCh0aGlzLnJvb3QuZGF0YSB8fCBbXSkuY29uY2F0KHRoaXMucm9vdC5jaGlsZHJlbikpO1xuICB9XG59IiwgImltcG9ydCB7IFVuaXhGUyB9IGZyb20gJ2lwZnMtdW5peGZzJztcbmltcG9ydCBwZXJzaXN0IGZyb20gJy4uLy4uL3V0aWxzL3BlcnNpc3QuanMnO1xuaW1wb3J0ICogYXMgZGFnUGIgZnJvbSAnQGlwbGQvZGFnLXBiJztcbmltcG9ydCAqIGFzIHJhdyBmcm9tICdtdWx0aWZvcm1hdHMvY29kZWNzL3Jhdyc7XG5hc3luYyBmdW5jdGlvbiogYnVmZmVySW1wb3J0ZXIoZmlsZSwgYmxvY2ssIG9wdGlvbnMpIHtcbiAgZm9yIGF3YWl0IChsZXQgYnVmZmVyIG9mIGZpbGUuY29udGVudCkge1xuICAgIHlpZWxkIGFzeW5jICgpID0+IHtcbiAgICAgIG9wdGlvbnMucHJvZ3Jlc3MoYnVmZmVyLmxlbmd0aCwgZmlsZS5wYXRoKTtcbiAgICAgIGxldCB1bml4ZnM7XG4gICAgICBjb25zdCBvcHRzID0ge1xuICAgICAgICBjb2RlYzogZGFnUGIsXG4gICAgICAgIGNpZFZlcnNpb246IG9wdGlvbnMuY2lkVmVyc2lvbixcbiAgICAgICAgaGFzaGVyOiBvcHRpb25zLmhhc2hlcixcbiAgICAgICAgb25seUhhc2g6IG9wdGlvbnMub25seUhhc2hcbiAgICAgIH07XG4gICAgICBpZiAob3B0aW9ucy5yYXdMZWF2ZXMpIHtcbiAgICAgICAgb3B0cy5jb2RlYyA9IHJhdztcbiAgICAgICAgb3B0cy5jaWRWZXJzaW9uID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVuaXhmcyA9IG5ldyBVbml4RlMoe1xuICAgICAgICAgIHR5cGU6IG9wdGlvbnMubGVhZlR5cGUsXG4gICAgICAgICAgZGF0YTogYnVmZmVyXG4gICAgICAgIH0pO1xuICAgICAgICBidWZmZXIgPSBkYWdQYi5lbmNvZGUoe1xuICAgICAgICAgIERhdGE6IHVuaXhmcy5tYXJzaGFsKCksXG4gICAgICAgICAgTGlua3M6IFtdXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY2lkOiBhd2FpdCBwZXJzaXN0KGJ1ZmZlciwgYmxvY2ssIG9wdHMpLFxuICAgICAgICB1bml4ZnMsXG4gICAgICAgIHNpemU6IGJ1ZmZlci5sZW5ndGhcbiAgICAgIH07XG4gICAgfTtcbiAgfVxufVxuZXhwb3J0IGRlZmF1bHQgYnVmZmVySW1wb3J0ZXI7IiwgImltcG9ydCBkaXJCdWlsZGVyIGZyb20gJy4vZGlyLmpzJztcbmltcG9ydCBmaWxlQnVpbGRlciBmcm9tICcuL2ZpbGUvaW5kZXguanMnO1xuaW1wb3J0IGVyckNvZGUgZnJvbSAnZXJyLWNvZGUnO1xuaW1wb3J0IHJhYmluIGZyb20gJy4uL2NodW5rZXIvcmFiaW4uanMnO1xuaW1wb3J0IGZpeGVkU2l6ZSBmcm9tICcuLi9jaHVua2VyL2ZpeGVkLXNpemUuanMnO1xuaW1wb3J0IHZhbGlkYXRlQ2h1bmtzIGZyb20gJy4vdmFsaWRhdGUtY2h1bmtzLmpzJztcbmZ1bmN0aW9uIGlzSXRlcmFibGUodGhpbmcpIHtcbiAgcmV0dXJuIFN5bWJvbC5pdGVyYXRvciBpbiB0aGluZztcbn1cbmZ1bmN0aW9uIGlzQXN5bmNJdGVyYWJsZSh0aGluZykge1xuICByZXR1cm4gU3ltYm9sLmFzeW5jSXRlcmF0b3IgaW4gdGhpbmc7XG59XG5mdW5jdGlvbiBjb250ZW50QXNBc3luY0l0ZXJhYmxlKGNvbnRlbnQpIHtcbiAgdHJ5IHtcbiAgICBpZiAoY29udGVudCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgIHJldHVybiBhc3luYyBmdW5jdGlvbiogKCkge1xuICAgICAgICB5aWVsZCBjb250ZW50O1xuICAgICAgfSgpO1xuICAgIH0gZWxzZSBpZiAoaXNJdGVyYWJsZShjb250ZW50KSkge1xuICAgICAgcmV0dXJuIGFzeW5jIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIHlpZWxkKiBjb250ZW50O1xuICAgICAgfSgpO1xuICAgIH0gZWxzZSBpZiAoaXNBc3luY0l0ZXJhYmxlKGNvbnRlbnQpKSB7XG4gICAgICByZXR1cm4gY29udGVudDtcbiAgICB9XG4gIH0gY2F0Y2gge1xuICAgIHRocm93IGVyckNvZGUobmV3IEVycm9yKCdDb250ZW50IHdhcyBpbnZhbGlkJyksICdFUlJfSU5WQUxJRF9DT05URU5UJyk7XG4gIH1cbiAgdGhyb3cgZXJyQ29kZShuZXcgRXJyb3IoJ0NvbnRlbnQgd2FzIGludmFsaWQnKSwgJ0VSUl9JTlZBTElEX0NPTlRFTlQnKTtcbn1cbmFzeW5jIGZ1bmN0aW9uKiBkYWdCdWlsZGVyKHNvdXJjZSwgYmxvY2tzdG9yZSwgb3B0aW9ucykge1xuICBmb3IgYXdhaXQgKGNvbnN0IGVudHJ5IG9mIHNvdXJjZSkge1xuICAgIGlmIChlbnRyeS5wYXRoKSB7XG4gICAgICBpZiAoZW50cnkucGF0aC5zdWJzdHJpbmcoMCwgMikgPT09ICcuLycpIHtcbiAgICAgICAgb3B0aW9ucy53cmFwV2l0aERpcmVjdG9yeSA9IHRydWU7XG4gICAgICB9XG4gICAgICBlbnRyeS5wYXRoID0gZW50cnkucGF0aC5zcGxpdCgnLycpLmZpbHRlcihwYXRoID0+IHBhdGggJiYgcGF0aCAhPT0gJy4nKS5qb2luKCcvJyk7XG4gICAgfVxuICAgIGlmIChlbnRyeS5jb250ZW50KSB7XG4gICAgICBsZXQgY2h1bmtlcjtcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5jaHVua2VyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNodW5rZXIgPSBvcHRpb25zLmNodW5rZXI7XG4gICAgICB9IGVsc2UgaWYgKG9wdGlvbnMuY2h1bmtlciA9PT0gJ3JhYmluJykge1xuICAgICAgICBjaHVua2VyID0gcmFiaW47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaHVua2VyID0gZml4ZWRTaXplO1xuICAgICAgfVxuICAgICAgbGV0IGNodW5rVmFsaWRhdG9yO1xuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmNodW5rVmFsaWRhdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNodW5rVmFsaWRhdG9yID0gb3B0aW9ucy5jaHVua1ZhbGlkYXRvcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNodW5rVmFsaWRhdG9yID0gdmFsaWRhdGVDaHVua3M7XG4gICAgICB9XG4gICAgICBjb25zdCBmaWxlID0ge1xuICAgICAgICBwYXRoOiBlbnRyeS5wYXRoLFxuICAgICAgICBtdGltZTogZW50cnkubXRpbWUsXG4gICAgICAgIG1vZGU6IGVudHJ5Lm1vZGUsXG4gICAgICAgIGNvbnRlbnQ6IGNodW5rZXIoY2h1bmtWYWxpZGF0b3IoY29udGVudEFzQXN5bmNJdGVyYWJsZShlbnRyeS5jb250ZW50KSwgb3B0aW9ucyksIG9wdGlvbnMpXG4gICAgICB9O1xuICAgICAgeWllbGQgKCkgPT4gZmlsZUJ1aWxkZXIoZmlsZSwgYmxvY2tzdG9yZSwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIGlmIChlbnRyeS5wYXRoKSB7XG4gICAgICBjb25zdCBkaXIgPSB7XG4gICAgICAgIHBhdGg6IGVudHJ5LnBhdGgsXG4gICAgICAgIG10aW1lOiBlbnRyeS5tdGltZSxcbiAgICAgICAgbW9kZTogZW50cnkubW9kZVxuICAgICAgfTtcbiAgICAgIHlpZWxkICgpID0+IGRpckJ1aWxkZXIoZGlyLCBibG9ja3N0b3JlLCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbXBvcnQgY2FuZGlkYXRlIG11c3QgaGF2ZSBjb250ZW50IG9yIHBhdGggb3IgYm90aCcpO1xuICAgIH1cbiAgfVxufVxuZXhwb3J0IGRlZmF1bHQgZGFnQnVpbGRlcjsiLCAiaW1wb3J0IEJ1ZmZlckxpc3QgZnJvbSAnYmwvQnVmZmVyTGlzdC5qcyc7XG5pbXBvcnQgeyBjcmVhdGUgfSBmcm9tICdyYWJpbi13YXNtJztcbmltcG9ydCBlcnJjb2RlIGZyb20gJ2Vyci1jb2RlJztcbmFzeW5jIGZ1bmN0aW9uKiByYWJpbkNodW5rZXIoc291cmNlLCBvcHRpb25zKSB7XG4gIGxldCBtaW4sIG1heCwgYXZnO1xuICBpZiAob3B0aW9ucy5taW5DaHVua1NpemUgJiYgb3B0aW9ucy5tYXhDaHVua1NpemUgJiYgb3B0aW9ucy5hdmdDaHVua1NpemUpIHtcbiAgICBhdmcgPSBvcHRpb25zLmF2Z0NodW5rU2l6ZTtcbiAgICBtaW4gPSBvcHRpb25zLm1pbkNodW5rU2l6ZTtcbiAgICBtYXggPSBvcHRpb25zLm1heENodW5rU2l6ZTtcbiAgfSBlbHNlIGlmICghb3B0aW9ucy5hdmdDaHVua1NpemUpIHtcbiAgICB0aHJvdyBlcnJjb2RlKG5ldyBFcnJvcigncGxlYXNlIHNwZWNpZnkgYW4gYXZlcmFnZSBjaHVuayBzaXplJyksICdFUlJfSU5WQUxJRF9BVkdfQ0hVTktfU0laRScpO1xuICB9IGVsc2Uge1xuICAgIGF2ZyA9IG9wdGlvbnMuYXZnQ2h1bmtTaXplO1xuICAgIG1pbiA9IGF2ZyAvIDM7XG4gICAgbWF4ID0gYXZnICsgYXZnIC8gMjtcbiAgfVxuICBpZiAobWluIDwgMTYpIHtcbiAgICB0aHJvdyBlcnJjb2RlKG5ldyBFcnJvcigncmFiaW4gbWluIG11c3QgYmUgZ3JlYXRlciB0aGFuIDE2JyksICdFUlJfSU5WQUxJRF9NSU5fQ0hVTktfU0laRScpO1xuICB9XG4gIGlmIChtYXggPCBtaW4pIHtcbiAgICBtYXggPSBtaW47XG4gIH1cbiAgaWYgKGF2ZyA8IG1pbikge1xuICAgIGF2ZyA9IG1pbjtcbiAgfVxuICBjb25zdCBzaXplcG93ID0gTWF0aC5mbG9vcihNYXRoLmxvZzIoYXZnKSk7XG4gIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgcmFiaW4oc291cmNlLCB7XG4gICAgICBtaW46IG1pbixcbiAgICAgIG1heDogbWF4LFxuICAgICAgYml0czogc2l6ZXBvdyxcbiAgICAgIHdpbmRvdzogb3B0aW9ucy53aW5kb3csXG4gICAgICBwb2x5bm9taWFsOiBvcHRpb25zLnBvbHlub21pYWxcbiAgICB9KSkge1xuICAgIHlpZWxkIGNodW5rO1xuICB9XG59XG5leHBvcnQgZGVmYXVsdCByYWJpbkNodW5rZXI7XG5hc3luYyBmdW5jdGlvbiogcmFiaW4oc291cmNlLCBvcHRpb25zKSB7XG4gIGNvbnN0IHIgPSBhd2FpdCBjcmVhdGUob3B0aW9ucy5iaXRzLCBvcHRpb25zLm1pbiwgb3B0aW9ucy5tYXgsIG9wdGlvbnMud2luZG93KTtcbiAgY29uc3QgYnVmZmVycyA9IG5ldyBCdWZmZXJMaXN0KCk7XG4gIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2Ygc291cmNlKSB7XG4gICAgYnVmZmVycy5hcHBlbmQoY2h1bmspO1xuICAgIGNvbnN0IHNpemVzID0gci5maW5nZXJwcmludChjaHVuayk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaXplcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgc2l6ZSA9IHNpemVzW2ldO1xuICAgICAgY29uc3QgYnVmID0gYnVmZmVycy5zbGljZSgwLCBzaXplKTtcbiAgICAgIGJ1ZmZlcnMuY29uc3VtZShzaXplKTtcbiAgICAgIHlpZWxkIGJ1ZjtcbiAgICB9XG4gIH1cbiAgaWYgKGJ1ZmZlcnMubGVuZ3RoKSB7XG4gICAgeWllbGQgYnVmZmVycy5zbGljZSgwKTtcbiAgfVxufSIsICJpbXBvcnQgQnVmZmVyTGlzdCBmcm9tICdibC9CdWZmZXJMaXN0LmpzJztcbmFzeW5jIGZ1bmN0aW9uKiBmaXhlZFNpemVDaHVua2VyKHNvdXJjZSwgb3B0aW9ucykge1xuICBsZXQgYmwgPSBuZXcgQnVmZmVyTGlzdCgpO1xuICBsZXQgY3VycmVudExlbmd0aCA9IDA7XG4gIGxldCBlbWl0dGVkID0gZmFsc2U7XG4gIGNvbnN0IG1heENodW5rU2l6ZSA9IG9wdGlvbnMubWF4Q2h1bmtTaXplO1xuICBmb3IgYXdhaXQgKGNvbnN0IGJ1ZmZlciBvZiBzb3VyY2UpIHtcbiAgICBibC5hcHBlbmQoYnVmZmVyKTtcbiAgICBjdXJyZW50TGVuZ3RoICs9IGJ1ZmZlci5sZW5ndGg7XG4gICAgd2hpbGUgKGN1cnJlbnRMZW5ndGggPj0gbWF4Q2h1bmtTaXplKSB7XG4gICAgICB5aWVsZCBibC5zbGljZSgwLCBtYXhDaHVua1NpemUpO1xuICAgICAgZW1pdHRlZCA9IHRydWU7XG4gICAgICBpZiAobWF4Q2h1bmtTaXplID09PSBibC5sZW5ndGgpIHtcbiAgICAgICAgYmwgPSBuZXcgQnVmZmVyTGlzdCgpO1xuICAgICAgICBjdXJyZW50TGVuZ3RoID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IG5ld0JsID0gbmV3IEJ1ZmZlckxpc3QoKTtcbiAgICAgICAgbmV3QmwuYXBwZW5kKGJsLnNoYWxsb3dTbGljZShtYXhDaHVua1NpemUpKTtcbiAgICAgICAgYmwgPSBuZXdCbDtcbiAgICAgICAgY3VycmVudExlbmd0aCAtPSBtYXhDaHVua1NpemU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICghZW1pdHRlZCB8fCBjdXJyZW50TGVuZ3RoKSB7XG4gICAgeWllbGQgYmwuc2xpY2UoMCwgY3VycmVudExlbmd0aCk7XG4gIH1cbn1cbmV4cG9ydCBkZWZhdWx0IGZpeGVkU2l6ZUNodW5rZXI7IiwgImltcG9ydCBlcnJDb2RlIGZyb20gJ2Vyci1jb2RlJztcbmltcG9ydCB7IGZyb21TdHJpbmcgYXMgdWludDhBcnJheUZyb21TdHJpbmcgfSBmcm9tICd1aW50OGFycmF5cy9mcm9tLXN0cmluZyc7XG5hc3luYyBmdW5jdGlvbiogdmFsaWRhdGVDaHVua3Moc291cmNlKSB7XG4gIGZvciBhd2FpdCAoY29uc3QgY29udGVudCBvZiBzb3VyY2UpIHtcbiAgICBpZiAoY29udGVudC5sZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgZXJyQ29kZShuZXcgRXJyb3IoJ0NvbnRlbnQgd2FzIGludmFsaWQnKSwgJ0VSUl9JTlZBTElEX0NPTlRFTlQnKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJyB8fCBjb250ZW50IGluc3RhbmNlb2YgU3RyaW5nKSB7XG4gICAgICB5aWVsZCB1aW50OEFycmF5RnJvbVN0cmluZyhjb250ZW50LnRvU3RyaW5nKCkpO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShjb250ZW50KSkge1xuICAgICAgeWllbGQgVWludDhBcnJheS5mcm9tKGNvbnRlbnQpO1xuICAgIH0gZWxzZSBpZiAoY29udGVudCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgIHlpZWxkIGNvbnRlbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGVyckNvZGUobmV3IEVycm9yKCdDb250ZW50IHdhcyBpbnZhbGlkJyksICdFUlJfSU5WQUxJRF9DT05URU5UJyk7XG4gICAgfVxuICB9XG59XG5leHBvcnQgZGVmYXVsdCB2YWxpZGF0ZUNodW5rczsiLCAiaW1wb3J0IHsgZnJvbSB9IGZyb20gJy4vYmFzZS5qcyc7XG5pbXBvcnQge1xuICBmcm9tU3RyaW5nLFxuICB0b1N0cmluZ1xufSBmcm9tICcuLi9ieXRlcy5qcyc7XG5leHBvcnQgY29uc3QgaWRlbnRpdHkgPSBmcm9tKHtcbiAgcHJlZml4OiAnXFwwJyxcbiAgbmFtZTogJ2lkZW50aXR5JyxcbiAgZW5jb2RlOiBidWYgPT4gdG9TdHJpbmcoYnVmKSxcbiAgZGVjb2RlOiBzdHIgPT4gZnJvbVN0cmluZyhzdHIpXG59KTsiLCAiaW1wb3J0IHsgcmZjNDY0OCB9IGZyb20gJy4vYmFzZS5qcyc7XG5leHBvcnQgY29uc3QgYmFzZTIgPSByZmM0NjQ4KHtcbiAgcHJlZml4OiAnMCcsXG4gIG5hbWU6ICdiYXNlMicsXG4gIGFscGhhYmV0OiAnMDEnLFxuICBiaXRzUGVyQ2hhcjogMVxufSk7IiwgImltcG9ydCB7IHJmYzQ2NDggfSBmcm9tICcuL2Jhc2UuanMnO1xuZXhwb3J0IGNvbnN0IGJhc2U4ID0gcmZjNDY0OCh7XG4gIHByZWZpeDogJzcnLFxuICBuYW1lOiAnYmFzZTgnLFxuICBhbHBoYWJldDogJzAxMjM0NTY3JyxcbiAgYml0c1BlckNoYXI6IDNcbn0pOyIsICJpbXBvcnQgeyBiYXNlWCB9IGZyb20gJy4vYmFzZS5qcyc7XG5leHBvcnQgY29uc3QgYmFzZTEwID0gYmFzZVgoe1xuICBwcmVmaXg6ICc5JyxcbiAgbmFtZTogJ2Jhc2UxMCcsXG4gIGFscGhhYmV0OiAnMDEyMzQ1Njc4OSdcbn0pOyIsICJpbXBvcnQgeyByZmM0NjQ4IH0gZnJvbSAnLi9iYXNlLmpzJztcbmV4cG9ydCBjb25zdCBiYXNlMTYgPSByZmM0NjQ4KHtcbiAgcHJlZml4OiAnZicsXG4gIG5hbWU6ICdiYXNlMTYnLFxuICBhbHBoYWJldDogJzAxMjM0NTY3ODlhYmNkZWYnLFxuICBiaXRzUGVyQ2hhcjogNFxufSk7XG5leHBvcnQgY29uc3QgYmFzZTE2dXBwZXIgPSByZmM0NjQ4KHtcbiAgcHJlZml4OiAnRicsXG4gIG5hbWU6ICdiYXNlMTZ1cHBlcicsXG4gIGFscGhhYmV0OiAnMDEyMzQ1Njc4OUFCQ0RFRicsXG4gIGJpdHNQZXJDaGFyOiA0XG59KTsiLCAiaW1wb3J0IHsgYmFzZVggfSBmcm9tICcuL2Jhc2UuanMnO1xuZXhwb3J0IGNvbnN0IGJhc2UzNiA9IGJhc2VYKHtcbiAgcHJlZml4OiAnaycsXG4gIG5hbWU6ICdiYXNlMzYnLFxuICBhbHBoYWJldDogJzAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5eidcbn0pO1xuZXhwb3J0IGNvbnN0IGJhc2UzNnVwcGVyID0gYmFzZVgoe1xuICBwcmVmaXg6ICdLJyxcbiAgbmFtZTogJ2Jhc2UzNnVwcGVyJyxcbiAgYWxwaGFiZXQ6ICcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVonXG59KTsiLCAiaW1wb3J0IHsgcmZjNDY0OCB9IGZyb20gJy4vYmFzZS5qcyc7XG5leHBvcnQgY29uc3QgYmFzZTY0ID0gcmZjNDY0OCh7XG4gIHByZWZpeDogJ20nLFxuICBuYW1lOiAnYmFzZTY0JyxcbiAgYWxwaGFiZXQ6ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJyxcbiAgYml0c1BlckNoYXI6IDZcbn0pO1xuZXhwb3J0IGNvbnN0IGJhc2U2NHBhZCA9IHJmYzQ2NDgoe1xuICBwcmVmaXg6ICdNJyxcbiAgbmFtZTogJ2Jhc2U2NHBhZCcsXG4gIGFscGhhYmV0OiAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz0nLFxuICBiaXRzUGVyQ2hhcjogNlxufSk7XG5leHBvcnQgY29uc3QgYmFzZTY0dXJsID0gcmZjNDY0OCh7XG4gIHByZWZpeDogJ3UnLFxuICBuYW1lOiAnYmFzZTY0dXJsJyxcbiAgYWxwaGFiZXQ6ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OS1fJyxcbiAgYml0c1BlckNoYXI6IDZcbn0pO1xuZXhwb3J0IGNvbnN0IGJhc2U2NHVybHBhZCA9IHJmYzQ2NDgoe1xuICBwcmVmaXg6ICdVJyxcbiAgbmFtZTogJ2Jhc2U2NHVybHBhZCcsXG4gIGFscGhhYmV0OiAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODktXz0nLFxuICBiaXRzUGVyQ2hhcjogNlxufSk7IiwgImltcG9ydCB7IGZyb20gfSBmcm9tICcuL2Jhc2UuanMnO1xuY29uc3QgYWxwaGFiZXQgPSBBcnJheS5mcm9tKCdcXHVEODNEXFx1REU4MFxcdUQ4M0VcXHVERTkwXFx1MjYwNFxcdUQ4M0RcXHVERUYwXFx1RDgzQ1xcdURGMENcXHVEODNDXFx1REYxMVxcdUQ4M0NcXHVERjEyXFx1RDgzQ1xcdURGMTNcXHVEODNDXFx1REYxNFxcdUQ4M0NcXHVERjE1XFx1RDgzQ1xcdURGMTZcXHVEODNDXFx1REYxN1xcdUQ4M0NcXHVERjE4XFx1RDgzQ1xcdURGMERcXHVEODNDXFx1REYwRlxcdUQ4M0NcXHVERjBFXFx1RDgzRFxcdURDMDlcXHUyNjAwXFx1RDgzRFxcdURDQkJcXHVEODNEXFx1RERBNVxcdUQ4M0RcXHVEQ0JFXFx1RDgzRFxcdURDQkZcXHVEODNEXFx1REUwMlxcdTI3NjRcXHVEODNEXFx1REUwRFxcdUQ4M0VcXHVERDIzXFx1RDgzRFxcdURFMEFcXHVEODNEXFx1REU0RlxcdUQ4M0RcXHVEQzk1XFx1RDgzRFxcdURFMkRcXHVEODNEXFx1REUxOFxcdUQ4M0RcXHVEQzREXFx1RDgzRFxcdURFMDVcXHVEODNEXFx1REM0RlxcdUQ4M0RcXHVERTAxXFx1RDgzRFxcdUREMjVcXHVEODNFXFx1REQ3MFxcdUQ4M0RcXHVEQzk0XFx1RDgzRFxcdURDOTZcXHVEODNEXFx1REM5OVxcdUQ4M0RcXHVERTIyXFx1RDgzRVxcdUREMTRcXHVEODNEXFx1REUwNlxcdUQ4M0RcXHVERTQ0XFx1RDgzRFxcdURDQUFcXHVEODNEXFx1REUwOVxcdTI2M0FcXHVEODNEXFx1REM0Q1xcdUQ4M0VcXHVERDE3XFx1RDgzRFxcdURDOUNcXHVEODNEXFx1REUxNFxcdUQ4M0RcXHVERTBFXFx1RDgzRFxcdURFMDdcXHVEODNDXFx1REYzOVxcdUQ4M0VcXHVERDI2XFx1RDgzQ1xcdURGODlcXHVEODNEXFx1REM5RVxcdTI3MENcXHUyNzI4XFx1RDgzRVxcdUREMzdcXHVEODNEXFx1REUzMVxcdUQ4M0RcXHVERTBDXFx1RDgzQ1xcdURGMzhcXHVEODNEXFx1REU0Q1xcdUQ4M0RcXHVERTBCXFx1RDgzRFxcdURDOTdcXHVEODNEXFx1REM5QVxcdUQ4M0RcXHVERTBGXFx1RDgzRFxcdURDOUJcXHVEODNEXFx1REU0MlxcdUQ4M0RcXHVEQzkzXFx1RDgzRVxcdUREMjlcXHVEODNEXFx1REUwNFxcdUQ4M0RcXHVERTAwXFx1RDgzRFxcdUREQTRcXHVEODNEXFx1REUwM1xcdUQ4M0RcXHVEQ0FGXFx1RDgzRFxcdURFNDhcXHVEODNEXFx1REM0N1xcdUQ4M0NcXHVERkI2XFx1RDgzRFxcdURFMTJcXHVEODNFXFx1REQyRFxcdTI3NjNcXHVEODNEXFx1REUxQ1xcdUQ4M0RcXHVEQzhCXFx1RDgzRFxcdURDNDBcXHVEODNEXFx1REUyQVxcdUQ4M0RcXHVERTExXFx1RDgzRFxcdURDQTVcXHVEODNEXFx1REU0QlxcdUQ4M0RcXHVERTFFXFx1RDgzRFxcdURFMjlcXHVEODNEXFx1REUyMVxcdUQ4M0VcXHVERDJBXFx1RDgzRFxcdURDNEFcXHVEODNFXFx1REQ3M1xcdUQ4M0RcXHVERTI1XFx1RDgzRVxcdUREMjRcXHVEODNEXFx1REM0OVxcdUQ4M0RcXHVEQzgzXFx1RDgzRFxcdURFMzNcXHUyNzBCXFx1RDgzRFxcdURFMUFcXHVEODNEXFx1REUxRFxcdUQ4M0RcXHVERTM0XFx1RDgzQ1xcdURGMUZcXHVEODNEXFx1REUyQ1xcdUQ4M0RcXHVERTQzXFx1RDgzQ1xcdURGNDBcXHVEODNDXFx1REYzN1xcdUQ4M0RcXHVERTNCXFx1RDgzRFxcdURFMTNcXHUyQjUwXFx1MjcwNVxcdUQ4M0VcXHVERDdBXFx1RDgzQ1xcdURGMDhcXHVEODNEXFx1REUwOFxcdUQ4M0VcXHVERDE4XFx1RDgzRFxcdURDQTZcXHUyNzE0XFx1RDgzRFxcdURFMjNcXHVEODNDXFx1REZDM1xcdUQ4M0RcXHVEQzkwXFx1MjYzOVxcdUQ4M0NcXHVERjhBXFx1RDgzRFxcdURDOThcXHVEODNEXFx1REUyMFxcdTI2MURcXHVEODNEXFx1REUxNVxcdUQ4M0NcXHVERjNBXFx1RDgzQ1xcdURGODJcXHVEODNDXFx1REYzQlxcdUQ4M0RcXHVERTEwXFx1RDgzRFxcdUREOTVcXHVEODNEXFx1REM5RFxcdUQ4M0RcXHVERTRBXFx1RDgzRFxcdURFMzlcXHVEODNEXFx1RERFM1xcdUQ4M0RcXHVEQ0FCXFx1RDgzRFxcdURDODBcXHVEODNEXFx1REM1MVxcdUQ4M0NcXHVERkI1XFx1RDgzRVxcdUREMUVcXHVEODNEXFx1REUxQlxcdUQ4M0RcXHVERDM0XFx1RDgzRFxcdURFMjRcXHVEODNDXFx1REYzQ1xcdUQ4M0RcXHVERTJCXFx1MjZCRFxcdUQ4M0VcXHVERDE5XFx1MjYxNVxcdUQ4M0NcXHVERkM2XFx1RDgzRVxcdUREMkJcXHVEODNEXFx1REM0OFxcdUQ4M0RcXHVERTJFXFx1RDgzRFxcdURFNDZcXHVEODNDXFx1REY3QlxcdUQ4M0NcXHVERjQzXFx1RDgzRFxcdURDMzZcXHVEODNEXFx1REM4MVxcdUQ4M0RcXHVERTMyXFx1RDgzQ1xcdURGM0ZcXHVEODNFXFx1RERFMVxcdUQ4M0NcXHVERjgxXFx1MjZBMVxcdUQ4M0NcXHVERjFFXFx1RDgzQ1xcdURGODhcXHUyNzRDXFx1MjcwQVxcdUQ4M0RcXHVEQzRCXFx1RDgzRFxcdURFMzBcXHVEODNFXFx1REQyOFxcdUQ4M0RcXHVERTM2XFx1RDgzRVxcdUREMURcXHVEODNEXFx1REVCNlxcdUQ4M0RcXHVEQ0IwXFx1RDgzQ1xcdURGNTNcXHVEODNEXFx1RENBMlxcdUQ4M0VcXHVERDFGXFx1RDgzRFxcdURFNDFcXHVEODNEXFx1REVBOFxcdUQ4M0RcXHVEQ0E4XFx1RDgzRVxcdUREMkNcXHUyNzA4XFx1RDgzQ1xcdURGODBcXHVEODNDXFx1REY3QVxcdUQ4M0VcXHVERDEzXFx1RDgzRFxcdURFMTlcXHVEODNEXFx1REM5RlxcdUQ4M0NcXHVERjMxXFx1RDgzRFxcdURFMTZcXHVEODNEXFx1REM3NlxcdUQ4M0VcXHVERDc0XFx1MjVCNlxcdTI3QTFcXHUyNzUzXFx1RDgzRFxcdURDOEVcXHVEODNEXFx1RENCOFxcdTJCMDdcXHVEODNEXFx1REUyOFxcdUQ4M0NcXHVERjFBXFx1RDgzRVxcdUREOEJcXHVEODNEXFx1REUzN1xcdUQ4M0RcXHVERDdBXFx1MjZBMFxcdUQ4M0RcXHVERTQ1XFx1RDgzRFxcdURFMUZcXHVEODNEXFx1REUzNVxcdUQ4M0RcXHVEQzRFXFx1RDgzRVxcdUREMzJcXHVEODNFXFx1REQyMFxcdUQ4M0VcXHVERDI3XFx1RDgzRFxcdURDQ0NcXHVEODNEXFx1REQzNVxcdUQ4M0RcXHVEQzg1XFx1RDgzRVxcdURERDBcXHVEODNEXFx1REMzRVxcdUQ4M0NcXHVERjUyXFx1RDgzRFxcdURFMTdcXHVEODNFXFx1REQxMVxcdUQ4M0NcXHVERjBBXFx1RDgzRVxcdUREMkZcXHVEODNEXFx1REMzN1xcdTI2MEVcXHVEODNEXFx1RENBN1xcdUQ4M0RcXHVERTJGXFx1RDgzRFxcdURDODZcXHVEODNEXFx1REM0NlxcdUQ4M0NcXHVERkE0XFx1RDgzRFxcdURFNDdcXHVEODNDXFx1REY1MVxcdTI3NDRcXHVEODNDXFx1REYzNFxcdUQ4M0RcXHVEQ0EzXFx1RDgzRFxcdURDMzhcXHVEODNEXFx1REM4Q1xcdUQ4M0RcXHVEQ0NEXFx1RDgzRVxcdURENDBcXHVEODNFXFx1REQyMlxcdUQ4M0RcXHVEQzQ1XFx1RDgzRFxcdURDQTFcXHVEODNEXFx1RENBOVxcdUQ4M0RcXHVEQzUwXFx1RDgzRFxcdURDRjhcXHVEODNEXFx1REM3QlxcdUQ4M0VcXHVERDEwXFx1RDgzRVxcdUREMkVcXHVEODNDXFx1REZCQ1xcdUQ4M0VcXHVERDc1XFx1RDgzRFxcdURFQTlcXHVEODNDXFx1REY0RVxcdUQ4M0NcXHVERjRBXFx1RDgzRFxcdURDN0NcXHVEODNEXFx1REM4RFxcdUQ4M0RcXHVEQ0UzXFx1RDgzRVxcdURENDInKTtcbmNvbnN0IGFscGhhYmV0Qnl0ZXNUb0NoYXJzID0gYWxwaGFiZXQucmVkdWNlKChwLCBjLCBpKSA9PiB7XG4gIHBbaV0gPSBjO1xuICByZXR1cm4gcDtcbn0sIFtdKTtcbmNvbnN0IGFscGhhYmV0Q2hhcnNUb0J5dGVzID0gYWxwaGFiZXQucmVkdWNlKChwLCBjLCBpKSA9PiB7XG4gIHBbYy5jb2RlUG9pbnRBdCgwKV0gPSBpO1xuICByZXR1cm4gcDtcbn0sIFtdKTtcbmZ1bmN0aW9uIGVuY29kZShkYXRhKSB7XG4gIHJldHVybiBkYXRhLnJlZHVjZSgocCwgYykgPT4ge1xuICAgIHAgKz0gYWxwaGFiZXRCeXRlc1RvQ2hhcnNbY107XG4gICAgcmV0dXJuIHA7XG4gIH0sICcnKTtcbn1cbmZ1bmN0aW9uIGRlY29kZShzdHIpIHtcbiAgY29uc3QgYnl0cyA9IFtdO1xuICBmb3IgKGNvbnN0IGNoYXIgb2Ygc3RyKSB7XG4gICAgY29uc3QgYnl0ID0gYWxwaGFiZXRDaGFyc1RvQnl0ZXNbY2hhci5jb2RlUG9pbnRBdCgwKV07XG4gICAgaWYgKGJ5dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vbi1iYXNlMjU2ZW1vamkgY2hhcmFjdGVyOiAkeyBjaGFyIH1gKTtcbiAgICB9XG4gICAgYnl0cy5wdXNoKGJ5dCk7XG4gIH1cbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ5dHMpO1xufVxuZXhwb3J0IGNvbnN0IGJhc2UyNTZlbW9qaSA9IGZyb20oe1xuICBwcmVmaXg6ICdcXHVEODNEXFx1REU4MCcsXG4gIG5hbWU6ICdiYXNlMjU2ZW1vamknLFxuICBlbmNvZGUsXG4gIGRlY29kZVxufSk7IiwgImltcG9ydCB7IGNvZXJjZSB9IGZyb20gJy4uL2J5dGVzLmpzJztcbmltcG9ydCAqIGFzIERpZ2VzdCBmcm9tICcuL2RpZ2VzdC5qcyc7XG5jb25zdCBjb2RlID0gMDtcbmNvbnN0IG5hbWUgPSAnaWRlbnRpdHknO1xuY29uc3QgZW5jb2RlID0gY29lcmNlO1xuY29uc3QgZGlnZXN0ID0gaW5wdXQgPT4gRGlnZXN0LmNyZWF0ZShjb2RlLCBlbmNvZGUoaW5wdXQpKTtcbmV4cG9ydCBjb25zdCBpZGVudGl0eSA9IHtcbiAgY29kZSxcbiAgbmFtZSxcbiAgZW5jb2RlLFxuICBkaWdlc3Rcbn07IiwgImNvbnN0IHRleHRFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG5jb25zdCB0ZXh0RGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xuZXhwb3J0IGNvbnN0IG5hbWUgPSAnanNvbic7XG5leHBvcnQgY29uc3QgY29kZSA9IDUxMjtcbmV4cG9ydCBjb25zdCBlbmNvZGUgPSBub2RlID0+IHRleHRFbmNvZGVyLmVuY29kZShKU09OLnN0cmluZ2lmeShub2RlKSk7XG5leHBvcnQgY29uc3QgZGVjb2RlID0gZGF0YSA9PiBKU09OLnBhcnNlKHRleHREZWNvZGVyLmRlY29kZShkYXRhKSk7IiwgImltcG9ydCAqIGFzIGlkZW50aXR5QmFzZSBmcm9tICcuL2Jhc2VzL2lkZW50aXR5LmpzJztcbmltcG9ydCAqIGFzIGJhc2UyIGZyb20gJy4vYmFzZXMvYmFzZTIuanMnO1xuaW1wb3J0ICogYXMgYmFzZTggZnJvbSAnLi9iYXNlcy9iYXNlOC5qcyc7XG5pbXBvcnQgKiBhcyBiYXNlMTAgZnJvbSAnLi9iYXNlcy9iYXNlMTAuanMnO1xuaW1wb3J0ICogYXMgYmFzZTE2IGZyb20gJy4vYmFzZXMvYmFzZTE2LmpzJztcbmltcG9ydCAqIGFzIGJhc2UzMiBmcm9tICcuL2Jhc2VzL2Jhc2UzMi5qcyc7XG5pbXBvcnQgKiBhcyBiYXNlMzYgZnJvbSAnLi9iYXNlcy9iYXNlMzYuanMnO1xuaW1wb3J0ICogYXMgYmFzZTU4IGZyb20gJy4vYmFzZXMvYmFzZTU4LmpzJztcbmltcG9ydCAqIGFzIGJhc2U2NCBmcm9tICcuL2Jhc2VzL2Jhc2U2NC5qcyc7XG5pbXBvcnQgKiBhcyBiYXNlMjU2ZW1vamkgZnJvbSAnLi9iYXNlcy9iYXNlMjU2ZW1vamkuanMnO1xuaW1wb3J0ICogYXMgc2hhMiBmcm9tICcuL2hhc2hlcy9zaGEyLmpzJztcbmltcG9ydCAqIGFzIGlkZW50aXR5IGZyb20gJy4vaGFzaGVzL2lkZW50aXR5LmpzJztcbmltcG9ydCAqIGFzIHJhdyBmcm9tICcuL2NvZGVjcy9yYXcuanMnO1xuaW1wb3J0ICogYXMganNvbiBmcm9tICcuL2NvZGVjcy9qc29uLmpzJztcbmltcG9ydCB7XG4gIENJRCxcbiAgaGFzaGVyLFxuICBkaWdlc3QsXG4gIHZhcmludCxcbiAgYnl0ZXNcbn0gZnJvbSAnLi9pbmRleC5qcyc7XG5jb25zdCBiYXNlcyA9IHtcbiAgLi4uaWRlbnRpdHlCYXNlLFxuICAuLi5iYXNlMixcbiAgLi4uYmFzZTgsXG4gIC4uLmJhc2UxMCxcbiAgLi4uYmFzZTE2LFxuICAuLi5iYXNlMzIsXG4gIC4uLmJhc2UzNixcbiAgLi4uYmFzZTU4LFxuICAuLi5iYXNlNjQsXG4gIC4uLmJhc2UyNTZlbW9qaVxufTtcbmNvbnN0IGhhc2hlcyA9IHtcbiAgLi4uc2hhMixcbiAgLi4uaWRlbnRpdHlcbn07XG5jb25zdCBjb2RlY3MgPSB7XG4gIHJhdyxcbiAganNvblxufTtcbmV4cG9ydCB7XG4gIENJRCxcbiAgaGFzaGVyLFxuICBkaWdlc3QsXG4gIHZhcmludCxcbiAgYnl0ZXMsXG4gIGhhc2hlcyxcbiAgYmFzZXMsXG4gIGNvZGVjc1xufTsiLCAiZXhwb3J0IGZ1bmN0aW9uIGFzVWludDhBcnJheShidWYpIHtcbiAgaWYgKGdsb2JhbFRoaXMuQnVmZmVyICE9IG51bGwpIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnVmLmJ1ZmZlciwgYnVmLmJ5dGVPZmZzZXQsIGJ1Zi5ieXRlTGVuZ3RoKTtcbiAgfVxuICByZXR1cm4gYnVmO1xufSIsICJpbXBvcnQgeyBhc1VpbnQ4QXJyYXkgfSBmcm9tICcuL3V0aWwvYXMtdWludDhhcnJheS5qcyc7XG5leHBvcnQgZnVuY3Rpb24gYWxsb2Moc2l6ZSA9IDApIHtcbiAgaWYgKGdsb2JhbFRoaXMuQnVmZmVyICE9IG51bGwgJiYgZ2xvYmFsVGhpcy5CdWZmZXIuYWxsb2MgIT0gbnVsbCkge1xuICAgIHJldHVybiBhc1VpbnQ4QXJyYXkoZ2xvYmFsVGhpcy5CdWZmZXIuYWxsb2Moc2l6ZSkpO1xuICB9XG4gIHJldHVybiBuZXcgVWludDhBcnJheShzaXplKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBhbGxvY1Vuc2FmZShzaXplID0gMCkge1xuICBpZiAoZ2xvYmFsVGhpcy5CdWZmZXIgIT0gbnVsbCAmJiBnbG9iYWxUaGlzLkJ1ZmZlci5hbGxvY1Vuc2FmZSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIGFzVWludDhBcnJheShnbG9iYWxUaGlzLkJ1ZmZlci5hbGxvY1Vuc2FmZShzaXplKSk7XG4gIH1cbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHNpemUpO1xufSIsICJpbXBvcnQgeyBiYXNlcyB9IGZyb20gJ211bHRpZm9ybWF0cy9iYXNpY3MnO1xuaW1wb3J0IHsgYWxsb2NVbnNhZmUgfSBmcm9tICcuLi9hbGxvYy5qcyc7XG5mdW5jdGlvbiBjcmVhdGVDb2RlYyhuYW1lLCBwcmVmaXgsIGVuY29kZSwgZGVjb2RlKSB7XG4gIHJldHVybiB7XG4gICAgbmFtZSxcbiAgICBwcmVmaXgsXG4gICAgZW5jb2Rlcjoge1xuICAgICAgbmFtZSxcbiAgICAgIHByZWZpeCxcbiAgICAgIGVuY29kZVxuICAgIH0sXG4gICAgZGVjb2RlcjogeyBkZWNvZGUgfVxuICB9O1xufVxuY29uc3Qgc3RyaW5nID0gY3JlYXRlQ29kZWMoJ3V0ZjgnLCAndScsIGJ1ZiA9PiB7XG4gIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoJ3V0ZjgnKTtcbiAgcmV0dXJuICd1JyArIGRlY29kZXIuZGVjb2RlKGJ1Zik7XG59LCBzdHIgPT4ge1xuICBjb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gIHJldHVybiBlbmNvZGVyLmVuY29kZShzdHIuc3Vic3RyaW5nKDEpKTtcbn0pO1xuY29uc3QgYXNjaWkgPSBjcmVhdGVDb2RlYygnYXNjaWknLCAnYScsIGJ1ZiA9PiB7XG4gIGxldCBzdHJpbmcgPSAnYSc7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmLmxlbmd0aDsgaSsrKSB7XG4gICAgc3RyaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKTtcbiAgfVxuICByZXR1cm4gc3RyaW5nO1xufSwgc3RyID0+IHtcbiAgc3RyID0gc3RyLnN1YnN0cmluZygxKTtcbiAgY29uc3QgYnVmID0gYWxsb2NVbnNhZmUoc3RyLmxlbmd0aCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgYnVmW2ldID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gIH1cbiAgcmV0dXJuIGJ1Zjtcbn0pO1xuY29uc3QgQkFTRVMgPSB7XG4gIHV0Zjg6IHN0cmluZyxcbiAgJ3V0Zi04Jzogc3RyaW5nLFxuICBoZXg6IGJhc2VzLmJhc2UxNixcbiAgbGF0aW4xOiBhc2NpaSxcbiAgYXNjaWk6IGFzY2lpLFxuICBiaW5hcnk6IGFzY2lpLFxuICAuLi5iYXNlc1xufTtcbmV4cG9ydCBkZWZhdWx0IEJBU0VTOyIsICJpbXBvcnQgYmFzZXMgZnJvbSAnLi91dGlsL2Jhc2VzLmpzJztcbmltcG9ydCB7IGFzVWludDhBcnJheSB9IGZyb20gJy4vdXRpbC9hcy11aW50OGFycmF5LmpzJztcbmV4cG9ydCBmdW5jdGlvbiBmcm9tU3RyaW5nKHN0cmluZywgZW5jb2RpbmcgPSAndXRmOCcpIHtcbiAgY29uc3QgYmFzZSA9IGJhc2VzW2VuY29kaW5nXTtcbiAgaWYgKCFiYXNlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBlbmNvZGluZyBcIiR7IGVuY29kaW5nIH1cImApO1xuICB9XG4gIGlmICgoZW5jb2RpbmcgPT09ICd1dGY4JyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi04JykgJiYgZ2xvYmFsVGhpcy5CdWZmZXIgIT0gbnVsbCAmJiBnbG9iYWxUaGlzLkJ1ZmZlci5mcm9tICE9IG51bGwpIHtcbiAgICByZXR1cm4gYXNVaW50OEFycmF5KGdsb2JhbFRoaXMuQnVmZmVyLmZyb20oc3RyaW5nLCAndXRmLTgnKSk7XG4gIH1cbiAgcmV0dXJuIGJhc2UuZGVjb2Rlci5kZWNvZGUoYCR7IGJhc2UucHJlZml4IH0keyBzdHJpbmcgfWApO1xufSIsICJjbGFzcyBEaXIge1xuICBjb25zdHJ1Y3Rvcihwcm9wcywgb3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdGhpcy5yb290ID0gcHJvcHMucm9vdDtcbiAgICB0aGlzLmRpciA9IHByb3BzLmRpcjtcbiAgICB0aGlzLnBhdGggPSBwcm9wcy5wYXRoO1xuICAgIHRoaXMuZGlydHkgPSBwcm9wcy5kaXJ0eTtcbiAgICB0aGlzLmZsYXQgPSBwcm9wcy5mbGF0O1xuICAgIHRoaXMucGFyZW50ID0gcHJvcHMucGFyZW50O1xuICAgIHRoaXMucGFyZW50S2V5ID0gcHJvcHMucGFyZW50S2V5O1xuICAgIHRoaXMudW5peGZzID0gcHJvcHMudW5peGZzO1xuICAgIHRoaXMubW9kZSA9IHByb3BzLm1vZGU7XG4gICAgdGhpcy5tdGltZSA9IHByb3BzLm10aW1lO1xuICAgIHRoaXMuY2lkID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuc2l6ZSA9IHVuZGVmaW5lZDtcbiAgfVxuICBhc3luYyBwdXQobmFtZSwgdmFsdWUpIHtcbiAgfVxuICBnZXQobmFtZSkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcyk7XG4gIH1cbiAgYXN5bmMgKmVhY2hDaGlsZFNlcmllcygpIHtcbiAgfVxuICBhc3luYyAqZmx1c2goYmxvY2tzdG9yZSkge1xuICB9XG59XG5leHBvcnQgZGVmYXVsdCBEaXI7IiwgImltcG9ydCB7XG4gIGVuY29kZSxcbiAgcHJlcGFyZVxufSBmcm9tICdAaXBsZC9kYWctcGInO1xuaW1wb3J0IHsgVW5peEZTIH0gZnJvbSAnaXBmcy11bml4ZnMnO1xuaW1wb3J0IERpciBmcm9tICcuL2Rpci5qcyc7XG5pbXBvcnQgcGVyc2lzdCBmcm9tICcuL3V0aWxzL3BlcnNpc3QuanMnO1xuY2xhc3MgRGlyRmxhdCBleHRlbmRzIERpciB7XG4gIGNvbnN0cnVjdG9yKHByb3BzLCBvcHRpb25zKSB7XG4gICAgc3VwZXIocHJvcHMsIG9wdGlvbnMpO1xuICAgIHRoaXMuX2NoaWxkcmVuID0ge307XG4gIH1cbiAgYXN5bmMgcHV0KG5hbWUsIHZhbHVlKSB7XG4gICAgdGhpcy5jaWQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5zaXplID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2NoaWxkcmVuW25hbWVdID0gdmFsdWU7XG4gIH1cbiAgZ2V0KG5hbWUpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2NoaWxkcmVuW25hbWVdKTtcbiAgfVxuICBjaGlsZENvdW50KCkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLl9jaGlsZHJlbikubGVuZ3RoO1xuICB9XG4gIGRpcmVjdENoaWxkcmVuQ291bnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hpbGRDb3VudCgpO1xuICB9XG4gIG9ubHlDaGlsZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2hpbGRyZW5bT2JqZWN0LmtleXModGhpcy5fY2hpbGRyZW4pWzBdXTtcbiAgfVxuICBhc3luYyAqZWFjaENoaWxkU2VyaWVzKCkge1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh0aGlzLl9jaGlsZHJlbik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgICAgeWllbGQge1xuICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgY2hpbGQ6IHRoaXMuX2NoaWxkcmVuW2tleV1cbiAgICAgIH07XG4gICAgfVxuICB9XG4gIGFzeW5jICpmbHVzaChibG9jaykge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gT2JqZWN0LmtleXModGhpcy5fY2hpbGRyZW4pO1xuICAgIGNvbnN0IGxpbmtzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IGNoaWxkID0gdGhpcy5fY2hpbGRyZW5bY2hpbGRyZW5baV1dO1xuICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgRGlyKSB7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgZW50cnkgb2YgY2hpbGQuZmx1c2goYmxvY2spKSB7XG4gICAgICAgICAgY2hpbGQgPSBlbnRyeTtcbiAgICAgICAgICB5aWVsZCBjaGlsZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNoaWxkLnNpemUgIT0gbnVsbCAmJiBjaGlsZC5jaWQpIHtcbiAgICAgICAgbGlua3MucHVzaCh7XG4gICAgICAgICAgTmFtZTogY2hpbGRyZW5baV0sXG4gICAgICAgICAgVHNpemU6IGNoaWxkLnNpemUsXG4gICAgICAgICAgSGFzaDogY2hpbGQuY2lkXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB1bml4ZnMgPSBuZXcgVW5peEZTKHtcbiAgICAgIHR5cGU6ICdkaXJlY3RvcnknLFxuICAgICAgbXRpbWU6IHRoaXMubXRpbWUsXG4gICAgICBtb2RlOiB0aGlzLm1vZGVcbiAgICB9KTtcbiAgICBjb25zdCBub2RlID0ge1xuICAgICAgRGF0YTogdW5peGZzLm1hcnNoYWwoKSxcbiAgICAgIExpbmtzOiBsaW5rc1xuICAgIH07XG4gICAgY29uc3QgYnVmZmVyID0gZW5jb2RlKHByZXBhcmUobm9kZSkpO1xuICAgIGNvbnN0IGNpZCA9IGF3YWl0IHBlcnNpc3QoYnVmZmVyLCBibG9jaywgdGhpcy5vcHRpb25zKTtcbiAgICBjb25zdCBzaXplID0gYnVmZmVyLmxlbmd0aCArIG5vZGUuTGlua3MucmVkdWNlKChhY2MsIGN1cnIpID0+IGFjYyArIChjdXJyLlRzaXplID09IG51bGwgPyAwIDogY3Vyci5Uc2l6ZSksIDApO1xuICAgIHRoaXMuY2lkID0gY2lkO1xuICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gICAgeWllbGQge1xuICAgICAgY2lkLFxuICAgICAgdW5peGZzLFxuICAgICAgcGF0aDogdGhpcy5wYXRoLFxuICAgICAgc2l6ZVxuICAgIH07XG4gIH1cbn1cbmV4cG9ydCBkZWZhdWx0IERpckZsYXQ7IiwgImltcG9ydCB7XG4gIGVuY29kZSxcbiAgcHJlcGFyZVxufSBmcm9tICdAaXBsZC9kYWctcGInO1xuaW1wb3J0IHsgVW5peEZTIH0gZnJvbSAnaXBmcy11bml4ZnMnO1xuaW1wb3J0IERpciBmcm9tICcuL2Rpci5qcyc7XG5pbXBvcnQgcGVyc2lzdCBmcm9tICcuL3V0aWxzL3BlcnNpc3QuanMnO1xuaW1wb3J0IHtcbiAgY3JlYXRlSEFNVCxcbiAgQnVja2V0XG59IGZyb20gJ2hhbXQtc2hhcmRpbmcnO1xuY2xhc3MgRGlyU2hhcmRlZCBleHRlbmRzIERpciB7XG4gIGNvbnN0cnVjdG9yKHByb3BzLCBvcHRpb25zKSB7XG4gICAgc3VwZXIocHJvcHMsIG9wdGlvbnMpO1xuICAgIHRoaXMuX2J1Y2tldCA9IGNyZWF0ZUhBTVQoe1xuICAgICAgaGFzaEZuOiBvcHRpb25zLmhhbXRIYXNoRm4sXG4gICAgICBiaXRzOiBvcHRpb25zLmhhbXRCdWNrZXRCaXRzXG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgcHV0KG5hbWUsIHZhbHVlKSB7XG4gICAgYXdhaXQgdGhpcy5fYnVja2V0LnB1dChuYW1lLCB2YWx1ZSk7XG4gIH1cbiAgZ2V0KG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5fYnVja2V0LmdldChuYW1lKTtcbiAgfVxuICBjaGlsZENvdW50KCkge1xuICAgIHJldHVybiB0aGlzLl9idWNrZXQubGVhZkNvdW50KCk7XG4gIH1cbiAgZGlyZWN0Q2hpbGRyZW5Db3VudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fYnVja2V0LmNoaWxkcmVuQ291bnQoKTtcbiAgfVxuICBvbmx5Q2hpbGQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2J1Y2tldC5vbmx5Q2hpbGQoKTtcbiAgfVxuICBhc3luYyAqZWFjaENoaWxkU2VyaWVzKCkge1xuICAgIGZvciBhd2FpdCAoY29uc3Qge2tleSwgdmFsdWV9IG9mIHRoaXMuX2J1Y2tldC5lYWNoTGVhZlNlcmllcygpKSB7XG4gICAgICB5aWVsZCB7XG4gICAgICAgIGtleSxcbiAgICAgICAgY2hpbGQ6IHZhbHVlXG4gICAgICB9O1xuICAgIH1cbiAgfVxuICBhc3luYyAqZmx1c2goYmxvY2tzdG9yZSkge1xuICAgIGZvciBhd2FpdCAoY29uc3QgZW50cnkgb2YgZmx1c2godGhpcy5fYnVja2V0LCBibG9ja3N0b3JlLCB0aGlzLCB0aGlzLm9wdGlvbnMpKSB7XG4gICAgICB5aWVsZCB7XG4gICAgICAgIC4uLmVudHJ5LFxuICAgICAgICBwYXRoOiB0aGlzLnBhdGhcbiAgICAgIH07XG4gICAgfVxuICB9XG59XG5leHBvcnQgZGVmYXVsdCBEaXJTaGFyZGVkO1xuYXN5bmMgZnVuY3Rpb24qIGZsdXNoKGJ1Y2tldCwgYmxvY2tzdG9yZSwgc2hhcmRSb290LCBvcHRpb25zKSB7XG4gIGNvbnN0IGNoaWxkcmVuID0gYnVja2V0Ll9jaGlsZHJlbjtcbiAgY29uc3QgbGlua3MgPSBbXTtcbiAgbGV0IGNoaWxkcmVuU2l6ZSA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuLmdldChpKTtcbiAgICBpZiAoIWNoaWxkKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgbGFiZWxQcmVmaXggPSBpLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpLnBhZFN0YXJ0KDIsICcwJyk7XG4gICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgQnVja2V0KSB7XG4gICAgICBsZXQgc2hhcmQ7XG4gICAgICBmb3IgYXdhaXQgKGNvbnN0IHN1YlNoYXJkIG9mIGF3YWl0IGZsdXNoKGNoaWxkLCBibG9ja3N0b3JlLCBudWxsLCBvcHRpb25zKSkge1xuICAgICAgICBzaGFyZCA9IHN1YlNoYXJkO1xuICAgICAgfVxuICAgICAgaWYgKCFzaGFyZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBmbHVzaCBzaGFyZGVkIGRpcmVjdG9yeSwgbm8gc3Vic2hhcmQgZm91bmQnKTtcbiAgICAgIH1cbiAgICAgIGxpbmtzLnB1c2goe1xuICAgICAgICBOYW1lOiBsYWJlbFByZWZpeCxcbiAgICAgICAgVHNpemU6IHNoYXJkLnNpemUsXG4gICAgICAgIEhhc2g6IHNoYXJkLmNpZFxuICAgICAgfSk7XG4gICAgICBjaGlsZHJlblNpemUgKz0gc2hhcmQuc2l6ZTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBjaGlsZC52YWx1ZS5mbHVzaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29uc3QgZGlyID0gY2hpbGQudmFsdWU7XG4gICAgICBsZXQgZmx1c2hlZERpcjtcbiAgICAgIGZvciBhd2FpdCAoY29uc3QgZW50cnkgb2YgZGlyLmZsdXNoKGJsb2Nrc3RvcmUpKSB7XG4gICAgICAgIGZsdXNoZWREaXIgPSBlbnRyeTtcbiAgICAgICAgeWllbGQgZmx1c2hlZERpcjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxhYmVsID0gbGFiZWxQcmVmaXggKyBjaGlsZC5rZXk7XG4gICAgICBsaW5rcy5wdXNoKHtcbiAgICAgICAgTmFtZTogbGFiZWwsXG4gICAgICAgIFRzaXplOiBmbHVzaGVkRGlyLnNpemUsXG4gICAgICAgIEhhc2g6IGZsdXNoZWREaXIuY2lkXG4gICAgICB9KTtcbiAgICAgIGNoaWxkcmVuU2l6ZSArPSBmbHVzaGVkRGlyLnNpemU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gY2hpbGQudmFsdWU7XG4gICAgICBpZiAoIXZhbHVlLmNpZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxhYmVsID0gbGFiZWxQcmVmaXggKyBjaGlsZC5rZXk7XG4gICAgICBjb25zdCBzaXplID0gdmFsdWUuc2l6ZTtcbiAgICAgIGxpbmtzLnB1c2goe1xuICAgICAgICBOYW1lOiBsYWJlbCxcbiAgICAgICAgVHNpemU6IHNpemUsXG4gICAgICAgIEhhc2g6IHZhbHVlLmNpZFxuICAgICAgfSk7XG4gICAgICBjaGlsZHJlblNpemUgKz0gc2l6ZTtcbiAgICB9XG4gIH1cbiAgY29uc3QgZGF0YSA9IFVpbnQ4QXJyYXkuZnJvbShjaGlsZHJlbi5iaXRGaWVsZCgpLnJldmVyc2UoKSk7XG4gIGNvbnN0IGRpciA9IG5ldyBVbml4RlMoe1xuICAgIHR5cGU6ICdoYW10LXNoYXJkZWQtZGlyZWN0b3J5JyxcbiAgICBkYXRhLFxuICAgIGZhbm91dDogYnVja2V0LnRhYmxlU2l6ZSgpLFxuICAgIGhhc2hUeXBlOiBvcHRpb25zLmhhbXRIYXNoQ29kZSxcbiAgICBtdGltZTogc2hhcmRSb290ICYmIHNoYXJkUm9vdC5tdGltZSxcbiAgICBtb2RlOiBzaGFyZFJvb3QgJiYgc2hhcmRSb290Lm1vZGVcbiAgfSk7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgRGF0YTogZGlyLm1hcnNoYWwoKSxcbiAgICBMaW5rczogbGlua3NcbiAgfTtcbiAgY29uc3QgYnVmZmVyID0gZW5jb2RlKHByZXBhcmUobm9kZSkpO1xuICBjb25zdCBjaWQgPSBhd2FpdCBwZXJzaXN0KGJ1ZmZlciwgYmxvY2tzdG9yZSwgb3B0aW9ucyk7XG4gIGNvbnN0IHNpemUgPSBidWZmZXIubGVuZ3RoICsgY2hpbGRyZW5TaXplO1xuICB5aWVsZCB7XG4gICAgY2lkLFxuICAgIHVuaXhmczogZGlyLFxuICAgIHNpemVcbiAgfTtcbn0iLCAiaW1wb3J0IERpclNoYXJkZWQgZnJvbSAnLi9kaXItc2hhcmRlZC5qcyc7XG5pbXBvcnQgRGlyRmxhdCBmcm9tICcuL2Rpci1mbGF0LmpzJztcbmFzeW5jIGZ1bmN0aW9uIGZsYXRUb1NoYXJkKGNoaWxkLCBkaXIsIHRocmVzaG9sZCwgb3B0aW9ucykge1xuICBsZXQgbmV3RGlyID0gZGlyO1xuICBpZiAoZGlyIGluc3RhbmNlb2YgRGlyRmxhdCAmJiBkaXIuZGlyZWN0Q2hpbGRyZW5Db3VudCgpID49IHRocmVzaG9sZCkge1xuICAgIG5ld0RpciA9IGF3YWl0IGNvbnZlcnRUb1NoYXJkKGRpciwgb3B0aW9ucyk7XG4gIH1cbiAgY29uc3QgcGFyZW50ID0gbmV3RGlyLnBhcmVudDtcbiAgaWYgKHBhcmVudCkge1xuICAgIGlmIChuZXdEaXIgIT09IGRpcikge1xuICAgICAgaWYgKGNoaWxkKSB7XG4gICAgICAgIGNoaWxkLnBhcmVudCA9IG5ld0RpcjtcbiAgICAgIH1cbiAgICAgIGlmICghbmV3RGlyLnBhcmVudEtleSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHBhcmVudCBrZXkgZm91bmQnKTtcbiAgICAgIH1cbiAgICAgIGF3YWl0IHBhcmVudC5wdXQobmV3RGlyLnBhcmVudEtleSwgbmV3RGlyKTtcbiAgICB9XG4gICAgcmV0dXJuIGZsYXRUb1NoYXJkKG5ld0RpciwgcGFyZW50LCB0aHJlc2hvbGQsIG9wdGlvbnMpO1xuICB9XG4gIHJldHVybiBuZXdEaXI7XG59XG5hc3luYyBmdW5jdGlvbiBjb252ZXJ0VG9TaGFyZChvbGREaXIsIG9wdGlvbnMpIHtcbiAgY29uc3QgbmV3RGlyID0gbmV3IERpclNoYXJkZWQoe1xuICAgIHJvb3Q6IG9sZERpci5yb290LFxuICAgIGRpcjogdHJ1ZSxcbiAgICBwYXJlbnQ6IG9sZERpci5wYXJlbnQsXG4gICAgcGFyZW50S2V5OiBvbGREaXIucGFyZW50S2V5LFxuICAgIHBhdGg6IG9sZERpci5wYXRoLFxuICAgIGRpcnR5OiBvbGREaXIuZGlydHksXG4gICAgZmxhdDogZmFsc2UsXG4gICAgbXRpbWU6IG9sZERpci5tdGltZSxcbiAgICBtb2RlOiBvbGREaXIubW9kZVxuICB9LCBvcHRpb25zKTtcbiAgZm9yIGF3YWl0IChjb25zdCB7a2V5LCBjaGlsZH0gb2Ygb2xkRGlyLmVhY2hDaGlsZFNlcmllcygpKSB7XG4gICAgYXdhaXQgbmV3RGlyLnB1dChrZXksIGNoaWxkKTtcbiAgfVxuICByZXR1cm4gbmV3RGlyO1xufVxuZXhwb3J0IGRlZmF1bHQgZmxhdFRvU2hhcmQ7IiwgImNvbnN0IHRvUGF0aENvbXBvbmVudHMgPSAocGF0aCA9ICcnKSA9PiB7XG4gIHJldHVybiAocGF0aC50cmltKCkubWF0Y2goLyhbXlxcXFwvXXxcXFxcXFwvKSsvZykgfHwgW10pLmZpbHRlcihCb29sZWFuKTtcbn07XG5leHBvcnQgZGVmYXVsdCB0b1BhdGhDb21wb25lbnRzOyIsICJpbXBvcnQgRGlyRmxhdCBmcm9tICcuL2Rpci1mbGF0LmpzJztcbmltcG9ydCBmbGF0VG9TaGFyZCBmcm9tICcuL2ZsYXQtdG8tc2hhcmQuanMnO1xuaW1wb3J0IERpciBmcm9tICcuL2Rpci5qcyc7XG5pbXBvcnQgdG9QYXRoQ29tcG9uZW50cyBmcm9tICcuL3V0aWxzL3RvLXBhdGgtY29tcG9uZW50cy5qcyc7XG5hc3luYyBmdW5jdGlvbiBhZGRUb1RyZWUoZWxlbSwgdHJlZSwgb3B0aW9ucykge1xuICBjb25zdCBwYXRoRWxlbXMgPSB0b1BhdGhDb21wb25lbnRzKGVsZW0ucGF0aCB8fCAnJyk7XG4gIGNvbnN0IGxhc3RJbmRleCA9IHBhdGhFbGVtcy5sZW5ndGggLSAxO1xuICBsZXQgcGFyZW50ID0gdHJlZTtcbiAgbGV0IGN1cnJlbnRQYXRoID0gJyc7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aEVsZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgcGF0aEVsZW0gPSBwYXRoRWxlbXNbaV07XG4gICAgY3VycmVudFBhdGggKz0gYCR7IGN1cnJlbnRQYXRoID8gJy8nIDogJycgfSR7IHBhdGhFbGVtIH1gO1xuICAgIGNvbnN0IGxhc3QgPSBpID09PSBsYXN0SW5kZXg7XG4gICAgcGFyZW50LmRpcnR5ID0gdHJ1ZTtcbiAgICBwYXJlbnQuY2lkID0gdW5kZWZpbmVkO1xuICAgIHBhcmVudC5zaXplID0gdW5kZWZpbmVkO1xuICAgIGlmIChsYXN0KSB7XG4gICAgICBhd2FpdCBwYXJlbnQucHV0KHBhdGhFbGVtLCBlbGVtKTtcbiAgICAgIHRyZWUgPSBhd2FpdCBmbGF0VG9TaGFyZChudWxsLCBwYXJlbnQsIG9wdGlvbnMuc2hhcmRTcGxpdFRocmVzaG9sZCwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBkaXIgPSBhd2FpdCBwYXJlbnQuZ2V0KHBhdGhFbGVtKTtcbiAgICAgIGlmICghZGlyIHx8ICEoZGlyIGluc3RhbmNlb2YgRGlyKSkge1xuICAgICAgICBkaXIgPSBuZXcgRGlyRmxhdCh7XG4gICAgICAgICAgcm9vdDogZmFsc2UsXG4gICAgICAgICAgZGlyOiB0cnVlLFxuICAgICAgICAgIHBhcmVudDogcGFyZW50LFxuICAgICAgICAgIHBhcmVudEtleTogcGF0aEVsZW0sXG4gICAgICAgICAgcGF0aDogY3VycmVudFBhdGgsXG4gICAgICAgICAgZGlydHk6IHRydWUsXG4gICAgICAgICAgZmxhdDogdHJ1ZSxcbiAgICAgICAgICBtdGltZTogZGlyICYmIGRpci51bml4ZnMgJiYgZGlyLnVuaXhmcy5tdGltZSxcbiAgICAgICAgICBtb2RlOiBkaXIgJiYgZGlyLnVuaXhmcyAmJiBkaXIudW5peGZzLm1vZGVcbiAgICAgICAgfSwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBhd2FpdCBwYXJlbnQucHV0KHBhdGhFbGVtLCBkaXIpO1xuICAgICAgcGFyZW50ID0gZGlyO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJlZTtcbn1cbmFzeW5jIGZ1bmN0aW9uKiBmbHVzaEFuZFlpZWxkKHRyZWUsIGJsb2Nrc3RvcmUpIHtcbiAgaWYgKCEodHJlZSBpbnN0YW5jZW9mIERpcikpIHtcbiAgICBpZiAodHJlZSAmJiB0cmVlLnVuaXhmcyAmJiB0cmVlLnVuaXhmcy5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICB5aWVsZCB0cmVlO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbiAgeWllbGQqIHRyZWUuZmx1c2goYmxvY2tzdG9yZSk7XG59XG5hc3luYyBmdW5jdGlvbiogdHJlZUJ1aWxkZXIoc291cmNlLCBibG9jaywgb3B0aW9ucykge1xuICBsZXQgdHJlZSA9IG5ldyBEaXJGbGF0KHtcbiAgICByb290OiB0cnVlLFxuICAgIGRpcjogdHJ1ZSxcbiAgICBwYXRoOiAnJyxcbiAgICBkaXJ0eTogdHJ1ZSxcbiAgICBmbGF0OiB0cnVlXG4gIH0sIG9wdGlvbnMpO1xuICBmb3IgYXdhaXQgKGNvbnN0IGVudHJ5IG9mIHNvdXJjZSkge1xuICAgIGlmICghZW50cnkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB0cmVlID0gYXdhaXQgYWRkVG9UcmVlKGVudHJ5LCB0cmVlLCBvcHRpb25zKTtcbiAgICBpZiAoIWVudHJ5LnVuaXhmcyB8fCAhZW50cnkudW5peGZzLmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgIHlpZWxkIGVudHJ5O1xuICAgIH1cbiAgfVxuICBpZiAob3B0aW9ucy53cmFwV2l0aERpcmVjdG9yeSkge1xuICAgIHlpZWxkKiBmbHVzaEFuZFlpZWxkKHRyZWUsIGJsb2NrKTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IHVud3JhcHBlZCBvZiB0cmVlLmVhY2hDaGlsZFNlcmllcygpKSB7XG4gICAgICBpZiAoIXVud3JhcHBlZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHlpZWxkKiBmbHVzaEFuZFlpZWxkKHVud3JhcHBlZC5jaGlsZCwgYmxvY2spO1xuICAgIH1cbiAgfVxufVxuZXhwb3J0IGRlZmF1bHQgdHJlZUJ1aWxkZXI7IiwgImltcG9ydCBlcnJDb2RlIGZyb20gJ2Vyci1jb2RlJztcbmltcG9ydCB7IGZyb21TdHJpbmcgYXMgdWludDhBcnJheUZyb21TdHJpbmcgfSBmcm9tICd1aW50OGFycmF5cy9mcm9tLXN0cmluZyc7XG5pbXBvcnQgYnJvd3NlclN0cmVhbVRvSXQgZnJvbSAnYnJvd3Nlci1yZWFkYWJsZXN0cmVhbS10by1pdCc7XG5pbXBvcnQgYmxvYlRvSXQgZnJvbSAnYmxvYi10by1pdCc7XG5pbXBvcnQgaXRQZWVrYWJsZSBmcm9tICdpdC1wZWVrYWJsZSc7XG5pbXBvcnQgYWxsIGZyb20gJ2l0LWFsbCc7XG5pbXBvcnQgbWFwIGZyb20gJ2l0LW1hcCc7XG5pbXBvcnQge1xuICBpc0J5dGVzLFxuICBpc1JlYWRhYmxlU3RyZWFtLFxuICBpc0Jsb2Jcbn0gZnJvbSAnLi91dGlscy5qcyc7XG5hc3luYyBmdW5jdGlvbiogdG9Bc3luY0l0ZXJhYmxlKHRoaW5nKSB7XG4gIHlpZWxkIHRoaW5nO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIG5vcm1hbGlzZUNvbnRlbnQoaW5wdXQpIHtcbiAgaWYgKGlzQnl0ZXMoaW5wdXQpKSB7XG4gICAgcmV0dXJuIHRvQXN5bmNJdGVyYWJsZSh0b0J5dGVzKGlucHV0KSk7XG4gIH1cbiAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycgfHwgaW5wdXQgaW5zdGFuY2VvZiBTdHJpbmcpIHtcbiAgICByZXR1cm4gdG9Bc3luY0l0ZXJhYmxlKHRvQnl0ZXMoaW5wdXQudG9TdHJpbmcoKSkpO1xuICB9XG4gIGlmIChpc0Jsb2IoaW5wdXQpKSB7XG4gICAgcmV0dXJuIGJsb2JUb0l0KGlucHV0KTtcbiAgfVxuICBpZiAoaXNSZWFkYWJsZVN0cmVhbShpbnB1dCkpIHtcbiAgICBpbnB1dCA9IGJyb3dzZXJTdHJlYW1Ub0l0KGlucHV0KTtcbiAgfVxuICBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIGlucHV0IHx8IFN5bWJvbC5hc3luY0l0ZXJhdG9yIGluIGlucHV0KSB7XG4gICAgY29uc3QgcGVla2FibGUgPSBpdFBlZWthYmxlKGlucHV0KTtcbiAgICBjb25zdCB7dmFsdWUsIGRvbmV9ID0gYXdhaXQgcGVla2FibGUucGVlaygpO1xuICAgIGlmIChkb25lKSB7XG4gICAgICByZXR1cm4gdG9Bc3luY0l0ZXJhYmxlKG5ldyBVaW50OEFycmF5KDApKTtcbiAgICB9XG4gICAgcGVla2FibGUucHVzaCh2YWx1ZSk7XG4gICAgaWYgKE51bWJlci5pc0ludGVnZXIodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdG9Bc3luY0l0ZXJhYmxlKFVpbnQ4QXJyYXkuZnJvbShhd2FpdCBhbGwocGVla2FibGUpKSk7XG4gICAgfVxuICAgIGlmIChpc0J5dGVzKHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8IHZhbHVlIGluc3RhbmNlb2YgU3RyaW5nKSB7XG4gICAgICByZXR1cm4gbWFwKHBlZWthYmxlLCB0b0J5dGVzKTtcbiAgICB9XG4gIH1cbiAgdGhyb3cgZXJyQ29kZShuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgaW5wdXQ6ICR7IGlucHV0IH1gKSwgJ0VSUl9VTkVYUEVDVEVEX0lOUFVUJyk7XG59XG5mdW5jdGlvbiB0b0J5dGVzKGNodW5rKSB7XG4gIGlmIChjaHVuayBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICByZXR1cm4gY2h1bms7XG4gIH1cbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhjaHVuaykpIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoY2h1bmsuYnVmZmVyLCBjaHVuay5ieXRlT2Zmc2V0LCBjaHVuay5ieXRlTGVuZ3RoKTtcbiAgfVxuICBpZiAoY2h1bmsgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShjaHVuayk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkoY2h1bmspKSB7XG4gICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShjaHVuayk7XG4gIH1cbiAgcmV0dXJuIHVpbnQ4QXJyYXlGcm9tU3RyaW5nKGNodW5rLnRvU3RyaW5nKCkpO1xufSIsICJleHBvcnQgZnVuY3Rpb24gaXNCeXRlcyhvYmopIHtcbiAgcmV0dXJuIEFycmF5QnVmZmVyLmlzVmlldyhvYmopIHx8IG9iaiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzQmxvYihvYmopIHtcbiAgcmV0dXJuIG9iai5jb25zdHJ1Y3RvciAmJiAob2JqLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdCbG9iJyB8fCBvYmouY29uc3RydWN0b3IubmFtZSA9PT0gJ0ZpbGUnKSAmJiB0eXBlb2Ygb2JqLnN0cmVhbSA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0ZpbGVPYmplY3Qob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiAob2JqLnBhdGggfHwgb2JqLmNvbnRlbnQpO1xufVxuZXhwb3J0IGNvbnN0IGlzUmVhZGFibGVTdHJlYW0gPSB2YWx1ZSA9PiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUuZ2V0UmVhZGVyID09PSAnZnVuY3Rpb24nOyIsICJpbXBvcnQgZXJyQ29kZSBmcm9tICdlcnItY29kZSc7XG5pbXBvcnQgYnJvd3NlclN0cmVhbVRvSXQgZnJvbSAnYnJvd3Nlci1yZWFkYWJsZXN0cmVhbS10by1pdCc7XG5pbXBvcnQgaXRQZWVrYWJsZSBmcm9tICdpdC1wZWVrYWJsZSc7XG5pbXBvcnQge1xuICBpc0J5dGVzLFxuICBpc0Jsb2IsXG4gIGlzUmVhZGFibGVTdHJlYW0sXG4gIGlzRmlsZU9iamVjdFxufSBmcm9tICcuL3V0aWxzLmpzJztcbmltcG9ydCB7XG4gIHBhcnNlTXRpbWUsXG4gIHBhcnNlTW9kZVxufSBmcm9tICdpcGZzLXVuaXhmcyc7XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24qIG5vcm1hbGlzZUNhbmRpZGF0ZVNpbmdsZShpbnB1dCwgbm9ybWFsaXNlQ29udGVudCkge1xuICBpZiAoaW5wdXQgPT09IG51bGwgfHwgaW5wdXQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IGVyckNvZGUobmV3IEVycm9yKGBVbmV4cGVjdGVkIGlucHV0OiAkeyBpbnB1dCB9YCksICdFUlJfVU5FWFBFQ1RFRF9JTlBVVCcpO1xuICB9XG4gIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnIHx8IGlucHV0IGluc3RhbmNlb2YgU3RyaW5nKSB7XG4gICAgeWllbGQgdG9GaWxlT2JqZWN0KGlucHV0LnRvU3RyaW5nKCksIG5vcm1hbGlzZUNvbnRlbnQpO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoaXNCeXRlcyhpbnB1dCkgfHwgaXNCbG9iKGlucHV0KSkge1xuICAgIHlpZWxkIHRvRmlsZU9iamVjdChpbnB1dCwgbm9ybWFsaXNlQ29udGVudCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChpc1JlYWRhYmxlU3RyZWFtKGlucHV0KSkge1xuICAgIGlucHV0ID0gYnJvd3NlclN0cmVhbVRvSXQoaW5wdXQpO1xuICB9XG4gIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gaW5wdXQgfHwgU3ltYm9sLmFzeW5jSXRlcmF0b3IgaW4gaW5wdXQpIHtcbiAgICBjb25zdCBwZWVrYWJsZSA9IGl0UGVla2FibGUoaW5wdXQpO1xuICAgIGNvbnN0IHt2YWx1ZSwgZG9uZX0gPSBhd2FpdCBwZWVrYWJsZS5wZWVrKCk7XG4gICAgaWYgKGRvbmUpIHtcbiAgICAgIHlpZWxkIHsgY29udGVudDogW10gfTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcGVla2FibGUucHVzaCh2YWx1ZSk7XG4gICAgaWYgKE51bWJlci5pc0ludGVnZXIodmFsdWUpIHx8IGlzQnl0ZXModmFsdWUpIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgdmFsdWUgaW5zdGFuY2VvZiBTdHJpbmcpIHtcbiAgICAgIHlpZWxkIHRvRmlsZU9iamVjdChwZWVrYWJsZSwgbm9ybWFsaXNlQ29udGVudCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRocm93IGVyckNvZGUobmV3IEVycm9yKCdVbmV4cGVjdGVkIGlucHV0OiBtdWx0aXBsZSBpdGVtcyBwYXNzZWQgLSBpZiB5b3UgYXJlIHVzaW5nIGlwZnMuYWRkLCBwbGVhc2UgdXNlIGlwZnMuYWRkQWxsIGluc3RlYWQnKSwgJ0VSUl9VTkVYUEVDVEVEX0lOUFVUJyk7XG4gIH1cbiAgaWYgKGlzRmlsZU9iamVjdChpbnB1dCkpIHtcbiAgICB5aWVsZCB0b0ZpbGVPYmplY3QoaW5wdXQsIG5vcm1hbGlzZUNvbnRlbnQpO1xuICAgIHJldHVybjtcbiAgfVxuICB0aHJvdyBlcnJDb2RlKG5ldyBFcnJvcignVW5leHBlY3RlZCBpbnB1dDogY2Fubm90IGNvbnZlcnQgXCInICsgdHlwZW9mIGlucHV0ICsgJ1wiIGludG8gSW1wb3J0Q2FuZGlkYXRlJyksICdFUlJfVU5FWFBFQ1RFRF9JTlBVVCcpO1xufVxuYXN5bmMgZnVuY3Rpb24gdG9GaWxlT2JqZWN0KGlucHV0LCBub3JtYWxpc2VDb250ZW50KSB7XG4gIGNvbnN0IHtwYXRoLCBtb2RlLCBtdGltZSwgY29udGVudH0gPSBpbnB1dDtcbiAgY29uc3QgZmlsZSA9IHtcbiAgICBwYXRoOiBwYXRoIHx8ICcnLFxuICAgIG1vZGU6IHBhcnNlTW9kZShtb2RlKSxcbiAgICBtdGltZTogcGFyc2VNdGltZShtdGltZSlcbiAgfTtcbiAgaWYgKGNvbnRlbnQpIHtcbiAgICBmaWxlLmNvbnRlbnQgPSBhd2FpdCBub3JtYWxpc2VDb250ZW50KGNvbnRlbnQpO1xuICB9IGVsc2UgaWYgKCFwYXRoKSB7XG4gICAgZmlsZS5jb250ZW50ID0gYXdhaXQgbm9ybWFsaXNlQ29udGVudChpbnB1dCk7XG4gIH1cbiAgcmV0dXJuIGZpbGU7XG59IiwgImltcG9ydCB7IG5vcm1hbGlzZUNvbnRlbnQgfSBmcm9tICcuL25vcm1hbGlzZS1jb250ZW50LmpzJztcbmltcG9ydCB7IG5vcm1hbGlzZUNhbmRpZGF0ZVNpbmdsZSB9IGZyb20gJy4vbm9ybWFsaXNlLWNhbmRpZGF0ZS1zaW5nbGUuanMnO1xuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGlzZUlucHV0KGlucHV0KSB7XG4gIHJldHVybiBub3JtYWxpc2VDYW5kaWRhdGVTaW5nbGUoaW5wdXQsIG5vcm1hbGlzZUNvbnRlbnQpO1xufSIsICJpbXBvcnQgZXJyQ29kZSBmcm9tICdlcnItY29kZSc7XG5pbXBvcnQgYnJvd3NlclN0cmVhbVRvSXQgZnJvbSAnYnJvd3Nlci1yZWFkYWJsZXN0cmVhbS10by1pdCc7XG5pbXBvcnQgaXRQZWVrYWJsZSBmcm9tICdpdC1wZWVrYWJsZSc7XG5pbXBvcnQgbWFwIGZyb20gJ2l0LW1hcCc7XG5pbXBvcnQge1xuICBpc0J5dGVzLFxuICBpc0Jsb2IsXG4gIGlzUmVhZGFibGVTdHJlYW0sXG4gIGlzRmlsZU9iamVjdFxufSBmcm9tICcuL3V0aWxzLmpzJztcbmltcG9ydCB7XG4gIHBhcnNlTXRpbWUsXG4gIHBhcnNlTW9kZVxufSBmcm9tICdpcGZzLXVuaXhmcyc7XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24qIG5vcm1hbGlzZUNhbmRpZGF0ZU11bHRpcGxlKGlucHV0LCBub3JtYWxpc2VDb250ZW50KSB7XG4gIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnIHx8IGlucHV0IGluc3RhbmNlb2YgU3RyaW5nIHx8IGlzQnl0ZXMoaW5wdXQpIHx8IGlzQmxvYihpbnB1dCkgfHwgaW5wdXQuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICB0aHJvdyBlcnJDb2RlKG5ldyBFcnJvcignVW5leHBlY3RlZCBpbnB1dDogc2luZ2xlIGl0ZW0gcGFzc2VkIC0gaWYgeW91IGFyZSB1c2luZyBpcGZzLmFkZEFsbCwgcGxlYXNlIHVzZSBpcGZzLmFkZCBpbnN0ZWFkJyksICdFUlJfVU5FWFBFQ1RFRF9JTlBVVCcpO1xuICB9XG4gIGlmIChpc1JlYWRhYmxlU3RyZWFtKGlucHV0KSkge1xuICAgIGlucHV0ID0gYnJvd3NlclN0cmVhbVRvSXQoaW5wdXQpO1xuICB9XG4gIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gaW5wdXQgfHwgU3ltYm9sLmFzeW5jSXRlcmF0b3IgaW4gaW5wdXQpIHtcbiAgICBjb25zdCBwZWVrYWJsZSA9IGl0UGVla2FibGUoaW5wdXQpO1xuICAgIGNvbnN0IHt2YWx1ZSwgZG9uZX0gPSBhd2FpdCBwZWVrYWJsZS5wZWVrKCk7XG4gICAgaWYgKGRvbmUpIHtcbiAgICAgIHlpZWxkKiBbXTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcGVla2FibGUucHVzaCh2YWx1ZSk7XG4gICAgaWYgKE51bWJlci5pc0ludGVnZXIodmFsdWUpKSB7XG4gICAgICB0aHJvdyBlcnJDb2RlKG5ldyBFcnJvcignVW5leHBlY3RlZCBpbnB1dDogc2luZ2xlIGl0ZW0gcGFzc2VkIC0gaWYgeW91IGFyZSB1c2luZyBpcGZzLmFkZEFsbCwgcGxlYXNlIHVzZSBpcGZzLmFkZCBpbnN0ZWFkJyksICdFUlJfVU5FWFBFQ1RFRF9JTlBVVCcpO1xuICAgIH1cbiAgICBpZiAodmFsdWUuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICAgIHlpZWxkKiBtYXAocGVla2FibGUsIHZhbHVlID0+IHRvRmlsZU9iamVjdCh7IGNvbnRlbnQ6IHZhbHVlIH0sIG5vcm1hbGlzZUNvbnRlbnQpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGlzQnl0ZXModmFsdWUpKSB7XG4gICAgICB5aWVsZCB0b0ZpbGVPYmplY3QoeyBjb250ZW50OiBwZWVrYWJsZSB9LCBub3JtYWxpc2VDb250ZW50KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGlzRmlsZU9iamVjdCh2YWx1ZSkgfHwgdmFsdWVbU3ltYm9sLml0ZXJhdG9yXSB8fCB2YWx1ZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gfHwgaXNSZWFkYWJsZVN0cmVhbSh2YWx1ZSkgfHwgaXNCbG9iKHZhbHVlKSkge1xuICAgICAgeWllbGQqIG1hcChwZWVrYWJsZSwgdmFsdWUgPT4gdG9GaWxlT2JqZWN0KHZhbHVlLCBub3JtYWxpc2VDb250ZW50KSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIGlmIChpc0ZpbGVPYmplY3QoaW5wdXQpKSB7XG4gICAgdGhyb3cgZXJyQ29kZShuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgaW5wdXQ6IHNpbmdsZSBpdGVtIHBhc3NlZCAtIGlmIHlvdSBhcmUgdXNpbmcgaXBmcy5hZGRBbGwsIHBsZWFzZSB1c2UgaXBmcy5hZGQgaW5zdGVhZCcpLCAnRVJSX1VORVhQRUNURURfSU5QVVQnKTtcbiAgfVxuICB0aHJvdyBlcnJDb2RlKG5ldyBFcnJvcignVW5leHBlY3RlZCBpbnB1dDogJyArIHR5cGVvZiBpbnB1dCksICdFUlJfVU5FWFBFQ1RFRF9JTlBVVCcpO1xufVxuYXN5bmMgZnVuY3Rpb24gdG9GaWxlT2JqZWN0KGlucHV0LCBub3JtYWxpc2VDb250ZW50KSB7XG4gIGNvbnN0IHtwYXRoLCBtb2RlLCBtdGltZSwgY29udGVudH0gPSBpbnB1dDtcbiAgY29uc3QgZmlsZSA9IHtcbiAgICBwYXRoOiBwYXRoIHx8ICcnLFxuICAgIG1vZGU6IHBhcnNlTW9kZShtb2RlKSxcbiAgICBtdGltZTogcGFyc2VNdGltZShtdGltZSlcbiAgfTtcbiAgaWYgKGNvbnRlbnQpIHtcbiAgICBmaWxlLmNvbnRlbnQgPSBhd2FpdCBub3JtYWxpc2VDb250ZW50KGNvbnRlbnQpO1xuICB9IGVsc2UgaWYgKCFwYXRoKSB7XG4gICAgZmlsZS5jb250ZW50ID0gYXdhaXQgbm9ybWFsaXNlQ29udGVudChpbnB1dCk7XG4gIH1cbiAgcmV0dXJuIGZpbGU7XG59IiwgImltcG9ydCB7IG5vcm1hbGlzZUNvbnRlbnQgfSBmcm9tICcuL25vcm1hbGlzZS1jb250ZW50LmpzJztcbmltcG9ydCB7IG5vcm1hbGlzZUNhbmRpZGF0ZU11bHRpcGxlIH0gZnJvbSAnLi9ub3JtYWxpc2UtY2FuZGlkYXRlLW11bHRpcGxlLmpzJztcbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpc2VJbnB1dChpbnB1dCkge1xuICByZXR1cm4gbm9ybWFsaXNlQ2FuZGlkYXRlTXVsdGlwbGUoaW5wdXQsIG5vcm1hbGlzZUNvbnRlbnQpO1xufSIsICJpbXBvcnQgeyBub3JtYWxpc2VJbnB1dCBhcyBub3JtYWxpc2VJbnB1dFNpbmdsZSB9IGZyb20gJ2lwZnMtY29yZS11dGlscy9maWxlcy9ub3JtYWxpc2UtaW5wdXQtc2luZ2xlJztcbmltcG9ydCB7IG5vcm1hbGlzZUlucHV0IGFzIG5vcm1hbGlzZUlucHV0TXVsdGlwbGUgfSBmcm9tICdpcGZzLWNvcmUtdXRpbHMvZmlsZXMvbm9ybWFsaXNlLWlucHV0LW11bHRpcGxlJztcbmZ1bmN0aW9uIGlzQnl0ZXMob2JqKSB7XG4gICAgcmV0dXJuIEFycmF5QnVmZmVyLmlzVmlldyhvYmopIHx8IG9iaiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyO1xufVxuZnVuY3Rpb24gaXNCbG9iKG9iaikge1xuICAgIHJldHVybiBCb29sZWFuKG9iai5jb25zdHJ1Y3RvcikgJiZcbiAgICAgICAgKG9iai5jb25zdHJ1Y3Rvci5uYW1lID09PSAnQmxvYicgfHwgb2JqLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdGaWxlJykgJiZcbiAgICAgICAgdHlwZW9mIG9iai5zdHJlYW0gPT09ICdmdW5jdGlvbic7XG59XG5mdW5jdGlvbiBpc1NpbmdsZShpbnB1dCkge1xuICAgIHJldHVybiB0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnIHx8IGlucHV0IGluc3RhbmNlb2YgU3RyaW5nIHx8IGlzQnl0ZXMoaW5wdXQpIHx8IGlzQmxvYihpbnB1dCkgfHwgJ19yZWFkYWJsZVN0YXRlJyBpbiBpbnB1dDtcbn1cbi8qKlxuICogR2V0IGEgc2luZ2xlIG9yIG11bHRpcGxlIG5vcm1hbGlzZXIgZGVwZW5kaW5nIG9uIHRoZSBpbnB1dC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE5vcm1hbGlzZXIoaW5wdXQpIHtcbiAgICBpZiAoaXNTaW5nbGUoaW5wdXQpKSB7XG4gICAgICAgIHJldHVybiBub3JtYWxpc2VJbnB1dFNpbmdsZShpbnB1dCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbm9ybWFsaXNlSW5wdXRNdWx0aXBsZShpbnB1dCk7XG4gICAgfVxufVxuIiwgImltcG9ydCBlcnJDb2RlIGZyb20gJ2Vyci1jb2RlJztcbmV4cG9ydCBmdW5jdGlvbiBub3RGb3VuZEVycm9yKGVycikge1xuICBlcnIgPSBlcnIgfHwgbmV3IEVycm9yKCdOb3QgRm91bmQnKTtcbiAgcmV0dXJuIGVyckNvZGUoZXJyLCAnRVJSX05PVF9GT1VORCcpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGFib3J0ZWRFcnJvcihlcnIpIHtcbiAgZXJyID0gZXJyIHx8IG5ldyBFcnJvcignQWJvcnRlZCcpO1xuICByZXR1cm4gZXJyQ29kZShlcnIsICdFUlJfQUJPUlRFRCcpO1xufSIsICJpbXBvcnQgZHJhaW4gZnJvbSAnaXQtZHJhaW4nO1xuaW1wb3J0IGZpbHRlciBmcm9tICdpdC1maWx0ZXInO1xuaW1wb3J0IHRha2UgZnJvbSAnaXQtdGFrZSc7XG5pbXBvcnQgYWxsIGZyb20gJ2l0LWFsbCc7XG5jb25zdCBzb3J0QWxsID0gKGl0ZXJhYmxlLCBzb3J0ZXIpID0+IHtcbiAgcmV0dXJuIGFzeW5jIGZ1bmN0aW9uKiAoKSB7XG4gICAgY29uc3QgdmFsdWVzID0gYXdhaXQgYWxsKGl0ZXJhYmxlKTtcbiAgICB5aWVsZCogdmFsdWVzLnNvcnQoc29ydGVyKTtcbiAgfSgpO1xufTtcbmV4cG9ydCBjbGFzcyBCYXNlQmxvY2tzdG9yZSB7XG4gIG9wZW4oKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignLm9wZW4gaXMgbm90IGltcGxlbWVudGVkJykpO1xuICB9XG4gIGNsb3NlKCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJy5jbG9zZSBpcyBub3QgaW1wbGVtZW50ZWQnKSk7XG4gIH1cbiAgcHV0KGtleSwgdmFsLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignLnB1dCBpcyBub3QgaW1wbGVtZW50ZWQnKSk7XG4gIH1cbiAgZ2V0KGtleSwgb3B0aW9ucykge1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJy5nZXQgaXMgbm90IGltcGxlbWVudGVkJykpO1xuICB9XG4gIGhhcyhrZXksIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCcuaGFzIGlzIG5vdCBpbXBsZW1lbnRlZCcpKTtcbiAgfVxuICBkZWxldGUoa2V5LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignLmRlbGV0ZSBpcyBub3QgaW1wbGVtZW50ZWQnKSk7XG4gIH1cbiAgYXN5bmMgKnB1dE1hbnkoc291cmNlLCBvcHRpb25zID0ge30pIHtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IHtrZXksIHZhbHVlfSBvZiBzb3VyY2UpIHtcbiAgICAgIGF3YWl0IHRoaXMucHV0KGtleSwgdmFsdWUsIG9wdGlvbnMpO1xuICAgICAgeWllbGQge1xuICAgICAgICBrZXksXG4gICAgICAgIHZhbHVlXG4gICAgICB9O1xuICAgIH1cbiAgfVxuICBhc3luYyAqZ2V0TWFueShzb3VyY2UsIG9wdGlvbnMgPSB7fSkge1xuICAgIGZvciBhd2FpdCAoY29uc3Qga2V5IG9mIHNvdXJjZSkge1xuICAgICAgeWllbGQgdGhpcy5nZXQoa2V5LCBvcHRpb25zKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgKmRlbGV0ZU1hbnkoc291cmNlLCBvcHRpb25zID0ge30pIHtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IGtleSBvZiBzb3VyY2UpIHtcbiAgICAgIGF3YWl0IHRoaXMuZGVsZXRlKGtleSwgb3B0aW9ucyk7XG4gICAgICB5aWVsZCBrZXk7XG4gICAgfVxuICB9XG4gIGJhdGNoKCkge1xuICAgIGxldCBwdXRzID0gW107XG4gICAgbGV0IGRlbHMgPSBbXTtcbiAgICByZXR1cm4ge1xuICAgICAgcHV0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgcHV0cy5wdXNoKHtcbiAgICAgICAgICBrZXksXG4gICAgICAgICAgdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgZGVsZXRlKGtleSkge1xuICAgICAgICBkZWxzLnB1c2goa2V5KTtcbiAgICAgIH0sXG4gICAgICBjb21taXQ6IGFzeW5jIG9wdGlvbnMgPT4ge1xuICAgICAgICBhd2FpdCBkcmFpbih0aGlzLnB1dE1hbnkocHV0cywgb3B0aW9ucykpO1xuICAgICAgICBwdXRzID0gW107XG4gICAgICAgIGF3YWl0IGRyYWluKHRoaXMuZGVsZXRlTWFueShkZWxzLCBvcHRpb25zKSk7XG4gICAgICAgIGRlbHMgPSBbXTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGFzeW5jICpfYWxsKHEsIG9wdGlvbnMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJy5fYWxsIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xuICB9XG4gIGFzeW5jICpfYWxsS2V5cyhxLCBvcHRpb25zKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCcuX2FsbEtleXMgaXMgbm90IGltcGxlbWVudGVkJyk7XG4gIH1cbiAgcXVlcnkocSwgb3B0aW9ucykge1xuICAgIGxldCBpdCA9IHRoaXMuX2FsbChxLCBvcHRpb25zKTtcbiAgICBpZiAocS5wcmVmaXggIT0gbnVsbCkge1xuICAgICAgaXQgPSBmaWx0ZXIoaXQsIGUgPT4gZS5rZXkudG9TdHJpbmcoKS5zdGFydHNXaXRoKHEucHJlZml4IHx8ICcnKSk7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KHEuZmlsdGVycykpIHtcbiAgICAgIGl0ID0gcS5maWx0ZXJzLnJlZHVjZSgoaXQsIGYpID0+IGZpbHRlcihpdCwgZiksIGl0KTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocS5vcmRlcnMpKSB7XG4gICAgICBpdCA9IHEub3JkZXJzLnJlZHVjZSgoaXQsIGYpID0+IHNvcnRBbGwoaXQsIGYpLCBpdCk7XG4gICAgfVxuICAgIGlmIChxLm9mZnNldCAhPSBudWxsKSB7XG4gICAgICBsZXQgaSA9IDA7XG4gICAgICBpdCA9IGZpbHRlcihpdCwgKCkgPT4gaSsrID49IChxLm9mZnNldCB8fCAwKSk7XG4gICAgfVxuICAgIGlmIChxLmxpbWl0ICE9IG51bGwpIHtcbiAgICAgIGl0ID0gdGFrZShpdCwgcS5saW1pdCk7XG4gICAgfVxuICAgIHJldHVybiBpdDtcbiAgfVxuICBxdWVyeUtleXMocSwgb3B0aW9ucykge1xuICAgIGxldCBpdCA9IHRoaXMuX2FsbEtleXMocSwgb3B0aW9ucyk7XG4gICAgaWYgKHEucHJlZml4ICE9IG51bGwpIHtcbiAgICAgIGl0ID0gZmlsdGVyKGl0LCBjaWQgPT4gY2lkLnRvU3RyaW5nKCkuc3RhcnRzV2l0aChxLnByZWZpeCB8fCAnJykpO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShxLmZpbHRlcnMpKSB7XG4gICAgICBpdCA9IHEuZmlsdGVycy5yZWR1Y2UoKGl0LCBmKSA9PiBmaWx0ZXIoaXQsIGYpLCBpdCk7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KHEub3JkZXJzKSkge1xuICAgICAgaXQgPSBxLm9yZGVycy5yZWR1Y2UoKGl0LCBmKSA9PiBzb3J0QWxsKGl0LCBmKSwgaXQpO1xuICAgIH1cbiAgICBpZiAocS5vZmZzZXQgIT0gbnVsbCkge1xuICAgICAgbGV0IGkgPSAwO1xuICAgICAgaXQgPSBmaWx0ZXIoaXQsICgpID0+IGkrKyA+PSBxLm9mZnNldCk7XG4gICAgfVxuICAgIGlmIChxLmxpbWl0ICE9IG51bGwpIHtcbiAgICAgIGl0ID0gdGFrZShpdCwgcS5saW1pdCk7XG4gICAgfVxuICAgIHJldHVybiBpdDtcbiAgfVxufSIsICJpbXBvcnQgKiBhcyBFcnJvcnNJbXBvcnQgZnJvbSAnLi9lcnJvcnMuanMnO1xuZXhwb3J0IHtcbiAgQmFzZUJsb2Nrc3RvcmVcbn0gZnJvbSAnLi9iYXNlLmpzJztcbmV4cG9ydCB7XG4gIE1lbW9yeUJsb2Nrc3RvcmVcbn0gZnJvbSAnLi9tZW1vcnkuanMnO1xuZXhwb3J0IGNvbnN0IEVycm9ycyA9IHsgLi4uRXJyb3JzSW1wb3J0IH07IiwgImltcG9ydCB7IENJRCB9IGZyb20gJ211bHRpZm9ybWF0cyc7XG5pbXBvcnQgeyBCYXNlQmxvY2tzdG9yZSB9IGZyb20gJ2Jsb2Nrc3RvcmUtY29yZSc7XG5leHBvcnQgY2xhc3MgTWVtb3J5QmxvY2tTdG9yZSBleHRlbmRzIEJhc2VCbG9ja3N0b3JlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zdG9yZSA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgYXN5bmMgKmJsb2NrcygpIHtcbiAgICAgICAgZm9yIChjb25zdCBbY2lkU3RyLCBieXRlc10gb2YgdGhpcy5zdG9yZS5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgIHlpZWxkIHsgY2lkOiBDSUQucGFyc2UoY2lkU3RyKSwgYnl0ZXMgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwdXQoY2lkLCBieXRlcykge1xuICAgICAgICB0aGlzLnN0b3JlLnNldChjaWQudG9TdHJpbmcoKSwgYnl0ZXMpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIGdldChjaWQpIHtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSB0aGlzLnN0b3JlLmdldChjaWQudG9TdHJpbmcoKSk7XG4gICAgICAgIGlmICghYnl0ZXMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgYmxvY2sgd2l0aCBjaWQgJHtjaWQudG9TdHJpbmcoKX0gbm8gZm91bmRgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGJ5dGVzKTtcbiAgICB9XG4gICAgaGFzKGNpZCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuc3RvcmUuaGFzKGNpZC50b1N0cmluZygpKSk7XG4gICAgfVxuICAgIGNsb3NlKCkge1xuICAgICAgICB0aGlzLnN0b3JlLmNsZWFyKCk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHsgc2hhMjU2IH0gZnJvbSAnbXVsdGlmb3JtYXRzL2hhc2hlcy9zaGEyJztcbmV4cG9ydCBjb25zdCB1bml4ZnNJbXBvcnRlck9wdGlvbnNEZWZhdWx0ID0ge1xuICAgIGNpZFZlcnNpb246IDEsXG4gICAgY2h1bmtlcjogJ2ZpeGVkJyxcbiAgICBtYXhDaHVua1NpemU6IDI2MjE0NCxcbiAgICBoYXNoZXI6IHNoYTI1NixcbiAgICByYXdMZWF2ZXM6IHRydWUsXG4gICAgd3JhcFdpdGhEaXJlY3Rvcnk6IHRydWUsXG4gICAgbWF4Q2hpbGRyZW5QZXJOb2RlOiAxNzRcbn07XG4iLCAiLyoqXG4gKiBJbmRleC5qc1xuICpcbiAqIGEgcmVxdWVzdCBBUEkgY29tcGF0aWJsZSB3aXRoIHdpbmRvdy5mZXRjaFxuICpcbiAqIEFsbCBzcGVjIGFsZ29yaXRobSBzdGVwIG51bWJlcnMgYXJlIGJhc2VkIG9uIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnL2NvbW1pdC1zbmFwc2hvdHMvYWU3MTY4MjJjYjNhNjE4NDMyMjZjZDA5MGVlZmM2NTg5NDQ2YzFkMi8uXG4gKi9cblxuaW1wb3J0IGh0dHAgZnJvbSAnaHR0cCc7XG5pbXBvcnQgaHR0cHMgZnJvbSAnaHR0cHMnO1xuaW1wb3J0IHpsaWIgZnJvbSAnemxpYic7XG5pbXBvcnQgZnMgZnJvbSAnZnMnO1xuaW1wb3J0ICogYXMgbWltZSBmcm9tICdtcm1pbWUnXG5pbXBvcnQgZGF0YVVyaVRvQnVmZmVyIGZyb20gJ2RhdGEtdXJpLXRvLWJ1ZmZlcic7XG5pbXBvcnQge0J1ZmZlcn0gZnJvbSAnYnVmZmVyJztcblxuaW1wb3J0IHt3cml0ZVRvU3RyZWFtLCBmcm9tQXN5bmNJdGVyYWJsZX0gZnJvbSAnLi9ib2R5LmpzJztcbmltcG9ydCBSZXNwb25zZSBmcm9tICcuL3Jlc3BvbnNlLmpzJztcbmltcG9ydCBIZWFkZXJzLCB7ZnJvbVJhd0hlYWRlcnN9IGZyb20gJy4vaGVhZGVycy5qcyc7XG5pbXBvcnQgUmVxdWVzdCwge2dldE5vZGVSZXF1ZXN0T3B0aW9uc30gZnJvbSAnLi9yZXF1ZXN0LmpzJztcbmltcG9ydCB7RmV0Y2hFcnJvcn0gZnJvbSAnLi9lcnJvcnMvZmV0Y2gtZXJyb3IuanMnO1xuaW1wb3J0IHtBYm9ydEVycm9yfSBmcm9tICcuL2Vycm9ycy9hYm9ydC1lcnJvci5qcyc7XG5pbXBvcnQge2lzUmVkaXJlY3R9IGZyb20gJy4vdXRpbHMvaXMtcmVkaXJlY3QuanMnO1xuaW1wb3J0IHtwaXBlbGluZSBhcyBwdW1wLCBQYXNzVGhyb3VnaH0gZnJvbSAnc3RyZWFtJztcbmltcG9ydCAqIGFzIFN0cmVhbSBmcm9tICdzdHJlYW0nO1xuaW1wb3J0IHsgUmVhZGFibGVTdHJlYW0sIEJsb2IsIEZvcm1EYXRhICB9IGZyb20gJy4vcGFja2FnZS5qcyc7XG5cblxuZXhwb3J0IHtIZWFkZXJzLCBSZXF1ZXN0LCBSZXNwb25zZSwgUmVhZGFibGVTdHJlYW0sIEJsb2IsIEZvcm1EYXRhfTtcblxuY29uc3Qgc3VwcG9ydGVkU2NoZW1hcyA9IG5ldyBTZXQoWydkYXRhOicsICdodHRwOicsICdodHRwczonLCAnZmlsZTonXSk7XG5cbi8qKlxuICogRmV0Y2ggZnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0gICB7c3RyaW5nIHwgVVJMIHwgaW1wb3J0KCcuL3JlcXVlc3QuanMnKS5kZWZhdWx0fSB1cmwgLSBBYnNvbHV0ZSB1cmwgb3IgUmVxdWVzdCBpbnN0YW5jZVxuICogQHBhcmFtICAge1JlcXVlc3RJbml0ICYgaW1wb3J0KCcuL3JlcXVlc3QuanMnKS5SZXF1ZXN0RXh0cmFPcHRpb25zfSBbb3B0aW9uc19dIC0gRmV0Y2ggb3B0aW9uc1xuICogQHJldHVybiAge1Byb21pc2U8aW1wb3J0KCcuL3Jlc3BvbnNlLmpzJykuZGVmYXVsdD59XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGZldGNoKHVybCwgb3B0aW9uc18gPSB7fSkge1xuXHRyZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXHRcdC8vIEJ1aWxkIHJlcXVlc3Qgb2JqZWN0XG5cdFx0Y29uc3QgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KHVybCwgb3B0aW9uc18pO1xuXHRcdGNvbnN0IG9wdGlvbnMgPSBnZXROb2RlUmVxdWVzdE9wdGlvbnMocmVxdWVzdCk7XG5cdFx0aWYgKCFzdXBwb3J0ZWRTY2hlbWFzLmhhcyhvcHRpb25zLnByb3RvY29sKSkge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihgbm9kZS1mZXRjaCBjYW5ub3QgbG9hZCAke3VybH0uIFVSTCBzY2hlbWUgXCIke29wdGlvbnMucHJvdG9jb2wucmVwbGFjZSgvOiQvLCAnJyl9XCIgaXMgbm90IHN1cHBvcnRlZC5gKTtcblx0XHR9XG5cblx0XHRpZiAob3B0aW9ucy5wcm90b2NvbCA9PT0gJ2RhdGE6Jykge1xuXHRcdFx0Y29uc3QgZGF0YSA9IGRhdGFVcmlUb0J1ZmZlcihyZXF1ZXN0LnVybC50b1N0cmluZygpKTtcblx0XHRcdGNvbnN0IHJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKGRhdGEsIHtoZWFkZXJzOiB7J0NvbnRlbnQtVHlwZSc6IGRhdGEudHlwZUZ1bGx9fSk7XG5cdFx0XHRyZXNvbHZlKHJlc3BvbnNlKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAob3B0aW9ucy5wcm90b2NvbCA9PT0gJ2ZpbGU6Jykge1xuXHRcdFx0Y29uc3Qgc3RyZWFtID0gZnMuY3JlYXRlUmVhZFN0cmVhbShuZXcgVVJMKHJlcXVlc3QudXJsKSlcblx0XHRcdGNvbnN0IHR5cGUgPSBtaW1lLmxvb2t1cChyZXF1ZXN0LnVybCkgfHwgJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbSdcblx0XHRcdGNvbnN0IHJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKHN0cmVhbSwge2hlYWRlcnM6IHsnQ29udGVudC1UeXBlJzogdHlwZSB9fSk7XG5cdFx0XHRyZXNvbHZlKHJlc3BvbnNlKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBXcmFwIGh0dHAucmVxdWVzdCBpbnRvIGZldGNoXG5cdFx0Y29uc3Qgc2VuZCA9IChvcHRpb25zLnByb3RvY29sID09PSAnaHR0cHM6JyA/IGh0dHBzIDogaHR0cCkucmVxdWVzdDtcblx0XHRjb25zdCB7c2lnbmFsfSA9IHJlcXVlc3Q7XG5cdFx0LyoqIEB0eXBlIHtSZXNwb25zZXxudWxsfSAqL1xuXHRcdGxldCByZXNwb25zZSA9IG51bGw7XG5cdFx0LyoqIEB0eXBlIHtpbXBvcnQoJ2h0dHAnKS5JbmNvbWluZ01lc3NhZ2V8bnVsbH0gKi9cblx0XHRsZXQgcmVzcG9uc2VfID0gbnVsbDtcblxuXHRcdGNvbnN0IGFib3J0ID0gKCkgPT4ge1xuXHRcdFx0Y29uc3QgZXJyb3IgPSBuZXcgQWJvcnRFcnJvcignVGhlIG9wZXJhdGlvbiB3YXMgYWJvcnRlZC4nKTtcblx0XHRcdHJlamVjdChlcnJvcik7XG5cdFx0XHRpZiAocmVxdWVzdC5ib2R5KSB7XG5cdFx0XHRcdHJlcXVlc3QuYm9keS5jYW5jZWwoZXJyb3IpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIXJlc3BvbnNlXykge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHJlc3BvbnNlXy5lbWl0KCdlcnJvcicsIGVycm9yKTtcblx0XHR9O1xuXG5cdFx0aWYgKHNpZ25hbCAmJiBzaWduYWwuYWJvcnRlZCkge1xuXHRcdFx0YWJvcnQoKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRjb25zdCBhYm9ydEFuZEZpbmFsaXplID0gKCkgPT4ge1xuXHRcdFx0YWJvcnQoKTtcblx0XHRcdGZpbmFsaXplKCk7XG5cdFx0fTtcblxuXHRcdC8vIFNlbmQgcmVxdWVzdFxuXHRcdGNvbnN0IHJlcXVlc3RfID0gc2VuZChvcHRpb25zKTtcblxuXHRcdGlmIChzaWduYWwpIHtcblx0XHRcdHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIGFib3J0QW5kRmluYWxpemUpO1xuXHRcdH1cblxuXHRcdGNvbnN0IGZpbmFsaXplID0gKCkgPT4ge1xuXHRcdFx0cmVxdWVzdF8uYWJvcnQoKTtcblx0XHRcdGlmIChzaWduYWwpIHtcblx0XHRcdFx0c2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRBbmRGaW5hbGl6ZSk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdHJlcXVlc3RfLm9uKCdlcnJvcicsIGVyciA9PiB7XG5cdFx0XHQvLyBAdHMtZXhwZWN0LWVycm9yIC0gZXJyIG1heSBub3QgYmUgU3lzdGVtRXJyb3Jcblx0XHRcdHJlamVjdChuZXcgRmV0Y2hFcnJvcihgcmVxdWVzdCB0byAke3JlcXVlc3QudXJsfSBmYWlsZWQsIHJlYXNvbjogJHtlcnIubWVzc2FnZX1gLCAnc3lzdGVtJywgZXJyKSk7XG5cdFx0XHRmaW5hbGl6ZSgpO1xuXHRcdH0pO1xuXG5cdFx0Zml4UmVzcG9uc2VDaHVua2VkVHJhbnNmZXJCYWRFbmRpbmcocmVxdWVzdF8sIGVyciA9PiB7XG5cdFx0XHRpZiAoc2lnbmFsICYmIHNpZ25hbC5hYm9ydGVkKSB7XG5cdFx0XHRcdHJldHVyblxuXHRcdFx0fVxuXG5cdFx0XHRyZXNwb25zZV8/LmVtaXQoXCJlcnJvclwiLCBlcnIpO1xuXHRcdH0pO1xuXG5cdFx0LyogYzggaWdub3JlIG5leHQgMTggKi9cblx0XHRpZiAocGFyc2VJbnQocHJvY2Vzcy52ZXJzaW9uLnN1YnN0cmluZygxKSkgPCAxNCkge1xuXHRcdFx0Ly8gQmVmb3JlIE5vZGUuanMgMTQsIHBpcGVsaW5lKCkgZG9lcyBub3QgZnVsbHkgc3VwcG9ydCBhc3luYyBpdGVyYXRvcnMgYW5kIGRvZXMgbm90IGFsd2F5c1xuXHRcdFx0Ly8gcHJvcGVybHkgaGFuZGxlIHdoZW4gdGhlIHNvY2tldCBjbG9zZS9lbmQgZXZlbnRzIGFyZSBvdXQgb2Ygb3JkZXIuXG5cdFx0XHRyZXF1ZXN0Xy5vbignc29ja2V0JywgcyA9PiB7XG5cdFx0XHRcdHMucHJlcGVuZExpc3RlbmVyKCdjbG9zZScsIGhhZEVycm9yID0+IHtcblx0XHRcdFx0XHQvLyBpZiBhIGRhdGEgbGlzdGVuZXIgaXMgc3RpbGwgcHJlc2VudCB3ZSBkaWRuJ3QgZW5kIGNsZWFubHlcblx0XHRcdFx0XHRjb25zdCBoYXNEYXRhTGlzdGVuZXIgPSBzLmxpc3RlbmVyQ291bnQoJ2RhdGEnKSA+IDBcblxuXHRcdFx0XHRcdC8vIGlmIGVuZCBoYXBwZW5lZCBiZWZvcmUgY2xvc2UgYnV0IHRoZSBzb2NrZXQgZGlkbid0IGVtaXQgYW4gZXJyb3IsIGRvIGl0IG5vd1xuXHRcdFx0XHRcdGlmIChyZXNwb25zZSAmJiBoYXNEYXRhTGlzdGVuZXIgJiYgIWhhZEVycm9yICYmICEoc2lnbmFsICYmIHNpZ25hbC5hYm9ydGVkKSkge1xuXHRcdFx0XHRcdFx0Y29uc3QgZXJyID0gT2JqZWN0LmFzc2lnbihuZXcgRXJyb3IoJ1ByZW1hdHVyZSBjbG9zZScpLCB7XG5cdFx0XHRcdFx0XHRcdGNvZGU6ICdFUlJfU1RSRUFNX1BSRU1BVFVSRV9DTE9TRSdcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0cmVzcG9uc2VfPy5lbWl0KCdlcnJvcicsIGVycik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHJlcXVlc3RfLm9uKCdyZXNwb25zZScsIGluY29taW5nID0+IHtcblx0XHRcdHJlc3BvbnNlXyA9IGluY29taW5nO1xuXHRcdFx0cmVxdWVzdF8uc2V0VGltZW91dCgwKTtcblx0XHRcdGNvbnN0IGhlYWRlcnMgPSBmcm9tUmF3SGVhZGVycyhyZXNwb25zZV8ucmF3SGVhZGVycyk7XG5cblx0XHRcdC8vIEhUVFAgZmV0Y2ggc3RlcCA1XG5cdFx0XHRpZiAoaXNSZWRpcmVjdChOdW1iZXIocmVzcG9uc2VfLnN0YXR1c0NvZGUpKSkge1xuXHRcdFx0XHQvLyBIVFRQIGZldGNoIHN0ZXAgNS4yXG5cdFx0XHRcdGNvbnN0IGxvY2F0aW9uID0gaGVhZGVycy5nZXQoJ0xvY2F0aW9uJyk7XG5cblx0XHRcdFx0Ly8gSFRUUCBmZXRjaCBzdGVwIDUuM1xuXHRcdFx0XHRjb25zdCBsb2NhdGlvblVSTCA9IGxvY2F0aW9uID09PSBudWxsID8gbnVsbCA6IG5ldyBVUkwobG9jYXRpb24sIHJlcXVlc3QudXJsKTtcblxuXHRcdFx0XHQvLyBIVFRQIGZldGNoIHN0ZXAgNS41XG5cdFx0XHRcdHN3aXRjaCAocmVxdWVzdC5yZWRpcmVjdCkge1xuXHRcdFx0XHRcdGNhc2UgJ2Vycm9yJzpcblx0XHRcdFx0XHRcdHJlamVjdChuZXcgRmV0Y2hFcnJvcihgdXJpIHJlcXVlc3RlZCByZXNwb25kcyB3aXRoIGEgcmVkaXJlY3QsIHJlZGlyZWN0IG1vZGUgaXMgc2V0IHRvIGVycm9yOiAke3JlcXVlc3QudXJsfWAsICduby1yZWRpcmVjdCcpKTtcblx0XHRcdFx0XHRcdGZpbmFsaXplKCk7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0Y2FzZSAnbWFudWFsJzpcblx0XHRcdFx0XHRcdC8vIE5vZGUtZmV0Y2gtc3BlY2lmaWMgc3RlcDogbWFrZSBtYW51YWwgcmVkaXJlY3QgYSBiaXQgZWFzaWVyIHRvIHVzZSBieSBzZXR0aW5nIHRoZSBMb2NhdGlvbiBoZWFkZXIgdmFsdWUgdG8gdGhlIHJlc29sdmVkIFVSTC5cblx0XHRcdFx0XHRcdGlmIChsb2NhdGlvblVSTCAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0XHRoZWFkZXJzLnNldCgnTG9jYXRpb24nLCBsb2NhdGlvblVSTC50b1N0cmluZygpKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAnZm9sbG93Jzoge1xuXHRcdFx0XHRcdFx0Ly8gSFRUUC1yZWRpcmVjdCBmZXRjaCBzdGVwIDJcblx0XHRcdFx0XHRcdGlmIChsb2NhdGlvblVSTCA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gSFRUUC1yZWRpcmVjdCBmZXRjaCBzdGVwIDVcblx0XHRcdFx0XHRcdGlmIChyZXF1ZXN0LmNvdW50ZXIgPj0gcmVxdWVzdC5mb2xsb3cpIHtcblx0XHRcdFx0XHRcdFx0cmVqZWN0KG5ldyBGZXRjaEVycm9yKGBtYXhpbXVtIHJlZGlyZWN0IHJlYWNoZWQgYXQ6ICR7cmVxdWVzdC51cmx9YCwgJ21heC1yZWRpcmVjdCcpKTtcblx0XHRcdFx0XHRcdFx0ZmluYWxpemUoKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBIVFRQLXJlZGlyZWN0IGZldGNoIHN0ZXAgNiAoY291bnRlciBpbmNyZW1lbnQpXG5cdFx0XHRcdFx0XHQvLyBDcmVhdGUgYSBuZXcgUmVxdWVzdCBvYmplY3QuXG5cdFx0XHRcdFx0XHRjb25zdCByZXF1ZXN0T3B0aW9ucyA9IHtcblx0XHRcdFx0XHRcdFx0aGVhZGVyczogbmV3IEhlYWRlcnMocmVxdWVzdC5oZWFkZXJzKSxcblx0XHRcdFx0XHRcdFx0Zm9sbG93OiByZXF1ZXN0LmZvbGxvdyxcblx0XHRcdFx0XHRcdFx0Y291bnRlcjogcmVxdWVzdC5jb3VudGVyICsgMSxcblx0XHRcdFx0XHRcdFx0YWdlbnQ6IHJlcXVlc3QuYWdlbnQsXG5cdFx0XHRcdFx0XHRcdGNvbXByZXNzOiByZXF1ZXN0LmNvbXByZXNzLFxuXHRcdFx0XHRcdFx0XHRtZXRob2Q6IHJlcXVlc3QubWV0aG9kLFxuXHRcdFx0XHRcdFx0XHQvLyBOb3RlOiBXZSBjYW4gbm90IHVzZSBgcmVxdWVzdC5ib2R5YCBiZWNhdXNlIHNlbmQgd291bGQgaGF2ZVxuXHRcdFx0XHRcdFx0XHQvLyBjb25zdW1lZCBpdCBhbHJlYWR5LlxuXHRcdFx0XHRcdFx0XHRib2R5OiBvcHRpb25zXy5ib2R5LFxuXHRcdFx0XHRcdFx0XHRzaWduYWw6IHNpZ25hbCxcblx0XHRcdFx0XHRcdFx0c2l6ZTogcmVxdWVzdC5zaXplXG5cdFx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0XHQvLyBIVFRQLXJlZGlyZWN0IGZldGNoIHN0ZXAgOVxuXHRcdFx0XHRcdFx0Y29uc3QgaXNTdHJlYW1Cb2R5ID1cblx0XHRcdFx0XHRcdFx0cmVxdWVzdE9wdGlvbnMuYm9keSBpbnN0YW5jZW9mIFJlYWRhYmxlU3RyZWFtIHx8XG5cdFx0XHRcdFx0XHRcdHJlcXVlc3RPcHRpb25zLmJvZHkgaW5zdGFuY2VvZiBTdHJlYW0uUmVhZGFibGU7XG5cdFx0XHRcdFx0XHRpZiAocmVzcG9uc2VfLnN0YXR1c0NvZGUgIT09IDMwMyAmJiBpc1N0cmVhbUJvZHkpIHtcblx0XHRcdFx0XHRcdFx0cmVqZWN0KG5ldyBGZXRjaEVycm9yKCdDYW5ub3QgZm9sbG93IHJlZGlyZWN0IHdpdGggYm9keSBiZWluZyBhIHJlYWRhYmxlIHN0cmVhbScsICd1bnN1cHBvcnRlZC1yZWRpcmVjdCcpKTtcblx0XHRcdFx0XHRcdFx0ZmluYWxpemUoKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBIVFRQLXJlZGlyZWN0IGZldGNoIHN0ZXAgMTFcblx0XHRcdFx0XHRcdGlmIChyZXNwb25zZV8uc3RhdHVzQ29kZSA9PT0gMzAzIHx8ICgocmVzcG9uc2VfLnN0YXR1c0NvZGUgPT09IDMwMSB8fCByZXNwb25zZV8uc3RhdHVzQ29kZSA9PT0gMzAyKSAmJiByZXF1ZXN0Lm1ldGhvZCA9PT0gJ1BPU1QnKSkge1xuXHRcdFx0XHRcdFx0XHRyZXF1ZXN0T3B0aW9ucy5tZXRob2QgPSAnR0VUJztcblx0XHRcdFx0XHRcdFx0cmVxdWVzdE9wdGlvbnMuYm9keSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdFx0cmVxdWVzdE9wdGlvbnMuaGVhZGVycy5kZWxldGUoJ2NvbnRlbnQtbGVuZ3RoJyk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIEhUVFAtcmVkaXJlY3QgZmV0Y2ggc3RlcCAxNVxuXHRcdFx0XHRcdFx0ZmV0Y2gobmV3IFJlcXVlc3QobG9jYXRpb25VUkwuaHJlZiwgcmVxdWVzdE9wdGlvbnMpKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG5cdFx0XHRcdFx0XHRmaW5hbGl6ZSgpO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVqZWN0KG5ldyBUeXBlRXJyb3IoYFJlZGlyZWN0IG9wdGlvbiAnJHtyZXF1ZXN0LnJlZGlyZWN0fScgaXMgbm90IGEgdmFsaWQgdmFsdWUgb2YgUmVxdWVzdFJlZGlyZWN0YCkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFByZXBhcmUgcmVzcG9uc2Vcblx0XHRcdGlmIChzaWduYWwpIHtcblx0XHRcdFx0cmVzcG9uc2VfLm9uY2UoJ2VuZCcsICgpID0+IHtcblx0XHRcdFx0XHRzaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydEFuZEZpbmFsaXplKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdGxldCBib2R5ID0gcHVtcChyZXNwb25zZV8sIG5ldyBQYXNzVGhyb3VnaCgpLCByZWplY3QpO1xuXHRcdFx0Ly8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9wdWxsLzI5Mzc2XG5cdFx0XHQvKiBjOCBpZ25vcmUgbmV4dCAzICovXG5cdFx0XHRpZiAocHJvY2Vzcy52ZXJzaW9uIDwgJ3YxMi4xMCcpIHtcblx0XHRcdFx0cmVzcG9uc2VfLm9uKCdhYm9ydGVkJywgYWJvcnRBbmRGaW5hbGl6ZSk7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHJlc3BvbnNlT3B0aW9ucyA9IHtcblx0XHRcdFx0dXJsOiByZXF1ZXN0LnVybCxcblx0XHRcdFx0c3RhdHVzOiByZXNwb25zZV8uc3RhdHVzQ29kZSxcblx0XHRcdFx0c3RhdHVzVGV4dDogcmVzcG9uc2VfLnN0YXR1c01lc3NhZ2UsXG5cdFx0XHRcdGhlYWRlcnMsXG5cdFx0XHRcdHNpemU6IHJlcXVlc3Quc2l6ZSxcblx0XHRcdFx0Y291bnRlcjogcmVxdWVzdC5jb3VudGVyLFxuXHRcdFx0XHRoaWdoV2F0ZXJNYXJrOiByZXF1ZXN0LmhpZ2hXYXRlck1hcmtcblx0XHRcdH07XG5cblx0XHRcdC8vIEhUVFAtbmV0d29yayBmZXRjaCBzdGVwIDEyLjEuMS4zXG5cdFx0XHRjb25zdCBjb2RpbmdzID0gaGVhZGVycy5nZXQoJ0NvbnRlbnQtRW5jb2RpbmcnKTtcblxuXHRcdFx0Ly8gSFRUUC1uZXR3b3JrIGZldGNoIHN0ZXAgMTIuMS4xLjQ6IGhhbmRsZSBjb250ZW50IGNvZGluZ3NcblxuXHRcdFx0Ly8gaW4gZm9sbG93aW5nIHNjZW5hcmlvcyB3ZSBpZ25vcmUgY29tcHJlc3Npb24gc3VwcG9ydFxuXHRcdFx0Ly8gMS4gY29tcHJlc3Npb24gc3VwcG9ydCBpcyBkaXNhYmxlZFxuXHRcdFx0Ly8gMi4gSEVBRCByZXF1ZXN0XG5cdFx0XHQvLyAzLiBubyBDb250ZW50LUVuY29kaW5nIGhlYWRlclxuXHRcdFx0Ly8gNC4gbm8gY29udGVudCByZXNwb25zZSAoMjA0KVxuXHRcdFx0Ly8gNS4gY29udGVudCBub3QgbW9kaWZpZWQgcmVzcG9uc2UgKDMwNClcblx0XHRcdGlmICghcmVxdWVzdC5jb21wcmVzcyB8fCByZXF1ZXN0Lm1ldGhvZCA9PT0gJ0hFQUQnIHx8IGNvZGluZ3MgPT09IG51bGwgfHwgcmVzcG9uc2VfLnN0YXR1c0NvZGUgPT09IDIwNCB8fCByZXNwb25zZV8uc3RhdHVzQ29kZSA9PT0gMzA0KSB7XG5cdFx0XHRcdHJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKGJvZHksIHJlc3BvbnNlT3B0aW9ucyk7XG5cdFx0XHRcdHJlc29sdmUocmVzcG9uc2UpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZvciBOb2RlIHY2K1xuXHRcdFx0Ly8gQmUgbGVzcyBzdHJpY3Qgd2hlbiBkZWNvZGluZyBjb21wcmVzc2VkIHJlc3BvbnNlcywgc2luY2Ugc29tZXRpbWVzXG5cdFx0XHQvLyBzZXJ2ZXJzIHNlbmQgc2xpZ2h0bHkgaW52YWxpZCByZXNwb25zZXMgdGhhdCBhcmUgc3RpbGwgYWNjZXB0ZWRcblx0XHRcdC8vIGJ5IGNvbW1vbiBicm93c2Vycy5cblx0XHRcdC8vIEFsd2F5cyB1c2luZyBaX1NZTkNfRkxVU0ggaXMgd2hhdCBjVVJMIGRvZXMuXG5cdFx0XHRjb25zdCB6bGliT3B0aW9ucyA9IHtcblx0XHRcdFx0Zmx1c2g6IHpsaWIuWl9TWU5DX0ZMVVNILFxuXHRcdFx0XHRmaW5pc2hGbHVzaDogemxpYi5aX1NZTkNfRkxVU0hcblx0XHRcdH07XG5cblx0XHRcdC8vIEZvciBnemlwXG5cdFx0XHRpZiAoY29kaW5ncyA9PT0gJ2d6aXAnIHx8IGNvZGluZ3MgPT09ICd4LWd6aXAnKSB7XG5cdFx0XHRcdGJvZHkgPSBwdW1wKGJvZHksIHpsaWIuY3JlYXRlR3VuemlwKHpsaWJPcHRpb25zKSwgcmVqZWN0KTtcblx0XHRcdFx0cmVzcG9uc2UgPSBuZXcgUmVzcG9uc2UoZnJvbUFzeW5jSXRlcmFibGUoYm9keSksIHJlc3BvbnNlT3B0aW9ucyk7XG5cdFx0XHRcdHJlc29sdmUocmVzcG9uc2UpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZvciBkZWZsYXRlXG5cdFx0XHRpZiAoY29kaW5ncyA9PT0gJ2RlZmxhdGUnIHx8IGNvZGluZ3MgPT09ICd4LWRlZmxhdGUnKSB7XG5cdFx0XHRcdC8vIEhhbmRsZSB0aGUgaW5mYW1vdXMgcmF3IGRlZmxhdGUgcmVzcG9uc2UgZnJvbSBvbGQgc2VydmVyc1xuXHRcdFx0XHQvLyBhIGhhY2sgZm9yIG9sZCBJSVMgYW5kIEFwYWNoZSBzZXJ2ZXJzXG5cdFx0XHRcdGNvbnN0IHJhdyA9IHB1bXAocmVzcG9uc2VfLCBuZXcgUGFzc1Rocm91Z2goKSwgcmVqZWN0KTtcblx0XHRcdFx0cmF3Lm9uY2UoJ2RhdGEnLCBjaHVuayA9PiB7XG5cdFx0XHRcdFx0Ly8gU2VlIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzc1MTk4Mjhcblx0XHRcdFx0XHRpZiAoKGNodW5rWzBdICYgMHgwRikgPT09IDB4MDgpIHtcblx0XHRcdFx0XHRcdGJvZHkgPSBwdW1wKGJvZHksIHpsaWIuY3JlYXRlSW5mbGF0ZSgpLCByZWplY3QpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRib2R5ID0gcHVtcChib2R5LCB6bGliLmNyZWF0ZUluZmxhdGVSYXcoKSwgcmVqZWN0KTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXNwb25zZSA9IG5ldyBSZXNwb25zZShmcm9tQXN5bmNJdGVyYWJsZShib2R5KSwgcmVzcG9uc2VPcHRpb25zKTtcblx0XHRcdFx0XHRyZXNvbHZlKHJlc3BvbnNlKTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRm9yIGJyXG5cdFx0XHRpZiAoY29kaW5ncyA9PT0gJ2JyJykge1xuXHRcdFx0XHRib2R5ID0gcHVtcChib2R5LCB6bGliLmNyZWF0ZUJyb3RsaURlY29tcHJlc3MoKSwgcmVqZWN0KTtcblx0XHRcdFx0cmVzcG9uc2UgPSBuZXcgUmVzcG9uc2UoZnJvbUFzeW5jSXRlcmFibGUoYm9keSksIHJlc3BvbnNlT3B0aW9ucyk7XG5cdFx0XHRcdHJlc29sdmUocmVzcG9uc2UpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIE90aGVyd2lzZSwgdXNlIHJlc3BvbnNlIGFzLWlzXG5cdFx0XHRyZXNwb25zZSA9IG5ldyBSZXNwb25zZShmcm9tQXN5bmNJdGVyYWJsZShib2R5KSwgcmVzcG9uc2VPcHRpb25zKTtcblx0XHRcdHJlc29sdmUocmVzcG9uc2UpO1xuXHRcdH0pO1xuXG5cdFx0d3JpdGVUb1N0cmVhbShyZXF1ZXN0XywgcmVxdWVzdCk7XG5cdH0pO1xufVxuXG4vKipcbiAqXG4gKiBAcGFyYW0ge2ltcG9ydCgnaHR0cCcpLkNsaWVudFJlcXVlc3R9IHJlcXVlc3RcbiAqIEBwYXJhbSB7KGVycm9yOkVycm9yKSA9PiB2b2lkfSBlcnJvckNhbGxiYWNrXG4gKi9cbmZ1bmN0aW9uIGZpeFJlc3BvbnNlQ2h1bmtlZFRyYW5zZmVyQmFkRW5kaW5nKHJlcXVlc3QsIGVycm9yQ2FsbGJhY2spIHtcblx0Y29uc3QgTEFTVF9DSFVOSyA9IEJ1ZmZlci5mcm9tKCcwXFxyXFxuXFxyXFxuJyk7XG5cblx0bGV0IGlzQ2h1bmtlZFRyYW5zZmVyID0gZmFsc2U7XG5cdGxldCBwcm9wZXJMYXN0Q2h1bmtSZWNlaXZlZCA9IGZhbHNlO1xuXHQvKiogQHR5cGUge0J1ZmZlciB8IHVuZGVmaW5lZH0gKi9cblx0bGV0IHByZXZpb3VzQ2h1bms7XG5cblx0cmVxdWVzdC5vbigncmVzcG9uc2UnLCByZXNwb25zZSA9PiB7XG5cdFx0Y29uc3Qge2hlYWRlcnN9ID0gcmVzcG9uc2U7XG5cdFx0aXNDaHVua2VkVHJhbnNmZXIgPSBoZWFkZXJzWyd0cmFuc2Zlci1lbmNvZGluZyddID09PSAnY2h1bmtlZCcgJiYgIWhlYWRlcnNbJ2NvbnRlbnQtbGVuZ3RoJ107XG5cdH0pO1xuXG5cdHJlcXVlc3Qub24oJ3NvY2tldCcsIHNvY2tldCA9PiB7XG5cdFx0Y29uc3Qgb25Tb2NrZXRDbG9zZSA9ICgpID0+IHtcblx0XHRcdGlmIChpc0NodW5rZWRUcmFuc2ZlciAmJiAhcHJvcGVyTGFzdENodW5rUmVjZWl2ZWQpIHtcblx0XHRcdFx0Y29uc3QgZXJyb3IgPSBPYmplY3QuYXNzaWduKG5ldyBFcnJvcignUHJlbWF0dXJlIGNsb3NlJyksIHtcblx0XHRcdFx0XHRjb2RlOiAnRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0UnXG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRlcnJvckNhbGxiYWNrKGVycm9yKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0LyoqIEBwYXJhbSB7QnVmZmVyfSBidWYgKi9cblx0XHRjb25zdCBvbkRhdGEgPSBidWYgPT4ge1xuXHRcdFx0cHJvcGVyTGFzdENodW5rUmVjZWl2ZWQgPSBCdWZmZXIuY29tcGFyZShidWYuc2xpY2UoLTUpLCBMQVNUX0NIVU5LKSA9PT0gMDtcblxuXHRcdFx0Ly8gU29tZXRpbWVzIGZpbmFsIDAtbGVuZ3RoIGNodW5rIGFuZCBlbmQgb2YgbWVzc2FnZSBjb2RlIGFyZSBpbiBzZXBhcmF0ZSBwYWNrZXRzXG5cdFx0XHRpZiAoIXByb3Blckxhc3RDaHVua1JlY2VpdmVkICYmIHByZXZpb3VzQ2h1bmspIHtcblx0XHRcdFx0cHJvcGVyTGFzdENodW5rUmVjZWl2ZWQgPSAoXG5cdFx0XHRcdFx0QnVmZmVyLmNvbXBhcmUocHJldmlvdXNDaHVuay5zbGljZSgtMyksIExBU1RfQ0hVTksuc2xpY2UoMCwgMykpID09PSAwICYmXG5cdFx0XHRcdFx0QnVmZmVyLmNvbXBhcmUoYnVmLnNsaWNlKC0yKSwgTEFTVF9DSFVOSy5zbGljZSgzKSkgPT09IDBcblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0cHJldmlvdXNDaHVuayA9IGJ1Zjtcblx0XHR9O1xuXG5cdFx0c29ja2V0LnByZXBlbmRMaXN0ZW5lcignY2xvc2UnLCBvblNvY2tldENsb3NlKTtcblx0XHRzb2NrZXQub24oJ2RhdGEnLCBvbkRhdGEpO1xuXG5cdFx0Y29uc3QgcmVtb3ZlU29ja2V0TGlzdGVuZXJzID0gKCkgPT4ge1xuXHRcdFx0c29ja2V0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uU29ja2V0Q2xvc2UpO1xuXHRcdFx0c29ja2V0LnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25EYXRhKTtcblx0XHR9XG5cblx0XHRyZXF1ZXN0Lm9uKCdjbG9zZScsIHJlbW92ZVNvY2tldExpc3RlbmVycyk7XG5cdFx0cmVxdWVzdC5vbignYWJvcnQnLCByZW1vdmVTb2NrZXRMaXN0ZW5lcnMpO1xuXHR9KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZmV0Y2hcbmV4cG9ydCB7IGZldGNoIH1cbiIsICJleHBvcnQgY29uc3QgbWltZXMgPSB7XG4gIFwiZXpcIjogXCJhcHBsaWNhdGlvbi9hbmRyZXctaW5zZXRcIixcbiAgXCJhd1wiOiBcImFwcGxpY2F0aW9uL2FwcGxpeHdhcmVcIixcbiAgXCJhdG9tXCI6IFwiYXBwbGljYXRpb24vYXRvbSt4bWxcIixcbiAgXCJhdG9tY2F0XCI6IFwiYXBwbGljYXRpb24vYXRvbWNhdCt4bWxcIixcbiAgXCJhdG9tZGVsZXRlZFwiOiBcImFwcGxpY2F0aW9uL2F0b21kZWxldGVkK3htbFwiLFxuICBcImF0b21zdmNcIjogXCJhcHBsaWNhdGlvbi9hdG9tc3ZjK3htbFwiLFxuICBcImR3ZFwiOiBcImFwcGxpY2F0aW9uL2F0c2MtZHdkK3htbFwiLFxuICBcImhlbGRcIjogXCJhcHBsaWNhdGlvbi9hdHNjLWhlbGQreG1sXCIsXG4gIFwicnNhdFwiOiBcImFwcGxpY2F0aW9uL2F0c2MtcnNhdCt4bWxcIixcbiAgXCJiZG9jXCI6IFwiYXBwbGljYXRpb24vYmRvY1wiLFxuICBcInhjc1wiOiBcImFwcGxpY2F0aW9uL2NhbGVuZGFyK3htbFwiLFxuICBcImNjeG1sXCI6IFwiYXBwbGljYXRpb24vY2N4bWwreG1sXCIsXG4gIFwiY2RmeFwiOiBcImFwcGxpY2F0aW9uL2NkZngreG1sXCIsXG4gIFwiY2RtaWFcIjogXCJhcHBsaWNhdGlvbi9jZG1pLWNhcGFiaWxpdHlcIixcbiAgXCJjZG1pY1wiOiBcImFwcGxpY2F0aW9uL2NkbWktY29udGFpbmVyXCIsXG4gIFwiY2RtaWRcIjogXCJhcHBsaWNhdGlvbi9jZG1pLWRvbWFpblwiLFxuICBcImNkbWlvXCI6IFwiYXBwbGljYXRpb24vY2RtaS1vYmplY3RcIixcbiAgXCJjZG1pcVwiOiBcImFwcGxpY2F0aW9uL2NkbWktcXVldWVcIixcbiAgXCJjdVwiOiBcImFwcGxpY2F0aW9uL2N1LXNlZW1lXCIsXG4gIFwibXBkXCI6IFwiYXBwbGljYXRpb24vZGFzaCt4bWxcIixcbiAgXCJkYXZtb3VudFwiOiBcImFwcGxpY2F0aW9uL2Rhdm1vdW50K3htbFwiLFxuICBcImRia1wiOiBcImFwcGxpY2F0aW9uL2RvY2Jvb2sreG1sXCIsXG4gIFwiZHNzY1wiOiBcImFwcGxpY2F0aW9uL2Rzc2MrZGVyXCIsXG4gIFwieGRzc2NcIjogXCJhcHBsaWNhdGlvbi9kc3NjK3htbFwiLFxuICBcImVzXCI6IFwiYXBwbGljYXRpb24vZWNtYXNjcmlwdFwiLFxuICBcImVjbWFcIjogXCJhcHBsaWNhdGlvbi9lY21hc2NyaXB0XCIsXG4gIFwiZW1tYVwiOiBcImFwcGxpY2F0aW9uL2VtbWEreG1sXCIsXG4gIFwiZW1vdGlvbm1sXCI6IFwiYXBwbGljYXRpb24vZW1vdGlvbm1sK3htbFwiLFxuICBcImVwdWJcIjogXCJhcHBsaWNhdGlvbi9lcHViK3ppcFwiLFxuICBcImV4aVwiOiBcImFwcGxpY2F0aW9uL2V4aVwiLFxuICBcImZkdFwiOiBcImFwcGxpY2F0aW9uL2ZkdCt4bWxcIixcbiAgXCJwZnJcIjogXCJhcHBsaWNhdGlvbi9mb250LXRkcGZyXCIsXG4gIFwiZ2VvanNvblwiOiBcImFwcGxpY2F0aW9uL2dlbytqc29uXCIsXG4gIFwiZ21sXCI6IFwiYXBwbGljYXRpb24vZ21sK3htbFwiLFxuICBcImdweFwiOiBcImFwcGxpY2F0aW9uL2dweCt4bWxcIixcbiAgXCJneGZcIjogXCJhcHBsaWNhdGlvbi9neGZcIixcbiAgXCJnelwiOiBcImFwcGxpY2F0aW9uL2d6aXBcIixcbiAgXCJoanNvblwiOiBcImFwcGxpY2F0aW9uL2hqc29uXCIsXG4gIFwic3RrXCI6IFwiYXBwbGljYXRpb24vaHlwZXJzdHVkaW9cIixcbiAgXCJpbmtcIjogXCJhcHBsaWNhdGlvbi9pbmttbCt4bWxcIixcbiAgXCJpbmttbFwiOiBcImFwcGxpY2F0aW9uL2lua21sK3htbFwiLFxuICBcImlwZml4XCI6IFwiYXBwbGljYXRpb24vaXBmaXhcIixcbiAgXCJpdHNcIjogXCJhcHBsaWNhdGlvbi9pdHMreG1sXCIsXG4gIFwiamFyXCI6IFwiYXBwbGljYXRpb24vamF2YS1hcmNoaXZlXCIsXG4gIFwid2FyXCI6IFwiYXBwbGljYXRpb24vamF2YS1hcmNoaXZlXCIsXG4gIFwiZWFyXCI6IFwiYXBwbGljYXRpb24vamF2YS1hcmNoaXZlXCIsXG4gIFwic2VyXCI6IFwiYXBwbGljYXRpb24vamF2YS1zZXJpYWxpemVkLW9iamVjdFwiLFxuICBcImNsYXNzXCI6IFwiYXBwbGljYXRpb24vamF2YS12bVwiLFxuICBcImpzXCI6IFwiYXBwbGljYXRpb24vamF2YXNjcmlwdFwiLFxuICBcIm1qc1wiOiBcImFwcGxpY2F0aW9uL2phdmFzY3JpcHRcIixcbiAgXCJqc29uXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICBcIm1hcFwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgXCJqc29uNVwiOiBcImFwcGxpY2F0aW9uL2pzb241XCIsXG4gIFwianNvbm1sXCI6IFwiYXBwbGljYXRpb24vanNvbm1sK2pzb25cIixcbiAgXCJqc29ubGRcIjogXCJhcHBsaWNhdGlvbi9sZCtqc29uXCIsXG4gIFwibGdyXCI6IFwiYXBwbGljYXRpb24vbGdyK3htbFwiLFxuICBcImxvc3R4bWxcIjogXCJhcHBsaWNhdGlvbi9sb3N0K3htbFwiLFxuICBcImhxeFwiOiBcImFwcGxpY2F0aW9uL21hYy1iaW5oZXg0MFwiLFxuICBcImNwdFwiOiBcImFwcGxpY2F0aW9uL21hYy1jb21wYWN0cHJvXCIsXG4gIFwibWFkc1wiOiBcImFwcGxpY2F0aW9uL21hZHMreG1sXCIsXG4gIFwid2VibWFuaWZlc3RcIjogXCJhcHBsaWNhdGlvbi9tYW5pZmVzdCtqc29uXCIsXG4gIFwibXJjXCI6IFwiYXBwbGljYXRpb24vbWFyY1wiLFxuICBcIm1yY3hcIjogXCJhcHBsaWNhdGlvbi9tYXJjeG1sK3htbFwiLFxuICBcIm1hXCI6IFwiYXBwbGljYXRpb24vbWF0aGVtYXRpY2FcIixcbiAgXCJuYlwiOiBcImFwcGxpY2F0aW9uL21hdGhlbWF0aWNhXCIsXG4gIFwibWJcIjogXCJhcHBsaWNhdGlvbi9tYXRoZW1hdGljYVwiLFxuICBcIm1hdGhtbFwiOiBcImFwcGxpY2F0aW9uL21hdGhtbCt4bWxcIixcbiAgXCJtYm94XCI6IFwiYXBwbGljYXRpb24vbWJveFwiLFxuICBcIm1zY21sXCI6IFwiYXBwbGljYXRpb24vbWVkaWFzZXJ2ZXJjb250cm9sK3htbFwiLFxuICBcIm1ldGFsaW5rXCI6IFwiYXBwbGljYXRpb24vbWV0YWxpbmsreG1sXCIsXG4gIFwibWV0YTRcIjogXCJhcHBsaWNhdGlvbi9tZXRhbGluazQreG1sXCIsXG4gIFwibWV0c1wiOiBcImFwcGxpY2F0aW9uL21ldHMreG1sXCIsXG4gIFwibWFlaVwiOiBcImFwcGxpY2F0aW9uL21tdC1hZWkreG1sXCIsXG4gIFwibXVzZFwiOiBcImFwcGxpY2F0aW9uL21tdC11c2QreG1sXCIsXG4gIFwibW9kc1wiOiBcImFwcGxpY2F0aW9uL21vZHMreG1sXCIsXG4gIFwibTIxXCI6IFwiYXBwbGljYXRpb24vbXAyMVwiLFxuICBcIm1wMjFcIjogXCJhcHBsaWNhdGlvbi9tcDIxXCIsXG4gIFwibXA0c1wiOiBcImFwcGxpY2F0aW9uL21wNFwiLFxuICBcIm00cFwiOiBcImFwcGxpY2F0aW9uL21wNFwiLFxuICBcImRvY1wiOiBcImFwcGxpY2F0aW9uL21zd29yZFwiLFxuICBcImRvdFwiOiBcImFwcGxpY2F0aW9uL21zd29yZFwiLFxuICBcIm14ZlwiOiBcImFwcGxpY2F0aW9uL214ZlwiLFxuICBcIm5xXCI6IFwiYXBwbGljYXRpb24vbi1xdWFkc1wiLFxuICBcIm50XCI6IFwiYXBwbGljYXRpb24vbi10cmlwbGVzXCIsXG4gIFwiY2pzXCI6IFwiYXBwbGljYXRpb24vbm9kZVwiLFxuICBcImJpblwiOiBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiLFxuICBcImRtc1wiOiBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiLFxuICBcImxyZlwiOiBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiLFxuICBcIm1hclwiOiBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiLFxuICBcInNvXCI6IFwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCIsXG4gIFwiZGlzdFwiOiBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiLFxuICBcImRpc3R6XCI6IFwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCIsXG4gIFwicGtnXCI6IFwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCIsXG4gIFwiYnBrXCI6IFwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCIsXG4gIFwiZHVtcFwiOiBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiLFxuICBcImVsY1wiOiBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiLFxuICBcImRlcGxveVwiOiBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiLFxuICBcImV4ZVwiOiBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiLFxuICBcImRsbFwiOiBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiLFxuICBcImRlYlwiOiBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiLFxuICBcImRtZ1wiOiBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiLFxuICBcImlzb1wiOiBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiLFxuICBcImltZ1wiOiBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiLFxuICBcIm1zaVwiOiBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiLFxuICBcIm1zcFwiOiBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiLFxuICBcIm1zbVwiOiBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiLFxuICBcImJ1ZmZlclwiOiBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiLFxuICBcIm9kYVwiOiBcImFwcGxpY2F0aW9uL29kYVwiLFxuICBcIm9wZlwiOiBcImFwcGxpY2F0aW9uL29lYnBzLXBhY2thZ2UreG1sXCIsXG4gIFwib2d4XCI6IFwiYXBwbGljYXRpb24vb2dnXCIsXG4gIFwib21kb2NcIjogXCJhcHBsaWNhdGlvbi9vbWRvYyt4bWxcIixcbiAgXCJvbmV0b2NcIjogXCJhcHBsaWNhdGlvbi9vbmVub3RlXCIsXG4gIFwib25ldG9jMlwiOiBcImFwcGxpY2F0aW9uL29uZW5vdGVcIixcbiAgXCJvbmV0bXBcIjogXCJhcHBsaWNhdGlvbi9vbmVub3RlXCIsXG4gIFwib25lcGtnXCI6IFwiYXBwbGljYXRpb24vb25lbm90ZVwiLFxuICBcIm94cHNcIjogXCJhcHBsaWNhdGlvbi9veHBzXCIsXG4gIFwicmVsb1wiOiBcImFwcGxpY2F0aW9uL3AycC1vdmVybGF5K3htbFwiLFxuICBcInhlclwiOiBcImFwcGxpY2F0aW9uL3BhdGNoLW9wcy1lcnJvcit4bWxcIixcbiAgXCJwZGZcIjogXCJhcHBsaWNhdGlvbi9wZGZcIixcbiAgXCJwZ3BcIjogXCJhcHBsaWNhdGlvbi9wZ3AtZW5jcnlwdGVkXCIsXG4gIFwiYXNjXCI6IFwiYXBwbGljYXRpb24vcGdwLXNpZ25hdHVyZVwiLFxuICBcInNpZ1wiOiBcImFwcGxpY2F0aW9uL3BncC1zaWduYXR1cmVcIixcbiAgXCJwcmZcIjogXCJhcHBsaWNhdGlvbi9waWNzLXJ1bGVzXCIsXG4gIFwicDEwXCI6IFwiYXBwbGljYXRpb24vcGtjczEwXCIsXG4gIFwicDdtXCI6IFwiYXBwbGljYXRpb24vcGtjczctbWltZVwiLFxuICBcInA3Y1wiOiBcImFwcGxpY2F0aW9uL3BrY3M3LW1pbWVcIixcbiAgXCJwN3NcIjogXCJhcHBsaWNhdGlvbi9wa2NzNy1zaWduYXR1cmVcIixcbiAgXCJwOFwiOiBcImFwcGxpY2F0aW9uL3BrY3M4XCIsXG4gIFwiYWNcIjogXCJhcHBsaWNhdGlvbi9wa2l4LWF0dHItY2VydFwiLFxuICBcImNlclwiOiBcImFwcGxpY2F0aW9uL3BraXgtY2VydFwiLFxuICBcImNybFwiOiBcImFwcGxpY2F0aW9uL3BraXgtY3JsXCIsXG4gIFwicGtpcGF0aFwiOiBcImFwcGxpY2F0aW9uL3BraXgtcGtpcGF0aFwiLFxuICBcInBraVwiOiBcImFwcGxpY2F0aW9uL3BraXhjbXBcIixcbiAgXCJwbHNcIjogXCJhcHBsaWNhdGlvbi9wbHMreG1sXCIsXG4gIFwiYWlcIjogXCJhcHBsaWNhdGlvbi9wb3N0c2NyaXB0XCIsXG4gIFwiZXBzXCI6IFwiYXBwbGljYXRpb24vcG9zdHNjcmlwdFwiLFxuICBcInBzXCI6IFwiYXBwbGljYXRpb24vcG9zdHNjcmlwdFwiLFxuICBcInByb3Z4XCI6IFwiYXBwbGljYXRpb24vcHJvdmVuYW5jZSt4bWxcIixcbiAgXCJjd3dcIjogXCJhcHBsaWNhdGlvbi9wcnMuY3d3XCIsXG4gIFwicHNrY3htbFwiOiBcImFwcGxpY2F0aW9uL3Bza2MreG1sXCIsXG4gIFwicmFtbFwiOiBcImFwcGxpY2F0aW9uL3JhbWwreWFtbFwiLFxuICBcInJkZlwiOiBcImFwcGxpY2F0aW9uL3JkZit4bWxcIixcbiAgXCJvd2xcIjogXCJhcHBsaWNhdGlvbi9yZGYreG1sXCIsXG4gIFwicmlmXCI6IFwiYXBwbGljYXRpb24vcmVnaW5mbyt4bWxcIixcbiAgXCJybmNcIjogXCJhcHBsaWNhdGlvbi9yZWxheC1uZy1jb21wYWN0LXN5bnRheFwiLFxuICBcInJsXCI6IFwiYXBwbGljYXRpb24vcmVzb3VyY2UtbGlzdHMreG1sXCIsXG4gIFwicmxkXCI6IFwiYXBwbGljYXRpb24vcmVzb3VyY2UtbGlzdHMtZGlmZit4bWxcIixcbiAgXCJyc1wiOiBcImFwcGxpY2F0aW9uL3Jscy1zZXJ2aWNlcyt4bWxcIixcbiAgXCJyYXBkXCI6IFwiYXBwbGljYXRpb24vcm91dGUtYXBkK3htbFwiLFxuICBcInNsc1wiOiBcImFwcGxpY2F0aW9uL3JvdXRlLXMtdHNpZCt4bWxcIixcbiAgXCJydXNkXCI6IFwiYXBwbGljYXRpb24vcm91dGUtdXNkK3htbFwiLFxuICBcImdiclwiOiBcImFwcGxpY2F0aW9uL3Jwa2ktZ2hvc3RidXN0ZXJzXCIsXG4gIFwibWZ0XCI6IFwiYXBwbGljYXRpb24vcnBraS1tYW5pZmVzdFwiLFxuICBcInJvYVwiOiBcImFwcGxpY2F0aW9uL3Jwa2ktcm9hXCIsXG4gIFwicnNkXCI6IFwiYXBwbGljYXRpb24vcnNkK3htbFwiLFxuICBcInJzc1wiOiBcImFwcGxpY2F0aW9uL3Jzcyt4bWxcIixcbiAgXCJydGZcIjogXCJhcHBsaWNhdGlvbi9ydGZcIixcbiAgXCJzYm1sXCI6IFwiYXBwbGljYXRpb24vc2JtbCt4bWxcIixcbiAgXCJzY3FcIjogXCJhcHBsaWNhdGlvbi9zY3ZwLWN2LXJlcXVlc3RcIixcbiAgXCJzY3NcIjogXCJhcHBsaWNhdGlvbi9zY3ZwLWN2LXJlc3BvbnNlXCIsXG4gIFwic3BxXCI6IFwiYXBwbGljYXRpb24vc2N2cC12cC1yZXF1ZXN0XCIsXG4gIFwic3BwXCI6IFwiYXBwbGljYXRpb24vc2N2cC12cC1yZXNwb25zZVwiLFxuICBcInNkcFwiOiBcImFwcGxpY2F0aW9uL3NkcFwiLFxuICBcInNlbm1seFwiOiBcImFwcGxpY2F0aW9uL3Nlbm1sK3htbFwiLFxuICBcInNlbnNtbHhcIjogXCJhcHBsaWNhdGlvbi9zZW5zbWwreG1sXCIsXG4gIFwic2V0cGF5XCI6IFwiYXBwbGljYXRpb24vc2V0LXBheW1lbnQtaW5pdGlhdGlvblwiLFxuICBcInNldHJlZ1wiOiBcImFwcGxpY2F0aW9uL3NldC1yZWdpc3RyYXRpb24taW5pdGlhdGlvblwiLFxuICBcInNoZlwiOiBcImFwcGxpY2F0aW9uL3NoZit4bWxcIixcbiAgXCJzaXZcIjogXCJhcHBsaWNhdGlvbi9zaWV2ZVwiLFxuICBcInNpZXZlXCI6IFwiYXBwbGljYXRpb24vc2lldmVcIixcbiAgXCJzbWlcIjogXCJhcHBsaWNhdGlvbi9zbWlsK3htbFwiLFxuICBcInNtaWxcIjogXCJhcHBsaWNhdGlvbi9zbWlsK3htbFwiLFxuICBcInJxXCI6IFwiYXBwbGljYXRpb24vc3BhcnFsLXF1ZXJ5XCIsXG4gIFwic3J4XCI6IFwiYXBwbGljYXRpb24vc3BhcnFsLXJlc3VsdHMreG1sXCIsXG4gIFwiZ3JhbVwiOiBcImFwcGxpY2F0aW9uL3NyZ3NcIixcbiAgXCJncnhtbFwiOiBcImFwcGxpY2F0aW9uL3NyZ3MreG1sXCIsXG4gIFwic3J1XCI6IFwiYXBwbGljYXRpb24vc3J1K3htbFwiLFxuICBcInNzZGxcIjogXCJhcHBsaWNhdGlvbi9zc2RsK3htbFwiLFxuICBcInNzbWxcIjogXCJhcHBsaWNhdGlvbi9zc21sK3htbFwiLFxuICBcInN3aWR0YWdcIjogXCJhcHBsaWNhdGlvbi9zd2lkK3htbFwiLFxuICBcInRlaVwiOiBcImFwcGxpY2F0aW9uL3RlaSt4bWxcIixcbiAgXCJ0ZWljb3JwdXNcIjogXCJhcHBsaWNhdGlvbi90ZWkreG1sXCIsXG4gIFwidGZpXCI6IFwiYXBwbGljYXRpb24vdGhyYXVkK3htbFwiLFxuICBcInRzZFwiOiBcImFwcGxpY2F0aW9uL3RpbWVzdGFtcGVkLWRhdGFcIixcbiAgXCJ0b21sXCI6IFwiYXBwbGljYXRpb24vdG9tbFwiLFxuICBcInRyaWdcIjogXCJhcHBsaWNhdGlvbi90cmlnXCIsXG4gIFwidHRtbFwiOiBcImFwcGxpY2F0aW9uL3R0bWwreG1sXCIsXG4gIFwidWJqXCI6IFwiYXBwbGljYXRpb24vdWJqc29uXCIsXG4gIFwicnNoZWV0XCI6IFwiYXBwbGljYXRpb24vdXJjLXJlc3NoZWV0K3htbFwiLFxuICBcInRkXCI6IFwiYXBwbGljYXRpb24vdXJjLXRhcmdldGRlc2MreG1sXCIsXG4gIFwidnhtbFwiOiBcImFwcGxpY2F0aW9uL3ZvaWNleG1sK3htbFwiLFxuICBcIndhc21cIjogXCJhcHBsaWNhdGlvbi93YXNtXCIsXG4gIFwid2d0XCI6IFwiYXBwbGljYXRpb24vd2lkZ2V0XCIsXG4gIFwiaGxwXCI6IFwiYXBwbGljYXRpb24vd2luaGxwXCIsXG4gIFwid3NkbFwiOiBcImFwcGxpY2F0aW9uL3dzZGwreG1sXCIsXG4gIFwid3Nwb2xpY3lcIjogXCJhcHBsaWNhdGlvbi93c3BvbGljeSt4bWxcIixcbiAgXCJ4YW1sXCI6IFwiYXBwbGljYXRpb24veGFtbCt4bWxcIixcbiAgXCJ4YXZcIjogXCJhcHBsaWNhdGlvbi94Y2FwLWF0dCt4bWxcIixcbiAgXCJ4Y2FcIjogXCJhcHBsaWNhdGlvbi94Y2FwLWNhcHMreG1sXCIsXG4gIFwieGRmXCI6IFwiYXBwbGljYXRpb24veGNhcC1kaWZmK3htbFwiLFxuICBcInhlbFwiOiBcImFwcGxpY2F0aW9uL3hjYXAtZWwreG1sXCIsXG4gIFwieG5zXCI6IFwiYXBwbGljYXRpb24veGNhcC1ucyt4bWxcIixcbiAgXCJ4ZW5jXCI6IFwiYXBwbGljYXRpb24veGVuYyt4bWxcIixcbiAgXCJ4aHRtbFwiOiBcImFwcGxpY2F0aW9uL3hodG1sK3htbFwiLFxuICBcInhodFwiOiBcImFwcGxpY2F0aW9uL3hodG1sK3htbFwiLFxuICBcInhsZlwiOiBcImFwcGxpY2F0aW9uL3hsaWZmK3htbFwiLFxuICBcInhtbFwiOiBcImFwcGxpY2F0aW9uL3htbFwiLFxuICBcInhzbFwiOiBcImFwcGxpY2F0aW9uL3htbFwiLFxuICBcInhzZFwiOiBcImFwcGxpY2F0aW9uL3htbFwiLFxuICBcInJuZ1wiOiBcImFwcGxpY2F0aW9uL3htbFwiLFxuICBcImR0ZFwiOiBcImFwcGxpY2F0aW9uL3htbC1kdGRcIixcbiAgXCJ4b3BcIjogXCJhcHBsaWNhdGlvbi94b3AreG1sXCIsXG4gIFwieHBsXCI6IFwiYXBwbGljYXRpb24veHByb2MreG1sXCIsXG4gIFwieHNsdFwiOiBcImFwcGxpY2F0aW9uL3htbFwiLFxuICBcInhzcGZcIjogXCJhcHBsaWNhdGlvbi94c3BmK3htbFwiLFxuICBcIm14bWxcIjogXCJhcHBsaWNhdGlvbi94dit4bWxcIixcbiAgXCJ4aHZtbFwiOiBcImFwcGxpY2F0aW9uL3h2K3htbFwiLFxuICBcInh2bWxcIjogXCJhcHBsaWNhdGlvbi94dit4bWxcIixcbiAgXCJ4dm1cIjogXCJhcHBsaWNhdGlvbi94dit4bWxcIixcbiAgXCJ5YW5nXCI6IFwiYXBwbGljYXRpb24veWFuZ1wiLFxuICBcInlpblwiOiBcImFwcGxpY2F0aW9uL3lpbit4bWxcIixcbiAgXCJ6aXBcIjogXCJhcHBsaWNhdGlvbi96aXBcIixcbiAgXCIzZ3BwXCI6IFwidmlkZW8vM2dwcFwiLFxuICBcImFkcFwiOiBcImF1ZGlvL2FkcGNtXCIsXG4gIFwiYW1yXCI6IFwiYXVkaW8vYW1yXCIsXG4gIFwiYXVcIjogXCJhdWRpby9iYXNpY1wiLFxuICBcInNuZFwiOiBcImF1ZGlvL2Jhc2ljXCIsXG4gIFwibWlkXCI6IFwiYXVkaW8vbWlkaVwiLFxuICBcIm1pZGlcIjogXCJhdWRpby9taWRpXCIsXG4gIFwia2FyXCI6IFwiYXVkaW8vbWlkaVwiLFxuICBcInJtaVwiOiBcImF1ZGlvL21pZGlcIixcbiAgXCJteG1mXCI6IFwiYXVkaW8vbW9iaWxlLXhtZlwiLFxuICBcIm1wM1wiOiBcImF1ZGlvL21wZWdcIixcbiAgXCJtNGFcIjogXCJhdWRpby9tcDRcIixcbiAgXCJtcDRhXCI6IFwiYXVkaW8vbXA0XCIsXG4gIFwibXBnYVwiOiBcImF1ZGlvL21wZWdcIixcbiAgXCJtcDJcIjogXCJhdWRpby9tcGVnXCIsXG4gIFwibXAyYVwiOiBcImF1ZGlvL21wZWdcIixcbiAgXCJtMmFcIjogXCJhdWRpby9tcGVnXCIsXG4gIFwibTNhXCI6IFwiYXVkaW8vbXBlZ1wiLFxuICBcIm9nYVwiOiBcImF1ZGlvL29nZ1wiLFxuICBcIm9nZ1wiOiBcImF1ZGlvL29nZ1wiLFxuICBcInNweFwiOiBcImF1ZGlvL29nZ1wiLFxuICBcIm9wdXNcIjogXCJhdWRpby9vZ2dcIixcbiAgXCJzM21cIjogXCJhdWRpby9zM21cIixcbiAgXCJzaWxcIjogXCJhdWRpby9zaWxrXCIsXG4gIFwid2F2XCI6IFwiYXVkaW8vd2F2XCIsXG4gIFwid2ViYVwiOiBcImF1ZGlvL3dlYm1cIixcbiAgXCJ4bVwiOiBcImF1ZGlvL3htXCIsXG4gIFwidHRjXCI6IFwiZm9udC9jb2xsZWN0aW9uXCIsXG4gIFwib3RmXCI6IFwiZm9udC9vdGZcIixcbiAgXCJ0dGZcIjogXCJmb250L3R0ZlwiLFxuICBcIndvZmZcIjogXCJmb250L3dvZmZcIixcbiAgXCJ3b2ZmMlwiOiBcImZvbnQvd29mZjJcIixcbiAgXCJleHJcIjogXCJpbWFnZS9hY2VzXCIsXG4gIFwiYXBuZ1wiOiBcImltYWdlL2FwbmdcIixcbiAgXCJhdmlmXCI6IFwiaW1hZ2UvYXZpZlwiLFxuICBcImJtcFwiOiBcImltYWdlL2JtcFwiLFxuICBcImNnbVwiOiBcImltYWdlL2NnbVwiLFxuICBcImRybGVcIjogXCJpbWFnZS9kaWNvbS1ybGVcIixcbiAgXCJlbWZcIjogXCJpbWFnZS9lbWZcIixcbiAgXCJmaXRzXCI6IFwiaW1hZ2UvZml0c1wiLFxuICBcImczXCI6IFwiaW1hZ2UvZzNmYXhcIixcbiAgXCJnaWZcIjogXCJpbWFnZS9naWZcIixcbiAgXCJoZWljXCI6IFwiaW1hZ2UvaGVpY1wiLFxuICBcImhlaWNzXCI6IFwiaW1hZ2UvaGVpYy1zZXF1ZW5jZVwiLFxuICBcImhlaWZcIjogXCJpbWFnZS9oZWlmXCIsXG4gIFwiaGVpZnNcIjogXCJpbWFnZS9oZWlmLXNlcXVlbmNlXCIsXG4gIFwiaGVqMlwiOiBcImltYWdlL2hlajJrXCIsXG4gIFwiaHNqMlwiOiBcImltYWdlL2hzajJcIixcbiAgXCJpZWZcIjogXCJpbWFnZS9pZWZcIixcbiAgXCJqbHNcIjogXCJpbWFnZS9qbHNcIixcbiAgXCJqcDJcIjogXCJpbWFnZS9qcDJcIixcbiAgXCJqcGcyXCI6IFwiaW1hZ2UvanAyXCIsXG4gIFwianBlZ1wiOiBcImltYWdlL2pwZWdcIixcbiAgXCJqcGdcIjogXCJpbWFnZS9qcGVnXCIsXG4gIFwianBlXCI6IFwiaW1hZ2UvanBlZ1wiLFxuICBcImpwaFwiOiBcImltYWdlL2pwaFwiLFxuICBcImpoY1wiOiBcImltYWdlL2pwaGNcIixcbiAgXCJqcG1cIjogXCJpbWFnZS9qcG1cIixcbiAgXCJqcHhcIjogXCJpbWFnZS9qcHhcIixcbiAgXCJqcGZcIjogXCJpbWFnZS9qcHhcIixcbiAgXCJqeHJcIjogXCJpbWFnZS9qeHJcIixcbiAgXCJqeHJhXCI6IFwiaW1hZ2UvanhyYVwiLFxuICBcImp4cnNcIjogXCJpbWFnZS9qeHJzXCIsXG4gIFwianhzXCI6IFwiaW1hZ2UvanhzXCIsXG4gIFwianhzY1wiOiBcImltYWdlL2p4c2NcIixcbiAgXCJqeHNpXCI6IFwiaW1hZ2UvanhzaVwiLFxuICBcImp4c3NcIjogXCJpbWFnZS9qeHNzXCIsXG4gIFwia3R4XCI6IFwiaW1hZ2Uva3R4XCIsXG4gIFwia3R4MlwiOiBcImltYWdlL2t0eDJcIixcbiAgXCJwbmdcIjogXCJpbWFnZS9wbmdcIixcbiAgXCJidGlmXCI6IFwiaW1hZ2UvcHJzLmJ0aWZcIixcbiAgXCJwdGlcIjogXCJpbWFnZS9wcnMucHRpXCIsXG4gIFwic2dpXCI6IFwiaW1hZ2Uvc2dpXCIsXG4gIFwic3ZnXCI6IFwiaW1hZ2Uvc3ZnK3htbFwiLFxuICBcInN2Z3pcIjogXCJpbWFnZS9zdmcreG1sXCIsXG4gIFwidDM4XCI6IFwiaW1hZ2UvdDM4XCIsXG4gIFwidGlmXCI6IFwiaW1hZ2UvdGlmZlwiLFxuICBcInRpZmZcIjogXCJpbWFnZS90aWZmXCIsXG4gIFwidGZ4XCI6IFwiaW1hZ2UvdGlmZi1meFwiLFxuICBcIndlYnBcIjogXCJpbWFnZS93ZWJwXCIsXG4gIFwid21mXCI6IFwiaW1hZ2Uvd21mXCIsXG4gIFwiZGlzcG9zaXRpb24tbm90aWZpY2F0aW9uXCI6IFwibWVzc2FnZS9kaXNwb3NpdGlvbi1ub3RpZmljYXRpb25cIixcbiAgXCJ1OG1zZ1wiOiBcIm1lc3NhZ2UvZ2xvYmFsXCIsXG4gIFwidThkc25cIjogXCJtZXNzYWdlL2dsb2JhbC1kZWxpdmVyeS1zdGF0dXNcIixcbiAgXCJ1OG1kblwiOiBcIm1lc3NhZ2UvZ2xvYmFsLWRpc3Bvc2l0aW9uLW5vdGlmaWNhdGlvblwiLFxuICBcInU4aGRyXCI6IFwibWVzc2FnZS9nbG9iYWwtaGVhZGVyc1wiLFxuICBcImVtbFwiOiBcIm1lc3NhZ2UvcmZjODIyXCIsXG4gIFwibWltZVwiOiBcIm1lc3NhZ2UvcmZjODIyXCIsXG4gIFwiM21mXCI6IFwibW9kZWwvM21mXCIsXG4gIFwiZ2x0ZlwiOiBcIm1vZGVsL2dsdGYranNvblwiLFxuICBcImdsYlwiOiBcIm1vZGVsL2dsdGYtYmluYXJ5XCIsXG4gIFwiaWdzXCI6IFwibW9kZWwvaWdlc1wiLFxuICBcImlnZXNcIjogXCJtb2RlbC9pZ2VzXCIsXG4gIFwibXNoXCI6IFwibW9kZWwvbWVzaFwiLFxuICBcIm1lc2hcIjogXCJtb2RlbC9tZXNoXCIsXG4gIFwic2lsb1wiOiBcIm1vZGVsL21lc2hcIixcbiAgXCJtdGxcIjogXCJtb2RlbC9tdGxcIixcbiAgXCJvYmpcIjogXCJtb2RlbC9vYmpcIixcbiAgXCJzdHB6XCI6IFwibW9kZWwvc3RlcCt6aXBcIixcbiAgXCJzdHB4elwiOiBcIm1vZGVsL3N0ZXAteG1sK3ppcFwiLFxuICBcInN0bFwiOiBcIm1vZGVsL3N0bFwiLFxuICBcIndybFwiOiBcIm1vZGVsL3ZybWxcIixcbiAgXCJ2cm1sXCI6IFwibW9kZWwvdnJtbFwiLFxuICBcIngzZGJcIjogXCJtb2RlbC94M2QrZmFzdGluZm9zZXRcIixcbiAgXCJ4M2RielwiOiBcIm1vZGVsL3gzZCtiaW5hcnlcIixcbiAgXCJ4M2R2XCI6IFwibW9kZWwveDNkLXZybWxcIixcbiAgXCJ4M2R2elwiOiBcIm1vZGVsL3gzZCt2cm1sXCIsXG4gIFwieDNkXCI6IFwibW9kZWwveDNkK3htbFwiLFxuICBcIngzZHpcIjogXCJtb2RlbC94M2QreG1sXCIsXG4gIFwiYXBwY2FjaGVcIjogXCJ0ZXh0L2NhY2hlLW1hbmlmZXN0XCIsXG4gIFwibWFuaWZlc3RcIjogXCJ0ZXh0L2NhY2hlLW1hbmlmZXN0XCIsXG4gIFwiaWNzXCI6IFwidGV4dC9jYWxlbmRhclwiLFxuICBcImlmYlwiOiBcInRleHQvY2FsZW5kYXJcIixcbiAgXCJjb2ZmZWVcIjogXCJ0ZXh0L2NvZmZlZXNjcmlwdFwiLFxuICBcImxpdGNvZmZlZVwiOiBcInRleHQvY29mZmVlc2NyaXB0XCIsXG4gIFwiY3NzXCI6IFwidGV4dC9jc3NcIixcbiAgXCJjc3ZcIjogXCJ0ZXh0L2NzdlwiLFxuICBcImh0bWxcIjogXCJ0ZXh0L2h0bWxcIixcbiAgXCJodG1cIjogXCJ0ZXh0L2h0bWxcIixcbiAgXCJzaHRtbFwiOiBcInRleHQvaHRtbFwiLFxuICBcImphZGVcIjogXCJ0ZXh0L2phZGVcIixcbiAgXCJqc3hcIjogXCJ0ZXh0L2pzeFwiLFxuICBcImxlc3NcIjogXCJ0ZXh0L2xlc3NcIixcbiAgXCJtYXJrZG93blwiOiBcInRleHQvbWFya2Rvd25cIixcbiAgXCJtZFwiOiBcInRleHQvbWFya2Rvd25cIixcbiAgXCJtbWxcIjogXCJ0ZXh0L21hdGhtbFwiLFxuICBcIm1keFwiOiBcInRleHQvbWR4XCIsXG4gIFwibjNcIjogXCJ0ZXh0L24zXCIsXG4gIFwidHh0XCI6IFwidGV4dC9wbGFpblwiLFxuICBcInRleHRcIjogXCJ0ZXh0L3BsYWluXCIsXG4gIFwiY29uZlwiOiBcInRleHQvcGxhaW5cIixcbiAgXCJkZWZcIjogXCJ0ZXh0L3BsYWluXCIsXG4gIFwibGlzdFwiOiBcInRleHQvcGxhaW5cIixcbiAgXCJsb2dcIjogXCJ0ZXh0L3BsYWluXCIsXG4gIFwiaW5cIjogXCJ0ZXh0L3BsYWluXCIsXG4gIFwiaW5pXCI6IFwidGV4dC9wbGFpblwiLFxuICBcImRzY1wiOiBcInRleHQvcHJzLmxpbmVzLnRhZ1wiLFxuICBcInJ0eFwiOiBcInRleHQvcmljaHRleHRcIixcbiAgXCJzZ21sXCI6IFwidGV4dC9zZ21sXCIsXG4gIFwic2dtXCI6IFwidGV4dC9zZ21sXCIsXG4gIFwic2hleFwiOiBcInRleHQvc2hleFwiLFxuICBcInNsaW1cIjogXCJ0ZXh0L3NsaW1cIixcbiAgXCJzbG1cIjogXCJ0ZXh0L3NsaW1cIixcbiAgXCJzcGR4XCI6IFwidGV4dC9zcGR4XCIsXG4gIFwic3R5bHVzXCI6IFwidGV4dC9zdHlsdXNcIixcbiAgXCJzdHlsXCI6IFwidGV4dC9zdHlsdXNcIixcbiAgXCJ0c3ZcIjogXCJ0ZXh0L3RhYi1zZXBhcmF0ZWQtdmFsdWVzXCIsXG4gIFwidFwiOiBcInRleHQvdHJvZmZcIixcbiAgXCJ0clwiOiBcInRleHQvdHJvZmZcIixcbiAgXCJyb2ZmXCI6IFwidGV4dC90cm9mZlwiLFxuICBcIm1hblwiOiBcInRleHQvdHJvZmZcIixcbiAgXCJtZVwiOiBcInRleHQvdHJvZmZcIixcbiAgXCJtc1wiOiBcInRleHQvdHJvZmZcIixcbiAgXCJ0dGxcIjogXCJ0ZXh0L3R1cnRsZVwiLFxuICBcInVyaVwiOiBcInRleHQvdXJpLWxpc3RcIixcbiAgXCJ1cmlzXCI6IFwidGV4dC91cmktbGlzdFwiLFxuICBcInVybHNcIjogXCJ0ZXh0L3VyaS1saXN0XCIsXG4gIFwidmNhcmRcIjogXCJ0ZXh0L3ZjYXJkXCIsXG4gIFwidnR0XCI6IFwidGV4dC92dHRcIixcbiAgXCJ5YW1sXCI6IFwidGV4dC95YW1sXCIsXG4gIFwieW1sXCI6IFwidGV4dC95YW1sXCIsXG4gIFwiM2dwXCI6IFwidmlkZW8vM2dwcFwiLFxuICBcIjNnMlwiOiBcInZpZGVvLzNncHAyXCIsXG4gIFwiaDI2MVwiOiBcInZpZGVvL2gyNjFcIixcbiAgXCJoMjYzXCI6IFwidmlkZW8vaDI2M1wiLFxuICBcImgyNjRcIjogXCJ2aWRlby9oMjY0XCIsXG4gIFwibTRzXCI6IFwidmlkZW8vaXNvLnNlZ21lbnRcIixcbiAgXCJqcGd2XCI6IFwidmlkZW8vanBlZ1wiLFxuICBcImpwZ21cIjogXCJpbWFnZS9qcG1cIixcbiAgXCJtajJcIjogXCJ2aWRlby9tajJcIixcbiAgXCJtanAyXCI6IFwidmlkZW8vbWoyXCIsXG4gIFwidHNcIjogXCJ2aWRlby9tcDJ0XCIsXG4gIFwibXA0XCI6IFwidmlkZW8vbXA0XCIsXG4gIFwibXA0dlwiOiBcInZpZGVvL21wNFwiLFxuICBcIm1wZzRcIjogXCJ2aWRlby9tcDRcIixcbiAgXCJtcGVnXCI6IFwidmlkZW8vbXBlZ1wiLFxuICBcIm1wZ1wiOiBcInZpZGVvL21wZWdcIixcbiAgXCJtcGVcIjogXCJ2aWRlby9tcGVnXCIsXG4gIFwibTF2XCI6IFwidmlkZW8vbXBlZ1wiLFxuICBcIm0ydlwiOiBcInZpZGVvL21wZWdcIixcbiAgXCJvZ3ZcIjogXCJ2aWRlby9vZ2dcIixcbiAgXCJxdFwiOiBcInZpZGVvL3F1aWNrdGltZVwiLFxuICBcIm1vdlwiOiBcInZpZGVvL3F1aWNrdGltZVwiLFxuICBcIndlYm1cIjogXCJ2aWRlby93ZWJtXCJcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBsb29rdXAoZXh0bikge1xuXHRsZXQgdG1wID0gKCcnICsgZXh0bikudHJpbSgpLnRvTG93ZXJDYXNlKCk7XG5cdGxldCBpZHggPSB0bXAubGFzdEluZGV4T2YoJy4nKTtcblx0cmV0dXJuIG1pbWVzWyF+aWR4ID8gdG1wIDogdG1wLnN1YnN0cmluZygrK2lkeCldO1xufVxuIiwgIi8vIEB0cy1jaGVja1xuLyoqXG4gKiBCb2R5LmpzXG4gKlxuICogQm9keSBpbnRlcmZhY2UgcHJvdmlkZXMgY29tbW9uIG1ldGhvZHMgZm9yIFJlcXVlc3QgYW5kIFJlc3BvbnNlXG4gKi9cblxuaW1wb3J0IFN0cmVhbSBmcm9tICdzdHJlYW0nO1xuaW1wb3J0IHt0eXBlc30gZnJvbSAndXRpbCc7XG5cbmltcG9ydCB7QmxvYiwgUmVhZGFibGVTdHJlYW19IGZyb20gJy4vcGFja2FnZS5qcyc7XG5cbmltcG9ydCB7RmV0Y2hFcnJvcn0gZnJvbSAnLi9lcnJvcnMvZmV0Y2gtZXJyb3IuanMnO1xuaW1wb3J0IHtGZXRjaEJhc2VFcnJvcn0gZnJvbSAnLi9lcnJvcnMvYmFzZS5qcyc7XG5pbXBvcnQge2Zvcm1EYXRhSXRlcmF0b3IsIGdldEJvdW5kYXJ5LCBnZXRGb3JtRGF0YUxlbmd0aCwgdG9Gb3JtRGF0YX0gZnJvbSAnLi91dGlscy9mb3JtLWRhdGEuanMnO1xuaW1wb3J0IHtpc0Jsb2IsIGlzVVJMU2VhcmNoUGFyYW1ldGVycywgaXNGb3JtRGF0YSwgaXNNdWx0aXBhcnRGb3JtRGF0YVN0cmVhbSwgaXNSZWFkYWJsZVN0cmVhbX0gZnJvbSAnLi91dGlscy9pcy5qcyc7XG5pbXBvcnQgKiBhcyB1dGY4IGZyb20gJy4vdXRpbHMvdXRmOC5qcyc7XG5jb25zdCB7cmVhZGFibGVIaWdoV2F0ZXJNYXJrfSA9IG5ldyBTdHJlYW0uUmVhZGFibGUoKTtcblxuY29uc3QgSU5URVJOQUxTID0gU3ltYm9sKCdCb2R5IGludGVybmFscycpO1xuXG4vKipcbiAqIEJvZHkgbWl4aW5cbiAqXG4gKiBSZWY6IGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNib2R5XG4gKiBAaW1wbGVtZW50cyB7Z2xvYmFsVGhpcy5Cb2R5fVxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJvZHkge1xuXHQvKipcblx0ICogQHBhcmFtIHtCb2R5SW5pdHxTdHJlYW18bnVsbH0gYm9keVxuXHQgKiBAcGFyYW0ge3tzaXplPzpudW1iZXJ9fSBvcHRpb25zXG5cdCAqL1xuXHRjb25zdHJ1Y3Rvcihib2R5LCB7XG5cdFx0c2l6ZSA9IDBcblx0fSA9IHt9KSB7XG5cdFx0Y29uc3Qgc3RhdGUgPSB7XG5cdFx0XHQvKiogQHR5cGUge251bGx8UmVhZGFibGVTdHJlYW08VWludDhBcnJheT59ICovXG5cdFx0XHRib2R5OiBudWxsLFxuXHRcdFx0LyoqIEB0eXBlIHtzdHJpbmd8bnVsbH0gKi9cblx0XHRcdHR5cGU6IG51bGwsXG5cdFx0XHQvKiogQHR5cGUge251bWJlcnxudWxsfSAqL1xuXHRcdFx0c2l6ZTogbnVsbCxcblx0XHRcdC8qKiBAdHlwZSB7bnVsbHxzdHJpbmd9ICovXG5cdFx0XHRib3VuZGFyeTogbnVsbCxcblx0XHRcdGRpc3R1cmJlZDogZmFsc2UsXG5cdFx0XHQvKiogQHR5cGUge251bGx8RXJyb3J9ICovXG5cdFx0XHRlcnJvcjogbnVsbFxuXHRcdH07XG5cdFx0LyoqIEBwcml2YXRlICovXG5cdFx0dGhpc1tJTlRFUk5BTFNdID0gc3RhdGU7XG5cblx0XHRpZiAoYm9keSA9PT0gbnVsbCkge1xuXHRcdFx0Ly8gQm9keSBpcyB1bmRlZmluZWQgb3IgbnVsbFxuXHRcdFx0c3RhdGUuYm9keSA9IG51bGw7XG5cdFx0XHRzdGF0ZS5zaXplID0gMDtcblx0XHR9IGVsc2UgaWYgKGlzVVJMU2VhcmNoUGFyYW1ldGVycyhib2R5KSkge1xuXHRcdC8vIEJvZHkgaXMgYSBVUkxTZWFyY2hQYXJhbXNcblx0XHRcdGNvbnN0IGJ5dGVzID0gdXRmOC5lbmNvZGUoYm9keS50b1N0cmluZygpKTtcblx0XHRcdHN0YXRlLmJvZHkgPSBmcm9tQnl0ZXMoYnl0ZXMpO1xuXHRcdFx0c3RhdGUuc2l6ZSA9IGJ5dGVzLmJ5dGVMZW5ndGg7XG5cdFx0XHRzdGF0ZS50eXBlID0gJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDtjaGFyc2V0PVVURi04Jztcblx0XHR9IGVsc2UgaWYgKGlzQmxvYihib2R5KSkge1xuXHRcdFx0Ly8gQm9keSBpcyBibG9iXG5cdFx0XHRzdGF0ZS5zaXplID0gYm9keS5zaXplO1xuXHRcdFx0c3RhdGUudHlwZSA9IGJvZHkudHlwZSB8fCBudWxsO1xuXHRcdFx0c3RhdGUuYm9keSA9IGJvZHkuc3RyZWFtKCk7XG5cdFx0fSBlbHNlIGlmIChib2R5IGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuXHRcdFx0Ly8gQm9keSBpcyBCdWZmZXJcblx0XHRcdHN0YXRlLmJvZHkgPSBmcm9tQnl0ZXMoYm9keSk7XG5cdFx0XHRzdGF0ZS5zaXplID0gYm9keS5ieXRlTGVuZ3RoO1xuXHRcdH0gZWxzZSBpZiAodHlwZXMuaXNBbnlBcnJheUJ1ZmZlcihib2R5KSkge1xuXHRcdFx0Ly8gQm9keSBpcyBBcnJheUJ1ZmZlclxuXHRcdFx0Y29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShib2R5KTtcblx0XHRcdHN0YXRlLmJvZHkgPSBmcm9tQnl0ZXMoYnl0ZXMpO1xuXHRcdFx0c3RhdGUuc2l6ZSA9IGJ5dGVzLmJ5dGVMZW5ndGg7XG5cdFx0fSBlbHNlIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoYm9keSkpIHtcblx0XHRcdC8vIEJvZHkgaXMgQXJyYXlCdWZmZXJWaWV3XG5cdFx0XHRjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGJvZHkuYnVmZmVyLCBib2R5LmJ5dGVPZmZzZXQsIGJvZHkuYnl0ZUxlbmd0aCk7XG5cdFx0XHRzdGF0ZS5ib2R5ID0gZnJvbUJ5dGVzKGJ5dGVzKTtcblx0XHRcdHN0YXRlLnNpemUgPSBieXRlcy5ieXRlTGVuZ3RoO1xuXHRcdH0gZWxzZSBpZiAoaXNSZWFkYWJsZVN0cmVhbShib2R5KSkge1xuXHRcdFx0Ly8gQm9keSBpcyBzdHJlYW1cblx0XHRcdHN0YXRlLmJvZHkgPSBib2R5O1xuXHRcdH0gZWxzZSBpZiAoaXNGb3JtRGF0YShib2R5KSkge1xuXHRcdFx0Ly8gQm9keSBpcyBhbiBpbnN0YW5jZSBvZiBmb3JtZGF0YS1ub2RlXG5cdFx0XHRjb25zdCBib3VuZGFyeSA9IGBOb2RlRmV0Y2hGb3JtRGF0YUJvdW5kYXJ5JHtnZXRCb3VuZGFyeSgpfWA7XG5cdFx0XHRzdGF0ZS50eXBlID0gYG11bHRpcGFydC9mb3JtLWRhdGE7IGJvdW5kYXJ5PSR7Ym91bmRhcnl9YDtcblx0XHRcdHN0YXRlLnNpemUgPSBnZXRGb3JtRGF0YUxlbmd0aChib2R5LCBib3VuZGFyeSk7XG5cdFx0XHRzdGF0ZS5ib2R5ID0gZnJvbUFzeW5jSXRlcmFibGUoZm9ybURhdGFJdGVyYXRvcihib2R5LCBib3VuZGFyeSkpO1xuXHRcdH0gZWxzZSBpZiAoaXNNdWx0aXBhcnRGb3JtRGF0YVN0cmVhbShib2R5KSkge1xuXHRcdFx0c3RhdGUudHlwZSA9IGBtdWx0aXBhcnQvZm9ybS1kYXRhOyBib3VuZGFyeT0ke2JvZHkuZ2V0Qm91bmRhcnkoKX1gO1xuXHRcdFx0c3RhdGUuc2l6ZSA9IGJvZHkuaGFzS25vd25MZW5ndGgoKSA/IGJvZHkuZ2V0TGVuZ3RoU3luYygpIDogbnVsbDtcblx0XHRcdHN0YXRlLmJvZHkgPSBmcm9tU3RyZWFtKGJvZHkpO1xuXHRcdH0gZWxzZSBpZiAoYm9keSBpbnN0YW5jZW9mIFN0cmVhbSkge1xuXHRcdFx0c3RhdGUuYm9keSA9IGZyb21TdHJlYW0oYm9keSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIE5vbmUgb2YgdGhlIGFib3ZlXG5cdFx0XHQvLyBjb2VyY2UgdG8gc3RyaW5nIHRoZW4gYnVmZmVyXG5cdFx0XHRjb25zdCBieXRlcyA9IHV0ZjguZW5jb2RlKFN0cmluZyhib2R5KSk7XG5cdFx0XHRzdGF0ZS50eXBlID0gJ3RleHQvcGxhaW47Y2hhcnNldD1VVEYtOCc7XG5cdFx0XHRzdGF0ZS5zaXplID0gYnl0ZXMuYnl0ZUxlbmd0aDtcblx0XHRcdHN0YXRlLmJvZHkgPSBmcm9tQnl0ZXMoYnl0ZXMpO1xuXHRcdH1cblxuXHRcdHRoaXMuc2l6ZSA9IHNpemU7XG5cblx0XHQvLyBpZiAoYm9keSBpbnN0YW5jZW9mIFN0cmVhbSkge1xuXHRcdC8vIFx0Ym9keS5vbignZXJyb3InLCBlcnIgPT4ge1xuXHRcdC8vIFx0XHRjb25zdCBlcnJvciA9IGVyciBpbnN0YW5jZW9mIEZldGNoQmFzZUVycm9yID9cblx0XHQvLyBcdFx0XHRlcnIgOlxuXHRcdC8vIFx0XHRcdG5ldyBGZXRjaEVycm9yKGBJbnZhbGlkIHJlc3BvbnNlIGJvZHkgd2hpbGUgdHJ5aW5nIHRvIGZldGNoICR7dGhpcy51cmx9OiAke2Vyci5tZXNzYWdlfWAsICdzeXN0ZW0nLCBlcnIpO1xuXHRcdC8vIFx0XHR0aGlzW0lOVEVSTkFMU10uZXJyb3IgPSBlcnJvcjtcblx0XHQvLyBcdH0pO1xuXHRcdC8vIH1cblx0fVxuXG5cdC8qKiBAdHlwZSB7SGVhZGVyc30gKi9cblx0LyogYzggaWdub3JlIG5leHQgMyAqL1xuXHRnZXQgaGVhZGVycygpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKGAnZ2V0IGhlYWRlcnMnIGNhbGxlZCBvbiBhbiBvYmplY3QgdGhhdCBkb2VzIG5vdCBpbXBsZW1lbnRzIGludGVyZmFjZS5gKVxuXHR9XG5cblx0Z2V0IGJvZHkoKSB7XG5cdFx0cmV0dXJuIHRoaXNbSU5URVJOQUxTXS5ib2R5O1xuXHR9XG5cblx0Z2V0IGJvZHlVc2VkKCkge1xuXHRcdHJldHVybiB0aGlzW0lOVEVSTkFMU10uZGlzdHVyYmVkO1xuXHR9XG5cblx0LyoqXG5cdCAqIERlY29kZSByZXNwb25zZSBhcyBBcnJheUJ1ZmZlclxuXHQgKlxuXHQgKiBAcmV0dXJuIHtQcm9taXNlPEFycmF5QnVmZmVyPn1cblx0ICovXG5cdGFzeW5jIGFycmF5QnVmZmVyKCkge1xuXHRcdGNvbnN0IHtidWZmZXIsIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGh9ID0gYXdhaXQgY29uc3VtZUJvZHkodGhpcyk7XG5cdFx0cmV0dXJuIGJ1ZmZlci5zbGljZShieXRlT2Zmc2V0LCBieXRlT2Zmc2V0ICsgYnl0ZUxlbmd0aCk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJuIHJhdyByZXNwb25zZSBhcyBCbG9iXG5cdCAqXG5cdCAqIEByZXR1cm4gUHJvbWlzZVxuXHQgKi9cblx0YXN5bmMgYmxvYigpIHtcblx0XHRjb25zdCBjdCA9ICh0aGlzLmhlYWRlcnMgJiYgdGhpcy5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJykpIHx8ICh0aGlzW0lOVEVSTkFMU10uYm9keSAmJiB0aGlzW0lOVEVSTkFMU10udHlwZSkgfHwgJyc7XG5cdFx0Y29uc3QgYnVmID0gYXdhaXQgY29uc3VtZUJvZHkodGhpcyk7XG5cblx0XHRyZXR1cm4gbmV3IEJsb2IoW2J1Zl0sIHtcblx0XHRcdHR5cGU6IGN0XG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogRGVjb2RlIHJlc3BvbnNlIGFzIGpzb25cblx0ICpcblx0ICogQHJldHVybiAgUHJvbWlzZVxuXHQgKi9cblx0YXN5bmMganNvbigpIHtcblx0XHRyZXR1cm4gSlNPTi5wYXJzZShhd2FpdCB0aGlzLnRleHQoKSk7XG5cdH1cblxuXHQvKipcblx0ICogRGVjb2RlIHJlc3BvbnNlIGFzIHRleHRcblx0ICpcblx0ICogQHJldHVybiAgUHJvbWlzZVxuXHQgKi9cblx0YXN5bmMgdGV4dCgpIHtcblx0XHRjb25zdCBidWZmZXIgPSBhd2FpdCBjb25zdW1lQm9keSh0aGlzKTtcblx0XHRyZXR1cm4gdXRmOC5kZWNvZGUoYnVmZmVyKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7UHJvbWlzZTxGb3JtRGF0YT59XG5cdCAqL1xuXG5cdGFzeW5jIGZvcm1EYXRhKCkge1xuXHRcdHJldHVybiB0b0Zvcm1EYXRhKHRoaXMpXG5cdH1cbn1cblxuLy8gSW4gYnJvd3NlcnMsIGFsbCBwcm9wZXJ0aWVzIGFyZSBlbnVtZXJhYmxlLlxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQm9keS5wcm90b3R5cGUsIHtcblx0Ym9keToge2VudW1lcmFibGU6IHRydWV9LFxuXHRib2R5VXNlZDoge2VudW1lcmFibGU6IHRydWV9LFxuXHRhcnJheUJ1ZmZlcjoge2VudW1lcmFibGU6IHRydWV9LFxuXHRibG9iOiB7ZW51bWVyYWJsZTogdHJ1ZX0sXG5cdGpzb246IHtlbnVtZXJhYmxlOiB0cnVlfSxcblx0dGV4dDoge2VudW1lcmFibGU6IHRydWV9LFxuXHRmb3JtRGF0YToge2VudW1lcmFibGU6IHRydWV9XG59KTtcblxuLyoqXG4gKiBDb25zdW1lIGFuZCBjb252ZXJ0IGFuIGVudGlyZSBCb2R5IHRvIGEgQnVmZmVyLlxuICpcbiAqIFJlZjogaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtYm9keS1jb25zdW1lLWJvZHlcbiAqXG4gKiBAcGFyYW0ge0JvZHkgJiB7dXJsPzpzdHJpbmd9fSBkYXRhXG4gKiBAcmV0dXJuIHtQcm9taXNlPFVpbnQ4QXJyYXk+fVxuICovXG5hc3luYyBmdW5jdGlvbiBjb25zdW1lQm9keShkYXRhKSB7XG5cdGNvbnN0IHN0YXRlID0gZGF0YVtJTlRFUk5BTFNdO1xuXHRpZiAoc3RhdGUuZGlzdHVyYmVkKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihgYm9keSB1c2VkIGFscmVhZHkgZm9yOiAke2RhdGEudXJsfWApO1xuXHR9XG5cblx0c3RhdGUuZGlzdHVyYmVkID0gdHJ1ZTtcblxuXHRpZiAoc3RhdGUuZXJyb3IpIHtcblx0XHR0aHJvdyBzdGF0ZS5lcnJvcjtcblx0fVxuXG5cdGNvbnN0IHtib2R5fSA9IHN0YXRlO1xuXG5cdC8vIEJvZHkgaXMgbnVsbFxuXHRpZiAoYm9keSA9PT0gbnVsbCkge1xuXHRcdHJldHVybiBuZXcgVWludDhBcnJheSgwKTtcblx0fVxuXG5cdC8vIEJvZHkgaXMgc3RyZWFtXG5cdC8vIGdldCByZWFkeSB0byBhY3R1YWxseSBjb25zdW1lIHRoZSBib2R5XG5cdC8qKiBAdHlwZSB7W1VpbnQ4QXJyYXl8bnVsbCwgVWludDhBcnJheVtdLCBudW1iZXJdfSAqL1xuXHRjb25zdCBbYnVmZmVyLCBjaHVua3MsIGxpbWl0XSA9IGRhdGEuc2l6ZSA+IDAgP1xuXHRcdFtuZXcgVWludDhBcnJheShkYXRhLnNpemUpLCBbXSwgZGF0YS5zaXplXSA6XG5cdFx0W251bGwsIFtdLCBJbmZpbml0eV07XG5cdGxldCBvZmZzZXQgPSAwO1xuXG5cdGNvbnN0IHNvdXJjZSA9IHN0cmVhbUl0ZXJhdG9yKGJvZHkpO1xuXHR0cnkge1xuXHRcdGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2Ygc291cmNlKSB7XG5cdFx0XHRjb25zdCBieXRlcyA9IGNodW5rIGluc3RhbmNlb2YgVWludDhBcnJheSA/XG5cdFx0XHRcdGNodW5rIDpcblx0XHRcdFx0QnVmZmVyLmZyb20oY2h1bmspO1xuXG5cdFx0XHRpZiAob2Zmc2V0ICsgYnl0ZXMuYnl0ZUxlbmd0aCA+IGxpbWl0KSB7XG5cdFx0XHRcdGNvbnN0IGVycm9yID0gbmV3IEZldGNoRXJyb3IoYGNvbnRlbnQgc2l6ZSBhdCAke2RhdGEudXJsfSBvdmVyIGxpbWl0OiAke2xpbWl0fWAsICdtYXgtc2l6ZScpO1xuXHRcdFx0XHRzb3VyY2UudGhyb3coZXJyb3IpO1xuXHRcdFx0XHR0aHJvdyBlcnJvcjtcblx0XHRcdH0gZWxzZSBpZiAoYnVmZmVyKSB7XG5cdFx0XHRcdGJ1ZmZlci5zZXQoYnl0ZXMsIG9mZnNldCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjaHVua3MucHVzaChieXRlcyk7XG5cdFx0XHR9XG5cblx0XHRcdG9mZnNldCArPSBieXRlcy5ieXRlTGVuZ3RoO1xuXHRcdH1cblxuXHRcdGlmIChidWZmZXIpIHtcblx0XHRcdGlmIChvZmZzZXQgPCBidWZmZXIuYnl0ZUxlbmd0aCkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRmV0Y2hFcnJvcihgUHJlbWF0dXJlIGNsb3NlIG9mIHNlcnZlciByZXNwb25zZSB3aGlsZSB0cnlpbmcgdG8gZmV0Y2ggJHtkYXRhLnVybH1gLCAncHJlbWF0dXJlLWNsb3NlJyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gYnVmZmVyO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gd3JpdGVCeXRlcyhuZXcgVWludDhBcnJheShvZmZzZXQpLCBjaHVua3MpO1xuXHRcdH1cblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRpZiAoZXJyb3IgaW5zdGFuY2VvZiBGZXRjaEJhc2VFcnJvcikge1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0Ly8gQHRzLWV4cGVjdC1lcnJvciAtIHdlIGtub3cgaXQgd2lsbCBoYXZlIGEgbmFtZVxuXHRcdH0gZWxzZSBpZiAoZXJyb3IgJiYgZXJyb3IubmFtZSA9PT0gJ0Fib3J0RXJyb3InKSB7XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29uc3QgZSA9IC8qKiBAdHlwZSB7aW1wb3J0KCcuL2Vycm9ycy9mZXRjaC1lcnJvcicpLlN5c3RlbUVycm9yfSAqLyhlcnJvcilcblx0XHRcdC8vIE90aGVyIGVycm9ycywgc3VjaCBhcyBpbmNvcnJlY3QgY29udGVudC1lbmNvZGluZ1xuXHRcdFx0dGhyb3cgbmV3IEZldGNoRXJyb3IoYEludmFsaWQgcmVzcG9uc2UgYm9keSB3aGlsZSB0cnlpbmcgdG8gZmV0Y2ggJHtkYXRhLnVybH06ICR7ZS5tZXNzYWdlfWAsICdzeXN0ZW0nLCBlKTtcblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBDbG9uZSBib2R5IGdpdmVuIFJlcy9SZXEgaW5zdGFuY2VcbiAqXG4gKiBAcGFyYW0ge0JvZHl9IGluc3RhbmNlICAgICAgIFJlc3BvbnNlIG9yIFJlcXVlc3QgaW5zdGFuY2VcbiAqIEByZXR1cm4ge1JlYWRhYmxlU3RyZWFtPFVpbnQ4QXJyYXk+IHwgbnVsbH1cbiAqL1xuZXhwb3J0IGNvbnN0IGNsb25lID0gaW5zdGFuY2UgPT4ge1xuXHRjb25zdCB7Ym9keX0gPSBpbnN0YW5jZTtcblxuXHQvLyBEb24ndCBhbGxvdyBjbG9uaW5nIGEgdXNlZCBib2R5XG5cdGlmIChpbnN0YW5jZS5ib2R5VXNlZCkge1xuXHRcdHRocm93IG5ldyBFcnJvcignY2Fubm90IGNsb25lIGJvZHkgYWZ0ZXIgaXQgaXMgdXNlZCcpO1xuXHR9XG5cblx0aWYgKCFib2R5KSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHRjb25zdCBbbGVmdCwgcmlnaHRdID0gYm9keS50ZWUoKTtcblx0aW5zdGFuY2VbSU5URVJOQUxTXS5ib2R5ID0gbGVmdDtcblx0cmV0dXJuIHJpZ2h0O1xufTtcblxuLyoqXG4gKiBQZXJmb3JtcyB0aGUgb3BlcmF0aW9uIFwiZXh0cmFjdCBhIGBDb250ZW50LVR5cGVgIHZhbHVlIGZyb20gfG9iamVjdHxcIiBhc1xuICogc3BlY2lmaWVkIGluIHRoZSBzcGVjaWZpY2F0aW9uOlxuICogaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtYm9keWluaXQtZXh0cmFjdFxuICpcbiAqIFRoaXMgZnVuY3Rpb24gYXNzdW1lcyB0aGF0IGluc3RhbmNlLmJvZHkgaXMgcHJlc2VudC5cbiAqXG4gKiBAcGFyYW0ge0JvZHl9IHNvdXJjZSBBbnkgb3B0aW9ucy5ib2R5IGlucHV0XG4gKiBAcmV0dXJucyB7c3RyaW5nIHwgbnVsbH1cbiAqL1xuZXhwb3J0IGNvbnN0IGV4dHJhY3RDb250ZW50VHlwZSA9IHNvdXJjZSA9PiBzb3VyY2VbSU5URVJOQUxTXS50eXBlO1xuXG4vKipcbiAqIFRoZSBGZXRjaCBTdGFuZGFyZCB0cmVhdHMgdGhpcyBhcyBpZiBcInRvdGFsIGJ5dGVzXCIgaXMgYSBwcm9wZXJ0eSBvbiB0aGUgYm9keS5cbiAqIEZvciB1cywgd2UgaGF2ZSB0byBleHBsaWNpdGx5IGdldCBpdCB3aXRoIGEgZnVuY3Rpb24uXG4gKlxuICogcmVmOiBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1ib2R5LXRvdGFsLWJ5dGVzXG4gKlxuICogQHBhcmFtIHtCb2R5fSBzb3VyY2UgLSBCb2R5IG9iamVjdCBmcm9tIHRoZSBCb2R5IGluc3RhbmNlLlxuICogQHJldHVybnMge251bWJlciB8IG51bGx9XG4gKi9cbmV4cG9ydCBjb25zdCBnZXRUb3RhbEJ5dGVzID0gc291cmNlID0+IHNvdXJjZVtJTlRFUk5BTFNdLnNpemU7XG5cbi8qKlxuICogV3JpdGUgYSBCb2R5IHRvIGEgTm9kZS5qcyBXcml0YWJsZVN0cmVhbSAoZS5nLiBodHRwLlJlcXVlc3QpIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge1N0cmVhbS5Xcml0YWJsZX0gZGVzdCAtIFRoZSBzdHJlYW0gdG8gd3JpdGUgdG8uXG4gKiBAcGFyYW0ge0JvZHl9IHNvdXJjZSAtIEJvZHkgb2JqZWN0IGZyb20gdGhlIEJvZHkgaW5zdGFuY2UuXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGNvbnN0IHdyaXRlVG9TdHJlYW0gPSAoZGVzdCwge2JvZHl9KSA9PiB7XG5cdGlmIChib2R5ID09PSBudWxsKSB7XG5cdFx0Ly8gQm9keSBpcyBudWxsXG5cdFx0ZGVzdC5lbmQoKTtcblx0fSBlbHNlIHtcblx0XHRTdHJlYW0uUmVhZGFibGUuZnJvbShzdHJlYW1JdGVyYXRvcihib2R5KSkucGlwZShkZXN0KTtcblx0fVxufTtcblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQGltcGxlbWVudHMge0FzeW5jR2VuZXJhdG9yPFQsIHZvaWQsIHZvaWQ+fVxuICovXG5jbGFzcyBTdHJlYW1JdGVyYWJsZUl0ZXJhdG9yIHtcblx0LyoqXG5cdCAqIEBwYXJhbSB7UmVhZGFibGVTdHJlYW08VD59IHN0cmVhbVxuXHQgKi9cblx0Y29uc3RydWN0b3Ioc3RyZWFtKSB7XG5cdFx0dGhpcy5zdHJlYW0gPSBzdHJlYW07XG5cdFx0dGhpcy5yZWFkZXIgPSBudWxsO1xuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm5zIHtBc3luY0dlbmVyYXRvcjxULCB2b2lkLCB2b2lkPn1cblx0ICovXG5cdFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHRnZXRSZWFkZXIoKSB7XG5cdFx0aWYgKHRoaXMucmVhZGVyKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5yZWFkZXI7XG5cdFx0fVxuXG5cdFx0Y29uc3QgcmVhZGVyID0gdGhpcy5zdHJlYW0uZ2V0UmVhZGVyKCk7XG5cdFx0dGhpcy5yZWFkZXIgPSByZWFkZXI7XG5cdFx0cmV0dXJuIHJlYWRlcjtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7UHJvbWlzZTxJdGVyYXRvclJlc3VsdDxULCB2b2lkPj59XG5cdCAqL1xuXHRuZXh0KCkge1xuXHRcdHJldHVybiAvKiogQHR5cGUge1Byb21pc2U8SXRlcmF0b3JSZXN1bHQ8VCwgdm9pZD4+fSAqLyAodGhpcy5nZXRSZWFkZXIoKS5yZWFkKCkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm5zIHtQcm9taXNlPEl0ZXJhdG9yUmVzdWx0PFQsIHZvaWQ+Pn1cblx0ICovXG5cdGFzeW5jIHJldHVybigpIHtcblx0XHRpZiAodGhpcy5yZWFkZXIpIHtcblx0XHRcdGF3YWl0IHRoaXMucmVhZGVyLmNhbmNlbCgpO1xuXHRcdH1cblxuXHRcdHJldHVybiB7ZG9uZTogdHJ1ZSwgdmFsdWU6IHVuZGVmaW5lZH07XG5cdH1cblxuXHQvKipcblx0ICogXG5cdCAqIEBwYXJhbSB7YW55fSBlcnJvciBcblx0ICogQHJldHVybnMge1Byb21pc2U8SXRlcmF0b3JSZXN1bHQ8VCwgdm9pZD4+fVxuXHQgKi9cblx0YXN5bmMgdGhyb3coZXJyb3IpIHtcblx0XHRhd2FpdCB0aGlzLmdldFJlYWRlcigpLmNhbmNlbChlcnJvcik7XG5cdFx0cmV0dXJuIHtkb25lOiB0cnVlLCB2YWx1ZTogdW5kZWZpbmVkfTtcblx0fVxufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge1JlYWRhYmxlU3RyZWFtPFQ+fSBzdHJlYW1cbiAqL1xuZXhwb3J0IGNvbnN0IHN0cmVhbUl0ZXJhdG9yID0gc3RyZWFtID0+IG5ldyBTdHJlYW1JdGVyYWJsZUl0ZXJhdG9yKHN0cmVhbSk7XG5cbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWZmZXJcbiAqIEBwYXJhbSB7VWludDhBcnJheVtdfSBjaHVua3NcbiAqL1xuY29uc3Qgd3JpdGVCeXRlcyA9IChidWZmZXIsIGNodW5rcykgPT4ge1xuXHRsZXQgb2Zmc2V0ID0gMDtcblx0Zm9yIChjb25zdCBjaHVuayBvZiBjaHVua3MpIHtcblx0XHRidWZmZXIuc2V0KGNodW5rLCBvZmZzZXQpO1xuXHRcdG9mZnNldCArPSBjaHVuay5ieXRlTGVuZ3RoO1xuXHR9XG5cblx0cmV0dXJuIGJ1ZmZlcjtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBieXRlc1xuICogQHJldHVybnMge1JlYWRhYmxlU3RyZWFtPFVpbnQ4QXJyYXk+fVxuICovXG4vLyBAdHMtaWdub3JlXG5jb25zdCBmcm9tQnl0ZXMgPSBieXRlcyA9PiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuXHRzdGFydChjb250cm9sbGVyKSB7XG5cdFx0Y29udHJvbGxlci5lbnF1ZXVlKGJ5dGVzKTtcblx0XHRjb250cm9sbGVyLmNsb3NlKCk7XG5cdH1cbn0pO1xuXG4vKipcbiAqIEBwYXJhbSB7QXN5bmNJdGVyYWJsZTxVaW50OEFycmF5Pn0gY29udGVudFxuICogQHJldHVybnMge1JlYWRhYmxlU3RyZWFtPFVpbnQ4QXJyYXk+fVxuICovXG5leHBvcnQgY29uc3QgZnJvbUFzeW5jSXRlcmFibGUgPSBjb250ZW50ID0+XG5cdC8vIEB0cy1pZ25vcmVcblx0bmV3IFJlYWRhYmxlU3RyZWFtKG5ldyBBc3luY0l0ZXJhYmxlUHVtcChjb250ZW50KSk7XG5cbi8qKlxuICogQGltcGxlbWVudHMge1VuZGVybHlpbmdTb3VyY2U8VWludDhBcnJheT59XG4gKi9cbmNsYXNzIEFzeW5jSXRlcmFibGVQdW1wIHtcblx0LyoqXG5cdCAqIEBwYXJhbSB7QXN5bmNJdGVyYWJsZTxVaW50OEFycmF5Pn0gc291cmNlXG5cdCAqL1xuXHRjb25zdHJ1Y3Rvcihzb3VyY2UpIHtcblx0XHR0aGlzLnNvdXJjZSA9IHNvdXJjZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcjxVaW50OEFycmF5Pn0gY29udHJvbGxlclxuXHQgKi9cblx0YXN5bmMgcHVsbChjb250cm9sbGVyKSB7XG5cdFx0dHJ5IHtcblx0XHRcdHdoaWxlIChjb250cm9sbGVyLmRlc2lyZWRTaXplIHx8IDAgPiAwKSB7XG5cdFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1hd2FpdC1pbi1sb29wXG5cdFx0XHRcdGNvbnN0IG5leHQgPSBhd2FpdCB0aGlzLnNvdXJjZS5uZXh0KCk7XG5cdFx0XHRcdGlmIChuZXh0LmRvbmUpIHtcblx0XHRcdFx0XHRjb250cm9sbGVyLmNsb3NlKCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y29udHJvbGxlci5lbnF1ZXVlKG5leHQudmFsdWUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGNvbnRyb2xsZXIuZXJyb3IoZXJyb3IpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge2FueX0gW3JlYXNvbl1cblx0ICovXG5cdGNhbmNlbChyZWFzb24pIHtcblx0XHRpZiAocmVhc29uKSB7XG5cdFx0XHRpZiAodHlwZW9mIHRoaXMuc291cmNlLnRocm93ID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdHRoaXMuc291cmNlLnRocm93KHJlYXNvbik7XG5cdFx0XHR9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLnNvdXJjZS5yZXR1cm4gPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0dGhpcy5zb3VyY2UucmV0dXJuKCk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmICh0eXBlb2YgdGhpcy5zb3VyY2UucmV0dXJuID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHR0aGlzLnNvdXJjZS5yZXR1cm4oKTtcblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1N0cmVhbSAmIHtyZWFkYWJsZUhpZ2hXYXRlck1hcms/Om51bWJlcn19IHNvdXJjZVxuICogQHJldHVybnMge1JlYWRhYmxlU3RyZWFtPFVpbnQ4QXJyYXk+fVxuICovXG5leHBvcnQgY29uc3QgZnJvbVN0cmVhbSA9IHNvdXJjZSA9PiB7XG5cdGNvbnN0IHB1bXAgPSBuZXcgU3RyZWFtUHVtcChzb3VyY2UpO1xuXHRjb25zdCBzdHJlYW0gPSBuZXcgUmVhZGFibGVTdHJlYW0ocHVtcCwgcHVtcCk7XG5cdHJldHVybiBzdHJlYW07XG59O1xuXG4vKipcbiAqIEBpbXBsZW1lbnRzIHtVbmRlcmx5aW5nU291cmNlPFVpbnQ4QXJyYXk+fVxuICogQGltcGxlbWVudHMge1F1ZXVpbmdTdHJhdGVneTxVaW50OEFycmF5Pn1cbiAqL1xuY2xhc3MgU3RyZWFtUHVtcCB7XG5cdC8qKlxuXHQgKiBAcGFyYW0ge1N0cmVhbSAmIHtcblx0ICogXHRyZWFkYWJsZUhpZ2hXYXRlck1hcms/OiBudW1iZXJcblx0ICogXHRyZWFkYWJsZT86Ym9vbGVhbixcblx0ICogXHRyZXN1bWU/OiAoKSA9PiB2b2lkLFxuXHQgKiBcdHBhdXNlPzogKCkgPT4gdm9pZFxuXHQgKiBcdGRlc3Ryb3k/OiAoZXJyb3I/OkVycm9yKSA9PiB2b2lkXG5cdCAqIH19IHN0cmVhbVxuXHQgKi9cblx0Y29uc3RydWN0b3Ioc3RyZWFtKSB7XG5cdFx0dGhpcy5oaWdoV2F0ZXJNYXJrID0gc3RyZWFtLnJlYWRhYmxlSGlnaFdhdGVyTWFyayB8fCByZWFkYWJsZUhpZ2hXYXRlck1hcms7XG5cdFx0dGhpcy5hY2N1bWFsYXRlZFNpemUgPSAwO1xuXHRcdHRoaXMuc3RyZWFtID0gc3RyZWFtO1xuXHRcdHRoaXMuZW5xdWV1ZSA9IHRoaXMuZW5xdWV1ZS5iaW5kKHRoaXMpO1xuXHRcdHRoaXMuZXJyb3IgPSB0aGlzLmVycm9yLmJpbmQodGhpcyk7XG5cdFx0dGhpcy5jbG9zZSA9IHRoaXMuY2xvc2UuYmluZCh0aGlzKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IFtjaHVua11cblx0ICovXG5cdHNpemUoY2h1bmspIHtcblx0XHRyZXR1cm4gY2h1bms/LmJ5dGVMZW5ndGggfHwgMDtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcjxVaW50OEFycmF5Pn0gY29udHJvbGxlclxuXHQgKi9cblx0c3RhcnQoY29udHJvbGxlcikge1xuXHRcdHRoaXMuY29udHJvbGxlciA9IGNvbnRyb2xsZXI7XG5cdFx0dGhpcy5zdHJlYW0ub24oJ2RhdGEnLCB0aGlzLmVucXVldWUpO1xuXHRcdHRoaXMuc3RyZWFtLm9uY2UoJ2Vycm9yJywgdGhpcy5lcnJvcik7XG5cdFx0dGhpcy5zdHJlYW0ub25jZSgnZW5kJywgdGhpcy5jbG9zZSk7XG5cdFx0dGhpcy5zdHJlYW0ub25jZSgnY2xvc2UnLCB0aGlzLmNsb3NlKTtcblx0fVxuXG5cdHB1bGwoKSB7XG5cdFx0dGhpcy5yZXN1bWUoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge2FueX0gW3JlYXNvbl1cblx0ICovXG5cdGNhbmNlbChyZWFzb24pIHtcblx0XHRpZiAodGhpcy5zdHJlYW0uZGVzdHJveSkge1xuXHRcdFx0dGhpcy5zdHJlYW0uZGVzdHJveShyZWFzb24pO1xuXHRcdH1cblxuXHRcdHRoaXMuc3RyZWFtLm9mZignZGF0YScsIHRoaXMuZW5xdWV1ZSk7XG5cdFx0dGhpcy5zdHJlYW0ub2ZmKCdlcnJvcicsIHRoaXMuZXJyb3IpO1xuXHRcdHRoaXMuc3RyZWFtLm9mZignZW5kJywgdGhpcy5jbG9zZSk7XG5cdFx0dGhpcy5zdHJlYW0ub2ZmKCdjbG9zZScsIHRoaXMuY2xvc2UpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7VWludDhBcnJheXxzdHJpbmd9IGNodW5rXG5cdCAqL1xuXHRlbnF1ZXVlKGNodW5rKSB7XG5cdFx0aWYgKHRoaXMuY29udHJvbGxlcikge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Y29uc3QgYnl0ZXMgPSBjaHVuayBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgP1xuXHRcdFx0XHRcdGNodW5rIDpcblx0XHRcdFx0XHRCdWZmZXIuZnJvbShjaHVuayk7XG5cblx0XHRcdFx0Y29uc3QgYXZhaWxhYmxlID0gKHRoaXMuY29udHJvbGxlci5kZXNpcmVkU2l6ZSB8fCAwKSAtIGJ5dGVzLmJ5dGVMZW5ndGg7XG5cdFx0XHRcdHRoaXMuY29udHJvbGxlci5lbnF1ZXVlKGJ5dGVzKTtcblx0XHRcdFx0aWYgKGF2YWlsYWJsZSA8PSAwKSB7XG5cdFx0XHRcdFx0dGhpcy5wYXVzZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGNhdGNoIHtcblx0XHRcdFx0dGhpcy5jb250cm9sbGVyLmVycm9yKG5ldyBFcnJvcignQ291bGQgbm90IGNyZWF0ZSBCdWZmZXIsIGNodW5rIG11c3QgYmUgb2YgdHlwZSBzdHJpbmcgb3IgYW4gaW5zdGFuY2Ugb2YgQnVmZmVyLCBBcnJheUJ1ZmZlciwgb3IgQXJyYXkgb3IgYW4gQXJyYXktbGlrZSBPYmplY3QnKSk7XG5cdFx0XHRcdHRoaXMuY2FuY2VsKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cGF1c2UoKSB7XG5cdFx0aWYgKHRoaXMuc3RyZWFtLnBhdXNlKSB7XG5cdFx0XHR0aGlzLnN0cmVhbS5wYXVzZSgpO1xuXHRcdH1cblx0fVxuXG5cdHJlc3VtZSgpIHtcblx0XHRpZiAodGhpcy5zdHJlYW0ucmVhZGFibGUgJiYgdGhpcy5zdHJlYW0ucmVzdW1lKSB7XG5cdFx0XHR0aGlzLnN0cmVhbS5yZXN1bWUoKTtcblx0XHR9XG5cdH1cblxuXHRjbG9zZSgpIHtcblx0XHRpZiAodGhpcy5jb250cm9sbGVyKSB7XG5cdFx0XHR0aGlzLmNvbnRyb2xsZXIuY2xvc2UoKTtcblx0XHRcdGRlbGV0ZSB0aGlzLmNvbnRyb2xsZXI7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7RXJyb3J9IGVycm9yIFxuXHQgKi9cblx0ZXJyb3IoZXJyb3IpIHtcblx0XHRpZiAodGhpcy5jb250cm9sbGVyKSB7XG5cdFx0XHR0aGlzLmNvbnRyb2xsZXIuZXJyb3IoZXJyb3IpO1xuXHRcdFx0ZGVsZXRlIHRoaXMuY29udHJvbGxlcjtcblx0XHR9XG5cdH1cbn1cbiIsICIvLyBJbiBub2RlIGBleHBvcnQgeyBUZXh0RW5jb2RlciB9YCB0aHJvd3M6XG4vLyBcIkV4cG9ydCAnVGV4dEVuY29kZXInIGlzIG5vdCBkZWZpbmVkIGluIG1vZHVsZVwiXG4vLyBUbyB3b3JrYXJvdW5kIHdlIGZpcnN0IGRlZmluZSBjb25zdGFudHMgYW5kIHRoZW4gZXhwb3J0IHdpdGggYXMuXG5jb25zdCBFbmNvZGVyID0gVGV4dEVuY29kZXJcbmNvbnN0IERlY29kZXIgPSBUZXh0RGVjb2RlclxuXG5leHBvcnQgeyBFbmNvZGVyIGFzIFRleHRFbmNvZGVyLCBEZWNvZGVyIGFzIFRleHREZWNvZGVyIH1cbiIsICIvLyBAdHMtaWdub3JlXG5pbXBvcnQgc3RyZWFtcyBmcm9tIFwiLi9zdHJlYW0uY2pzXCJcbmV4cG9ydCBjb25zdCB7XG4gIFJlYWRhYmxlU3RyZWFtLFxuICBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIsXG4gIFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlcixcbiAgUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdCxcbiAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcixcbiAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcixcbiAgVHJhbnNmb3JtU3RyZWFtLFxuICBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlcixcbiAgV3JpdGFibGVTdHJlYW0sXG4gIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcixcbiAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcixcbiAgQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneSxcbiAgQ291bnRRdWV1aW5nU3RyYXRlZ3ksXG4gIFRleHRFbmNvZGVyU3RyZWFtLFxuICBUZXh0RGVjb2RlclN0cmVhbSxcbn0gPSBzdHJlYW1zXG4iLCAiaW1wb3J0IHsgUmVhZGFibGVTdHJlYW0sIFRleHRFbmNvZGVyLCBUZXh0RGVjb2RlciB9IGZyb20gXCIuL3BhY2thZ2UuanNcIlxuXG4vKipcbiAqIEBpbXBsZW1lbnRzIHtnbG9iYWxUaGlzLkJsb2J9XG4gKi9cbmNvbnN0IFdlYkJsb2IgPSBjbGFzcyBCbG9iIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7QmxvYlBhcnRbXX0gW2luaXRdXG4gICAqIEBwYXJhbSB7QmxvYlByb3BlcnR5QmFnfSBbb3B0aW9uc11cbiAgICovXG4gIGNvbnN0cnVjdG9yKGluaXQgPSBbXSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgLyoqIEB0eXBlIHtVaW50OEFycmF5W119ICovXG4gICAgY29uc3QgcGFydHMgPSBbXVxuXG4gICAgbGV0IHNpemUgPSAwXG4gICAgZm9yIChjb25zdCBwYXJ0IG9mIGluaXQpIHtcbiAgICAgIGlmICh0eXBlb2YgcGFydCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBjb25zdCBieXRlcyA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShwYXJ0KVxuICAgICAgICBwYXJ0cy5wdXNoKGJ5dGVzKVxuICAgICAgICBzaXplICs9IGJ5dGVzLmJ5dGVMZW5ndGhcbiAgICAgIH0gZWxzZSBpZiAocGFydCBpbnN0YW5jZW9mIFdlYkJsb2IpIHtcbiAgICAgICAgc2l6ZSArPSBwYXJ0LnNpemVcbiAgICAgICAgLy8gQHRzLWlnbm9yZSAtIGBfcGFydHNgIGlzIG1hcmtlZCBwcml2YXRlIHNvIFRTIHdpbGwgY29tcGxhaW4gYWJvdXRcbiAgICAgICAgLy8gYWNjZXNzaW5nIGl0LlxuICAgICAgICBwYXJ0cy5wdXNoKC4uLnBhcnQuX3BhcnRzKVxuICAgICAgfSBlbHNlIGlmIChwYXJ0IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgcGFydHMucHVzaChuZXcgVWludDhBcnJheShwYXJ0KSlcbiAgICAgICAgc2l6ZSArPSBwYXJ0LmJ5dGVMZW5ndGhcbiAgICAgIH0gZWxzZSBpZiAocGFydCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgcGFydHMucHVzaChwYXJ0KVxuICAgICAgICBzaXplICs9IHBhcnQuYnl0ZUxlbmd0aFxuICAgICAgfSBlbHNlIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcocGFydCkpIHtcbiAgICAgICAgY29uc3QgeyBidWZmZXIsIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGggfSA9IHBhcnRcbiAgICAgICAgcGFydHMucHVzaChuZXcgVWludDhBcnJheShidWZmZXIsIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGgpKVxuICAgICAgICBzaXplICs9IGJ5dGVMZW5ndGhcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKFN0cmluZyhwYXJ0KSlcbiAgICAgICAgcGFydHMucHVzaChieXRlcylcbiAgICAgICAgc2l6ZSArPSBieXRlcy5ieXRlTGVuZ3RoXG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgdGhpcy5fc2l6ZSA9IHNpemVcbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICB0aGlzLl90eXBlID0gcmVhZFR5cGUob3B0aW9ucy50eXBlKVxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIHRoaXMuX3BhcnRzID0gcGFydHNcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgIF9zaXplOiB7IGVudW1lcmFibGU6IGZhbHNlIH0sXG4gICAgICBfdHlwZTogeyBlbnVtZXJhYmxlOiBmYWxzZSB9LFxuICAgICAgX3BhcnRzOiB7IGVudW1lcmFibGU6IGZhbHNlIH0sXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHN0cmluZyBpbmRpY2F0aW5nIHRoZSBNSU1FIHR5cGUgb2YgdGhlIGRhdGEgY29udGFpbmVkIGluIHRoZSBCbG9iLlxuICAgKiBJZiB0aGUgdHlwZSBpcyB1bmtub3duLCB0aGlzIHN0cmluZyBpcyBlbXB0eS5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCB0eXBlKCkge1xuICAgIHJldHVybiB0aGlzLl90eXBlXG4gIH1cbiAgLyoqXG4gICAqIFRoZSBzaXplLCBpbiBieXRlcywgb2YgdGhlIGRhdGEgY29udGFpbmVkIGluIHRoZSBCbG9iIG9iamVjdC5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBzaXplKCkge1xuICAgIHJldHVybiB0aGlzLl9zaXplXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIG5ldyBCbG9iIG9iamVjdCBjb250YWluaW5nIHRoZSBkYXRhIGluIHRoZSBzcGVjaWZpZWQgcmFuZ2Ugb2ZcbiAgICogYnl0ZXMgb2YgdGhlIGJsb2Igb24gd2hpY2ggaXQncyBjYWxsZWQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gLSBBbiBpbmRleCBpbnRvIHRoZSBCbG9iIGluZGljYXRpbmcgdGhlIGZpcnN0XG4gICAqIGJ5dGUgdG8gaW5jbHVkZSBpbiB0aGUgbmV3IEJsb2IuIElmIHlvdSBzcGVjaWZ5IGEgbmVnYXRpdmUgdmFsdWUsIGl0J3NcbiAgICogdHJlYXRlZCBhcyBhbiBvZmZzZXQgZnJvbSB0aGUgZW5kIG9mIHRoZSBCbG9iIHRvd2FyZCB0aGUgYmVnaW5uaW5nLiBGb3JcbiAgICogZXhhbXBsZSwgYC0xMGAgd291bGQgYmUgdGhlIDEwdGggZnJvbSBsYXN0IGJ5dGUgaW4gdGhlIEJsb2IuIFRoZSBkZWZhdWx0XG4gICAqIHZhbHVlIGlzIGAwYC4gSWYgeW91IHNwZWNpZnkgYSB2YWx1ZSBmb3Igc3RhcnQgdGhhdCBpcyBsYXJnZXIgdGhhbiB0aGVcbiAgICogc2l6ZSBvZiB0aGUgc291cmNlIEJsb2IsIHRoZSByZXR1cm5lZCBCbG9iIGhhcyBzaXplIDAgYW5kIGNvbnRhaW5zIG5vXG4gICAqIGRhdGEuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kXSAtIEFuIGluZGV4IGludG8gdGhlIGBCbG9iYCBpbmRpY2F0aW5nIHRoZSBmaXJzdCBieXRlXG4gICAqICB0aGF0IHdpbGwgKm5vdCogYmUgaW5jbHVkZWQgaW4gdGhlIG5ldyBgQmxvYmAgKGkuZS4gdGhlIGJ5dGUgZXhhY3RseSBhdFxuICAgKiB0aGlzIGluZGV4IGlzIG5vdCBpbmNsdWRlZCkuIElmIHlvdSBzcGVjaWZ5IGEgbmVnYXRpdmUgdmFsdWUsIGl0J3MgdHJlYXRlZFxuICAgKiBhcyBhbiBvZmZzZXQgZnJvbSB0aGUgZW5kIG9mIHRoZSBCbG9iIHRvd2FyZCB0aGUgYmVnaW5uaW5nLiBGb3IgZXhhbXBsZSxcbiAgICogYC0xMGAgd291bGQgYmUgdGhlIDEwdGggZnJvbSBsYXN0IGJ5dGUgaW4gdGhlIGBCbG9iYC4gVGhlIGRlZmF1bHQgdmFsdWUgaXNcbiAgICogc2l6ZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFt0eXBlXSAtIFRoZSBjb250ZW50IHR5cGUgdG8gYXNzaWduIHRvIHRoZSBuZXcgQmxvYjtcbiAgICogdGhpcyB3aWxsIGJlIHRoZSB2YWx1ZSBvZiBpdHMgdHlwZSBwcm9wZXJ0eS4gVGhlIGRlZmF1bHQgdmFsdWUgaXMgYW4gZW1wdHlcbiAgICogc3RyaW5nLlxuICAgKiBAcmV0dXJucyB7QmxvYn1cbiAgICovXG4gIHNsaWNlKHN0YXJ0ID0gMCwgZW5kID0gdGhpcy5zaXplLCB0eXBlID0gXCJcIikge1xuICAgIGNvbnN0IHsgc2l6ZSwgX3BhcnRzIH0gPSB0aGlzXG4gICAgbGV0IG9mZnNldCA9IHN0YXJ0IDwgMCA/IE1hdGgubWF4KHNpemUgKyBzdGFydCwgMCkgOiBNYXRoLm1pbihzdGFydCwgc2l6ZSlcblxuICAgIGxldCBsaW1pdCA9IGVuZCA8IDAgPyBNYXRoLm1heChzaXplICsgZW5kLCAwKSA6IE1hdGgubWluKGVuZCwgc2l6ZSlcbiAgICBjb25zdCBzcGFuID0gTWF0aC5tYXgobGltaXQgLSBvZmZzZXQsIDApXG4gICAgY29uc3QgYmxvYiA9IG5ldyBCbG9iKFtdLCB7IHR5cGUgfSlcblxuICAgIGlmIChzcGFuID09PSAwKSB7XG4gICAgICByZXR1cm4gYmxvYlxuICAgIH1cblxuICAgIGxldCBibG9iU2l6ZSA9IDBcbiAgICBjb25zdCBibG9iUGFydHMgPSBbXVxuICAgIGZvciAoY29uc3QgcGFydCBvZiBfcGFydHMpIHtcbiAgICAgIGNvbnN0IHsgYnl0ZUxlbmd0aCB9ID0gcGFydFxuICAgICAgaWYgKG9mZnNldCA+IDAgJiYgYnl0ZUxlbmd0aCA8PSBvZmZzZXQpIHtcbiAgICAgICAgb2Zmc2V0IC09IGJ5dGVMZW5ndGhcbiAgICAgICAgbGltaXQgLT0gYnl0ZUxlbmd0aFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgY2h1bmsgPSBwYXJ0LnN1YmFycmF5KG9mZnNldCwgTWF0aC5taW4oYnl0ZUxlbmd0aCwgbGltaXQpKVxuICAgICAgICBibG9iUGFydHMucHVzaChjaHVuaylcbiAgICAgICAgYmxvYlNpemUgKz0gY2h1bmsuYnl0ZUxlbmd0aFxuICAgICAgICAvLyBubyBsb25nZXIgbmVlZCB0byB0YWtlIHRoYXQgaW50byBhY2NvdW50XG4gICAgICAgIG9mZnNldCA9IDBcblxuICAgICAgICAvLyBkb24ndCBhZGQgdGhlIG92ZXJmbG93IHRvIG5ldyBibG9iUGFydHNcbiAgICAgICAgaWYgKGJsb2JTaXplID49IHNwYW4pIHtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgYmxvYi5fcGFydHMgPSBibG9iUGFydHNcbiAgICBibG9iLl9zaXplID0gYmxvYlNpemVcblxuICAgIHJldHVybiBibG9iXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIGFuIEFycmF5QnVmZmVyIGNvbnRhaW5pbmcgdGhlIGVudGlyZVxuICAgKiBjb250ZW50cyBvZiB0aGUgQmxvYiBhcyBiaW5hcnkgZGF0YS5cbiAgICogQHJldHVybnMge1Byb21pc2U8QXJyYXlCdWZmZXI+fVxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlcXVpcmUtYXdhaXRcbiAgYXN5bmMgYXJyYXlCdWZmZXIoKSB7XG4gICAgY29uc3QgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKHRoaXMuc2l6ZSlcbiAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlcilcbiAgICBsZXQgb2Zmc2V0ID0gMFxuICAgIGZvciAoY29uc3QgcGFydCBvZiB0aGlzLl9wYXJ0cykge1xuICAgICAgYnl0ZXMuc2V0KHBhcnQsIG9mZnNldClcbiAgICAgIG9mZnNldCArPSBwYXJ0LmJ5dGVMZW5ndGhcbiAgICB9XG4gICAgcmV0dXJuIGJ1ZmZlclxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCBhIFVTVlN0cmluZyBjb250YWluaW5nIHRoZSBlbnRpcmVcbiAgICogY29udGVudHMgb2YgdGhlIEJsb2IgaW50ZXJwcmV0ZWQgYXMgVVRGLTggdGV4dC5cbiAgICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nPn1cbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZXF1aXJlLWF3YWl0XG4gIGFzeW5jIHRleHQoKSB7XG4gICAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpXG4gICAgbGV0IHRleHQgPSBcIlwiXG4gICAgZm9yIChjb25zdCBwYXJ0IG9mIHRoaXMuX3BhcnRzKSB7XG4gICAgICB0ZXh0ICs9IGRlY29kZXIuZGVjb2RlKHBhcnQpXG4gICAgfVxuICAgIHJldHVybiB0ZXh0XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMge0Jsb2JTdHJlYW19XG4gICAqL1xuICBzdHJlYW0oKSB7XG4gICAgcmV0dXJuIG5ldyBCbG9iU3RyZWFtKHRoaXMuX3BhcnRzKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IEJsb2JdXCJcbiAgfVxuXG4gIGdldCBbU3ltYm9sLnRvU3RyaW5nVGFnXSgpIHtcbiAgICByZXR1cm4gXCJCbG9iXCJcbiAgfVxufVxuXG4vLyBNYXJraW5nIGV4cG9ydCBhcyBhIERPTSBGaWxlIG9iamVjdCBpbnN0ZWFkIG9mIGN1c3RvbSBjbGFzcy5cbi8qKiBAdHlwZSB7dHlwZW9mIGdsb2JhbFRoaXMuQmxvYn0gKi9cbmNvbnN0IEJsb2IgPSBXZWJCbG9iXG5cbi8qKlxuICogQmxvYiBzdHJlYW0gaXMgYSBgUmVhZGFibGVTdHJlYW1gIGV4dGVuc2lvbiBvcHRpbWl6ZWQgdG8gaGF2ZSBtaW5pbWFsXG4gKiBvdmVyaGVhZCB3aGVuIGNvbnN1bWVkIGFzIGBBc3luY0l0ZXJhYmxlPFVpbnQ4QXJyYXk+YC5cbiAqIEBleHRlbmRzIHtSZWFkYWJsZVN0cmVhbTxVaW50OEFycmF5Pn1cbiAqIEBpbXBsZW1lbnRzIHtBc3luY0l0ZXJhYmxlPFVpbnQ4QXJyYXk+fVxuICovXG5jbGFzcyBCbG9iU3RyZWFtIGV4dGVuZHMgUmVhZGFibGVTdHJlYW0ge1xuICAvKipcbiAgICogQHBhcmFtIHtVaW50OEFycmF5W119IGNodW5rc1xuICAgKi9cbiAgY29uc3RydWN0b3IoY2h1bmtzKSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHN1cGVyKG5ldyBCbG9iU3RyZWFtQ29udHJvbGxlcihjaHVua3MudmFsdWVzKCkpLCB7IHR5cGU6IFwiYnl0ZXNcIiB9KVxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIHRoaXMuX2NodW5rcyA9IGNodW5rc1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbX29wdGlvbnNdXG4gICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW19vcHRpb25zLnByZXZlbnRDYW5jZWxdXG4gICAqIEByZXR1cm5zIHtBc3luY0l0ZXJhdG9yPFVpbnQ4QXJyYXk+fVxuICAgKi9cbiAgYXN5bmMgKltTeW1ib2wuYXN5bmNJdGVyYXRvcl0oX29wdGlvbnMpIHtcbiAgICBjb25zdCByZWFkZXIgPSB0aGlzLmdldFJlYWRlcigpXG4gICAgeWllbGQqIHRoaXMuX2NodW5rc1xuICAgIHJlYWRlci5yZWxlYXNlTG9jaygpXG4gIH1cbn1cblxuY2xhc3MgQmxvYlN0cmVhbUNvbnRyb2xsZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtJdGVyYXRvcjxVaW50OEFycmF5Pn0gY2h1bmtzXG4gICAqL1xuICBjb25zdHJ1Y3RvcihjaHVua3MpIHtcbiAgICB0aGlzLmNodW5rcyA9IGNodW5rc1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7UmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcn0gY29udHJvbGxlclxuICAgKi9cbiAgc3RhcnQoY29udHJvbGxlcikge1xuICAgIHRoaXMud29yayhjb250cm9sbGVyKVxuICAgIHRoaXMuaXNXb3JraW5nID0gZmFsc2VcbiAgICB0aGlzLmlzQ2FuY2VsbGVkID0gZmFsc2VcbiAgfVxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyfSBjb250cm9sbGVyXG4gICAqL1xuICBhc3luYyB3b3JrKGNvbnRyb2xsZXIpIHtcbiAgICBjb25zdCB7IGNodW5rcyB9ID0gdGhpc1xuXG4gICAgdGhpcy5pc1dvcmtpbmcgPSB0cnVlXG4gICAgd2hpbGUgKCF0aGlzLmlzQ2FuY2VsbGVkICYmIChjb250cm9sbGVyLmRlc2lyZWRTaXplIHx8IDApID4gMCkge1xuICAgICAgbGV0IG5leHQgPSBudWxsXG4gICAgICB0cnkge1xuICAgICAgICBuZXh0ID0gY2h1bmtzLm5leHQoKVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29udHJvbGxlci5lcnJvcihlcnJvcilcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cblxuICAgICAgaWYgKG5leHQpIHtcbiAgICAgICAgaWYgKCFuZXh0LmRvbmUgJiYgIXRoaXMuaXNDYW5jZWxsZWQpIHtcbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUobmV4dC52YWx1ZSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb250cm9sbGVyLmNsb3NlKClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuaXNXb3JraW5nID0gZmFsc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1JlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJ9IGNvbnRyb2xsZXJcbiAgICovXG4gIHB1bGwoY29udHJvbGxlcikge1xuICAgIGlmICghdGhpcy5pc1dvcmtpbmcpIHtcbiAgICAgIHRoaXMud29yayhjb250cm9sbGVyKVxuICAgIH1cbiAgfVxuICBjYW5jZWwoKSB7XG4gICAgdGhpcy5pc0NhbmNlbGxlZCA9IHRydWVcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBbaW5wdXRdXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5jb25zdCByZWFkVHlwZSA9IChpbnB1dCA9IFwiXCIpID0+IHtcbiAgY29uc3QgdHlwZSA9IFN0cmluZyhpbnB1dCkudG9Mb3dlckNhc2UoKVxuICByZXR1cm4gL1teXFx1MDAyMC1cXHUwMDdFXS8udGVzdCh0eXBlKSA/IFwiXCIgOiB0eXBlXG59XG5cbmV4cG9ydCB7IEJsb2IsIFJlYWRhYmxlU3RyZWFtLCBUZXh0RW5jb2RlciwgVGV4dERlY29kZXIgfVxuIiwgImV4cG9ydCB7IFRleHRFbmNvZGVyLCBUZXh0RGVjb2RlciwgUmVhZGFibGVTdHJlYW0gfSBmcm9tIFwiLi9wYWNrYWdlLmpzXCJcbi8vIGltcG9ydCB7IEJsb2IgYXMgTm9kZUJsb2IgfSBmcm9tIFwiLi9ibG9iLm5vZGUuanNcIlxuaW1wb3J0IHsgQmxvYiBhcyBXZWJCbG9iIH0gZnJvbSBcIi4vYmxvYi5qc1wiXG5cbi8qKiBAdHlwZSB7dHlwZW9mIGdsb2JhbFRoaXMuQmxvYn0gKi9cbi8vIE91ciBmaXJzdCBjaG9pc2UgaXMgdG8gdXNlIGdsb2JhbCBgQmxvYmAgYmVjYXVzZSBpdCBtYXkgYmUgYXZhaWxhYmxlIGUuZy4gaW5cbi8vIGVsZWN0cm9uIHJlbmRlcnJlciBwcm9jZXNzLiBJZiBub3QgYXZhaWxhYmxlIGZhbGwgYmFjayB0byBub2RlIG5hdGl2ZVxuLy8gaW1wbGVtZW50YXRpb24sIGlmIGFsc28gbm90IGF2YWlsYWJsZSB1c2Ugb3VyIGltcGxlbWVudGF0aW9uLlxuZXhwb3J0IGNvbnN0IEJsb2IgPVxuICBnbG9iYWxUaGlzLkJsb2IgfHwgXG4gIC8vIERpc2FibGUgbm9kZSBuYXRpdmUgYmxvYiB1bnRpbCBpbXByYWN0aWNhbCBwZXJmIGlzc3VlIGlzIGZpeGVkXG4gIC8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2lzc3Vlcy80MjEwOFxuICAvLyBOb2RlQmxvYiB8fFxuICBXZWJCbG9iXG4iLCAiaW1wb3J0IHsgQmxvYiB9IGZyb20gXCIuL3BhY2thZ2UuanNcIlxuXG4vKipcbiAqIEBpbXBsZW1lbnRzIHtnbG9iYWxUaGlzLkZpbGV9XG4gKi9cbmV4cG9ydCBjbGFzcyBGaWxlIGV4dGVuZHMgQmxvYiB7XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge0Jsb2JQYXJ0W119IGluaXRcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBBIFVTVlN0cmluZyByZXByZXNlbnRpbmcgdGhlIGZpbGUgbmFtZSBvciB0aGUgcGF0aFxuICAgKiB0byB0aGUgZmlsZS5cbiAgICogQHBhcmFtIHtGaWxlUHJvcGVydHlCYWd9IFtvcHRpb25zXVxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgaW5pdCxcbiAgICBuYW1lID0gcGFuaWMobmV3IFR5cGVFcnJvcihcIkZpbGUgY29uc3RydWN0b3IgcmVxdWlyZXMgbmFtZSBhcmd1bWVudFwiKSksXG4gICAgb3B0aW9ucyA9IHt9XG4gICkge1xuICAgIHN1cGVyKGluaXQsIG9wdGlvbnMpXG4gICAgLy8gUGVyIEZpbGUgQVBJIHNwZWMgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL0ZpbGVBUEkvI2ZpbGUtY29uc3RydWN0b3JcbiAgICAvLyBFdmVyeSBcIi9cIiBjaGFyYWN0ZXIgb2YgZmlsZSBuYW1lIG11c3QgYmUgcmVwbGFjZWQgd2l0aCBhIFwiOlwiLlxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIHRoaXMuX25hbWUgPSBuYW1lXG4gICAgLy8gSXQgYXBwZWFycyB0aGF0IGJyb3dzZXIgZG8gbm90IGZvbGxvdyB0aGUgc3BlYyBoZXJlLlxuICAgIC8vIFN0cmluZyhuYW1lKS5yZXBsYWNlKC9cXC8vZywgXCI6XCIpXG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgdGhpcy5fbGFzdE1vZGlmaWVkID0gb3B0aW9ucy5sYXN0TW9kaWZpZWQgfHwgRGF0ZS5ub3coKVxuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBuYW1lIG9mIHRoZSBmaWxlIHJlZmVyZW5jZWQgYnkgdGhlIEZpbGUgb2JqZWN0LlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IG5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX25hbWVcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgcGF0aCB0aGUgVVJMIG9mIHRoZSBGaWxlIGlzIHJlbGF0aXZlIHRvLlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IHdlYmtpdFJlbGF0aXZlUGF0aCgpIHtcbiAgICByZXR1cm4gXCJcIlxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGxhc3QgbW9kaWZpZWQgdGltZSBvZiB0aGUgZmlsZSwgaW4gbWlsbGlzZWNvbmQgc2luY2UgdGhlIFVOSVhcbiAgICogZXBvY2ggKEphbnVhcnkgMXN0LCAxOTcwIGF0IE1pZG5pZ2h0KS5cbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICovXG4gIGdldCBsYXN0TW9kaWZpZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xhc3RNb2RpZmllZFxuICB9XG5cbiAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCkge1xuICAgIHJldHVybiBcIkZpbGVcIlxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHsqfSBlcnJvclxuICogQHJldHVybnMge25ldmVyfVxuICovXG5jb25zdCBwYW5pYyA9IGVycm9yID0+IHtcbiAgdGhyb3cgZXJyb3Jcbn1cbiIsICJcInVzZSBzdHJpY3RcIlxuXG5pbXBvcnQgeyBCbG9iIH0gZnJvbSBcIi4vcGFja2FnZS5qc1wiXG5pbXBvcnQgeyBGaWxlIGFzIFdlYkZpbGUgfSBmcm9tIFwiLi9maWxlLmpzXCJcblxuLy8gRWxlY3Ryb24tcmVuZGVyZXIgc2hvdWxkIGdldCB0aGUgYnJvd3NlciBpbXBsZW1lbnRhdGlvbiBpbnN0ZWFkIG9mIG5vZGVcbi8vIEJyb3dzZXIgY29uZmlndXJhdGlvbiBpcyBub3QgZW5vdWdoXG5cbi8vIE1hcmtpbmcgZXhwb3J0IGFzIGEgRE9NIEZpbGUgb2JqZWN0IGluc3RlYWQgb2YgY3VzdG9tIGNsYXNzLlxuLyoqIEB0eXBlIHt0eXBlb2YgZ2xvYmFsVGhpcy5GaWxlfSAqL1xuY29uc3QgRmlsZSA9IHR5cGVvZiBnbG9iYWxUaGlzLkZpbGUgPT09IFwiZnVuY3Rpb25cIiA/IGdsb2JhbFRoaXMuRmlsZSA6IFdlYkZpbGVcblxuZXhwb3J0IHsgRmlsZSwgQmxvYiB9XG4iLCAiLyoqXG4gKiBAaW1wbGVtZW50cyB7Z2xvYmFsVGhpcy5Gb3JtRGF0YX1cbiAqL1xuZXhwb3J0IGNsYXNzIEZvcm1EYXRhIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEZvcm1FbGVtZW50fSBbZm9ybV1cbiAgICovXG4gIGNvbnN0cnVjdG9yKGZvcm0pIHtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZWFkb25seVxuICAgICAqIEB0eXBlIHtBcnJheTxbc3RyaW5nLCBGb3JtRGF0YUVudHJ5VmFsdWVdPn1cbiAgICAgKi9cbiAgICB0aGlzLl9lbnRyaWVzID0gW11cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9lbnRyaWVzXCIsIHsgZW51bWVyYWJsZTogZmFsc2UgfSlcblxuICAgIGlmIChpc0hUTUxGb3JtRWxlbWVudChmb3JtKSkge1xuICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGZvcm0uZWxlbWVudHMpIHtcbiAgICAgICAgaWYgKGlzU2VsZWN0RWxlbWVudChlbGVtZW50KSkge1xuICAgICAgICAgIGZvciAoY29uc3Qgb3B0aW9uIG9mIGVsZW1lbnQub3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKG9wdGlvbi5zZWxlY3RlZCkge1xuICAgICAgICAgICAgICB0aGlzLmFwcGVuZChlbGVtZW50Lm5hbWUsIG9wdGlvbi52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgIGlzSW5wdXRFbGVtZW50KGVsZW1lbnQpICYmXG4gICAgICAgICAgKGVsZW1lbnQuY2hlY2tlZCB8fCAhW1wicmFkaW9cIiwgXCJjaGVja2JveFwiXS5pbmNsdWRlcyhlbGVtZW50LnR5cGUpKSAmJlxuICAgICAgICAgIGVsZW1lbnQubmFtZVxuICAgICAgICApIHtcbiAgICAgICAgICB0aGlzLmFwcGVuZChlbGVtZW50Lm5hbWUsIGVsZW1lbnQudmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGdldCBbU3ltYm9sLnRvU3RyaW5nVGFnXSgpIHtcbiAgICByZXR1cm4gXCJGb3JtRGF0YVwiXG4gIH1cblxuICAvKipcbiAgICogQXBwZW5kcyBhIG5ldyB2YWx1ZSBvbnRvIGFuIGV4aXN0aW5nIGtleSBpbnNpZGUgYSBGb3JtRGF0YSBvYmplY3QsIG9yIGFkZHNcbiAgICogdGhlIGtleSBpZiBpdCBkb2VzIG5vdCBhbHJlYWR5IGV4aXN0LlxuICAgKlxuICAgKiBUaGUgZGlmZmVyZW5jZSBiZXR3ZWVuIGBzZXRgIGFuZCBgYXBwZW5kYCBpcyB0aGF0IGlmIHRoZSBzcGVjaWZpZWQga2V5XG4gICAqIGFscmVhZHkgZXhpc3RzLCBgc2V0YCB3aWxsIG92ZXJ3cml0ZSBhbGwgZXhpc3RpbmcgdmFsdWVzIHdpdGggdGhlIG5ldyBvbmUsXG4gICAqIHdoZXJlYXMgYGFwcGVuZGAgd2lsbCBhcHBlbmQgdGhlIG5ldyB2YWx1ZSBvbnRvIHRoZSBlbmQgb2YgdGhlIGV4aXN0aW5nXG4gICAqIHNldCBvZiB2YWx1ZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfEJsb2J8RmlsZX0gdmFsdWUgLSBUaGUgbmFtZSBvZiB0aGUgZmllbGQgd2hvc2UgZGF0YSBpc1xuICAgKiBjb250YWluZWQgaW4gdmFsdWUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbZmlsZW5hbWVdIC0gVGhlIGZpbGVuYW1lIHJlcG9ydGVkIHRvIHRoZSBzZXJ2ZXIsIHdoZW4gYVxuICAgKiB2YWx1ZSBpcyBhIGBCbG9iYCBvciBhIGBGaWxlYC4gVGhlIGRlZmF1bHQgZmlsZW5hbWUgZm9yIGEgYEJsb2JgIG9iamVjdHMgaXNcbiAgICogYFwiYmxvYlwiYC4gVGhlIGRlZmF1bHQgZmlsZW5hbWUgZm9yIGEgYEZpbGVgIGlzIHRoZSBpdCdzIG5hbWUuXG4gICAqL1xuICBhcHBlbmQoXG4gICAgbmFtZSxcbiAgICB2YWx1ZSA9IHBhbmljKFxuICAgICAgbmV3IFR5cGVFcnJvcihcIkZvcm1EYXRhLmFwcGVuZDogcmVxdWlyZXMgYXQgbGVhc3QgMiBhcmd1bWVudHNcIilcbiAgICApLFxuICAgIGZpbGVuYW1lXG4gICkge1xuICAgIHRoaXMuX2VudHJpZXMucHVzaChbbmFtZSwgdG9FbnRyeVZhbHVlKHZhbHVlLCBmaWxlbmFtZSldKVxuICB9XG5cbiAgLyoqXG4gICAqIERlbGV0ZXMgYSBrZXkgYW5kIGFsbCBpdHMgdmFsdWVzIGZyb20gYSBGb3JtRGF0YSBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqL1xuICBkZWxldGUoXG4gICAgbmFtZSA9IHBhbmljKG5ldyBUeXBlRXJyb3IoXCJGb3JtRGF0YS5kZWxldGU6IHJlcXVpcmVzIHN0cmluZyBhcmd1bWVudFwiKSlcbiAgKSB7XG4gICAgY29uc3QgZW50cmllcyA9IHRoaXMuX2VudHJpZXNcbiAgICBsZXQgaW5kZXggPSAwXG4gICAgd2hpbGUgKGluZGV4IDwgZW50cmllcy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IFtlbnRyeU5hbWVdID0gLyoqIEB0eXBlIHtbc3RyaW5nLCBGb3JtRGF0YUVudHJ5VmFsdWVdfSovIChcbiAgICAgICAgZW50cmllc1tpbmRleF1cbiAgICAgIClcbiAgICAgIGlmIChlbnRyeU5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgZW50cmllcy5zcGxpY2UoaW5kZXgsIDEpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbmRleCsrXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGZpcnN0IHZhbHVlIGFzc29jaWF0ZWQgd2l0aCBhIGdpdmVuIGtleSBmcm9tIHdpdGhpbiBhXG4gICAqIEZvcm1EYXRhIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHJldHVybnMge0Zvcm1EYXRhRW50cnlWYWx1ZXxudWxsfVxuICAgKi9cblxuICBnZXQobmFtZSA9IHBhbmljKG5ldyBUeXBlRXJyb3IoXCJGb3JtRGF0YS5nZXQ6IHJlcXVpcmVzIHN0cmluZyBhcmd1bWVudFwiKSkpIHtcbiAgICBmb3IgKGNvbnN0IFtlbnRyeU5hbWUsIHZhbHVlXSBvZiB0aGlzLl9lbnRyaWVzKSB7XG4gICAgICBpZiAoZW50cnlOYW1lID09PSBuYW1lKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gYXJyYXkgb2YgYWxsIHRoZSB2YWx1ZXMgYXNzb2NpYXRlZCB3aXRoIGEgZ2l2ZW4ga2V5IGZyb20gd2l0aGluXG4gICAqIGEgRm9ybURhdGEuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEByZXR1cm5zIHtGb3JtRGF0YUVudHJ5VmFsdWVbXX1cbiAgICovXG4gIGdldEFsbChcbiAgICBuYW1lID0gcGFuaWMobmV3IFR5cGVFcnJvcihcIkZvcm1EYXRhLmdldEFsbDogcmVxdWlyZXMgc3RyaW5nIGFyZ3VtZW50XCIpKVxuICApIHtcbiAgICBjb25zdCB2YWx1ZXMgPSBbXVxuICAgIGZvciAoY29uc3QgW2VudHJ5TmFtZSwgdmFsdWVdIG9mIHRoaXMuX2VudHJpZXMpIHtcbiAgICAgIGlmIChlbnRyeU5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgdmFsdWVzLnB1c2godmFsdWUpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZXNcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgYm9vbGVhbiBzdGF0aW5nIHdoZXRoZXIgYSBGb3JtRGF0YSBvYmplY3QgY29udGFpbnMgYSBjZXJ0YWluIGtleS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICovXG5cbiAgaGFzKG5hbWUgPSBwYW5pYyhuZXcgVHlwZUVycm9yKFwiRm9ybURhdGEuaGFzOiByZXF1aXJlcyBzdHJpbmcgYXJndW1lbnRcIikpKSB7XG4gICAgZm9yIChjb25zdCBbZW50cnlOYW1lXSBvZiB0aGlzLl9lbnRyaWVzKSB7XG4gICAgICBpZiAoZW50cnlOYW1lID09PSBuYW1lKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgYSBuZXcgdmFsdWUgZm9yIGFuIGV4aXN0aW5nIGtleSBpbnNpZGUgYSBGb3JtRGF0YSBvYmplY3QsIG9yIGFkZHMgdGhlXG4gICAqIGtleS92YWx1ZSBpZiBpdCBkb2VzIG5vdCBhbHJlYWR5IGV4aXN0LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0ge3N0cmluZ3xCbG9ifEZpbGV9IHZhbHVlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbZmlsZW5hbWVdXG4gICAqL1xuXG4gIHNldChcbiAgICBuYW1lLFxuICAgIHZhbHVlID0gcGFuaWMobmV3IFR5cGVFcnJvcihcIkZvcm1EYXRhLnNldDogcmVxdWlyZXMgYXQgbGVhc3QgMiBhcmd1bWVudHNcIikpLFxuICAgIGZpbGVuYW1lXG4gICkge1xuICAgIGxldCBpbmRleCA9IDBcbiAgICBjb25zdCB7IF9lbnRyaWVzOiBlbnRyaWVzIH0gPSB0aGlzXG4gICAgY29uc3QgZW50cnlWYWx1ZSA9IHRvRW50cnlWYWx1ZSh2YWx1ZSwgZmlsZW5hbWUpXG4gICAgbGV0IHdhc1NldCA9IGZhbHNlXG4gICAgd2hpbGUgKGluZGV4IDwgZW50cmllcy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGVudHJ5ID0gLyoqIEB0eXBlIHtbc3RyaW5nLCBGb3JtRGF0YUVudHJ5VmFsdWVdfSovIChlbnRyaWVzW2luZGV4XSlcbiAgICAgIGlmIChlbnRyeVswXSA9PT0gbmFtZSkge1xuICAgICAgICBpZiAod2FzU2V0KSB7XG4gICAgICAgICAgZW50cmllcy5zcGxpY2UoaW5kZXgsIDEpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2FzU2V0ID0gdHJ1ZVxuICAgICAgICAgIGVudHJ5WzFdID0gZW50cnlWYWx1ZVxuICAgICAgICAgIGluZGV4KytcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5kZXgrK1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghd2FzU2V0KSB7XG4gICAgICBlbnRyaWVzLnB1c2goW25hbWUsIGVudHJ5VmFsdWVdKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgcmV0dXJucyBhbiBpdGVyYXRvciBhbGxvd2luZyB0byBnbyB0aHJvdWdoIGFsbCBrZXkvdmFsdWUgcGFpcnNcbiAgICogY29udGFpbmVkIGluIHRoaXMgb2JqZWN0LlxuICAgKi9cbiAgZW50cmllcygpIHtcbiAgICByZXR1cm4gdGhpcy5fZW50cmllcy52YWx1ZXMoKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gaXRlcmF0b3IgYWxsb3dpbmcgdG8gZ28gdGhyb3VnaCBhbGwga2V5cyBvZiB0aGUga2V5L3ZhbHVlIHBhaXJzXG4gICAqIGNvbnRhaW5lZCBpbiB0aGlzIG9iamVjdC5cbiAgICpcbiAgICogQHJldHVybnMge0l0ZXJhYmxlSXRlcmF0b3I8c3RyaW5nPn1cbiAgICovXG4gICprZXlzKCkge1xuICAgIGZvciAoY29uc3QgW25hbWVdIG9mIHRoaXMuX2VudHJpZXMpIHtcbiAgICAgIHlpZWxkIG5hbWVcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBpdGVyYXRvciBhbGxvd2luZyB0byBnbyB0aHJvdWdoIGFsbCB2YWx1ZXMgY29udGFpbmVkIGluIHRoaXNcbiAgICogb2JqZWN0LlxuICAgKlxuICAgKiBAcmV0dXJucyB7SXRlcmFibGVJdGVyYXRvcjxGb3JtRGF0YUVudHJ5VmFsdWU+fVxuICAgKi9cbiAgKnZhbHVlcygpIHtcbiAgICBmb3IgKGNvbnN0IFtfLCB2YWx1ZV0gb2YgdGhpcy5fZW50cmllcykge1xuICAgICAgeWllbGQgdmFsdWVcbiAgICB9XG4gIH1cblxuICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZW50cmllcy52YWx1ZXMoKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7KHZhbHVlOiBGb3JtRGF0YUVudHJ5VmFsdWUsIGtleTogc3RyaW5nLCBwYXJlbnQ6IGdsb2JhbFRoaXMuRm9ybURhdGEpID0+IHZvaWR9IGZuXG4gICAqIEBwYXJhbSB7YW55fSBbdGhpc0FyZ11cbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBmb3JFYWNoKGZuLCB0aGlzQXJnKSB7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgdGhpcy5fZW50cmllcykge1xuICAgICAgZm4uY2FsbCh0aGlzQXJnLCB2YWx1ZSwga2V5LCB0aGlzKVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuICogQHJldHVybnMge3ZhbHVlIGlzIEhUTUxGb3JtRWxlbWVudH1cbiAqL1xuY29uc3QgaXNIVE1MRm9ybUVsZW1lbnQgPSB2YWx1ZSA9PlxuICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpID09PSBcIltvYmplY3QgSFRNTEZvcm1FbGVtZW50XVwiXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8QmxvYnxGaWxlfSB2YWx1ZVxuICogQHBhcmFtIHtzdHJpbmd9IFtmaWxlbmFtZV1cbiAqIEByZXR1cm5zIHtGb3JtRGF0YUVudHJ5VmFsdWV9XG4gKi9cbmNvbnN0IHRvRW50cnlWYWx1ZSA9ICh2YWx1ZSwgZmlsZW5hbWUpID0+IHtcbiAgaWYgKGlzRmlsZSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmlsZW5hbWUgIT0gbnVsbCA/IG5ldyBCbG9iRmlsZShbdmFsdWVdLCBmaWxlbmFtZSwgdmFsdWUpIDogdmFsdWVcbiAgfSBlbHNlIGlmIChpc0Jsb2IodmFsdWUpKSB7XG4gICAgcmV0dXJuIG5ldyBCbG9iRmlsZShbdmFsdWVdLCBmaWxlbmFtZSAhPSBudWxsID8gZmlsZW5hbWUgOiBcImJsb2JcIilcbiAgfSBlbHNlIHtcbiAgICBpZiAoZmlsZW5hbWUgIT0gbnVsbCAmJiBmaWxlbmFtZSAhPSBcIlwiKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICBcImZpbGVuYW1lIGlzIG9ubHkgc3VwcG9ydGVkIHdoZW4gdmFsdWUgaXMgQmxvYiBvciBGaWxlXCJcbiAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIGAke3ZhbHVlfWBcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuICogQHJldHVybnMge3ZhbHVlIGlzIEZpbGV9XG4gKi9cbmNvbnN0IGlzRmlsZSA9IHZhbHVlID0+XG4gIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09IFwiW29iamVjdCBGaWxlXVwiICYmXG4gIHR5cGVvZiB2YWx1ZS5uYW1lID09PSBcInN0cmluZ1wiXG5cbi8qKlxuICogQHBhcmFtIHthbnl9IHZhbHVlXG4gKiBAcmV0dXJucyB7dmFsdWUgaXMgQmxvYn1cbiAqL1xuY29uc3QgaXNCbG9iID0gdmFsdWUgPT5cbiAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gXCJbb2JqZWN0IEJsb2JdXCJcblxuLyoqXG4gKiBTaW1wbGUgYEZpbGVgIGltcGxlbWVudGF0aW9uIHRoYXQganVzdCB3cmFwcyBhIGdpdmVuIGJsb2IuXG4gKiBAaW1wbGVtZW50cyB7Z2xvYmFsVGhpcy5GaWxlfVxuICovXG5jb25zdCBCbG9iRmlsZSA9IGNsYXNzIEZpbGUge1xuICAvKipcbiAgICogQHBhcmFtIHtbQmxvYl19IHBhcnRzXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7RmlsZVByb3BlcnR5QmFnfSBbb3B0aW9uc11cbiAgICovXG4gIGNvbnN0cnVjdG9yKFtibG9iXSwgbmFtZSwgeyBsYXN0TW9kaWZpZWQgPSBEYXRlLm5vdygpIH0gPSB7fSkge1xuICAgIHRoaXMuYmxvYiA9IGJsb2JcbiAgICB0aGlzLm5hbWUgPSBuYW1lXG4gICAgdGhpcy5sYXN0TW9kaWZpZWQgPSBsYXN0TW9kaWZpZWRcbiAgfVxuICBnZXQgd2Via2l0UmVsYXRpdmVQYXRoKCkge1xuICAgIHJldHVybiBcIlwiXG4gIH1cbiAgZ2V0IHNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuYmxvYi5zaXplXG4gIH1cbiAgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuYmxvYi50eXBlXG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnRdXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kXVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2NvbnRlbnRUeXBlXVxuICAgKi9cbiAgc2xpY2Uoc3RhcnQsIGVuZCwgY29udGVudFR5cGUpIHtcbiAgICByZXR1cm4gdGhpcy5ibG9iLnNsaWNlKHN0YXJ0LCBlbmQsIGNvbnRlbnRUeXBlKVxuICB9XG4gIHN0cmVhbSgpIHtcbiAgICByZXR1cm4gdGhpcy5ibG9iLnN0cmVhbSgpXG4gIH1cbiAgdGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy5ibG9iLnRleHQoKVxuICB9XG4gIGFycmF5QnVmZmVyKCkge1xuICAgIHJldHVybiB0aGlzLmJsb2IuYXJyYXlCdWZmZXIoKVxuICB9XG4gIGdldCBbU3ltYm9sLnRvU3RyaW5nVGFnXSgpIHtcbiAgICByZXR1cm4gXCJGaWxlXCJcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7Kn0gZXJyb3JcbiAqIEByZXR1cm5zIHtuZXZlcn1cbiAqL1xuY29uc3QgcGFuaWMgPSBlcnJvciA9PiB7XG4gIHRocm93IGVycm9yXG59XG5cbi8qKlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge2VsZW1lbnQgaXMgSFRNTFNlbGVjdEVsZW1lbnR9XG4gKi9cbmZ1bmN0aW9uIGlzU2VsZWN0RWxlbWVudChlbGVtZW50KSB7XG4gIHJldHVybiBlbGVtZW50LnRhZ05hbWUgPT09IFwiU0VMRUNUXCI7XG59XG5cbi8qKlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge2VsZW1lbnQgaXMgSFRNTElucHV0RWxlbWVudH1cbiAqL1xuZnVuY3Rpb24gaXNJbnB1dEVsZW1lbnQoZWxlbWVudCkge1xuICByZXR1cm4gZWxlbWVudC50YWdOYW1lID09PSBcIklOUFVUXCIgfHwgZWxlbWVudC50YWdOYW1lID09PSBcIlRFWFRBUkVBXCI7XG59XG4iLCAiLy8gQHRzLWNoZWNrXG5cInVzZSBzdHJpY3RcIlxuXG5pbXBvcnQgKiBhcyBwb2x5ZmlsbCBmcm9tIFwiLi9mb3JtLWRhdGEuanNcIlxuXG4vLyBFbGVjdHJvbi1yZW5kZXJlciBzaG91bGQgZ2V0IHRoZSBicm93c2VyIGltcGxlbWVudGF0aW9uIGluc3RlYWQgb2Ygbm9kZVxuLy8gd2hpY2ggaXMgd2h5IHdlIGNoZWNrIGdsb2JhbCBmaXJzdC5cbmV4cG9ydCBjb25zdCBGb3JtRGF0YSA9XG4gIHR5cGVvZiBnbG9iYWxUaGlzLkZvcm1EYXRhID09PSBcImZ1bmN0aW9uXCJcbiAgICA/IGdsb2JhbFRoaXMuRm9ybURhdGFcbiAgICA6IHBvbHlmaWxsLkZvcm1EYXRhXG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnQgY2xhc3MgRmV0Y2hCYXNlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG5cdC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSBcblx0ICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihtZXNzYWdlLCB0eXBlKSB7XG5cdFx0c3VwZXIobWVzc2FnZSk7XG5cdFx0Ly8gSGlkZSBjdXN0b20gZXJyb3IgaW1wbGVtZW50YXRpb24gZGV0YWlscyBmcm9tIGVuZC11c2Vyc1xuXHRcdEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpO1xuXG5cdFx0dGhpcy50eXBlID0gdHlwZTtcblx0fVxuXG5cdGdldCBuYW1lKCkge1xuXHRcdHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG5cdH1cblxuXHRnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG5cdFx0cmV0dXJuIHRoaXMuY29uc3RydWN0b3IubmFtZTtcblx0fVxufVxuXG4iLCAiXG5pbXBvcnQge0ZldGNoQmFzZUVycm9yfSBmcm9tICcuL2Jhc2UuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHt7XG4gKiBhZGRyZXNzPzogc3RyaW5nXG4gKiBjb2RlOiBzdHJpbmdcbiAqIGRlc3Q/OiBzdHJpbmdcbiAqIGVycm5vOiBudW1iZXJcbiAqIGluZm8/OiBvYmplY3RcbiAqIG1lc3NhZ2U6IHN0cmluZ1xuICogcGF0aD86IHN0cmluZ1xuICogcG9ydD86IG51bWJlclxuICogc3lzY2FsbDogc3RyaW5nXG4gKiB9fSBTeXN0ZW1FcnJvclxuKi9cblxuLyoqXG4gKiBGZXRjaEVycm9yIGludGVyZmFjZSBmb3Igb3BlcmF0aW9uYWwgZXJyb3JzXG4gKi9cbmV4cG9ydCBjbGFzcyBGZXRjaEVycm9yIGV4dGVuZHMgRmV0Y2hCYXNlRXJyb3Ige1xuXHQvKipcblx0ICogQHBhcmFtICB7c3RyaW5nfSBtZXNzYWdlIC0gICAgICBFcnJvciBtZXNzYWdlIGZvciBodW1hblxuXHQgKiBAcGFyYW0gIHtzdHJpbmd9IHR5cGUgLSAgICAgICAgRXJyb3IgdHlwZSBmb3IgbWFjaGluZVxuXHQgKiBAcGFyYW0gIHtTeXN0ZW1FcnJvcn0gW3N5c3RlbUVycm9yXSAtIEZvciBOb2RlLmpzIHN5c3RlbSBlcnJvclxuXHQgKi9cblx0Y29uc3RydWN0b3IobWVzc2FnZSwgdHlwZSwgc3lzdGVtRXJyb3IpIHtcblx0XHRzdXBlcihtZXNzYWdlLCB0eXBlKTtcblx0XHQvLyBXaGVuIGVyci50eXBlIGlzIGBzeXN0ZW1gLCBlcnIuZXJyb3JlZFN5c0NhbGwgY29udGFpbnMgc3lzdGVtIGVycm9yIGFuZCBlcnIuY29kZSBjb250YWlucyBzeXN0ZW0gZXJyb3IgY29kZVxuXHRcdGlmIChzeXN0ZW1FcnJvcikge1xuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW11bHRpLWFzc2lnblxuXHRcdFx0dGhpcy5jb2RlID0gdGhpcy5lcnJubyA9IHN5c3RlbUVycm9yLmNvZGU7XG5cdFx0XHR0aGlzLmVycm9yZWRTeXNDYWxsID0gc3lzdGVtRXJyb3Iuc3lzY2FsbDtcblx0XHR9XG5cdH1cbn1cbiIsICJpbXBvcnQge3JhbmRvbUJ5dGVzfSBmcm9tICdjcnlwdG8nO1xuaW1wb3J0IHsgaXRlcmF0ZU11bHRpcGFydCB9IGZyb20gJ0B3ZWIzLXN0b3JhZ2UvbXVsdGlwYXJ0LXBhcnNlcic7XG5pbXBvcnQgeyBGb3JtRGF0YSwgRmlsZSB9IGZyb20gJy4uL3BhY2thZ2UuanMnO1xuaW1wb3J0IHsgaXNCbG9iIH0gZnJvbSAnLi9pcy5qcyc7XG5cbmNvbnN0IGNhcnJpYWdlID0gJ1xcclxcbic7XG5jb25zdCBkYXNoZXMgPSAnLScucmVwZWF0KDIpO1xuY29uc3QgY2FycmlhZ2VMZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aChjYXJyaWFnZSk7XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGJvdW5kYXJ5XG4gKi9cbmNvbnN0IGdldEZvb3RlciA9IGJvdW5kYXJ5ID0+IGAke2Rhc2hlc30ke2JvdW5kYXJ5fSR7ZGFzaGVzfSR7Y2FycmlhZ2UucmVwZWF0KDIpfWA7XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGJvdW5kYXJ5XG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHsqfSBmaWVsZFxuICpcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZ2V0SGVhZGVyKGJvdW5kYXJ5LCBuYW1lLCBmaWVsZCkge1xuXHRsZXQgaGVhZGVyID0gJyc7XG5cblx0aGVhZGVyICs9IGAke2Rhc2hlc30ke2JvdW5kYXJ5fSR7Y2FycmlhZ2V9YDtcblx0aGVhZGVyICs9IGBDb250ZW50LURpc3Bvc2l0aW9uOiBmb3JtLWRhdGE7IG5hbWU9XCIke25hbWV9XCJgO1xuXG5cdGlmIChpc0Jsb2IoZmllbGQpKSB7XG5cdFx0Y29uc3QgeyBuYW1lID0gJ2Jsb2InLCB0eXBlIH0gPSAvKiogQHR5cGUge0Jsb2IgJiB7bmFtZT86c3RyaW5nfX0gKi8gKGZpZWxkKTtcblx0XHRoZWFkZXIgKz0gYDsgZmlsZW5hbWU9XCIke25hbWV9XCIke2NhcnJpYWdlfWA7XG5cdFx0aGVhZGVyICs9IGBDb250ZW50LVR5cGU6ICR7dHlwZSB8fCAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJ31gO1xuXHR9XG5cblx0cmV0dXJuIGAke2hlYWRlcn0ke2NhcnJpYWdlLnJlcGVhdCgyKX1gO1xufVxuXG4vKipcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGNvbnN0IGdldEJvdW5kYXJ5ID0gKCkgPT4gcmFuZG9tQnl0ZXMoOCkudG9TdHJpbmcoJ2hleCcpO1xuXG4vKipcbiAqIEBwYXJhbSB7Rm9ybURhdGF9IGZvcm1cbiAqIEBwYXJhbSB7c3RyaW5nfSBib3VuZGFyeVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gKiBmb3JtRGF0YUl0ZXJhdG9yKGZvcm0sIGJvdW5kYXJ5KSB7XG5cdGNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcblx0Zm9yIChjb25zdCBbbmFtZSwgdmFsdWVdIG9mIGZvcm0pIHtcblx0XHR5aWVsZCBlbmNvZGVyLmVuY29kZShnZXRIZWFkZXIoYm91bmRhcnksIG5hbWUsIHZhbHVlKSk7XG5cblx0XHRpZiAoaXNCbG9iKHZhbHVlKSkge1xuXHRcdFx0Ly8gQHRzLWlnbm9yZSAtIHdlIGtub3cgb3VyIHN0cmVhbXMgaW1wbGVtZW50IGF5c25jIGl0ZXJhdGlvblxuXHRcdFx0eWllbGQgKiB2YWx1ZS5zdHJlYW0oKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0eWllbGQgZW5jb2Rlci5lbmNvZGUodmFsdWUpO1xuXHRcdH1cblxuXHRcdHlpZWxkIGVuY29kZXIuZW5jb2RlKGNhcnJpYWdlKTtcblx0fVxuXG5cdHlpZWxkIGVuY29kZXIuZW5jb2RlKGdldEZvb3Rlcihib3VuZGFyeSkpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Rm9ybURhdGF9IGZvcm1cbiAqIEBwYXJhbSB7c3RyaW5nfSBib3VuZGFyeVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Rm9ybURhdGFMZW5ndGgoZm9ybSwgYm91bmRhcnkpIHtcblx0bGV0IGxlbmd0aCA9IDA7XG5cblx0Zm9yIChjb25zdCBbbmFtZSwgdmFsdWVdIG9mIGZvcm0pIHtcblx0XHRsZW5ndGggKz0gQnVmZmVyLmJ5dGVMZW5ndGgoZ2V0SGVhZGVyKGJvdW5kYXJ5LCBuYW1lLCB2YWx1ZSkpO1xuXG5cdFx0aWYgKGlzQmxvYih2YWx1ZSkpIHtcblx0XHRcdGxlbmd0aCArPSB2YWx1ZS5zaXplO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRsZW5ndGggKz0gQnVmZmVyLmJ5dGVMZW5ndGgoU3RyaW5nKHZhbHVlKSk7XG5cdFx0fVxuXG5cdFx0bGVuZ3RoICs9IGNhcnJpYWdlTGVuZ3RoO1xuXHR9XG5cblx0bGVuZ3RoICs9IEJ1ZmZlci5ieXRlTGVuZ3RoKGdldEZvb3Rlcihib3VuZGFyeSkpO1xuXG5cdHJldHVybiBsZW5ndGg7XG59XG5cbi8qKlxuICogQHBhcmFtIHtCb2R5ICYge2hlYWRlcnM/OkhlYWRlcnN9fSBzb3VyY2VcbiAqL1xuZXhwb3J0IGNvbnN0IHRvRm9ybURhdGEgPSBhc3luYyAoc291cmNlKSA9PiB7XG4gIGxldCB7IGJvZHksIGhlYWRlcnMgfSA9IHNvdXJjZTtcbiAgY29uc3QgY29udGVudFR5cGUgPSBoZWFkZXJzPy5nZXQoJ0NvbnRlbnQtVHlwZScpIHx8ICcnXG5cbiAgaWYgKGNvbnRlbnRUeXBlLnN0YXJ0c1dpdGgoJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcpICYmIGJvZHkgIT0gbnVsbCkge1xuXHRjb25zdCBmb3JtID0gbmV3IEZvcm1EYXRhKCk7XG5cdGxldCBib2R5VGV4dCA9IGF3YWl0IHNvdXJjZS50ZXh0KCk7XG5cdG5ldyBVUkxTZWFyY2hQYXJhbXMoYm9keVRleHQpLmZvckVhY2goKHYsIGspID0+IGZvcm0uYXBwZW5kKGssIHYpKTtcblx0cmV0dXJuIGZvcm07XG4gIH1cblxuICBjb25zdCBbdHlwZSwgYm91bmRhcnldID0gY29udGVudFR5cGUuc3BsaXQoL1xccyo7XFxzKmJvdW5kYXJ5PS8pXG4gIGlmICh0eXBlID09PSAnbXVsdGlwYXJ0L2Zvcm0tZGF0YScgJiYgYm91bmRhcnkgIT0gbnVsbCAmJiBib2R5ICE9IG51bGwpIHtcbiAgICBjb25zdCBmb3JtID0gbmV3IEZvcm1EYXRhKClcbiAgICBjb25zdCBwYXJ0cyA9IGl0ZXJhdGVNdWx0aXBhcnQoYm9keSwgYm91bmRhcnkpXG4gICAgZm9yIGF3YWl0IChjb25zdCB7IG5hbWUsIGRhdGEsIGZpbGVuYW1lLCBjb250ZW50VHlwZSB9IG9mIHBhcnRzKSB7XG4gICAgICBpZiAodHlwZW9mIGZpbGVuYW1lID09PSAnc3RyaW5nJykge1xuICAgICAgICBmb3JtLmFwcGVuZChuYW1lLCBuZXcgRmlsZShbZGF0YV0sIGZpbGVuYW1lLCB7IHR5cGU6IGNvbnRlbnRUeXBlIH0pKVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZmlsZW5hbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGZvcm0uYXBwZW5kKG5hbWUsIG5ldyBGaWxlKFtdLCAnJywgeyB0eXBlOiBjb250ZW50VHlwZSB9KSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvcm0uYXBwZW5kKG5hbWUsIG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShkYXRhKSwgZmlsZW5hbWUpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmb3JtXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ291bGQgbm90IHBhcnNlIGNvbnRlbnQgYXMgRm9ybURhdGEuJylcbiAgfVxufVxuIiwgImV4cG9ydCBmdW5jdGlvbiBzdHJpbmdUb0FycmF5KHMpIHtcbiAgY29uc3QgdXRmOCA9IHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChzKSk7XG4gIHJldHVybiBVaW50OEFycmF5LmZyb20odXRmOCwgKF8sIGkpID0+IHV0ZjguY2hhckNvZGVBdChpKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gYXJyYXlUb1N0cmluZyhhKSB7XG4gIGNvbnN0IHV0ZjggPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGEpO1xuICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGVzY2FwZSh1dGY4KSk7XG59XG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VBcnJheXMoLi4uYXJyYXlzKSB7XG4gIGNvbnN0IG91dCA9IG5ldyBVaW50OEFycmF5KGFycmF5cy5yZWR1Y2UoKHRvdGFsLCBhcnIpID0+IHRvdGFsICsgYXJyLmxlbmd0aCwgMCkpO1xuICBsZXQgb2Zmc2V0ID0gMDtcbiAgZm9yIChjb25zdCBhcnIgb2YgYXJyYXlzKSB7XG4gICAgb3V0LnNldChhcnIsIG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IGFyci5sZW5ndGg7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBhcnJheXNFcXVhbChhLCBiKSB7XG4gIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59IiwgImltcG9ydCB7XG4gIHN0cmluZ1RvQXJyYXksXG4gIG1lcmdlQXJyYXlzLFxuICBhcnJheVRvU3RyaW5nXG59IGZyb20gJy4vdXRpbHMuanMnO1xuZnVuY3Rpb24gY29lcmNlKGEpIHtcbiAgaWYgKGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgcmV0dXJuIGluZGV4ID0+IGFbaW5kZXhdO1xuICB9XG4gIHJldHVybiBhO1xufVxuZnVuY3Rpb24ganNtZW1jbXAoYnVmMSwgcG9zMSwgYnVmMiwgcG9zMiwgbGVuKSB7XG4gIGNvbnN0IGZuMSA9IGNvZXJjZShidWYxKTtcbiAgY29uc3QgZm4yID0gY29lcmNlKGJ1ZjIpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGZuMShwb3MxICsgaSkgIT09IGZuMihwb3MyICsgaSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBjcmVhdGVPY2N1cmVuY2VUYWJsZShzKSB7XG4gIGNvbnN0IHRhYmxlID0gbmV3IEFycmF5KDI1NikuZmlsbChzLmxlbmd0aCk7XG4gIGlmIChzLmxlbmd0aCA+IDEpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICB0YWJsZVtzW2ldXSA9IHMubGVuZ3RoIC0gMSAtIGk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0YWJsZTtcbn1cbmNvbnN0IE1BVENIID0gU3ltYm9sKCdNYXRjaCcpO1xuY2xhc3MgU3RyZWFtU2VhcmNoIHtcbiAgY29uc3RydWN0b3IobmVlZGxlKSB7XG4gICAgdGhpcy5fbG9va2JlaGluZCA9IG5ldyBVaW50OEFycmF5KCk7XG4gICAgaWYgKHR5cGVvZiBuZWVkbGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLl9uZWVkbGUgPSBuZWVkbGUgPSBzdHJpbmdUb0FycmF5KG5lZWRsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX25lZWRsZSA9IG5lZWRsZTtcbiAgICB9XG4gICAgdGhpcy5fbGFzdENoYXIgPSBuZWVkbGVbbmVlZGxlLmxlbmd0aCAtIDFdO1xuICAgIHRoaXMuX29jYyA9IGNyZWF0ZU9jY3VyZW5jZVRhYmxlKG5lZWRsZSk7XG4gIH1cbiAgZmVlZChjaHVuaykge1xuICAgIGxldCBwb3MgPSAwO1xuICAgIGxldCB0b2tlbnM7XG4gICAgY29uc3QgYWxsVG9rZW5zID0gW107XG4gICAgd2hpbGUgKHBvcyAhPT0gY2h1bmsubGVuZ3RoKSB7XG4gICAgICA7XG4gICAgICBbcG9zLCAuLi50b2tlbnNdID0gdGhpcy5fZmVlZChjaHVuaywgcG9zKTtcbiAgICAgIGFsbFRva2Vucy5wdXNoKC4uLnRva2Vucyk7XG4gICAgfVxuICAgIHJldHVybiBhbGxUb2tlbnM7XG4gIH1cbiAgZW5kKCkge1xuICAgIGNvbnN0IHRhaWwgPSB0aGlzLl9sb29rYmVoaW5kO1xuICAgIHRoaXMuX2xvb2tiZWhpbmQgPSBuZXcgVWludDhBcnJheSgpO1xuICAgIHJldHVybiB0YWlsO1xuICB9XG4gIF9mZWVkKGRhdGEsIGJ1ZlBvcykge1xuICAgIGNvbnN0IHRva2VucyA9IFtdO1xuICAgIGxldCBwb3MgPSAtdGhpcy5fbG9va2JlaGluZC5sZW5ndGg7XG4gICAgaWYgKHBvcyA8IDApIHtcbiAgICAgIHdoaWxlIChwb3MgPCAwICYmIHBvcyA8PSBkYXRhLmxlbmd0aCAtIHRoaXMuX25lZWRsZS5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgY2ggPSB0aGlzLl9jaGFyQXQoZGF0YSwgcG9zICsgdGhpcy5fbmVlZGxlLmxlbmd0aCAtIDEpO1xuICAgICAgICBpZiAoY2ggPT09IHRoaXMuX2xhc3RDaGFyICYmIHRoaXMuX21lbWNtcChkYXRhLCBwb3MsIHRoaXMuX25lZWRsZS5sZW5ndGggLSAxKSkge1xuICAgICAgICAgIGlmIChwb3MgPiAtdGhpcy5fbG9va2JlaGluZC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHRoaXMuX2xvb2tiZWhpbmQuc2xpY2UoMCwgdGhpcy5fbG9va2JlaGluZC5sZW5ndGggKyBwb3MpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdG9rZW5zLnB1c2goTUFUQ0gpO1xuICAgICAgICAgIHRoaXMuX2xvb2tiZWhpbmQgPSBuZXcgVWludDhBcnJheSgpO1xuICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBwb3MgKyB0aGlzLl9uZWVkbGUubGVuZ3RoLFxuICAgICAgICAgICAgLi4udG9rZW5zXG4gICAgICAgICAgXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwb3MgKz0gdGhpcy5fb2NjW2NoXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHBvcyA8IDApIHtcbiAgICAgICAgd2hpbGUgKHBvcyA8IDAgJiYgIXRoaXMuX21lbWNtcChkYXRhLCBwb3MsIGRhdGEubGVuZ3RoIC0gcG9zKSkge1xuICAgICAgICAgIHBvcysrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocG9zID49IDApIHtcbiAgICAgICAgdG9rZW5zLnB1c2godGhpcy5fbG9va2JlaGluZCk7XG4gICAgICAgIHRoaXMuX2xvb2tiZWhpbmQgPSBuZXcgVWludDhBcnJheSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgYnl0ZXNUb0N1dE9mZiA9IHRoaXMuX2xvb2tiZWhpbmQubGVuZ3RoICsgcG9zO1xuICAgICAgICBpZiAoYnl0ZXNUb0N1dE9mZiA+IDApIHtcbiAgICAgICAgICB0b2tlbnMucHVzaCh0aGlzLl9sb29rYmVoaW5kLnNsaWNlKDAsIGJ5dGVzVG9DdXRPZmYpKTtcbiAgICAgICAgICB0aGlzLl9sb29rYmVoaW5kID0gdGhpcy5fbG9va2JlaGluZC5zbGljZShieXRlc1RvQ3V0T2ZmKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9sb29rYmVoaW5kID0gVWludDhBcnJheS5mcm9tKG5ldyBBcnJheSh0aGlzLl9sb29rYmVoaW5kLmxlbmd0aCArIGRhdGEubGVuZ3RoKSwgKF8sIGkpID0+IHRoaXMuX2NoYXJBdChkYXRhLCBpIC0gdGhpcy5fbG9va2JlaGluZC5sZW5ndGgpKTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICBkYXRhLmxlbmd0aCxcbiAgICAgICAgICAuLi50b2tlbnNcbiAgICAgICAgXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcG9zICs9IGJ1ZlBvcztcbiAgICB3aGlsZSAocG9zIDw9IGRhdGEubGVuZ3RoIC0gdGhpcy5fbmVlZGxlLmxlbmd0aCkge1xuICAgICAgY29uc3QgY2ggPSBkYXRhW3BvcyArIHRoaXMuX25lZWRsZS5sZW5ndGggLSAxXTtcbiAgICAgIGlmIChjaCA9PT0gdGhpcy5fbGFzdENoYXIgJiYgZGF0YVtwb3NdID09PSB0aGlzLl9uZWVkbGVbMF0gJiYganNtZW1jbXAodGhpcy5fbmVlZGxlLCAwLCBkYXRhLCBwb3MsIHRoaXMuX25lZWRsZS5sZW5ndGggLSAxKSkge1xuICAgICAgICBpZiAocG9zID4gYnVmUG9zKSB7XG4gICAgICAgICAgdG9rZW5zLnB1c2goZGF0YS5zbGljZShidWZQb3MsIHBvcykpO1xuICAgICAgICB9XG4gICAgICAgIHRva2Vucy5wdXNoKE1BVENIKTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICBwb3MgKyB0aGlzLl9uZWVkbGUubGVuZ3RoLFxuICAgICAgICAgIC4uLnRva2Vuc1xuICAgICAgICBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcG9zICs9IHRoaXMuX29jY1tjaF07XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwb3MgPCBkYXRhLmxlbmd0aCkge1xuICAgICAgd2hpbGUgKHBvcyA8IGRhdGEubGVuZ3RoICYmIChkYXRhW3Bvc10gIT09IHRoaXMuX25lZWRsZVswXSB8fCAhanNtZW1jbXAoZGF0YSwgcG9zLCB0aGlzLl9uZWVkbGUsIDAsIGRhdGEubGVuZ3RoIC0gcG9zKSkpIHtcbiAgICAgICAgKytwb3M7XG4gICAgICB9XG4gICAgICBpZiAocG9zIDwgZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5fbG9va2JlaGluZCA9IGRhdGEuc2xpY2UocG9zKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBvcyA+IDApIHtcbiAgICAgIHRva2Vucy5wdXNoKGRhdGEuc2xpY2UoYnVmUG9zLCBwb3MgPCBkYXRhLmxlbmd0aCA/IHBvcyA6IGRhdGEubGVuZ3RoKSk7XG4gICAgfVxuICAgIHJldHVybiBbXG4gICAgICBkYXRhLmxlbmd0aCxcbiAgICAgIC4uLnRva2Vuc1xuICAgIF07XG4gIH1cbiAgX2NoYXJBdChkYXRhLCBwb3MpIHtcbiAgICBpZiAocG9zIDwgMCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2xvb2tiZWhpbmRbdGhpcy5fbG9va2JlaGluZC5sZW5ndGggKyBwb3NdO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YVtwb3NdO1xuICB9XG4gIF9tZW1jbXAoZGF0YSwgcG9zLCBsZW4pIHtcbiAgICByZXR1cm4ganNtZW1jbXAodGhpcy5fY2hhckF0LmJpbmQodGhpcywgZGF0YSksIHBvcywgdGhpcy5fbmVlZGxlLCAwLCBsZW4pO1xuICB9XG59XG5jbGFzcyBSZWFkYWJsZVN0cmVhbVNlYXJjaCB7XG4gIGNvbnN0cnVjdG9yKG5lZWRsZSwgX3JlYWRhYmxlU3RyZWFtKSB7XG4gICAgdGhpcy5fcmVhZGFibGVTdHJlYW0gPSBfcmVhZGFibGVTdHJlYW07XG4gICAgdGhpcy5fc2VhcmNoID0gbmV3IFN0cmVhbVNlYXJjaChuZWVkbGUpO1xuICB9XG4gIGFzeW5jICpbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgIGNvbnN0IHJlYWRlciA9IHRoaXMuX3JlYWRhYmxlU3RyZWFtLmdldFJlYWRlcigpO1xuICAgIHRyeSB7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICBpZiAocmVzdWx0LmRvbmUpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB5aWVsZCogdGhpcy5fc2VhcmNoLmZlZWQocmVzdWx0LnZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRhaWwgPSB0aGlzLl9zZWFyY2guZW5kKCk7XG4gICAgICBpZiAodGFpbC5sZW5ndGgpIHtcbiAgICAgICAgeWllbGQgdGFpbDtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgcmVhZGVyLnJlbGVhc2VMb2NrKCk7XG4gICAgfVxuICB9XG59XG5jb25zdCBFT1EgPSBTeW1ib2woJ0VuZCBvZiBRdWV1ZScpO1xuY2xhc3MgUXVldWVhYmxlU3RyZWFtU2VhcmNoIHtcbiAgY29uc3RydWN0b3IobmVlZGxlKSB7XG4gICAgdGhpcy5fY2h1bmtzUXVldWUgPSBbXTtcbiAgICB0aGlzLl9jbG9zZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9zZWFyY2ggPSBuZXcgU3RyZWFtU2VhcmNoKG5lZWRsZSk7XG4gIH1cbiAgcHVzaCguLi5jaHVua3MpIHtcbiAgICBpZiAodGhpcy5fY2xvc2VkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBjYWxsIHB1c2ggYWZ0ZXIgY2xvc2UnKTtcbiAgICB9XG4gICAgdGhpcy5fY2h1bmtzUXVldWUucHVzaCguLi5jaHVua3MpO1xuICAgIGlmICh0aGlzLl9ub3RpZnkpIHtcbiAgICAgIHRoaXMuX25vdGlmeSgpO1xuICAgIH1cbiAgfVxuICBjbG9zZSgpIHtcbiAgICBpZiAodGhpcy5fY2xvc2VkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nsb3NlIHdhcyBhbHJlYWR5IGNhbGxlZCcpO1xuICAgIH1cbiAgICB0aGlzLl9jbG9zZWQgPSB0cnVlO1xuICAgIHRoaXMuX2NodW5rc1F1ZXVlLnB1c2goRU9RKTtcbiAgICBpZiAodGhpcy5fbm90aWZ5KSB7XG4gICAgICB0aGlzLl9ub3RpZnkoKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgKltTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGxldCBjaHVuaztcbiAgICAgIHdoaWxlICghKGNodW5rID0gdGhpcy5fY2h1bmtzUXVldWUuc2hpZnQoKSkpIHtcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiB0aGlzLl9ub3RpZnkgPSByZXNvbHZlKTtcbiAgICAgICAgdGhpcy5fbm90aWZ5ID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgaWYgKGNodW5rID09PSBFT1EpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICB5aWVsZCogdGhpcy5fc2VhcmNoLmZlZWQoY2h1bmspO1xuICAgIH1cbiAgICBjb25zdCB0YWlsID0gdGhpcy5fc2VhcmNoLmVuZCgpO1xuICAgIGlmICh0YWlsLmxlbmd0aCkge1xuICAgICAgeWllbGQgdGFpbDtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHNwbGl0Q2h1bmtzKGNodW5rcywgbmVlZGxlKSB7XG4gIGNvbnN0IHNlYXJjaCA9IG5ldyBTdHJlYW1TZWFyY2gobmVlZGxlKTtcbiAgY29uc3Qgb3V0Y2h1bmtzID0gW1tdXTtcbiAgZm9yIChjb25zdCBjaHVuayBvZiBjaHVua3MpIHtcbiAgICBmb3IgKGNvbnN0IHRva2VuIG9mIHNlYXJjaC5mZWVkKGNodW5rKSkge1xuICAgICAgaWYgKHRva2VuID09PSBNQVRDSCkge1xuICAgICAgICBvdXRjaHVua3MucHVzaChbXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXRjaHVua3Nbb3V0Y2h1bmtzLmxlbmd0aCAtIDFdLnB1c2godG9rZW4pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb25zdCBlbmQgPSBzZWFyY2guZW5kKCk7XG4gIG91dGNodW5rc1tvdXRjaHVua3MubGVuZ3RoIC0gMV0ucHVzaChlbmQpO1xuICByZXR1cm4gb3V0Y2h1bmtzLm1hcChjaHVua3MgPT4gbWVyZ2VBcnJheXMoLi4uY2h1bmtzKSk7XG59XG5mdW5jdGlvbiBzcGxpdChidWYsIG5lZWRsZSkge1xuICByZXR1cm4gc3BsaXRDaHVua3MoW2J1Zl0sIG5lZWRsZSk7XG59XG5hc3luYyBmdW5jdGlvbiogY2h1bmtzSXRlcmF0b3IoaXRlcikge1xuICBsZXQgY2h1bmtzID0gW107XG4gIGZvciBhd2FpdCAoY29uc3QgdmFsdWUgb2YgaXRlcikge1xuICAgIGlmICh2YWx1ZSA9PT0gTUFUQ0gpIHtcbiAgICAgIHlpZWxkIGNodW5rcztcbiAgICAgIGNodW5rcyA9IFtdO1xuICAgIH0gZWxzZSB7XG4gICAgICBjaHVua3MucHVzaCh2YWx1ZSk7XG4gICAgfVxuICB9XG4gIHlpZWxkIGNodW5rcztcbn1cbmFzeW5jIGZ1bmN0aW9uKiBzdHJpbmdJdGVyYXRvcihpdGVyKSB7XG4gIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgY2h1bmtzSXRlcmF0b3IoaXRlcikpIHtcbiAgICB5aWVsZCBjaHVuay5tYXAoYXJyYXlUb1N0cmluZykuam9pbignJyk7XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGFsbFN0cmluZ3MoaXRlcikge1xuICBjb25zdCBzZWdtZW50cyA9IFtdO1xuICBmb3IgYXdhaXQgKGNvbnN0IHZhbHVlIG9mIHN0cmluZ0l0ZXJhdG9yKGl0ZXIpKSB7XG4gICAgc2VnbWVudHMucHVzaCh2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHNlZ21lbnRzO1xufVxuYXN5bmMgZnVuY3Rpb24qIGFycmF5SXRlcmF0b3IoaXRlcikge1xuICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIGNodW5rc0l0ZXJhdG9yKGl0ZXIpKSB7XG4gICAgeWllbGQgbWVyZ2VBcnJheXMoLi4uY2h1bmspO1xuICB9XG59XG5leHBvcnQge1xuICBNQVRDSCxcbiAgUXVldWVhYmxlU3RyZWFtU2VhcmNoLFxuICBSZWFkYWJsZVN0cmVhbVNlYXJjaCxcbiAgU3RyZWFtU2VhcmNoLFxuICBhbGxTdHJpbmdzLFxuICBhcnJheUl0ZXJhdG9yLFxuICBjaHVua3NJdGVyYXRvcixcbiAgc3BsaXQsXG4gIHNwbGl0Q2h1bmtzLFxuICBzdHJpbmdJdGVyYXRvclxufTsiLCAiaW1wb3J0IHtcbiAgUmVhZGFibGVTdHJlYW1TZWFyY2gsXG4gIFN0cmVhbVNlYXJjaCxcbiAgTUFUQ0hcbn0gZnJvbSAnLi9zZWFyY2guanMnO1xuaW1wb3J0IHtcbiAgYXJyYXlzRXF1YWwsXG4gIHN0cmluZ1RvQXJyYXksXG4gIGFycmF5VG9TdHJpbmcsXG4gIG1lcmdlQXJyYXlzXG59IGZyb20gJy4vdXRpbHMuanMnO1xuY29uc3QgbWVyZ2VBcnJheXMyID0gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmJpbmQobWVyZ2VBcnJheXMsIHVuZGVmaW5lZCk7XG5jb25zdCBkYXNoID0gc3RyaW5nVG9BcnJheSgnLS0nKTtcbmNvbnN0IENSTEYgPSBzdHJpbmdUb0FycmF5KCdcXHJcXG4nKTtcbmZ1bmN0aW9uIHBhcnNlQ29udGVudERpc3Bvc2l0aW9uKGhlYWRlcikge1xuICBjb25zdCBwYXJ0cyA9IGhlYWRlci5zcGxpdCgnOycpLm1hcChwYXJ0ID0+IHBhcnQudHJpbSgpKTtcbiAgaWYgKHBhcnRzLnNoaWZ0KCkgIT09ICdmb3JtLWRhdGEnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdtYWxmb3JtZWQgY29udGVudC1kaXNwb3NpdGlvbiBoZWFkZXI6IG1pc3NpbmcgXCJmb3JtLWRhdGFcIiBpbiBgJyArIEpTT04uc3RyaW5naWZ5KHBhcnRzKSArICdgJyk7XG4gIH1cbiAgY29uc3Qgb3V0ID0ge307XG4gIGZvciAoY29uc3QgcGFydCBvZiBwYXJ0cykge1xuICAgIGNvbnN0IGt2ID0gcGFydC5zcGxpdCgnPScsIDIpO1xuICAgIGlmIChrdi5sZW5ndGggIT09IDIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWFsZm9ybWVkIGNvbnRlbnQtZGlzcG9zaXRpb24gaGVhZGVyOiBrZXktdmFsdWUgcGFpciBub3QgZm91bmQgLSAnICsgcGFydCArICcgaW4gYCcgKyBoZWFkZXIgKyAnYCcpO1xuICAgIH1cbiAgICBjb25zdCBbbmFtZSwgdmFsdWVdID0ga3Y7XG4gICAgaWYgKHZhbHVlWzBdID09PSAnXCInICYmIHZhbHVlW3ZhbHVlLmxlbmd0aCAtIDFdID09PSAnXCInKSB7XG4gICAgICBvdXRbbmFtZV0gPSB2YWx1ZS5zbGljZSgxLCAtMSkucmVwbGFjZSgvXFxcXFwiL2csICdcIicpO1xuICAgIH0gZWxzZSBpZiAodmFsdWVbMF0gIT09ICdcIicgJiYgdmFsdWVbdmFsdWUubGVuZ3RoIC0gMV0gIT09ICdcIicpIHtcbiAgICAgIG91dFtuYW1lXSA9IHZhbHVlO1xuICAgIH0gZWxzZSBpZiAodmFsdWVbMF0gPT09ICdcIicgJiYgdmFsdWVbdmFsdWUubGVuZ3RoIC0gMV0gIT09ICdcIicgfHwgdmFsdWVbMF0gIT09ICdcIicgJiYgdmFsdWVbdmFsdWUubGVuZ3RoIC0gMV0gPT09ICdcIicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWFsZm9ybWVkIGNvbnRlbnQtZGlzcG9zaXRpb24gaGVhZGVyOiBtaXNtYXRjaGVkIHF1b3RhdGlvbnMgaW4gYCcgKyBoZWFkZXIgKyAnYCcpO1xuICAgIH1cbiAgfVxuICBpZiAoIW91dC5uYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdtYWxmb3JtZWQgY29udGVudC1kaXNwb3NpdGlvbiBoZWFkZXI6IG1pc3NpbmcgZmllbGQgbmFtZSBpbiBgJyArIGhlYWRlciArICdgJyk7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cbmZ1bmN0aW9uIHBhcnNlUGFydEhlYWRlcnMobGluZXMpIHtcbiAgY29uc3QgZW50cmllcyA9IFtdO1xuICBsZXQgZGlzcG9zaXRpb24gPSBmYWxzZTtcbiAgbGV0IGxpbmU7XG4gIHdoaWxlICh0eXBlb2YgKGxpbmUgPSBsaW5lcy5zaGlmdCgpKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBjb25zdCBjb2xvbiA9IGxpbmUuaW5kZXhPZignOicpO1xuICAgIGlmIChjb2xvbiA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWFsZm9ybWVkIG11bHRpcGFydC1mb3JtIGhlYWRlcjogbWlzc2luZyBjb2xvbicpO1xuICAgIH1cbiAgICBjb25zdCBoZWFkZXIgPSBsaW5lLnNsaWNlKDAsIGNvbG9uKS50cmltKCkudG9Mb3dlckNhc2UoKTtcbiAgICBjb25zdCB2YWx1ZSA9IGxpbmUuc2xpY2UoY29sb24gKyAxKS50cmltKCk7XG4gICAgc3dpdGNoIChoZWFkZXIpIHtcbiAgICBjYXNlICdjb250ZW50LWRpc3Bvc2l0aW9uJzpcbiAgICAgIGRpc3Bvc2l0aW9uID0gdHJ1ZTtcbiAgICAgIGVudHJpZXMucHVzaCguLi5PYmplY3QuZW50cmllcyhwYXJzZUNvbnRlbnREaXNwb3NpdGlvbih2YWx1ZSkpKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2NvbnRlbnQtdHlwZSc6XG4gICAgICBlbnRyaWVzLnB1c2goW1xuICAgICAgICAnY29udGVudFR5cGUnLFxuICAgICAgICB2YWx1ZVxuICAgICAgXSk7XG4gICAgfVxuICB9XG4gIGlmICghZGlzcG9zaXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ21hbGZvcm1lZCBtdWx0aXBhcnQtZm9ybSBoZWFkZXI6IG1pc3NpbmcgY29udGVudC1kaXNwb3NpdGlvbicpO1xuICB9XG4gIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoZW50cmllcyk7XG59XG5hc3luYyBmdW5jdGlvbiByZWFkSGVhZGVyTGluZXMoaXQsIG5lZWRsZSkge1xuICBsZXQgZmlyc3RDaHVuayA9IHRydWU7XG4gIGxldCBsYXN0VG9rZW5XYXNNYXRjaCA9IGZhbHNlO1xuICBjb25zdCBoZWFkZXJMaW5lcyA9IFtbXV07XG4gIGNvbnN0IGNybGZTZWFyY2ggPSBuZXcgU3RyZWFtU2VhcmNoKENSTEYpO1xuICBmb3IgKDs7KSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgaXQubmV4dCgpO1xuICAgIGlmIChyZXN1bHQuZG9uZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYWxmb3JtZWQgbXVsdGlwYXJ0LWZvcm0gZGF0YTogdW5leHBlY3RlZCBlbmQgb2Ygc3RyZWFtJyk7XG4gICAgfVxuICAgIGlmIChmaXJzdENodW5rICYmIHJlc3VsdC52YWx1ZSAhPT0gTUFUQ0ggJiYgYXJyYXlzRXF1YWwocmVzdWx0LnZhbHVlLnNsaWNlKDAsIDIpLCBkYXNoKSkge1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICBuZXcgVWludDhBcnJheSgpXG4gICAgICBdO1xuICAgIH1cbiAgICBsZXQgY2h1bms7XG4gICAgaWYgKHJlc3VsdC52YWx1ZSAhPT0gTUFUQ0gpIHtcbiAgICAgIGNodW5rID0gcmVzdWx0LnZhbHVlO1xuICAgIH0gZWxzZSBpZiAoIWxhc3RUb2tlbldhc01hdGNoKSB7XG4gICAgICBjaHVuayA9IG5lZWRsZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYWxmb3JtZWQgbXVsdGlwYXJ0LWZvcm0gZGF0YTogdW5leHBlY3RlZCBib3VuZGFyeScpO1xuICAgIH1cbiAgICBpZiAoIWNodW5rLmxlbmd0aCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChmaXJzdENodW5rKSB7XG4gICAgICBmaXJzdENodW5rID0gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHRva2VucyA9IGNybGZTZWFyY2guZmVlZChjaHVuayk7XG4gICAgZm9yIChjb25zdCBbaSwgdG9rZW5dIG9mIHRva2Vucy5lbnRyaWVzKCkpIHtcbiAgICAgIGNvbnN0IGlzTWF0Y2ggPSB0b2tlbiA9PT0gTUFUQ0g7XG4gICAgICBpZiAoIWlzTWF0Y2ggJiYgIXRva2VuLmxlbmd0aCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChsYXN0VG9rZW5XYXNNYXRjaCAmJiBpc01hdGNoKSB7XG4gICAgICAgIHRva2Vucy5wdXNoKGNybGZTZWFyY2guZW5kKCkpO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIGhlYWRlckxpbmVzLmZpbHRlcihjaHVua3MgPT4gY2h1bmtzLmxlbmd0aCkubWFwKG1lcmdlQXJyYXlzMikubWFwKGFycmF5VG9TdHJpbmcpLFxuICAgICAgICAgIG1lcmdlQXJyYXlzKC4uLnRva2Vucy5zbGljZShpICsgMSkubWFwKHRva2VuID0+IHRva2VuID09PSBNQVRDSCA/IENSTEYgOiB0b2tlbikpXG4gICAgICAgIF07XG4gICAgICB9XG4gICAgICBpZiAobGFzdFRva2VuV2FzTWF0Y2ggPSBpc01hdGNoKSB7XG4gICAgICAgIGhlYWRlckxpbmVzLnB1c2goW10pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGVhZGVyTGluZXNbaGVhZGVyTGluZXMubGVuZ3RoIC0gMV0ucHVzaCh0b2tlbik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24qIHN0cmVhbU11bHRpcGFydChib2R5LCBib3VuZGFyeSkge1xuICBjb25zdCBuZWVkbGUgPSBtZXJnZUFycmF5cyhkYXNoLCBzdHJpbmdUb0FycmF5KGJvdW5kYXJ5KSk7XG4gIGNvbnN0IGl0ID0gbmV3IFJlYWRhYmxlU3RyZWFtU2VhcmNoKG5lZWRsZSwgYm9keSlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCk7XG4gIGZvciAoOzspIHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBpdC5uZXh0KCk7XG4gICAgaWYgKHJlc3VsdC5kb25lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChyZXN1bHQudmFsdWUgPT09IE1BVENIKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgY29uc3QgY3JsZlNlYXJjaCA9IG5ldyBTdHJlYW1TZWFyY2goQ1JMRik7XG4gIGZvciAoOzspIHtcbiAgICBjb25zdCBbaGVhZGVyTGluZXMsIHRhaWxdID0gYXdhaXQgcmVhZEhlYWRlckxpbmVzKGl0LCBuZWVkbGUpO1xuICAgIGlmICghaGVhZGVyTGluZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYXN5bmMgZnVuY3Rpb24gbmV4dFRva2VuKCkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgaXQubmV4dCgpO1xuICAgICAgaWYgKHJlc3VsdC5kb25lKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWFsZm9ybWVkIG11bHRpcGFydC1mb3JtIGRhdGE6IHVuZXhwZWN0ZWQgZW5kIG9mIHN0cmVhbScpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgbGV0IHRyYWlsaW5nQ1JMRiA9IGZhbHNlO1xuICAgIGZ1bmN0aW9uIGZlZWRDaHVuayhjaHVuaykge1xuICAgICAgY29uc3QgY2h1bmtzID0gW107XG4gICAgICBmb3IgKGNvbnN0IHRva2VuIG9mIGNybGZTZWFyY2guZmVlZChjaHVuaykpIHtcbiAgICAgICAgaWYgKHRyYWlsaW5nQ1JMRikge1xuICAgICAgICAgIGNodW5rcy5wdXNoKENSTEYpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKHRyYWlsaW5nQ1JMRiA9IHRva2VuID09PSBNQVRDSCkpIHtcbiAgICAgICAgICBjaHVua3MucHVzaCh0b2tlbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBtZXJnZUFycmF5cyguLi5jaHVua3MpO1xuICAgIH1cbiAgICBsZXQgZG9uZSA9IGZhbHNlO1xuICAgIGFzeW5jIGZ1bmN0aW9uIG5leHRDaHVuaygpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IG5leHRUb2tlbigpO1xuICAgICAgbGV0IGNodW5rO1xuICAgICAgaWYgKHJlc3VsdC52YWx1ZSAhPT0gTUFUQ0gpIHtcbiAgICAgICAgY2h1bmsgPSByZXN1bHQudmFsdWU7XG4gICAgICB9IGVsc2UgaWYgKCF0cmFpbGluZ0NSTEYpIHtcbiAgICAgICAgY2h1bmsgPSBDUkxGO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgIHJldHVybiB7IHZhbHVlOiBjcmxmU2VhcmNoLmVuZCgpIH07XG4gICAgICB9XG4gICAgICByZXR1cm4geyB2YWx1ZTogZmVlZENodW5rKGNodW5rKSB9O1xuICAgIH1cbiAgICBjb25zdCBidWZmZXJlZENodW5rcyA9IFt7IHZhbHVlOiBmZWVkQ2h1bmsodGFpbCkgfV07XG4gICAgeWllbGQge1xuICAgICAgLi4ucGFyc2VQYXJ0SGVhZGVycyhoZWFkZXJMaW5lcyksXG4gICAgICBkYXRhOiB7XG4gICAgICAgIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIGFzeW5jIG5leHQoKSB7XG4gICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYnVmZmVyZWRDaHVua3Muc2hpZnQoKTtcbiAgICAgICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdC52YWx1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZG9uZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdW5kZWZpbmVkXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBuZXh0Q2h1bmsoKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQudmFsdWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgd2hpbGUgKCFkb25lKSB7XG4gICAgICBidWZmZXJlZENodW5rcy5wdXNoKGF3YWl0IG5leHRDaHVuaygpKTtcbiAgICB9XG4gIH1cbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiogaXRlcmF0ZU11bHRpcGFydChib2R5LCBib3VuZGFyeSkge1xuICBmb3IgYXdhaXQgKGNvbnN0IHBhcnQgb2Ygc3RyZWFtTXVsdGlwYXJ0KGJvZHksIGJvdW5kYXJ5KSkge1xuICAgIGNvbnN0IGNodW5rcyA9IFtdO1xuICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgcGFydC5kYXRhKSB7XG4gICAgICBjaHVua3MucHVzaChjaHVuayk7XG4gICAgfVxuICAgIHlpZWxkIHtcbiAgICAgIC4uLnBhcnQsXG4gICAgICBkYXRhOiBtZXJnZUFycmF5cyguLi5jaHVua3MpXG4gICAgfTtcbiAgfVxufSIsICJpbXBvcnQgU3RyZWFtIGZyb20gXCJzdHJlYW1cIjtcblxuLyoqXG4gKiBJcy5qc1xuICpcbiAqIE9iamVjdCB0eXBlIGNoZWNrcy5cbiAqL1xuXG5jb25zdCBOQU1FID0gU3ltYm9sLnRvU3RyaW5nVGFnO1xuXG4vKipcbiAqIENoZWNrIGlmIGBvYmpgIGlzIGEgVVJMU2VhcmNoUGFyYW1zIG9iamVjdFxuICogcmVmOiBodHRwczovL2dpdGh1Yi5jb20vbm9kZS1mZXRjaC9ub2RlLWZldGNoL2lzc3Vlcy8yOTYjaXNzdWVjb21tZW50LTMwNzU5ODE0M1xuICpcbiAqIEBwYXJhbSAge2FueX0gb2JqZWN0XG4gKiBAcmV0dXJuIHtvYmogaXMgVVJMU2VhcmNoUGFyYW1zfVxuICovXG5leHBvcnQgY29uc3QgaXNVUkxTZWFyY2hQYXJhbWV0ZXJzID0gKG9iamVjdCkgPT4ge1xuXHRyZXR1cm4gKFxuXHRcdHR5cGVvZiBvYmplY3QgPT09IFwib2JqZWN0XCIgJiZcblx0XHR0eXBlb2Ygb2JqZWN0LmFwcGVuZCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIG9iamVjdC5kZWxldGUgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBvYmplY3QuZ2V0ID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2Ygb2JqZWN0LmdldEFsbCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIG9iamVjdC5oYXMgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBvYmplY3Quc2V0ID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2Ygb2JqZWN0LnNvcnQgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdG9iamVjdFtOQU1FXSA9PT0gXCJVUkxTZWFyY2hQYXJhbXNcIlxuXHQpO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiBgb2JqZWN0YCBpcyBhIFczQyBgQmxvYmAgb2JqZWN0ICh3aGljaCBgRmlsZWAgaW5oZXJpdHMgZnJvbSlcbiAqXG4gKiBAcGFyYW0gIHsqfSBvYmplY3RcbiAqIEByZXR1cm4ge29iamVjdCBpcyBCbG9ifVxuICovXG5leHBvcnQgY29uc3QgaXNCbG9iID0gKG9iamVjdCkgPT4ge1xuXHRyZXR1cm4gKFxuXHRcdHR5cGVvZiBvYmplY3QgPT09IFwib2JqZWN0XCIgJiZcblx0XHR0eXBlb2Ygb2JqZWN0LmFycmF5QnVmZmVyID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2Ygb2JqZWN0LnR5cGUgPT09IFwic3RyaW5nXCIgJiZcblx0XHR0eXBlb2Ygb2JqZWN0LnN0cmVhbSA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIG9iamVjdC5jb25zdHJ1Y3RvciA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0L14oQmxvYnxGaWxlKSQvLnRlc3Qob2JqZWN0W05BTUVdKVxuXHQpO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiBgb2JqYCBpcyBhIHNwZWMtY29tcGxpYW50IGBGb3JtRGF0YWAgb2JqZWN0XG4gKlxuICogQHBhcmFtIHsqfSBvYmplY3RcbiAqIEByZXR1cm4ge29iamVjdCBpcyBGb3JtRGF0YX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRm9ybURhdGEob2JqZWN0KSB7XG5cdHJldHVybiAoXG5cdFx0dHlwZW9mIG9iamVjdCA9PT0gXCJvYmplY3RcIiAmJlxuXHRcdHR5cGVvZiBvYmplY3QuYXBwZW5kID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2Ygb2JqZWN0LnNldCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIG9iamVjdC5nZXQgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBvYmplY3QuZ2V0QWxsID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2Ygb2JqZWN0LmRlbGV0ZSA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIG9iamVjdC5rZXlzID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2Ygb2JqZWN0LnZhbHVlcyA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIG9iamVjdC5lbnRyaWVzID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2Ygb2JqZWN0LmNvbnN0cnVjdG9yID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHRvYmplY3RbTkFNRV0gPT09IFwiRm9ybURhdGFcIlxuXHQpO1xufVxuXG4vKipcbiAqIERldGVjdCBmb3JtIGRhdGEgaW5wdXQgZnJvbSBmb3JtLWRhdGEgbW9kdWxlXG4gKlxuICogQHBhcmFtIHthbnl9IHZhbHVlXG4gKiBAcmV0dXJucyB7dmFsdWUgaXMgU3RyZWFtICYge2dldEJvdW5kYXJ5KCk6c3RyaW5nLCBoYXNLbm93bkxlbmd0aCgpOmJvb2xlYW4sIGdldExlbmd0aFN5bmMoKTpudW1iZXJ8bnVsbH19XG4gKi9cbmV4cG9ydCBjb25zdCBpc011bHRpcGFydEZvcm1EYXRhU3RyZWFtID0gKHZhbHVlKSA9PiB7XG5cdHJldHVybiAoXG5cdFx0dmFsdWUgaW5zdGFuY2VvZiBTdHJlYW0gPT09IHRydWUgJiZcblx0XHR0eXBlb2YgdmFsdWUuZ2V0Qm91bmRhcnkgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiB2YWx1ZS5oYXNLbm93bkxlbmd0aCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIHZhbHVlLmdldExlbmd0aFN5bmMgPT09IFwiZnVuY3Rpb25cIlxuXHQpO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiBgb2JqYCBpcyBhbiBpbnN0YW5jZSBvZiBBYm9ydFNpZ25hbC5cbiAqXG4gKiBAcGFyYW0gIHthbnl9IG9iamVjdFxuICogQHJldHVybiB7b2JqIGlzIEFib3J0U2lnbmFsfVxuICovXG5leHBvcnQgY29uc3QgaXNBYm9ydFNpZ25hbCA9IChvYmplY3QpID0+IHtcblx0cmV0dXJuIChcblx0XHR0eXBlb2Ygb2JqZWN0ID09PSBcIm9iamVjdFwiICYmXG5cdFx0KG9iamVjdFtOQU1FXSA9PT0gXCJBYm9ydFNpZ25hbFwiIHx8IG9iamVjdFtOQU1FXSA9PT0gXCJFdmVudFRhcmdldFwiKVxuXHQpO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiBgdmFsdWVgIGlzIGEgUmVhZGFibGVTdHJlYW0uXG4gKlxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHJldHVybnMge3ZhbHVlIGlzIFJlYWRhYmxlU3RyZWFtfVxuICovXG5leHBvcnQgY29uc3QgaXNSZWFkYWJsZVN0cmVhbSA9ICh2YWx1ZSkgPT4ge1xuXHRyZXR1cm4gKFxuXHRcdHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJlxuXHRcdHR5cGVvZiB2YWx1ZS5nZXRSZWFkZXIgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiB2YWx1ZS5jYW5jZWwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiB2YWx1ZS50ZWUgPT09IFwiZnVuY3Rpb25cIlxuXHQpO1xufTtcblxuLyoqXG4gKlxuICogQHBhcmFtIHthbnl9IHZhbHVlXG4gKiBAcmV0dXJucyB7dmFsdWUgaXMgSXRlcmFibGU8dW5rbm93bj59XG4gKi9cbmV4cG9ydCBjb25zdCBpc0l0ZXJhYmxlID0gKHZhbHVlKSA9PiB2YWx1ZSAmJiBTeW1ib2wuaXRlcmF0b3IgaW4gdmFsdWU7XG4iLCAiaW1wb3J0IHtUZXh0RW5jb2RlciwgVGV4dERlY29kZXJ9IGZyb20gJ3V0aWwnO1xuXG5jb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG5jb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAqL1xuZXhwb3J0IGNvbnN0IGVuY29kZSA9IHRleHQgPT4gZW5jb2Rlci5lbmNvZGUodGV4dCk7XG5cbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBieXRlc1xuICovXG5leHBvcnQgY29uc3QgZGVjb2RlID0gYnl0ZXMgPT4gZGVjb2Rlci5kZWNvZGUoYnl0ZXMpO1xuIiwgIi8qKlxuICogSGVhZGVycy5qc1xuICpcbiAqIEhlYWRlcnMgY2xhc3Mgb2ZmZXJzIGNvbnZlbmllbnQgaGVscGVyc1xuICovXG5cbmltcG9ydCB7dHlwZXN9IGZyb20gJ3V0aWwnO1xuaW1wb3J0IGh0dHAgZnJvbSAnaHR0cCc7XG5pbXBvcnQgeyBpc0l0ZXJhYmxlIH0gZnJvbSAnLi91dGlscy9pcy5qcydcblxuY29uc3QgdmFsaWRhdG9ycyA9IC8qKiBAdHlwZSB7e3ZhbGlkYXRlSGVhZGVyTmFtZT86KG5hbWU6c3RyaW5nKSA9PiBhbnksIHZhbGlkYXRlSGVhZGVyVmFsdWU/OihuYW1lOnN0cmluZywgdmFsdWU6c3RyaW5nKSA9PiBhbnl9fSAqL1xuKGh0dHApXG5cbmNvbnN0IHZhbGlkYXRlSGVhZGVyTmFtZSA9IHR5cGVvZiB2YWxpZGF0b3JzLnZhbGlkYXRlSGVhZGVyTmFtZSA9PT0gJ2Z1bmN0aW9uJyA/XG5cdHZhbGlkYXRvcnMudmFsaWRhdGVIZWFkZXJOYW1lIDpcblx0LyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFxuXHQgKi9cblx0bmFtZSA9PiB7XG5cdFx0aWYgKCEvXltcXF5gXFwtXFx3ISMkJSYnKisufH5dKyQvLnRlc3QobmFtZSkpIHtcblx0XHRcdGNvbnN0IGVyciA9IG5ldyBUeXBlRXJyb3IoYEhlYWRlciBuYW1lIG11c3QgYmUgYSB2YWxpZCBIVFRQIHRva2VuIFske25hbWV9XWApO1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGVyciwgJ2NvZGUnLCB7dmFsdWU6ICdFUlJfSU5WQUxJRF9IVFRQX1RPS0VOJ30pO1xuXHRcdFx0dGhyb3cgZXJyO1xuXHRcdH1cblx0fTtcblxuY29uc3QgdmFsaWRhdGVIZWFkZXJWYWx1ZSA9IHR5cGVvZiB2YWxpZGF0b3JzLnZhbGlkYXRlSGVhZGVyVmFsdWUgPT09ICdmdW5jdGlvbicgP1xuXHR2YWxpZGF0b3JzLnZhbGlkYXRlSGVhZGVyVmFsdWUgOlxuXHQvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBcblx0ICovXG5cdChuYW1lLCB2YWx1ZSkgPT4ge1xuXHRcdGlmICgvW15cXHRcXHUwMDIwLVxcdTAwN0VcXHUwMDgwLVxcdTAwRkZdLy50ZXN0KHZhbHVlKSkge1xuXHRcdFx0Y29uc3QgZXJyID0gbmV3IFR5cGVFcnJvcihgSW52YWxpZCBjaGFyYWN0ZXIgaW4gaGVhZGVyIGNvbnRlbnQgW1wiJHtuYW1lfVwiXWApO1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGVyciwgJ2NvZGUnLCB7dmFsdWU6ICdFUlJfSU5WQUxJRF9DSEFSJ30pO1xuXHRcdFx0dGhyb3cgZXJyO1xuXHRcdH1cblx0fTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7SGVhZGVycyB8IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gfCBJdGVyYWJsZTxyZWFkb25seSBbc3RyaW5nLCBzdHJpbmddPiB8IEl0ZXJhYmxlPEl0ZXJhYmxlPHN0cmluZz4+fSBIZWFkZXJzSW5pdFxuICovXG5cbi8qKlxuICogVGhpcyBGZXRjaCBBUEkgaW50ZXJmYWNlIGFsbG93cyB5b3UgdG8gcGVyZm9ybSB2YXJpb3VzIGFjdGlvbnMgb24gSFRUUCByZXF1ZXN0IGFuZCByZXNwb25zZSBoZWFkZXJzLlxuICogVGhlc2UgYWN0aW9ucyBpbmNsdWRlIHJldHJpZXZpbmcsIHNldHRpbmcsIGFkZGluZyB0bywgYW5kIHJlbW92aW5nLlxuICogQSBIZWFkZXJzIG9iamVjdCBoYXMgYW4gYXNzb2NpYXRlZCBoZWFkZXIgbGlzdCwgd2hpY2ggaXMgaW5pdGlhbGx5IGVtcHR5IGFuZCBjb25zaXN0cyBvZiB6ZXJvIG9yIG1vcmUgbmFtZSBhbmQgdmFsdWUgcGFpcnMuXG4gKiBZb3UgY2FuIGFkZCB0byB0aGlzIHVzaW5nIG1ldGhvZHMgbGlrZSBhcHBlbmQoKSAoc2VlIEV4YW1wbGVzLilcbiAqIEluIGFsbCBtZXRob2RzIG9mIHRoaXMgaW50ZXJmYWNlLCBoZWFkZXIgbmFtZXMgYXJlIG1hdGNoZWQgYnkgY2FzZS1pbnNlbnNpdGl2ZSBieXRlIHNlcXVlbmNlLlxuICpcbiAqIEBpbXBsZW1lbnRzIHtnbG9iYWxUaGlzLkhlYWRlcnN9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEhlYWRlcnMgZXh0ZW5kcyBVUkxTZWFyY2hQYXJhbXMge1xuXHQvKipcblx0ICogSGVhZGVycyBjbGFzc1xuXHQgKlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtIZWFkZXJzSW5pdH0gW2luaXRdIC0gUmVzcG9uc2UgaGVhZGVyc1xuXHQgKi9cblx0Y29uc3RydWN0b3IoaW5pdCkge1xuXHRcdC8vIFZhbGlkYXRlIGFuZCBub3JtYWxpemUgaW5pdCBvYmplY3QgaW4gW25hbWUsIHZhbHVlKHMpXVtdXG5cdFx0LyoqIEB0eXBlIHtzdHJpbmdbXVtdfSAqL1xuXHRcdGxldCByZXN1bHQgPSBbXTtcblx0XHRpZiAoaW5pdCBpbnN0YW5jZW9mIEhlYWRlcnMpIHtcblx0XHRcdGNvbnN0IHJhdyA9IGluaXQucmF3KCk7XG5cdFx0XHRmb3IgKGNvbnN0IFtuYW1lLCB2YWx1ZXNdIG9mIE9iamVjdC5lbnRyaWVzKHJhdykpIHtcblx0XHRcdFx0cmVzdWx0LnB1c2goLi4udmFsdWVzLm1hcCh2YWx1ZSA9PiBbbmFtZSwgdmFsdWVdKSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChpbml0ID09IG51bGwpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1lcS1udWxsLCBlcWVxZXFcblx0XHRcdC8vIE5vIG9wXG5cdFx0fSBlbHNlIGlmIChpc0l0ZXJhYmxlKGluaXQpKSB7XG5cdFx0XHQvLyBTZXF1ZW5jZTxzZXF1ZW5jZTxCeXRlU3RyaW5nPj5cblx0XHRcdC8vIE5vdGU6IHBlciBzcGVjIHdlIGhhdmUgdG8gZmlyc3QgZXhoYXVzdCB0aGUgbGlzdHMgdGhlbiBwcm9jZXNzIHRoZW1cblx0XHRcdHJlc3VsdCA9IFsuLi5pbml0XVxuXHRcdFx0XHQubWFwKHBhaXIgPT4ge1xuXHRcdFx0XHRcdGlmIChcblx0XHRcdFx0XHRcdHR5cGVvZiBwYWlyICE9PSAnb2JqZWN0JyB8fCB0eXBlcy5pc0JveGVkUHJpbWl0aXZlKHBhaXIpXG5cdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdFYWNoIGhlYWRlciBwYWlyIG11c3QgYmUgYW4gaXRlcmFibGUgb2JqZWN0Jyk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIFsuLi5wYWlyXTtcblx0XHRcdFx0fSkubWFwKHBhaXIgPT4ge1xuXHRcdFx0XHRcdGlmIChwYWlyLmxlbmd0aCAhPT0gMikge1xuXHRcdFx0XHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignRWFjaCBoZWFkZXIgcGFpciBtdXN0IGJlIGEgbmFtZS92YWx1ZSB0dXBsZScpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiBbLi4ucGFpcl07XG5cdFx0XHRcdH0pO1xuXHRcdH0gZWxzZSBpZiAodHlwZW9mIGluaXQgPT09IFwib2JqZWN0XCIgJiYgaW5pdCAhPT0gbnVsbCkge1xuXHRcdFx0Ly8gUmVjb3JkPEJ5dGVTdHJpbmcsIEJ5dGVTdHJpbmc+XG5cdFx0XHRyZXN1bHQucHVzaCguLi5PYmplY3QuZW50cmllcyhpbml0KSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZhaWxlZCB0byBjb25zdHJ1Y3QgXFwnSGVhZGVyc1xcJzogVGhlIHByb3ZpZGVkIHZhbHVlIGlzIG5vdCBvZiB0eXBlIFxcJyhzZXF1ZW5jZTxzZXF1ZW5jZTxCeXRlU3RyaW5nPj4gb3IgcmVjb3JkPEJ5dGVTdHJpbmcsIEJ5dGVTdHJpbmc+KScpO1xuXHRcdH1cblxuXHRcdC8vIFZhbGlkYXRlIGFuZCBsb3dlcmNhc2Vcblx0XHRyZXN1bHQgPVxuXHRcdFx0cmVzdWx0Lmxlbmd0aCA+IDAgP1xuXHRcdFx0XHRyZXN1bHQubWFwKChbbmFtZSwgdmFsdWVdKSA9PiB7XG5cdFx0XHRcdFx0dmFsaWRhdGVIZWFkZXJOYW1lKG5hbWUpO1xuXHRcdFx0XHRcdHZhbGlkYXRlSGVhZGVyVmFsdWUobmFtZSwgU3RyaW5nKHZhbHVlKSk7XG5cdFx0XHRcdFx0cmV0dXJuIFtTdHJpbmcobmFtZSkudG9Mb3dlckNhc2UoKSwgU3RyaW5nKHZhbHVlKV07XG5cdFx0XHRcdH0pIDpcblx0XHRcdFx0W107XG5cblx0XHRzdXBlcihyZXN1bHQpO1xuXG5cdFx0Ly8gUmV0dXJuaW5nIGEgUHJveHkgdGhhdCB3aWxsIGxvd2VyY2FzZSBrZXkgbmFtZXMsIHZhbGlkYXRlIHBhcmFtZXRlcnMgYW5kIHNvcnQga2V5c1xuXHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zdHJ1Y3Rvci1yZXR1cm5cblx0XHRyZXR1cm4gbmV3IFByb3h5KHRoaXMsIHtcblx0XHRcdGdldCh0YXJnZXQsIHAsIHJlY2VpdmVyKSB7XG5cdFx0XHRcdHN3aXRjaCAocCkge1xuXHRcdFx0XHRcdGNhc2UgJ2FwcGVuZCc6XG5cdFx0XHRcdFx0Y2FzZSAnc2V0Jzpcblx0XHRcdFx0XHRcdC8qKlxuXHRcdFx0XHRcdFx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcblx0XHRcdFx0XHRcdCAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuXHRcdFx0XHRcdFx0ICovXG5cdFx0XHRcdFx0XHRyZXR1cm4gKG5hbWUsIHZhbHVlKSA9PiB7XG5cdFx0XHRcdFx0XHRcdHZhbGlkYXRlSGVhZGVyTmFtZShuYW1lKTtcblx0XHRcdFx0XHRcdFx0dmFsaWRhdGVIZWFkZXJWYWx1ZShuYW1lLCBTdHJpbmcodmFsdWUpKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGVbcF0uY2FsbChcblx0XHRcdFx0XHRcdFx0XHRyZWNlaXZlcixcblx0XHRcdFx0XHRcdFx0XHRTdHJpbmcobmFtZSkudG9Mb3dlckNhc2UoKSxcblx0XHRcdFx0XHRcdFx0XHRTdHJpbmcodmFsdWUpXG5cdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0Y2FzZSAnZGVsZXRlJzpcblx0XHRcdFx0XHRjYXNlICdoYXMnOlxuXHRcdFx0XHRcdGNhc2UgJ2dldEFsbCc6XG5cdFx0XHRcdFx0XHQvKipcblx0XHRcdFx0XHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG5cdFx0XHRcdFx0XHQgKi9cblx0XHRcdFx0XHRcdHJldHVybiBuYW1lID0+IHtcblx0XHRcdFx0XHRcdFx0dmFsaWRhdGVIZWFkZXJOYW1lKG5hbWUpO1xuXHRcdFx0XHRcdFx0XHQvLyBAdHMtaWdub3JlXG5cdFx0XHRcdFx0XHRcdHJldHVybiBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlW3BdLmNhbGwoXG5cdFx0XHRcdFx0XHRcdFx0cmVjZWl2ZXIsXG5cdFx0XHRcdFx0XHRcdFx0U3RyaW5nKG5hbWUpLnRvTG93ZXJDYXNlKClcblx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRjYXNlICdrZXlzJzpcblx0XHRcdFx0XHRcdHJldHVybiAoKSA9PiB7XG5cdFx0XHRcdFx0XHRcdHRhcmdldC5zb3J0KCk7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBuZXcgU2V0KFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUua2V5cy5jYWxsKHRhcmdldCkpLmtleXMoKTtcblx0XHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0cmV0dXJuIFJlZmxlY3QuZ2V0KHRhcmdldCwgcCwgcmVjZWl2ZXIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvKiBjOCBpZ25vcmUgbmV4dCAqL1xuXHRcdH0pO1xuXHR9XG5cblx0Z2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCkge1xuXHRcdHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG5cdH1cblxuXHR0b1N0cmluZygpIHtcblx0XHRyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHRoaXMpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBcblx0ICovXG5cdGdldChuYW1lKSB7XG5cdFx0Y29uc3QgdmFsdWVzID0gdGhpcy5nZXRBbGwobmFtZSk7XG5cdFx0aWYgKHZhbHVlcy5sZW5ndGggPT09IDApIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdGxldCB2YWx1ZSA9IHZhbHVlcy5qb2luKCcsICcpO1xuXHRcdGlmICgvXmNvbnRlbnQtZW5jb2RpbmckL2kudGVzdChuYW1lKSkge1xuXHRcdFx0dmFsdWUgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuXHRcdH1cblxuXHRcdHJldHVybiB2YWx1ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0geyh2YWx1ZTogc3RyaW5nLCBrZXk6IHN0cmluZywgcGFyZW50OiB0aGlzKSA9PiB2b2lkfSBjYWxsYmFjayBcblx0ICogQHBhcmFtIHthbnl9IHRoaXNBcmcgXG5cdCAqIEByZXR1cm5zIHt2b2lkfVxuXHQgKi9cblx0Zm9yRWFjaChjYWxsYmFjaywgdGhpc0FyZyA9IHVuZGVmaW5lZCkge1xuXHRcdGZvciAoY29uc3QgbmFtZSBvZiB0aGlzLmtleXMoKSkge1xuXHRcdFx0aWYgKG5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3NldC1jb29raWUnKSB7XG5cdFx0XHRcdGxldCBjb29raWVzID0gdGhpcy5nZXRBbGwobmFtZSk7XG5cdFx0XHRcdHdoaWxlIChjb29raWVzLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0XHRSZWZsZWN0LmFwcGx5KGNhbGxiYWNrLCB0aGlzQXJnLCBbY29va2llcy5zaGlmdCgpLCBuYW1lLCB0aGlzXSlcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0UmVmbGVjdC5hcHBseShjYWxsYmFjaywgdGhpc0FyZywgW3RoaXMuZ2V0KG5hbWUpLCBuYW1lLCB0aGlzXSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm5zIHtJdGVyYWJsZUl0ZXJhdG9yPHN0cmluZz59XG5cdCAqL1xuXHQqIHZhbHVlcygpIHtcblx0XHRmb3IgKGNvbnN0IG5hbWUgb2YgdGhpcy5rZXlzKCkpIHtcblx0XHRcdGlmIChuYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdzZXQtY29va2llJykge1xuXHRcdFx0XHRsZXQgY29va2llcyA9IHRoaXMuZ2V0QWxsKG5hbWUpO1xuXHRcdFx0XHR3aGlsZSAoY29va2llcy5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdFx0eWllbGQgLyoqIEB0eXBlIHtzdHJpbmd9ICovKGNvb2tpZXMuc2hpZnQoKSk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHlpZWxkIC8qKiBAdHlwZSB7c3RyaW5nfSAqLyh0aGlzLmdldChuYW1lKSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm5zIHtJdGVyYWJsZUl0ZXJhdG9yPFtzdHJpbmcsIHN0cmluZ10+fVxuXHQgKi9cblx0KiBlbnRyaWVzKCkge1xuXHRcdGZvciAoY29uc3QgbmFtZSBvZiB0aGlzLmtleXMoKSkge1xuXHRcdFx0aWYgKG5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3NldC1jb29raWUnKSB7XG5cdFx0XHRcdGxldCBjb29raWVzID0gdGhpcy5nZXRBbGwobmFtZSk7XG5cdFx0XHRcdHdoaWxlIChjb29raWVzLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0XHR5aWVsZCBbbmFtZSwgLyoqIEB0eXBlIHtzdHJpbmd9ICovKGNvb2tpZXMuc2hpZnQoKSldO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR5aWVsZCBbbmFtZSwgLyoqIEB0eXBlIHtzdHJpbmd9ICovKHRoaXMuZ2V0KG5hbWUpKV07XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0W1N5bWJvbC5pdGVyYXRvcl0oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZW50cmllcygpO1xuXHR9XG5cblx0LyoqXG5cdCAqIE5vZGUtZmV0Y2ggbm9uLXNwZWMgbWV0aG9kXG5cdCAqIHJldHVybmluZyBhbGwgaGVhZGVycyBhbmQgdGhlaXIgdmFsdWVzIGFzIGFycmF5XG5cdCAqIEByZXR1cm5zIHtSZWNvcmQ8c3RyaW5nLCBzdHJpbmdbXT59XG5cdCAqL1xuXHRyYXcoKSB7XG5cdFx0cmV0dXJuIFsuLi50aGlzLmtleXMoKV0ucmVkdWNlKChyZXN1bHQsIGtleSkgPT4ge1xuXHRcdFx0cmVzdWx0W2tleV0gPSB0aGlzLmdldEFsbChrZXkpO1xuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9LCAvKiogQHR5cGUge1JlY29yZDxzdHJpbmcsIHN0cmluZ1tdPn0gKi8oe30pKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBGb3IgYmV0dGVyIGNvbnNvbGUubG9nKGhlYWRlcnMpIGFuZCBhbHNvIHRvIGNvbnZlcnQgSGVhZGVycyBpbnRvIE5vZGUuanMgUmVxdWVzdCBjb21wYXRpYmxlIGZvcm1hdFxuXHQgKi9cblx0W1N5bWJvbC5mb3IoJ25vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tJyldKCkge1xuXHRcdHJldHVybiBbLi4udGhpcy5rZXlzKCldLnJlZHVjZSgocmVzdWx0LCBrZXkpID0+IHtcblx0XHRcdGNvbnN0IHZhbHVlcyA9IHRoaXMuZ2V0QWxsKGtleSk7XG5cdFx0XHQvLyBIdHRwLnJlcXVlc3QoKSBvbmx5IHN1cHBvcnRzIHN0cmluZyBhcyBIb3N0IGhlYWRlci5cblx0XHRcdC8vIFRoaXMgaGFjayBtYWtlcyBzcGVjaWZ5aW5nIGN1c3RvbSBIb3N0IGhlYWRlciBwb3NzaWJsZS5cblx0XHRcdGlmIChrZXkgPT09ICdob3N0Jykge1xuXHRcdFx0XHRyZXN1bHRba2V5XSA9IHZhbHVlc1swXTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJlc3VsdFtrZXldID0gdmFsdWVzLmxlbmd0aCA+IDEgPyB2YWx1ZXMgOiB2YWx1ZXNbMF07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fSwgLyoqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLCBzdHJpbmd8c3RyaW5nW10+fSAqLyh7fSkpO1xuXHR9XG59XG5cbi8qKlxuICogUmUtc2hhcGluZyBvYmplY3QgZm9yIFdlYiBJREwgdGVzdHNcbiAqIE9ubHkgbmVlZCB0byBkbyBpdCBmb3Igb3ZlcnJpZGRlbiBtZXRob2RzXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFxuXHRIZWFkZXJzLnByb3RvdHlwZSxcblx0WydnZXQnLCAnZW50cmllcycsICdmb3JFYWNoJywgJ3ZhbHVlcyddLnJlZHVjZSgocmVzdWx0LCBwcm9wZXJ0eSkgPT4ge1xuXHRcdHJlc3VsdFtwcm9wZXJ0eV0gPSB7ZW51bWVyYWJsZTogdHJ1ZX07XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fSwgLyoqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLCB7ZW51bWVyYWJsZTp0cnVlfT59ICovICh7fSkpXG4pO1xuXG4vKipcbiAqIENyZWF0ZSBhIEhlYWRlcnMgb2JqZWN0IGZyb20gYW4gaHR0cC5JbmNvbWluZ01lc3NhZ2UucmF3SGVhZGVycywgaWdub3JpbmcgdGhvc2UgdGhhdCBkb1xuICogbm90IGNvbmZvcm0gdG8gSFRUUCBncmFtbWFyIHByb2R1Y3Rpb25zLlxuICogQHBhcmFtIHtpbXBvcnQoJ2h0dHAnKS5JbmNvbWluZ01lc3NhZ2VbJ3Jhd0hlYWRlcnMnXX0gaGVhZGVyc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVJhd0hlYWRlcnMoaGVhZGVycyA9IFtdKSB7XG5cdHJldHVybiBuZXcgSGVhZGVycyhcblx0XHRoZWFkZXJzXG5cdFx0XHQvLyBTcGxpdCBpbnRvIHBhaXJzXG5cdFx0XHQucmVkdWNlKChyZXN1bHQsIHZhbHVlLCBpbmRleCwgYXJyYXkpID0+IHtcblx0XHRcdFx0aWYgKGluZGV4ICUgMiA9PT0gMCkge1xuXHRcdFx0XHRcdHJlc3VsdC5wdXNoKGFycmF5LnNsaWNlKGluZGV4LCBpbmRleCArIDIpKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0XHR9LCAvKiogQHR5cGUge3N0cmluZ1tdW119ICovKFtdKSlcblx0XHRcdC5maWx0ZXIoKFtuYW1lLCB2YWx1ZV0pID0+IHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHR2YWxpZGF0ZUhlYWRlck5hbWUobmFtZSk7XG5cdFx0XHRcdFx0dmFsaWRhdGVIZWFkZXJWYWx1ZShuYW1lLCBTdHJpbmcodmFsdWUpKTtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fSBjYXRjaCB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9KVxuXG5cdCk7XG59XG4iLCAiY29uc3QgcmVkaXJlY3RTdGF0dXMgPSBuZXcgU2V0KFszMDEsIDMwMiwgMzAzLCAzMDcsIDMwOF0pO1xuXG4vKipcbiAqIFJlZGlyZWN0IGNvZGUgbWF0Y2hpbmdcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gY29kZSAtIFN0YXR1cyBjb2RlXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgY29uc3QgaXNSZWRpcmVjdCA9IGNvZGUgPT4ge1xuXHRyZXR1cm4gcmVkaXJlY3RTdGF0dXMuaGFzKGNvZGUpO1xufTtcbiIsICIvKipcbiAqIFJlc3BvbnNlLmpzXG4gKlxuICogUmVzcG9uc2UgY2xhc3MgcHJvdmlkZXMgY29udGVudCBkZWNvZGluZ1xuICovXG5cbmltcG9ydCBIZWFkZXJzIGZyb20gJy4vaGVhZGVycy5qcyc7XG5pbXBvcnQgQm9keSwge2Nsb25lLCBleHRyYWN0Q29udGVudFR5cGV9IGZyb20gJy4vYm9keS5qcyc7XG5pbXBvcnQge2lzUmVkaXJlY3R9IGZyb20gJy4vdXRpbHMvaXMtcmVkaXJlY3QuanMnO1xuXG5jb25zdCBJTlRFUk5BTFMgPSBTeW1ib2woJ1Jlc3BvbnNlIGludGVybmFscycpO1xuXG4vKipcbiAqIFJlc3BvbnNlIGNsYXNzXG4gKiBcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEV4dFxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtzaXplXVxuICogQHByb3BlcnR5IHtzdHJpbmd9IFt1cmxdXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2NvdW50ZXJdXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2hpZ2hXYXRlck1hcmtdXG4gKiBcbiAqIEBpbXBsZW1lbnRzIHtnbG9iYWxUaGlzLlJlc3BvbnNlfVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZXNwb25zZSBleHRlbmRzIEJvZHkge1xuXHQvKipcblx0ICogQHBhcmFtIHtCb2R5SW5pdHxpbXBvcnQoJ3N0cmVhbScpLlN0cmVhbXxudWxsfSBbYm9keV0gLSBSZWFkYWJsZSBzdHJlYW1cblx0ICogQHBhcmFtIHtSZXNwb25zZUluaXQgJiBFeHR9IFtvcHRpb25zXSAtIFJlc3BvbnNlIG9wdGlvbnNcblx0ICovXG5cdGNvbnN0cnVjdG9yKGJvZHkgPSBudWxsLCBvcHRpb25zID0ge30pIHtcblx0XHRzdXBlcihib2R5LCBvcHRpb25zKTtcblxuXHRcdGNvbnN0IHN0YXR1cyA9IG9wdGlvbnMuc3RhdHVzIHx8IDIwMDtcblx0XHRjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnMob3B0aW9ucy5oZWFkZXJzKTtcblxuXHRcdGlmIChib2R5ICE9PSBudWxsICYmICFoZWFkZXJzLmhhcygnQ29udGVudC1UeXBlJykpIHtcblx0XHRcdGNvbnN0IGNvbnRlbnRUeXBlID0gZXh0cmFjdENvbnRlbnRUeXBlKHRoaXMpO1xuXHRcdFx0aWYgKGNvbnRlbnRUeXBlKSB7XG5cdFx0XHRcdGhlYWRlcnMuYXBwZW5kKCdDb250ZW50LVR5cGUnLCBjb250ZW50VHlwZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogQHByaXZhdGVcblx0XHQqL1xuXHRcdHRoaXNbSU5URVJOQUxTXSA9IHtcblx0XHRcdHVybDogb3B0aW9ucy51cmwsXG5cdFx0XHRzdGF0dXMsXG5cdFx0XHRzdGF0dXNUZXh0OiBvcHRpb25zLnN0YXR1c1RleHQgfHwgJycsXG5cdFx0XHRoZWFkZXJzLFxuXHRcdFx0Y291bnRlcjogb3B0aW9ucy5jb3VudGVyIHx8IDAsXG5cdFx0XHRoaWdoV2F0ZXJNYXJrOiBvcHRpb25zLmhpZ2hXYXRlck1hcmtcblx0XHR9O1xuXHR9XG5cblx0LyoqXG5cdCAqIEB0eXBlIHtSZXNwb25zZVR5cGV9XG5cdCAqL1xuXHRnZXQgdHlwZSgpIHtcblx0XHRyZXR1cm4gXCJkZWZhdWx0XCJcblx0fVxuXG5cdGdldCB1cmwoKSB7XG5cdFx0cmV0dXJuIHRoaXNbSU5URVJOQUxTXS51cmwgfHwgJyc7XG5cdH1cblxuXHRnZXQgc3RhdHVzKCkge1xuXHRcdHJldHVybiB0aGlzW0lOVEVSTkFMU10uc3RhdHVzO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlbmllbmNlIHByb3BlcnR5IHJlcHJlc2VudGluZyBpZiB0aGUgcmVxdWVzdCBlbmRlZCBub3JtYWxseVxuXHQgKi9cblx0Z2V0IG9rKCkge1xuXHRcdHJldHVybiB0aGlzW0lOVEVSTkFMU10uc3RhdHVzID49IDIwMCAmJiB0aGlzW0lOVEVSTkFMU10uc3RhdHVzIDwgMzAwO1xuXHR9XG5cblx0Z2V0IHJlZGlyZWN0ZWQoKSB7XG5cdFx0cmV0dXJuIHRoaXNbSU5URVJOQUxTXS5jb3VudGVyID4gMDtcblx0fVxuXG5cdGdldCBzdGF0dXNUZXh0KCkge1xuXHRcdHJldHVybiB0aGlzW0lOVEVSTkFMU10uc3RhdHVzVGV4dDtcblx0fVxuXG5cdC8qKlxuXHQgKiBAdHlwZSB7SGVhZGVyc31cblx0ICovXG5cdGdldCBoZWFkZXJzKCkge1xuXHRcdHJldHVybiB0aGlzW0lOVEVSTkFMU10uaGVhZGVycztcblx0fVxuXG5cdGdldCBoaWdoV2F0ZXJNYXJrKCkge1xuXHRcdHJldHVybiB0aGlzW0lOVEVSTkFMU10uaGlnaFdhdGVyTWFyaztcblx0fVxuXG5cdC8qKlxuXHQgKiBDbG9uZSB0aGlzIHJlc3BvbnNlXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtSZXNwb25zZX1cblx0ICovXG5cdGNsb25lKCkge1xuXHRcdHJldHVybiBuZXcgUmVzcG9uc2UoY2xvbmUodGhpcyksIHtcblx0XHRcdHVybDogdGhpcy51cmwsXG5cdFx0XHRzdGF0dXM6IHRoaXMuc3RhdHVzLFxuXHRcdFx0c3RhdHVzVGV4dDogdGhpcy5zdGF0dXNUZXh0LFxuXHRcdFx0aGVhZGVyczogdGhpcy5oZWFkZXJzLFxuXHRcdFx0c2l6ZTogdGhpcy5zaXplXG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IHVybCAgICBUaGUgVVJMIHRoYXQgdGhlIG5ldyByZXNwb25zZSBpcyB0byBvcmlnaW5hdGUgZnJvbS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHN0YXR1cyBBbiBvcHRpb25hbCBzdGF0dXMgY29kZSBmb3IgdGhlIHJlc3BvbnNlIChlLmcuLCAzMDIuKVxuXHQgKiBAcmV0dXJucyB7UmVzcG9uc2V9ICAgIEEgUmVzcG9uc2Ugb2JqZWN0LlxuXHQgKi9cblx0c3RhdGljIHJlZGlyZWN0KHVybCwgc3RhdHVzID0gMzAyKSB7XG5cdFx0aWYgKCFpc1JlZGlyZWN0KHN0YXR1cykpIHtcblx0XHRcdHRocm93IG5ldyBSYW5nZUVycm9yKCdGYWlsZWQgdG8gZXhlY3V0ZSBcInJlZGlyZWN0XCIgb24gXCJyZXNwb25zZVwiOiBJbnZhbGlkIHN0YXR1cyBjb2RlJyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG5ldyBSZXNwb25zZShudWxsLCB7XG5cdFx0XHRoZWFkZXJzOiB7XG5cdFx0XHRcdGxvY2F0aW9uOiBuZXcgVVJMKHVybCkudG9TdHJpbmcoKVxuXHRcdFx0fSxcblx0XHRcdHN0YXR1c1xuXHRcdH0pO1xuXHR9XG5cblx0Z2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCkge1xuXHRcdHJldHVybiAnUmVzcG9uc2UnO1xuXHR9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFJlc3BvbnNlLnByb3RvdHlwZSwge1xuXHR1cmw6IHtlbnVtZXJhYmxlOiB0cnVlfSxcblx0c3RhdHVzOiB7ZW51bWVyYWJsZTogdHJ1ZX0sXG5cdG9rOiB7ZW51bWVyYWJsZTogdHJ1ZX0sXG5cdHJlZGlyZWN0ZWQ6IHtlbnVtZXJhYmxlOiB0cnVlfSxcblx0c3RhdHVzVGV4dDoge2VudW1lcmFibGU6IHRydWV9LFxuXHRoZWFkZXJzOiB7ZW51bWVyYWJsZTogdHJ1ZX0sXG5cdGNsb25lOiB7ZW51bWVyYWJsZTogdHJ1ZX1cbn0pO1xuXG4iLCAiXG4vKipcbiAqIFJlcXVlc3QuanNcbiAqXG4gKiBSZXF1ZXN0IGNsYXNzIGNvbnRhaW5zIHNlcnZlciBvbmx5IG9wdGlvbnNcbiAqXG4gKiBBbGwgc3BlYyBhbGdvcml0aG0gc3RlcCBudW1iZXJzIGFyZSBiYXNlZCBvbiBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy9jb21taXQtc25hcHNob3RzL2FlNzE2ODIyY2IzYTYxODQzMjI2Y2QwOTBlZWZjNjU4OTQ0NmMxZDIvLlxuICovXG5cbmltcG9ydCB7Zm9ybWF0IGFzIGZvcm1hdFVybH0gZnJvbSAndXJsJztcbmltcG9ydCB7QWJvcnRDb250cm9sbGVyIGFzIEFib3J0Q29udHJvbGxlclBvbHlmaWxsfSBmcm9tICdhYm9ydC1jb250cm9sbGVyJztcbmltcG9ydCBIZWFkZXJzIGZyb20gJy4vaGVhZGVycy5qcyc7XG5pbXBvcnQgQm9keSwge2Nsb25lLCBleHRyYWN0Q29udGVudFR5cGUsIGdldFRvdGFsQnl0ZXN9IGZyb20gJy4vYm9keS5qcyc7XG5pbXBvcnQge2lzQWJvcnRTaWduYWx9IGZyb20gJy4vdXRpbHMvaXMuanMnO1xuaW1wb3J0IHtnZXRTZWFyY2h9IGZyb20gJy4vdXRpbHMvZ2V0LXNlYXJjaC5qcyc7XG5cbmNvbnN0IElOVEVSTkFMUyA9IFN5bWJvbCgnUmVxdWVzdCBpbnRlcm5hbHMnKTtcblxuY29uc3QgZm9yYmlkZGVuTWV0aG9kcyA9IG5ldyBTZXQoW1wiQ09OTkVDVFwiLCBcIlRSQUNFXCIsIFwiVFJBQ0tcIl0pO1xuY29uc3Qgbm9ybWFsaXplZE1ldGhvZHMgPSBuZXcgU2V0KFtcIkRFTEVURVwiLCBcIkdFVFwiLCBcIkhFQURcIiwgXCJPUFRJT05TXCIsIFwiUE9TVFwiLCBcIlBVVFwiXSk7XG5cbi8qKlxuICogQ2hlY2sgaWYgYG9iamAgaXMgYW4gaW5zdGFuY2Ugb2YgUmVxdWVzdC5cbiAqXG4gKiBAcGFyYW0gIHthbnl9IG9iamVjdFxuICogQHJldHVybiB7b2JqZWN0IGlzIFJlcXVlc3R9XG4gKi9cbmNvbnN0IGlzUmVxdWVzdCA9IG9iamVjdCA9PiB7XG5cdHJldHVybiAoXG5cdFx0dHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiZcblx0XHR0eXBlb2Ygb2JqZWN0W0lOVEVSTkFMU10gPT09ICdvYmplY3QnXG5cdCk7XG59O1xuXG5cbi8qKlxuICogUmVxdWVzdCBjbGFzc1xuICogQGltcGxlbWVudHMge2dsb2JhbFRoaXMuUmVxdWVzdH1cbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBSZXF1ZXN0U3RhdGVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBtZXRob2RcbiAqIEBwcm9wZXJ0eSB7UmVxdWVzdFJlZGlyZWN0fSByZWRpcmVjdFxuICogQHByb3BlcnR5IHtnbG9iYWxUaGlzLkhlYWRlcnN9IGhlYWRlcnNcbiAqIEBwcm9wZXJ0eSB7UmVxdWVzdENyZWRlbnRpYWxzfSBjcmVkZW50aWFsc1xuICogQHByb3BlcnR5IHtVUkx9IHBhcnNlZFVSTFxuICogQHByb3BlcnR5IHtBYm9ydFNpZ25hbHxudWxsfSBzaWduYWxcbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBSZXF1ZXN0RXh0cmFPcHRpb25zXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2ZvbGxvd11cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2NvbXByZXNzXVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtzaXplXVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtjb3VudGVyXVxuICogQHByb3BlcnR5IHtBZ2VudH0gW2FnZW50XVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtoaWdoV2F0ZXJNYXJrXVxuICogQHByb3BlcnR5IHtib29sZWFufSBbaW5zZWN1cmVIVFRQUGFyc2VyXVxuICpcbiAqIEB0eXBlZGVmIHsoKHVybDpVUkwpID0+IGltcG9ydCgnaHR0cCcpLkFnZW50IHwgaW1wb3J0KCdodHRwcycpLkFnZW50KSB8IGltcG9ydCgnaHR0cCcpLkFnZW50IHwgaW1wb3J0KCdodHRwcycpLkFnZW50fSBBZ2VudFxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFJlcXVlc3RPcHRpb25zXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW21ldGhvZF1cbiAqIEBwcm9wZXJ0eSB7UmVhZGFibGVTdHJlYW08VWludDhBcnJheT58bnVsbH0gW2JvZHldXG4gKiBAcHJvcGVydHkge2dsb2JhbFRoaXMuSGVhZGVyc30gW2hlYWRlcnNdXG4gKiBAcHJvcGVydHkge1JlcXVlc3RSZWRpcmVjdH0gW3JlZGlyZWN0XVxuICpcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVxdWVzdCBleHRlbmRzIEJvZHkge1xuXHQvKipcblx0ICogQHBhcmFtIHtzdHJpbmd8UmVxdWVzdHxVUkx9IGluZm8gIFVybCBvciBSZXF1ZXN0IGluc3RhbmNlXG5cdCAqIEBwYXJhbSB7UmVxdWVzdEluaXQgJiBSZXF1ZXN0RXh0cmFPcHRpb25zfSBpbml0ICAgQ3VzdG9tIG9wdGlvbnNcblx0ICovXG5cdGNvbnN0cnVjdG9yKGluZm8sIGluaXQgPSB7fSkge1xuXHRcdGxldCBwYXJzZWRVUkw7XG5cdFx0LyoqIEB0eXBlIHtSZXF1ZXN0T3B0aW9ucyAmIFJlcXVlc3RFeHRyYU9wdGlvbnN9ICovXG5cdFx0bGV0IHNldHRpbmdzXG5cblx0XHQvLyBOb3JtYWxpemUgaW5wdXQgYW5kIGZvcmNlIFVSTCB0byBiZSBlbmNvZGVkIGFzIFVURi04IChodHRwczovL2dpdGh1Yi5jb20vbm9kZS1mZXRjaC9ub2RlLWZldGNoL2lzc3Vlcy8yNDUpXG5cdFx0aWYgKGlzUmVxdWVzdChpbmZvKSkge1xuXHRcdFx0cGFyc2VkVVJMID0gbmV3IFVSTChpbmZvLnVybCk7XG5cdFx0XHRzZXR0aW5ncyA9IChpbmZvKVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRwYXJzZWRVUkwgPSBuZXcgVVJMKGluZm8pO1xuXHRcdFx0c2V0dGluZ3MgPSB7fTtcblx0XHR9XG5cblxuXG5cdFx0Ly8gTm9ybWFsaXplIG1ldGhvZDogaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI21ldGhvZHNcblx0XHRsZXQgbWV0aG9kID0gaW5pdC5tZXRob2QgfHwgc2V0dGluZ3MubWV0aG9kIHx8ICdHRVQnO1xuXHRcdGlmIChmb3JiaWRkZW5NZXRob2RzLmhhcyhtZXRob2QudG9VcHBlckNhc2UoKSkpIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoYEZhaWxlZCB0byBjb25zdHJ1Y3QgJ1JlcXVlc3QnOiAnJHttZXRob2R9JyBIVFRQIG1ldGhvZCBpcyB1bnN1cHBvcnRlZC5gKVxuXHRcdH0gZWxzZSBpZiAobm9ybWFsaXplZE1ldGhvZHMuaGFzKG1ldGhvZC50b1VwcGVyQ2FzZSgpKSkge1xuXHRcdFx0bWV0aG9kID0gbWV0aG9kLnRvVXBwZXJDYXNlKCk7XG5cdFx0fVxuXG5cdFx0Y29uc3QgaW5wdXRCb2R5ID0gaW5pdC5ib2R5ICE9IG51bGxcblx0XHRcdD8gaW5pdC5ib2R5XG5cdFx0XHQ6IChpc1JlcXVlc3QoaW5mbykgJiYgaW5mby5ib2R5ICE9PSBudWxsKVxuXHRcdFx0PyBjbG9uZShpbmZvKVxuXHRcdFx0OiBudWxsO1xuXG5cdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVxLW51bGwsIGVxZXFlcVxuXHRcdGlmIChpbnB1dEJvZHkgIT0gbnVsbCAmJiAobWV0aG9kID09PSAnR0VUJyB8fCBtZXRob2QgPT09ICdIRUFEJykpIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ1JlcXVlc3Qgd2l0aCBHRVQvSEVBRCBtZXRob2QgY2Fubm90IGhhdmUgYm9keScpO1xuXHRcdH1cblxuXHRcdHN1cGVyKGlucHV0Qm9keSwge1xuXHRcdFx0c2l6ZTogaW5pdC5zaXplIHx8IHNldHRpbmdzLnNpemUgfHwgMFxuXHRcdH0pO1xuXHRcdGNvbnN0IGlucHV0ID0gc2V0dGluZ3NcblxuXG5cdFx0Y29uc3QgaGVhZGVycyA9IC8qKiBAdHlwZSB7Z2xvYmFsVGhpcy5IZWFkZXJzfSAqL1xuXHRcdFx0KG5ldyBIZWFkZXJzKGluaXQuaGVhZGVycyB8fCBpbnB1dC5oZWFkZXJzIHx8IHt9KSk7XG5cblx0XHRpZiAoaW5wdXRCb2R5ICE9PSBudWxsICYmICFoZWFkZXJzLmhhcygnQ29udGVudC1UeXBlJykpIHtcblx0XHRcdGNvbnN0IGNvbnRlbnRUeXBlID0gZXh0cmFjdENvbnRlbnRUeXBlKHRoaXMpO1xuXHRcdFx0aWYgKGNvbnRlbnRUeXBlKSB7XG5cdFx0XHRcdGhlYWRlcnMuYXBwZW5kKCdDb250ZW50LVR5cGUnLCBjb250ZW50VHlwZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0bGV0IHNpZ25hbCA9ICdzaWduYWwnIGluIGluaXRcblx0XHRcdD8gaW5pdC5zaWduYWxcblx0XHRcdDogaXNSZXF1ZXN0KGlucHV0KVxuXHRcdFx0PyBpbnB1dC5zaWduYWxcblx0XHRcdDogbnVsbDtcblxuXHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lcS1udWxsLCBlcWVxZXFcblx0XHRpZiAoc2lnbmFsICE9IG51bGwgJiYgIWlzQWJvcnRTaWduYWwoc2lnbmFsKSkge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgc2lnbmFsIHRvIGJlIGFuIGluc3RhbmNlb2YgQWJvcnRTaWduYWwgb3IgRXZlbnRUYXJnZXQnKTtcblx0XHR9XG5cdFx0XG5cdFx0aWYgKCFzaWduYWwpIHtcblx0XHRcdGxldCBBYm9ydENvbnRyb2xsZXJDb25zdHJ1Y3RvciA9IHR5cGVvZiBBYm9ydENvbnRyb2xsZXIgIT0gXCJ1bmRlZmluZWRcIlxuXHRcdFx0PyBBYm9ydENvbnRyb2xsZXJcblx0XHRcdDogQWJvcnRDb250cm9sbGVyUG9seWZpbGw7XG5cdFx0XHQvKiogQHR5cGUge2FueX0gKi9cblx0XHRcdGxldCBuZXdTaWduYWwgPSBuZXcgQWJvcnRDb250cm9sbGVyQ29uc3RydWN0b3IoKS5zaWduYWw7XG5cdFx0XHRzaWduYWwgPSBuZXdTaWduYWw7XG5cdFx0fVxuXG5cdFx0LyoqIEB0eXBlIHtSZXF1ZXN0U3RhdGV9ICovXG5cdFx0dGhpc1tJTlRFUk5BTFNdID0ge1xuXHRcdFx0bWV0aG9kLFxuXHRcdFx0cmVkaXJlY3Q6IGluaXQucmVkaXJlY3QgfHwgaW5wdXQucmVkaXJlY3QgfHwgJ2ZvbGxvdycsXG5cdFx0XHRoZWFkZXJzLFxuXHRcdFx0Y3JlZGVudGlhbHM6IGluaXQuY3JlZGVudGlhbHMgfHwgJ3NhbWUtb3JpZ2luJyxcblx0XHRcdHBhcnNlZFVSTCxcblx0XHRcdHNpZ25hbDogc2lnbmFsIHx8IG51bGxcblx0XHR9O1xuXG5cdFx0LyoqIEB0eXBlIHtib29sZWFufSAqL1xuXHRcdHRoaXMua2VlcGFsaXZlXG5cblx0XHQvLyBOb2RlLWZldGNoLW9ubHkgb3B0aW9uc1xuXHRcdC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuXHRcdHRoaXMuZm9sbG93ID0gaW5pdC5mb2xsb3cgPT09IHVuZGVmaW5lZCA/IChpbnB1dC5mb2xsb3cgPT09IHVuZGVmaW5lZCA/IDIwIDogaW5wdXQuZm9sbG93KSA6IGluaXQuZm9sbG93O1xuXHRcdC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cblx0XHR0aGlzLmNvbXByZXNzID0gaW5pdC5jb21wcmVzcyA9PT0gdW5kZWZpbmVkID8gKGlucHV0LmNvbXByZXNzID09PSB1bmRlZmluZWQgPyB0cnVlIDogaW5wdXQuY29tcHJlc3MpIDogaW5pdC5jb21wcmVzcztcblx0XHQvKiogQHR5cGUge251bWJlcn0gKi9cblx0XHR0aGlzLmNvdW50ZXIgPSBpbml0LmNvdW50ZXIgfHwgaW5wdXQuY291bnRlciB8fCAwO1xuXHRcdC8qKiBAdHlwZSB7QWdlbnR8dW5kZWZpbmVkfSAqL1xuXHRcdHRoaXMuYWdlbnQgPSBpbml0LmFnZW50IHx8IGlucHV0LmFnZW50O1xuXHRcdC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuXHRcdHRoaXMuaGlnaFdhdGVyTWFyayA9IGluaXQuaGlnaFdhdGVyTWFyayB8fCBpbnB1dC5oaWdoV2F0ZXJNYXJrIHx8IDE2Mzg0O1xuXHRcdC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cblx0XHR0aGlzLmluc2VjdXJlSFRUUFBhcnNlciA9IGluaXQuaW5zZWN1cmVIVFRQUGFyc2VyIHx8IGlucHV0Lmluc2VjdXJlSFRUUFBhcnNlciB8fCBmYWxzZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAdHlwZSB7UmVxdWVzdENhY2hlfVxuXHQgKi9cblx0Z2V0IGNhY2hlKCkge1xuXHRcdHJldHVybiBcImRlZmF1bHRcIlxuXHR9XG5cblx0LyoqXG5cdCAqIEB0eXBlIHtSZXF1ZXN0Q3JlZGVudGlhbHN9XG5cdCAqL1xuXG5cdGdldCBjcmVkZW50aWFscygpIHtcblx0XHRyZXR1cm4gdGhpc1tJTlRFUk5BTFNdLmNyZWRlbnRpYWxzXG5cdH1cblxuXHQvKipcblx0ICogQHR5cGUge1JlcXVlc3REZXN0aW5hdGlvbn1cblx0ICovXG5cdGdldCBkZXN0aW5hdGlvbigpIHtcblx0XHRyZXR1cm4gXCJcIlxuXHR9XG5cblx0Z2V0IGludGVncml0eSgpIHtcblx0XHRyZXR1cm4gXCJcIlxuXHR9XG5cblx0LyoqIEB0eXBlIHtSZXF1ZXN0TW9kZX0gKi9cblx0Z2V0IG1vZGUoKSB7XG5cdFx0cmV0dXJuIFwiY29yc1wiXG5cdH1cblxuXHQvKiogQHR5cGUge3N0cmluZ30gKi9cblx0Z2V0IHJlZmVycmVyKCkge1xuXHRcdHJldHVybiAgXCJcIlxuXHR9XG5cblx0LyoqIEB0eXBlIHtSZWZlcnJlclBvbGljeX0gKi9cblx0Z2V0IHJlZmVycmVyUG9saWN5KCkge1xuXHRcdHJldHVybiBcIlwiXG5cdH1cblx0Z2V0IG1ldGhvZCgpIHtcblx0XHRyZXR1cm4gdGhpc1tJTlRFUk5BTFNdLm1ldGhvZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBAdHlwZSB7c3RyaW5nfVxuXHQgKi9cblx0Z2V0IHVybCgpIHtcblx0XHRyZXR1cm4gZm9ybWF0VXJsKHRoaXNbSU5URVJOQUxTXS5wYXJzZWRVUkwpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEB0eXBlIHtnbG9iYWxUaGlzLkhlYWRlcnN9XG5cdCAqL1xuXHRnZXQgaGVhZGVycygpIHtcblx0XHRyZXR1cm4gdGhpc1tJTlRFUk5BTFNdLmhlYWRlcnM7XG5cdH1cblxuXHRnZXQgcmVkaXJlY3QoKSB7XG5cdFx0cmV0dXJuIHRoaXNbSU5URVJOQUxTXS5yZWRpcmVjdDtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7QWJvcnRTaWduYWx9XG5cdCAqL1xuXHRnZXQgc2lnbmFsKCkge1xuXHRcdC8vIEB0cy1pZ25vcmVcblx0XHRyZXR1cm4gdGhpc1tJTlRFUk5BTFNdLnNpZ25hbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDbG9uZSB0aGlzIHJlcXVlc3Rcblx0ICpcblx0ICogQHJldHVybiAge2dsb2JhbFRoaXMuUmVxdWVzdH1cblx0ICovXG5cdGNsb25lKCkge1xuXHRcdHJldHVybiBuZXcgUmVxdWVzdCh0aGlzKTtcblx0fVxuXG5cdGdldCBbU3ltYm9sLnRvU3RyaW5nVGFnXSgpIHtcblx0XHRyZXR1cm4gJ1JlcXVlc3QnO1xuXHR9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFJlcXVlc3QucHJvdG90eXBlLCB7XG5cdG1ldGhvZDoge2VudW1lcmFibGU6IHRydWV9LFxuXHR1cmw6IHtlbnVtZXJhYmxlOiB0cnVlfSxcblx0aGVhZGVyczoge2VudW1lcmFibGU6IHRydWV9LFxuXHRyZWRpcmVjdDoge2VudW1lcmFibGU6IHRydWV9LFxuXHRjbG9uZToge2VudW1lcmFibGU6IHRydWV9LFxuXHRzaWduYWw6IHtlbnVtZXJhYmxlOiB0cnVlfVxufSk7XG5cbi8qKlxuICogQ29udmVydCBhIFJlcXVlc3QgdG8gTm9kZS5qcyBodHRwIHJlcXVlc3Qgb3B0aW9ucy5cbiAqIFRoZSBvcHRpb25zIG9iamVjdCB0byBiZSBwYXNzZWQgdG8gaHR0cC5yZXF1ZXN0XG4gKlxuICogQHBhcmFtIHtSZXF1ZXN0ICYgUmVjb3JkPElOVEVSTkFMUywgUmVxdWVzdFN0YXRlPn0gcmVxdWVzdCAtICBBIFJlcXVlc3QgaW5zdGFuY2VcbiAqL1xuZXhwb3J0IGNvbnN0IGdldE5vZGVSZXF1ZXN0T3B0aW9ucyA9IHJlcXVlc3QgPT4ge1xuXHRjb25zdCB7cGFyc2VkVVJMfSA9IHJlcXVlc3RbSU5URVJOQUxTXTtcblx0Y29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKHJlcXVlc3RbSU5URVJOQUxTXS5oZWFkZXJzKTtcblxuXHQvLyBGZXRjaCBzdGVwIDEuM1xuXHRpZiAoIWhlYWRlcnMuaGFzKCdBY2NlcHQnKSkge1xuXHRcdGhlYWRlcnMuc2V0KCdBY2NlcHQnLCAnKi8qJyk7XG5cdH1cblxuXHQvLyBIVFRQLW5ldHdvcmstb3ItY2FjaGUgZmV0Y2ggc3RlcHMgMi40LTIuN1xuXHRsZXQgY29udGVudExlbmd0aFZhbHVlID0gbnVsbDtcblx0aWYgKHJlcXVlc3QuYm9keSA9PT0gbnVsbCAmJiAvXihwb3N0fHB1dCkkL2kudGVzdChyZXF1ZXN0Lm1ldGhvZCkpIHtcblx0XHRjb250ZW50TGVuZ3RoVmFsdWUgPSAnMCc7XG5cdH1cblxuXHRpZiAocmVxdWVzdC5ib2R5ICE9PSBudWxsKSB7XG5cdFx0Y29uc3QgdG90YWxCeXRlcyA9IGdldFRvdGFsQnl0ZXMocmVxdWVzdCk7XG5cdFx0Ly8gU2V0IENvbnRlbnQtTGVuZ3RoIGlmIHRvdGFsQnl0ZXMgaXMgYSBudW1iZXIgKHRoYXQgaXMgbm90IE5hTilcblx0XHRpZiAodHlwZW9mIHRvdGFsQnl0ZXMgPT09ICdudW1iZXInICYmICFOdW1iZXIuaXNOYU4odG90YWxCeXRlcykpIHtcblx0XHRcdGNvbnRlbnRMZW5ndGhWYWx1ZSA9IFN0cmluZyh0b3RhbEJ5dGVzKTtcblx0XHR9XG5cdH1cblxuXHRpZiAoY29udGVudExlbmd0aFZhbHVlKSB7XG5cdFx0aGVhZGVycy5zZXQoJ0NvbnRlbnQtTGVuZ3RoJywgY29udGVudExlbmd0aFZhbHVlKTtcblx0fVxuXG5cdC8vIEhUVFAtbmV0d29yay1vci1jYWNoZSBmZXRjaCBzdGVwIDIuMTFcblx0aWYgKCFoZWFkZXJzLmhhcygnVXNlci1BZ2VudCcpKSB7XG5cdFx0aGVhZGVycy5zZXQoJ1VzZXItQWdlbnQnLCAnbm9kZS1mZXRjaCcpO1xuXHR9XG5cblx0Ly8gSFRUUC1uZXR3b3JrLW9yLWNhY2hlIGZldGNoIHN0ZXAgMi4xNVxuXHRpZiAocmVxdWVzdC5jb21wcmVzcyAmJiAhaGVhZGVycy5oYXMoJ0FjY2VwdC1FbmNvZGluZycpKSB7XG5cdFx0aGVhZGVycy5zZXQoJ0FjY2VwdC1FbmNvZGluZycsICdnemlwLGRlZmxhdGUsYnInKTtcblx0fVxuXG5cdGxldCB7YWdlbnR9ID0gcmVxdWVzdDtcblx0aWYgKHR5cGVvZiBhZ2VudCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdGFnZW50ID0gYWdlbnQocGFyc2VkVVJMKTtcblx0fVxuXG5cdGlmICghaGVhZGVycy5oYXMoJ0Nvbm5lY3Rpb24nKSAmJiAhYWdlbnQpIHtcblx0XHRoZWFkZXJzLnNldCgnQ29ubmVjdGlvbicsICdjbG9zZScpO1xuXHR9XG5cblx0Ly8gSFRUUC1uZXR3b3JrIGZldGNoIHN0ZXAgNC4yXG5cdC8vIGNodW5rZWQgZW5jb2RpbmcgaXMgaGFuZGxlZCBieSBOb2RlLmpzXG5cblx0Y29uc3Qgc2VhcmNoID0gZ2V0U2VhcmNoKHBhcnNlZFVSTCk7XG5cblx0Ly8gTWFudWFsbHkgc3ByZWFkIHRoZSBVUkwgb2JqZWN0IGluc3RlYWQgb2Ygc3ByZWFkIHN5bnRheFxuXHRjb25zdCByZXF1ZXN0T3B0aW9ucyA9IHtcblx0XHRwYXRoOiBwYXJzZWRVUkwucGF0aG5hbWUgKyBzZWFyY2gsXG5cdFx0cGF0aG5hbWU6IHBhcnNlZFVSTC5wYXRobmFtZSxcblx0XHRob3N0bmFtZTogcGFyc2VkVVJMLmhvc3RuYW1lLFxuXHRcdHByb3RvY29sOiBwYXJzZWRVUkwucHJvdG9jb2wsXG5cdFx0cG9ydDogcGFyc2VkVVJMLnBvcnQsXG5cdFx0aGFzaDogcGFyc2VkVVJMLmhhc2gsXG5cdFx0c2VhcmNoOiBwYXJzZWRVUkwuc2VhcmNoLFxuXHRcdC8vIEB0cy1pZ25vcmUgLSBpdCBkb2VzIG5vdCBoYXMgYSBxdWVyeVxuXHRcdHF1ZXJ5OiBwYXJzZWRVUkwucXVlcnksXG5cdFx0aHJlZjogcGFyc2VkVVJMLmhyZWYsXG5cdFx0bWV0aG9kOiByZXF1ZXN0Lm1ldGhvZCxcblx0XHQvLyBAdHMtaWdub3JlIC0gbm90IHN1cmUgd2hhdCB0aGlzIHN1cHBvc2VkIHRvIGRvXG5cdFx0aGVhZGVyczogaGVhZGVyc1tTeW1ib2wuZm9yKCdub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbScpXSgpLFxuXHRcdGluc2VjdXJlSFRUUFBhcnNlcjogcmVxdWVzdC5pbnNlY3VyZUhUVFBQYXJzZXIsXG5cdFx0YWdlbnRcblx0fTtcblxuXHRyZXR1cm4gcmVxdWVzdE9wdGlvbnM7XG59O1xuIiwgIi8qKlxuICogQHBhcmFtIHtVUkx9IHBhcnNlZFVSTCBcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBjb25zdCBnZXRTZWFyY2ggPSBwYXJzZWRVUkwgPT4ge1xuXHRpZiAocGFyc2VkVVJMLnNlYXJjaCkge1xuXHRcdHJldHVybiBwYXJzZWRVUkwuc2VhcmNoO1xuXHR9XG5cblx0Y29uc3QgbGFzdE9mZnNldCA9IHBhcnNlZFVSTC5ocmVmLmxlbmd0aCAtIDE7XG5cdGNvbnN0IGhhc2ggPSBwYXJzZWRVUkwuaGFzaCB8fCAocGFyc2VkVVJMLmhyZWZbbGFzdE9mZnNldF0gPT09ICcjJyA/ICcjJyA6ICcnKTtcblx0cmV0dXJuIHBhcnNlZFVSTC5ocmVmW2xhc3RPZmZzZXQgLSBoYXNoLmxlbmd0aF0gPT09ICc/JyA/ICc/JyA6ICcnO1xufTtcbiIsICJpbXBvcnQge0ZldGNoQmFzZUVycm9yfSBmcm9tICcuL2Jhc2UuanMnO1xuXG4vKipcbiAqIEFib3J0RXJyb3IgaW50ZXJmYWNlIGZvciBjYW5jZWxsZWQgcmVxdWVzdHNcbiAqL1xuZXhwb3J0IGNsYXNzIEFib3J0RXJyb3IgZXh0ZW5kcyBGZXRjaEJhc2VFcnJvciB7XG5cdC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSBcblx0ICogQHBhcmFtIHtzdHJpbmd9IFt0eXBlXVxuXHQgKi9cblx0Y29uc3RydWN0b3IobWVzc2FnZSwgdHlwZSA9ICdhYm9ydGVkJykge1xuXHRcdHN1cGVyKG1lc3NhZ2UsIHR5cGUpO1xuXHR9XG59XG4iLCAiaW1wb3J0IHsgZmV0Y2ggYXMgd2ViRmV0Y2gsIEhlYWRlcnMgYXMgV2ViSGVhZGVycywgUmVxdWVzdCBhcyBXZWJSZXF1ZXN0LCBSZXNwb25zZSBhcyBXZWJSZXNwb25zZSB9IGZyb20gXCIuL2ZldGNoLmpzXCJcblxuZXhwb3J0IHsgUmVhZGFibGVTdHJlYW0sIEJsb2IsIEZvcm1EYXRhLCBGaWxlICB9IGZyb20gJy4vcGFja2FnZS5qcyc7XG4vLyBFbGVjdHJvbi1yZW5kZXJlciBzaG91bGQgZ2V0IHRoZSBicm93c2VyIGltcGxlbWVudGF0aW9uIGluc3RlYWQgb2Ygbm9kZVxuLy8gQnJvd3NlciBjb25maWd1cmF0aW9uIGlzIG5vdCBlbm91Z2hcblxuLy8gTWFya2luZyBleHBvcnQgYXMgYSBET00gRmlsZSBvYmplY3QgaW5zdGVhZCBvZiBjdXN0b20gY2xhc3MuXG5leHBvcnQgY29uc3QgZmV0Y2ggPSAvKiogQHR5cGUge3R5cGVvZiBnbG9iYWxUaGlzLmZldGNofSAqL1xuICAodHlwZW9mIGdsb2JhbFRoaXMuZmV0Y2ggPT09IFwiZnVuY3Rpb25cIiA/IGdsb2JhbFRoaXMuZmV0Y2guYmluZChnbG9iYWxUaGlzKSA6IHdlYkZldGNoKVxuXG5leHBvcnQgY29uc3QgSGVhZGVycyA9IGdsb2JhbFRoaXMuSGVhZGVycyB8fCBXZWJIZWFkZXJzXG5leHBvcnQgY29uc3QgUmVxdWVzdCA9IGdsb2JhbFRoaXMuUmVxdWVzdCB8fCBXZWJSZXF1ZXN0XG5leHBvcnQgY29uc3QgUmVzcG9uc2UgPSBnbG9iYWxUaGlzLlJlc3BvbnNlIHx8IFdlYlJlc3BvbnNlXG5cbmV4cG9ydCBkZWZhdWx0IGZldGNoXG4iLCAiaW1wb3J0IGZzIGZyb20gJ2ZzJztcbmltcG9ydCBvcyBmcm9tICdvcyc7XG5pbXBvcnQgeyBDSUQgfSBmcm9tICdtdWx0aWZvcm1hdHMnO1xuaW1wb3J0IHsgQmFzZUJsb2Nrc3RvcmUgfSBmcm9tICdibG9ja3N0b3JlLWNvcmUnO1xuZXhwb3J0IGNsYXNzIEZzQmxvY2tTdG9yZSBleHRlbmRzIEJhc2VCbG9ja3N0b3JlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5wYXRoID0gYCR7b3MudG1wZGlyKCl9LyR7KHBhcnNlSW50KFN0cmluZyhNYXRoLnJhbmRvbSgpICogMWU5KSwgMTApKS50b1N0cmluZygpICsgRGF0ZS5ub3coKX1gO1xuICAgICAgICB0aGlzLl9vcGVuZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgYXN5bmMgX29wZW4oKSB7XG4gICAgICAgIGlmICh0aGlzLl9vcGVuaW5nKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9vcGVuaW5nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fb3BlbmluZyA9IGZzLnByb21pc2VzLm1rZGlyKHRoaXMucGF0aCk7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9vcGVuaW5nO1xuICAgICAgICAgICAgdGhpcy5fb3BlbmVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBwdXQoY2lkLCBieXRlcykge1xuICAgICAgICBpZiAoIXRoaXMuX29wZW5lZCkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fb3BlbigpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNpZFN0ciA9IGNpZC50b1N0cmluZygpO1xuICAgICAgICBjb25zdCBsb2NhdGlvbiA9IGAke3RoaXMucGF0aH0vJHtjaWRTdHJ9YDtcbiAgICAgICAgYXdhaXQgZnMucHJvbWlzZXMud3JpdGVGaWxlKGxvY2F0aW9uLCBieXRlcyk7XG4gICAgfVxuICAgIGFzeW5jIGdldChjaWQpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9vcGVuZWQpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX29wZW4oKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjaWRTdHIgPSBjaWQudG9TdHJpbmcoKTtcbiAgICAgICAgY29uc3QgbG9jYXRpb24gPSBgJHt0aGlzLnBhdGh9LyR7Y2lkU3RyfWA7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gYXdhaXQgZnMucHJvbWlzZXMucmVhZEZpbGUobG9jYXRpb24pO1xuICAgICAgICByZXR1cm4gYnl0ZXM7XG4gICAgfVxuICAgIGFzeW5jIGhhcyhjaWQpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9vcGVuZWQpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX29wZW4oKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjaWRTdHIgPSBjaWQudG9TdHJpbmcoKTtcbiAgICAgICAgY29uc3QgbG9jYXRpb24gPSBgJHt0aGlzLnBhdGh9LyR7Y2lkU3RyfWA7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCBmcy5wcm9taXNlcy5hY2Nlc3MobG9jYXRpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jICpibG9ja3MoKSB7XG4gICAgICAgIGlmICghdGhpcy5fb3BlbmVkKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9vcGVuKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2lkcyA9IGF3YWl0IGZzLnByb21pc2VzLnJlYWRkaXIodGhpcy5wYXRoKTtcbiAgICAgICAgZm9yIChjb25zdCBjaWRTdHIgb2YgY2lkcykge1xuICAgICAgICAgICAgY29uc3QgbG9jYXRpb24gPSBgJHt0aGlzLnBhdGh9LyR7Y2lkU3RyfWA7XG4gICAgICAgICAgICBjb25zdCBieXRlcyA9IGF3YWl0IGZzLnByb21pc2VzLnJlYWRGaWxlKGxvY2F0aW9uKTtcbiAgICAgICAgICAgIHlpZWxkIHsgY2lkOiBDSUQucGFyc2UoY2lkU3RyKSwgYnl0ZXMgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBjbG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX29wZW5lZCkge1xuICAgICAgICAgICAgYXdhaXQgZnMucHJvbWlzZXMucm0odGhpcy5wYXRoLCB7IHJlY3Vyc2l2ZTogdHJ1ZSB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9vcGVuZWQgPSBmYWxzZTtcbiAgICB9XG59XG4iLCAiZXhwb3J0IGNvbnN0IEdBVEVXQVkgPSBuZXcgVVJMKCdodHRwczovL25mdHN0b3JhZ2UubGluay8nKVxuXG4vKipcbiAqIEB0eXBlZGVmIHtzdHJpbmd8VVJMfSBHYXRld2F5VVJMIEJhc2UgVVJMIG9mIGFuIElQRlMgR2F0ZXdheSBlLmcuIGh0dHBzOi8vZHdlYi5saW5rLyBvciBodHRwczovL2lwZnMuaW8vXG4gKiBAdHlwZWRlZiB7eyBnYXRld2F5PzogR2F0ZXdheVVSTCB9fSBHYXRld2F5VVJMT3B0aW9uc1xuICovXG5cbi8qKlxuICogQ29udmVydCBhbiBJUEZTIFVSTCAoc3RhcnRpbmcgaXBmczovLykgdG8gYSBnYXRld2F5IFVSTCAoc3RhcnRpbmcgaHR0cHM6Ly8pXG4gKiB0aGF0IGNhbiBiZSB1c2VkIGluIGEgd2VicGFnZS4gSWYgdGhlIHBhc3NlZCBVUkwgaXMgbm90IGFuIElQRlMgVVJMIGl0IGlzXG4gKiByZXR1cm5lZCBhcyBhIG5ldyBVUkwgb2JqZWN0IHdpdGggbm8gZnVydGhlciBjaGFuZ2VzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfFVSTH0gdXJsIEFuIElQRlMgVVJMIGUuZy4gaXBmczovL2JhZnkuLi4vcGF0aFxuICogQHBhcmFtIHtHYXRld2F5VVJMT3B0aW9uc30gW29wdGlvbnNdIE9wdGlvbnMgdGhhdCBhbGxvdyBjdXN0b21pemF0aW9uIG9mIHRoZSBnYXRld2F5IHVzZWQuXG4gKiBAcmV0dXJucyB7VVJMfSBBbiBJUEZTIGdhdGV3YXkgVVJMIGUuZy4gaHR0cHM6Ly9uZnRzdG9yYWdlLmxpbmsvaXBmcy9iYWZ5Li4uL3BhdGhcbiAqL1xuZXhwb3J0IGNvbnN0IHRvR2F0ZXdheVVSTCA9ICh1cmwsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICBjb25zdCBnYXRld2F5ID0gb3B0aW9ucy5nYXRld2F5IHx8IEdBVEVXQVlcbiAgdXJsID0gbmV3IFVSTChTdHJpbmcodXJsKSlcbiAgcmV0dXJuIHVybC5wcm90b2NvbCA9PT0gJ2lwZnM6J1xuICAgID8gbmV3IFVSTChgL2lwZnMvJHt1cmwuaHJlZi5zbGljZSgnaXBmczovLycubGVuZ3RoKX1gLCBnYXRld2F5KVxuICAgIDogdXJsXG59XG4iLCAiLyoqXG4gKiBBbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgQ0FSIHJlYWRlciBpbnRlcmZhY2UgdGhhdCBpcyBiYWNrZWQgYnkgYSBibG9ja3N0b3JlLlxuICpcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ211bHRpZm9ybWF0cycpLkNJRH0gQ0lEXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdAaXBsZC9jYXIvYXBpJykuQ2FyUmVhZGVyfSBDYXJSZWFkZXJcbiAqIEBpbXBsZW1lbnRzIHtDYXJSZWFkZXJ9XG4gKi9cbmV4cG9ydCBjbGFzcyBCbG9ja3N0b3JlQ2FyUmVhZGVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2ZXJzaW9uXG4gICAqIEBwYXJhbSB7Q0lEW119IHJvb3RzXG4gICAqIEBwYXJhbSB7aW1wb3J0KCdpcGZzLWNhci9ibG9ja3N0b3JlJykuQmxvY2tzdG9yZX0gYmxvY2tzdG9yZVxuICAgKi9cbiAgY29uc3RydWN0b3IodmVyc2lvbiwgcm9vdHMsIGJsb2Nrc3RvcmUpIHtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3ZlcnNpb24gPSB2ZXJzaW9uXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9yb290cyA9IHJvb3RzXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9ibG9ja3N0b3JlID0gYmxvY2tzdG9yZVxuICB9XG5cbiAgZ2V0IHZlcnNpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZlcnNpb25cbiAgfVxuXG4gIGdldCBibG9ja3N0b3JlKCkge1xuICAgIHJldHVybiB0aGlzLl9ibG9ja3N0b3JlXG4gIH1cblxuICBhc3luYyBnZXRSb290cygpIHtcbiAgICByZXR1cm4gdGhpcy5fcm9vdHNcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0NJRH0gY2lkXG4gICAqL1xuICBoYXMoY2lkKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Jsb2Nrc3RvcmUuaGFzKGNpZClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0NJRH0gY2lkXG4gICAqL1xuICBhc3luYyBnZXQoY2lkKSB7XG4gICAgY29uc3QgYnl0ZXMgPSBhd2FpdCB0aGlzLl9ibG9ja3N0b3JlLmdldChjaWQpXG4gICAgcmV0dXJuIHsgY2lkLCBieXRlcyB9XG4gIH1cblxuICBibG9ja3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Jsb2Nrc3RvcmUuYmxvY2tzKClcbiAgfVxuXG4gIGFzeW5jICpjaWRzKCkge1xuICAgIGZvciBhd2FpdCAoY29uc3QgYiBvZiB0aGlzLmJsb2NrcygpKSB7XG4gICAgICB5aWVsZCBiLmNpZFxuICAgIH1cbiAgfVxufVxuIiwgImltcG9ydCB7IHBhY2sgfSBmcm9tICdpcGZzLWNhci9wYWNrJ1xuaW1wb3J0IHsgQ0lEIH0gZnJvbSAnbXVsdGlmb3JtYXRzL2NpZCdcbmltcG9ydCAqIGFzIEJsb2NrIGZyb20gJ211bHRpZm9ybWF0cy9ibG9jaydcbmltcG9ydCB7IHNoYTI1NiB9IGZyb20gJ211bHRpZm9ybWF0cy9oYXNoZXMvc2hhMidcbmltcG9ydCAqIGFzIGRhZ0Nib3IgZnJvbSAnQGlwbGQvZGFnLWNib3InXG5pbXBvcnQgeyBCbG9iLCBGb3JtRGF0YSwgQmxvY2tzdG9yZSB9IGZyb20gJy4vcGxhdGZvcm0uanMnXG5pbXBvcnQgeyB0b0dhdGV3YXlVUkwsIEdBVEVXQVkgfSBmcm9tICcuL2dhdGV3YXkuanMnXG5pbXBvcnQgeyBCbG9ja3N0b3JlQ2FyUmVhZGVyIH0gZnJvbSAnLi9icy1jYXItcmVhZGVyLmpzJ1xuXG4vKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4vZ2F0ZXdheS5qcycpLkdhdGV3YXlVUkxPcHRpb25zfSBFbWJlZE9wdGlvbnNcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4vbGliL2ludGVyZmFjZS5qcycpLlRva2VuSW5wdXR9IFRva2VuSW5wdXRcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2lwZnMtY2FyL2Jsb2Nrc3RvcmUnKS5CbG9ja3N0b3JlfSBCbG9ja3N0b3JlXG4gKi9cblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHR5cGVkZWYge2ltcG9ydCgnLi9saWIvaW50ZXJmYWNlLmpzJykuRW5jb2RlZDxULCBbW0Jsb2IsIFVSTF1dPn0gRW5jb2RlZEJsb2JVcmxcbiAqL1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBHXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuL2xpYi9pbnRlcmZhY2UuanMnKS5FbmNvZGVkPEcsIFtbQmxvYiwgQmxvYl1dPn0gRW5jb2RlZEJsb2JCbG9iXG4gKi9cblxuLyoqXG4gKiBAdGVtcGxhdGUge2ltcG9ydCgnLi9saWIvaW50ZXJmYWNlLmpzJykuVG9rZW5JbnB1dH0gVFxuICogQHR5cGVkZWYge2ltcG9ydCgnLi9saWIvaW50ZXJmYWNlLmpzJykuVG9rZW48VD59IFRva2VuVHlwZVxuICovXG5cbi8qKlxuICogQHRlbXBsYXRlIHtUb2tlbklucHV0fSBUXG4gKiBAaW1wbGVtZW50cyB7VG9rZW5UeXBlPFQ+fVxuICovXG5leHBvcnQgY2xhc3MgVG9rZW4ge1xuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoJy4vbGliL2ludGVyZmFjZS5qcycpLkNJRFN0cmluZ30gaXBuZnRcbiAgICogQHBhcmFtIHtpbXBvcnQoJy4vbGliL2ludGVyZmFjZS5qcycpLkVuY29kZWRVUkx9IHVybFxuICAgKiBAcGFyYW0ge2ltcG9ydCgnLi9saWIvaW50ZXJmYWNlLmpzJykuRW5jb2RlZDxULCBbW0Jsb2IsIFVSTF1dPn0gZGF0YVxuICAgKi9cbiAgY29uc3RydWN0b3IoaXBuZnQsIHVybCwgZGF0YSkge1xuICAgIC8qKiBAcmVhZG9ubHkgKi9cbiAgICB0aGlzLmlwbmZ0ID0gaXBuZnRcbiAgICAvKiogQHJlYWRvbmx5ICovXG4gICAgdGhpcy51cmwgPSB1cmxcbiAgICAvKiogQHJlYWRvbmx5ICovXG4gICAgdGhpcy5kYXRhID0gZGF0YVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgaXBuZnQ6IHsgZW51bWVyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IGZhbHNlIH0sXG4gICAgICB1cmw6IHsgZW51bWVyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IGZhbHNlIH0sXG4gICAgICBkYXRhOiB7IGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogZmFsc2UgfSxcbiAgICB9KVxuICB9XG4gIC8qKlxuICAgKiBAcmV0dXJucyB7aW1wb3J0KCcuL2xpYi9pbnRlcmZhY2UuanMnKS5FbmNvZGVkPFQsIFtbQmxvYiwgVVJMXV0+fVxuICAgKi9cbiAgZW1iZWQoKSB7XG4gICAgcmV0dXJuIFRva2VuLmVtYmVkKHRoaXMpXG4gIH1cblxuICAvKipcbiAgICogQHRlbXBsYXRlIHtUb2tlbklucHV0fSBUXG4gICAqIEBwYXJhbSB7e2RhdGE6IGltcG9ydCgnLi9saWIvaW50ZXJmYWNlLmpzJykuRW5jb2RlZDxULCBbW0Jsb2IsIFVSTF1dPn19IHRva2VuXG4gICAqIEByZXR1cm5zIHtpbXBvcnQoJy4vbGliL2ludGVyZmFjZS5qcycpLkVuY29kZWQ8VCwgW1tCbG9iLCBVUkxdXT59XG4gICAqL1xuICBzdGF0aWMgZW1iZWQoeyBkYXRhIH0pIHtcbiAgICByZXR1cm4gZW1iZWQoZGF0YSwgeyBnYXRld2F5OiBHQVRFV0FZIH0pXG4gIH1cblxuICAvKipcbiAgICogVGFrZXMgdG9rZW4gaW5wdXQsIGVuY29kZXMgaXQgYXMgYSBEQUcsIHdyYXBzIGl0IGluIGEgQ0FSIGFuZCBjcmVhdGVzIGEgbmV3XG4gICAqIFRva2VuIGluc3RhbmNlIGZyb20gaXQuIFdoZXJlIHZhbHVlcyBhcmUgZGlzY292ZXJlZCBgQmxvYmAgKG9yIGBGaWxlYClcbiAgICogb2JqZWN0cyBpbiB0aGUgZ2l2ZW4gaW5wdXQsIHRoZXkgYXJlIHJlcGxhY2VkIHdpdGggSVBGUyBVUkxzIChhbiBgaXBmczovL2BcbiAgICogcHJlZml4ZWQgQ0lEIHdpdGggYW4gb3B0aW9uYWwgcGF0aCkuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IGNhdCA9IG5ldyBGaWxlKFsnLi4uJ10sICdjYXQucG5nJylcbiAgICogY29uc3Qga2l0dHkgPSBuZXcgRmlsZShbJy4uLiddLCAna2l0dHkucG5nJylcbiAgICogY29uc3QgeyB0b2tlbiwgY2FyIH0gPSBhd2FpdCBUb2tlbi5lbmNvZGUoe1xuICAgKiAgIG5hbWU6ICdoZWxsbydcbiAgICogICBpbWFnZTogY2F0XG4gICAqICAgcHJvcGVydGllczoge1xuICAgKiAgICAgZXh0cmE6IHtcbiAgICogICAgICAgaW1hZ2U6IGtpdHR5XG4gICAqICAgICB9XG4gICAqICAgfVxuICAgKiB9KVxuICAgKiBgYGBcbiAgICpcbiAgICogQHRlbXBsYXRlIHtUb2tlbklucHV0fSBUXG4gICAqIEBwYXJhbSB7VH0gaW5wdXRcbiAgICogQHJldHVybnMge1Byb21pc2U8eyBjaWQ6IENJRCwgdG9rZW46IFRva2VuVHlwZTxUPiwgY2FyOiBpbXBvcnQoJy4vbGliL2ludGVyZmFjZS5qcycpLkNhclJlYWRlciB9Pn1cbiAgICovXG4gIHN0YXRpYyBhc3luYyBlbmNvZGUoaW5wdXQpIHtcbiAgICBjb25zdCBibG9ja3N0b3JlID0gbmV3IEJsb2Nrc3RvcmUoKVxuICAgIGNvbnN0IFtibG9icywgbWV0YV0gPSBtYXBUb2tlbklucHV0QmxvYnMoaW5wdXQpXG4gICAgLyoqIEB0eXBlIHtFbmNvZGVkQmxvYlVybDxUPn0gKi9cbiAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShtZXRhKSlcbiAgICAvKiogQHR5cGUge2ltcG9ydCgnLi9saWIvaW50ZXJmYWNlLmpzJykuRW5jb2RlZDxULCBbW0Jsb2IsIENJRF1dPn0gKi9cbiAgICBjb25zdCBkYWcgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG1ldGEpKVxuXG4gICAgZm9yIChjb25zdCBbZG90UGF0aCwgYmxvYl0gb2YgYmxvYnMuZW50cmllcygpKSB7XG4gICAgICAvKiogQHR5cGUge3N0cmluZ3x1bmRlZmluZWR9ICovXG4gICAgICAvLyBAdHMtaWdub3JlIGJsb2IgbWF5IGJlIGEgRmlsZSFcbiAgICAgIGNvbnN0IG5hbWUgPSBibG9iLm5hbWUgfHwgJ2Jsb2InXG4gICAgICAvKiogQHR5cGUge2ltcG9ydCgnLi9wbGF0Zm9ybS5qcycpLlJlYWRhYmxlU3RyZWFtfSAqL1xuICAgICAgbGV0IGNvbnRlbnRcbiAgICAgIC8vIEZJWE1FOiBzaG91bGQgbm90IGJlIG5lY2Vzc2FyeSB0byBhd2FpdCBhcnJheUJ1ZmZlcigpIVxuICAgICAgLy8gTm9kZS5qcyAyMCBoYW5ncyByZWFkaW5nIHRoZSBzdHJlYW0gKGl0IG5ldmVyIGVuZHMpIGJ1dCBpblxuICAgICAgLy8gb2xkZXIgbm9kZSB2ZXJzaW9ucyBhbmQgdGhlIGJyb3dzZXIgaXQgaXMgZmluZSB0byB1c2UgYmxvYi5zdHJlYW0oKS5cbiAgICAgIC8qIGM4IGlnbm9yZSBuZXh0IDUgKi9cbiAgICAgIGlmIChwYXJzZUludChnbG9iYWxUaGlzLnByb2Nlc3M/LnZlcnNpb25zPy5ub2RlKSA+IDE4KSB7XG4gICAgICAgIGNvbnRlbnQgPSBuZXcgVWludDhBcnJheShhd2FpdCBibG9iLmFycmF5QnVmZmVyKCkpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250ZW50ID0gYmxvYi5zdHJlYW0oKVxuICAgICAgfVxuICAgICAgY29uc3QgeyByb290OiBjaWQgfSA9IGF3YWl0IHBhY2soe1xuICAgICAgICBpbnB1dDogW3sgcGF0aDogbmFtZSwgY29udGVudCB9XSxcbiAgICAgICAgYmxvY2tzdG9yZSxcbiAgICAgICAgd3JhcFdpdGhEaXJlY3Rvcnk6IHRydWUsXG4gICAgICB9KVxuXG4gICAgICBjb25zdCBocmVmID0gbmV3IFVSTChgaXBmczovLyR7Y2lkfS8ke25hbWV9YClcbiAgICAgIGNvbnN0IHBhdGggPSBkb3RQYXRoLnNwbGl0KCcuJylcbiAgICAgIHNldEluKGRhdGEsIHBhdGgsIGhyZWYpXG4gICAgICBzZXRJbihkYWcsIHBhdGgsIGNpZClcbiAgICB9XG5cbiAgICBjb25zdCB7IHJvb3Q6IG1ldGFkYXRhSnNvbkNpZCB9ID0gYXdhaXQgcGFjayh7XG4gICAgICBpbnB1dDogW3sgcGF0aDogJ21ldGFkYXRhLmpzb24nLCBjb250ZW50OiBKU09OLnN0cmluZ2lmeShkYXRhKSB9XSxcbiAgICAgIGJsb2Nrc3RvcmUsXG4gICAgICB3cmFwV2l0aERpcmVjdG9yeTogZmFsc2UsXG4gICAgfSlcblxuICAgIGNvbnN0IGJsb2NrID0gYXdhaXQgQmxvY2suZW5jb2RlKHtcbiAgICAgIHZhbHVlOiB7XG4gICAgICAgIC4uLmRhZyxcbiAgICAgICAgJ21ldGFkYXRhLmpzb24nOiBtZXRhZGF0YUpzb25DaWQsXG4gICAgICAgIHR5cGU6ICduZnQnLFxuICAgICAgfSxcbiAgICAgIGNvZGVjOiBkYWdDYm9yLFxuICAgICAgaGFzaGVyOiBzaGEyNTYsXG4gICAgfSlcbiAgICBhd2FpdCBibG9ja3N0b3JlLnB1dChibG9jay5jaWQsIGJsb2NrLmJ5dGVzKVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGNpZDogYmxvY2suY2lkLFxuICAgICAgdG9rZW46IG5ldyBUb2tlbihcbiAgICAgICAgYmxvY2suY2lkLnRvU3RyaW5nKCksXG4gICAgICAgIGBpcGZzOi8vJHtibG9jay5jaWR9L21ldGFkYXRhLmpzb25gLFxuICAgICAgICBkYXRhXG4gICAgICApLFxuICAgICAgY2FyOiBuZXcgQmxvY2tzdG9yZUNhclJlYWRlcigxLCBbYmxvY2suY2lkXSwgYmxvY2tzdG9yZSksXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7RW5jb2RlZEJsb2JVcmw8VD59IGlucHV0XG4gKiBAcGFyYW0ge0VtYmVkT3B0aW9uc30gb3B0aW9uc1xuICogQHJldHVybnMge0VuY29kZWRCbG9iVXJsPFQ+fVxuICovXG5leHBvcnQgY29uc3QgZW1iZWQgPSAoaW5wdXQsIG9wdGlvbnMpID0+XG4gIG1hcFdpdGgoaW5wdXQsIGlzVVJMLCBlbWJlZFVSTCwgb3B0aW9ucylcblxuLyoqXG4gKiBAdGVtcGxhdGUge1Rva2VuSW5wdXR9IFRcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2xpYi9pbnRlcmZhY2UuanMnKS5FbmNvZGVkVG9rZW48VD59IHZhbHVlXG4gKiBAcGFyYW0ge1NldDxzdHJpbmc+fSBwYXRocyAtIFBhdGhzIHdlcmUgdG8gZXhwZWN0IEVuY29kZWRVUkxzXG4gKiBAcmV0dXJucyB7VG9rZW48VD59XG4gKi9cbmV4cG9ydCBjb25zdCBkZWNvZGUgPSAoeyBpcG5mdCwgdXJsLCBkYXRhIH0sIHBhdGhzKSA9PlxuICBuZXcgVG9rZW4oaXBuZnQsIHVybCwgbWFwV2l0aChkYXRhLCBpc0VuY29kZWRVUkwsIGRlY29kZVVSTCwgcGF0aHMpKVxuXG4vKipcbiAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuICogQHJldHVybnMge3ZhbHVlIGlzIFVSTH1cbiAqL1xuY29uc3QgaXNVUkwgPSAodmFsdWUpID0+IHZhbHVlIGluc3RhbmNlb2YgVVJMXG5cbi8qKlxuICogQHRlbXBsYXRlIFN0YXRlXG4gKiBAcGFyYW0ge1N0YXRlfSBzdGF0ZVxuICogQHBhcmFtIHtpbXBvcnQoJy4vbGliL2ludGVyZmFjZS5qcycpLkVuY29kZWRVUkx9IHVybFxuICogQHJldHVybnMge1tTdGF0ZSwgVVJMXX1cbiAqL1xuY29uc3QgZGVjb2RlVVJMID0gKHN0YXRlLCB1cmwpID0+IFtzdGF0ZSwgbmV3IFVSTCh1cmwpXVxuXG4vKipcbiAqIEBwYXJhbSB7RW1iZWRPcHRpb25zfSBjb250ZXh0XG4gKiBAcGFyYW0ge1VSTH0gdXJsXG4gKiBAcmV0dXJucyB7W0VtYmVkT3B0aW9ucywgVVJMXX1cbiAqL1xuY29uc3QgZW1iZWRVUkwgPSAoY29udGV4dCwgdXJsKSA9PiBbY29udGV4dCwgdG9HYXRld2F5VVJMKHVybCwgY29udGV4dCldXG5cbi8qKlxuICogQHBhcmFtIHthbnl9IHZhbHVlXG4gKiBAcmV0dXJucyB7dmFsdWUgaXMgb2JqZWN0fVxuICovXG5jb25zdCBpc09iamVjdCA9ICh2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPSBudWxsXG5cbi8qKlxuICogQHBhcmFtIHthbnl9IHZhbHVlXG4gKiBAcGFyYW0ge1NldDxzdHJpbmc+fSBhc3NldFBhdGhzXG4gKiBAcGFyYW0ge1Byb3BlcnR5S2V5W119IHBhdGhcbiAqIEByZXR1cm5zIHt2YWx1ZSBpcyBpbXBvcnQoJy4vbGliL2ludGVyZmFjZS5qcycpLkVuY29kZWRVUkx9XG4gKi9cbmNvbnN0IGlzRW5jb2RlZFVSTCA9ICh2YWx1ZSwgYXNzZXRQYXRocywgcGF0aCkgPT5cbiAgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiBhc3NldFBhdGhzLmhhcyhwYXRoLmpvaW4oJy4nKSlcblxuLyoqXG4gKiBUYWtlcyB0b2tlbiBpbnB1dCBhbmQgZW5jb2RlcyBpdCBpbnRvXG4gKiBbRm9ybURhdGFdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Gb3JtRGF0YSlcbiAqIG9iamVjdCB3aGVyZSBmb3JtIGZpZWxkIHZhbHVlcyBhcmUgZGlzY292ZXJlZCBgQmxvYmAgKG9yIGBGaWxlYCkgb2JqZWN0cyBpblxuICogdGhlIGdpdmVuIHRva2VuIGFuZCBmaWVsZCBrZXlzIGFyZSBgLmAgam9pbmVkIHBhdGhzIHdoZXJlIHRoZXkgd2VyZSBkaXNjb3ZlcmRcbiAqIGluIHRoZSB0b2tlbi4gQWRkaXRpb25hbGx5IGVuY29kZWQgYEZvcm1EYXRhYCB3aWxsIGFsc28gaGF2ZSBhIGZpZWxkXG4gKiBuYW1lZCBgbWV0YWAgY29udGFpbmluZyBKU09OIHNlcmlhbGl6ZWQgdG9rZW4gd2l0aCBibG9icyBhbmQgZmlsZSB2YWx1ZXNcbiAqIGBudWxsYCBzZXQgdG8gbnVsbCAodGhpcyBhbGxvd3MgYmFja2VuZCB0byBpbmplc3QgYWxsIG9mIHRoZSBmaWxlcyBmcm9tXG4gKiBgbXVsdGlwYXJ0L2Zvcm0tZGF0YWAgcmVxdWVzdCBhbmQgdXBkYXRlIHByb3ZpZGVkIFwibWV0YVwiIGRhdGEgd2l0aFxuICogY29ycmVzcG9uZGluZyBmaWxlIGlwZnM6Ly8gVVJMcylcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqIGNvbnN0IGNhdCA9IG5ldyBGaWxlKFtdLCAnY2F0LnBuZycpXG4gKiBjb25zdCBraXR0eSA9IG5ldyBGaWxlKFtdLCAna2l0dHkucG5nJylcbiAqIGNvbnN0IGZvcm0gPSBlbmNvZGUoe1xuICogICBuYW1lOiAnaGVsbG8nXG4gKiAgIGltYWdlOiBjYXRcbiAqICAgcHJvcGVydGllczoge1xuICogICAgIGV4dHJhOiB7XG4gKiAgICAgICBpbWFnZToga2l0dHlcbiAqICAgICB9XG4gKiAgIH1cbiAqIH0pXG4gKiBbLi4uZm9ybS5lbnRyaWVzKCldIC8vPlxuICogLy8gW1xuICogLy8gICBbJ2ltYWdlJywgY2F0XSxcbiAqIC8vICAgWydwcm9wZXJ0aWVzLmV4dHJhLmltYWdlJywga2l0dHldLFxuICogLy8gICBbJ21ldGEnLCAne1wibmFtZVwiOlwiaGVsbG9cIixpbWFnZTpudWxsLFwicHJvcGVydGllc1wiOntcImV4dHJhXCI6e1wia2l0dHlcIjogbnVsbH19fSddXG4gKiAvLyBdXG4gKiBgYGBcbiAqXG4gKiBAdGVtcGxhdGUge1Rva2VuSW5wdXR9IFRcbiAqIEBwYXJhbSB7RW5jb2RlZEJsb2JCbG9iPFQ+fSBpbnB1dFxuICogQHJldHVybnMge0Zvcm1EYXRhfVxuICovXG5leHBvcnQgY29uc3QgZW5jb2RlID0gKGlucHV0KSA9PiB7XG4gIGNvbnN0IFttYXAsIG1ldGFdID0gbWFwVmFsdWVXaXRoKGlucHV0LCBpc0Jsb2IsIGVuY29kZUJsb2IsIG5ldyBNYXAoKSwgW10pXG4gIGNvbnN0IGZvcm0gPSBuZXcgRm9ybURhdGEoKVxuICBmb3IgKGNvbnN0IFtrLCB2XSBvZiBtYXAuZW50cmllcygpKSB7XG4gICAgZm9ybS5zZXQoaywgdilcbiAgfVxuICBmb3JtLnNldCgnbWV0YScsIEpTT04uc3RyaW5naWZ5KG1ldGEpKVxuICByZXR1cm4gZm9ybVxufVxuXG4vKipcbiAqIEBwYXJhbSB7TWFwPHN0cmluZywgQmxvYj59IGRhdGFcbiAqIEBwYXJhbSB7QmxvYn0gYmxvYlxuICogQHBhcmFtIHtQcm9wZXJ0eUtleVtdfSBwYXRoXG4gKiBAcmV0dXJucyB7W01hcDxzdHJpbmcsIEJsb2I+LCB2b2lkXX1cbiAqL1xuY29uc3QgZW5jb2RlQmxvYiA9IChkYXRhLCBibG9iLCBwYXRoKSA9PiB7XG4gIGRhdGEuc2V0KHBhdGguam9pbignLicpLCBibG9iKVxuICByZXR1cm4gW2RhdGEsIHVuZGVmaW5lZF1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gdmFsdWVcbiAqIEByZXR1cm5zIHt2YWx1ZSBpcyBCbG9ifVxuICovXG5jb25zdCBpc0Jsb2IgPSAodmFsdWUpID0+IHZhbHVlIGluc3RhbmNlb2YgQmxvYlxuXG4vKipcbiAqIEB0ZW1wbGF0ZSB7VG9rZW5JbnB1dH0gVFxuICogQHBhcmFtIHtFbmNvZGVkQmxvYkJsb2I8VD59IGlucHV0XG4gKi9cbmNvbnN0IG1hcFRva2VuSW5wdXRCbG9icyA9IChpbnB1dCkgPT4ge1xuICByZXR1cm4gbWFwVmFsdWVXaXRoKGlucHV0LCBpc0Jsb2IsIGVuY29kZUJsb2IsIG5ldyBNYXAoKSwgW10pXG59XG5cbi8qKlxuICogU3Vic3RpdHVlcyB2YWx1ZXMgaW4gdGhlIGdpdmVuIGBpbnB1dGAgdGhhdCBtYXRjaCBgcCh2YWx1ZSkgPT0gdHJ1ZWAgd2l0aFxuICogYGYodmFsdWUsIGNvbnRleHQsIHBhdGgpYCB3aGVyZSBgY29udGV4dGAgaXMgd2hhdGV2ZXIgeW91IHBhc3MgKHVzdWFsbHlcbiAqIGEgbXV0YWJsZSBzdGF0ZSkgYW5kIGBwYXRoYCBpcyBhIGFycmF5IG9mIGtleXMgLyBpbmRleGVzIHdoZXJlIHRoZSB2YWx1ZVxuICogd2FzIGVuY291bnRlcmVkLlxuICpcbiAqIEB0ZW1wbGF0ZSBULCBJLCBYLCBPLCBTdGF0ZVxuICogQHBhcmFtIHtpbXBvcnQoJy4vbGliL2ludGVyZmFjZS5qcycpLkVuY29kZWQ8VCwgW1tJLCBYXV0+fSBpbnB1dCAtIEFyYml0cmFyeSBpbnB1dC5cbiAqIEBwYXJhbSB7KGlucHV0OmFueSwgc3RhdGU6U3RhdGUsIHBhdGg6UHJvcGVydHlLZXlbXSkgPT4gaW5wdXQgaXMgWH0gcCAtIFByZWRpY2F0ZSBmdW5jdGlvbiB0byBkZXRlcm1pbmVcbiAqIHdoaWNoIHZhbHVlcyB0byBzd2FwLlxuICogQHBhcmFtIHsoc3RhdGU6U3RhdGUsIGlucHV0OlgsIHBhdGg6UHJvcGVydHlLZXlbXSkgPT4gW1N0YXRlLCBPXX0gZiAtIEZ1bmN0aW9uXG4gKiB0aGF0IHN3YXBzIG1hdGNoaW5nIHZhbHVlcy5cbiAqIEBwYXJhbSB7U3RhdGV9IHN0YXRlIC0gU29tZSBhZGRpdGlvbmFsIGNvbnRleHQgeW91IG5lZWQgaW4gdGhlIHByb2Nlc3MuXG4gKiBsaWtleSB5b3UnbGwgc3RhcnQgd2l0aCBgW11gLlxuICogQHJldHVybnMge2ltcG9ydCgnLi9saWIvaW50ZXJmYWNlLmpzJykuRW5jb2RlZDxULCBbW0ksIE9dXT59XG4gKi9cbmV4cG9ydCBjb25zdCBtYXBXaXRoID0gKGlucHV0LCBwLCBmLCBzdGF0ZSkgPT4ge1xuICBjb25zdCBbLCBvdXRwdXRdID0gbWFwVmFsdWVXaXRoKGlucHV0LCBwLCBmLCBzdGF0ZSwgW10pXG4gIHJldHVybiBvdXRwdXRcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVCwgSSwgWCwgTywgU3RhdGVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2xpYi9pbnRlcmZhY2UuanMnKS5FbmNvZGVkPFQsIFtbSSwgWF1dPn0gaW5wdXQgLSBBcmJpdHJhcnkgaW5wdXQuXG4gKiBAcGFyYW0geyhpbnB1dDphbnksIHN0YXRlOlN0YXRlLCBwYXRoOlByb3BlcnR5S2V5W10pID0+IGlucHV0IGlzIFh9IHAgLSBQcmVkaWNhdGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lXG4gKiB3aGljaCB2YWx1ZXMgdG8gc3dhcC5cbiAqIEBwYXJhbSB7KHN0YXRlOlN0YXRlLCBpbnB1dDpYLCBwYXRoOlByb3BlcnR5S2V5W10pID0+IFtTdGF0ZSwgT119IGYgLSBGdW5jdGlvblxuICogdGhhdCBzd2FwcyBtYXRjaGluZyB2YWx1ZXMuXG4gKiBAcGFyYW0ge1N0YXRlfSBzdGF0ZSAtIFNvbWUgYWRkaXRpb25hbCBjb250ZXh0IHlvdSBuZWVkIGluIHRoZSBwcm9jZXNzLlxuICogQHBhcmFtIHtQcm9wZXJ0eUtleVtdfSBwYXRoIC0gUGF0aCB3aGVyZSB0aGUgdmFsdWUgd2FzIGVuY291bnRlcmVkLiBNb3N0XG4gKiBsaWtleSB5b3UnbGwgc3RhcnQgd2l0aCBgW11gLlxuICogQHJldHVybnMge1tTdGF0ZSwgaW1wb3J0KCcuL2xpYi9pbnRlcmZhY2UuanMnKS5FbmNvZGVkPFQsIFtbSSwgT11dPl19XG4gKi9cbmNvbnN0IG1hcFZhbHVlV2l0aCA9IChpbnB1dCwgcCwgZiwgc3RhdGUsIHBhdGgpID0+XG4gIHAoaW5wdXQsIHN0YXRlLCBwYXRoKVxuICAgID8gZihzdGF0ZSwgaW5wdXQsIHBhdGgpXG4gICAgOiBBcnJheS5pc0FycmF5KGlucHV0KVxuICAgID8gbWFwQXJyYXlXaXRoKGlucHV0LCBwLCBmLCBzdGF0ZSwgcGF0aClcbiAgICA6IGlzT2JqZWN0KGlucHV0KVxuICAgID8gbWFwT2JqZWN0V2l0aChpbnB1dCwgcCwgZiwgc3RhdGUsIHBhdGgpXG4gICAgOiBbc3RhdGUsIC8qKiBAdHlwZSB7YW55fSAqLyAoaW5wdXQpXVxuXG4vKipcbiAqIEp1c3QgbGlrZSBgbWFwV2l0aGAgZXhjZXB0XG4gKlxuICogQHRlbXBsYXRlIFN0YXRlLCBULCBJLCBYLCBPXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9saWIvaW50ZXJmYWNlLmpzJykuRW5jb2RlZDxULCBbW0ksIFhdXT59IGlucHV0XG4gKiBAcGFyYW0geyhpbnB1dDphbnksIHN0YXRlOlN0YXRlLCBwYXRoOlByb3BlcnR5S2V5W10pID0+IGlucHV0IGlzIFh9IHBcbiAqIEBwYXJhbSB7KHN0YXRlOiBTdGF0ZSwgaW5wdXQ6WCwgcGF0aDpQcm9wZXJ0eUtleVtdKSA9PiBbU3RhdGUsIE9dfSBmXG4gKiBAcGFyYW0ge1N0YXRlfSBpbml0XG4gKiBAcGFyYW0ge1Byb3BlcnR5S2V5W119IHBhdGhcbiAqIEByZXR1cm5zIHtbU3RhdGUsIGltcG9ydCgnLi9saWIvaW50ZXJmYWNlLmpzJykuRW5jb2RlZDxULCBbW0ksIE9dXT5dfVxuICovXG5jb25zdCBtYXBPYmplY3RXaXRoID0gKGlucHV0LCBwLCBmLCBpbml0LCBwYXRoKSA9PiB7XG4gIGxldCBzdGF0ZSA9IGluaXRcbiAgY29uc3Qgb3V0cHV0ID1cbiAgICAvKiogQHR5cGUge2ltcG9ydCgnLi9saWIvaW50ZXJmYWNlLmpzJykuRW5jb2RlZDxULCBbW0ksIE9dXT59ICovICh7fSlcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoaW5wdXQpKSB7XG4gICAgY29uc3QgW25leHQsIG91dF0gPSBtYXBWYWx1ZVdpdGgodmFsdWUsIHAsIGYsIHN0YXRlLCBbLi4ucGF0aCwga2V5XSlcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgb3V0cHV0W2tleV0gPSBvdXRcbiAgICBzdGF0ZSA9IG5leHRcbiAgfVxuICByZXR1cm4gW3N0YXRlLCBvdXRwdXRdXG59XG5cbi8qKlxuICogSnVzdCBsaWtlIGBtYXBXaXRoYCBleGNlcHQgZm9yIEFycmF5cy5cbiAqXG4gKiBAdGVtcGxhdGUgSSwgWCwgTywgU3RhdGVcbiAqIEB0ZW1wbGF0ZSB7YW55W119IFRcbiAqIEBwYXJhbSB7VH0gaW5wdXRcbiAqIEBwYXJhbSB7KGlucHV0OmFueSwgc3RhdGU6U3RhdGUsIHBhdGg6UHJvcGVydHlLZXlbXSkgPT4gaW5wdXQgaXMgWH0gcFxuICogQHBhcmFtIHsoc3RhdGU6IFN0YXRlLCBpbnB1dDpYLCBwYXRoOlByb3BlcnR5S2V5W10pID0+IFtTdGF0ZSwgT119IGZcbiAqIEBwYXJhbSB7U3RhdGV9IGluaXRcbiAqIEBwYXJhbSB7UHJvcGVydHlLZXlbXX0gcGF0aFxuICogQHJldHVybnMge1tTdGF0ZSwgaW1wb3J0KCcuL2xpYi9pbnRlcmZhY2UuanMnKS5FbmNvZGVkPFQsIFtbSSwgT11dPl19XG4gKi9cbmNvbnN0IG1hcEFycmF5V2l0aCA9IChpbnB1dCwgcCwgZiwgaW5pdCwgcGF0aCkgPT4ge1xuICBjb25zdCBvdXRwdXQgPSAvKiogQHR5cGUge3Vua25vd25bXX0gKi8gKFtdKVxuXG4gIGxldCBzdGF0ZSA9IGluaXRcbiAgZm9yIChjb25zdCBbaW5kZXgsIGVsZW1lbnRdIG9mIGlucHV0LmVudHJpZXMoKSkge1xuICAgIGNvbnN0IFtuZXh0LCBvdXRdID0gbWFwVmFsdWVXaXRoKGVsZW1lbnQsIHAsIGYsIHN0YXRlLCBbLi4ucGF0aCwgaW5kZXhdKVxuICAgIG91dHB1dFtpbmRleF0gPSBvdXRcbiAgICBzdGF0ZSA9IG5leHRcbiAgfVxuXG4gIHJldHVybiBbXG4gICAgc3RhdGUsXG4gICAgLyoqIEB0eXBlIHtpbXBvcnQoJy4vbGliL2ludGVyZmFjZS5qcycpLkVuY29kZWQ8VCwgW1tJLCBPXV0+fSAqLyAob3V0cHV0KSxcbiAgXVxufVxuXG4vKipcbiAqIFNldHMgYSBnaXZlbiBgdmFsdWVgIGF0IHRoZSBnaXZlbiBgcGF0aGAgb24gYSBwYXNzZWQgYG9iamVjdGAuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiBjb25zdCBvYmogPSB7IGE6IHsgYjogeyBjOiAxIH19fVxuICogc2V0SW4ob2JqLCBbJ2EnLCAnYicsICdjJ10sIDUpXG4gKiBvYmouYS5iLmMgLy8+IDVcbiAqIGBgYFxuICpcbiAqIEB0ZW1wbGF0ZSBWXG4gKiBAcGFyYW0ge2FueX0gb2JqZWN0XG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXRoXG4gKiBAcGFyYW0ge1Z9IHZhbHVlXG4gKi9cbmNvbnN0IHNldEluID0gKG9iamVjdCwgcGF0aCwgdmFsdWUpID0+IHtcbiAgY29uc3QgbiA9IHBhdGgubGVuZ3RoIC0gMVxuICBsZXQgdGFyZ2V0ID0gb2JqZWN0XG4gIGZvciAobGV0IFtpbmRleCwga2V5XSBvZiBwYXRoLmVudHJpZXMoKSkge1xuICAgIGlmIChpbmRleCA9PT0gbikge1xuICAgICAgdGFyZ2V0W2tleV0gPSB2YWx1ZVxuICAgIH0gZWxzZSB7XG4gICAgICB0YXJnZXQgPSB0YXJnZXRba2V5XVxuICAgIH1cbiAgfVxufVxuIiwgImltcG9ydCB7XG4gIFB1YmxpY0tleSxcbiAgU3lzdGVtUHJvZ3JhbSxcbiAgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbixcbn0gZnJvbSAnQHNvbGFuYS93ZWIzLmpzJztcblxuaW1wb3J0IEJOIGZyb20gJ2JuLmpzJztcblxuaW1wb3J0IHtcbiAgY3JlYXRlQXBwcm92ZUluc3RydWN0aW9uLFxuICBjcmVhdGVBc3NvY2lhdGVkVG9rZW5BY2NvdW50SW5zdHJ1Y3Rpb24sXG4gIGNyZWF0ZUluaXRpYWxpemVNaW50SW5zdHJ1Y3Rpb24sXG4gIGNyZWF0ZU1pbnRUb0NoZWNrZWRJbnN0cnVjdGlvbixcbiAgZ2V0QXNzb2NpYXRlZFRva2VuQWRkcmVzc1N5bmMsXG4gIGdldE1pbmltdW1CYWxhbmNlRm9yUmVudEV4ZW1wdE1pbnQsXG4gIE1JTlRfU0laRSxcbiAgVE9LRU5fUFJPR1JBTV9JRCxcbn0gZnJvbSAnQHNvbGFuYS9zcGwtdG9rZW4nO1xuaW1wb3J0IHtcbiAgZGVidWdMb2csXG4gIEtleXBhaXJBY2NvdW50LFxuICBNaW50SW5zdHJ1Y3Rpb24sXG4gIFB1YmtleSxcbiAgUmVzdWx0LFxuICBTZWNyZXQsXG4gIFRyeSxcbn0gZnJvbSAnQHNvbGFuYS1zdWl0ZS9zaGFyZWQnO1xuXG5pbXBvcnQgeyBTdG9yYWdlIH0gZnJvbSAnaW50ZXJuYWwvc3RvcmFnZSc7XG5cbmltcG9ydCB7XG4gIENvbnZlcnQsXG4gIFBkYSxcbiAgUm95YWx0eSxcbiAgVXNlclNpZGVJbnB1dCxcbiAgVmFsaWRhdG9yLFxufSBmcm9tICdpbnRlcm5hbC9zaGFyZWQtbWV0YXBsZXgnO1xuXG5pbXBvcnQge1xuICBjcmVhdGVDcmVhdGVNYXN0ZXJFZGl0aW9uVjNJbnN0cnVjdGlvbixcbiAgY3JlYXRlQ3JlYXRlTWV0YWRhdGFBY2NvdW50VjNJbnN0cnVjdGlvbixcbiAgRGF0YVYyLFxufSBmcm9tICdAbWV0YXBsZXgtZm91bmRhdGlvbi9tcGwtdG9rZW4tbWV0YWRhdGEnO1xuaW1wb3J0IHsgTm9kZSB9IGZyb20gJ0Bzb2xhbmEtc3VpdGUvc2hhcmVkJztcbmNvbnN0IE5GVF9BTU9VTlQgPSAxO1xuZXhwb3J0IG5hbWVzcGFjZSBNZXRhcGxleCB7XG4gIGV4cG9ydCBjb25zdCBjcmVhdGVEZWxlYWdhdGVJbnN0cnVjdGlvbiA9IChcbiAgICBtaW50OiBQdWJsaWNLZXksXG4gICAgb3duZXI6IFB1YmxpY0tleSxcbiAgICBkZWxlZ2F0ZUF1dGhvcml0eTogUHVibGljS2V5LFxuICApOiBUcmFuc2FjdGlvbkluc3RydWN0aW9uID0+IHtcbiAgICBjb25zdCB0b2tlbkFjY291bnQgPSBnZXRBc3NvY2lhdGVkVG9rZW5BZGRyZXNzU3luYyhtaW50LCBvd25lcik7XG5cbiAgICByZXR1cm4gY3JlYXRlQXBwcm92ZUluc3RydWN0aW9uKFxuICAgICAgdG9rZW5BY2NvdW50LFxuICAgICAgZGVsZWdhdGVBdXRob3JpdHksXG4gICAgICBvd25lcixcbiAgICAgIE5GVF9BTU9VTlQsXG4gICAgKTtcbiAgfTtcblxuICBleHBvcnQgY29uc3QgY3JlYXRlTWludEluc3RydWN0aW9ucyA9IGFzeW5jIChcbiAgICBtaW50OiBQdWJsaWNLZXksXG4gICAgb3duZXI6IFB1YmxpY0tleSxcbiAgICBuZnRNZXRhZGF0YTogRGF0YVYyLFxuICAgIGZlZVBheWVyOiBQdWJsaWNLZXksXG4gICAgaXNNdXRhYmxlOiBib29sZWFuLFxuICApOiBQcm9taXNlPFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb25bXT4gPT4ge1xuICAgIGNvbnN0IGF0YSA9IGdldEFzc29jaWF0ZWRUb2tlbkFkZHJlc3NTeW5jKG1pbnQsIG93bmVyKTtcbiAgICBjb25zdCB0b2tlbk1ldGFkYXRhUHVia2V5ID0gUGRhLmdldE1ldGFkYXRhKG1pbnQudG9TdHJpbmcoKSk7XG4gICAgY29uc3QgbWFzdGVyRWRpdGlvblB1YmtleSA9IFBkYS5nZXRNYXN0ZXJFZGl0aW9uKG1pbnQudG9TdHJpbmcoKSk7XG4gICAgY29uc3QgY29ubmVjdGlvbiA9IE5vZGUuZ2V0Q29ubmVjdGlvbigpO1xuXG4gICAgY29uc3QgaW5zdDEgPSBTeXN0ZW1Qcm9ncmFtLmNyZWF0ZUFjY291bnQoe1xuICAgICAgZnJvbVB1YmtleTogZmVlUGF5ZXIsXG4gICAgICBuZXdBY2NvdW50UHVia2V5OiBtaW50LFxuICAgICAgbGFtcG9ydHM6IGF3YWl0IGdldE1pbmltdW1CYWxhbmNlRm9yUmVudEV4ZW1wdE1pbnQoY29ubmVjdGlvbiksXG4gICAgICBzcGFjZTogTUlOVF9TSVpFLFxuICAgICAgcHJvZ3JhbUlkOiBUT0tFTl9QUk9HUkFNX0lELFxuICAgIH0pO1xuXG4gICAgY29uc3QgaW5zdDIgPSBjcmVhdGVJbml0aWFsaXplTWludEluc3RydWN0aW9uKG1pbnQsIDAsIG93bmVyLCBvd25lcik7XG5cbiAgICBjb25zdCBpbnN0MyA9IGNyZWF0ZUFzc29jaWF0ZWRUb2tlbkFjY291bnRJbnN0cnVjdGlvbihcbiAgICAgIGZlZVBheWVyLFxuICAgICAgYXRhLFxuICAgICAgb3duZXIsXG4gICAgICBtaW50LFxuICAgICk7XG5cbiAgICBjb25zdCBpbnN0NCA9IGNyZWF0ZU1pbnRUb0NoZWNrZWRJbnN0cnVjdGlvbihtaW50LCBhdGEsIG93bmVyLCAxLCAwKTtcblxuICAgIGNvbnN0IGluc3Q1ID0gY3JlYXRlQ3JlYXRlTWV0YWRhdGFBY2NvdW50VjNJbnN0cnVjdGlvbihcbiAgICAgIHtcbiAgICAgICAgbWV0YWRhdGE6IHRva2VuTWV0YWRhdGFQdWJrZXksXG4gICAgICAgIG1pbnQsXG4gICAgICAgIG1pbnRBdXRob3JpdHk6IG93bmVyLFxuICAgICAgICBwYXllcjogZmVlUGF5ZXIsXG4gICAgICAgIHVwZGF0ZUF1dGhvcml0eTogb3duZXIsXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBjcmVhdGVNZXRhZGF0YUFjY291bnRBcmdzVjM6IHtcbiAgICAgICAgICBkYXRhOiBuZnRNZXRhZGF0YSxcbiAgICAgICAgICBpc011dGFibGUsXG4gICAgICAgICAgY29sbGVjdGlvbkRldGFpbHM6IHsgX19raW5kOiAnVjEnLCBzaXplOiBuZXcgQk4oMSkgfSxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgKTtcblxuICAgIGNvbnN0IGluc3Q2ID0gY3JlYXRlQ3JlYXRlTWFzdGVyRWRpdGlvblYzSW5zdHJ1Y3Rpb24oXG4gICAgICB7XG4gICAgICAgIGVkaXRpb246IG1hc3RlckVkaXRpb25QdWJrZXksXG4gICAgICAgIG1pbnQsXG4gICAgICAgIHVwZGF0ZUF1dGhvcml0eTogb3duZXIsXG4gICAgICAgIG1pbnRBdXRob3JpdHk6IG93bmVyLFxuICAgICAgICBwYXllcjogZmVlUGF5ZXIsXG4gICAgICAgIG1ldGFkYXRhOiB0b2tlbk1ldGFkYXRhUHVia2V5LFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgY3JlYXRlTWFzdGVyRWRpdGlvbkFyZ3M6IHtcbiAgICAgICAgICBtYXhTdXBwbHk6IDAsXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICk7XG4gICAgcmV0dXJuIFtpbnN0MSwgaW5zdDIsIGluc3QzLCBpbnN0NCwgaW5zdDUsIGluc3Q2XTtcbiAgfTtcblxuICAvKipcbiAgICogVXBsb2FkIGNvbnRlbnQgYW5kIE5GVCBtaW50XG4gICAqXG4gICAqIEBwYXJhbSB7UHVia2V5fSBvd25lciAgICAgICAgICAvLyBmaXJzdCBtaW50ZWQgb3duZXJcbiAgICogQHBhcmFtIHtTZWNyZXR9IHNpZ25lciAgICAgICAgIC8vIG93bmVyJ3MgU2VjcmV0XG4gICAqIEBwYXJhbSB7VXNlclNpZGVJbnB1dC5OZnRNZXRhZGF0YX0gaW5wdXRcbiAgICoge1xuICAgKiAgIG5hbWU6IHN0cmluZyAgICAgICAgICAgICAgIC8vIG5mdCBjb250ZW50IG5hbWVcbiAgICogICBzeW1ib2w6IHN0cmluZyAgICAgICAgICAgICAvLyBuZnQgdGlja2VyIHN5bWJvbFxuICAgKiAgIGZpbGVQYXRoOiBzdHJpbmcgfCBGaWxlICAgIC8vIG5mdCB0aWNrZXIgc3ltYm9sXG4gICAqICAgcm95YWx0eTogbnVtYmVyICAgICAgICAgICAgLy8gcm95YWx0eSBwZXJjZW50YWdlXG4gICAqICAgc3RvcmFnZVR5cGU6ICdhcndlYXZlJ3wnbmZ0U3RvcmFnZScgLy8gcm95YWx0eSBwZXJjZW50YWdlXG4gICAqICAgZGVzY3JpcHRpb24/OiBzdHJpbmcgICAgICAgLy8gbmZ0IGNvbnRlbnQgZGVzY3JpcHRpb25cbiAgICogICBleHRlcm5hbF91cmw/OiBzdHJpbmcgICAgICAvLyBsYW5kaW5nIHBhZ2UsIGhvbWUgcGFnZSB1cmksIHJlbGF0ZWQgdXJsXG4gICAqICAgYXR0cmlidXRlcz86IE1ldGFkYXRhQXR0cmlidXRlW10gICAgIC8vIGdhbWUgY2hhcmFjdGVyIHBhcmFtZXRlciwgcGVyc29uYWxpdHksIGNoYXJhY3RlcmlzdGljc1xuICAgKiAgIHByb3BlcnRpZXM/OiBNZXRhZGF0YVByb3BlcnRpZXM8VXJpPiAvLyBpbmNsdWRlIGZpbGUgbmFtZSwgdXJpLCBzdXBwb3J0ZWQgZmlsZSB0eXBlXG4gICAqICAgY29sbGVjdGlvbj86IFB1YmtleSAgICAgICAgICAgLy8gY29sbGVjdGlvbnMgb2YgZGlmZmVyZW50IGNvbG9ycywgc2hhcGVzLCBldGMuXG4gICAqICAgY3JlYXRvcnM/OiBJbnB1dENyZWF0b3JzW10gICAgLy8gb3RoZXIgY3JlYXRvcnMgdGhhbiBvd25lclxuICAgKiAgIHVzZXM/OiBVc2VzICAgICAgICAgICAgICAgICAgIC8vIHVzYWdlIGZlYXR1cmU6IGJ1cm4sIHNpbmdsZSwgbXVsdGlwbGVcbiAgICogICBpc011dGFibGU/OiBib29sZWFuICAgICAgICAgICAvLyBlbmFibGUgdXBkYXRlKClcbiAgICogICBvcHRpb25zPzogW2tleTogc3RyaW5nXT86IHVua25vd24gICAgICAgLy8gb3B0aW9uYWwgcGFyYW0sIFVzdWFsbHkgbm90IHVzZWQuXG4gICAqIH1cbiAgICogQHBhcmFtIHtTZWNyZXR9IGZlZVBheWVyPyAgICAgICAgIC8vIGZlZSBwYXllclxuICAgKiBAcGFyYW0ge1B1YmtleX0gZnJlZXplQXV0aG9yaXR5PyAgLy8gZnJlZXplIGF1dGhvcml0eVxuICAgKiBAcmV0dXJuIFByb21pc2U8UmVzdWx0PE1pbnRJbnN0cnVjdGlvbiwgRXJyb3I+PlxuICAgKi9cbiAgZXhwb3J0IGNvbnN0IG1pbnQgPSBhc3luYyAoXG4gICAgb3duZXI6IFB1YmtleSxcbiAgICBzaWduZXI6IFNlY3JldCxcbiAgICBpbnB1dDogVXNlclNpZGVJbnB1dC5OZnRNZXRhZGF0YSxcbiAgICBmZWVQYXllcj86IFNlY3JldCxcbiAgICBmcmVlemVBdXRob3JpdHk/OiBQdWJrZXksXG4gICk6IFByb21pc2U8UmVzdWx0PE1pbnRJbnN0cnVjdGlvbiwgRXJyb3I+PiA9PiB7XG4gICAgcmV0dXJuIFRyeShhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB2YWxpZCA9IFZhbGlkYXRvci5jaGVja0FsbDxVc2VyU2lkZUlucHV0Lk5mdE1ldGFkYXRhPihpbnB1dCk7XG4gICAgICBpZiAodmFsaWQuaXNFcnIpIHtcbiAgICAgICAgdGhyb3cgdmFsaWQuZXJyb3I7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHBheWVyID0gZmVlUGF5ZXIgPyBmZWVQYXllciA6IHNpZ25lcjtcblxuICAgICAgLy8tLS0gcG9ycGVydGllcywgVXBsb2FkIGNvbnRlbnQgLS0tXG4gICAgICBsZXQgcHJvcGVydGllcztcbiAgICAgIGlmIChpbnB1dC5wcm9wZXJ0aWVzICYmIGlucHV0LnN0b3JhZ2VUeXBlKSB7XG4gICAgICAgIHByb3BlcnRpZXMgPSBhd2FpdCBDb252ZXJ0LlByb3BlcnRpZXMuaW50b0luZnJhU2lkZShcbiAgICAgICAgICBpbnB1dC5wcm9wZXJ0aWVzLFxuICAgICAgICAgIFN0b3JhZ2UudXBsb2FkQ29udGVudCxcbiAgICAgICAgICBpbnB1dC5zdG9yYWdlVHlwZSxcbiAgICAgICAgICBwYXllcixcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSBpZiAoaW5wdXQucHJvcGVydGllcyAmJiAhaW5wdXQuc3RvcmFnZVR5cGUpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ011c3Qgc2V0IHN0b3JhZ2VUeXBlIGlmIHdpbGwgdXNlIHByb3BlcnRpZXMnKTtcbiAgICAgIH1cblxuICAgICAgaW5wdXQgPSB7XG4gICAgICAgIC4uLmlucHV0LFxuICAgICAgICBwcm9wZXJ0aWVzLFxuICAgICAgfTtcbiAgICAgIC8vLS0tIHBvcnBlcnRpZXMsIFVwbG9hZCBjb250ZW50IC0tLVxuXG4gICAgICBjb25zdCBzZWxsZXJGZWVCYXNpc1BvaW50cyA9IFJveWFsdHkuY29udmVydChpbnB1dC5yb3lhbHR5KTtcbiAgICAgIGNvbnN0IG5mdFN0b3JhZ2VNZXRhZGF0YSA9IFN0b3JhZ2UudG9Db252ZXJ0T2ZmY2hhaW5kYXRhKFxuICAgICAgICBpbnB1dCxcbiAgICAgICAgc2VsbGVyRmVlQmFzaXNQb2ludHMsXG4gICAgICApO1xuXG4gICAgICAvLyBjcmVhdGVkIGF0IGJ5IHVuaXggdGltZXN0YW1wXG4gICAgICBjb25zdCBjcmVhdGVkQXQgPSBNYXRoLmZsb29yKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC8gMTAwMCk7XG4gICAgICBuZnRTdG9yYWdlTWV0YWRhdGEuY3JlYXRlZF9hdCA9IGNyZWF0ZWRBdDtcblxuICAgICAgbGV0IHVyaSE6IHN0cmluZztcbiAgICAgIGlmIChpbnB1dC5maWxlUGF0aCAmJiBpbnB1dC5zdG9yYWdlVHlwZSkge1xuICAgICAgICBjb25zdCB1cGxvYWRlZCA9IGF3YWl0IFN0b3JhZ2UudXBsb2FkTWV0YUFuZENvbnRlbnQoXG4gICAgICAgICAgbmZ0U3RvcmFnZU1ldGFkYXRhLFxuICAgICAgICAgIGlucHV0LmZpbGVQYXRoLFxuICAgICAgICAgIGlucHV0LnN0b3JhZ2VUeXBlLFxuICAgICAgICAgIHBheWVyLFxuICAgICAgICApO1xuICAgICAgICBkZWJ1Z0xvZygnIyB1cGxvYWQgY29udGVudCB1cmw6ICcsIHVwbG9hZGVkKTtcbiAgICAgICAgaWYgKHVwbG9hZGVkLmlzRXJyKSB7XG4gICAgICAgICAgdGhyb3cgdXBsb2FkZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdXJpID0gdXBsb2FkZWQudmFsdWU7XG4gICAgICB9IGVsc2UgaWYgKGlucHV0LnVyaSkge1xuICAgICAgICB1cmkgPSBpbnB1dC51cmk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBFcnJvcihgTXVzdCBzZXQgJ3N0b3JhZ2VUeXBlICsgZmlsZVBhdGgnIG9yICd1cmknYCk7XG4gICAgICB9XG5cbiAgICAgIGxldCBkYXRhdjIgPSBDb252ZXJ0Lk5mdE1ldGFkYXRhLmludG9JbmZyYVNpZGUoXG4gICAgICAgIGlucHV0LFxuICAgICAgICB1cmksXG4gICAgICAgIHNlbGxlckZlZUJhc2lzUG9pbnRzLFxuICAgICAgKTtcblxuICAgICAgLy8tLS0gY29sbGVjdGlvbiAtLS1cbiAgICAgIGxldCBjb2xsZWN0aW9uO1xuICAgICAgaWYgKGlucHV0LmNvbGxlY3Rpb24gJiYgaW5wdXQuY29sbGVjdGlvbikge1xuICAgICAgICBjb2xsZWN0aW9uID0gQ29udmVydC5Db2xsZWN0aW9uLmludG9JbmZyYVNpZGUoaW5wdXQuY29sbGVjdGlvbik7XG4gICAgICAgIGRhdGF2MiA9IHsgLi4uZGF0YXYyLCBjb2xsZWN0aW9uIH07XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGlzTXV0YWJsZSA9IGlucHV0LmlzTXV0YWJsZSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGlucHV0LmlzTXV0YWJsZTtcblxuICAgICAgZGVidWdMb2coJyMgaW5wdXQ6ICcsIGlucHV0KTtcbiAgICAgIGRlYnVnTG9nKCcjIHNlbGxlckZlZUJhc2lzUG9pbnRzOiAnLCBzZWxsZXJGZWVCYXNpc1BvaW50cyk7XG4gICAgICBkZWJ1Z0xvZygnIyBkYXRhdjI6ICcsIGRhdGF2Mik7XG5cbiAgICAgIGNvbnN0IG1pbnQgPSBLZXlwYWlyQWNjb3VudC5jcmVhdGUoKTtcblxuICAgICAgY29uc3QgaW5zdHMgPSBhd2FpdCBjcmVhdGVNaW50SW5zdHJ1Y3Rpb25zKFxuICAgICAgICBtaW50LnRvUHVibGljS2V5KCksXG4gICAgICAgIG93bmVyLnRvUHVibGljS2V5KCksXG4gICAgICAgIGRhdGF2MixcbiAgICAgICAgcGF5ZXIudG9LZXlwYWlyKCkucHVibGljS2V5LFxuICAgICAgICBpc011dGFibGUsXG4gICAgICApO1xuXG4gICAgICAvLyBmcmVlemVBdXRob3JpdHlcbiAgICAgIGlmIChmcmVlemVBdXRob3JpdHkpIHtcbiAgICAgICAgaW5zdHMucHVzaChcbiAgICAgICAgICBjcmVhdGVEZWxlYWdhdGVJbnN0cnVjdGlvbihcbiAgICAgICAgICAgIG1pbnQudG9QdWJsaWNLZXkoKSxcbiAgICAgICAgICAgIG93bmVyLnRvUHVibGljS2V5KCksXG4gICAgICAgICAgICBmcmVlemVBdXRob3JpdHkudG9QdWJsaWNLZXkoKSxcbiAgICAgICAgICApLFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IE1pbnRJbnN0cnVjdGlvbihcbiAgICAgICAgaW5zdHMsXG4gICAgICAgIFtzaWduZXIudG9LZXlwYWlyKCksIG1pbnQudG9LZXlwYWlyKCldLFxuICAgICAgICBwYXllci50b0tleXBhaXIoKSxcbiAgICAgICAgbWludC5wdWJrZXksXG4gICAgICApO1xuICAgIH0pO1xuICB9O1xufVxuIiwgImltcG9ydCB7XG4gIFBhcnRpYWxTaWduSW5zdHJ1Y3Rpb24sXG4gIFB1YmtleSxcbiAgUmVzdWx0LFxuICBTZWNyZXQsXG59IGZyb20gJ0Bzb2xhbmEtc3VpdGUvc2hhcmVkJztcbmltcG9ydCB7IFNwbFRva2VuIH0gZnJvbSAnQHNvbGFuYS1zdWl0ZS9jb3JlJztcblxuZXhwb3J0IG5hbWVzcGFjZSBNZXRhcGxleCB7XG4gIGNvbnN0IE5GVF9BTU9VTlQgPSAxO1xuICBjb25zdCBORlRfREVDSU1BTFMgPSAwO1xuXG4gIGV4cG9ydCBjb25zdCBmZWVQYXllclBhcnRpYWxTaWduVHJhbnNmZXJOZnQgPSBhc3luYyAoXG4gICAgbWludDogUHVia2V5LFxuICAgIG93bmVyOiBQdWJrZXksXG4gICAgZGVzdDogUHVia2V5LFxuICAgIHNpZ25lcnM6IFNlY3JldFtdLFxuICAgIGZlZVBheWVyOiBQdWJrZXlcbiAgKTogUHJvbWlzZTxSZXN1bHQ8UGFydGlhbFNpZ25JbnN0cnVjdGlvbiwgRXJyb3I+PiA9PiB7XG4gICAgcmV0dXJuIFNwbFRva2VuLmZlZVBheWVyUGFydGlhbFNpZ25UcmFuc2ZlcihcbiAgICAgIG1pbnQsXG4gICAgICBvd25lcixcbiAgICAgIGRlc3QsXG4gICAgICBzaWduZXJzLFxuICAgICAgTkZUX0FNT1VOVCxcbiAgICAgIE5GVF9ERUNJTUFMUyxcbiAgICAgIGZlZVBheWVyXG4gICAgKTtcbiAgfTtcbn1cbiIsICJpbXBvcnQge1xuICBJbnN0cnVjdGlvbixcbiAgS2V5cGFpckFjY291bnQsXG4gIFB1YmtleSxcbiAgUmVzdWx0LFxuICBTZWNyZXQsXG4gIFRyeSxcbn0gZnJvbSAnQHNvbGFuYS1zdWl0ZS9zaGFyZWQnO1xuaW1wb3J0IHsgUGRhIH0gZnJvbSAnaW50ZXJuYWwvc2hhcmVkLW1ldGFwbGV4JztcbmltcG9ydCB7IGdldEFzc29jaWF0ZWRUb2tlbkFkZHJlc3NTeW5jIH0gZnJvbSAnQHNvbGFuYS9zcGwtdG9rZW4nO1xuaW1wb3J0IHsgY3JlYXRlVGhhd0RlbGVnYXRlZEFjY291bnRJbnN0cnVjdGlvbiB9IGZyb20gJ0BtZXRhcGxleC1mb3VuZGF0aW9uL21wbC10b2tlbi1tZXRhZGF0YSc7XG5cbmV4cG9ydCBuYW1lc3BhY2UgTWV0YXBsZXgge1xuICAvKipcbiAgICogVGhhd2luZyBhIHRhcmdldCBORlRcbiAgICogaXQgc2hvdWxkIHNldCB0byBmcmVlemVBdXRob3JpdHkgd2hlbiBtaW50KClcbiAgICpcbiAgICogQHBhcmFtIHtQdWJrZXl9IG1pbnQgICAgICAgICAgICAgLy8gbWludCBhZGRyZXNzXG4gICAqIEBwYXJhbSB7UHVia2V5fSBvd25lciAgICAgICAgICAgIC8vIGN1cnJlbnQgb3duZXJcbiAgICogQHBhcmFtIHtTZWNyZXR9IGZyZWV6ZUF1dGhvcml0eSAgLy8gc2V0dGVkIGZyZWV6ZSBhdXRob3JpdHkgb2YgbmZ0XG4gICAqIEBwYXJhbSB7U2VjcmV0fSBmZWVQYXllcj8gICAgICAgLy8gZmVlIHBheWVyXG4gICAqL1xuICBleHBvcnQgY29uc3QgdGhhdyA9IChcbiAgICBtaW50OiBQdWJrZXksXG4gICAgb3duZXI6IFB1YmtleSxcbiAgICBmcmVlemVBdXRob3JpdHk6IFNlY3JldCxcbiAgICBmZWVQYXllcj86IFNlY3JldFxuICApOiBSZXN1bHQ8SW5zdHJ1Y3Rpb24sIEVycm9yPiA9PiB7XG4gICAgY29uc3QgcGF5ZXIgPSBmZWVQYXllciA/IGZlZVBheWVyIDogZnJlZXplQXV0aG9yaXR5O1xuICAgIHJldHVybiBUcnkoKCkgPT4ge1xuICAgICAgY29uc3QgdG9rZW5BY2NvdW50ID0gZ2V0QXNzb2NpYXRlZFRva2VuQWRkcmVzc1N5bmMoXG4gICAgICAgIG1pbnQudG9QdWJsaWNLZXkoKSxcbiAgICAgICAgb3duZXIudG9QdWJsaWNLZXkoKVxuICAgICAgKTtcbiAgICAgIGNvbnN0IGVkaXRpb25BZGRyZXNzID0gUGRhLmdldE1hc3RlckVkaXRpb24obWludCk7XG5cbiAgICAgIGNvbnN0IGluc3QgPSBjcmVhdGVUaGF3RGVsZWdhdGVkQWNjb3VudEluc3RydWN0aW9uKHtcbiAgICAgICAgZGVsZWdhdGU6IG5ldyBLZXlwYWlyQWNjb3VudCh7IHNlY3JldDogZnJlZXplQXV0aG9yaXR5IH0pLnRvUHVibGljS2V5KCksXG4gICAgICAgIHRva2VuQWNjb3VudDogdG9rZW5BY2NvdW50LFxuICAgICAgICBlZGl0aW9uOiBlZGl0aW9uQWRkcmVzcyxcbiAgICAgICAgbWludDogbWludC50b1B1YmxpY0tleSgpLFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gbmV3IEluc3RydWN0aW9uKFxuICAgICAgICBbaW5zdF0sXG4gICAgICAgIFtmcmVlemVBdXRob3JpdHkudG9LZXlwYWlyKCldLFxuICAgICAgICBwYXllci50b0tleXBhaXIoKVxuICAgICAgKTtcbiAgICB9KTtcbiAgfTtcbn1cbiIsICJpbXBvcnQgeyBJbnN0cnVjdGlvbiwgUHVia2V5LCBSZXN1bHQsIFNlY3JldCB9IGZyb20gJ0Bzb2xhbmEtc3VpdGUvc2hhcmVkJztcbmltcG9ydCB7IFNwbFRva2VuIH0gZnJvbSAnQHNvbGFuYS1zdWl0ZS9jb3JlJztcblxuZXhwb3J0IG5hbWVzcGFjZSBNZXRhcGxleCB7XG4gIGNvbnN0IE5GVF9BTU9VTlQgPSAxO1xuICBjb25zdCBORlRfREVDSU1BTFMgPSAwO1xuXG4gIGV4cG9ydCBjb25zdCB0cmFuc2ZlciA9IGFzeW5jIChcbiAgICBtaW50OiBQdWJrZXksXG4gICAgb3duZXI6IFB1YmtleSxcbiAgICBkZXN0OiBQdWJrZXksXG4gICAgc2lnbmVyczogU2VjcmV0W10sXG4gICAgZmVlUGF5ZXI/OiBTZWNyZXRcbiAgKTogUHJvbWlzZTxSZXN1bHQ8SW5zdHJ1Y3Rpb24sIEVycm9yPj4gPT4ge1xuICAgIHJldHVybiBTcGxUb2tlbi50cmFuc2ZlcihcbiAgICAgIG1pbnQsXG4gICAgICBvd25lcixcbiAgICAgIGRlc3QsXG4gICAgICBzaWduZXJzLFxuICAgICAgTkZUX0FNT1VOVCxcbiAgICAgIE5GVF9ERUNJTUFMUyxcbiAgICAgIGZlZVBheWVyXG4gICAgKTtcbiAgfTtcbn1cbiIsICJpbXBvcnQgeyBNZXRhcGxleCBhcyBCdXJuIH0gZnJvbSAnLi9idXJuJztcbmltcG9ydCB7IE1ldGFwbGV4IGFzIEZpbmQgfSBmcm9tICcuL2ZpbmQnO1xuaW1wb3J0IHsgTWV0YXBsZXggYXMgRnJlZXplIH0gZnJvbSAnLi9mcmVlemUnO1xuaW1wb3J0IHsgTWV0YXBsZXggYXMgRmVlUGF5ZXIgfSBmcm9tICcuL2ZlZS1wYXllci1wYXJ0aWFsLXNpZ24tbWludCc7XG5pbXBvcnQgeyBNZXRhcGxleCBhcyBGZWVQYXllclRyYW5zZmVyIH0gZnJvbSAnLi9mZWUtcGF5ZXItcGFydGlhbC1zaWduLXRyYW5zZmVyJztcbmltcG9ydCB7IE1ldGFwbGV4IGFzIE1pbnQgfSBmcm9tICcuL21pbnQnO1xuaW1wb3J0IHsgTWV0YXBsZXggYXMgVGhhdyB9IGZyb20gJy4vdGhhdyc7XG5pbXBvcnQgeyBNZXRhcGxleCBhcyBUcmFuc2ZlciB9IGZyb20gJy4vdHJhbnNmZXInO1xuXG5leHBvcnQgY29uc3QgTWV0YXBsZXggPSBPYmplY3QuYXNzaWduKFxuICB7fSxcbiAgQnVybixcbiAgRmluZCxcbiAgRnJlZXplLFxuICBGZWVQYXllcixcbiAgRmVlUGF5ZXJUcmFuc2ZlcixcbiAgTWludCxcbiAgVGhhdyxcbiAgVHJhbnNmZXIsXG4pO1xuIl0sCiAgIm1hcHBpbmdzIjogIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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QUFDbEIsVUFBRSxDQUFDLEtBQUssRUFBRSxDQUFDLE1BQU07QUFDakIsVUFBRSxDQUFDLEtBQUs7QUFFUixVQUFFLENBQUMsS0FBSyxFQUFFLENBQUMsSUFBSSxFQUFFLENBQUM7QUFDbEIsVUFBRSxDQUFDLEtBQUssRUFBRSxDQUFDLE1BQU07QUFDakIsVUFBRSxDQUFDLEtBQUs7QUFFUixVQUFFLENBQUMsS0FBSyxFQUFFLENBQUMsSUFBSSxFQUFFLENBQUM7QUFDbEIsVUFBRSxDQUFDLEtBQUssRUFBRSxDQUFDLE1BQU07QUFDakIsVUFBRSxDQUFDLEtBQUs7QUFFUixVQUFFLENBQUMsS0FBSyxFQUFFLENBQUMsSUFBSSxFQUFFLENBQUM7QUFDbEIsVUFBRSxDQUFDLEtBQUssRUFBRSxDQUFDLE1BQU07QUFDakIsVUFBRSxDQUFDLEtBQUs7QUFFUixVQUFFLENBQUMsS0FBSyxFQUFFLENBQUMsSUFBSSxFQUFFLENBQUM7QUFDbEIsVUFBRSxDQUFDLEtBQUssRUFBRSxDQUFDLE1BQU07QUFDakIsVUFBRSxDQUFDLEtBQUs7QUFFUixVQUFFLENBQUMsS0FBTSxFQUFFLENBQUMsSUFBSSxFQUFFLENBQUMsSUFBTSxFQUFFLENBQUMsSUFBSSxFQUFFLENBQUMsSUFBTSxFQUFFLENBQUMsSUFBSSxFQUFFLENBQUMsSUFBTSxFQUFFLENBQUMsSUFBSSxFQUFFLENBQUM7QUFDbkUsVUFBRSxDQUFDLEtBQUs7QUFFUixlQUFPLENBQUUsRUFBRSxDQUFDLEtBQUssS0FBTSxFQUFFLENBQUMsR0FBSSxFQUFFLENBQUMsS0FBSyxLQUFNLEVBQUUsQ0FBQyxDQUFDO0FBQUEsTUFDcEQ7QUFFQSxlQUFTLFNBQVMsR0FBRyxHQUFHO0FBT3BCLGFBQUs7QUFFTCxZQUFJLE1BQU0sSUFBSTtBQUNWLGlCQUFPLENBQUMsRUFBRSxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUM7QUFBQSxRQUN0QixXQUFXLElBQUksSUFBSTtBQUNmLGlCQUFPLENBQUUsRUFBRSxDQUFDLEtBQUssSUFBTSxFQUFFLENBQUMsTUFBTyxLQUFL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QUFHLEVBQUUsQ0FBQztBQUFBLFVBRTFELEtBQUs7QUFDRCxpQkFBSyxRQUFRLElBQUksY0FBYyxDQUFDLEdBQUcsTUFBTSxJQUFJLEVBQUUsQ0FBQyxHQUFHLEVBQUUsQ0FBQztBQUFBLFVBRTFELEtBQUs7QUFDRCxpQkFBSyxRQUFRLElBQUksY0FBYyxDQUFDLEdBQUcsTUFBTSxJQUFJLEVBQUUsQ0FBQyxHQUFHLEVBQUUsQ0FBQztBQUFBLFVBRTFELEtBQUs7QUFDRCxpQkFBSyxRQUFRLElBQUksY0FBYyxDQUFDLEdBQUcsTUFBTSxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUFBLFVBRXhELEtBQUs7QUFDRCxpQkFBSyxRQUFRLElBQUksQ0FBQyxHQUFHLE1BQU0sSUFBSSxDQUFDLENBQUMsQ0FBQztBQUNsQyxpQkFBSyxhQUFhLElBQUksRUFBRTtBQUN4QixpQkFBSyxTQUFTLElBQUksRUFBRTtBQUNwQixpQkFBSyxhQUFhLElBQUksRUFBRTtBQUN4QixpQkFBSyxRQUFRLElBQUksRUFBRTtBQUFBLFVBRXZCLEtBQUs7QUFDRCxpQkFBSyxRQUFRLElBQUksY0FBYyxDQUFDLEdBQUcsTUFBTSxJQUFJLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztBQUFBLFVBRXpELEtBQUs7QUFDRCxpQkFBSyxRQUFRLElBQUksY0FBYyxDQUFDLEdBQUcsTUFBTSxJQUFJLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztBQUFBLFVBRXpELEtBQUs7QUFDRCxpQkFBSyxRQUFRLElBQUksY0FBYyxDQUFDLEdBQUcsTUFBTSxJQUFJLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztBQUFBLFVBRXpELEtBQUs7QUFDRCxpQkFBSyxRQUFRLElBQUksY0FBYyxDQUFDLEdBQUcsTUFBTSxJQUFJLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztBQUFBLFVBRXpELEtBQUs7QUFDRCxpQkFBSyxRQUFRLElBQUksY0FBYyxDQUFDLEdBQUcsTUFBTSxJQUFJLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztBQUFBLFVBRXpE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QUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxF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QUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxNQUFNO0FBQUEsRUFDTixTQUFTO0FBQUEsRUFDVCxPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxTQUFTO0FBQUEsRUFDVCxTQUFTO0FBQUEsRUFDVCxPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxTQUFTO0FBQUEsRUFDVCxNQUFNO0FBQUEsRUFDTixPQUFPO0FBQUEsRUFDUCxRQUFRO0FBQUEsRUFDUixPQUFPO0FBQUEsRUFDUCxTQUFTO0FBQUEsRUFDVCxVQUFVO0FBQUEsRUFDVixVQUFVO0FBQUEsRUFDVixPQUFPO0FBQUEsRUFDUCxXQUFXO0FBQUEsRUFDWCxPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxRQUFRO0FBQUEsRUFDUixlQUFlO0FBQUEsRUFDZixPQUFPO0FBQUEsRUFDUCxRQUFRO0FBQUEsRUFDUixNQUFNO0FBQUEsRUFDTixNQUFNO0FBQUEsRUFDTixNQUFNO0FBQUEsRUFDTixVQUFVO0FBQUEsRUFDVixRQUFRO0FBQUEsRUFDUixTQUFTO0FBQUEsRUFDVCxZQUFZO0FBQUEsRUFDWixTQUFTO0FBQUEsRUFDVCxRQUFRO0FBQUEsRUFDUixRQUFRO0FBQUEsRUFDUixRQUFRO0FBQUEsRUFDUixRQUFRO0FBQUEsRUFDUixPQUFPO0FBQUEsRUFDUCxRQUFRO0FBQUEsRUFDUixRQUFRO0FBQUEsRUFDUixPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxNQUFNO0FBQUEsRUFDTixNQUFNO0FBQUEsRUFDTixPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxNQUFNO0FBQUEsRUFDTixRQUFRO0FBQUEsRUFDUixTQUFTO0FBQUEsRUFDVCxPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxRQUFRO0FBQUEsRUFDUixPQUFPO0FBQUEsRUFDUCxVQUFVO0FBQUEsRUFDVixPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxVQUFVO0FBQUEsRUFDVixPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxTQUFTO0FBQUEsRUFDVCxVQUFVO0FBQUEsRUFDVixXQUFXO0FBQUEsRUFDWCxVQUFVO0FBQUEsRUFDVixVQUFVO0FBQUEsRUFDVixRQUFRO0FBQUEsRUFDUixRQUFRO0FBQUEsRUFDUixPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxNQUFNO0FBQUEsRUFDTixNQUFNO0FBQUEsRUFDTixPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxXQUFXO0FBQUEsRUFDWCxPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxNQUFNO0FBQUEsRUFDTixPQUFPO0FBQUEsRUFDUCxNQUFNO0FBQUEsRUFDTixTQUFTO0FBQUEsRUFDVCxPQUFPO0FBQUEsRUFDUCxXQUFXO0FBQUEsRUFDWCxRQUFRO0FBQUEsRUFDUixPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxNQUFNO0FBQUEsRUFDTixPQUFPO0FBQUEsRUFDUCxNQUFNO0FBQUEsRUFDTixRQUFRO0FBQUEsRUFDUixPQUFPO0FBQUEsRUFDUCxRQUFRO0FBQUEsRUFDUixPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxRQUFRO0FBQUEsRUFDUixPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxVQUFVO0FBQUEsRUFDVixXQUFXO0FBQUEsRUFDWCxVQUFVO0FBQUEsRUFDVixVQUFVO0FBQUEsRUFDVixPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxTQUFTO0FBQUEsRUFDVCxPQUFPO0FBQUEsRUFDUCxRQUFRO0FBQUEsRUFDUixNQUFNO0FBQUEsRUFDTixPQUFPO0FBQUEsRUFDUCxRQUFRO0FBQUEsRUFDUixTQUFTO0FBQUEsRUFDVCxPQUFPO0FBQUEsRUFDUCxRQUFRO0FBQUEsRUFDUixRQUFRO0FBQUEsRUFDUixXQUFXO0FBQUEsRUFDWCxPQUFPO0FBQUEsRUFDUCxhQUFhO0FBQUEsRUFDYixPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxRQUFRO0FBQUEsRUFDUixRQUFRO0FBQUEsRUFDUixRQUFRO0FBQUEsRUFDUixPQUFPO0FBQUEsRUFDUCxVQUFVO0FBQUEsRUFDVixNQUFNO0FBQUEsRUFDTixRQUFRO0FBQUEsRUFDUixRQUFRO0FBQUEsRUFDUixPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxRQUFRO0FBQUEsRUFDUixZQUFZO0FBQUEsRUFDWixRQUFRO0FBQUEsRUFDUixPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxRQUFRO0FBQUEsRUFDUixTQUFTO0FBQUEsRUFDVCxPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxRQUFRO0FBQUEsRUFDUixRQUFRO0FBQUEsRUFDUixRQUFRO0FBQUEsRUFDUixTQUFTO0FBQUEsRUFDVCxRQUFRO0FBQUEsRUFDUixPQUFPO0FBQUEsRUFDUCxRQUFRO0FBQUEsRUFDUixPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxRQUFRO0FBQUEsRUFDUixPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxNQUFNO0FBQUEsRUFDTixPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxRQUFRO0FBQUEsRUFDUixPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxRQUFRO0FBQUEsRUFDUixPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxRQUFRO0FBQUEsRUFDUixRQUFRO0FBQUEsRUFDUixPQUFPO0FBQUEsRUFDUCxRQUFRO0FBQUEsRUFDUixPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxRQUFRO0FBQUEsRUFDUixPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxRQUFRO0FBQUEsRUFDUixNQUFNO0FBQUEsRUFDTixPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxRQUFRO0FBQUEsRUFDUixTQUFTO0FBQUEsRUFDVCxPQUFPO0FBQUEsRUFDUCxRQUFRO0FBQUEsRUFDUixRQUFRO0FBQUEsRUFDUixPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxRQUFRO0FBQUEsRUFDUixPQUFPO0FBQUEsRUFDUCxRQUFRO0FBQUEsRUFDUixNQUFNO0FBQUEsRUFDTixPQUFPO0FBQUEsRUFDUCxRQUFRO0FBQUEsRUFDUixTQUFTO0FBQUEsRUFDVCxRQUFRO0FBQUEsRUFDUixTQUFTO0FBQUEsRUFDVCxRQUFRO0FBQUEsRUFDUixRQUFRO0FBQUEsRUFDUixPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxRQUFRO0FBQUEsRUFDUixRQUFRO0FBQUEsRUFDUixPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxRQUFRO0FBQUEsRUFDUixRQUFRO0FBQUEsRUFDUixPQUFPO0FBQUEsRUFDUCxRQUFRO0FBQUEsRUFDUixRQUFRO0FBQUEsRUFDUixRQUFRO0FBQUEsRUFDUixPQUFPO0FBQUEsRUFDUCxRQUFRO0FBQUEsRUFDUixPQUFPO0FBQUEsRUFDUCxRQUFRO0FBQUEsRUFDUixPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxRQUFRO0FBQUEsRUFDUixPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxRQUFRO0FBQUEsRUFDUixPQUFPO0FBQUEsRUFDUCxRQUFRO0FBQUEsRUFDUixPQUFPO0FBQUEsRUFDUCw0QkFBNEI7QUFBQSxFQUM1QixTQUFTO0FBQUEsRUFDVCxTQUFTO0FBQUEsRUFDVCxTQUFTO0FBQUEsRUFDVCxTQUFTO0FBQUEsRUFDVCxPQUFPO0FBQUEsRUFDUCxRQUFRO0FBQUEsRUFDUixPQUFPO0FBQUEsRUFDUCxRQUFRO0FBQUEsRUFDUixPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxRQUFRO0FBQUEsRUFDUixPQUFPO0FBQUEsRUFDUCxRQUFRO0FBQUEsRUFDUixRQUFRO0FBQUEsRUFDUixPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxRQUFRO0FBQUEsRUFDUixTQUFTO0FBQUEsRUFDVCxPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxRQUFRO0FBQUEsRUFDUixRQUFRO0FBQUEsRUFDUixTQUFTO0FBQUEsRUFDVCxRQUFRO0FBQUEsRUFDUixTQUFTO0FBQUEsRUFDVCxPQUFPO0FBQUEsRUFDUCxRQUFRO0FBQUEsRUFDUixZQUFZO0FBQUEsRUFDWixZQUFZO0FBQUEsRUFDWixPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxVQUFVO0FBQUEsRUFDVixhQUFhO0FBQUEsRUFDYixPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxRQUFRO0FBQUEsRUFDUixPQUFPO0FBQUEsRUFDUCxTQUFTO0FBQUEsRUFDVCxRQUFRO0FBQUEsRUFDUixPQUFPO0FBQUEsRUFDUCxRQUFRO0FBQUEsRUFDUixZQUFZO0FBQUEsRUFDWixNQUFNO0FBQUEsRUFDTixPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxNQUFNO0FBQUEsRUFDTixPQUFPO0FBQUEsRUFDUCxRQUFRO0FBQUEsRUFDUixRQUFRO0FBQUEsRUFDUixPQUFPO0FBQUEsRUFDUCxRQUFRO0FBQUEsRUFDUixPQUFPO0FBQUEsRUFDUCxNQUFNO0FBQUEsRUFDTixPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxRQUFRO0FBQUEsRUFDUixPQUFPO0FBQUEsRUFDUCxRQUFRO0FBQUEsRUFDUixRQUFRO0FBQUEsRUFDUixPQUFPO0FBQUEsRUFDUCxRQUFRO0FBQUEsRUFDUixVQUFVO0FBQUEsRUFDVixRQUFRO0FBQUEsRUFDUixPQUFPO0FBQUEsRUFDUCxLQUFLO0FBQUEsRUFDTCxNQUFNO0FBQUEsRUFDTixRQUFRO0FBQUEsRUFDUixPQUFPO0FBQUEsRUFDUCxNQUFNO0FBQUEsRUFDTixNQUFNO0FBQUEsRUFDTixPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxRQUFRO0FBQUEsRUFDUixRQUFRO0FBQUEsRUFDUixTQUFTO0FBQUEsRUFDVCxPQUFPO0FBQUEsRUFDUCxRQUFRO0FBQUEsRUFDUixPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxRQUFRO0FBQUEsRUFDUixRQUFRO0FBQUEsRUFDUixRQUFRO0FBQUEsRUFDUixPQUFPO0FBQUEsRUFDUCxRQUFRO0FBQUEsRUFDUixRQUFRO0FBQUEsRUFDUixPQUFPO0FBQUEsRUFDUCxRQUFRO0FBQUEsRUFDUixNQUFN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QUFlRjtBQUFBLFFBQ25CLEtBQUssWUFBWTtBQUFBLFFBQ2pCLE1BQU0sWUFBWTtBQUFBLE1BQ3BCO0FBQ0EsWUFBTSxpQkFBaUIsSUFBSSxpQkFBaUIsSUFBSTtBQUVoRCxZQUFNLE9BQU8sc0NBQXNDO0FBQUEsUUFDakQsVUFBVSxJQUFJRyxnQkFBZSxFQUFFLFFBQVEsZ0JBQWdCLENBQUMsRUFBRSxZQUFZO0FBQUEsUUFDdEU7QUFBQSxRQUNBLFNBQVM7QUFBQSxRQUNULE1BQU0sS0FBSyxZQUFZO0FBQUEsTUFDekIsQ0FBQztBQUNELGFBQU8sSUFBSUM7QUFBQSxRQUNULENBQUMsSUFBSTtBQUFBLFFBQ0wsQ0FBQyxnQkFBZ0IsVUFBVSxDQUFDO0FBQUEsUUFDNUIsTUFBTSxVQUFVO0FBQUEsTUFDbEI7QUFBQSxJQUNGLENBQUM7QUFBQSxFQUNIO0FBQUEsR0FwQ2VILDBCQUFBOzs7QUNYakIsU0FBUyxZQUFBSSxpQkFBZ0I7QUFFbEIsSUFBVUM7QUFBQSxDQUFWLENBQVVBLGVBQVY7QUFDTCxRQUFNQyxjQUFhO0FBQ25CLFFBQU0sZUFBZTtBQUVkLEVBQU1ELFdBQUEsV0FBVyxDQUN0QixNQUNBLE9BQ0EsTUFDQSxTQUNBLGFBQ3dDO0FBQ3hDLFdBQU9FLFVBQVM7QUFBQSxNQUNkO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQUQ7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLElBQ0Y7QUFBQSxFQUNGO0FBQUEsR0FwQmVELDBCQUFBOzs7QUNNVixJQUFNRyxZQUFXLE9BQU87QUFBQSxFQUM3QixDQUFDO0FBQUEsRUFDRDtBQUFBLEVBQ0FBO0FBQUEsRUFDQUE7QUFBQSxFQUNBQTtBQUFBLEVBQ0FBO0FBQUEsRUFDQUE7QUFBQSxFQUNBQTtBQUFBLEVBQ0FBO0FBQ0Y7IiwKICAibmFtZXMiOiBbImV4cG9ydHMiLCAibW9kdWxlIiwgInNlbGYiLCAiZXhwb3J0cyIsICJvcmlnaW5hbCIsICJyZXF1aXJlX3JldHJ5IiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgIkFib3J0RXJyb3IiLCAicFJldHJ5IiwgImVycm9yIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImVuY29kZSIsICJNU0IiLCAiUkVTVCIsICJNU0JBTEwiLCAiSU5UIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgInJlYWQiLCAiTVNCIiwgIlJFU1QiLCAiYnVmIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgIk4xIiwgIk4yIiwgIk4zIiwgIk40IiwgIk41IiwgIk42IiwgIk43IiwgIk44IiwgIk45IiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImxhc3QiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAiaXNJdGVyYWJsZSIsICJwaXBlIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImJhdGNoIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImJhdGNoIiwgInBhcmFsbGVsQmF0Y2giLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAibmFtZSIsICJnbG9iYWxUaGlzIiwgImNsb25lIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgInVuZGVmaW5lZCIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJjb2RlIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgInBhcmFtcyIsICJvZmZzZXQiLCAiZXhwb3J0cyIsICJiYXNlNjQiLCAibGVuZ3RoIiwgInN0cmluZyIsICJlbmNvZGUiLCAiYnVmZmVyIiwgImkiLCAiZGVjb2RlIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImJ1ZiIsICJleHBvcnRzIiwgInN0cmluZyIsICJidWZmZXIiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAiYWxsb2MiLCAic2xpY2UiLCAic2l6ZSIsICJidWYiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAiZnJvbSIsICJsZW5ndGgiLCAiZXhwb3J0cyIsICJpc09iamVjdCIsICJCdWZmZXIiLCAic3JjIiwgIm5hbWUiLCAidG9TdHJpbmciLCAiaSIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJiYXNlNjQiLCAibm9vcCIsICJjcmVhdGUiLCAiYWxsb2MiLCAiYnVmIiwgIndyaXRlQnl0ZXMiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAiYnVmIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImJ1ZmZlciIsICJjcmVhdGVfYXJyYXkiLCAiY3JlYXRlIiwgImJ1ZiIsICJsZW5ndGgiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAiYnVmZmVyIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgInNlbGYiLCAiZXJyIiwgImV4cG9ydHMiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAiZXhwb3J0cyIsICJyZXF1aXJlX21pbmltYWwiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAiYWxsIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgIkJ1ZmZlciIsICJCdWZmZXJMaXN0IiwgImJ1ZiIsICJnZXQiLCAic2xpY2UiLCAiY29weSIsICJ0b1N0cmluZyIsICJtIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImJ1ZiIsICJleHBvcnRzIiwgImJ1ZmZlciIsICJsZW5ndGgiLCAibGFzdCIsICJhbGxvYyIsICJidWYiLCAiVHlwZSIsICJtb2R1bGUiLCAibmFtZSIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJmcyIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJjcmVhdGUiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAibGFzdCIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJiYXNlIiwgIm5hbWUiLCAiZW5jb2RlIiwgImxlbmd0aCIsICJpIiwgImoiLCAiZGVjb2RlIiwgInN0cmluZyIsICJidWZmZXIiLCAic3JjIiwgIl9icnJwX19tdWx0aWZvcm1hdHNfc2NvcGVfYmFzZVgiLCAiZXhwb3J0cyIsICJlbXB0eSIsICJ0b0hleCIsICJmcm9tSGV4IiwgImVxdWFscyIsICJjb2VyY2UiLCAiaXNCaW5hcnkiLCAiZnJvbVN0cmluZyIsICJ0b1N0cmluZyIsICJleHBvcnRzIiwgIkVuY29kZXIiLCAibmFtZSIsICJieXRlcyIsICJEZWNvZGVyIiwgImRlY29kZXIiLCAib3IiLCAiQ29tcG9zZWREZWNvZGVyIiwgIkNvZGVjIiwgImZyb20iLCAiZW5jb2RlIiwgImRlY29kZSIsICJiYXNlWCIsICJhbHBoYWJldCIsICJzdHJpbmciLCAiYnVmZmVyIiwgInJmYzQ2NDgiLCAiZXhwb3J0cyIsICJiYXNlIiwgImlkZW50aXR5IiwgImJ1ZiIsICJleHBvcnRzIiwgImJhc2UiLCAiYmFzZTIiLCAiZXhwb3J0cyIsICJiYXNlIiwgImJhc2U4IiwgImV4cG9ydHMiLCAiYmFzZSIsICJiYXNlMTAiLCAiZXhwb3J0cyIsICJiYXNlIiwgImJhc2UxNiIsICJiYXNlMTZ1cHBlciIsICJleHBvcnRzIiwgImJhc2UiLCAiYmFzZTMyIiwgImJhc2UzMnVwcGVyIiwgImJhc2UzMnBhZCIsICJiYXNlMzJwYWR1cHBlciIsICJiYXNlMzJoZXgiLCAiYmFzZTMyaGV4dXBwZXIiLCAiYmFzZTMyaGV4cGFkIiwgImJhc2UzMmhleHBhZHVwcGVyIiwgImJhc2UzMnoiLCAiZXhwb3J0cyIsICJiYXNlIiwgImJhc2UzNiIsICJiYXNlMzZ1cHBlciIsICJleHBvcnRzIiwgImJhc2UiLCAiYmFzZTU4YnRjIiwgImJhc2U1OGZsaWNrciIsICJyZXF1aXJlX2Jhc2U2NCIsICJleHBvcnRzIiwgImJhc2UiLCAiYmFzZTY0IiwgImJhc2U2NHBhZCIsICJiYXNlNjR1cmwiLCAiYmFzZTY0dXJscGFkIiwgImV4cG9ydHMiLCAiYmFzZSIsICJhbHBoYWJldCIsICJhbHBoYWJldEJ5dGVzVG9DaGFycyIsICJhbHBoYWJldENoYXJzVG9CeXRlcyIsICJlbmNvZGUiLCAiZGVjb2RlIiwgImJhc2UyNTZlbW9qaSIsICJyZXF1aXJlX3ZhcmludCIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJlbmNvZGVfMSIsICJlbmNvZGUiLCAiTVNCIiwgIlJFU1QiLCAiTVNCQUxMIiwgIklOVCIsICJkZWNvZGUiLCAicmVhZCIsICJNU0IkMSIsICJSRVNUJDEiLCAiYnVmIiwgIk4xIiwgIk4yIiwgIk4zIiwgIk40IiwgIk41IiwgIk42IiwgIk43IiwgIk44IiwgIk45IiwgImxlbmd0aCIsICJ2YXJpbnQiLCAiX2JycnBfdmFyaW50IiwgInJlcXVpcmVfdmFyaW50IiwgImV4cG9ydHMiLCAiZGVjb2RlIiwgImNvZGUiLCAiZW5jb2RlVG8iLCAiZW5jb2RpbmdMZW5ndGgiLCAiZXhwb3J0cyIsICJ2YXJpbnQiLCAiY3JlYXRlIiwgImNvZGUiLCAiZGlnZXN0IiwgImJ5dGVzIiwgIkRpZ2VzdCIsICJkZWNvZGUiLCAiZXF1YWxzIiwgImV4cG9ydHMiLCAiZGlnZXN0IiwgImZyb20iLCAibmFtZSIsICJjb2RlIiwgImVuY29kZSIsICJIYXNoZXIiLCAiZXhwb3J0cyIsICJjcnlwdG8iLCAic2hhMjU2IiwgInNoYTUxMiIsICJyZXF1aXJlX2lkZW50aXR5IiwgImV4cG9ydHMiLCAiY29kZSIsICJuYW1lIiwgImVuY29kZSIsICJkaWdlc3QiLCAiaWRlbnRpdHkiLCAiZXhwb3J0cyIsICJuYW1lIiwgImNvZGUiLCAiZW5jb2RlIiwgImRlY29kZSIsICJleHBvcnRzIiwgInRleHRFbmNvZGVyIiwgInRleHREZWNvZGVyIiwgIm5hbWUiLCAiY29kZSIsICJlbmNvZGUiLCAiZGVjb2RlIiwgImV4cG9ydHMiLCAidmFyaW50IiwgImRpZ2VzdCIsICJiYXNlMzIiLCAiQ0lEIiwgInZlcnNpb24iLCAiY29kZSIsICJieXRlcyIsICJoaWRkZW4iLCAicmVhZG9ubHkiLCAiREFHX1BCX0NPREUiLCAiU0hBXzI1Nl9DT0RFIiwgImJhc2UiLCAidG9TdHJpbmdWMCIsICJ0b1N0cmluZ1YxIiwgImRlcHJlY2F0ZSIsICJJU19DSURfREVQUkVDQVRJT04iLCAiY2lkU3ltYm9sIiwgImVuY29kZUNJRCIsICJsZW5ndGgiLCAicGFyc2VDSUR0b0J5dGVzIiwgImRlY29kZXIiLCAiY2lkIiwgInJlcXVpcmVfc3JjIiwgImV4cG9ydHMiLCAidmFyaW50IiwgImRpZ2VzdCIsICJleHBvcnRzIiwgImlkZW50aXR5IiwgImJhc2UyIiwgImJhc2U4IiwgImJhc2UxMCIsICJiYXNlMTYiLCAiYmFzZTMyIiwgImJhc2UzNiIsICJiYXNlNjQiLCAiYmFzZTI1NmVtb2ppIiwgImRpZ2VzdCIsICJ2YXJpbnQiLCAiYmFzZXMiLCAiaGFzaGVzIiwgImV4cG9ydHMiLCAiYXNVaW50OEFycmF5IiwgImJ1ZiIsICJleHBvcnRzIiwgImFsbG9jIiwgImFsbG9jVW5zYWZlIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImFsbG9jIiwgImNyZWF0ZUNvZGVjIiwgIm5hbWUiLCAiZW5jb2RlIiwgImRlY29kZSIsICJzdHJpbmciLCAiYnVmIiwgImRlY29kZXIiLCAiZW5jb2RlciIsICJhc2NpaSIsICJCQVNFUyIsICJleHBvcnRzIiwgImJhc2VzIiwgImZyb21TdHJpbmciLCAic3RyaW5nIiwgImJhc2UiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAiQnVja2V0IiwgIm1hcCIsICJyZWR1Y2UiLCAiYWNjIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImxlbmd0aCIsICJleHBvcnRzIiwgImFsbG9jIiwgImNvbmNhdCIsICJsZW5ndGgiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAiYnVmZmVyIiwgInJlcXVpcmVfc3JjIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgIkJ1Y2tldCIsICJjcmVhdGVIQU1UIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImJsb2JUb0l0IiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgIm1hcCIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJkcmFpbiIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJmaWx0ZXIiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAidGFrZSIsICJ0aHJvdHRsZWRRdWV1ZSIsICJfYSIsICJtb2R1bGUiLCAiZXhwb3J0cyIsICJkYXRhVXJpVG9CdWZmZXIiLCAiYmFzZTY0IiwgImJ1ZmZlciIsICJtb2R1bGUiLCAibm9vcCIsICJuYW1lIiwgIl9hIiwgInNyYyIsICJidWZmZXIiLCAibGVuZ3RoIiwgInNsaWNlIiwgInN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24iLCAiZGVmYXVsdENvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uIiwgIkRPTUV4Y2VwdGlvbiIsICJmbHVzaCIsICJ0cmFuc2Zvcm0iLCAicmVhZGFibGVIaWdoV2F0ZXJNYXJrIiwgIlNpbXBsZVF1ZXVlIiwgIlN5bWJvbCIsICJSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIiLCAiUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9ySW1wbCIsICJSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0IiwgIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIiLCAiUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyIiwgIldyaXRhYmxlU3RyZWFtIiwgIldyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlciIsICJXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyIiwgIlJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIiLCAiUmVhZGFibGVTdHJlYW0iLCAiQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneSIsICJDb3VudFF1ZXVpbmdTdHJhdGVneSIsICJUcmFuc2Zvcm1TdHJlYW0iLCAiVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAiaXNPYmplY3QiLCAidHlwZXMiLCAiRXZlbnRUYXJnZXQiLCAiZGVmaW5lRXZlbnRBdHRyaWJ1dGUiLCAiQWJvcnRDb250cm9sbGVyIiwgIk1ldGFwbGV4IiwgIk5GVF9BTU9VTlQiLCAiY29udmVydFRpbWVzdGFtcFRvRGF0ZVRpbWUiLCAiQ29udmVydCIsICJDb2xsZWN0aW9uIiwgIkNyZWF0b3JzIiwgIlVzZXMiLCAiVG9rZW5NZXRhZGF0YSIsICJOZnRNZXRhZGF0YSIsICJQcm9wZXJ0aWVzIiwgIl9fYXN5bmMiLCAiX19zcHJlYWRQcm9wcyIsICJfX3NwcmVhZFZhbHVlcyIsICJVc2VyU2lkZUlucHV0IiwgIlRva2VuU3RhbmRhcmQiLCAiX1NoYXJlZCIsICJVc2VNZXRob2QiLCAiUGRhIiwgIlJveWFsdHkiLCAiVmFsaWRhdG9yIiwgIk1lc3NhZ2UiLCAibmFtZSIsICJTcGxUb2tlbiIsICJNZXRhcGxleCIsICJTcGxUb2tlbiIsICJUcnkiLCAiTWV0YXBsZXgiLCAiVHJ5IiwgImRlYnVnTG9nIiwgIktleXBhaXJBY2NvdW50IiwgIk5vZGUiLCAiVHJ5IiwgIlRyeSIsICJpbXBvcnRfdmFyaW50IiwgImJ1ZiIsICJkZWNvZGUiLCAiY29kZSIsICJjb2RlIiwgImRpZ2VzdCIsICJkZWNvZGUiLCAiZXF1YWxzIiwgIm5hbWUiLCAiZW5jb2RlIiwgImxlbmd0aCIsICJpIiwgImoiLCAiZGVjb2RlIiwgInN0cmluZyIsICJidWZmZXIiLCAibmFtZSIsICJkZWNvZGVyIiwgImVuY29kZSIsICJkZWNvZGUiLCAiYWxwaGFiZXQiLCAic3RyaW5nIiwgImJ1ZmZlciIsICJ2ZXJzaW9uIiwgImNvZGUiLCAiZGlnZXN0IiwgImVxdWFscyIsICJiYXNlIiwgImRlY29kZSIsICJsZW5ndGgiLCAiZGVjb2RlciIsICJjaWQiLCAibmFtZSIsICJpc0J1ZmZlciIsICJidWYiLCAidG9TdHJpbmciLCAiZnJvbVN0cmluZyIsICJzdHJpbmciLCAibGVuZ3RoIiwgImlzQnVmZmVyIiwgInN0cmluZyIsICJsZW5ndGgiLCAiYnVmIiwgImJ1ZiIsICJlbmNvZGVkU2l6ZSIsICJidWYiLCAiZW5jb2RlZFNpemUiLCAiY29tcGFyZVRva2VucyIsICJsZW5ndGgiLCAiYnVmIiwgImZyb21TdHJpbmciLCAiZW5jb2RlZFNpemUiLCAiY29tcGFyZVRva2VucyIsICJ0b1Rva2VuIiwgImxlbmd0aCIsICJ0b1N0cmluZyIsICJ0b1Rva2VuIiwgImxlbmd0aCIsICJidWYiLCAiZW5jb2RlZFNpemUiLCAidG9Ub2tlbiIsICJsZW5ndGgiLCAiYnVmIiwgImVuY29kZWRTaXplIiwgImJ1ZiIsICJlbmNvZGVkU2l6ZSIsICJidWYiLCAiZW5jb2RlZFNpemUiLCAidWk4YSIsICJsZW5ndGgiLCAiYnVmIiwgImVuY29kZXIiLCAiZW5jb2RlIiwgImRlY29kZXIiLCAiZGVjb2RlIiwgImVuY29kZSIsICJkZWNvZGUiLCAidmFyaW50IiwgImxlbmd0aCIsICJkZWNvZGUiLCAiYnl0ZXMiLCAibXVsdGloYXNoIiwgInZlcnNpb24iLCAicmVhZCIsICJ2ZXJzaW9uIiwgImRlY29kZXIiLCAiQ2FyUmVhZGVyIiwgInJlYWQiLCAidmVyc2lvbiIsICJkZWNvZGVyIiwgInZlcnNpb24iLCAiZGVjb2RlciIsICJmcyIsICJwcm9taXNpZnkiLCAiaW1wb3J0X3ZhcmludCIsICJlbmNvZGUiLCAidmFyaW50IiwgImNyZWF0ZSIsICJkcmFpbmVyIiwgImVuY29kZXIiLCAiY3JlYXRlIiwgImZzcmVhZCIsICJwcm9taXNpZnkiLCAiZnMiLCAiQ2FyV3JpdGVyIiwgInJlYWQiLCAiZnJvbSIsICJuYW1lIiwgImNvZGUiLCAiZW5jb2RlIiwgImRpZ2VzdCIsICJyZWFkb25seSIsICJiYXNlIiwgImVuY29kZSIsICJkZWNvZGUiLCAiZW5jb2RlIiwgImVuY29kZSIsICJkZWNvZGUiLCAiY29kZSIsICJkZWNvZGUiLCAiZW5jb2RlIiwgIm5hbWUiLCAiQ0lEX0NCT1JfVEFHIiwgImNpZEVuY29kZXIiLCAidW5kZWZpbmVkRW5jb2RlciIsICJudW1iZXJFbmNvZGVyIiwgImVuY29kZU9wdGlvbnMiLCAiY2lkRGVjb2RlciIsICJkZWNvZGVPcHRpb25zIiwgIm5hbWUiLCAiY29kZSIsICJlbmNvZGUiLCAiZGVjb2RlIiwgImNvZGUiLCAiZGVjb2RlIiwgImVuY29kZSIsICJuYW1lIiwgInRleHREZWNvZGVyIiwgImxpbmtzIiwgInRleHRFbmNvZGVyIiwgInNpemUiLCAiYmFzZSIsICJ0ZXh0RW5jb2RlciIsICJsaW5rcyIsICJuYW1lIiwgIm5hbWUiLCAiY29kZSIsICJlbmNvZGUiLCAiZGVjb2RlIiwgImRlY29kZXIiLCAiQ2FyV3JpdGVyIiwgImNpZCIsICJDYXJSZWFkZXIiLCAiYnVmZmVyIiwgImltcG9ydF9pdF9wYXJhbGxlbF9iYXRjaCIsICJpbXBvcnRfaW5kZXgiLCAibWVyZ2VPcHRpb25zIiwgImZyb20iLCAiZnJvbSIsICJtdXIiLCAiYnVmIiwgIiRwcm90b2J1ZiIsICJEYXRhIiwgImVuY29kZSIsICJkZWNvZGUiLCAiVW5peFRpbWUiLCAiTWV0YWRhdGEiLCAiZXJyY29kZSIsICJidWZmZXIiLCAiYnVmZmVyIiwgImVuY29kZSIsICJpbXBvcnRfZXJyX2NvZGUiLCAicmVkdWNlIiwgImFsbCIsICJyZWR1Y2UiLCAiYmF0Y2giLCAiaW1wb3J0X2l0X2JhdGNoIiwgInJlZHVjZSIsICJiYXRjaCIsICJidWZmZXIiLCAiZW5jb2RlIiwgImJ1ZmZlckltcG9ydGVyIiwgInBhcmFsbGVsQmF0Y2giLCAiYnVmZmVyIiwgImVuY29kZSIsICJsaW5rcyIsICJkYWdCdWlsZGVyIiwgImVyckNvZGUiLCAiaW1wb3J0X2Vycl9jb2RlIiwgImltcG9ydF9lcnJfY29kZSIsICJlcnJjb2RlIiwgIkJ1ZmZlckxpc3QiLCAiYnVmIiwgImltcG9ydF9CdWZmZXJMaXN0IiwgIkJ1ZmZlckxpc3QiLCAiYnVmZmVyIiwgImltcG9ydF9lcnJfY29kZSIsICJidWYiLCAiZW5jb2RlIiwgImRlY29kZSIsICJpZGVudGl0eV9leHBvcnRzIiwgImlkZW50aXR5IiwgImNvZGUiLCAibmFtZSIsICJlbmNvZGUiLCAiaWRlbnRpdHkiLCAidGV4dEVuY29kZXIiLCAidGV4dERlY29kZXIiLCAiaWRlbnRpdHlfZXhwb3J0cyIsICJidWYiLCAibmFtZSIsICJlbmNvZGUiLCAiZGVjb2RlIiwgImJ1ZiIsICJkZWNvZGVyIiwgImVuY29kZXIiLCAic3RyaW5nIiwgImZyb21TdHJpbmciLCAic3RyaW5nIiwgImJhc2UiLCAiZXJyQ29kZSIsICJmcm9tU3RyaW5nIiwgImVyckNvZGUiLCAibmFtZSIsICJkaXJfZGVmYXVsdCIsICJkaXJfZGVmYXVsdCIsICJuYW1lIiwgImxpbmtzIiwgImJ1ZmZlciIsICJlbmNvZGUiLCAiZGlyX2RlZmF1bHQiLCAibmFtZSIsICJsaW5rcyIsICJkaXIiLCAiaXRlciIsICJtb3JlIiwgInRlbXAiLCAiZXJyb3IiLCAic2l6ZSIsICJidWZmZXIiLCAiZW5jb2RlIiwgInRyZWUiLCAibGFzdCIsICJkaXJfZGVmYXVsdCIsICJpdGVyIiwgIm1vcmUiLCAidGVtcCIsICJlcnJvciIsICJkYWdCdWlsZGVyIiwgInRyZWVCdWlsZGVyIiwgInBhcmFsbGVsQmF0Y2giLCAiaW1wb3J0X2Vycl9jb2RlIiwgImltcG9ydF9pdF9hbGwiLCAiYmxvYlRvSXQiLCAiYnJvd3NlclN0cmVhbVRvSXQiLCAiaXRQZWVrYWJsZSIsICJhbGwiLCAibWFwIiwgImVyckNvZGUiLCAiZnJvbVN0cmluZyIsICJpbXBvcnRfZXJyX2NvZGUiLCAiaW1wb3J0X2Jyb3dzZXJfcmVhZGFibGVzdHJlYW1fdG9faXQiLCAiaW1wb3J0X2l0X3BlZWthYmxlIiwgIm5vcm1hbGlzZUNvbnRlbnQiLCAiZXJyQ29kZSIsICJicm93c2VyU3RyZWFtVG9JdCIsICJpdFBlZWthYmxlIiwgImltcG9ydF9lcnJfY29kZSIsICJpbXBvcnRfYnJvd3Nlcl9yZWFkYWJsZXN0cmVhbV90b19pdCIsICJpbXBvcnRfaXRfcGVla2FibGUiLCAiaW1wb3J0X2l0X21hcCIsICJub3JtYWxpc2VDb250ZW50IiwgImVyckNvZGUiLCAiYnJvd3NlclN0cmVhbVRvSXQiLCAiaXRQZWVrYWJsZSIsICJtYXAiLCAidmFsdWUiLCAidG9GaWxlT2JqZWN0IiwgIm5vcm1hbGlzZUlucHV0IiwgImlzQnl0ZXMiLCAiaXNCbG9iIiwgIm5vcm1hbGlzZUlucHV0IiwgImltcG9ydF9lcnJfY29kZSIsICJlcnJDb2RlIiwgImltcG9ydF9pdF9hbGwiLCAiYWxsIiwgImRyYWluIiwgImZpbHRlciIsICJpdCIsICJ0YWtlIiwgImxhc3QiLCAicGlwZSIsICJDYXJXcml0ZXIiLCAiaHR0cCIsICJmcyIsICJCdWZmZXIiLCAiU3RyZWFtIiwgInR5cGVzIiwgIkVuY29kZXIiLCAiRGVjb2RlciIsICJSZWFkYWJsZVN0cmVhbSIsICJSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIiLCAiUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyIiwgIlJlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QiLCAiUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlciIsICJSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyIiwgIlRyYW5zZm9ybVN0cmVhbSIsICJUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlciIsICJXcml0YWJsZVN0cmVhbSIsICJXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIiLCAiV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlciIsICJCeXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5IiwgIkNvdW50UXVldWluZ1N0cmF0ZWd5IiwgInN0cmVhbXMiLCAiRW5jb2RlciIsICJidWZmZXIiLCAiZGVjb2RlciIsICJEZWNvZGVyIiwgIkJsb2IiLCAiUmVhZGFibGVTdHJlYW0iLCAiQmxvYiIsICJCbG9iIiwgIm5hbWUiLCAiRmlsZSIsICJuYW1lIiwgInBhbmljIiwgImlzQmxvYiIsICJGaWxlIiwgIkZvcm1EYXRhIiwgImNvZXJjZSIsICJuYW1lIiwgInRva2VuIiwgImZlZWRDaHVuayIsICJfYSIsICJpdGVyIiwgIm1vcmUiLCAidGVtcCIsICJlcnJvciIsICJpc0Jsb2IiLCAiaXNBYm9ydFNpZ25hbCIsICJpc1JlYWRhYmxlU3RyZWFtIiwgImlzSXRlcmFibGUiLCAibmFtZSIsICJpc0Jsb2IiLCAiZW5jb2RlciIsICJsZW5ndGgiLCAiRm9ybURhdGEiLCAiY29udGVudFR5cGUiLCAiRmlsZSIsICJUZXh0RW5jb2RlciIsICJUZXh0RGVjb2RlciIsICJlbmNvZGUiLCAiZGVjb2RlIiwgIlN0cmVhbSIsICJlbmNvZGUiLCAiZnJvbUJ5dGVzIiwgImlzQmxvYiIsICJ0eXBlcyIsICJpc1JlYWRhYmxlU3RyZWFtIiwgImJ1ZmZlciIsICJidWYiLCAiQmxvYiIsICJkZWNvZGUiLCAiZXJyb3IiLCAiUmVhZGFibGVTdHJlYW0iLCAicHVtcCIsICJ0eXBlcyIsICJuYW1lIiwgImlzSXRlcmFibGUiLCAidHlwZXMiLCAiY29kZSIsICJJTlRFUk5BTFMiLCAiUmVzcG9uc2UiLCAiSU5URVJOQUxTIiwgImlzQWJvcnRTaWduYWwiLCAiQWJvcnRDb250cm9sbGVyUG9seWZpbGwiLCAiU3RyZWFtIiwgImRhdGFVcmlUb0J1ZmZlciIsICJyZXNwb25zZSIsICJSZXNwb25zZSIsICJmcyIsICJodHRwIiwgIlJlYWRhYmxlU3RyZWFtIiwgIkJ1ZmZlciIsICJidWYiLCAiZmV0Y2giLCAiSGVhZGVycyIsICJSZXF1ZXN0IiwgIlJlc3BvbnNlIiwgImZzIiwgImZzIiwgInZlcnNpb24iLCAiVG9rZW4iLCAiX2EiLCAibmFtZSIsICJlbmNvZGUiLCAiaXNPYmplY3QiLCAiaXNCbG9iIiwgIkJsb2IiLCAiaXNPYmplY3QiLCAiaW1wb3J0X2l0X3BpcGUiLCAidGhyb3R0bGVkUXVldWUiLCAiX2EiLCAiQmxvYiIsICJjYXIiLCAiX2IiLCAiaXRlciIsICJtb3JlIiwgInRlbXAiLCAiZXJyb3IiLCAicFJldHJ5IiwgIlRva2VuIiwgInBpcGUiLCAiZmlsZXMiLCAibmFtZSIsICJCbG9iIiwgIkNvbnN0YW50cyIsICJpc05vZGUiLCAiaXNCcm93c2VyIiwgImRlYnVnTG9nIiwgIlRyeSIsICJ0b01ldGFwbGV4RmlsZSIsICJCdW5kbHIiLCAiQXJ3ZWF2ZSIsICJfX2FzeW5jIiwgImJ1ZmZlciIsICJOZnRTdG9yYWdlIiwgIkJsb2IiLCAiU3RvcmFnZSIsICJnZXRBc3NvY2lhdGVkVG9rZW5BZGRyZXNzU3luYyIsICJkZWJ1Z0xvZyIsICJLZXlwYWlyQWNjb3VudCIsICJUcnkiLCAiTm9kZSIsICJNZXRhcGxleCIsICJtaW50IiwgImdldEFzc29jaWF0ZWRUb2tlbkFkZHJlc3NTeW5jIiwgIk5vZGUiLCAiVHJ5IiwgImRlYnVnTG9nIiwgIktleXBhaXJBY2NvdW50IiwgIk1ldGFwbGV4IiwgIlRyeSIsICJkZWJ1Z0xvZyIsICJLZXlwYWlyQWNjb3VudCIsICJOb2RlIiwgInNpZ25lciIsICJTcGxUb2tlbiIsICJNZXRhcGxleCIsICJORlRfQU1PVU5UIiwgIlNwbFRva2VuIiwgIkluc3RydWN0aW9uIiwgIktleXBhaXJBY2NvdW50IiwgIlRyeSIsICJnZXRBc3NvY2lhdGVkVG9rZW5BZGRyZXNzU3luYyIsICJNZXRhcGxleCIsICJUcnkiLCAiS2V5cGFpckFjY291bnQiLCAiSW5zdHJ1Y3Rpb24iLCAiU3BsVG9rZW4iLCAiTWV0YXBsZXgiLCAiTkZUX0FNT1VOVCIsICJTcGxUb2tlbiIsICJNZXRhcGxleCJdCn0K